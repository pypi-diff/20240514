# Comparing `tmp/libqasm-0.6.5-cp39-cp39-win_amd64.whl.zip` & `tmp/libqasm-0.6.6-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,18 @@
-Zip file size: 773284 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat        3 b- defN 24-Apr-24 11:00 cqasm/__init__.py
--rw-rw-rw-  2.0 fat     2850 b- defN 24-Apr-24 11:00 cqasm/v3x/__init__.py
--rw-rw-rw-  2.0 fat   423539 b- defN 24-Apr-24 11:02 cqasm/v3x/ast.py
--rw-rw-rw-  2.0 fat     1219 b- defN 24-Apr-24 11:00 cqasm/v3x/instruction.py
--rw-rw-rw-  2.0 fat     1731 b- defN 24-Apr-24 11:00 cqasm/v3x/primitives.py
--rw-rw-rw-  2.0 fat    88893 b- defN 24-Apr-24 11:02 cqasm/v3x/semantic.py
--rw-rw-rw-  2.0 fat    53029 b- defN 24-Apr-24 11:02 cqasm/v3x/types.py
--rw-rw-rw-  2.0 fat    63394 b- defN 24-Apr-24 11:02 cqasm/v3x/values.py
--rw-rw-rw-  2.0 fat      752 b- defN 24-Apr-24 11:00 libQasm/__init__.py
--rw-rw-rw-  2.0 fat  2286592 b- defN 24-Apr-24 11:03 libQasm/_libQasm.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat    31677 b- defN 24-Apr-24 11:03 libQasm/libQasm.py
--rw-rw-rw-  2.0 fat      579 b- defN 24-Apr-24 11:03 libqasm-0.6.5.dist-info/LICENSE.md
--rw-rw-rw-  2.0 fat     6103 b- defN 24-Apr-24 11:03 libqasm-0.6.5.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 24-Apr-24 11:03 libqasm-0.6.5.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       14 b- defN 24-Apr-24 11:03 libqasm-0.6.5.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1252 b- defN 24-Apr-24 11:03 libqasm-0.6.5.dist-info/RECORD
-16 files, 2961727 bytes uncompressed, 771260 bytes compressed:  74.0%
+Zip file size: 775445 bytes, number of entries: 16
+-rw-rw-rw-  2.0 fat        3 b- defN 24-May-14 13:16 cqasm/__init__.py
+-rw-rw-rw-  2.0 fat     2850 b- defN 24-May-14 13:16 cqasm/v3x/__init__.py
+-rw-rw-rw-  2.0 fat   420170 b- defN 24-May-14 13:18 cqasm/v3x/ast.py
+-rw-rw-rw-  2.0 fat     1219 b- defN 24-May-14 13:16 cqasm/v3x/instruction.py
+-rw-rw-rw-  2.0 fat     1731 b- defN 24-May-14 13:16 cqasm/v3x/primitives.py
+-rw-rw-rw-  2.0 fat    88679 b- defN 24-May-14 13:18 cqasm/v3x/semantic.py
+-rw-rw-rw-  2.0 fat    65070 b- defN 24-May-14 13:18 cqasm/v3x/types.py
+-rw-rw-rw-  2.0 fat    63394 b- defN 24-May-14 13:18 cqasm/v3x/values.py
+-rw-rw-rw-  2.0 fat      752 b- defN 24-May-14 13:16 libqasm/__init__.py
+-rw-rw-rw-  2.0 fat  2291200 b- defN 24-May-14 13:19 libqasm/_libqasm.cp39-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    31677 b- defN 24-May-14 13:19 libqasm/libqasm.py
+-rw-rw-rw-  2.0 fat      579 b- defN 24-May-14 13:19 libqasm-0.6.6.dist-info/LICENSE.md
+-rw-rw-rw-  2.0 fat     6775 b- defN 24-May-14 13:19 libqasm-0.6.6.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 24-May-14 13:19 libqasm-0.6.6.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       14 b- defN 24-May-14 13:19 libqasm-0.6.6.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1252 b- defN 24-May-14 13:19 libqasm-0.6.6.dist-info/RECORD
+16 files, 2975465 bytes uncompressed, 773421 bytes compressed:  74.0%
```

## zipnote {}

```diff
@@ -18,32 +18,32 @@
 
 Filename: cqasm/v3x/types.py
 Comment: 
 
 Filename: cqasm/v3x/values.py
 Comment: 
 
-Filename: libQasm/__init__.py
+Filename: libqasm/__init__.py
 Comment: 
 
-Filename: libQasm/_libQasm.cp39-win_amd64.pyd
+Filename: libqasm/_libqasm.cp39-win_amd64.pyd
 Comment: 
 
-Filename: libQasm/libQasm.py
+Filename: libqasm/libqasm.py
 Comment: 
 
-Filename: libqasm-0.6.5.dist-info/LICENSE.md
+Filename: libqasm-0.6.6.dist-info/LICENSE.md
 Comment: 
 
-Filename: libqasm-0.6.5.dist-info/METADATA
+Filename: libqasm-0.6.6.dist-info/METADATA
 Comment: 
 
-Filename: libqasm-0.6.5.dist-info/WHEEL
+Filename: libqasm-0.6.6.dist-info/WHEEL
 Comment: 
 
-Filename: libqasm-0.6.5.dist-info/top_level.txt
+Filename: libqasm-0.6.6.dist-info/top_level.txt
 Comment: 
 
-Filename: libqasm-0.6.5.dist-info/RECORD
+Filename: libqasm-0.6.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cqasm/v3x/__init__.py

```diff
@@ -1,34 +1,34 @@
 import cqasm.v3x.ast as ast
 import cqasm.v3x.semantic as semantic
-import libQasm
+import libqasm
 
 
-class Analyzer(libQasm.V3xAnalyzer):
+class Analyzer(libqasm.V3xAnalyzer):
     # parse_file and parse_string are static methods because they do not change the status of the analyzer
     # Instead, they just invoke free functions that create a temporary instance of a parser
     # analyze_file and analyze_string are not static methods because they change the status of the analyzer
 
     # parse_file, parse_string, analyze_file, and analyze_string return a vector of strings
     # If the length of the vector is 1, the string is a serialization of the AST
     # Otherwise, it is a list of errors
 
     @staticmethod
     def parse_file(*args):
-        ret = libQasm.V3xAnalyzer.parse_file(*args)
+        ret = libqasm.V3xAnalyzer.parse_file(*args)
         if len(ret) == 1:
             serialized_ast_str = str(ret[0])
             serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
             deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
             return deserialized_ast
         return [str(error) for error in ret[1:]]
 
     @staticmethod
     def parse_string(*args):
-        ret = libQasm.V3xAnalyzer.parse_string(*args)
+        ret = libqasm.V3xAnalyzer.parse_string(*args)
         if len(ret) == 1:
             serialized_ast_str = str(ret[0])
             serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
             deserialized_ast = ast.Root.deserialize(serialized_ast_bytes)
             return deserialized_ast
         return [str(error) for error in ret[1:]]
 
@@ -48,18 +48,18 @@
             serialized_ast_bytes = serialized_ast_str.encode(encoding='utf-8', errors="surrogateescape")
             deserialized_ast = semantic.Program.deserialize(serialized_ast_bytes)
             return deserialized_ast
         return [str(error) for error in ret[1:]]
 
     @staticmethod
     def parse_file_to_json(*args):
-        return libQasm.V3xAnalyzer.parse_file_to_json(*args)
+        return libqasm.V3xAnalyzer.parse_file_to_json(*args)
 
     @staticmethod
     def parse_string_to_json(*args):
-        return libQasm.V3xAnalyzer.parse_string_to_json(*args)
+        return libqasm.V3xAnalyzer.parse_string_to_json(*args)
 
     def analyze_file_to_json(self, *args):
         return super().analyze_file_to_json(*args)
 
     def analyze_string_to_json(self, *args):
         return super().analyze_string_to_json(*args)
```

## cqasm/v3x/ast.py

```diff
@@ -5327,99 +5327,49 @@
     _T = Gate
 
 
 _typemap['Gate'] = Gate
 
 class GlobalBlock(Block):
     __slots__ = [
-        '_attr_qubit_variable_declaration',
-        '_attr_gates',
-        '_attr_measure_instructions',
+        '_attr_statements',
     ]
 
     def __init__(
         self,
-        qubit_variable_declaration=None,
-        gates=None,
-        measure_instructions=None,
+        statements=None,
     ):
         super().__init__()
-        self.qubit_variable_declaration = qubit_variable_declaration
-        self.gates = gates
-        self.measure_instructions = measure_instructions
+        self.statements = statements
 
     @property
-    def qubit_variable_declaration(self):
-        return self._attr_qubit_variable_declaration
+    def statements(self):
+        return self._attr_statements
 
-    @qubit_variable_declaration.setter
-    def qubit_variable_declaration(self, val):
+    @statements.setter
+    def statements(self, val):
         if val is None:
-            del self.qubit_variable_declaration
+            del self.statements
             return
-        if not isinstance(val, Variable):
+        if not isinstance(val, MultiStatement):
             # Try to "typecast" if this isn't an obvious mistake.
             if isinstance(val, Node):
-                raise TypeError('qubit_variable_declaration must be of type Variable')
-            val = Variable(val)
-        self._attr_qubit_variable_declaration = val
-
-    @qubit_variable_declaration.deleter
-    def qubit_variable_declaration(self):
-        self._attr_qubit_variable_declaration = None
-
-    @property
-    def gates(self):
-        return self._attr_gates
-
-    @gates.setter
-    def gates(self, val):
-        if val is None:
-            del self.gates
-            return
-        if not isinstance(val, MultiGate):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('gates must be of type MultiGate')
-            val = MultiGate(val)
-        self._attr_gates = val
-
-    @gates.deleter
-    def gates(self):
-        self._attr_gates = MultiGate()
-
-    @property
-    def measure_instructions(self):
-        return self._attr_measure_instructions
-
-    @measure_instructions.setter
-    def measure_instructions(self, val):
-        if val is None:
-            del self.measure_instructions
-            return
-        if not isinstance(val, MultiMeasureInstruction):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('measure_instructions must be of type MultiMeasureInstruction')
-            val = MultiMeasureInstruction(val)
-        self._attr_measure_instructions = val
-
-    @measure_instructions.deleter
-    def measure_instructions(self):
-        self._attr_measure_instructions = MultiMeasureInstruction()
+                raise TypeError('statements must be of type MultiStatement')
+            val = MultiStatement(val)
+        self._attr_statements = val
+
+    @statements.deleter
+    def statements(self):
+        self._attr_statements = MultiStatement()
 
     def __eq__(self, other):
         """Equality operator. Ignores annotations!"""
         if not isinstance(other, GlobalBlock):
             return False
-        if self.qubit_variable_declaration != other.qubit_variable_declaration:
-            return False
-        if self.gates != other.gates:
-            return False
-        if self.measure_instructions != other.measure_instructions:
+        if self.statements != other.statements:
             return False
         return True
 
     def dump(self, indent=0, annotations=None, links=1):
         """Returns a debug representation of this tree as a multiline string.
         indent is the number of double spaces prefixed before every line.
         annotations, if specified, must be a set-like object containing the key
@@ -5431,37 +5381,20 @@
             annotations = []
         for key in annotations:
             if key in self:
                 s.append(' # {}: {}'.format(key, self[key]))
         s.append('\n')
         indent += 1
         s.append('  '*indent)
-        s.append('qubit_variable_declaration: ')
-        if self.qubit_variable_declaration is None:
-            s.append('!MISSING\n')
-        else:
-            s.append('<\n')
-            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
-        s.append('gates: ')
-        if not self.gates:
-            s.append('-\n')
-        else:
-            s.append('[\n')
-            for child in self.gates:
-                s.append(child.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + ']\n')
-        s.append('  '*indent)
-        s.append('measure_instructions: ')
-        if not self.measure_instructions:
+        s.append('statements: ')
+        if not self.statements:
             s.append('-\n')
         else:
             s.append('[\n')
-            for child in self.measure_instructions:
+            for child in self.statements:
                 s.append(child.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + ']\n')
         indent -= 1
         s.append('  '*indent)
         s.append(')')
         return ''.join(s)
 
@@ -5473,56 +5406,42 @@
         numbers for all nodes in the tree rooted at this node. If id_map is
         specified, found nodes are appended to it."""
         if id_map is None:
             id_map = {}
         if id(self) in id_map:
             raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
         id_map[id(self)] = len(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.find_reachable(id_map)
-        for el in self._attr_gates:
-            el.find_reachable(id_map)
-        for el in self._attr_measure_instructions:
+        for el in self._attr_statements:
             el.find_reachable(id_map)
         return id_map
 
     def check_complete(self, id_map=None):
         """Raises NotWellFormed if the tree rooted at this node is not
         well-formed. If id_map is specified, this tree is only a subtree in the
         context of a larger tree, and id_map must be a dict mapping from Python
         id() codes to tree indices for all reachable nodes."""
         if id_map is None:
             id_map = self.find_reachable()
-        if self._attr_qubit_variable_declaration is None:
-            raise NotWellFormed('qubit_variable_declaration is required but not set')
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.check_complete(id_map)
-        for child in self._attr_gates:
-            child.check_complete(id_map)
-        for child in self._attr_measure_instructions:
+        for child in self._attr_statements:
             child.check_complete(id_map)
 
     def copy(self):
         """Returns a shallow copy of this node."""
         return GlobalBlock(
-            qubit_variable_declaration=self._attr_qubit_variable_declaration,
-            gates=self._attr_gates.copy(),
-            measure_instructions=self._attr_measure_instructions.copy()
+            statements=self._attr_statements.copy()
         )
 
     def clone(self):
         """Returns a deep copy of this node. This mimics the C++ interface,
         deficiencies with links included; that is, links always point to the
         original tree. If you're not cloning a subtree in a context where this
         is the desired behavior, you may want to use the copy.deepcopy() from
         the stdlib instead, which should copy links correctly."""
         return GlobalBlock(
-            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
-            gates=_cloned(self._attr_gates),
-            measure_instructions=_cloned(self._attr_measure_instructions)
+            statements=_cloned(self._attr_statements)
         )
 
     @staticmethod
     def _deserialize(cbor, seq_to_ob, links):
         """Attempts to deserialize the given cbor object (in Python primitive
         representation) into a node of this type. All (sub)nodes are added to
         the seq_to_ob dict, indexed by their cbor sequence number. All links are
@@ -5533,57 +5452,31 @@
             raise TypeError('node description object must be a dict')
         typ = cbor.get('@t', None)
         if typ is None:
             raise ValueError('type (@t) field is missing from node serialization')
         if typ != 'GlobalBlock':
             raise ValueError('found node serialization for ' + typ + ', but expected GlobalBlock')
 
-        # Deserialize the qubit_variable_declaration field.
-        field = cbor.get('qubit_variable_declaration', None)
+        # Deserialize the statements field.
+        field = cbor.get('statements', None)
         if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
-        if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field qubit_variable_declaration')
-        if field.get('@t', None) is None:
-            f_qubit_variable_declaration = None
-        else:
-            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
-
-        # Deserialize the gates field.
-        field = cbor.get('gates', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field gates')
-        if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field gates')
-        data = field.get('@d', None)
-        if not isinstance(data, list):
-            raise ValueError('missing serialization of Any/Many contents')
-        f_gates = MultiGate()
-        for element in data:
-            if element.get('@T') != '1':
-                raise ValueError('unexpected edge type for Any/Many element')
-            f_gates.append(Gate._deserialize(element, seq_to_ob, links))
-
-        # Deserialize the measure_instructions field.
-        field = cbor.get('measure_instructions', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field measure_instructions')
+            raise ValueError('missing or invalid serialization of field statements')
         if field.get('@T') != '*':
-            raise ValueError('unexpected edge type for field measure_instructions')
+            raise ValueError('unexpected edge type for field statements')
         data = field.get('@d', None)
         if not isinstance(data, list):
             raise ValueError('missing serialization of Any/Many contents')
-        f_measure_instructions = MultiMeasureInstruction()
+        f_statements = MultiStatement()
         for element in data:
             if element.get('@T') != '1':
                 raise ValueError('unexpected edge type for Any/Many element')
-            f_measure_instructions.append(MeasureInstruction._deserialize(element, seq_to_ob, links))
+            f_statements.append(Statement._deserialize(element, seq_to_ob, links))
 
         # Construct the GlobalBlock node.
-        node = GlobalBlock(f_qubit_variable_declaration, f_gates, f_measure_instructions)
+        node = GlobalBlock(f_statements)
 
         # Deserialize annotations.
         for key, val in cbor.items():
             if not (key.startswith('{') and key.endswith('}')):
                 continue
             key = key[1:-1]
             node[key] = cqasm.v3x.primitives.deserialize(key, val)
@@ -5601,41 +5494,23 @@
     def _serialize(self, id_map):
         """Serializes this node to the Python primitive representation of its
         CBOR serialization. The tree that the node belongs to must be
         well-formed. id_map must match Python id() calls for all nodes to unique
         integers, to use for the sequence number representation of links."""
         cbor = {'@i': id_map[id(self)], '@t': 'GlobalBlock'}
 
-        # Serialize the qubit_variable_declaration field.
-        field = {'@T': '1'}
-        if self._attr_qubit_variable_declaration is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
-        cbor['qubit_variable_declaration'] = field
-
-        # Serialize the gates field.
-        field = {'@T': '*'}
-        lst = []
-        for el in self._attr_gates:
-            el = el._serialize(id_map)
-            el['@T'] = '1'
-            lst.append(el)
-        field['@d'] = lst
-        cbor['gates'] = field
-
-        # Serialize the measure_instructions field.
+        # Serialize the statements field.
         field = {'@T': '*'}
         lst = []
-        for el in self._attr_measure_instructions:
+        for el in self._attr_statements:
             el = el._serialize(id_map)
             el['@T'] = '1'
             lst.append(el)
         field['@d'] = lst
-        cbor['measure_instructions'] = field
+        cbor['statements'] = field
 
         # Serialize annotations.
         for key, val in self._annot.items():
             cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
 
         return cbor
 
@@ -7948,28 +7823,36 @@
 
     _T = LogicalXorExpression
 
 
 _typemap['LogicalXorExpression'] = LogicalXorExpression
 
 class MeasureInstruction(Instruction):
+    """For some instructions, like the measure instruction, we want to
+    differentiate between left hand side and right and side operands. For a
+    measure instruction, the right hand side operand should be a qubit, and the
+    left hand side operand a bit."""
+
     __slots__ = [
         '_attr_name',
-        '_attr_operand',
+        '_attr_lhs',
+        '_attr_rhs',
     ]
 
     def __init__(
         self,
         name=None,
-        operand=None,
+        lhs=None,
+        rhs=None,
         annotations=None,
     ):
         super().__init__(annotations=annotations)
         self.name = name
-        self.operand = operand
+        self.lhs = lhs
+        self.rhs = rhs
 
     @property
     def name(self):
         return self._attr_name
 
     @name.setter
     def name(self, val):
@@ -7984,40 +7867,62 @@
         self._attr_name = val
 
     @name.deleter
     def name(self):
         self._attr_name = None
 
     @property
-    def operand(self):
-        return self._attr_operand
+    def lhs(self):
+        return self._attr_lhs
 
-    @operand.setter
-    def operand(self, val):
+    @lhs.setter
+    def lhs(self, val):
         if val is None:
-            del self.operand
+            del self.lhs
             return
         if not isinstance(val, Expression):
             # Try to "typecast" if this isn't an obvious mistake.
             if isinstance(val, Node):
-                raise TypeError('operand must be of type Expression')
+                raise TypeError('lhs must be of type Expression')
             val = Expression(val)
-        self._attr_operand = val
+        self._attr_lhs = val
 
-    @operand.deleter
-    def operand(self):
-        self._attr_operand = None
+    @lhs.deleter
+    def lhs(self):
+        self._attr_lhs = None
+
+    @property
+    def rhs(self):
+        return self._attr_rhs
+
+    @rhs.setter
+    def rhs(self, val):
+        if val is None:
+            del self.rhs
+            return
+        if not isinstance(val, Expression):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('rhs must be of type Expression')
+            val = Expression(val)
+        self._attr_rhs = val
+
+    @rhs.deleter
+    def rhs(self):
+        self._attr_rhs = None
 
     def __eq__(self, other):
         """Equality operator. Ignores annotations!"""
         if not isinstance(other, MeasureInstruction):
             return False
         if self.name != other.name:
             return False
-        if self.operand != other.operand:
+        if self.lhs != other.lhs:
+            return False
+        if self.rhs != other.rhs:
             return False
         if self.annotations != other.annotations:
             return False
         return True
 
     def dump(self, indent=0, annotations=None, links=1):
         """Returns a debug representation of this tree as a multiline string.
@@ -8039,20 +7944,28 @@
         if self.name is None:
             s.append('!MISSING\n')
         else:
             s.append('<\n')
             s.append(self.name.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
         s.append('  '*indent)
-        s.append('operand: ')
-        if self.operand is None:
+        s.append('lhs: ')
+        if self.lhs is None:
+            s.append('!MISSING\n')
+        else:
+            s.append('<\n')
+            s.append(self.lhs.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('rhs: ')
+        if self.rhs is None:
             s.append('!MISSING\n')
         else:
             s.append('<\n')
-            s.append(self.operand.dump(indent + 1, annotations, links) + '\n')
+            s.append(self.rhs.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
         s.append('  '*indent)
         s.append('annotations: ')
         if not self.annotations:
             s.append('-\n')
         else:
             s.append('[\n')
@@ -8074,16 +7987,18 @@
         if id_map is None:
             id_map = {}
         if id(self) in id_map:
             raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
         id_map[id(self)] = len(id_map)
         if self._attr_name is not None:
             self._attr_name.find_reachable(id_map)
-        if self._attr_operand is not None:
-            self._attr_operand.find_reachable(id_map)
+        if self._attr_lhs is not None:
+            self._attr_lhs.find_reachable(id_map)
+        if self._attr_rhs is not None:
+            self._attr_rhs.find_reachable(id_map)
         for el in self._attr_annotations:
             el.find_reachable(id_map)
         return id_map
 
     def check_complete(self, id_map=None):
         """Raises NotWellFormed if the tree rooted at this node is not
         well-formed. If id_map is specified, this tree is only a subtree in the
@@ -8091,38 +8006,44 @@
         id() codes to tree indices for all reachable nodes."""
         if id_map is None:
             id_map = self.find_reachable()
         if self._attr_name is None:
             raise NotWellFormed('name is required but not set')
         if self._attr_name is not None:
             self._attr_name.check_complete(id_map)
-        if self._attr_operand is None:
-            raise NotWellFormed('operand is required but not set')
-        if self._attr_operand is not None:
-            self._attr_operand.check_complete(id_map)
+        if self._attr_lhs is None:
+            raise NotWellFormed('lhs is required but not set')
+        if self._attr_lhs is not None:
+            self._attr_lhs.check_complete(id_map)
+        if self._attr_rhs is None:
+            raise NotWellFormed('rhs is required but not set')
+        if self._attr_rhs is not None:
+            self._attr_rhs.check_complete(id_map)
         for child in self._attr_annotations:
             child.check_complete(id_map)
 
     def copy(self):
         """Returns a shallow copy of this node."""
         return MeasureInstruction(
             name=self._attr_name,
-            operand=self._attr_operand,
+            lhs=self._attr_lhs,
+            rhs=self._attr_rhs,
             annotations=self._attr_annotations.copy()
         )
 
     def clone(self):
         """Returns a deep copy of this node. This mimics the C++ interface,
         deficiencies with links included; that is, links always point to the
         original tree. If you're not cloning a subtree in a context where this
         is the desired behavior, you may want to use the copy.deepcopy() from
         the stdlib instead, which should copy links correctly."""
         return MeasureInstruction(
             name=_cloned(self._attr_name),
-            operand=_cloned(self._attr_operand),
+            lhs=_cloned(self._attr_lhs),
+            rhs=_cloned(self._attr_rhs),
             annotations=_cloned(self._attr_annotations)
         )
 
     @staticmethod
     def _deserialize(cbor, seq_to_ob, links):
         """Attempts to deserialize the given cbor object (in Python primitive
         representation) into a node of this type. All (sub)nodes are added to
@@ -8145,24 +8066,35 @@
         if field.get('@T') != '1':
             raise ValueError('unexpected edge type for field name')
         if field.get('@t', None) is None:
             f_name = None
         else:
             f_name = Identifier._deserialize(field, seq_to_ob, links)
 
-        # Deserialize the operand field.
-        field = cbor.get('operand', None)
+        # Deserialize the lhs field.
+        field = cbor.get('lhs', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field lhs')
+        if field.get('@T') != '1':
+            raise ValueError('unexpected edge type for field lhs')
+        if field.get('@t', None) is None:
+            f_lhs = None
+        else:
+            f_lhs = Expression._deserialize(field, seq_to_ob, links)
+
+        # Deserialize the rhs field.
+        field = cbor.get('rhs', None)
         if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field operand')
+            raise ValueError('missing or invalid serialization of field rhs')
         if field.get('@T') != '1':
-            raise ValueError('unexpected edge type for field operand')
+            raise ValueError('unexpected edge type for field rhs')
         if field.get('@t', None) is None:
-            f_operand = None
+            f_rhs = None
         else:
-            f_operand = Expression._deserialize(field, seq_to_ob, links)
+            f_rhs = Expression._deserialize(field, seq_to_ob, links)
 
         # Deserialize the annotations field.
         field = cbor.get('annotations', None)
         if not isinstance(field, dict):
             raise ValueError('missing or invalid serialization of field annotations')
         if field.get('@T') != '*':
             raise ValueError('unexpected edge type for field annotations')
@@ -8172,15 +8104,15 @@
         f_annotations = MultiAnnotationData()
         for element in data:
             if element.get('@T') != '1':
                 raise ValueError('unexpected edge type for Any/Many element')
             f_annotations.append(AnnotationData._deserialize(element, seq_to_ob, links))
 
         # Construct the MeasureInstruction node.
-        node = MeasureInstruction(f_name, f_operand, f_annotations)
+        node = MeasureInstruction(f_name, f_lhs, f_rhs, f_annotations)
 
         # Deserialize annotations.
         for key, val in cbor.items():
             if not (key.startswith('{') and key.endswith('}')):
                 continue
             key = key[1:-1]
             node[key] = cqasm.v3x.primitives.deserialize(key, val)
@@ -8206,21 +8138,29 @@
         field = {'@T': '1'}
         if self._attr_name is None:
             field['@t'] = None
         else:
             field.update(self._attr_name._serialize(id_map))
         cbor['name'] = field
 
-        # Serialize the operand field.
+        # Serialize the lhs field.
+        field = {'@T': '1'}
+        if self._attr_lhs is None:
+            field['@t'] = None
+        else:
+            field.update(self._attr_lhs._serialize(id_map))
+        cbor['lhs'] = field
+
+        # Serialize the rhs field.
         field = {'@T': '1'}
-        if self._attr_operand is None:
+        if self._attr_rhs is None:
             field['@t'] = None
         else:
-            field.update(self._attr_operand._serialize(id_map))
-        cbor['operand'] = field
+            field.update(self._attr_rhs._serialize(id_map))
+        cbor['rhs'] = field
 
         # Serialize the annotations field.
         field = {'@T': '*'}
         lst = []
         for el in self._attr_annotations:
             el = el._serialize(id_map)
             el['@T'] = '1'
@@ -8987,15 +8927,15 @@
         else:
             s.append('<\n')
             s.append(self.version.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
         s.append('  '*indent)
         s.append('block: ')
         if self.block is None:
-            s.append('-\n')
+            s.append('!MISSING\n')
         else:
             s.append('<\n')
             s.append(self.block.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
         indent -= 1
         s.append('  '*indent)
         s.append(')')
@@ -9026,14 +8966,16 @@
         id() codes to tree indices for all reachable nodes."""
         if id_map is None:
             id_map = self.find_reachable()
         if self._attr_version is None:
             raise NotWellFormed('version is required but not set')
         if self._attr_version is not None:
             self._attr_version.check_complete(id_map)
+        if self._attr_block is None:
+            raise NotWellFormed('block is required but not set')
         if self._attr_block is not None:
             self._attr_block.check_complete(id_map)
 
     def copy(self):
         """Returns a shallow copy of this node."""
         return Program(
             version=self._attr_version,
@@ -9078,15 +9020,15 @@
         else:
             f_version = Version._deserialize(field, seq_to_ob, links)
 
         # Deserialize the block field.
         field = cbor.get('block', None)
         if not isinstance(field, dict):
             raise ValueError('missing or invalid serialization of field block')
-        if field.get('@T') != '?':
+        if field.get('@T') != '1':
             raise ValueError('unexpected edge type for field block')
         if field.get('@t', None) is None:
             f_block = None
         else:
             f_block = GlobalBlock._deserialize(field, seq_to_ob, links)
 
         # Construct the Program node.
@@ -9121,15 +9063,15 @@
         if self._attr_version is None:
             field['@t'] = None
         else:
             field.update(self._attr_version._serialize(id_map))
         cbor['version'] = field
 
         # Serialize the block field.
-        field = {'@T': '?'}
+        field = {'@T': '1'}
         if self._attr_block is None:
             field['@t'] = None
         else:
             field.update(self._attr_block._serialize(id_map))
         cbor['block'] = field
 
         # Serialize annotations.
```

## cqasm/v3x/semantic.py

```diff
@@ -1549,30 +1549,30 @@
 
 _typemap['Instruction'] = Instruction
 
 class Program(Node):
     __slots__ = [
         '_attr_api_version',
         '_attr_version',
-        '_attr_qubit_variable_declaration',
         '_attr_block',
+        '_attr_variables',
     ]
 
     def __init__(
         self,
         api_version=None,
         version=None,
-        qubit_variable_declaration=None,
         block=None,
+        variables=None,
     ):
         super().__init__()
         self.api_version = api_version
         self.version = version
-        self.qubit_variable_declaration = qubit_variable_declaration
         self.block = block
+        self.variables = variables
 
     @property
     def api_version(self):
         """API version. This may be greater than or equal to the file version.
         This controls which fields of the tree are used, where such usage
         depends on the version."""
         return self._attr_api_version
@@ -1611,35 +1611,14 @@
         self._attr_version = val
 
     @version.deleter
     def version(self):
         self._attr_version = None
 
     @property
-    def qubit_variable_declaration(self):
-        """Qubit variable."""
-        return self._attr_qubit_variable_declaration
-
-    @qubit_variable_declaration.setter
-    def qubit_variable_declaration(self, val):
-        if val is None:
-            del self.qubit_variable_declaration
-            return
-        if not isinstance(val, Variable):
-            # Try to "typecast" if this isn't an obvious mistake.
-            if isinstance(val, Node):
-                raise TypeError('qubit_variable_declaration must be of type Variable')
-            val = Variable(val)
-        self._attr_qubit_variable_declaration = val
-
-    @qubit_variable_declaration.deleter
-    def qubit_variable_declaration(self):
-        self._attr_qubit_variable_declaration = None
-
-    @property
     def block(self):
         """Global scope block."""
         return self._attr_block
 
     @block.setter
     def block(self, val):
         if val is None:
@@ -1652,26 +1631,47 @@
             val = Block(val)
         self._attr_block = val
 
     @block.deleter
     def block(self):
         self._attr_block = None
 
+    @property
+    def variables(self):
+        """The list of variables."""
+        return self._attr_variables
+
+    @variables.setter
+    def variables(self, val):
+        if val is None:
+            del self.variables
+            return
+        if not isinstance(val, MultiVariable):
+            # Try to "typecast" if this isn't an obvious mistake.
+            if isinstance(val, Node):
+                raise TypeError('variables must be of type MultiVariable')
+            val = MultiVariable(val)
+        self._attr_variables = val
+
+    @variables.deleter
+    def variables(self):
+        self._attr_variables = MultiVariable()
+
     def __eq__(self, other):
         """Equality operator. Ignores annotations!"""
         if not isinstance(other, Program):
             return False
         if self.api_version != other.api_version:
             return False
         if self.version != other.version:
             return False
-        if self.qubit_variable_declaration != other.qubit_variable_declaration:
-            return False
         if self.block != other.block:
             return False
+        if self.variables != other.variables:
+            return False
         return True
 
     def dump(self, indent=0, annotations=None, links=1):
         """Returns a debug representation of this tree as a multiline string.
         indent is the number of double spaces prefixed before every line.
         annotations, if specified, must be a set-like object containing the key
         strings of the annotations that are to be printed. links specifies the
@@ -1693,29 +1693,30 @@
         if self.version is None:
             s.append('!MISSING\n')
         else:
             s.append('<\n')
             s.append(self.version.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
         s.append('  '*indent)
-        s.append('qubit_variable_declaration: ')
-        if self.qubit_variable_declaration is None:
-            s.append('-\n')
-        else:
-            s.append('<\n')
-            s.append(self.qubit_variable_declaration.dump(indent + 1, annotations, links) + '\n')
-            s.append('  '*indent + '>\n')
-        s.append('  '*indent)
         s.append('block: ')
         if self.block is None:
-            s.append('-\n')
+            s.append('!MISSING\n')
         else:
             s.append('<\n')
             s.append(self.block.dump(indent + 1, annotations, links) + '\n')
             s.append('  '*indent + '>\n')
+        s.append('  '*indent)
+        s.append('variables: ')
+        if not self.variables:
+            s.append('-\n')
+        else:
+            s.append('[\n')
+            for child in self.variables:
+                s.append(child.dump(indent + 1, annotations, links) + '\n')
+            s.append('  '*indent + ']\n')
         indent -= 1
         s.append('  '*indent)
         s.append(')')
         return ''.join(s)
 
     __str__ = dump
     __repr__ = dump
@@ -1727,56 +1728,58 @@
         if id_map is None:
             id_map = {}
         if id(self) in id_map:
             raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
         id_map[id(self)] = len(id_map)
         if self._attr_version is not None:
             self._attr_version.find_reachable(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.find_reachable(id_map)
         if self._attr_block is not None:
             self._attr_block.find_reachable(id_map)
+        for el in self._attr_variables:
+            el.find_reachable(id_map)
         return id_map
 
     def check_complete(self, id_map=None):
         """Raises NotWellFormed if the tree rooted at this node is not
         well-formed. If id_map is specified, this tree is only a subtree in the
         context of a larger tree, and id_map must be a dict mapping from Python
         id() codes to tree indices for all reachable nodes."""
         if id_map is None:
             id_map = self.find_reachable()
         if self._attr_version is None:
             raise NotWellFormed('version is required but not set')
         if self._attr_version is not None:
             self._attr_version.check_complete(id_map)
-        if self._attr_qubit_variable_declaration is not None:
-            self._attr_qubit_variable_declaration.check_complete(id_map)
+        if self._attr_block is None:
+            raise NotWellFormed('block is required but not set')
         if self._attr_block is not None:
             self._attr_block.check_complete(id_map)
+        for child in self._attr_variables:
+            child.check_complete(id_map)
 
     def copy(self):
         """Returns a shallow copy of this node."""
         return Program(
             api_version=self._attr_api_version,
             version=self._attr_version,
-            qubit_variable_declaration=self._attr_qubit_variable_declaration,
-            block=self._attr_block
+            block=self._attr_block,
+            variables=self._attr_variables.copy()
         )
 
     def clone(self):
         """Returns a deep copy of this node. This mimics the C++ interface,
         deficiencies with links included; that is, links always point to the
         original tree. If you're not cloning a subtree in a context where this
         is the desired behavior, you may want to use the copy.deepcopy() from
         the stdlib instead, which should copy links correctly."""
         return Program(
             api_version=_cloned(self._attr_api_version),
             version=_cloned(self._attr_version),
-            qubit_variable_declaration=_cloned(self._attr_qubit_variable_declaration),
-            block=_cloned(self._attr_block)
+            block=_cloned(self._attr_block),
+            variables=_cloned(self._attr_variables)
         )
 
     @staticmethod
     def _deserialize(cbor, seq_to_ob, links):
         """Attempts to deserialize the given cbor object (in Python primitive
         representation) into a node of this type. All (sub)nodes are added to
         the seq_to_ob dict, indexed by their cbor sequence number. All links are
@@ -1807,38 +1810,42 @@
         if field.get('@T') != '1':
             raise ValueError('unexpected edge type for field version')
         if field.get('@t', None) is None:
             f_version = None
         else:
             f_version = Version._deserialize(field, seq_to_ob, links)
 
-        # Deserialize the qubit_variable_declaration field.
-        field = cbor.get('qubit_variable_declaration', None)
-        if not isinstance(field, dict):
-            raise ValueError('missing or invalid serialization of field qubit_variable_declaration')
-        if field.get('@T') != '?':
-            raise ValueError('unexpected edge type for field qubit_variable_declaration')
-        if field.get('@t', None) is None:
-            f_qubit_variable_declaration = None
-        else:
-            f_qubit_variable_declaration = Variable._deserialize(field, seq_to_ob, links)
-
         # Deserialize the block field.
         field = cbor.get('block', None)
         if not isinstance(field, dict):
             raise ValueError('missing or invalid serialization of field block')
-        if field.get('@T') != '?':
+        if field.get('@T') != '1':
             raise ValueError('unexpected edge type for field block')
         if field.get('@t', None) is None:
             f_block = None
         else:
             f_block = Block._deserialize(field, seq_to_ob, links)
 
+        # Deserialize the variables field.
+        field = cbor.get('variables', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field variables')
+        if field.get('@T') != '*':
+            raise ValueError('unexpected edge type for field variables')
+        data = field.get('@d', None)
+        if not isinstance(data, list):
+            raise ValueError('missing serialization of Any/Many contents')
+        f_variables = MultiVariable()
+        for element in data:
+            if element.get('@T') != '1':
+                raise ValueError('unexpected edge type for Any/Many element')
+            f_variables.append(Variable._deserialize(element, seq_to_ob, links))
+
         # Construct the Program node.
-        node = Program(f_api_version, f_version, f_qubit_variable_declaration, f_block)
+        node = Program(f_api_version, f_version, f_block, f_variables)
 
         # Deserialize annotations.
         for key, val in cbor.items():
             if not (key.startswith('{') and key.endswith('}')):
                 continue
             key = key[1:-1]
             node[key] = cqasm.v3x.primitives.deserialize(key, val)
@@ -1870,30 +1877,32 @@
         field = {'@T': '1'}
         if self._attr_version is None:
             field['@t'] = None
         else:
             field.update(self._attr_version._serialize(id_map))
         cbor['version'] = field
 
-        # Serialize the qubit_variable_declaration field.
-        field = {'@T': '?'}
-        if self._attr_qubit_variable_declaration is None:
-            field['@t'] = None
-        else:
-            field.update(self._attr_qubit_variable_declaration._serialize(id_map))
-        cbor['qubit_variable_declaration'] = field
-
         # Serialize the block field.
-        field = {'@T': '?'}
+        field = {'@T': '1'}
         if self._attr_block is None:
             field['@t'] = None
         else:
             field.update(self._attr_block._serialize(id_map))
         cbor['block'] = field
 
+        # Serialize the variables field.
+        field = {'@T': '*'}
+        lst = []
+        for el in self._attr_variables:
+            el = el._serialize(id_map)
+            el['@T'] = '1'
+            lst.append(el)
+        field['@d'] = lst
+        cbor['variables'] = field
+
         # Serialize annotations.
         for key, val in self._annot.items():
             cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
 
         return cbor
```

## cqasm/v3x/types.py

```diff
@@ -635,16 +635,20 @@
             raise ValueError('type (@t) field is missing from node serialization')
         if typ == 'Bool':
             return Bool._deserialize(cbor, seq_to_ob, links)
         if typ == 'Int':
             return Int._deserialize(cbor, seq_to_ob, links)
         if typ == 'Float':
             return Float._deserialize(cbor, seq_to_ob, links)
+        if typ == 'Bit':
+            return Bit._deserialize(cbor, seq_to_ob, links)
         if typ == 'Qubit':
             return Qubit._deserialize(cbor, seq_to_ob, links)
+        if typ == 'BitArray':
+            return BitArray._deserialize(cbor, seq_to_ob, links)
         if typ == 'QubitArray':
             return QubitArray._deserialize(cbor, seq_to_ob, links)
         raise ValueError('unknown or unexpected type (@t) found in node serialization')
 
     def _serialize(self, id_map):
         """Serializes this node to the Python primitive representation of its
         CBOR serialization. The tree that the node belongs to must be
@@ -669,14 +673,316 @@
     """Wrapper for an edge with multiple TypeBase objects."""
 
     _T = TypeBase
 
 
 _typemap['TypeBase'] = TypeBase
 
+class Bit(TypeBase):
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, Bit):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('Bit(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return Bit(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return Bit(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'Bit':
+            raise ValueError('found node serialization for ' + typ + ', but expected Bit')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the Bit node.
+        node = Bit(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'Bit'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBit(_Multiple):
+    """Wrapper for an edge with multiple Bit objects."""
+
+    _T = Bit
+
+
+_typemap['Bit'] = Bit
+
+class BitArray(TypeBase):
+    __slots__ = []
+
+    def __init__(
+        self,
+        size=None,
+    ):
+        super().__init__(size=size)
+
+    def __eq__(self, other):
+        """Equality operator. Ignores annotations!"""
+        if not isinstance(other, BitArray):
+            return False
+        if self.size != other.size:
+            return False
+        return True
+
+    def dump(self, indent=0, annotations=None, links=1):
+        """Returns a debug representation of this tree as a multiline string.
+        indent is the number of double spaces prefixed before every line.
+        annotations, if specified, must be a set-like object containing the key
+        strings of the annotations that are to be printed. links specifies the
+        maximum link recursion depth."""
+        s = ['  '*indent]
+        s.append('BitArray(')
+        if annotations is None:
+            annotations = []
+        for key in annotations:
+            if key in self:
+                s.append(' # {}: {}'.format(key, self[key]))
+        s.append('\n')
+        indent += 1
+        s.append('  '*indent)
+        s.append('size: ')
+        s.append(str(self.size) + '\n')
+        indent -= 1
+        s.append('  '*indent)
+        s.append(')')
+        return ''.join(s)
+
+    __str__ = dump
+    __repr__ = dump
+
+    def find_reachable(self, id_map=None):
+        """Returns a dictionary mapping Python id() values to stable sequence
+        numbers for all nodes in the tree rooted at this node. If id_map is
+        specified, found nodes are appended to it."""
+        if id_map is None:
+            id_map = {}
+        if id(self) in id_map:
+            raise NotWellFormed('node {!r} with id {} occurs more than once'.format(self, id(self)))
+        id_map[id(self)] = len(id_map)
+        return id_map
+
+    def check_complete(self, id_map=None):
+        """Raises NotWellFormed if the tree rooted at this node is not
+        well-formed. If id_map is specified, this tree is only a subtree in the
+        context of a larger tree, and id_map must be a dict mapping from Python
+        id() codes to tree indices for all reachable nodes."""
+        if id_map is None:
+            id_map = self.find_reachable()
+
+    def copy(self):
+        """Returns a shallow copy of this node."""
+        return BitArray(
+            size=self._attr_size
+        )
+
+    def clone(self):
+        """Returns a deep copy of this node. This mimics the C++ interface,
+        deficiencies with links included; that is, links always point to the
+        original tree. If you're not cloning a subtree in a context where this
+        is the desired behavior, you may want to use the copy.deepcopy() from
+        the stdlib instead, which should copy links correctly."""
+        return BitArray(
+            size=_cloned(self._attr_size)
+        )
+
+    @staticmethod
+    def _deserialize(cbor, seq_to_ob, links):
+        """Attempts to deserialize the given cbor object (in Python primitive
+        representation) into a node of this type. All (sub)nodes are added to
+        the seq_to_ob dict, indexed by their cbor sequence number. All links are
+        registered in the links list by means of a two-tuple of the setter
+        function for the link field and the sequence number of the target node.
+        """
+        if not isinstance(cbor, dict):
+            raise TypeError('node description object must be a dict')
+        typ = cbor.get('@t', None)
+        if typ is None:
+            raise ValueError('type (@t) field is missing from node serialization')
+        if typ != 'BitArray':
+            raise ValueError('found node serialization for ' + typ + ', but expected BitArray')
+
+        # Deserialize the size field.
+        field = cbor.get('size', None)
+        if not isinstance(field, dict):
+            raise ValueError('missing or invalid serialization of field size')
+        if hasattr(cqasm.v3x.primitives.Int, 'deserialize_cbor'):
+            f_size = cqasm.v3x.primitives.Int.deserialize_cbor(field)
+        else:
+            f_size = cqasm.v3x.primitives.deserialize(cqasm.v3x.primitives.Int, field)
+
+        # Construct the BitArray node.
+        node = BitArray(f_size)
+
+        # Deserialize annotations.
+        for key, val in cbor.items():
+            if not (key.startswith('{') and key.endswith('}')):
+                continue
+            key = key[1:-1]
+            node[key] = cqasm.v3x.primitives.deserialize(key, val)
+
+        # Register node in sequence number lookup.
+        seq = cbor.get('@i', None)
+        if not isinstance(seq, int):
+            raise ValueError('sequence number field (@i) is not an integer or missing from node serialization')
+        if seq in seq_to_ob:
+            raise ValueError('duplicate sequence number %d' % seq)
+        seq_to_ob[seq] = node
+
+        return node
+
+    def _serialize(self, id_map):
+        """Serializes this node to the Python primitive representation of its
+        CBOR serialization. The tree that the node belongs to must be
+        well-formed. id_map must match Python id() calls for all nodes to unique
+        integers, to use for the sequence number representation of links."""
+        cbor = {'@i': id_map[id(self)], '@t': 'BitArray'}
+
+        # Serialize the size field.
+        if hasattr(self._attr_size, 'serialize_cbor'):
+            cbor['size'] = self._attr_size.serialize_cbor()
+        else:
+            cbor['size'] = cqasm.v3x.primitives.serialize(cqasm.v3x.primitives.Int, self._attr_size)
+
+        # Serialize annotations.
+        for key, val in self._annot.items():
+            cbor['{%s}' % key] = _py_to_cbor(cqasm.v3x.primitives.serialize(key, val))
+
+        return cbor
+
+
+class MultiBitArray(_Multiple):
+    """Wrapper for an edge with multiple BitArray objects."""
+
+    _T = BitArray
+
+
+_typemap['BitArray'] = BitArray
+
 class Bool(TypeBase):
     """Type of a boolean."""
 
     __slots__ = []
 
     def __init__(
         self,
```

## Comparing `libQasm/__init__.py` & `libqasm/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,10 +16,10 @@
     raise EnvironmentError(
         "sys.version_info refers does not refer to a version of Python 3. "
         "This is not permitted. "
         "sys.version_info = {}".format(version_info))
 del version_info
 
 # Import the SWIG-generated module.
-from .libQasm import *
+from .libqasm import *
 
 # __all__ = [ init, schedule, compile ]
```

## Comparing `libQasm/libQasm.py` & `libqasm/libqasm.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 #
 # Do not make changes to this file unless you know what you are doing - modify
 # the SWIG interface file instead.
 
 from sys import version_info as _swig_python_version_info
 # Import the low-level C/C++ module
 if __package__ or "." in __name__:
-    from . import _libQasm
+    from . import _libqasm
 else:
-    import _libQasm
+    import _libqasm
 
 try:
     import builtins as __builtin__
 except ImportError:
     import __builtin__
 
 def _swig_repr(self):
@@ -60,1023 +60,1023 @@
 
 class SwigPyIterator(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined - class is abstract")
     __repr__ = _swig_repr
-    __swig_destroy__ = _libQasm.delete_SwigPyIterator
+    __swig_destroy__ = _libqasm.delete_SwigPyIterator
 
     def value(self):
-        return _libQasm.SwigPyIterator_value(self)
+        return _libqasm.SwigPyIterator_value(self)
 
     def incr(self, n=1):
-        return _libQasm.SwigPyIterator_incr(self, n)
+        return _libqasm.SwigPyIterator_incr(self, n)
 
     def decr(self, n=1):
-        return _libQasm.SwigPyIterator_decr(self, n)
+        return _libqasm.SwigPyIterator_decr(self, n)
 
     def distance(self, x):
-        return _libQasm.SwigPyIterator_distance(self, x)
+        return _libqasm.SwigPyIterator_distance(self, x)
 
     def equal(self, x):
-        return _libQasm.SwigPyIterator_equal(self, x)
+        return _libqasm.SwigPyIterator_equal(self, x)
 
     def copy(self):
-        return _libQasm.SwigPyIterator_copy(self)
+        return _libqasm.SwigPyIterator_copy(self)
 
     def next(self):
-        return _libQasm.SwigPyIterator_next(self)
+        return _libqasm.SwigPyIterator_next(self)
 
     def __next__(self):
-        return _libQasm.SwigPyIterator___next__(self)
+        return _libqasm.SwigPyIterator___next__(self)
 
     def previous(self):
-        return _libQasm.SwigPyIterator_previous(self)
+        return _libqasm.SwigPyIterator_previous(self)
 
     def advance(self, n):
-        return _libQasm.SwigPyIterator_advance(self, n)
+        return _libqasm.SwigPyIterator_advance(self, n)
 
     def __eq__(self, x):
-        return _libQasm.SwigPyIterator___eq__(self, x)
+        return _libqasm.SwigPyIterator___eq__(self, x)
 
     def __ne__(self, x):
-        return _libQasm.SwigPyIterator___ne__(self, x)
+        return _libqasm.SwigPyIterator___ne__(self, x)
 
     def __iadd__(self, n):
-        return _libQasm.SwigPyIterator___iadd__(self, n)
+        return _libqasm.SwigPyIterator___iadd__(self, n)
 
     def __isub__(self, n):
-        return _libQasm.SwigPyIterator___isub__(self, n)
+        return _libqasm.SwigPyIterator___isub__(self, n)
 
     def __add__(self, n):
-        return _libQasm.SwigPyIterator___add__(self, n)
+        return _libqasm.SwigPyIterator___add__(self, n)
 
     def __sub__(self, *args):
-        return _libQasm.SwigPyIterator___sub__(self, *args)
+        return _libqasm.SwigPyIterator___sub__(self, *args)
     def __iter__(self):
         return self
 
-# Register SwigPyIterator in _libQasm:
-_libQasm.SwigPyIterator_swigregister(SwigPyIterator)
+# Register SwigPyIterator in _libqasm:
+_libqasm.SwigPyIterator_swigregister(SwigPyIterator)
 class ios_base(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
 
     def __init__(self, *args, **kwargs):
         raise AttributeError("No constructor defined")
     __repr__ = _swig_repr
-    erase_event = _libQasm.ios_base_erase_event
-    imbue_event = _libQasm.ios_base_imbue_event
-    copyfmt_event = _libQasm.ios_base_copyfmt_event
+    erase_event = _libqasm.ios_base_erase_event
+    imbue_event = _libqasm.ios_base_imbue_event
+    copyfmt_event = _libqasm.ios_base_copyfmt_event
 
     def register_callback(self, __fn, __index):
-        return _libQasm.ios_base_register_callback(self, __fn, __index)
+        return _libqasm.ios_base_register_callback(self, __fn, __index)
 
     def flags(self, *args):
-        return _libQasm.ios_base_flags(self, *args)
+        return _libqasm.ios_base_flags(self, *args)
 
     def setf(self, *args):
-        return _libQasm.ios_base_setf(self, *args)
+        return _libqasm.ios_base_setf(self, *args)
 
     def unsetf(self, __mask):
-        return _libQasm.ios_base_unsetf(self, __mask)
+        return _libqasm.ios_base_unsetf(self, __mask)
 
     def precision(self, *args):
-        return _libQasm.ios_base_precision(self, *args)
+        return _libqasm.ios_base_precision(self, *args)
 
     def width(self, *args):
-        return _libQasm.ios_base_width(self, *args)
+        return _libqasm.ios_base_width(self, *args)
 
     @staticmethod
     def sync_with_stdio(__sync=True):
-        return _libQasm.ios_base_sync_with_stdio(__sync)
+        return _libqasm.ios_base_sync_with_stdio(__sync)
 
     def imbue(self, __loc):
-        return _libQasm.ios_base_imbue(self, __loc)
+        return _libqasm.ios_base_imbue(self, __loc)
 
     def getloc(self):
-        return _libQasm.ios_base_getloc(self)
+        return _libqasm.ios_base_getloc(self)
 
     @staticmethod
     def xalloc():
-        return _libQasm.ios_base_xalloc()
+        return _libqasm.ios_base_xalloc()
 
     def iword(self, __ix):
-        return _libQasm.ios_base_iword(self, __ix)
+        return _libqasm.ios_base_iword(self, __ix)
 
     def pword(self, __ix):
-        return _libQasm.ios_base_pword(self, __ix)
-    __swig_destroy__ = _libQasm.delete_ios_base
+        return _libqasm.ios_base_pword(self, __ix)
+    __swig_destroy__ = _libqasm.delete_ios_base
 
-# Register ios_base in _libQasm:
-_libQasm.ios_base_swigregister(ios_base)
-cvar = _libQasm.cvar
-ios_base.boolalpha = _libQasm.cvar.ios_base_boolalpha
-ios_base.dec = _libQasm.cvar.ios_base_dec
-ios_base.fixed = _libQasm.cvar.ios_base_fixed
-ios_base.hex = _libQasm.cvar.ios_base_hex
-ios_base.internal = _libQasm.cvar.ios_base_internal
-ios_base.left = _libQasm.cvar.ios_base_left
-ios_base.oct = _libQasm.cvar.ios_base_oct
-ios_base.right = _libQasm.cvar.ios_base_right
-ios_base.scientific = _libQasm.cvar.ios_base_scientific
-ios_base.showbase = _libQasm.cvar.ios_base_showbase
-ios_base.showpoint = _libQasm.cvar.ios_base_showpoint
-ios_base.showpos = _libQasm.cvar.ios_base_showpos
-ios_base.skipws = _libQasm.cvar.ios_base_skipws
-ios_base.unitbuf = _libQasm.cvar.ios_base_unitbuf
-ios_base.uppercase = _libQasm.cvar.ios_base_uppercase
-ios_base.adjustfield = _libQasm.cvar.ios_base_adjustfield
-ios_base.basefield = _libQasm.cvar.ios_base_basefield
-ios_base.floatfield = _libQasm.cvar.ios_base_floatfield
-ios_base.badbit = _libQasm.cvar.ios_base_badbit
-ios_base.eofbit = _libQasm.cvar.ios_base_eofbit
-ios_base.failbit = _libQasm.cvar.ios_base_failbit
-ios_base.goodbit = _libQasm.cvar.ios_base_goodbit
-ios_base.app = _libQasm.cvar.ios_base_app
-ios_base.ate = _libQasm.cvar.ios_base_ate
-ios_base.binary = _libQasm.cvar.ios_base_binary
-ios_base.ios_base_in = _libQasm.cvar.ios_base_ios_base_in
-ios_base.out = _libQasm.cvar.ios_base_out
-ios_base.trunc = _libQasm.cvar.ios_base_trunc
-ios_base.beg = _libQasm.cvar.ios_base_beg
-ios_base.cur = _libQasm.cvar.ios_base_cur
-ios_base.end = _libQasm.cvar.ios_base_end
+# Register ios_base in _libqasm:
+_libqasm.ios_base_swigregister(ios_base)
+cvar = _libqasm.cvar
+ios_base.boolalpha = _libqasm.cvar.ios_base_boolalpha
+ios_base.dec = _libqasm.cvar.ios_base_dec
+ios_base.fixed = _libqasm.cvar.ios_base_fixed
+ios_base.hex = _libqasm.cvar.ios_base_hex
+ios_base.internal = _libqasm.cvar.ios_base_internal
+ios_base.left = _libqasm.cvar.ios_base_left
+ios_base.oct = _libqasm.cvar.ios_base_oct
+ios_base.right = _libqasm.cvar.ios_base_right
+ios_base.scientific = _libqasm.cvar.ios_base_scientific
+ios_base.showbase = _libqasm.cvar.ios_base_showbase
+ios_base.showpoint = _libqasm.cvar.ios_base_showpoint
+ios_base.showpos = _libqasm.cvar.ios_base_showpos
+ios_base.skipws = _libqasm.cvar.ios_base_skipws
+ios_base.unitbuf = _libqasm.cvar.ios_base_unitbuf
+ios_base.uppercase = _libqasm.cvar.ios_base_uppercase
+ios_base.adjustfield = _libqasm.cvar.ios_base_adjustfield
+ios_base.basefield = _libqasm.cvar.ios_base_basefield
+ios_base.floatfield = _libqasm.cvar.ios_base_floatfield
+ios_base.badbit = _libqasm.cvar.ios_base_badbit
+ios_base.eofbit = _libqasm.cvar.ios_base_eofbit
+ios_base.failbit = _libqasm.cvar.ios_base_failbit
+ios_base.goodbit = _libqasm.cvar.ios_base_goodbit
+ios_base.app = _libqasm.cvar.ios_base_app
+ios_base.ate = _libqasm.cvar.ios_base_ate
+ios_base.binary = _libqasm.cvar.ios_base_binary
+ios_base.ios_base_in = _libqasm.cvar.ios_base_ios_base_in
+ios_base.out = _libqasm.cvar.ios_base_out
+ios_base.trunc = _libqasm.cvar.ios_base_trunc
+ios_base.beg = _libqasm.cvar.ios_base_beg
+ios_base.cur = _libqasm.cvar.ios_base_cur
+ios_base.end = _libqasm.cvar.ios_base_end
 
 class ios(ios_base):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def rdstate(self):
-        return _libQasm.ios_rdstate(self)
+        return _libqasm.ios_rdstate(self)
 
     def clear(self, *args):
-        return _libQasm.ios_clear(self, *args)
+        return _libqasm.ios_clear(self, *args)
 
     def setstate(self, __state):
-        return _libQasm.ios_setstate(self, __state)
+        return _libqasm.ios_setstate(self, __state)
 
     def good(self):
-        return _libQasm.ios_good(self)
+        return _libqasm.ios_good(self)
 
     def eof(self):
-        return _libQasm.ios_eof(self)
+        return _libqasm.ios_eof(self)
 
     def fail(self):
-        return _libQasm.ios_fail(self)
+        return _libqasm.ios_fail(self)
 
     def bad(self):
-        return _libQasm.ios_bad(self)
+        return _libqasm.ios_bad(self)
 
     def exceptions(self, *args):
-        return _libQasm.ios_exceptions(self, *args)
+        return _libqasm.ios_exceptions(self, *args)
 
     def __init__(self, __sb):
-        _libQasm.ios_swiginit(self, _libQasm.new_ios(__sb))
-    __swig_destroy__ = _libQasm.delete_ios
+        _libqasm.ios_swiginit(self, _libqasm.new_ios(__sb))
+    __swig_destroy__ = _libqasm.delete_ios
 
     def tie(self, *args):
-        return _libQasm.ios_tie(self, *args)
+        return _libqasm.ios_tie(self, *args)
 
     def rdbuf(self, *args):
-        return _libQasm.ios_rdbuf(self, *args)
+        return _libqasm.ios_rdbuf(self, *args)
 
     def copyfmt(self, __rhs):
-        return _libQasm.ios_copyfmt(self, __rhs)
+        return _libqasm.ios_copyfmt(self, __rhs)
 
     def fill(self, *args):
-        return _libQasm.ios_fill(self, *args)
+        return _libqasm.ios_fill(self, *args)
 
     def imbue(self, __loc):
-        return _libQasm.ios_imbue(self, __loc)
+        return _libqasm.ios_imbue(self, __loc)
 
     def narrow(self, __c, __dfault):
-        return _libQasm.ios_narrow(self, __c, __dfault)
+        return _libqasm.ios_narrow(self, __c, __dfault)
 
     def widen(self, __c):
-        return _libQasm.ios_widen(self, __c)
+        return _libqasm.ios_widen(self, __c)
 
-# Register ios in _libQasm:
-_libQasm.ios_swigregister(ios)
+# Register ios in _libqasm:
+_libqasm.ios_swigregister(ios)
 class string(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def length(self):
-        return _libQasm.string_length(self)
+        return _libqasm.string_length(self)
 
     def max_size(self):
-        return _libQasm.string_max_size(self)
+        return _libqasm.string_max_size(self)
 
     def capacity(self):
-        return _libQasm.string_capacity(self)
+        return _libqasm.string_capacity(self)
 
     def reserve(self, __res_arg):
-        return _libQasm.string_reserve(self, __res_arg)
+        return _libqasm.string_reserve(self, __res_arg)
 
     def shrink_to_fit(self):
-        return _libQasm.string_shrink_to_fit(self)
+        return _libqasm.string_shrink_to_fit(self)
 
     def copy(self, __s, __n, __pos=0):
-        return _libQasm.string_copy(self, __s, __n, __pos)
+        return _libqasm.string_copy(self, __s, __n, __pos)
 
     def c_str(self):
-        return _libQasm.string_c_str(self)
+        return _libqasm.string_c_str(self)
 
     def find(self, *args):
-        return _libQasm.string_find(self, *args)
+        return _libqasm.string_find(self, *args)
 
     def rfind(self, *args):
-        return _libQasm.string_rfind(self, *args)
+        return _libqasm.string_rfind(self, *args)
 
     def find_first_of(self, *args):
-        return _libQasm.string_find_first_of(self, *args)
+        return _libqasm.string_find_first_of(self, *args)
 
     def find_last_of(self, *args):
-        return _libQasm.string_find_last_of(self, *args)
+        return _libqasm.string_find_last_of(self, *args)
 
     def find_first_not_of(self, *args):
-        return _libQasm.string_find_first_not_of(self, *args)
+        return _libqasm.string_find_first_not_of(self, *args)
 
     def find_last_not_of(self, *args):
-        return _libQasm.string_find_last_not_of(self, *args)
+        return _libqasm.string_find_last_not_of(self, *args)
 
     def substr(self, *args):
-        return _libQasm.string_substr(self, *args)
+        return _libqasm.string_substr(self, *args)
 
     def empty(self):
-        return _libQasm.string_empty(self)
+        return _libqasm.string_empty(self)
 
     def size(self):
-        return _libQasm.string_size(self)
+        return _libqasm.string_size(self)
 
     def swap(self, v):
-        return _libQasm.string_swap(self, v)
+        return _libqasm.string_swap(self, v)
 
     def begin(self):
-        return _libQasm.string_begin(self)
+        return _libqasm.string_begin(self)
 
     def end(self):
-        return _libQasm.string_end(self)
+        return _libqasm.string_end(self)
 
     def rbegin(self):
-        return _libQasm.string_rbegin(self)
+        return _libqasm.string_rbegin(self)
 
     def rend(self):
-        return _libQasm.string_rend(self)
+        return _libqasm.string_rend(self)
 
     def get_allocator(self):
-        return _libQasm.string_get_allocator(self)
+        return _libqasm.string_get_allocator(self)
 
     def erase(self, *args):
-        return _libQasm.string_erase(self, *args)
+        return _libqasm.string_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.string_swiginit(self, _libQasm.new_string(*args))
+        _libqasm.string_swiginit(self, _libqasm.new_string(*args))
 
     def assign(self, *args):
-        return _libQasm.string_assign(self, *args)
+        return _libqasm.string_assign(self, *args)
 
     def resize(self, *args):
-        return _libQasm.string_resize(self, *args)
+        return _libqasm.string_resize(self, *args)
 
     def iterator(self):
-        return _libQasm.string_iterator(self)
+        return _libqasm.string_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.string___nonzero__(self)
+        return _libqasm.string___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.string___bool__(self)
+        return _libqasm.string___bool__(self)
 
     def __len__(self):
-        return _libQasm.string___len__(self)
+        return _libqasm.string___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.string___getslice__(self, i, j)
+        return _libqasm.string___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.string___setslice__(self, *args)
+        return _libqasm.string___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.string___delslice__(self, i, j)
+        return _libqasm.string___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.string___delitem__(self, *args)
+        return _libqasm.string___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.string___getitem__(self, *args)
+        return _libqasm.string___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.string___setitem__(self, *args)
+        return _libqasm.string___setitem__(self, *args)
 
     def insert(self, *args):
-        return _libQasm.string_insert(self, *args)
+        return _libqasm.string_insert(self, *args)
 
     def replace(self, *args):
-        return _libQasm.string_replace(self, *args)
+        return _libqasm.string_replace(self, *args)
 
     def __iadd__(self, v):
-        return _libQasm.string___iadd__(self, v)
+        return _libqasm.string___iadd__(self, v)
 
     def __add__(self, v):
-        return _libQasm.string___add__(self, v)
+        return _libqasm.string___add__(self, v)
 
     def __radd__(self, v):
-        return _libQasm.string___radd__(self, v)
+        return _libqasm.string___radd__(self, v)
 
     def __str__(self):
-        return _libQasm.string___str__(self)
+        return _libqasm.string___str__(self)
 
     def __rlshift__(self, out):
-        return _libQasm.string___rlshift__(self, out)
+        return _libqasm.string___rlshift__(self, out)
 
     def __eq__(self, v):
-        return _libQasm.string___eq__(self, v)
+        return _libqasm.string___eq__(self, v)
 
     def __ne__(self, v):
-        return _libQasm.string___ne__(self, v)
+        return _libqasm.string___ne__(self, v)
 
     def __gt__(self, v):
-        return _libQasm.string___gt__(self, v)
+        return _libqasm.string___gt__(self, v)
 
     def __lt__(self, v):
-        return _libQasm.string___lt__(self, v)
+        return _libqasm.string___lt__(self, v)
 
     def __ge__(self, v):
-        return _libQasm.string___ge__(self, v)
+        return _libqasm.string___ge__(self, v)
 
     def __le__(self, v):
-        return _libQasm.string___le__(self, v)
-    __swig_destroy__ = _libQasm.delete_string
+        return _libqasm.string___le__(self, v)
+    __swig_destroy__ = _libqasm.delete_string
 
-# Register string in _libQasm:
-_libQasm.string_swigregister(string)
-string.npos = _libQasm.cvar.string_npos
+# Register string in _libqasm:
+_libqasm.string_swigregister(string)
+string.npos = _libqasm.cvar.string_npos
 
 class ostream(ios):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, __sb):
-        _libQasm.ostream_swiginit(self, _libQasm.new_ostream(__sb))
-    __swig_destroy__ = _libQasm.delete_ostream
+        _libqasm.ostream_swiginit(self, _libqasm.new_ostream(__sb))
+    __swig_destroy__ = _libqasm.delete_ostream
 
     def __lshift__(self, *args):
-        return _libQasm.ostream___lshift__(self, *args)
+        return _libqasm.ostream___lshift__(self, *args)
 
     def put(self, __c):
-        return _libQasm.ostream_put(self, __c)
+        return _libqasm.ostream_put(self, __c)
 
     def write(self, __s, __n):
-        return _libQasm.ostream_write(self, __s, __n)
+        return _libqasm.ostream_write(self, __s, __n)
 
     def flush(self):
-        return _libQasm.ostream_flush(self)
+        return _libqasm.ostream_flush(self)
 
     def tellp(self):
-        return _libQasm.ostream_tellp(self)
+        return _libqasm.ostream_tellp(self)
 
     def seekp(self, *args):
-        return _libQasm.ostream_seekp(self, *args)
+        return _libqasm.ostream_seekp(self, *args)
 
-# Register ostream in _libQasm:
-_libQasm.ostream_swigregister(ostream)
+# Register ostream in _libqasm:
+_libqasm.ostream_swigregister(ostream)
 cin = cvar.cin
 cout = cvar.cout
 cerr = cvar.cerr
 clog = cvar.clog
 
 class istream(ios):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, __sb):
-        _libQasm.istream_swiginit(self, _libQasm.new_istream(__sb))
-    __swig_destroy__ = _libQasm.delete_istream
+        _libqasm.istream_swiginit(self, _libqasm.new_istream(__sb))
+    __swig_destroy__ = _libqasm.delete_istream
 
     def __rshift__(self, *args):
-        return _libQasm.istream___rshift__(self, *args)
+        return _libqasm.istream___rshift__(self, *args)
 
     def gcount(self):
-        return _libQasm.istream_gcount(self)
+        return _libqasm.istream_gcount(self)
 
     def get(self, *args):
-        return _libQasm.istream_get(self, *args)
+        return _libqasm.istream_get(self, *args)
 
     def getline(self, *args):
-        return _libQasm.istream_getline(self, *args)
+        return _libqasm.istream_getline(self, *args)
 
     def ignore(self, *args):
-        return _libQasm.istream_ignore(self, *args)
+        return _libqasm.istream_ignore(self, *args)
 
     def peek(self):
-        return _libQasm.istream_peek(self)
+        return _libqasm.istream_peek(self)
 
     def read(self, __s, __n):
-        return _libQasm.istream_read(self, __s, __n)
+        return _libqasm.istream_read(self, __s, __n)
 
     def readsome(self, __s, __n):
-        return _libQasm.istream_readsome(self, __s, __n)
+        return _libqasm.istream_readsome(self, __s, __n)
 
     def putback(self, __c):
-        return _libQasm.istream_putback(self, __c)
+        return _libqasm.istream_putback(self, __c)
 
     def unget(self):
-        return _libQasm.istream_unget(self)
+        return _libqasm.istream_unget(self)
 
     def sync(self):
-        return _libQasm.istream_sync(self)
+        return _libqasm.istream_sync(self)
 
     def tellg(self):
-        return _libQasm.istream_tellg(self)
+        return _libqasm.istream_tellg(self)
 
     def seekg(self, *args):
-        return _libQasm.istream_seekg(self, *args)
+        return _libqasm.istream_seekg(self, *args)
 
-# Register istream in _libQasm:
-_libQasm.istream_swigregister(istream)
+# Register istream in _libqasm:
+_libqasm.istream_swigregister(istream)
 class iostream(istream, ostream):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, __sb):
-        _libQasm.iostream_swiginit(self, _libQasm.new_iostream(__sb))
-    __swig_destroy__ = _libQasm.delete_iostream
+        _libqasm.iostream_swiginit(self, _libqasm.new_iostream(__sb))
+    __swig_destroy__ = _libqasm.delete_iostream
 
-# Register iostream in _libQasm:
-_libQasm.iostream_swigregister(iostream)
-endl_cb_ptr = _libQasm.endl_cb_ptr
-endl = _libQasm.endl
-ends_cb_ptr = _libQasm.ends_cb_ptr
-ends = _libQasm.ends
-flush_cb_ptr = _libQasm.flush_cb_ptr
-flush = _libQasm.flush
+# Register iostream in _libqasm:
+_libqasm.iostream_swigregister(iostream)
+endl_cb_ptr = _libqasm.endl_cb_ptr
+endl = _libqasm.endl
+ends_cb_ptr = _libqasm.ends_cb_ptr
+ends = _libqasm.ends
+flush_cb_ptr = _libqasm.flush_cb_ptr
+flush = _libqasm.flush
 class vectori(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def iterator(self):
-        return _libQasm.vectori_iterator(self)
+        return _libqasm.vectori_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.vectori___nonzero__(self)
+        return _libqasm.vectori___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.vectori___bool__(self)
+        return _libqasm.vectori___bool__(self)
 
     def __len__(self):
-        return _libQasm.vectori___len__(self)
+        return _libqasm.vectori___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.vectori___getslice__(self, i, j)
+        return _libqasm.vectori___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.vectori___setslice__(self, *args)
+        return _libqasm.vectori___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.vectori___delslice__(self, i, j)
+        return _libqasm.vectori___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.vectori___delitem__(self, *args)
+        return _libqasm.vectori___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.vectori___getitem__(self, *args)
+        return _libqasm.vectori___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.vectori___setitem__(self, *args)
+        return _libqasm.vectori___setitem__(self, *args)
 
     def pop(self):
-        return _libQasm.vectori_pop(self)
+        return _libqasm.vectori_pop(self)
 
     def append(self, x):
-        return _libQasm.vectori_append(self, x)
+        return _libqasm.vectori_append(self, x)
 
     def empty(self):
-        return _libQasm.vectori_empty(self)
+        return _libqasm.vectori_empty(self)
 
     def size(self):
-        return _libQasm.vectori_size(self)
+        return _libqasm.vectori_size(self)
 
     def swap(self, v):
-        return _libQasm.vectori_swap(self, v)
+        return _libqasm.vectori_swap(self, v)
 
     def begin(self):
-        return _libQasm.vectori_begin(self)
+        return _libqasm.vectori_begin(self)
 
     def end(self):
-        return _libQasm.vectori_end(self)
+        return _libqasm.vectori_end(self)
 
     def rbegin(self):
-        return _libQasm.vectori_rbegin(self)
+        return _libqasm.vectori_rbegin(self)
 
     def rend(self):
-        return _libQasm.vectori_rend(self)
+        return _libqasm.vectori_rend(self)
 
     def clear(self):
-        return _libQasm.vectori_clear(self)
+        return _libqasm.vectori_clear(self)
 
     def get_allocator(self):
-        return _libQasm.vectori_get_allocator(self)
+        return _libqasm.vectori_get_allocator(self)
 
     def pop_back(self):
-        return _libQasm.vectori_pop_back(self)
+        return _libqasm.vectori_pop_back(self)
 
     def erase(self, *args):
-        return _libQasm.vectori_erase(self, *args)
+        return _libqasm.vectori_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.vectori_swiginit(self, _libQasm.new_vectori(*args))
+        _libqasm.vectori_swiginit(self, _libqasm.new_vectori(*args))
 
     def push_back(self, x):
-        return _libQasm.vectori_push_back(self, x)
+        return _libqasm.vectori_push_back(self, x)
 
     def front(self):
-        return _libQasm.vectori_front(self)
+        return _libqasm.vectori_front(self)
 
     def back(self):
-        return _libQasm.vectori_back(self)
+        return _libqasm.vectori_back(self)
 
     def assign(self, n, x):
-        return _libQasm.vectori_assign(self, n, x)
+        return _libqasm.vectori_assign(self, n, x)
 
     def resize(self, *args):
-        return _libQasm.vectori_resize(self, *args)
+        return _libqasm.vectori_resize(self, *args)
 
     def insert(self, *args):
-        return _libQasm.vectori_insert(self, *args)
+        return _libqasm.vectori_insert(self, *args)
 
     def reserve(self, n):
-        return _libQasm.vectori_reserve(self, n)
+        return _libqasm.vectori_reserve(self, n)
 
     def capacity(self):
-        return _libQasm.vectori_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectori
+        return _libqasm.vectori_capacity(self)
+    __swig_destroy__ = _libqasm.delete_vectori
 
-# Register vectori in _libQasm:
-_libQasm.vectori_swigregister(vectori)
+# Register vectori in _libqasm:
+_libqasm.vectori_swigregister(vectori)
 class vectorui(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def iterator(self):
-        return _libQasm.vectorui_iterator(self)
+        return _libqasm.vectorui_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.vectorui___nonzero__(self)
+        return _libqasm.vectorui___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.vectorui___bool__(self)
+        return _libqasm.vectorui___bool__(self)
 
     def __len__(self):
-        return _libQasm.vectorui___len__(self)
+        return _libqasm.vectorui___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.vectorui___getslice__(self, i, j)
+        return _libqasm.vectorui___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.vectorui___setslice__(self, *args)
+        return _libqasm.vectorui___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.vectorui___delslice__(self, i, j)
+        return _libqasm.vectorui___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.vectorui___delitem__(self, *args)
+        return _libqasm.vectorui___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.vectorui___getitem__(self, *args)
+        return _libqasm.vectorui___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.vectorui___setitem__(self, *args)
+        return _libqasm.vectorui___setitem__(self, *args)
 
     def pop(self):
-        return _libQasm.vectorui_pop(self)
+        return _libqasm.vectorui_pop(self)
 
     def append(self, x):
-        return _libQasm.vectorui_append(self, x)
+        return _libqasm.vectorui_append(self, x)
 
     def empty(self):
-        return _libQasm.vectorui_empty(self)
+        return _libqasm.vectorui_empty(self)
 
     def size(self):
-        return _libQasm.vectorui_size(self)
+        return _libqasm.vectorui_size(self)
 
     def swap(self, v):
-        return _libQasm.vectorui_swap(self, v)
+        return _libqasm.vectorui_swap(self, v)
 
     def begin(self):
-        return _libQasm.vectorui_begin(self)
+        return _libqasm.vectorui_begin(self)
 
     def end(self):
-        return _libQasm.vectorui_end(self)
+        return _libqasm.vectorui_end(self)
 
     def rbegin(self):
-        return _libQasm.vectorui_rbegin(self)
+        return _libqasm.vectorui_rbegin(self)
 
     def rend(self):
-        return _libQasm.vectorui_rend(self)
+        return _libqasm.vectorui_rend(self)
 
     def clear(self):
-        return _libQasm.vectorui_clear(self)
+        return _libqasm.vectorui_clear(self)
 
     def get_allocator(self):
-        return _libQasm.vectorui_get_allocator(self)
+        return _libqasm.vectorui_get_allocator(self)
 
     def pop_back(self):
-        return _libQasm.vectorui_pop_back(self)
+        return _libqasm.vectorui_pop_back(self)
 
     def erase(self, *args):
-        return _libQasm.vectorui_erase(self, *args)
+        return _libqasm.vectorui_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.vectorui_swiginit(self, _libQasm.new_vectorui(*args))
+        _libqasm.vectorui_swiginit(self, _libqasm.new_vectorui(*args))
 
     def push_back(self, x):
-        return _libQasm.vectorui_push_back(self, x)
+        return _libqasm.vectorui_push_back(self, x)
 
     def front(self):
-        return _libQasm.vectorui_front(self)
+        return _libqasm.vectorui_front(self)
 
     def back(self):
-        return _libQasm.vectorui_back(self)
+        return _libqasm.vectorui_back(self)
 
     def assign(self, n, x):
-        return _libQasm.vectorui_assign(self, n, x)
+        return _libqasm.vectorui_assign(self, n, x)
 
     def resize(self, *args):
-        return _libQasm.vectorui_resize(self, *args)
+        return _libqasm.vectorui_resize(self, *args)
 
     def insert(self, *args):
-        return _libQasm.vectorui_insert(self, *args)
+        return _libqasm.vectorui_insert(self, *args)
 
     def reserve(self, n):
-        return _libQasm.vectorui_reserve(self, n)
+        return _libqasm.vectorui_reserve(self, n)
 
     def capacity(self):
-        return _libQasm.vectorui_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectorui
+        return _libqasm.vectorui_capacity(self)
+    __swig_destroy__ = _libqasm.delete_vectorui
 
-# Register vectorui in _libQasm:
-_libQasm.vectorui_swigregister(vectorui)
+# Register vectorui in _libqasm:
+_libqasm.vectorui_swigregister(vectorui)
 class vectorf(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def iterator(self):
-        return _libQasm.vectorf_iterator(self)
+        return _libqasm.vectorf_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.vectorf___nonzero__(self)
+        return _libqasm.vectorf___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.vectorf___bool__(self)
+        return _libqasm.vectorf___bool__(self)
 
     def __len__(self):
-        return _libQasm.vectorf___len__(self)
+        return _libqasm.vectorf___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.vectorf___getslice__(self, i, j)
+        return _libqasm.vectorf___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.vectorf___setslice__(self, *args)
+        return _libqasm.vectorf___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.vectorf___delslice__(self, i, j)
+        return _libqasm.vectorf___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.vectorf___delitem__(self, *args)
+        return _libqasm.vectorf___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.vectorf___getitem__(self, *args)
+        return _libqasm.vectorf___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.vectorf___setitem__(self, *args)
+        return _libqasm.vectorf___setitem__(self, *args)
 
     def pop(self):
-        return _libQasm.vectorf_pop(self)
+        return _libqasm.vectorf_pop(self)
 
     def append(self, x):
-        return _libQasm.vectorf_append(self, x)
+        return _libqasm.vectorf_append(self, x)
 
     def empty(self):
-        return _libQasm.vectorf_empty(self)
+        return _libqasm.vectorf_empty(self)
 
     def size(self):
-        return _libQasm.vectorf_size(self)
+        return _libqasm.vectorf_size(self)
 
     def swap(self, v):
-        return _libQasm.vectorf_swap(self, v)
+        return _libqasm.vectorf_swap(self, v)
 
     def begin(self):
-        return _libQasm.vectorf_begin(self)
+        return _libqasm.vectorf_begin(self)
 
     def end(self):
-        return _libQasm.vectorf_end(self)
+        return _libqasm.vectorf_end(self)
 
     def rbegin(self):
-        return _libQasm.vectorf_rbegin(self)
+        return _libqasm.vectorf_rbegin(self)
 
     def rend(self):
-        return _libQasm.vectorf_rend(self)
+        return _libqasm.vectorf_rend(self)
 
     def clear(self):
-        return _libQasm.vectorf_clear(self)
+        return _libqasm.vectorf_clear(self)
 
     def get_allocator(self):
-        return _libQasm.vectorf_get_allocator(self)
+        return _libqasm.vectorf_get_allocator(self)
 
     def pop_back(self):
-        return _libQasm.vectorf_pop_back(self)
+        return _libqasm.vectorf_pop_back(self)
 
     def erase(self, *args):
-        return _libQasm.vectorf_erase(self, *args)
+        return _libqasm.vectorf_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.vectorf_swiginit(self, _libQasm.new_vectorf(*args))
+        _libqasm.vectorf_swiginit(self, _libqasm.new_vectorf(*args))
 
     def push_back(self, x):
-        return _libQasm.vectorf_push_back(self, x)
+        return _libqasm.vectorf_push_back(self, x)
 
     def front(self):
-        return _libQasm.vectorf_front(self)
+        return _libqasm.vectorf_front(self)
 
     def back(self):
-        return _libQasm.vectorf_back(self)
+        return _libqasm.vectorf_back(self)
 
     def assign(self, n, x):
-        return _libQasm.vectorf_assign(self, n, x)
+        return _libqasm.vectorf_assign(self, n, x)
 
     def resize(self, *args):
-        return _libQasm.vectorf_resize(self, *args)
+        return _libqasm.vectorf_resize(self, *args)
 
     def insert(self, *args):
-        return _libQasm.vectorf_insert(self, *args)
+        return _libqasm.vectorf_insert(self, *args)
 
     def reserve(self, n):
-        return _libQasm.vectorf_reserve(self, n)
+        return _libqasm.vectorf_reserve(self, n)
 
     def capacity(self):
-        return _libQasm.vectorf_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectorf
+        return _libqasm.vectorf_capacity(self)
+    __swig_destroy__ = _libqasm.delete_vectorf
 
-# Register vectorf in _libQasm:
-_libQasm.vectorf_swigregister(vectorf)
+# Register vectorf in _libqasm:
+_libqasm.vectorf_swigregister(vectorf)
 class vectord(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def iterator(self):
-        return _libQasm.vectord_iterator(self)
+        return _libqasm.vectord_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.vectord___nonzero__(self)
+        return _libqasm.vectord___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.vectord___bool__(self)
+        return _libqasm.vectord___bool__(self)
 
     def __len__(self):
-        return _libQasm.vectord___len__(self)
+        return _libqasm.vectord___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.vectord___getslice__(self, i, j)
+        return _libqasm.vectord___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.vectord___setslice__(self, *args)
+        return _libqasm.vectord___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.vectord___delslice__(self, i, j)
+        return _libqasm.vectord___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.vectord___delitem__(self, *args)
+        return _libqasm.vectord___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.vectord___getitem__(self, *args)
+        return _libqasm.vectord___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.vectord___setitem__(self, *args)
+        return _libqasm.vectord___setitem__(self, *args)
 
     def pop(self):
-        return _libQasm.vectord_pop(self)
+        return _libqasm.vectord_pop(self)
 
     def append(self, x):
-        return _libQasm.vectord_append(self, x)
+        return _libqasm.vectord_append(self, x)
 
     def empty(self):
-        return _libQasm.vectord_empty(self)
+        return _libqasm.vectord_empty(self)
 
     def size(self):
-        return _libQasm.vectord_size(self)
+        return _libqasm.vectord_size(self)
 
     def swap(self, v):
-        return _libQasm.vectord_swap(self, v)
+        return _libqasm.vectord_swap(self, v)
 
     def begin(self):
-        return _libQasm.vectord_begin(self)
+        return _libqasm.vectord_begin(self)
 
     def end(self):
-        return _libQasm.vectord_end(self)
+        return _libqasm.vectord_end(self)
 
     def rbegin(self):
-        return _libQasm.vectord_rbegin(self)
+        return _libqasm.vectord_rbegin(self)
 
     def rend(self):
-        return _libQasm.vectord_rend(self)
+        return _libqasm.vectord_rend(self)
 
     def clear(self):
-        return _libQasm.vectord_clear(self)
+        return _libqasm.vectord_clear(self)
 
     def get_allocator(self):
-        return _libQasm.vectord_get_allocator(self)
+        return _libqasm.vectord_get_allocator(self)
 
     def pop_back(self):
-        return _libQasm.vectord_pop_back(self)
+        return _libqasm.vectord_pop_back(self)
 
     def erase(self, *args):
-        return _libQasm.vectord_erase(self, *args)
+        return _libqasm.vectord_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.vectord_swiginit(self, _libQasm.new_vectord(*args))
+        _libqasm.vectord_swiginit(self, _libqasm.new_vectord(*args))
 
     def push_back(self, x):
-        return _libQasm.vectord_push_back(self, x)
+        return _libqasm.vectord_push_back(self, x)
 
     def front(self):
-        return _libQasm.vectord_front(self)
+        return _libqasm.vectord_front(self)
 
     def back(self):
-        return _libQasm.vectord_back(self)
+        return _libqasm.vectord_back(self)
 
     def assign(self, n, x):
-        return _libQasm.vectord_assign(self, n, x)
+        return _libqasm.vectord_assign(self, n, x)
 
     def resize(self, *args):
-        return _libQasm.vectord_resize(self, *args)
+        return _libqasm.vectord_resize(self, *args)
 
     def insert(self, *args):
-        return _libQasm.vectord_insert(self, *args)
+        return _libqasm.vectord_insert(self, *args)
 
     def reserve(self, n):
-        return _libQasm.vectord_reserve(self, n)
+        return _libqasm.vectord_reserve(self, n)
 
     def capacity(self):
-        return _libQasm.vectord_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectord
+        return _libqasm.vectord_capacity(self)
+    __swig_destroy__ = _libqasm.delete_vectord
 
-# Register vectord in _libQasm:
-_libQasm.vectord_swigregister(vectord)
+# Register vectord in _libqasm:
+_libqasm.vectord_swigregister(vectord)
 class vectors(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def iterator(self):
-        return _libQasm.vectors_iterator(self)
+        return _libqasm.vectors_iterator(self)
     def __iter__(self):
         return self.iterator()
 
     def __nonzero__(self):
-        return _libQasm.vectors___nonzero__(self)
+        return _libqasm.vectors___nonzero__(self)
 
     def __bool__(self):
-        return _libQasm.vectors___bool__(self)
+        return _libqasm.vectors___bool__(self)
 
     def __len__(self):
-        return _libQasm.vectors___len__(self)
+        return _libqasm.vectors___len__(self)
 
     def __getslice__(self, i, j):
-        return _libQasm.vectors___getslice__(self, i, j)
+        return _libqasm.vectors___getslice__(self, i, j)
 
     def __setslice__(self, *args):
-        return _libQasm.vectors___setslice__(self, *args)
+        return _libqasm.vectors___setslice__(self, *args)
 
     def __delslice__(self, i, j):
-        return _libQasm.vectors___delslice__(self, i, j)
+        return _libqasm.vectors___delslice__(self, i, j)
 
     def __delitem__(self, *args):
-        return _libQasm.vectors___delitem__(self, *args)
+        return _libqasm.vectors___delitem__(self, *args)
 
     def __getitem__(self, *args):
-        return _libQasm.vectors___getitem__(self, *args)
+        return _libqasm.vectors___getitem__(self, *args)
 
     def __setitem__(self, *args):
-        return _libQasm.vectors___setitem__(self, *args)
+        return _libqasm.vectors___setitem__(self, *args)
 
     def pop(self):
-        return _libQasm.vectors_pop(self)
+        return _libqasm.vectors_pop(self)
 
     def append(self, x):
-        return _libQasm.vectors_append(self, x)
+        return _libqasm.vectors_append(self, x)
 
     def empty(self):
-        return _libQasm.vectors_empty(self)
+        return _libqasm.vectors_empty(self)
 
     def size(self):
-        return _libQasm.vectors_size(self)
+        return _libqasm.vectors_size(self)
 
     def swap(self, v):
-        return _libQasm.vectors_swap(self, v)
+        return _libqasm.vectors_swap(self, v)
 
     def begin(self):
-        return _libQasm.vectors_begin(self)
+        return _libqasm.vectors_begin(self)
 
     def end(self):
-        return _libQasm.vectors_end(self)
+        return _libqasm.vectors_end(self)
 
     def rbegin(self):
-        return _libQasm.vectors_rbegin(self)
+        return _libqasm.vectors_rbegin(self)
 
     def rend(self):
-        return _libQasm.vectors_rend(self)
+        return _libqasm.vectors_rend(self)
 
     def clear(self):
-        return _libQasm.vectors_clear(self)
+        return _libqasm.vectors_clear(self)
 
     def get_allocator(self):
-        return _libQasm.vectors_get_allocator(self)
+        return _libqasm.vectors_get_allocator(self)
 
     def pop_back(self):
-        return _libQasm.vectors_pop_back(self)
+        return _libqasm.vectors_pop_back(self)
 
     def erase(self, *args):
-        return _libQasm.vectors_erase(self, *args)
+        return _libqasm.vectors_erase(self, *args)
 
     def __init__(self, *args):
-        _libQasm.vectors_swiginit(self, _libQasm.new_vectors(*args))
+        _libqasm.vectors_swiginit(self, _libqasm.new_vectors(*args))
 
     def push_back(self, x):
-        return _libQasm.vectors_push_back(self, x)
+        return _libqasm.vectors_push_back(self, x)
 
     def front(self):
-        return _libQasm.vectors_front(self)
+        return _libqasm.vectors_front(self)
 
     def back(self):
-        return _libQasm.vectors_back(self)
+        return _libqasm.vectors_back(self)
 
     def assign(self, n, x):
-        return _libQasm.vectors_assign(self, n, x)
+        return _libqasm.vectors_assign(self, n, x)
 
     def resize(self, *args):
-        return _libQasm.vectors_resize(self, *args)
+        return _libqasm.vectors_resize(self, *args)
 
     def insert(self, *args):
-        return _libQasm.vectors_insert(self, *args)
+        return _libqasm.vectors_insert(self, *args)
 
     def reserve(self, n):
-        return _libQasm.vectors_reserve(self, n)
+        return _libqasm.vectors_reserve(self, n)
 
     def capacity(self):
-        return _libQasm.vectors_capacity(self)
-    __swig_destroy__ = _libQasm.delete_vectors
+        return _libqasm.vectors_capacity(self)
+    __swig_destroy__ = _libqasm.delete_vectors
 
-# Register vectors in _libQasm:
-_libQasm.vectors_swigregister(vectors)
+# Register vectors in _libqasm:
+_libqasm.vectors_swigregister(vectors)
 class V3xAnalyzer(object):
     thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
     __repr__ = _swig_repr
 
     def __init__(self, *args):
-        _libQasm.V3xAnalyzer_swiginit(self, _libQasm.new_V3xAnalyzer(*args))
-    __swig_destroy__ = _libQasm.delete_V3xAnalyzer
+        _libqasm.V3xAnalyzer_swiginit(self, _libqasm.new_V3xAnalyzer(*args))
+    __swig_destroy__ = _libqasm.delete_V3xAnalyzer
 
     def register_instruction(self, *args):
-        return _libQasm.V3xAnalyzer_register_instruction(self, *args)
+        return _libqasm.V3xAnalyzer_register_instruction(self, *args)
 
     @staticmethod
     def parse_file(file_name):
-        return _libQasm.V3xAnalyzer_parse_file(file_name)
+        return _libqasm.V3xAnalyzer_parse_file(file_name)
 
     @staticmethod
     def parse_file_to_json(file_name):
-        return _libQasm.V3xAnalyzer_parse_file_to_json(file_name)
+        return _libqasm.V3xAnalyzer_parse_file_to_json(file_name)
 
     @staticmethod
     def parse_string(*args):
-        return _libQasm.V3xAnalyzer_parse_string(*args)
+        return _libqasm.V3xAnalyzer_parse_string(*args)
 
     @staticmethod
     def parse_string_to_json(*args):
-        return _libQasm.V3xAnalyzer_parse_string_to_json(*args)
+        return _libqasm.V3xAnalyzer_parse_string_to_json(*args)
 
     def analyze_file(self, file_name):
-        return _libQasm.V3xAnalyzer_analyze_file(self, file_name)
+        return _libqasm.V3xAnalyzer_analyze_file(self, file_name)
 
     def analyze_file_to_json(self, file_name):
-        return _libQasm.V3xAnalyzer_analyze_file_to_json(self, file_name)
+        return _libqasm.V3xAnalyzer_analyze_file_to_json(self, file_name)
 
     def analyze_string(self, *args):
-        return _libQasm.V3xAnalyzer_analyze_string(self, *args)
+        return _libqasm.V3xAnalyzer_analyze_string(self, *args)
 
     def analyze_string_to_json(self, *args):
-        return _libQasm.V3xAnalyzer_analyze_string_to_json(self, *args)
+        return _libqasm.V3xAnalyzer_analyze_string_to_json(self, *args)
 
-# Register V3xAnalyzer in _libQasm:
-_libQasm.V3xAnalyzer_swigregister(V3xAnalyzer)
+# Register V3xAnalyzer in _libqasm:
+_libqasm.V3xAnalyzer_swigregister(V3xAnalyzer)
```

## Comparing `libqasm-0.6.5.dist-info/LICENSE.md` & `libqasm-0.6.6.dist-info/LICENSE.md`

 * *Files identical despite different names*

## Comparing `libqasm-0.6.5.dist-info/METADATA` & `libqasm-0.6.6.dist-info/METADATA`

 * *Files 18% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 Metadata-Version: 2.1
 Name: libqasm
-Version: 0.6.5
-Summary: libQasm Python Package
+Version: 0.6.6
+Summary: libqasm Python Package
 Home-page: https://github.com/QuTech-Delft/libqasm
 Author: QuTech, TU Delft
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: POSIX :: Linux
 Classifier: Operating System :: MacOS
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Programming Language :: Python :: 3 :: Only
@@ -76,36 +76,42 @@
 - the `conan profile` command only has to be run only once, and not before every build.
 - the `conan build` command is building `libqasm` in Debug mode with tests using the `tests-debug` profile.
 - the `-b missing` parameter asks `conan` to build packages from sources
 in case it cannot find the binary packages for the current configuration (platform, OS, compiler, build type...). 
 
 ### Build profiles
 
-A group of predefined profiles is provided under the `conan/profiles` folder.
-They follow the `[tests-](debug|release)[-compat]` naming convention. For example:
-  - `release` is a Release build without tests and compatibility with the original API.
-  - `tests-debug-compat` is a Debug build with tests and compatibility enabled.
+A group of predefined profiles is provided under the `conan/profiles` folder.<br/>
+They follow the `[tests](-build_type)(-compiler)(-os)(-arch)[-shared]` naming convention:
+  - `tests`: if tests are being built.
+  - `build_type`: can be `debug` or `release`.
+  - `compiler`: `apple-clang`, `clang`, `gcc`, `msvc`.
+  - `os`: `emscripten`, `linux`, `macos`, `windows`.
+  - `arch`: `arm64`, `wasm`, `x64`.
+  - `shared`: if the library is being built in shared mode.
 
-All the profiles set the C++ standard to 20. All the `tests` profiles enable Address Sanitizer.
+All the profiles set the C++ standard to 20.<br/>
+All the `tests`, except for `linux-x64` profiles, enable Address Sanitizer.
 
 ### Build options
 
-Profiles are a shorthand for command line options. The command above could be written as well as: 
+Profiles are a shorthand for command line options. The command above could be written, similarly,  as: 
 
 ```
-conan build . -s:h compiler.cppstd=20 -s:h libqasm/*:build_type=Debug -o libqasm/*:build_tests=True -o libqasm/*:asan_enabled=True -b missing
+conan build . -s:a compiler.cppstd=20 -s:a libqasm/*:build_type=Debug -o libqasm/*:build_tests=True -o libqasm/*:asan_enabled=True -b missing
 ```
 
-These are the list of options that could be specified whether in a profile or in the command line:
+This is the list of options that could be specified either in a profile or in the command line:
 
 - `libqasm/*:asan_enabled={True,False}`: enables Address Sanitizer.
-- `libqasm/*:build_tests={True,False}`: builds tests or not.
 - `libqasm/*:build_type={Debug,Release}`: builds in debug or release mode.
 - `libqasm/*:shared={True,False}`: builds a shared object library instead of a static library, if applicable.
 
+Tests are enabled by default. To disable them, use `-c tools.build:skip_test=True`.
+
 ## Install
 
 ### From Python
 
 Install from the project root directory as follows:
 
 ```
@@ -119,72 +125,100 @@
 ```
 
 ### From C++
 
 The `CMakeLists.txt` file in the root directory includes install targets:
 
 ```
-conan create --version 0.5.2 . -pr=tests-debug -b missing
+conan create --version 0.6.6 . -pr:a=tests-debug -b missing
 ```
 
 You can test if it works by doing:
 
 ```
 cd test/Debug
 ctest -C Debug --output-on-failure
 ```
 
 ## Use from another project
 
 ### From Python
 
-After installation, you should be able to use the bindings for the original API by just `import libQasm`.
-The new API doesn't have Python bindings yet.
+The `libqasm` module should provide access to the `V3xAnalyzer` API:
+- `parse_file`,
+- `parse_string`,
+- `analyze_file`, and
+- `analyzer_string`.
+
+The `cqasm.v3x` module is also available for a more fine-grained use of the library.
+
+```
+import cqasm.v3x.ast
+import cqasm.v3x.instruction
+import cqasm.v3x.primitives
+import cqasm.v3x.semantic
+import cqasm.v3x.types
+import cqasm.v3x.values
+```
 
 ### From C++
 
-The easiest way to use `libqasm` in a CMake project is to fetch the library and then link against it.
+`libqasm` can be requested as a Conan package from a `conanfile.py`.
 
 ```
-include(FetchContent)
-FetchContent_Declare(cqasm
-    GIT_REPOSITORY https://github.com/QuTech-Delft/libqasm.git
-    GIT_TAG "<a given cqasm git tag>"
-)
-FetchContent_MakeAvailable(cqasm)
-target_include_directories(<your target> SYSTEM PRIVATE "${cqasm_SOURCE_DIR}/include")
-target_link_libraries(<your target> PUBLIC cqasm)
+def build_requirements(self):
+    self.tool_requires("libqasm/0.6.5")
+def requirements(self):
+    self.requires("libqasm/0.6.5")
+```
+
+And then linked against from a `CMakeLists.txt`: 
+
+```
+target_link_libraries(<your target> PUBLIC libqasm::libqasm)
 ```
 
 Note that the following dependency is required for `libqasm` to build:
 
 * `Java JRE` >= 11
 
-The original API headers are *not* included by default.
-To enable those, pass <code><nobr>-o libqasm/*:compat=True</nobr></code> as a build option to Conan.
+The header file `cqasm.hpp` should provide access to the following API:
+- `cqasm::v3x::analyze_file`, and
+- `cqasm::v3x::analyze_string`.
+
+Again, other header files are available for a more fine-grained use of the library.
 
 ## Docker
 
 This tests the library in a container with the bare minimum requirements for `libqasm`.
 
 ```
 docker build .
 ```
 
-**Note for Windows users:** The above might fail on Windows to the autocrlf transformation that git does.
+**Note for Windows users:** The above might fail on Windows due to the `autocrlf` transformation that git does.
 If you are having trouble with this just create new clone of this repository using:
 
 ```
 git clone --config core.autocrlf=input git@github.com:QuTech-Delft/libqasm.git
 ```
 
 ## Emscripten
 
 The generation of emscripten binaries has been tested as a cross-compilation from an ubuntu/x64 platform.
 
 ```
-conan build . -pr=conan/profiles/emscripten -pr:b=conan/profiles/release -b missing
+conan build . -pr=conan/profiles/release-clang-emscripten-wasm -pr:b=conan/profiles/release -b missing
 ```
 
 The output of this build lives in `build/Release/emscripten`:
 - `cqasm_emscripten.js`.
 - `cqasm_emscripten.wasm`.
+
+Note that `cqasm_emscripten.js` is an ES6 module. An example of how to use it would be:
+
+```
+cd build/Release/emscripten
+mv cqasm_emscripten.js cqasm_emscripten.mjs
+cd ../../../emscripten
+deno run -A test_libqasm.ts
+```
```

