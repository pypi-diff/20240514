# Comparing `tmp/rms_oops-0.0.3.tar.gz` & `tmp/rms_oops-0.0.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "rms_oops-0.0.3.tar", last modified: Wed Apr 17 04:22:36 2024, max compression
+gzip compressed data, was "rms_oops-0.0.4.tar", last modified: Tue May 14 19:16:39 2024, max compression
```

## Comparing `rms_oops-0.0.3.tar` & `rms_oops-0.0.4.tar`

### file list

```diff
@@ -1,304 +1,461 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.535551 rms_oops-0.0.3/
--rw-r--r--   0 runner    (1001) docker     (127)      187 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.coveragerc
--rw-r--r--   0 runner    (1001) docker     (127)      263 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.flake8
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.487551 rms_oops-0.0.3/.github/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.491551 rms_oops-0.0.3/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (127)      765 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.github/workflows/publish_to_pypi.yml
--rw-r--r--   0 runner    (1001) docker     (127)      882 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.github/workflows/publish_to_test_pypi.yml
--rw-r--r--   0 runner    (1001) docker     (127)      736 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.github/workflows/run-lint.yml
--rw-r--r--   0 runner    (1001) docker     (127)     1938 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.github/workflows/run-tests.yml
--rw-r--r--   0 runner    (1001) docker     (127)     1077 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.github/workflows/run-windows-tests.yml
--rwxr-xr-x   0 runner    (1001) docker     (127)     3185 2024-04-17 04:22:09.000000 rms_oops-0.0.3/.gitignore
--rw-r--r--   0 runner    (1001) docker     (127)     5487 2024-04-17 04:22:09.000000 rms_oops-0.0.3/CODE_OF_CONDUCT.md
--rw-r--r--   0 runner    (1001) docker     (127)     7089 2024-04-17 04:22:09.000000 rms_oops-0.0.3/CONTRIBUTING.md
--rw-r--r--   0 runner    (1001) docker     (127)    10494 2024-04-17 04:22:09.000000 rms_oops-0.0.3/LICENSE.md
--rw-r--r--   0 runner    (1001) docker     (127)     4004 2024-04-17 04:22:36.535551 rms_oops-0.0.3/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     2293 2024-04-17 04:22:09.000000 rms_oops-0.0.3/README.md
--rw-r--r--   0 runner    (1001) docker     (127)      142 2024-04-17 04:22:09.000000 rms_oops-0.0.3/codecov.yml
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.491551 rms_oops-0.0.3/ideas/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.495551 rms_oops-0.0.3/ideas/cmodel_/
--rwxr-xr-x   0 runner    (1001) docker     (127)      589 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3926 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/cmodel.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2174 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/distance.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1887 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/latitude.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2202 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/longitude.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2020 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/radius.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      652 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/cmodel_/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.495551 rms_oops-0.0.3/ideas/format_/
--rwxr-xr-x   0 runner    (1001) docker     (127)      476 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/format_/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1193 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/format_/format.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4732 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/format_/hms.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1362 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/format_/pythonfmt.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      534 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/format_/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.495551 rms_oops-0.0.3/ideas/gll_ssi_masked/
--rwxr-xr-x   0 runner    (1001) docker     (127)    43215 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/gll_ssi_masked/backplane-__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    45411 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/gll_ssi_masked/observation-__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    14081 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/gll_ssi_masked/ssi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.495551 rms_oops-0.0.3/ideas/multipath/
--rw-r--r--   0 runner    (1001) docker     (127)     9369 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/multipath/multipath.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.495551 rms_oops-0.0.3/ideas/nav_/
--rwxr-xr-x   0 runner    (1001) docker     (127)      186 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6666 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/navigation.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2149 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/nullnav.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6451 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/platescale.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    10583 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/repointing.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4459 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/timeshift.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      583 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/nav_/unittester.py
--rw-r--r--   0 runner    (1001) docker     (127)     5851 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_frame_interpolation_using_matrix3.py.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.499551 rms_oops-0.0.3/ideas/old_observation_subclasses/
--rwxr-xr-x   0 runner    (1001) docker     (127)    21539 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_observation_subclasses/pushbroom.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19409 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_observation_subclasses/pushframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    28460 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_observation_subclasses/rasterscan.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    28080 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_observation_subclasses/rasterslit.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22312 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/old_observation_subclasses/slit.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.499551 rms_oops-0.0.3/ideas/packrat/
--rwxr-xr-x   0 runner    (1001) docker     (127)      318 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/packrat/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    41206 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/packrat/packrat.py
--rw-r--r--   0 runner    (1001) docker     (127)    47188 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/packrat/packrat_arrays.py
--rw-r--r--   0 runner    (1001) docker     (127)      419 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/packrat/packrat_entities.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      585 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/packrat/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    16085 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/poleframe-with-tilt.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8574 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/registry.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.499551 rms_oops-0.0.3/ideas/shape2d/
--rwxr-xr-x   0 runner    (1001) docker     (127)    10775 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8755 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/affine.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     7004 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/arc.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    15556 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/circle.py
--rw-r--r--   0 runner    (1001) docker     (127)     9967 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/conic.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    32925 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/ellipse.py
--rw-r--r--   0 runner    (1001) docker     (127)    29842 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/line.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     9657 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/point.py
--rw-r--r--   0 runner    (1001) docker     (127)    18016 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/polygon.py
--rw-r--r--   0 runner    (1001) docker     (127)    18263 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/shape2d/triangle.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.503551 rms_oops-0.0.3/ideas/spice_starcat/
--rwxr-xr-x   0 runner    (1001) docker     (127)     2011 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1010 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/make.sh
--rwxr-xr-x   0 runner    (1001) docker     (127)     6395 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01.i
--rwxr-xr-x   0 runner    (1001) docker     (127)     2543 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4738 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01_interface.f
--rwxr-xr-x   0 runner    (1001) docker     (127)   118981 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01_wrap.c
--rwxr-xr-x   0 runner    (1001) docker     (127)     3909 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/spice_starcat/strings.f
--rwxr-xr-x   0 runner    (1001) docker     (127)    17339 2024-04-17 04:22:09.000000 rms_oops-0.0.3/ideas/wobble.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.503551 rms_oops-0.0.3/oops/
--rw-r--r--   0 runner    (1001) docker     (127)      179 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/.coveragerc
--rwxr-xr-x   0 runner    (1001) docker     (127)     2561 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      411 2024-04-17 04:22:36.000000 rms_oops-0.0.3/oops/_version.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.507551 rms_oops-0.0.3/oops/backplane/
--rwxr-xr-x   0 runner    (1001) docker     (127)    38796 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      805 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    14163 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/ansa.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6927 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/border.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     7763 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/distance.py
--rw-r--r--   0 runner    (1001) docker     (127)    99884 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/gold_master.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21419 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/lighting.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    11587 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/limb.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5028 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/orbit.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3419 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/pole.py
--rw-r--r--   0 runner    (1001) docker     (127)     5940 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/resolution.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    51688 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/ring.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    14140 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/sky.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    24260 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/spheroid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21353 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/backplane/where.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    70794 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/body.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.507551 rms_oops-0.0.3/oops/cadence/
--rwxr-xr-x   0 runner    (1001) docker     (127)    11134 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      761 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    29573 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/dualcadence.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6309 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/instant.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    57751 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/metronome.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    33319 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/reshapedcadence.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12198 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/reversedcadence.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    18725 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/sequence.py
--rw-r--r--   0 runner    (1001) docker     (127)    38812 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/tdicadence.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      847 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/cadence/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.511551 rms_oops-0.0.3/oops/calibration/
--rwxr-xr-x   0 runner    (1001) docker     (127)     7969 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      768 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4360 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/extendedsource.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    14220 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/flatcalib.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4378 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/nullcalib.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5029 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/pointsource.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    13369 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/radiance.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    13101 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/rawcounts.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      844 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/calibration/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21255 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/config.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      760 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/constants.py
--rwxr-xr-x   0 runner    (1001) docker     (127)   106278 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/event.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3101 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fittable.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.511551 rms_oops-0.0.3/oops/fov/
--rw-r--r--   0 runner    (1001) docker     (127)    36798 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      898 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    28001 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/barrelfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6323 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/flatfov.py
--rw-r--r--   0 runner    (1001) docker     (127)     5417 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/gapfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12271 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/nullfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6558 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/offsetfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    25290 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/polyfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    26924 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/polynomialfov.py
--rw-r--r--   0 runner    (1001) docker     (127)    26746 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/radialfov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4379 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/slicefov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6518 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/subarray.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6898 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/subsampledfov.py
--rw-r--r--   0 runner    (1001) docker     (127)     9945 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/tdifov.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      976 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/unittester.py
--rw-r--r--   0 runner    (1001) docker     (127)    28721 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/fov/wcsfov.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.515551 rms_oops-0.0.3/oops/frame/
--rwxr-xr-x   0 runner    (1001) docker     (127)    53937 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1202 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    13069 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/cmatrix.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6173 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/inclinedframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     9979 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/laplaceframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     6010 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/navigation.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19982 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/poleframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4319 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/postargframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    11327 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/ringframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5977 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/rotation.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    32685 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/spiceframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8859 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/spicetype1frame.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8328 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/spinframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5278 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/synchronousframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     7293 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/trackerframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5678 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/twovectorframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1239 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/frame/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.515551 rms_oops-0.0.3/oops/gravity/
--rwxr-xr-x   0 runner    (1001) docker     (127)     5019 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/gravity/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      444 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/gravity/all.py
--rw-r--r--   0 runner    (1001) docker     (127)    43227 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/gravity/oblategravity.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.515551 rms_oops-0.0.3/oops/hosts/
--rwxr-xr-x   0 runner    (1001) docker     (127)      186 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/cassini/
--rwxr-xr-x   0 runner    (1001) docker     (127)    15843 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      468 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/gold_master.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    24835 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/iss.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22276 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/iss_test_suite.py
--rw-r--r--   0 runner    (1001) docker     (127)     1425 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/standard_obs.py
--rw-r--r--   0 runner    (1001) docker     (127)      455 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21289 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/uvis.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    23388 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/uvis_test_suite.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    38560 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/vims.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22140 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/cassini/vims_test_suite.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/galileo/
--rwxr-xr-x   0 runner    (1001) docker     (127)    12002 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/galileo/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/galileo/ssi/
--rwxr-xr-x   0 runner    (1001) docker     (127)    15506 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/galileo/ssi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      476 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/galileo/ssi/gold_master.py
--rw-r--r--   0 runner    (1001) docker     (127)     6242 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/galileo/ssi/standard_obs.py
--rw-r--r--   0 runner    (1001) docker     (127)      459 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/galileo/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/hst/
--rwxr-xr-x   0 runner    (1001) docker     (127)    44796 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/hst/acs/
--rwxr-xr-x   0 runner    (1001) docker     (127)     3948 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/acs/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4937 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/acs/hrc.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3920 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/acs/sbc.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     7378 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/acs/wfc.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.519551 rms_oops-0.0.3/oops/hosts/hst/nicmos/
--rwxr-xr-x   0 runner    (1001) docker     (127)     6143 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/nicmos/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/nicmos/nic1.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/nicmos/nic2.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2621 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/nicmos/nic3.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      422 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/hst/wfc3/
--rwxr-xr-x   0 runner    (1001) docker     (127)     2925 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4953 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3/ir.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5224 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3/uvis.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2501 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3/wfc3_pointing_test.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     9572 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3/wfc3_test_suite.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3653 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3_pointing_test.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12677 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfc3_test_suite.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    12280 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/hst/wfpc2.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/juno/
--rw-r--r--   0 runner    (1001) docker     (127)    20306 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/juno/jiram/
--rw-r--r--   0 runner    (1001) docker     (127)     9855 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/jiram/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10360 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/jiram/img.py
--rw-r--r--   0 runner    (1001) docker     (127)     8169 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/jiram/spe.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/juno/junocam/
--rw-r--r--   0 runner    (1001) docker     (127)    19494 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/junocam/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      474 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/junocam/gold_master.py
--rw-r--r--   0 runner    (1001) docker     (127)     4956 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/junocam/standard_obs.py
--rw-r--r--   0 runner    (1001) docker     (127)      522 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/juno/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/jwst/
--rwxr-xr-x   0 runner    (1001) docker     (127)    21414 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/jwst/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/jwst/nircam/
--rwxr-xr-x   0 runner    (1001) docker     (127)     8235 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/jwst/nircam/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    30553 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/jwst/nircam/uncal.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/keck/
--rwxr-xr-x   0 runner    (1001) docker     (127)     8715 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/keck/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/keck/nirc2/
--rwxr-xr-x   0 runner    (1001) docker     (127)     7939 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/keck/nirc2/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5195 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/keck/nirc2.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/newhorizons/
--rwxr-xr-x   0 runner    (1001) docker     (127)     5645 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/newhorizons/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    27031 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/newhorizons/lorri.py
--rw-r--r--   0 runner    (1001) docker     (127)    13865 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/pds3.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      732 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.523551 rms_oops-0.0.3/oops/hosts/voyager/
--rwxr-xr-x   0 runner    (1001) docker     (127)      195 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/voyager/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    18987 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/hosts/voyager/iss.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    14693 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/lightsource.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    17836 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/meshgrid.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.527552 rms_oops-0.0.3/oops/observation/
--rw-r--r--   0 runner    (1001) docker     (127)     3488 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/NOTES-ABOUT-OBSERVATION-CLASSES.txt
--rwxr-xr-x   0 runner    (1001) docker     (127)    49568 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1115 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/all.py
--rw-r--r--   0 runner    (1001) docker     (127)     3589 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/insitu.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19395 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/pixel.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21226 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/pushbroom.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    20422 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/pushframe.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    28362 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/rasterscan.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    29161 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/rasterslit.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    20723 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/rasterslit1d.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22030 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/slit.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    15007 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/slit1d.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    32370 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/snapshot.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    70170 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/timedimage.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1173 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/observation/unittester.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.527552 rms_oops-0.0.3/oops/path/
--rwxr-xr-x   0 runner    (1001) docker     (127)    64953 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      839 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     5711 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/circlepath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3428 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/coordpath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3035 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/fixedpath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    43443 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/keplerpath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3887 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/linearcoordpath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3890 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/linearpath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     9284 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/multipath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    37286 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/spicepath.py
--rwxr-xr-x   0 runner    (1001) docker     (127)      769 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/path/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     4916 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/spice_support.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.531551 rms_oops-0.0.3/oops/surface/
--rwxr-xr-x   0 runner    (1001) docker     (127)    84590 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1089 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/all.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19898 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/ansa.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    21862 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/centricellipsoid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19297 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/centricspheroid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    41671 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/ellipsoid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22354 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/graphicellipsoid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    19326 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/graphicspheroid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    46515 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/limb.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     8942 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/nullsurface.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    28328 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/orbitplane.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     9076 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/polarlimb.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    22063 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/ringplane.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    25602 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/spheroid.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3250 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/spice_shape.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1261 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/surface/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    18045 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/transform.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     1014 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/unittester.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2744 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/unittester_support.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    18859 2024-04-17 04:22:09.000000 rms_oops-0.0.3/oops/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     1721 2024-04-17 04:22:09.000000 rms_oops-0.0.3/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (127)      293 2024-04-17 04:22:09.000000 rms_oops-0.0.3/requirements.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.531551 rms_oops-0.0.3/rms_oops.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     4004 2024-04-17 04:22:36.000000 rms_oops-0.0.3/rms_oops.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     7013 2024-04-17 04:22:36.000000 rms_oops-0.0.3/rms_oops.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-04-17 04:22:36.000000 rms_oops-0.0.3/rms_oops.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)      161 2024-04-17 04:22:36.000000 rms_oops-0.0.3/rms_oops.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       13 2024-04-17 04:22:36.000000 rms_oops-0.0.3/rms_oops.egg-info/top_level.txt
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.491551 rms_oops-0.0.3/scripts/
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.531551 rms_oops-0.0.3/scripts/automated_tests/
--rwxr-xr-x   0 runner    (1001) docker     (127)     1604 2024-04-17 04:22:09.000000 rms_oops-0.0.3/scripts/automated_tests/oops_main_test.sh
--rw-r--r--   0 runner    (1001) docker     (127)       66 2024-04-17 04:22:36.535551 rms_oops-0.0.3/setup.cfg
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-04-17 04:22:36.531551 rms_oops-0.0.3/spicedb/
--rwxr-xr-x   0 runner    (1001) docker     (127)   133536 2024-04-17 04:22:09.000000 rms_oops-0.0.3/spicedb/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     3517 2024-04-17 04:22:09.000000 rms_oops-0.0.3/spicedb/sqlite_db.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.815393 rms_oops-0.0.4/
+-rw-r--r--   0 runner    (1001) docker     (127)      187 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.coveragerc
+-rw-r--r--   0 runner    (1001) docker     (127)      263 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.flake8
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.739392 rms_oops-0.0.4/.github/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.751392 rms_oops-0.0.4/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (127)      765 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.github/workflows/publish_to_pypi.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      882 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.github/workflows/publish_to_test_pypi.yml
+-rw-r--r--   0 runner    (1001) docker     (127)      736 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.github/workflows/run-lint.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     1938 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.github/workflows/run-tests.yml
+-rw-r--r--   0 runner    (1001) docker     (127)     1077 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.github/workflows/run-windows-tests.yml
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3185 2024-05-14 19:16:18.000000 rms_oops-0.0.4/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (127)     5487 2024-05-14 19:16:18.000000 rms_oops-0.0.4/CODE_OF_CONDUCT.md
+-rw-r--r--   0 runner    (1001) docker     (127)     7089 2024-05-14 19:16:18.000000 rms_oops-0.0.4/CONTRIBUTING.md
+-rw-r--r--   0 runner    (1001) docker     (127)    10494 2024-05-14 19:16:18.000000 rms_oops-0.0.4/LICENSE.md
+-rw-r--r--   0 runner    (1001) docker     (127)     4004 2024-05-14 19:16:39.815393 rms_oops-0.0.4/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2293 2024-05-14 19:16:18.000000 rms_oops-0.0.4/README.md
+-rw-r--r--   0 runner    (1001) docker     (127)      142 2024-05-14 19:16:18.000000 rms_oops-0.0.4/codecov.yml
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.751392 rms_oops-0.0.4/ideas/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.755392 rms_oops-0.0.4/ideas/cmodel_/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      589 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3926 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/cmodel.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2174 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/distance.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1887 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/latitude.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2202 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/longitude.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2020 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/radius.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      652 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/cmodel_/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.755392 rms_oops-0.0.4/ideas/deprecated/
+-rw-r--r--   0 runner    (1001) docker     (127)     3488 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/NOTES-ABOUT-OBSERVATION-CLASSES.txt
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4360 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/extendedsource.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    22276 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/iss_test_suite.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5029 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/pointsource.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    26924 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/polynomialfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21226 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/pushbroom.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    20422 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/pushframe.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26746 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/radialfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    28362 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/rasterscan.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    29161 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/rasterslit.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    22030 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/slit.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    23388 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/uvis_test_suite.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    22140 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/vims_test_suite.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2501 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/wfc3_pointing_test copy.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3653 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/wfc3_pointing_test.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9572 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/wfc3_test_suite copy.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12677 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/deprecated/wfc3_test_suite.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/format_/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      476 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/format_/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1193 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/format_/format.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4732 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/format_/hms.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1362 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/format_/pythonfmt.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      534 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/format_/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/gll_ssi_masked/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    43215 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/gll_ssi_masked/backplane-__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    45411 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/gll_ssi_masked/observation-__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    14081 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/gll_ssi_masked/ssi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/multipath/
+-rw-r--r--   0 runner    (1001) docker     (127)     9369 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/multipath/multipath.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/nav_/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      186 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6666 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/navigation.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2149 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/nullnav.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6451 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/platescale.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10583 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/repointing.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4459 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/timeshift.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      583 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/nav_/unittester.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5851 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_frame_interpolation_using_matrix3.py.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/old_observation_subclasses/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21539 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_observation_subclasses/pushbroom.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    19409 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_observation_subclasses/pushframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    28460 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_observation_subclasses/rasterscan.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    28080 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_observation_subclasses/rasterslit.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    22312 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/old_observation_subclasses/slit.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.759392 rms_oops-0.0.4/ideas/packrat/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      318 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/packrat/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    41206 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/packrat/packrat.py
+-rw-r--r--   0 runner    (1001) docker     (127)    47188 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/packrat/packrat_arrays.py
+-rw-r--r--   0 runner    (1001) docker     (127)      419 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/packrat/packrat_entities.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      585 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/packrat/unittester.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16085 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/poleframe-with-tilt.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8574 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/registry.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.763393 rms_oops-0.0.4/ideas/shape2d/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10775 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8755 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/affine.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7004 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/arc.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15556 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/circle.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9967 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/conic.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    32925 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/ellipse.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29842 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/line.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9657 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/point.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18016 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/polygon.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18263 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/shape2d/triangle.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.763393 rms_oops-0.0.4/ideas/spice_starcat/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2011 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1010 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/make.sh
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6395 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01.i
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2543 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4738 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01_interface.f
+-rwxr-xr-x   0 runner    (1001) docker     (127)   118981 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01_wrap.c
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3909 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/spice_starcat/strings.f
+-rwxr-xr-x   0 runner    (1001) docker     (127)    17339 2024-05-14 19:16:18.000000 rms_oops-0.0.4/ideas/wobble.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.767392 rms_oops-0.0.4/oops/
+-rw-r--r--   0 runner    (1001) docker     (127)      179 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/.coveragerc
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3142 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      411 2024-05-14 19:16:39.000000 rms_oops-0.0.4/oops/_version.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.767392 rms_oops-0.0.4/oops/backplane/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    38686 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      646 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/all.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10474 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/ansa.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4743 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/border.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4572 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/distance.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10824 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/lighting.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8007 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/limb.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3609 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/orbit.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2491 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/pole.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4311 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/resolution.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    34686 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/ring.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9207 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/sky.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    17024 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/spheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16471 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/backplane/where.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    68241 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/body.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.771393 rms_oops-0.0.4/oops/cadence/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      690 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10698 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/cadence_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    13252 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/dualcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5894 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/instant.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16147 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/metronome.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    19079 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/reshapedcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9046 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/reversedcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15765 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/sequence.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11770 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/cadence/tdicadence.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.771393 rms_oops-0.0.4/oops/calibration/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      537 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7536 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/calibration_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6909 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/flatcalib.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4005 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/nullcalib.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5517 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/radiance.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5244 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/calibration/rawcounts.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21255 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/config.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      760 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/constants.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    78079 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/event.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3101 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fittable.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.775393 rms_oops-0.0.4/oops/fov/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      753 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    17931 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/barrelfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4977 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/flatfov.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35841 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/fov_.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4997 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/gapfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11870 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/nullfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6172 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/offsetfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    18674 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/polynomialfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3994 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/slicefov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4836 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/subarray.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4200 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/subsampledfov.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5858 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/tdifov.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14824 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/fov/wcsfov.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.775393 rms_oops-0.0.4/oops/frame/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1208 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4946 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/cmatrix.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    47457 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/frame_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5730 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/inclinedframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9617 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/laplaceframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5623 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/navigation.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9982 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/poleframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3610 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/postargframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8570 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/ringframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5538 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/rotation.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16082 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/spiceframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8407 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/spicetype1frame.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4712 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/spinframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3530 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/synchronousframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5946 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/trackerframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5292 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/frame/twovectorframe.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.779393 rms_oops-0.0.4/oops/gold_master/
+-rw-r--r--   0 runner    (1001) docker     (127)    99914 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      679 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/all.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3788 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/ansa.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2264 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/border.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3274 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/distance.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10723 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/lighting.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3690 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/limb.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1503 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/orbit.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1011 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/pole.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1717 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/resolution.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    17156 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/ring.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5114 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/sky.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7364 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/spheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1727 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/test_support.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5226 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gold_master/where.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.779393 rms_oops-0.0.4/oops/gravity/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      372 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gravity/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5123 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gravity/gravity_.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40158 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/gravity/oblategravity.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.779393 rms_oops-0.0.4/oops/hosts/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      187 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/cassini/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15832 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      458 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/gold_master.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    24835 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/iss.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1415 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      455 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/unittester.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21279 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/uvis.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    38550 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/cassini/vims.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/galileo/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12002 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/galileo/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/galileo/ssi/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15477 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/galileo/ssi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      466 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/galileo/ssi/gold_master.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6232 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/galileo/ssi/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      459 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/galileo/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/hst/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    44796 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/hst/acs/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3948 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/acs/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4937 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/acs/hrc.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3920 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/acs/sbc.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7378 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/acs/wfc.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/hst/nicmos/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6143 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/nicmos/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/nicmos/nic1.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/nicmos/nic2.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2621 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/nicmos/nic3.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      422 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.783393 rms_oops-0.0.4/oops/hosts/hst/wfc3/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2925 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/wfc3/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4953 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/wfc3/ir.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5224 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/wfc3/uvis.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12280 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/hst/wfpc2.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/juno/
+-rw-r--r--   0 runner    (1001) docker     (127)    20306 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/juno/jiram/
+-rw-r--r--   0 runner    (1001) docker     (127)     9855 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/jiram/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10360 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/jiram/img.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8169 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/jiram/spe.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/juno/junocam/
+-rw-r--r--   0 runner    (1001) docker     (127)    19494 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/junocam/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      464 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/junocam/gold_master.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4946 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/junocam/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      522 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/juno/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/jwst/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21414 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/jwst/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/jwst/nircam/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8235 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/jwst/nircam/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    30553 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/jwst/nircam/uncal.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/keck/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8715 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/keck/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/keck/nirc2/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7939 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/keck/nirc2/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5195 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/keck/nirc2.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/newhorizons/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5645 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/newhorizons/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    27031 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/newhorizons/lorri.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13865 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/pds3.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      732 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.787393 rms_oops-0.0.4/oops/hosts/voyager/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      195 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/voyager/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    18987 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/hosts/voyager/iss.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    14340 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/lightsource.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    17348 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/meshgrid.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.791393 rms_oops-0.0.4/oops/observation/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      635 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3206 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/insitu.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    49121 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/observation_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12030 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/pixel.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11158 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/rasterslit1d.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10481 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/slit1d.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    27756 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/snapshot.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16047 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/observation/timedimage.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.791393 rms_oops-0.0.4/oops/path/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      766 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4725 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/circlepath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3035 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/coordpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2678 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/fixedpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    34522 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/keplerpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3482 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/linearcoordpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3532 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/linearpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6006 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/multipath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    59950 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/path_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10000 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/path/spicepath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4541 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/spice_support.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.795393 rms_oops-0.0.4/oops/surface/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1018 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    13581 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/ansa.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10577 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/centricellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7284 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/centricspheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    30544 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/ellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11016 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/graphicellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7240 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/graphicspheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    28406 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/limb.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8619 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/nullsurface.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    18588 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/orbitplane.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6763 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/polarlimb.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16017 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/ringplane.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    14217 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/spheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1980 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/spice_shape.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    83713 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/surface/surface_.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    14369 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/transform.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1531 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/unittester_support.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9106 2024-05-14 19:16:18.000000 rms_oops-0.0.4/oops/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1721 2024-05-14 19:16:18.000000 rms_oops-0.0.4/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)      293 2024-05-14 19:16:18.000000 rms_oops-0.0.4/requirements.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.815393 rms_oops-0.0.4/rms_oops.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     4004 2024-05-14 19:16:39.000000 rms_oops-0.0.4/rms_oops.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    11012 2024-05-14 19:16:39.000000 rms_oops-0.0.4/rms_oops.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-14 19:16:39.000000 rms_oops-0.0.4/rms_oops.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      161 2024-05-14 19:16:39.000000 rms_oops-0.0.4/rms_oops.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       13 2024-05-14 19:16:39.000000 rms_oops-0.0.4/rms_oops.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.747392 rms_oops-0.0.4/scripts/
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.795393 rms_oops-0.0.4/scripts/automated_tests/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1605 2024-05-14 19:16:18.000000 rms_oops-0.0.4/scripts/automated_tests/oops_main_test.sh
+-rw-r--r--   0 runner    (1001) docker     (127)       66 2024-05-14 19:16:39.819393 rms_oops-0.0.4/setup.cfg
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.795393 rms_oops-0.0.4/spicedb/
+-rwxr-xr-x   0 runner    (1001) docker     (127)   133536 2024-05-14 19:16:18.000000 rms_oops-0.0.4/spicedb/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3517 2024-05-14 19:16:18.000000 rms_oops-0.0.4/spicedb/sqlite_db.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.795393 rms_oops-0.0.4/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      179 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/.coveragerc
+-rwxr-xr-x   0 runner    (1001) docker     (127)      182 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.799393 rms_oops-0.0.4/tests/cadence/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      190 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16523 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_dualcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    41895 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_metronome.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    14587 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_reshapedcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3447 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_reversedcadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3250 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_sequence.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27271 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/test_tdicadence.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      776 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/cadence/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.799393 rms_oops-0.0.4/tests/calibration/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      194 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/calibration/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7503 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/calibration/test_flatcalib.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8018 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/calibration/test_radiance.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8054 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/calibration/test_rawcounts.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      573 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/calibration/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.799393 rms_oops-0.0.4/tests/fov/
+-rw-r--r--   0 runner    (1001) docker     (127)      186 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10284 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_barrelfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2074 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_flatfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7150 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_polynomialfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1744 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_subarray.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2741 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_subsampledfov.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4246 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_tdifov.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13991 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/test_wcsfov.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      777 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/fov/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.803393 rms_oops-0.0.4/tests/frame/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      188 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1277 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/all.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8156 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_cmatrix.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6478 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_frame.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10007 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_poleframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      889 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_postargframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2836 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_ringframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    16659 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_spiceframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3825 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_spinframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1939 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_synchronousframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1651 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/test_trackerframe.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      946 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/frame/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.803393 rms_oops-0.0.4/tests/gravity/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      190 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/gravity/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3440 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/gravity/test_gravity.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      443 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/gravity/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.803393 rms_oops-0.0.4/tests/hosts/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      186 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.803393 rms_oops-0.0.4/tests/hosts/cassini/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15843 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      468 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/gold_master.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    24835 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/iss.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1425 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      455 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/unittester.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21289 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/uvis.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    38560 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/cassini/vims.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.803393 rms_oops-0.0.4/tests/hosts/galileo/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12002 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/galileo/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/galileo/ssi/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    15506 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/galileo/ssi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      476 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/galileo/ssi/gold_master.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6242 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/galileo/ssi/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      459 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/galileo/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/hst/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    44796 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/hst/acs/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3948 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/acs/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4937 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/acs/hrc.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3920 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/acs/sbc.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7378 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/acs/wfc.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/hst/nicmos/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6143 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/nicmos/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/nicmos/nic1.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2623 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/nicmos/nic2.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2621 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/nicmos/nic3.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      422 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/hst/wfc3/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2925 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4953 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3/ir.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5224 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3/uvis.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2501 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3/wfc3_pointing_test.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9572 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3/wfc3_test_suite.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3653 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3_pointing_test.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12677 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfc3_test_suite.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12280 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/hst/wfpc2.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/juno/
+-rw-r--r--   0 runner    (1001) docker     (127)    20306 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.807393 rms_oops-0.0.4/tests/hosts/juno/jiram/
+-rw-r--r--   0 runner    (1001) docker     (127)     9855 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/jiram/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10360 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/jiram/img.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8169 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/jiram/spe.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/juno/junocam/
+-rw-r--r--   0 runner    (1001) docker     (127)    19494 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/junocam/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      474 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/junocam/gold_master.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4956 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/junocam/standard_obs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      522 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/juno/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/jwst/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    21414 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/jwst/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/jwst/nircam/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8235 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/jwst/nircam/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    30553 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/jwst/nircam/uncal.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/keck/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     8715 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/keck/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/keck/nirc2/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7939 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/keck/nirc2/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5195 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/keck/nirc2.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/newhorizons/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5645 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/newhorizons/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    27031 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/newhorizons/lorri.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13865 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/pds3.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      732 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/hosts/voyager/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      195 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/voyager/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    18987 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/hosts/voyager/iss.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.811393 rms_oops-0.0.4/tests/observation/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      194 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     7506 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/test_pixel.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9762 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/test_rasterslit1d.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4713 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/test_slit1d.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     4826 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/test_snapshot.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    54226 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/test_timedimage.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      706 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/observation/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.815393 rms_oops-0.0.4/tests/path/
+-rwxr-xr-x   0 runner    (1001) docker     (127)      187 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1176 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/test_circlepath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9089 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/test_keplerpath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3408 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/test_multipath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     5012 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/test_path.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    27339 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/test_spicepath.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      655 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/path/unittester.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-14 19:16:39.815393 rms_oops-0.0.4/tests/surface/
+-rwxr-xr-x   0 runner    (1001) docker     (127)    84591 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6589 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_ansa.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11599 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_centricellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12332 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_centricspheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11473 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_ellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11652 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_graphicellipsoid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    12385 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_graphicspheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    18336 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_limb.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    10009 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_orbitplane.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     6403 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_ringplane.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    11639 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_spheroid.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1471 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/test_spice_shape.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     1234 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/unittester.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2652 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/surface/xtest_polarlimb-NOT-WORKING.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2728 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/test_body.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    28041 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/test_event.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     3687 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/test_transform.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9461 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/test_utils.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)      996 2024-05-14 19:16:18.000000 rms_oops-0.0.4/tests/unittester.py
```

### Comparing `rms_oops-0.0.3/.github/workflows/publish_to_pypi.yml` & `rms_oops-0.0.4/.github/workflows/publish_to_pypi.yml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/.github/workflows/publish_to_test_pypi.yml` & `rms_oops-0.0.4/.github/workflows/publish_to_test_pypi.yml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/.github/workflows/run-lint.yml` & `rms_oops-0.0.4/.github/workflows/run-lint.yml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/.github/workflows/run-tests.yml` & `rms_oops-0.0.4/.github/workflows/run-tests.yml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/.github/workflows/run-windows-tests.yml` & `rms_oops-0.0.4/.github/workflows/run-windows-tests.yml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/.gitignore` & `rms_oops-0.0.4/.gitignore`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/CODE_OF_CONDUCT.md` & `rms_oops-0.0.4/CODE_OF_CONDUCT.md`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/CONTRIBUTING.md` & `rms_oops-0.0.4/CONTRIBUTING.md`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/LICENSE.md` & `rms_oops-0.0.4/LICENSE.md`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/PKG-INFO` & `rms_oops-0.0.4/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: rms-oops
-Version: 0.0.3
+Version: 0.0.4
 Summary: Object-Oriented Python and SPICE
 Maintainer-email: "Robert S. French" <rfrench@seti.org>, "Joseph N. Spitale" <jspitale@seti.org>
 License: Apache-2.0
 Project-URL: Homepage, https://github.com/SETI/rms-oops
 Project-URL: Repository, https://github.com/SETI/rms-oops
 Project-URL: Source, https://github.com/SETI/rms-oops
 Project-URL: Issues, https://github.com/SETI/rms-oops/issues
```

### Comparing `rms_oops-0.0.3/README.md` & `rms_oops-0.0.4/README.md`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/__init__.py` & `rms_oops-0.0.4/ideas/cmodel_/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/cmodel.py` & `rms_oops-0.0.4/ideas/cmodel_/cmodel.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/distance.py` & `rms_oops-0.0.4/ideas/cmodel_/distance.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/latitude.py` & `rms_oops-0.0.4/ideas/cmodel_/latitude.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/longitude.py` & `rms_oops-0.0.4/ideas/cmodel_/longitude.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/radius.py` & `rms_oops-0.0.4/ideas/cmodel_/radius.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/cmodel_/unittester.py` & `rms_oops-0.0.4/ideas/cmodel_/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/format_/format.py` & `rms_oops-0.0.4/ideas/format_/format.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/format_/hms.py` & `rms_oops-0.0.4/ideas/format_/hms.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/format_/pythonfmt.py` & `rms_oops-0.0.4/ideas/format_/pythonfmt.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/format_/unittester.py` & `rms_oops-0.0.4/ideas/format_/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/gll_ssi_masked/backplane-__init__.py` & `rms_oops-0.0.4/ideas/gll_ssi_masked/backplane-__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/gll_ssi_masked/observation-__init__.py` & `rms_oops-0.0.4/ideas/gll_ssi_masked/observation-__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/gll_ssi_masked/ssi.py` & `rms_oops-0.0.4/ideas/gll_ssi_masked/ssi.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/multipath/multipath.py` & `rms_oops-0.0.4/ideas/multipath/multipath.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/navigation.py` & `rms_oops-0.0.4/ideas/nav_/navigation.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/nullnav.py` & `rms_oops-0.0.4/ideas/nav_/nullnav.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/platescale.py` & `rms_oops-0.0.4/ideas/nav_/platescale.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/repointing.py` & `rms_oops-0.0.4/ideas/nav_/repointing.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/timeshift.py` & `rms_oops-0.0.4/ideas/nav_/timeshift.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/nav_/unittester.py` & `rms_oops-0.0.4/ideas/nav_/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_frame_interpolation_using_matrix3.py.txt` & `rms_oops-0.0.4/ideas/old_frame_interpolation_using_matrix3.py.txt`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_observation_subclasses/pushbroom.py` & `rms_oops-0.0.4/ideas/old_observation_subclasses/pushbroom.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_observation_subclasses/pushframe.py` & `rms_oops-0.0.4/ideas/old_observation_subclasses/pushframe.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_observation_subclasses/rasterscan.py` & `rms_oops-0.0.4/ideas/old_observation_subclasses/rasterscan.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_observation_subclasses/rasterslit.py` & `rms_oops-0.0.4/ideas/old_observation_subclasses/rasterslit.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/old_observation_subclasses/slit.py` & `rms_oops-0.0.4/ideas/old_observation_subclasses/slit.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/packrat/packrat.py` & `rms_oops-0.0.4/ideas/packrat/packrat.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/packrat/packrat_arrays.py` & `rms_oops-0.0.4/ideas/packrat/packrat_arrays.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/packrat/unittester.py` & `rms_oops-0.0.4/ideas/packrat/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/poleframe-with-tilt.py` & `rms_oops-0.0.4/ideas/poleframe-with-tilt.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/registry.py` & `rms_oops-0.0.4/ideas/registry.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/__init__.py` & `rms_oops-0.0.4/ideas/shape2d/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/affine.py` & `rms_oops-0.0.4/ideas/shape2d/affine.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/arc.py` & `rms_oops-0.0.4/ideas/shape2d/arc.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/circle.py` & `rms_oops-0.0.4/ideas/shape2d/circle.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/conic.py` & `rms_oops-0.0.4/ideas/shape2d/conic.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/ellipse.py` & `rms_oops-0.0.4/ideas/shape2d/ellipse.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/line.py` & `rms_oops-0.0.4/ideas/shape2d/line.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/point.py` & `rms_oops-0.0.4/ideas/shape2d/point.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/polygon.py` & `rms_oops-0.0.4/ideas/shape2d/polygon.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/shape2d/triangle.py` & `rms_oops-0.0.4/ideas/shape2d/triangle.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/__init__.py` & `rms_oops-0.0.4/ideas/spice_starcat/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/make.sh` & `rms_oops-0.0.4/ideas/spice_starcat/make.sh`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01.i` & `rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01.i`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01.py` & `rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01_interface.f` & `rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01_interface.f`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/spice_stcx01_wrap.c` & `rms_oops-0.0.4/ideas/spice_starcat/spice_stcx01_wrap.c`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/spice_starcat/strings.f` & `rms_oops-0.0.4/ideas/spice_starcat/strings.f`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/ideas/wobble.py` & `rms_oops-0.0.4/ideas/wobble.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/__init__.py` & `rms_oops-0.0.4/oops/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,49 +1,61 @@
 ################################################################################
 # oops/__init__.py
 ################################################################################
 
 # Examples of import statements and how they work:
 #
 # >>> import oops
-#   This imports the entire oops object tree (but not instruments), creating
+#   This imports the entire oops object tree (but not hosts), creating
 #   classes such as oops.Scalar, ops.Event, oops.path.SpicePath, plus other
-#   components such as oops.registry and oops.config. This is the recommended
-#   form of import.
+#   components such as oops.config. This is the recommended form of import.
 #
 # >>> import oops as abc
 #   Imports the ENTIRE oops object tree but with the prefix "abc" replacing
 #   "oops".
 #
 # >>> from oops import *
 #   This imports all the oops components without the "oops" prefix. It can fill
 #   up the default name space but there is nothing wrong with it.
 
 import cspyce
 import cspyce.aliases
 cspyce.use_errors()
 cspyce.use_aliases()
 
-import oops.backplane.all   as Backplane
-import oops.cadence.all     as cadence
-import oops.calibration.all as calib
-import oops.fov.all         as fov
-import oops.gravity.all     as gravity
-import oops.frame.all       as frame
-import oops.observation.all as obs
-import oops.observation.all as observation
-import oops.path.all        as path
-import oops.surface.all     as surface
+import oops.cadence
+import oops.calibration
+import oops.fov
+import oops.gravity
+import oops.frame
+import oops.observation
+import oops.path
+import oops.surface
+
+oops.obs = oops.observation         # handy abbreviation
+
+# Add all abstract base classes to top level namespace
+Cadence     = oops.cadence.Cadence
+Calibration = oops.calibration.Calibration
+FOV         = oops.fov.FOV
+Gravity     = oops.gravity.Gravity
+Frame       = oops.frame.Frame
+Observation = oops.observation.Observation
+Path        = oops.path.Path
+Surface     = oops.surface.Surface
 
+from oops.backplane import Backplane
 from oops.body      import Body
 from oops.event     import Event
 from oops.fittable  import Fittable
 from oops.meshgrid  import Meshgrid
 from oops.transform import Transform
 
+import oops.backplane.all           # define all Backplane methods
+
 import oops.constants     as constants
 import oops.spice_support as spice
 import oops.config        as config
 import oops.utils         as utils
 
 from oops.constants import C, C_INVERSE, RPD, DPR, SPR, RPS, SPD, AU, \
                            PI, TWOPI, HALFPI
@@ -52,22 +64,33 @@
                      Units, Vector, Vector3
 
 try:
     from ._version import __version__
 except ImportError as err:
     __version__ = 'Version unspecified'
 
-
 ################################################################################
-# Class cross-references and other class attributes to be defined after startup
+# The hierarchy of imports is:
+#   Body, Surface, Path, Gravity, Event, Frame, Transform
+# Each class can reference classes later in the list, but any reference to a
+# class earlier in the list requires this approach.
 ################################################################################
 
 Transform.FRAME_CLASS = frame.Frame
 Transform.IDENTITY = Transform(Matrix3.IDENTITY,
                                Vector3.ZERO,
                                frame.Frame.J2000,
                                frame.Frame.J2000,
                                path.Path.SSB)
 
+Frame.EVENT_CLASS = Event
+Frame.PATH_CLASS = Path
+Frame.SPICEPATH_CLASS = oops.path.SpicePath
+
 Event.PATH_CLASS = path.Path
+Event.SSB = path.Path.SSB
+
+Gravity.BODY_CLASS = Body
+Surface.BODY_CLASS = Body
+Path.BODY_CLASS = Body
 
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/__init__.py` & `rms_oops-0.0.4/oops/backplane/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -974,9 +974,7 @@
 
                 # If it does not start with underscore, save it in the set of
                 # callables.
                 if key[0] != '_':
                     Backplane.CALLABLES.add(key)
 
 ################################################################################
-# oops/backplane/__init__.py
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/ansa.py` & `rms_oops-0.0.4/oops/backplane/ansa.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 ################################################################################
-# oops/backplanes/ansa_backplanes.py: Ansa backplanes
+# oops/backplanes/ansa.py: Ansa backplanes
 ################################################################################
 
 from polymath import Scalar, Pair
 
 from oops.backplane import Backplane
 
 # Backplane names that can be "nested", such that the array mask propagates
@@ -250,99 +250,7 @@
 
 ################################################################################
 
 # Add these functions to the Backplane module
 Backplane._define_backplane_names(globals().copy())
 
 ################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-import numpy as np
-from oops.backplane.gold_master import register_test_suite
-from oops.constants import PI
-
-def ansa_test_suite(bpt):
-
-    bp = bpt.backplane
-    for name in bpt.ansa_names:
-        bpt.gmtest(bp.ansa_radius(name),
-                   name + ' radius (km)',
-                   limit=0.1, radius=1)
-        bpt.gmtest(bp.ansa_altitude(name),
-                   name + ' altitude (km)',
-                   limit=0.1, radius=1)
-        bpt.gmtest(bp.ansa_radial_resolution(name),
-                   name + ' radial resolution (km)',
-                   limit=0.003, radius=1.5)
-        bpt.gmtest(bp.ansa_vertical_resolution(name),
-                   name + ' vertical resolution (km)',
-                   limit=0.003, radius=1.5)
-
-        bpt.gmtest(bp.ansa_longitude(name, 'node'),
-                   name + ' longitude wrt node (deg)',
-                   method='mod360', limit=0.001, radius=1)
-        bpt.gmtest(bp.ansa_longitude(name, 'aries'),
-                   name + ' longitude wrt Aries (deg)',
-                   method='mod360', limit=0.001, radius=1)
-
-        longitude = bp.ansa_longitude(name, 'obs')
-        bpt.gmtest(longitude,
-                   name + ' longitude wrt observer (deg)',
-                   method='mod360', limit=0.001, radius=1)
-        bpt.compare(longitude - bp.ansa_longitude(name, 'oha'),
-                    PI,
-                    name + ' longitude wrt observer minus wrt OHA (deg)',
-                    method='mod360', limit=1.e-13)
-
-        longitude = bp.ansa_longitude(name, 'sun')
-        bpt.gmtest(longitude,
-                   name + ' longitude wrt Sun (deg)',
-                   method = 'mod360', limit = 0.001, radius = 1)
-        bpt.compare(longitude - bp.ansa_longitude(name, 'sha'),
-                    PI,
-                    name + ' longitude wrt Sun minus wrt SHA (deg)',
-                    method='mod360', limit=1.e-13)
-
-    # Derivative tests
-    if bpt.derivs:
-      (bp, bp_u0, bp_u1, bp_v0, bp_v1) = bpt.backplanes
-      pixel_duv = np.abs(bp.obs.fov.uv_scale.vals)
-
-      for name in bpt.ansa_names:
-
-        ulimit = bp.center_distance(name).max() * pixel_duv[0] * 1.e-3
-        vlimit = bp.center_distance(name).max() * pixel_duv[1] * 1.e-3
-
-        # ansa_radius
-        rad = bp.ansa_radius(name)
-        drad_duv = rad.d_dlos.chain(bp.dlos_duv)
-        (drad_du, drad_dv) = drad_duv.extract_denoms()
-
-        drad = bp_u1.ansa_radius(name) - bp_u0.ansa_radius(name)
-        bpt.compare(drad.wod/bpt.duv, drad_du,
-                    name + ' radius d/du self-check (km/pix)',
-                    limit=ulimit, radius=1)
-
-        drad = bp_v1.ansa_radius(name) - bp_v0.ansa_radius(name)
-        bpt.compare(drad.wod/bpt.duv, drad_dv,
-                    name + ' radius d/dv self-check (km/pix)',
-                    limit=vlimit, radius=1)
-
-        # ansa_altitude
-        alt = bp.ansa_altitude(name)
-        dalt_duv = alt.d_dlos.chain(bp.dlos_duv)
-        (dalt_du, dalt_dv) = dalt_duv.extract_denoms()
-
-        dalt = bp_u1.ansa_altitude(name) - bp_u0.ansa_altitude(name)
-        bpt.compare(dalt.wod/bpt.duv, dalt_du,
-                    name + ' altitude d/du self-check (km/pix)',
-                    limit=ulimit, radius=1)
-
-        dalt = bp_v1.ansa_altitude(name) - bp_v0.ansa_altitude(name)
-        bpt.compare(dalt.wod/bpt.duv, dalt_dv,
-                    name + ' altitude d/dv self-check (km/pix)',
-                    limit=vlimit, radius=1)
-
-register_test_suite('ansa', ansa_test_suite)
-
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/border.py` & `rms_oops-0.0.4/oops/backplane/border.py`

 * *Files 24% similar despite different names*

```diff
@@ -136,66 +136,7 @@
 
 ################################################################################
 
 # Add these functions to the Backplane module
 Backplane._define_backplane_names(globals().copy())
 
 ################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-from oops.backplane.gold_master import register_test_suite
-
-def border_test_suite(bpt):
-
-    bp = bpt.backplane
-
-    # Test border of each body intercepted mask
-    for name in bpt.body_names:
-        mask    = bp.where_intercepted(name)
-        inside  = bp.border_inside(mask)
-        outside = bp.border_outside(mask)
-
-        bpt.gmtest(inside,
-                   name + ' interior border',
-                   method='border', radius=1)
-        bpt.gmtest(outside,
-                   name + ' exterior border',
-                   method='border', radius=1)
-
-        # ... additional tests
-        bpt.compare(mask[inside], True,
-                    name + ' where interior border overlaps mask')
-        bpt.compare(mask[outside], False,
-                    name + ' where exterior border overlaps mask')
-
-    # Test ring boundaries
-    for name in bpt.ring_names:
-        radius = bp.ring_radius(name)
-        below  = bp.border_below(('ring_radius', name), 100.e3)
-        above  = bp.border_above(('ring_radius', name), 100.e3)
-        atop   = bp.border_atop (('ring_radius', name), 100.e3)
-
-        bpt.gmtest(below,
-                   name + ' border below radius 100 kkm',
-                   method='border', radius=1)
-        bpt.gmtest(above,
-                   name + ' border above radius 100 kkm',
-                   method='border', radius=1)
-        bpt.gmtest(atop ,
-                   name + ' border atop radius 100 kkm',
-                   method='border', radius=1)
-
-        # ... additional tests
-        bpt.compare(radius[below], 100.e3,
-                    name + ' radii of border below 100 kkm',
-                    operator='<=')
-        bpt.compare(radius[above], 100.e3,
-                    name + ' radii of border above 100 kkm',
-                    operator='>=')
-        bpt.compare((above | below)[atop], True,
-                    name + ' border atop 100 kkm overlaps above|below',
-                    radius=1)
-
-register_test_suite('border', border_test_suite)
-
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/gold_master.py` & `rms_oops-0.0.4/oops/gold_master/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 ################################################################################
-# oops/backplane/gold_master.py: Backplane gold master tester and support.
+# oops/gold_master/__init__.py: Backplane gold master tester and support.
 ################################################################################
 """\
 ########################################################################
 # How to use with the Python unittest module for a host or instrument...
 ########################################################################
 # Case 1: A single test
 ####################################
 
 import unittest
-import oops.backplane.gold_master as gm
+import oops.gold_master as gm
 
 class Test_<your test name>(unittest.TestCase):
 
     def runTest(self):
 
         # Define the default observation
         gm.define_default_obs(
@@ -30,15 +30,15 @@
         gm.execute_as_unittest(self)
 
 ####################################
 # Case 2: Multiple tests
 ####################################
 
 import unittest
-import oops.backplane.gold_master as gm
+import oops.gold_master as gm
 
 class Test_<your test name>(unittest.TestCase):
 
     def setUp():
 
         # Define the standard observations
         gm.define_standard_obs('obs1',
@@ -66,15 +66,15 @@
         gm.execute_as_unittest(self, 'obs3')
 
 ########################################################################
 # How to have a gold master tester program dedicated to an instrument...
 ########################################################################
 
 import os
-import oops.backplane.gold_master as gm
+import oops.gold_master as gm
 
 # Define the default observation and any number of others for testing;
 # note that the selection can be overridden on the command line.
 
 gm.define_default_obs(
             obspath = 'file path inside the test_data directory',
             index   = (index to apply to result of from_file, or None),
@@ -92,15 +92,15 @@
     gm.execute_as_command()
 
 ########################################################################
 # Log file format
 ########################################################################
 
 A single record of the log file has this format:
-    "<time> | oops.backplane.gold_master | <level> | <suite> | <message>"
+    "<time> | oops.gold_master | <level> | <suite> | <message>"
 where
     <time>  is the local time to the level of ms.
     <level> is one of "DEBUG", "INFO", "WARNING", "ERROR", "FATAL".
     <suite> is the name of the test suite, e.g., "ring".
     <message> is a descriptive message.
 
 For comparison tests, the message has the following format:
@@ -149,24 +149,22 @@
 import sys
 import warnings
 
 from collections   import defaultdict
 from scipy.ndimage import minimum_filter, maximum_filter
 from scipy.ndimage import zoom as zoom_image
 
-from polymath         import Boolean, Pair, Qube, Scalar
-from oops.backplane   import Backplane
-from oops.body        import Body
-from oops.config      import LOGGING
-from oops.constants   import DPR
-from oops.observation import Observation
-
-from oops.unittester_support import (OOPS_BACKPLANE_OUTPUT_PATH,
-                                     OOPS_GOLD_MASTER_PATH,
-                                     OOPS_TEST_DATA_PATH)
+import oops
+from oops.config    import LOGGING
+from oops.constants import DPR
+from polymath       import Boolean, Pair, Qube, Scalar
+
+from oops.gold_master.test_support import (OOPS_BACKPLANE_OUTPUT_PATH,
+                                           OOPS_GOLD_MASTER_PATH,
+                                           OOPS_TEST_DATA_PATH)
 
 ################################################################################
 # Use set_default_obs() and set_standard_obs() to define the observation used
 # for unit tests and as the default for a run from the command line.
 ################################################################################
 
 # This is a dictionary test name -> key inputs for test
@@ -365,14 +363,16 @@
         abpaths         the list of absolute paths to the observations.
         backplane_tests the list of BackplaneTest objects.
 
     Inputs:
         **options       overrides for any default gold_master input arguments.
     """
 
+    import oops.gold_master.all         # define all test suites
+
     # Define parser...
     parser = argparse.ArgumentParser(
                     description='Gold Master backplane test utility%s.'
                                 % ('' if not DEFAULTS['module'] else
                                    ' for module ' + DEFAULTS['module']))
 
     # Data objects
@@ -596,14 +596,15 @@
 
 def execute_as_unittest(testcase, obsname='default'):
     """Run the gold master test suites for all of the defined standard
     observations.
     """
 
     import traceback
+    import oops.gold_master.all         # define all test suites
 
     # This try-except is needed to ensure that a unit-test failure is
     # triggered in the event of an error.
     try:
         # Initialize the command argument namespace
         args = argparse.Namespace()
         for key, value in DEFAULTS.items():
@@ -757,15 +758,15 @@
         rings   = args.rings   or STANDARD_OBS_INFO[obsname]['rings']
 
         result = args.from_file(abspath, **kwargs)
         if index is not None:
             result = result[index]
 
         overrides = TEST_OVERRIDES[obsname]
-        if isinstance(result, Observation):
+        if isinstance(result, oops.Observation):
             bpt = BackplaneTest(result, planets, moons, rings, overrides, args)
             args.backplane_tests.append(bpt)
         else:
             for k, obs in enumerate(result):
                 bpt = BackplaneTest(obs, planets, moons, rings, overrides, args,
                                     suffix='_' + str(k))
                 args.backplane_tests.append(bpt)
@@ -1000,30 +1001,30 @@
 
         # Fill in all the backplane surface names
         for body in planets + moons:
             if body:
                 self.body_names.append(body)
                 self.limb_names.append(body + ':LIMB')
 
-                if Body.lookup(body).ring_body:
+                if oops.Body.lookup(body).ring_body:
                     self.ring_names.append(body + ':RING')
                     self.ansa_names.append(body + ':ANSA')
                     self.planet_ring_pairs.append((body, body + ':RING'))
 
         for moon in moons:
             if moon:
-                planet = Body.lookup(moon).parent.name.upper()
+                planet = oops.Body.lookup(moon).parent.name.upper()
                 self.planet_moon_pairs.append((planet, moon))
 
         for ring in rings:
             if ring:
                 self.ring_names.append(ring)
                 self.ansa_names.append(ring + ':ANSA')
 
-                planet = Body.lookup(ring).parent.name.upper()
+                planet = oops.Body.lookup(ring).parent.name.upper()
                 pair = (planet, ring)
                 if pair not in self.planet_ring_pairs:
                     self.planet_ring_pairs.append(pair)
 
         # Create backplane object plus four with offset meshgrids
         EPS = 1.e-5
         self.origins = [(0.5 + self.args.du      , 0.5 + self.args.dv      ),
@@ -1046,15 +1047,15 @@
         if self.inventory:
             inventory_dict = {'inventory': {}, 'inventory_border': self.border}
         else:
             inventory_dict = {'inventory': None}
 
         self.backplanes = []
         for meshgrid in self.meshgrids:
-            backplane = Backplane(obs, meshgrid=meshgrid, **inventory_dict)
+            backplane = oops.Backplane(obs, meshgrid=meshgrid, **inventory_dict)
             self.backplanes.append(backplane)
 
         # Select the primary meshgrid and backplane
         self.meshgrid = self.meshgrids[0]
         self.backplane = self.backplanes[0]
         self.backplane.ALL_DERIVS = True
 
@@ -1095,17 +1096,17 @@
         """Run the complete suite of tests for this BackplaneTest."""
 
         global LATEST_TITLE, TEST_SUITE
         LATEST_TITLE = ''
         TEST_SUITE = ''
 
         # Set up diagnostics and performance logging
-        Backplane.CONVERGENCE = self.args.convergence
-        Backplane.DIAGNOSTICS = self.args.diagnostics
-        Backplane.PERFORMANCE = self.args.performance
+        oops.Backplane.CONVERGENCE = self.args.convergence
+        oops.Backplane.DIAGNOSTICS = self.args.diagnostics
+        oops.Backplane.PERFORMANCE = self.args.performance
 
         # Re-initialize the comparison tracking
         self.gold_summary_ = None
         self.summary = {}
         self.results = {}
 
         # Set up the log handler; set aside any old log
@@ -2320,15 +2321,15 @@
 
 ################################################################################
 # To handle gold master testing from the command line...
 ################################################################################
 
 if __name__ == '__main__':
 
-    import oops.backplane.gold_master as gm
+    import oops.gold_master as gm
 
     # Define the default observation
     gm.set_default_obs(
             obspath = os.path.join(OOPS_TEST_DATA_PATH,
                                    'cassini/ISS/W1573721822_1.IMG'),
             index   = None,
             planets = ['SATURN'],
```

### Comparing `rms_oops-0.0.3/oops/backplane/limb.py` & `rms_oops-0.0.4/oops/backplane/limb.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
 # oops/backplanes/limb_backplanes.py: Limb altitude backplanes.
 ################################################################################
 
 import numpy as np
+
 from polymath               import Qube
 from oops.backplane         import Backplane
 from oops.surface.polarlimb import PolarLimb
 
 # Backplane names that can be "nested", such that the array mask propagates
 # forward to each new backplane array that refers to it.
 LIMB_BACKPLANES = ('limb_altitude',)
@@ -187,97 +188,7 @@
 
 ################################################################################
 
 # Add these functions to the Backplane module
 Backplane._define_backplane_names(globals().copy())
 
 ################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-from oops.backplane.gold_master import register_test_suite
-
-def limb_test_suite(bpt):
-
-    bp = bpt.backplane
-    for name in bpt.limb_names:
-
-        altitude = bp.limb_altitude(name)
-        bpt.gmtest(altitude,
-                   name + ' altitude (km)',
-                   limit=0.1, radius=1)
-        bpt.compare(bp.limb_longitude(name) - bp.longitude(name), 0.,
-                   name + ' longitude, limb minus generic (deg)',
-                   method='mod360', limit=1.e-13)
-        bpt.compare(bp.limb_latitude(name) - bp.latitude(name), 0.,
-                   name + ' latitude, limb minus generic (deg)',
-                   method='degrees', limit=1.e-13)
-
-        bpt.gmtest(bp.limb_clock_angle(name),
-                   name + ' clock angle (deg)',
-                   limit=0.001, radius=1, method='mod360')
-
-        # Test a masked version
-        key = ('limb_altitude', name, 0., 80000.)
-        limited = bp.evaluate(key)
-        mask = limited.expand_mask().mask
-
-        bpt.gmtest(limited,
-                   name + ' altitude masked above 80 kkm',
-                   limit=0.1, radius=1)
-        bpt.compare(limited - altitude, 0.,
-                    name + ' altitude masked above 80 kkm minus unmasked')
-        bpt.compare(limited - 80000., 0.,
-                    name + ' altitude masked above 80 kkm minus 80,000',
-                    operator='<=')
-
-        # Test lat/lon derived from masked altitude
-        bpt.compare(bp.limb_longitude(key).mask == mask,
-                    True,
-                    name + ' longitude mask eq altitude mask')
-        bpt.compare(bp.limb_latitude(key).mask == mask,
-                    True,
-                    name + ' latitude mask eq altitude mask')
-
-    # Derivative tests
-    if bpt.derivs:
-      (bp, bp_u0, bp_u1, bp_v0, bp_v1) = bpt.backplanes
-      pixel_duv = np.abs(bp.obs.fov.uv_scale.vals)
-
-      for name in bpt.limb_names:
-
-        ulimit = bp.center_distance(name).max() * pixel_duv[0] * 1.e-3
-        vlimit = bp.center_distance(name).max() * pixel_duv[1] * 1.e-3
-
-        # limb_altitude
-        alt = bp.limb_altitude(name)
-        dalt_duv = alt.d_dlos.chain(bp.dlos_duv)
-        (dalt_du, dalt_dv) = dalt_duv.extract_denoms()
-
-        dalt = bp_u1.limb_altitude(name) - bp_u0.limb_altitude(name)
-        bpt.compare(dalt.wod/bpt.duv, dalt_du,
-                    name + ' altitude d/du self-check (km/pix)',
-                    limit=ulimit, radius=1)
-
-        dalt = bp_v1.limb_altitude(name) - bp_v0.limb_altitude(name)
-        bpt.compare(dalt.wod/bpt.duv, dalt_dv,
-                    name + ' altitude d/dv self-check (km/pix)',
-                    limit=vlimit, radius=1)
-
-        # limb_clock_angle
-        clock = bp.limb_clock_angle(name)
-        dclock_duv = clock.d_dlos.chain(bp.dlos_duv)
-        (dclock_du, dclock_dv) = dclock_duv.extract_denoms()
-
-        dclock = bp_u1.limb_clock_angle(name) - bp_u0.limb_clock_angle(name)
-        bpt.compare(dclock.wod/bpt.duv, dclock_du,
-                    name + ' clock angle d/du self-check (km/pix)',
-                    limit=ulimit, radius=1)
-
-        dclock = bp_v1.limb_clock_angle(name) - bp_v0.limb_clock_angle(name)
-        bpt.compare(dclock.wod/bpt.duv, dclock_dv,
-                    name + ' clock angle d/dv self-check (km/pix)',
-                    limit=vlimit, radius=1, method='mod360')
-
-register_test_suite('limb', limb_test_suite)
-
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/ring.py` & `rms_oops-0.0.4/oops/observation/observation_.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,1175 +1,1073 @@
 ################################################################################
-# oops/backplanes/ring.py: Ring backplanes
+# oops/observation/__init__.py: Abstract class Observation
 ################################################################################
 
 import numpy as np
-from polymath       import Pair, Qube, Scalar
-from oops.backplane import Backplane
-from oops.body      import Body
-from oops.frame     import Frame
-
-# Backplane names that can be "nested", such that the array mask propagates
-# forward to each new backplane array that refers to it.
-RING_BACKPLANES = ('ring_radius', 'radial_mode')
-
-def ring_radius(self, event_key, rmin=None, rmax=None):
-    """Radius of the ring intercept point in the observation.
-
-    Input:
-        event_key       key defining the ring surface event.
-        rmin            minimum radius in km; None to allow it to be defined by
-                        the event_key.
-        rmax            maximum radius in km; None to allow it to be defined by
-                        the event_key.
-    """
-
-    event_key = self.standardize_event_key(event_key, default='RING')
-    key = ('ring_radius', event_key, rmin, rmax)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    default_key = ('ring_radius', event_key, None, None)
-    if default_key not in self.backplanes:
-        self._fill_ring_intercepts(event_key)
-
-    radius = self.get_backplane(default_key)
-    if rmin is None and rmax is None:
-        return radius
-
-    new_mask = False
-    if rmin is not None:
-        new_mask = Qube.or_(new_mask, radius < rmin)
-    if rmax is not None:
-        new_mask = Qube.or_(new_mask, radius > rmax)
-
-    if np.any(new_mask):
-        radius = radius.remask_or(new_mask)
-
-    return self.register_backplane(key, radius)
-
-#===============================================================================
-def ring_longitude(self, event_key, reference='node'):
-    """Longitude of the ring intercept point in the image.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-        reference       defines the location of zero longitude.
-                        'aries' for the First point of Aries;
-                        'node'  for the J2000 ascending node;
-                        'obs'   for the sub-observer longitude;
-                        'sun'   for the sub-solar longitude;
-                        'oha'   for the anti-observer longitude;
-                        'sha'   for the anti-solar longitude, returning the
-                                solar hour angle.
-    """
-
-    # Handle embedded backplane
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_longitude', event_key, reference)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # Check inputs
-    if reference not in ('aries', 'node', 'obs', 'oha', 'sun', 'sha'):
-        raise ValueError('invalid longitude reference: ' + repr(reference))
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # If it is not found with reference='node', fill in those backplanes
-    default_key = ('ring_longitude', event_key, 'node')
-    if default_key not in self.backplanes:
-        self._fill_ring_intercepts(event_key)
-
-    # Now apply the reference longitude
-    longitude = self.get_backplane(default_key)
-    if reference == 'node':
-        return longitude
-
-    if reference == 'aries':
-        ref_lon = self._aries_ring_longitude(event_key)
-    elif reference == 'sun':
-        ref_lon = self._sub_solar_longitude(event_key)
-    elif reference == 'sha':
-        ref_lon = self._sub_solar_longitude(event_key) - Scalar.PI
-    elif reference == 'obs':
-        ref_lon = self._sub_observer_longitude(event_key)
-    elif reference == 'oha':
-        ref_lon = self._sub_observer_longitude(event_key) - Scalar.PI
-
-    longitude = (longitude - ref_lon) % Scalar.TWOPI
-    return self.register_backplane(key, longitude)
-
-#===============================================================================
-def radial_mode(self, backplane_key, cycles, epoch, amp, peri0, speed,
-                      a0=0., dperi_da=0., reference='node'):
-    """Radius shift based on a particular ring mode.
-
-    Input:
-        backplane_key   key defining a ring_radius or radial_mode backplane,
-                        possibly with other radial modes.
-        cycles          the number of radial oscillations in 360 degrees of
-                        longitude.
-        epoch           the time (seconds TDB) at which the mode parameters
-                        apply.
-        amp             radial amplitude of the mode in km.
-        peri0           a longitude (radians) at epoch where the mode is at its
-                        radial minimum at semimajor axis a0. For cycles == 0, it
-                        is the phase at epoch, where a phase of 0 corresponds to
-                        the minimum ring radius, with every particle at
-                        pericenter.
-        speed           local pattern speed in radians per second, as scaled by
-                        the number of cycles.
-        a0              the reference semimajor axis, used for slopes
-        dperi_da        the rate of change of pericenter with semimajor axis,
-                        measured at semimajor axis a0 in radians/km.
-        reference       the reference longitude used to describe the mode; same
-                        options as for ring_longitude
-    """
-
-    backplane_key = self.standardize_backplane_key(backplane_key)
-    key = ('radial_mode', backplane_key, cycles, epoch, amp, peri0, speed,
-                          a0, dperi_da, reference)
-
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # Get original longitude, radius, and event time, ignoring modes
-    ring_radius_key = backplane_key
-    while ring_radius_key[0] == 'radial_mode':
-        ring_radius_key = ring_radius_key[1]
-
-    # Get the original ring_radius key; save rmin and rmax for later
-    (backplane_type, event_key, rmin, rmax) = ring_radius_key
-    if backplane_type != 'ring_radius':
-        raise ValueError('radial modes only apply to ring_radius backplanes')
-
-    # Get the referenced backplane without its mask
-    if backplane_key[0] == 'ring_radius':
-        radius = self.ring_radius(event_key, rmin=None, rmax=None)
-    else:
-        # We always save the unmasked version of each radial mode backplane
-        unmasked_key = ('_unmasked_radial_mode',) + backplane_key[1:]
-        radius = self.get_backplane(unmasked_key)
-
-    # Evaluate the original unmasked ring backplanes
-    a = self.ring_radius(event_key)
-    time = self.event_time(event_key)
-
-    # Apply the mode
-    peri = peri0 + dperi_da * (a - a0) + speed * (time - epoch)
-    if cycles == 0:
-        mode = radius + amp * peri.cos()
-    else:
-        longitude = self.ring_longitude(event_key, reference)
-        mode = radius + amp * (cycles * (longitude - peri)).cos()
-
-    # Save the unmasked result
-    unmasked_key = ('_unmasked_radial_mode',) + key[1:]
-    self.register_backplane(unmasked_key, mode)
-
-    # Update the mask if necessary
-    if rmin is not None or rmax is not None:
-        mask = False
-        if rmin is not None:
-            mask = Qube.or_(mask, mode.vals < rmin)
-        if rmax is not None:
-            mask = Qube.or_(mask, mode.vals > rmax)
-
-        mode = mode.remask_or(mask)
-
-    return self.register_backplane(key, mode)
-
-#===============================================================================
-def _aries_ring_longitude(self, event_key):
-    """Gridless longitude of First Point of Aries from the ring ascending node.
-
-    Primarily used internally. Longitudes are measured in the eastward
-    (prograde) direction.
-    """
-
-    event_key = self.gridless_event_key(event_key, default='RING')
-    key = ('_aries_ring_longitude', event_key)
-
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    event = self.get_gridless_event(event_key)
-    frame = Frame.as_primary_frame(event.frame)
-    longitude = (-frame.node_at_time(event.time)) % Scalar.TWOPI
-
-    return self.register_backplane(key, longitude)
-
-#===============================================================================
-def ring_azimuth(self, event_key, direction='obs', apparent=True):
-    """Angle from a photon direction to the local radial direction.
-
-    The angle is measured in the prograde direction from the photon's direction
-    to the local radial, as measured at the ring intercept point and projected
-    into the ring plane. This value is 90 degrees at the left ansa and 270
-    degrees at the right ansa.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-        direction       'obs'   for the apparent departing direction of the
-                                photon to the observer;
-                        'sun'   for the (negative) apparent direction of the
-                                photon arriving from the Sun.
-        apparent        True for the apparent azimuth in the surface frame,
-                        allowing for the fact that ring particles are in orbital
-                        motion around the planet center;
-                        False for the actual azimuth.
-    """
-
-    if direction not in ('obs', 'sun'):
-        raise ValueError('invalid azimuth direction: ' + repr(direction))
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_azimuth', event_key, direction, apparent)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    if direction == 'obs':
-        event = self.get_surface_event(event_key)
-        photon_los = event.dep_ap if apparent else event.dep
-    else:
-        event = self.get_surface_event(event_key, arrivals=True)
-        photon_los = event.neg_arr_ap if apparent else event.neg_arr
-
-    photon_angle = photon_los.longitude(recursive=self.ALL_DERIVS)
-    radius_angle = event.pos.longitude(recursive=self.ALL_DERIVS)
-    azimuth = (radius_angle - photon_angle) % Scalar.TWOPI
-
-    return self.register_backplane(key, azimuth)
-
-#===============================================================================
-def ring_elevation(self, event_key, direction='obs', pole='prograde',
-                                    apparent=True):
-    """Angle from the ring plane to the photon direction, evaluated at the ring
-    intercept point.
-
-    It is equivalent to (PI/2 - incidence) if photon == 'obs', (PI/2 - emission)
-    if photon == 'sun'.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-        direction       'obs'       for the apparent departing direction of the
-                                    photon to the observer;
-                        'sun'       for the (negative) apparent direction of the
-                                    photon arriving from the Sun.
-        pole            'sunward'   positive elevations on the illuminated face;
-                        'observed'  positive elevations on the observed face;
-                        'north'     positive elevations on the IAU north face;
-                        'prograde'  positive elevations on the side of the rings
-                                    defined by positive angular momentum;
-                        'unsigned'  for positive elevations on both ring faces.
-        apparent        True for the apparent elevation in the surface frame,
-                        allowing for the fact that ring particles are in orbital
-                        motion around the planet center;
-                        False for the actual elevation.
-    """
-
-    if direction not in ('obs', 'sun'):
-        raise ValueError('invalid elevation direction: ' + repr(direction))
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_elevation', event_key, direction, pole, apparent)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # "unsigned" is the one option not explicitly supported by ring_incidence or
-    # ring_emission
-    if direction == 'obs':
-        pole = pole.replace('unsigned', 'observed')
-        alt_key = ('ring_emission_angle', event_key, pole, apparent)
-    else:
-        pole = pole.replace('unsigned', 'sunward')
-        alt_key = ('ring_incidence_angle', event_key, pole, apparent)
-
-    pole_angle = self.evaluate(alt_key)
-    return self.register_backplane(key, Scalar.HALFPI - pole_angle)
-
-#===============================================================================
-def _fill_ring_intercepts(self, event_key):
-    """Internal method to fill in the ring intercept geometry backplanes.
+import numbers
 
-    Input:
-        event_key       key defining the ring surface event.
-    """
-
-    # Validate the surface type
-    surface = self.get_surface(event_key[1])
-    if surface.COORDINATE_TYPE != 'polar':
-        raise ValueError('invalid coordinate type for ring geometry: '
-                         + surface.COORDINATE_TYPE)
-
-    # Get the ring intercept coordinates
-    event = self.get_surface_event(event_key)
-
-    # Register the default ring_radius and ring_longitude backplanes
-    self.register_backplane(('ring_radius', event_key, None, None),
-                            event.coord1)
-    self.register_backplane(('ring_longitude', event_key, 'node'),
-                            event.coord2)
-
-#===============================================================================
-def ring_incidence_angle(self, event_key, pole='sunward', apparent=True):
-    """Incidence angle of the arriving photons at the local ring surface.
-
-    By default, angles are measured from the sunward pole and should always be
-    <= pi/2. However, calculations for values relative to the IAU-defined north
-    pole and relative to the prograde pole are also supported.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-        pole            'sunward'   for incidence < pi/2 on the illuminated
-                                    face;
-                        'observed'  for incidence < pi/2 on the observed face;
-                        'north'     for incidence < pi/2 on the IAU-defined
-                                    north face;
-                        'prograde'  for incidence < pi/2 on the side of the ring
-                                    plane defined by positive angular momentum.
-        apparent        True for the apparent angle in the surface frame;
-                        False for the actual.
-    """
-
-    if pole not in ('sunward', 'observed', 'north', 'prograde'):
-        raise ValueError('invalid incidence angle pole: ' + repr(pole))
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_incidence_angle', event_key, pole, apparent)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # See lighting.py for the standard definitions of incidence and emission.
-    # A request for the standard definition always returns the sunward value,
-    # but it also saves the "prograde" definition.
-    sunward = self.incidence_angle(event_key, apparent=apparent)
-    if pole == 'sunward':
-        return self.register_backplane(key, sunward)
-
-    prograde_key = key[:-2] + ('prograde', apparent)
-    prograde = self.get_backplane(prograde_key)
-    if pole == 'prograde':
-        return prograde
-
-    # Default emission angle is > pi/2 wherever the observed face of the rings
-    # is different from the illuminated face.
-    if pole == 'observed':
-        flip = self.emission_angle(event_key, apparent) > Scalar.HALFPI
-        incidence = Scalar.PI * flip + (1 - 2*flip) * sunward
-        return self.register_backplane(key, incidence)
-
-    # The remaining case is 'north'
-    # If the ring is prograde, 'north' and 'prograde' are the same
-    if self._ring_is_retrograde(event_key):
-        incidence = Scalar.PI - prograde
-    else:
-        incidence = prograde
-
-    return self.register_backplane(key, incidence)
-
-#===============================================================================
-def ring_emission_angle(self, event_key, pole='sunward', apparent=True):
-    """Emission angle of the departing photons at the local ring surface.
-
-    By default, angles are measured from the sunward pole, so the emission angle
-    should be < pi/2 on the sunlit side and > pi/2 on the dark side of the
-    rings. However, calculations for values relative to the IAU-defined north
-    pole and relative to the prograde pole are also supported.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-        pole            'sunward'   for emission < pi/2 on the illuminated face;
-                        'observed'  for emission < pi/2 on the observed face;
-                        'north'     for emission < pi/2 on the IAU-defined north
-                                    face;
-                        'prograde'  for emission < pi/2 on the side of the ring
-                                    plane defined by positive angular momentum.
-        apparent        True for the apparent angle in the surface frame;
-                        False for the actual.
-    """
-
-    if pole not in ('sunward', 'observed', 'north', 'prograde'):
-        raise ValueError('invalid emission angle pole: ' + repr(pole))
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_emission_angle', event_key, pole, apparent)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # See lighting.py for the standard definitions of incidence and emission.
-    # A request for the standard definition always returns the sunward value,
-    # but it also saves the "prograde" definition.
-    sunward = self.emission_angle(event_key, apparent=apparent)
-    if pole == 'sunward':
-        return self.register_backplane(key, sunward)
-
-    prograde_key = key[:-2] + ('prograde', apparent)
-    prograde = self.get_backplane(prograde_key)
-    if pole == 'prograde':
-        return prograde
-
-    # The "observed" emission is always <= pi/2
-    if pole == 'observed':
-        emission = Scalar.HALFPI - (Scalar.HALFPI - sunward).abs()
-        return self.register_backplane(key, emission)
-
-    # The remaining case is 'north'
-    # If the ring is prograde, 'north' and 'prograde' are the same
-    if self._ring_is_retrograde(event_key):
-        emission = Scalar.PI - prograde
-    else:
-        emission = prograde
-
-    return self.register_backplane(key, emission)
-
-#===============================================================================
-def ring_sub_observer_longitude(self, event_key, reference='node'):
-    """Gridless sub-observer longitude in the ring plane.
-
-    Input:
-        event_key       key defining the event on the center of the ring's path.
-        reference       defines the location of zero longitude.
-                        'aries' for the First point of Aries;
-                        'node'  for the J2000 ascending node;
-                        'obs'   for the sub-observer longitude;
-                        'sun'   for the sub-solar longitude;
-                        'oha'   for the anti-observer longitude;
-                        'sha'   for the anti-solar longitude, returning the
-                                solar hour angle.
-    """
+from polymath      import Scalar, Pair, Vector, Vector3, Qube
+from oops.config   import LOGGING, PATH_PHOTONS
+from oops.event    import Event
+from oops.meshgrid import Meshgrid
+
+class Observation(object):
+    """An Observation is an abstract class that defines the timing and pointing
+    of the samples that comprise a data array.
+
+    The axes of an observation are related to up to two spatial axes and one
+    time axis. Spatial axes (u,v) are defined within an FOV (field of view)
+    object. Time is specified as an offset in seconds relative to the start time
+    of the observation. An observation provides methods to convert between the
+    indices of the data array and the coordinates (u,v,t) that define a line of
+    sight at a particular time.
+
+    When indices have non-integer values, the integer part identifies one
+    "corner" of the sample, and the fractional part locates a point within the
+    sample, i.e., part way from the start time to the end time of an
+    integration, or a location inside the boundaries of a spatial pixel.
+    Half-integer indices falls at the midpoint of each sample.
+
+    At minimum, these attributes are used to describe the observation:
+
+        time            a tuple or Pair defining the start time and end time of
+                        the observation overall, in seconds TDB.
+
+        midtime         the mid-time of the observation, in seconds TDB.
+
+        cadence         a Cadence object defining the timing of the observation.
+
+        fov             a FOV (field-of-view) object, which describes the field
+                        of view including any spatial distortion. It maps
+                        between spatial coordinates (u,v) and instrument
+                        coordinates (x,y).
+
+        uv_shape        a tuple defining the 2-D shape of the spatial axes of
+                        the data array, in (u,v) order. Note that this may
+                        differ from fov.uv_shape.
+
+        u_axis, v_axis  integers identifying the axes of the data array
+                        associated with the u-axis and the v-axis. Use -1 if
+                        that axis is not associated with an array index.
+
+        swap_uv         True if the v-axis comes before the u-axis;
+                        False otherwise.
+
+        t_axis          integers or lists of integers identifying the axes of
+                        the data array associated with time. When a list has
+                        multiple values, this is the sequence of array indices
+                        that break down time into finer and finer divisions,
+                        ordered from left to right. Use -1 if the observation
+                        has no time-dependence.
+
+        shape           a list or tuple defining the overall shape of the
+                        observation data. Where the size of an axis is unknown
+                        (e.g., for a wavelength axis), the value can be zero.
+
+        path            the path waypoint co-located with the instrument.
+
+        frame           the wayframe of a coordinate frame fixed to the optics
+                        of the instrument. This frame should have its Z-axis
+                        pointing outward near the center of the line of sight,
+                        with the X-axis pointing rightward and the y-axis
+                        pointing downward.
 
-    if reference not in ('aries', 'node', 'obs', 'oha', 'sun', 'sha'):
-        raise ValueError('invalid longitude reference: ' + repr(reference))
+        subfields       a dictionary containing all of the optional attributes.
+                        Additional subfields may be included as needed.
 
-    # Look up under the desired reference
-    gridless_key = self.gridless_event_key(event_key, default='RING')
-    key0 = ('ring_sub_observer_longitude', gridless_key)
-    key = key0 + (reference,)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # Generate longitude values
-    default_key = key0 + ('node',)
-    if default_key in self.backplanes:
-        longitude = self.get_backplane(default_key)
-    else:
-        longitude = self._sub_observer_longitude(gridless_key)
-        longitude = self.register_backplane(default_key, longitude)
-
-    if reference == 'node':
-        return longitude
-
-    # Now apply an alternative reference longitude
-    if reference == 'aries':
-        ref_lon = self._aries_ring_longitude(gridless_key)
-    elif reference == 'sun':
-        ref_lon = self._sub_solar_longitude(gridless_key)
-    elif reference == 'sha':
-        ref_lon = self._sub_solar_longitude(gridless_key) - np.pi
-    elif reference == 'obs':
-        ref_lon = self._sub_observer_longitude(gridless_key)
-    elif reference == 'oha':
-        ref_lon = self._sub_observer_longitude(gridless_key) - np.pi
-
-    longitude = (longitude - ref_lon) % Scalar.TWOPI
-    return self.register_backplane(key, longitude)
-
-#===============================================================================
-def ring_sub_solar_longitude(self, event_key, reference='node'):
-    """Gridless sub-solar longitude in the ring plane.
-
-    Input:
-        event_key       key defining the event on the center of the ring's path.
-        reference       defines the location of zero longitude.
-                        'aries' for the First point of Aries;
-                        'node'  for the J2000 ascending node;
-                        'obs'   for the sub-observer longitude;
-                        'sun'   for the sub-solar longitude;
-                        'oha'   for the anti-observer longitude;
-                        'sha'   for the anti-solar longitude, returning the
-                                solar hour angle.
+            data        a reserved subfield to contain the NumPy array of
+                        numbers associated with the observation.
     """
 
-    if reference not in ('aries', 'node', 'obs', 'oha', 'sun', 'sha'):
-        raise ValueError('invalid longitude reference: ' + repr(reference))
-
-    # Look up under the desired reference
-    gridless_key = self.gridless_event_key(event_key, default='RING')
-    key0 = ('ring_sub_solar_longitude', gridless_key)
-    key = key0 + (reference,)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # If it is not found with reference='node', fill in those backplanes
-    default_key = key0 + ('node',)
-    if default_key in self.backplanes:
-        longitude = self.get_backplane(default_key)
-    else:
-        longitude = self._sub_solar_longitude(gridless_key)
-        longitude = self.register_backplane(default_key, longitude)
-
-    if reference == 'node':
-        return longitude
-
-    # Now apply an alternative reference longitude
-    if reference == 'aries':
-        ref_lon = self._aries_ring_longitude(gridless_key)
-    elif reference == 'sun':
-        ref_lon = self._sub_solar_longitude(gridless_key)
-    elif reference == 'sha':
-        ref_lon = self._sub_solar_longitude(gridless_key) - np.pi
-    elif reference == 'obs':
-        ref_lon = self._sub_observer_longitude(gridless_key)
-    elif reference == 'oha':
-        ref_lon = self._sub_observer_longitude(gridless_key) - np.pi
-
-    longitude = (longitude - ref_lon) % Scalar.TWOPI
-    return self.register_backplane(key, longitude)
-
-#===============================================================================
-def ring_center_incidence_angle(self, event_key, pole='sunward', apparent=True):
-    """Incidence angle of the arriving photons at the ring system center.
-
-    Input:
-        event_key       key defining the ring surface event.
-        pole            'sunward'   for incidence < pi/2 on the illuminated
-                                    face;
-                        'observed'  for incidence < pi/2 on the observed face;
-                        'north'     for incidence < pi/2 on the IAU-defined
-                                    north face;
-                        'prograde'  for incidence < pi/2 on the side of the ring
-                                    plane defined by positive angular momentum.
-        apparent        True for the apparent angle in the body frame;
-                        False for the actual.
-    """
-
-    gridless_key = self.gridless_event_key(event_key, default='RING')
-    return self.ring_incidence_angle(gridless_key, pole=pole, apparent=apparent)
-
-#===============================================================================
-def ring_center_emission_angle(self, event_key, pole='sunward', apparent=True):
-    """Emission angle of departing photons at the center of the ring system.
-
-    By default, angles are measured from the sunward pole, so the emission angle
-    should be < pi/2 on the sunlit side and > pi/2 on the dark side of the
-    rings. However, calculations for values relative to the IAU-defined north
-    pole and relative to the prograde pole are also supported.
-
-    Input:
-        event_key       key defining the ring surface event.
-        pole            'sunward'   for emission < pi/2 on the illuminated face;
-                        'observed'  for emission < pi/2 on the observed face;
-                        'north'     for emission < pi/2 on the IAU-defined north
-                                    face;
-                        'prograde'  for emission < pi/2 on the side of the ring
-                                    plane defined by positive angular momentum.
-        apparent        True for the apparent angle in the body frame;
-                        False for the actual.
-    """
-
-    gridless_key = self.gridless_event_key(event_key, default='RING')
-    return self.ring_emission_angle(gridless_key, pole=pole, apparent=apparent)
-
-#===============================================================================
-def ring_radial_resolution(self, event_key):
-    """Projected radial resolution in km/pixel at the ring intercept point.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-    """
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_radial_resolution', event_key)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    event = self.get_surface_event(event_key, derivs=True)
-    if event.surface.COORDINATE_TYPE != 'polar':
-        raise ValueError('invalid coordinate type for ring geometry: '
-                         + event.surface.COORDINATE_TYPE)
-
-    radius = event.coord1
-    drad_duv = radius.d_dlos.chain(self.dlos_duv)
-    resolution = drad_duv.join_items(Pair).norm()
-
-    return self.register_backplane(key, resolution)
-
-#===============================================================================
-def ring_angular_resolution(self, event_key):
-    """Projected angular resolution in radians/pixel at the ring intercept.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-    """
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_angular_resolution', event_key)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    event = self.get_surface_event(event_key, derivs=True)
-    if event.surface.COORDINATE_TYPE != 'polar':
-        raise ValueError('invalid coordinate type for ring geometry: '
-                         + event.surface.COORDINATE_TYPE)
-
-    longitude = event.coord2
-    dlon_duv = longitude.d_dlos.chain(self.dlos_duv)
-    resolution = dlon_duv.join_items(Pair).norm()
-
-    return self.register_backplane(key, resolution)
-
-#===============================================================================
-def ring_gradient_angle(self, event_key):
-    """Direction of the radius gradient at each pixel in the image.
-
-    The angle is measured from the U-axis toward the V-axis.
-
-    Input:
-        event_key       key defining the ring surface event. Alternatively, a
-                        ring_radius or radial_mode backplane key, in which case
-                        this backplane inherits the mask of the given backplane
-                        array.
-    """
-
-    (event_key,
-     backplane_key) = self._event_and_backplane_keys(event_key, RING_BACKPLANES,
-                                                     default='RING')
-
-    key = ('ring_gradient_angle', event_key)
-    if backplane_key:
-        return self._remasked_backplane(key, backplane_key)
-
-    # If this backplane array is already defined, return it
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    event = self.get_surface_event(event_key, derivs=True)
-    if event.surface.COORDINATE_TYPE != 'polar':
-        raise ValueError('invalid coordinate type for ring geometry: '
-                         + event.surface.COORDINATE_TYPE)
-
-    rad = event.coord1
-    drad_duv = rad.d_dlos.chain(self.dlos_duv)
-    (drad_du, drad_dv) = drad_duv.join_items(Pair).to_scalars()
-
-    clock = drad_dv.arctan2(drad_du)
-    return self.register_backplane(key, clock)
-
-#===============================================================================
-def ring_shadow_radius(self, event_key, ring_surface_key):
-    """Radius in the ring plane that casts a shadow at each point on this body.
-    """
-
-    event_key = self.standardize_event_key(event_key)
-    ring_surface_key = ring_surface_key.upper()
-
-    key = ('ring_shadow_radius', event_key, ring_surface_key)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # Make sure the surface event is already defined
-    _ = self.get_surface_event(event_key, arrivals=True)
-
-    # Solve for the ring event
-    ring_event_key = event_key[:1] + (ring_surface_key,) + event_key[1:]
-    ring_event = self.get_surface_event(ring_event_key)
-    radius = ring_event.coord1
-
-    return self.register_backplane(key, radius)
-
-#===============================================================================
-def ring_shadow_incidence(self, event_key, ring_surface_key):
-    """Incidence angle in the ring plane that casts a shadow at each point on
-    this body.
-    """
-
-    event_key = self.standardize_event_key(event_key)
-    ring_surface_key = ring_surface_key.upper()
-
-    key = ('ring_shadow_incidence', event_key, ring_surface_key)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    # Make sure the surface event is already defined
-    _ = self.get_surface_event(event_key, arrivals=True)
-
-    # Solve for the ring event
-    ring_event_key = event_key[:1] + (ring_surface_key,) + event_key[1:]
-    ring_event = self.get_surface_event(ring_event_key)
-
-    # The departure vectors are defined in the ring event, but not the arrivals
-    emission = ring_event.emission_angle(apparent=True, derivs=self.ALL_DERIVS)
-    incidence = Scalar.HALFPI - (Scalar.HALFPI - emission).abs()
-
-    return self.register_backplane(key, incidence)
-
-#===============================================================================
-def ring_radius_in_front(self, event_key, ring_surface_key):
-    """Radius in the ring plane that obscures each point on this body."""
-
-    event_key = self.standardize_event_key(event_key)
-    ring_surface_key = ring_surface_key.upper()
-
-    key = ('ring_radius_in_front', event_key, ring_surface_key)
-    if key in self.backplanes:
-        return self.get_backplane(key)
-
-    ring_event_key = event_key[:1] + (ring_surface_key,)
-    radius = self.ring_radius(ring_event_key)
-    intercepted = self.where_intercepted(event_key, tvl=False)
-    radius = radius.remask_or(intercepted.logical_not())
-
-    return self.register_backplane(key, radius)
-
-#===============================================================================
-def _ring_is_retrograde(self, event_key):
-    """True if this ring is retrograde."""
-
-    body_name = event_key[1]
-    if ':' in body_name:
-        planet_name = body_name.partition(':')[0]
-        parent = Body.lookup(planet_name)
-    else:
-        parent = Body.lookup(body_name).parent
-
-    return parent.ring_is_retrograde
-
-################################################################################
-
-# Add these functions to the Backplane module
-Backplane._define_backplane_names(globals().copy())
-
-################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-from oops.backplane.gold_master import register_test_suite
-from oops.constants import DPR
-
-def ring_test_suite(bpt):
-
-    bp = bpt.backplane
-    for (planet, name) in bpt.planet_ring_pairs:
-
-        # Radius and resolution
-        bpt.gmtest(bp.ring_radius(name),
-                   name + ' radius (km)',
-                   limit=0.1, radius=1)
-
-        bpt.gmtest(bp.ring_radius(name) * bp.ring_angular_resolution(name),
-                   name + ' angular resolution (km)',
-                   limit=0.1, radius=1.5)
-
-        bpt.gmtest(bp.ring_angular_resolution(name),
-                   name + ' angular resolution (deg)',
-                   method='degrees', limit=0.01, radius=1.5)
-
-        # Longitude
-        bpt.gmtest(bp.ring_longitude(name, reference='aries'),
-                   name + ' longitude wrt Aries (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(bp.ring_longitude(name, reference='node'),
-                   name + ' longitude wrt node (deg)',
-                   method='mod360', limit=0.01, radius=1)
-
-        longitude = bp.ring_longitude(name, reference='obs')
-        bpt.gmtest(longitude,
-                   name + ' longitude wrt observer (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(longitude - bp.ring_longitude(name, reference='oha'),
-                    Scalar.PI,
-                    name + ' longitude wrt observer minus wrt OHA (deg)',
-                    method='mod360', limit=0.01)
-
-        longitude = bp.ring_longitude(name, reference='sun')
-        bpt.gmtest(longitude,
-                   name + ' longitude wrt Sun (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(longitude - bp.ring_longitude(name, reference='sha'),
-                    Scalar.PI,
-                    name + ' longitude wrt Sun minus wrt SHA (deg)',
-                    method='mod360', limit=1.e-13)
-
-        # Azimuth
-        apparent = bp.ring_azimuth(name, direction='obs', apparent=True)
-        actual   = bp.ring_azimuth(name, direction='obs', apparent=False)
-        bpt.gmtest(apparent,
-                   name + ' azimuth to observer, apparent (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(actual,
-                   name + ' azimuth to observer, actual (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(apparent - actual,
-                    0.,
-                    name + ' azimuth to observer, apparent minus actual (deg)',
-                    method='mod360', limit=0.1)
-
-        apparent = bp.ring_azimuth(name, direction='sun', apparent=True)
-        actual   = bp.ring_azimuth(name, direction='sun', apparent=False)
-        bpt.gmtest(apparent,
-                   name + ' azimuth of Sun, apparent (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(actual,
-                   name + ' azimuth of Sun, actual (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(apparent - actual,
-                    0.,
-                    name + ' azimuth of Sun, apparent minus actual (deg)',
-                    method='mod360', limit=0.1)
-
-        # Elevation
-        apparent = bp.ring_elevation(name, direction='obs', apparent=True)
-        actual   = bp.ring_elevation(name, direction='obs', apparent=False)
-        bpt.gmtest(apparent,
-                   name + ' elevation to observer, apparent (deg)',
-                   method='degrees', limit=0.01, radius=1)
-        bpt.gmtest(actual,
-                   name + ' elevation to observer, actual (deg)',
-                   method='degrees', limit=0.01, radius=1)
-        bpt.compare(apparent - actual,
-                    0.,
-                    name + ' elevation to observer, apparent minus actual (deg)',
-                    method='degrees', limit=0.1)
-
-        apparent = bp.ring_elevation(name, direction='sun', apparent=True)
-        actual   = bp.ring_elevation(name, direction='sun', apparent=False)
-        bpt.gmtest(apparent,
-                   name + ' elevation of Sun, apparent (deg)',
-                   method='degrees', limit=0.01, radius=1)
-        bpt.gmtest(actual,
-                   name + ' elevation of Sun, actual (deg)',
-                   method='degrees', limit=0.01, radius=1)
-        bpt.compare(apparent - actual,
-                    0.,
-                    name + ' elevation of Sun, apparent minus actual (deg)',
-                    method='degrees', limit=0.1)
-
-        # Longitude & azimuth tests
-        longitude = bp.ring_longitude(name, reference='obs')
-        azimuth = bp.ring_azimuth(name, direction='obs')
-        bpt.gmtest(azimuth - longitude,
-                   name + ' azimuth minus longitude wrt observer (deg)',
-                   method='mod360', limit=0.01, radius=1)
-
-        longitude = bp.ring_longitude(name, reference='sun')
-        azimuth = bp.ring_azimuth(name, direction='sun')
-        bpt.compare(azimuth - longitude, 0.,
-                    name + ' azimuth minus longitude wrt Sun (deg)',
-                    method='mod360', limit=1.)
-
-        # Sub-observer longitude
-        bpt.gmtest(bp.ring_sub_observer_longitude(name, reference='aries'),
-                   name + ' sub-observer longitude wrt Aries (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(bp.ring_sub_observer_longitude(name, reference='node'),
-                   name + ' sub-observer longitude wrt node (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(bp.ring_sub_observer_longitude(name, reference='sun'),
-                   name + ' sub-observer longitude wrt Sun (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(bp.ring_sub_observer_longitude(name, reference='obs'),
-                    0.,
-                    name + ' sub-observer longitude wrt observer (deg)',
-                    method='mod360')
-
-        # Sub-solar longitude
-        bpt.gmtest(bp.ring_sub_solar_longitude(name, reference='aries'),
-                   name + ' sub-solar longitude wrt Aries (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(bp.ring_sub_solar_longitude(name, reference='node'),
-                   name + ' sub-solar longitude wrt node (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.gmtest(bp.ring_sub_solar_longitude(name, reference='obs'),
-                   name + ' sub-solar longitude wrt observer (deg)',
-                   method='mod360', limit=0.01, radius=1)
-        bpt.compare(bp.ring_sub_solar_longitude(name, reference='sun'),
-                    0.,
-                    name + ' sub-solar longitude wrt Sun (deg)',
-                    method='mod360')
-
-        # Incidence, solar elevation
-        incidence = bp.ring_center_incidence_angle(name, 'sunward')
-        bpt.gmtest(incidence,
-                   name + ' center incidence angle, sunward (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.compare(incidence - Scalar.HALFPI, 0.,
-                    name + ' center incidence minus 90, sunward (deg)',
-                    operator='<', method='degrees')
-        bpt.gmtest(bp.ring_center_incidence_angle(name, 'north'),
-                   name + ' center incidence angle, north (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.gmtest(bp.ring_center_incidence_angle(name, 'observed'),
-                   name + ' center incidence angle, observed (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.gmtest(bp.ring_center_incidence_angle(name, 'prograde'),
-                   name + ' center incidence angle, prograde (deg)',
-                   limit=0.01, method='degrees', radius=1)
-
-        sunward = bp.ring_incidence_angle(name, 'sunward')
-        elevation = bp.ring_elevation(name, direction='sun', pole='sunward')
-        generic = bp.incidence_angle(name)
-
-        bpt.gmtest(sunward,
-                   name + ' incidence angle, sunward (deg)',
-                   limit=0.01, radius=1, method='degrees')
-        bpt.compare(sunward - Scalar.HALFPI, 0.,
-                    name + ' incidence angle minus 90, sunward (deg)',
-                    operator='<=', method='degrees')
-        bpt.compare(sunward + elevation, Scalar.HALFPI,
-                    name + ' incidence plus solar elevation (deg)',
-                    limit=1.e-13, method='degrees')
-        bpt.compare(sunward - generic, 0.,
-                    name + ' incidence angle, sunward minus generic (deg)',
-                    limit=1.e-13, method='degrees')
-
-        northward = bp.ring_incidence_angle(name, 'north')
-        bpt.gmtest(northward,
-                   name + ' incidence angle, north (deg)',
-                   limit=0.01, radius=1, method='degrees')
-
-        prograde = bp.ring_incidence_angle(name, 'prograde')
-        if planet in ('JUPITER', 'SATURN', 'NEPTUNE'):
-            bpt.compare(northward - prograde, 0.,
-                        name + ' incidence angle, north minus prograde (deg)',
-                        method='degrees')
-        elif planet == 'URANUS':
-            bpt.compare(northward + prograde, Scalar.PI,
-                        name + ' incidence angle, north plus prograde (deg)',
-                        limit=1.e-13, method='degrees')
-
-        incidence0 = bp.ring_incidence_angle(name)
-        incidence1 = bp.ring_center_incidence_angle(name)
-        bpt.compare(incidence0 - incidence1, 0.,
-                    name + ' incidence angle, ring minus center (deg)',
-                    limit=0.1, method='degrees')
-
-        # Emission, observer elevation
-        bpt.gmtest(bp.ring_center_emission_angle(name, 'sunward'),
-                   name + ' center emission angle, sunward (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.gmtest(bp.ring_center_emission_angle(name, 'north'),
-                   name + ' center emission angle, north (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.gmtest(bp.ring_center_emission_angle(name, 'prograde'),
-                   name + ' center emission angle, prograde (deg)',
-                   limit=0.01, method='degrees', radius=1)
-
-        emission = bp.ring_center_emission_angle(name, 'observed')
-        bpt.gmtest(emission,
-                   name + ' center emission angle, observed (deg)',
-                   limit=0.01, method='degrees', radius=1)
-        bpt.compare(emission - Scalar.HALFPI, 0.,
-                    name + ' center emission minus 90, observed (deg)',
-                    operator='<', method='degrees')
-
-        emission = bp.ring_emission_angle(name, 'observed')
-        elevation = bp.ring_elevation(name, direction='obs', pole='observed')
-        generic = bp.emission_angle(name)
-
-        bpt.gmtest(emission,
-                   name + ' emission angle, observed (deg)',
-                   limit=0.01, radius=1, method='degrees')
-        bpt.compare(emission - Scalar.HALFPI, 0.,
-                    name + ' emission angle minus 90, observed (deg)',
-                    operator='<', method='degrees')
-        bpt.compare(emission + elevation, Scalar.HALFPI,
-                    name + ' emission plus observer elevation (deg)',
-                    limit=1.e-13, method='degrees')
-
-        sunward = bp.ring_emission_angle(name, 'sunward')
-        bpt.compare(sunward - generic, 0.,
-                    name + ' emission angle, sunward minus generic (deg)',
-                    limit=1.e-13, method='degrees')
-
-        northward = bp.ring_emission_angle(name, 'north')
-        bpt.gmtest(northward,
-                   name + ' emission angle, north (deg)',
-                   limit=0.01, radius=1, method='degrees')
-
-        prograde = bp.ring_emission_angle(name, 'prograde')
-        if planet in ('JUPITER', 'SATURN', 'NEPTUNE'):
-            bpt.compare(northward - prograde, 0.,
-                        name + ' emission angle, north minus prograde (deg)',
-                        limit=1.e-13, method='degrees')
-        elif planet == 'URANUS':
-            bpt.compare(northward + prograde, Scalar.PI,
-                        name + ' emission angle, north plus prograde (deg)',
-                        limit=1.e-13, method='degrees')
-
-        emission0 = bp.ring_emission_angle(name)
-        emission1 = bp.ring_center_emission_angle(name)
-        bpt.compare(emission0 - emission1, 0.,
-                    name + ' emission angle, ring minus center (deg)',
-                    limit=5., method='degrees')
-
-    # Mode tests, Saturn only
-    for (planet, name) in bpt.planet_ring_pairs:
-        if planet != 'SATURN':
-            continue
-
-        test0 = bp.ring_radius(name, 70.e3, 100.e3)
-        bpt.gmtest(test0,
-                   name + ' radius, modeless, 70-100 km',
-                   limit=0.1, radius=1)
-
-        test1 = bp.radial_mode(test0.key, 40, 0., 1000., 0., 0., 100.e3)
-        bpt.gmtest(test1, name + ' radius, mode 1, 70-100 kkm',
-                   limit=0.1, radius=1)
-
-        test2 = bp.radial_mode(test1.key, 40, 0., -1000., 0., 0., 100.e3)
-        bpt.gmtest(test2, name + ' radius, mode 1 canceled, 70-100 kkm',
-                   limit=0.1, radius=1)
-
-        bpt.compare(test0, test2,
-                    name + ' radius, modeless vs. mode 1 canceled (km)',
-                    limit=0.1, radius=1)
-
-        test3 = bp.radial_mode(test1.key, 25, 0., 500., 0., 0., 100.e3)
-        bpt.gmtest(test3,
-                   name + ' radius, modes 1 and 2, 70-100 kkm',
-                   limit=0.1, radius=1)
-        bpt.gmtest(bp.ring_longitude(test3.key, 'node'),
-                   name + ' longitude, modes 1 and 2, 70-100 kkm (deg)',
-                   limit=0.01, method='mod360', radius=1)
-
-    # Derivative tests
-    if bpt.derivs:
-      (bp, bp_u0, bp_u1, bp_v0, bp_v1) = bpt.backplanes
-      pixel_uv = np.abs(bp.obs.fov.uv_scale.vals)
-
-      for name in bpt.ring_names:
-
-        # Get approximate ring spatial scale in km/pixel and deg/pixel
-        km_per_los_radian = bp.distance(name) / bp.mu(name)
-        if np.all(km_per_los_radian.mask):
-            continue
-
-        km_per_pixel = km_per_los_radian.max() * pixel_uv
-        (ulimit_km, vlimit_km) = km_per_pixel * 0.001
-
-        deg_per_los_radian = km_per_los_radian / bp.ring_radius(name) * DPR
-        deg_per_pixel = deg_per_los_radian.max() * pixel_uv
-        (ulimit_deg, vlimit_deg) = deg_per_pixel * 0.001
-
-        # ring_radius
-        rad = bp.ring_radius(name)
-        drad_duv = rad.d_dlos.chain(bp.dlos_duv)
-        (drad_du, drad_dv) = drad_duv.extract_denoms()
-
-        drad = bp_u1.ring_radius(name) - bp_u0.ring_radius(name)
-        bpt.compare(drad.wod/bpt.duv, drad_du,
-                    name + ' radius d/du self-check (km/pix)',
-                    limit=ulimit_km, radius=1)
-
-        drad = bp_v1.ring_radius(name) - bp_v0.ring_radius(name)
-        bpt.compare(drad.wod/bpt.duv, drad_dv,
-                    name + ' radius d/dv self-check (km/pix)',
-                    limit=vlimit_km, radius=1)
-
-        # ring_longitude
-        lon = bp.ring_longitude(name)
-        dlon_duv = lon.d_dlos.chain(bp.dlos_duv)
-        (dlon_du, dlon_dv) = dlon_duv.extract_denoms()
-
-        dlon = (bp_u1.ring_longitude(name) - bp_u0.ring_longitude(name)).abs()
-        dlon = Scalar.PI - (dlon - Scalar.PI).abs()
-        bpt.compare((dlon.wod/bpt.duv - dlon_du).abs().median(), 0.,
-                    name + ' longitude d/du self-check (deg/pix)',
-                    limit=ulimit_deg, method='degrees')
-
-        dlon = (bp_v1.ring_longitude(name) - bp_v0.ring_longitude(name)).abs()
-        dlon = Scalar.PI - (dlon.wod - Scalar.PI).abs()
-        bpt.compare((dlon.wod/bpt.duv - dlon_dv).abs().median(), 0.,
-                    name + ' longitude d/dv self-check (deg/pix)',
-                    limit=vlimit_deg, method='degrees')
-
-        # ring_azimuth
-        az = bp.ring_azimuth(name)
-        daz_duv = az.d_dlos.chain(bp.dlos_duv)
-        (daz_du, daz_dv) = daz_duv.extract_denoms()
-
-        daz = (bp_u1.ring_azimuth(name) - bp_u0.ring_azimuth(name)).abs()
-        daz = Scalar.PI - (daz - Scalar.PI).abs()
-        bpt.compare((daz.wod/bpt.duv - daz_du).abs().median(), 0.,
-                    name + ' azimuth d/du self-check (deg/pix)',
-                    limit=ulimit_deg, method='degrees')
-
-        daz = (bp_v1.ring_azimuth(name) - bp_v0.ring_azimuth(name)).abs()
-        daz = Scalar.PI - (daz - Scalar.PI).abs()
-        bpt.compare((daz.wod/bpt.duv - daz_dv).abs().median(), 0.,
-                    name + ' azimuth d/dv self-check (deg/pix)',
-                    limit=vlimit_deg, method='degrees')
+    INVENTORY_IMPLEMENTED = False
 
-        # ring_elevation is tested by incidence and emission
+    DEBUG = False       # True to log iterative convergence steps
 
-register_test_suite('ring', ring_test_suite)
+    ############################################################################
+    # Methods to be defined for each subclass
+    ############################################################################
+
+    def __init__(self):
+        """A constructor."""
+
+        pass
+
+    #===========================================================================
+    def uvt(self, indices, remask=False, derivs=True):
+        """Coordinates (u,v) and time t for indices into the data array.
+
+        This method supports non-integer index values.
+
+        Input:
+            indices     a Scalar or Vector of array indices.
+            remask      True to mask values outside the field of view.
+            derivs      True to include derivatives in the returned values.
+
+        Return:         (uv, time)
+            uv          a Pair defining the values of (u,v) within the FOV that
+                        are associated with the array indices.
+            time        a Scalar defining the time in seconds TDB associated
+                        with the array indices.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.uvt ' +
+                                  'is not implemented')
+
+    #===========================================================================
+    def uvt_range(self, indices, remask=False):
+        """Ranges of (u,v) spatial coordinates and time for integer array
+        indices.
+
+        Input:
+            indices     a Vector of array indices.
+            remask      True to mask values outside the field of view.
+
+        Return:         (uv_min, uv_max, time_min, time_max)
+            uv_min      a Pair defining the minimum values of (u,v) associated
+                        the pixel.
+            uv_max      a Pair defining the maximum values of (u,v).
+            time_min    a Scalar defining the minimum time associated with the
+                        pixel. It is given in seconds TDB.
+            time_max    a Scalar defining the maximum time value.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.uvt_range ' +
+                                  'is not implemented')
+
+    #===========================================================================
+    def time_range_at_uv(self, uv_pair, remask=False):
+        """The start and stop times of the specified spatial pixel (u,v).
+
+        Input:
+            uv_pair     a Pair of spatial (u,v) data array coordinates,
+                        truncated to integers if necessary.
+            remask      True to mask values outside the field of view.
+
+        Return:         a tuple containing Scalars of the start time and stop
+                        time of each (u,v) pair, as seconds TDB.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.time_range_at_uv ' +
+                                  'is not implemented')
+
+    #===========================================================================
+    def time_range_at_uv_0d(self, uv_pair, remask=False):
+        """time_range_at_uv() for some observations in which the spatial and
+        time axes are independent.
+
+        Input:
+            uv_pair     a Pair of spatial (u,v) data array coordinates,
+                        truncated to integers if necessary.
+
+        Return:         a tuple containing Scalars of the start time and stop
+                        time of each (u,v) pair, as seconds TDB.
+        """
+
+        time_min = Scalar(self.time[0])     # shapeless scalars
+        time_max = Scalar(self.time[1])
+
+        if remask:
+            uv_pair = Pair.as_pair(uv_pair, recursive=False)
+            new_mask = self.fov.uv_is_outside(uv_pair)
+            if new_mask.any_true_or_masked():
+                new_mask = Qube.or_(new_mask.vals, new_mask.mask)
+                time_min = Scalar.filled(uv_pair.shape, self.time[0],
+                                                        mask=new_mask)
+                time_max = Scalar.filled(uv_pair.shape, self.time[1],
+                                                        mask=new_mask)
+
+        return (time_min, time_max)
+
+    #===========================================================================
+    def time_range_at_uv_1d(self, uv_pair, axis=0, remask=False):
+        """time_range_at_uv() for some observations with a 1-D cadence.
+
+        Input:
+            uv_pair     a Pair of spatial (u,v) data array coordinates,
+                        truncated to integers if necessary.
+            axis        0 or 1, indicating the uv axis associated with the
+                        cadence.
+
+        Return:         a tuple containing Scalars of the start time and stop
+                        time of each (u,v) pair, as seconds TDB.
+        """
+
+        uv_pair = Pair.as_pair(uv_pair, recursive=False)
+        tstep = uv_pair.to_scalar(axis)
+
+        # Re-mask the time-independent axis if necessary
+        if remask:
+            not_t_vals = uv_pair.vals[..., 1-axis]
+            not_t_max = self.uv_shape[1-axis]
+            new_mask = Qube.or_(not_t_vals < 0, not_t_vals > not_t_max)
+            tstep = tstep.remask_or(new_mask)
+
+        return self.cadence.time_range_at_tstep(tstep, remask=remask)
+
+    #===========================================================================
+    def time_range_at_uv_2d(self, uv_pair, fast=1, remask=False):
+        """time_range_at_uv() for some observations with a 2-D cadence.
+
+        Input:
+            uv_pair     a Pair of spatial (u,v) data array coordinates,
+                        truncated to integers if necessary.
+            fast        0 or 1, indicating the uv axis associated with the
+                        fast index of the cadence. The slow index is always
+                        1 - fast.
+
+        Return:         a tuple containing Scalars of the start time and stop
+                        time of each (u,v) pair, as seconds TDB.
+        """
+
+        uv_pair = Pair.as_pair(uv_pair, recursive=False)
+
+        if fast == 1:
+            return self.cadence.time_range_at_tstep(uv_pair, remask=remask)
+        else:
+            return self.cadence.time_range_at_tstep(uv_pair.swapxy(),
+                                                    remask=remask)
+
+    #===========================================================================
+    def uv_range_at_time(self, time, remask=False):
+        """The (u,v) range of spatial pixels in the data array observed at the
+        specified time.
+
+        Input:
+            time        a Scalar of time values in seconds TDB.
+            remask      True to mask values outside the time limits.
+
+        Return:         (uv_min, uv_max)
+            uv_min      the lower (u,v) corner Pair of the area observed at the
+                        specified time.
+            uv_max      the upper (u,v) corner Pair of the area observed at the
+                        specified time.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.uv_range_at_time ' +
+                                  'is not implemented')
+
+    #===========================================================================
+    def uv_range_at_time_0d(self, time, uv_shape, remask=False):
+        """uv_range_at_time() for an observation in which any time-dependence is
+        decoupled from the spatial axes.
+
+        Input:
+            time        time Scalar.
+            uv_shape    shape of the active detector(s) within the FOV.
+            remask      True to mask times that are out of range.
+        """
+
+        # Without re-masking, shapeless Pairs are OK
+        if not remask:
+            return (Pair.INT00, Pair.as_pair(uv_shape))
+
+        # Define the new mask
+        time = Scalar.as_scalar(time, derivs=False)
+        new_mask = Qube.or_(time.mask, self.cadence.time_is_outside(time).vals)
+
+        # Without any mask, shapeless Pairs are OK
+        if not np.any(new_mask):
+            return (Pair.INT00, Pair.as_pair(uv_shape))
+
+        # Construct the array of results if necessary
+        uv_min = Pair.zeros(time.shape, dtype='int', mask=new_mask)
+        return (uv_min, uv_min + Pair.as_pair(uv_shape))
+
+    #===========================================================================
+    def uv_range_at_time_1d(self, time, uv_shape, axis=0, remask=False):
+        """uv_range_at_time() for some observations with a 1-D cadence.
+
+        Input:
+            time        time Scalar.
+            uv_shape    shape of the active detector(s) within the FOV.
+            axis        0 or 1, indicating the uv axis associated with the
+                        cadence. Alternatively, -1 indicates that time axis is
+                        not associated with a spatial axis.
+            remask      True to mask times that are out of range.
+        """
+
+        if axis < 0:
+            return self.uv_range_at_time_0d(time, uv_shape, remask=remask)
+
+        (tstep_min,
+         tstep_max) = self.cadence.tstep_range_at_time(time, remask=remask)
+
+        uv_min_vals = np.zeros(tstep_min.shape + (2,), dtype='int')
+        uv_max_vals = np.empty(tstep_min.shape + (2,), dtype='int')
+
+        uv_min_vals[..., axis] = tstep_min.vals
+        uv_max_vals[..., axis] = tstep_max.vals
+        uv_max_vals[..., 1-axis] = uv_shape[1-axis]
+
+        uv_min = Pair(uv_min_vals, tstep_min.mask)
+        uv_max = Pair(uv_max_vals, tstep_min.mask)
+        return (uv_min, uv_max)
+
+    #===========================================================================
+    def uv_range_at_time_2d(self, time, uv_shape, slow=0, fast=1, remask=False):
+        """uv_range_at_time() for some observations with a 2-D cadence.
+
+        Input:
+            time        time Scalar.
+            uv_shape    shape of the active detector(s) within the FOV.
+            slow, fast  0 or 1, indicating the uv axes associated with the slow
+                        and fast indices of the cadence. Alternatively, -1
+                        indicates that time axis is not associated with a
+                        spatial axis.
+            remask      True to mask times that are out of range.
+        """
+
+        (tstep_min,
+         tstep_max) = self.cadence.tstep_range_at_time(time, remask=remask)
+
+        if slow == 0 and fast == 1:
+            return (tstep_min, tstep_max)
+        elif slow == 1 and fast == 0:
+            return (tstep_min.swapxy(), tstep_max.swapxy())
+
+        uv_min_vals = np.zeros(tstep_min.shape + (2,), dtype='int')
+        uv_max_vals = np.empty(tstep_min.shape + (2,), dtype='int')
+        uv_max_vals[..., 0] = uv_shape[0]
+        uv_max_vals[..., 1] = uv_shape[1]
+
+        if slow >= 0:
+            uv_min_vals[..., slow] = tstep_min.vals[..., 0]
+            uv_max_vals[..., slow] = tstep_max.vals[..., 0]
+        if fast >= 0:
+            uv_min_vals[..., fast] = tstep_min.vals[..., 1]
+            uv_max_vals[..., fast] = tstep_max.vals[..., 1]
+
+        uv_min = Pair(uv_min_vals, tstep_min.mask)
+        uv_max = Pair(uv_max_vals, tstep_min.mask)
+        return (uv_min, uv_max)
+
+    #===========================================================================
+    def time_shift(self, dtime):
+        """A copy of the observation object with a time-shift.
+
+        Input:
+            dtime       the time offset to apply to the observation, in units of
+                        seconds. A positive value shifts the observation later.
+
+        Return:         a (shallow) copy of the object with a new time.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.time_shift ' +
+                                  'is not implemented')
+
+    ############################################################################
+    # Subfield support methods
+    ############################################################################
+
+    def insert_subfield(self, key, value):
+        """Add a given subfield to the Event."""
+
+        self.subfields[key] = value
+        self.__dict__[key] = value      # This makes it an attribute as well
+
+    #===========================================================================
+    def delete_subfield(self, key):
+        """Delete a subfield, but not arr or dep."""
+
+        if key in self.subfields:
+            del self.subfields[key]
+            del self.__dict__[key]
+
+    #===========================================================================
+    def delete_subfields(self):
+        """Delete all subfields."""
+
+        for key in self.subfields:
+            del self.subfields[key]
+            del self.__dict__[key]
+
+    ############################################################################
+    # Methods probably not requiring overrides
+    ############################################################################
+
+    def uv_is_outside(self, uv_pair, inclusive=True):
+        """A Boolean mask identifying coordinates outside the FOV.
+
+        Input:
+            uv_pair     a Pair of (u,v) coordinates.
+            inclusive   True to interpret coordinate values at the upper end of
+                        each range as inside the FOV; False to interpet them as
+                        outside.
+
+        Return:         a Boolean indicating True where the point is outside the
+                        FOV.
+        """
+
+        # Interpret the (u,v) coordinates
+        uv_pair = Pair.as_pair(uv_pair, recursive=False)
+        (u,v) = uv_pair.to_scalars()
+
+        # Create the mask
+        if inclusive:
+            return (u.tvl_lt(0) | v.tvl_lt(0) | u.tvl_gt(self.uv_shape[0])
+                                              | v.tvl_gt(self.uv_shape[1]))
+        else:
+            return (u.tvl_lt(0) | v.tvl_lt(0) | u.tvl_gt(self.uv_shape[0])
+                                              | v.tvl_ge(self.uv_shape[1]))
+
+    #===========================================================================
+    def midtime_at_uv(self, uv, tfrac=0.5):
+        """The mid-time for the selected spatial pixel (u,v).
+
+        Input:
+            uv          a Pair of (u,v) coordinates.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5.
+        """
+
+        (time0, time1) = self.time_range_at_uv(uv)
+        return tfrac * (time0 + time1)
+
+    #===========================================================================
+    def meshgrid(self, origin=None, undersample=1, oversample=1, limit=None,
+                       center_uv=None, fov_keywords={}):
+        """A Meshgrid shaped to broadcast to the observation's shape.
+
+        This works like Meshgrid.for_fov() except that the (u,v) axes are
+        assigned their correct locations in the axis ordering of the
+        observation.
+
+        Input:
+            origin      A single value, tuple or Pair defining the origin of the
+                        grid. Default is to place the first sample in the middle
+                        of the first pixel, allowing for under- or oversampling.
+
+            undersample A single value, tuple or Pair defining the magnitude of
+                        under-sampling to be performed. For example, a value of
+                        2 would cause the meshgrid to sample every other pixel
+                        along each axis.
+
+            oversample  A single value, tuple or Pair defining the magnitude of
+                        over-sampling to be performed. For example, a value of
+                        2 would create a 2x2 array of samples inside each pixel.
+
+            limit       A single value, tuple or Pair defining the upper limits
+                        of the meshgrid. By default, this is the shape of the
+                        FOV.
+
+            center_uv   Reference point at the center of the FOV; use None for
+                        the default, which depends on the origin and limit.
+
+            fov_keywords  an optional dictionary of parameters passed to the
+                        FOV methods, containing parameters that might affect
+                        the properties of the FOV.
+        """
+
+        return Meshgrid.for_shape(self.fov, self.shape,
+                                  self.u_axis, self.v_axis,
+                                  origin=origin,
+                                  undersample=undersample,
+                                  oversample=oversample,
+                                  limit=limit,
+                                  center_uv=center_uv,
+                                  fov_keywords=fov_keywords)
+
+    #===========================================================================
+    def timegrid(self, meshgrid, oversample=1, tfrac_limits=(0,1)):
+        """A Scalar of times broadcastable with the shape of the given meshgrid.
+
+        Input:
+            meshgrid        the meshgrid defining spatial sampling.
+            oversample      1 to obtain one time sample per pixel; > 1 for finer
+                            sampling in time.
+
+            tfrac_limits    a tuple interpreted in different ways depending on
+                            the observation's structure.
+                            - if this observation has no time-dependence, it is
+                              the pair of fractional time limits within the
+                              overall exposure duration.
+                            - if this observation has time-dependence that is
+                              entirely coupled to spatial axes, then it is the
+                              fractional time limits within each pixel's
+                              individual exposure duration.
+                            - if this observation has time-dependence that is
+                              entirely decoupled from the spatial axes, then it
+                              is the start and end time relative to the time
+                              limits of the defined cadence.
+                            - the possible case of a 2-D time-dependence that
+                              has only one axis coupled to a spatial axis is not
+                              supported.
+        """
+
+        if isinstance(tfrac_limits, numbers.Number):
+            tfrac_limits = (tfrac_limits, tfrac_limits)
+
+        # Handle a time-independent observation
+        if self.t_axis == -1:
+
+            dt = self.time[1] - self.time[0]
+            time0 = self.time[0] + tfrac_limits[0] * dt
+            time1 = self.time[0] + tfrac_limits[1] * dt
+
+            # One step implies midtime, which can be returned as a scalar
+            if oversample == 1:
+                return Scalar(0.5 * (time0 + time1))
+
+            # Otherwise, uniform time steps between endpoints
+            fracs = np.arange(oversample) / (oversample - 1.)
+            times = time0 + fracs * (time1 - time0)
+
+            # Time is on a leading axis
+            tshape = times.shape + len(self.shape) * (1,)
+            return Scalar.as_scalar(times.reshape(tshape))
+
+        # Get times at each pixel in meshgrid
+        (tstarts, tstops) = self.time_range_at_uv(meshgrid.uv)
+
+        # Scale based on tfrac_limits
+        time0 = tstarts + tfrac_limits[0] * (tstops - tstarts)
+        time1 = tstarts + tfrac_limits[1] * (tstops - tstarts)
+
+        # Handle 1-D case
+        if isinstance(self.t_axis, numbers.Number):
+
+            # Time aligns with u-axis or v-axis
+            if self.t_axis in (self.u_axis, self.v_axis):
+
+                # One time step implies midtime
+                if oversample == 1:
+                    return Scalar.as_scalar(0.5 * (time0 + time1))
+
+                # Otherwise, uniform time steps on a leading axis
+                fracs = np.arange(oversample) / (oversample - 1.)
+                fracs = fracs.reshape(fracs.shape + len(self.shape) * (1,))
+                return Scalar(time0 + fracs * (time1 - time0))
+
+            # Otherwise time is along a unique axis
+            tstep0 = tfrac_limits[0] * self.cadence.shape[0]
+            tstep1 = tfrac_limits[1] * self.cadence.shape[0]
+            tsteps = np.arange(tstep0, tstep1 + 1.e-10, 1./oversample)
+            times = self.cadence.time_at_tstep(tsteps)
+
+            shape_list = len(self.shape) * [1]
+            shape_list[self.t_axis] = len(times)
+            times = Scalar.as_scalar(times).reshape(tuple(shape_list))
+            return times
+
+        # Handle a 2-D observation
+        if (self.t_axis[0] not in (self.u_axis, self.v_axis) or
+            self.t_axis[1] not in (self.u_axis, self.v_axis)):
+                raise NotImplementedError('Observation.timegrid not ' +
+                                          'implemented for ' +
+                                          't axes (%d,%d), ' % self.t_axis,
+                                          'u axis %d, ' % self.u_axis,
+                                          'v axis %d'   % self.v_axis)
+
+        # Time aligns with u-axis AND v-axis
+
+        # One time step implies midtime
+        if oversample == 1:
+            return Scalar.as_scalar(0.5 * (time0 + time1))
+
+        # Otherwise, uniform time steps on a leading axis
+        fracs = np.arange(oversample) / (oversample - 1.)
+        fracs = fracs.reshape(fracs.shape + len(self.shape) * (1,))
+        return Scalar(time0 + fracs * (time1 - time0))
+
+    #===========================================================================
+    def event_at_grid(self, meshgrid=None, tfrac=0.5, time=None):
+        """A photon arrival event from directions defined by a meshgrid.
+
+        Input:
+            meshgrid    a Meshgrid object describing the sampling of the field
+                        of view.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5.
+            time        optional Scalar of absolute time in seconds. Only one of
+                        tfrac and time can be specified.
+
+        Return:         the corresponding event.
+        """
+
+        if time is None:
+            time = self.midtime_at_uv(meshgrid.uv, tfrac=tfrac)
+
+        event = Event(time, Vector3.ZERO, self.path, self.frame)
+
+        # Insert the arrival directions
+        event.neg_arr_ap = meshgrid.los(time)
+
+        return event
+
+    #===========================================================================
+    def gridless_event(self, meshgrid=None, tfrac=0.5, time=None,
+                             shapeless=False):
+        """A photon arrival event irrespective of the direction.
+
+        Input:
+            meshgrid    a Meshgrid object describing the sampling of the field
+                        of view; None for a directionless observation. Here, it
+                        is only used to define the times if time is None.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5. Ignored if time is specified.
+            time        Scalar of optional absolute time in seconds.
+            shapeless   True to return a shapeless event, referring to the mean
+                        of all the times.
+
+        Return:         the corresponding event.
+        """
+
+        if time is None:
+            if meshgrid is None:
+                time = self.time[0] + tfrac * (self.time[1] - self.time[0])
+            else:
+                time = self.midtime_at_uv(meshgrid.uv, tfrac=tfrac)
+
+        if shapeless:
+            time = time.mean()
+
+        return Event(time, Vector3.ZERO, self.path, self.frame)
+
+    #===========================================================================
+    @staticmethod
+    def scalar_from_indices(indices, axis, derivs=True):
+        """Utility to return the selected Scalar from a Scalar or Vector of
+        indices, np.ndarray, or a number.
+        """
+
+        if axis < 0:
+            return None
+
+        if isinstance(indices, (Scalar, Pair, Vector)):
+            return indices.to_scalar(axis, recursive=derivs)
+
+        if isinstance(indices, numbers.Real):
+            if axis not in (0, -1):
+                raise IndexError('index out of range: ' + str(indices))
+            return Scalar(indices)
+
+        indices = np.array(indices)
+
+        # The meaning of the last axis in a Numpy array is ambiguous
+        if indices.shape[-1] > axis:
+            return Scalar(indices[..., axis])
+
+        return Scalar(indices)                  # might fail; not our problem
+
+    ############################################################################
+    # Geometry solvers
+    ############################################################################
+
+    def uv_from_ra_and_dec(self, ra, dec, tfrac=0.5, time=None, apparent=True,
+                           derivs=False, iters=2, quick={}):
+        """Convert arbitrary scalars of RA and dec to FOV (u,v) coordinates.
+
+        Input:
+            ra          a Scalar of J2000 right ascensions.
+            dec         a Scalar of J2000 declinations.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5.
+            time        Scalar of optional absolute time in seconds. Only one of
+                        tfrac and time can be specified.
+            apparent    True to interpret the (RA,dec) values as apparent
+                        coordinates; False to interpret them as actual
+                        coordinates. Default is True.
+            derivs      True to propagate derivatives of ra and dec through to
+                        derivatives of the returned (u,v) Pairs.
+            iters       the number of iterations to perform until convergence
+                        is reached. Two is the most that should ever be needed;
+                        Snapshot should override to one.
+            quick       an optional dictionary to override the configured
+                        default parameters for QuickPaths and QuickFrames; False
+                        to disable the use of QuickPaths and QuickFrames. The
+                        default configuration is defined in config.py.
+
+        Return:         a Pair of (u,v) coordinates.
+
+        Note: The only reasons for iteration are that the C-matrix and the
+        velocity WRT the SSB could vary during the observation. I doubt this
+        would ever be significant.
+        """
+
+        # Convert given (ra,dec) to line of sight in SSB/J2000 frame
+        neg_arr_j2000 = Vector3.from_ra_dec_length(ra, dec, recursive=derivs)
+
+        # Interpret the time
+        if time is None:
+            obs_time = self.time[0] + tfrac * (self.time[1] - self.time[0])
+
+            # Require extra at least two iterations if tfrac != 0.5
+            if not (Scalar.as_scalar(Scalar.as_scalar(tfrac) == 0.5)).all():
+                iters = max(2, iters)
+
+        else:
+            obs_time = time
+            iters = 1
+
+        # Iterate until (u,v) has converged
+        uv = None
+        for count in range(iters):
+
+            # Define the photon arrival event
+            obs_event = Event(obs_time, Vector3.ZERO, self.path, self.frame)
+
+            if apparent:
+                obs_event.neg_arr_ap_j2000 = neg_arr_j2000
+            else:
+                obs_event.neg_arr_j2000 = neg_arr_j2000
+
+            # Convert to FOV coordinates
+            prev_uv = uv
+            uv = self.fov.uv_from_los_t(obs_event.neg_arr_ap, time=obs_time,
+                                        derivs=derivs)
+
+            # If this is the last iteration, we're done
+            if count + 1 == iters:
+                break
+
+            # Update the time
+            (t0, t1) = self.time_range_at_uv(uv)
+            obs_time = t0 + tfrac * (t1 - t0)
+
+            # Stop at convergence
+            if uv == prev_uv:
+                break
+
+        return uv
+
+    #===========================================================================
+    def uv_from_path(self, path, tfrac=0.5, time=None, derivs=False, guess=None,
+                           quick={}, converge={}):
+        """The (u,v) indices of an object in the FOV, given its path.
+        **** NOT WELL TESTED! ****
+
+        Note: This procedure assumes that movement along a path is very limited
+        during the exposure time of an individual pixel. It could fail to
+        converge if there is a large gap in timing between adjacent pixels at a
+        time when the object is crossing that gap. However, even then, it should
+        select roughly the correct location. It could also fail to converge
+        during a fast slew.
+
+        Input:
+            path        a Path object.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5.
+            time        Scalar of optional absolute time in seconds. Only one of
+                        tfrac and time can be specified; the other must be None.
+            derivs      True to propagate derivatives of the link time and
+                        position into the returned event.
+            guess       an optional guess at the light travel time from the path
+                        to the event.
+            quick       an optional dictionary to override the configured
+                        default parameters for QuickPaths and QuickFrames; False
+                        to disable the use of QuickPaths and QuickFrames. The
+                        default configuration is defined in config.py.
+            converge    an optional dictionary of parameters to override the
+                        configured default convergence parameters. The default
+                        configuration is defined in config.py.
+
+        Return:         the (u,v) indices of the pixel in which the point was
+                        found. The path is evaluated at the mid-time of this
+                        pixel.
+        """
+
+        # Assemble convergence parameters
+        if converge:
+            defaults = PATH_PHOTONS.__dict__.copy()
+            defaults.update(converge)
+            converge = defaults
+        else:
+            converge = PATH_PHOTONS.__dict__
+
+        # Take a guess at the observation time
+        if time is None:
+            obs_time = self.time[0] + tfrac * (self.time[1] - self.time[0])
+            iters = converge['max_iterations']
+            dlt_precision = converge['dlt_precision']
+            max_dt = 1.e99
+        else:
+            # In this case, no guessing is needed
+            obs_time = time
+            iters = 0
+            converged = True
+
+        for count in range(iters):
+
+            # Locate the object in the field of view
+            obs_event = Event(obs_time, Vector3.ZERO, self.path, self.frame)
+            (path_event,
+             obs_event) = path.photon_to_event(obs_event,
+                                               derivs=False, guess=guess,
+                                               quick=quick, converge=converge)
+
+            # Locate the object in the FOV frame
+            uv = self.fov.uv_from_los_t(obs_event.neg_arr_ap,
+                                        time=obs_event.time, derivs=derivs)
+
+            # Update the observation time based on pixel midtime
+            (t0, t1) = self.time_range_at_uv(uv)
+            new_obs_time = t0 + tfrac * (t1 - t0)
+
+            # Test for convergence
+            prev_max_dt = max_dt
+            max_dt = (new_obs_time - obs_time).abs().max(builtins=True,
+                                                         masked=-1.)
+            obs_time = new_obs_time
+
+            if LOGGING.observation_iterations or Observation.DEBUG:
+                LOGGING.convergence('Observation.uv_from_path',
+                                    'iter=%d; change[s]=%.6g' % (count+1,
+                                                                 max_dt))
+
+            if max_dt <= dlt_precision:
+                converged = True
+                break
+
+            if max_dt >= prev_max_dt:
+                break
+
+        if not converged:
+            LOGGING.warn('Observation.uv_from_path did not converge;',
+                         'iter=%d; change=%.6g' % (count+1, max_dt))
+
+        # Return the results
+        obs_event = Event(obs_time, Vector3.ZERO, self.path, self.frame)
+        (path_event,
+         obs_event) = path.photon_to_event(obs_event,
+                                           derivs=derivs, guess=guess,
+                                           quick=quick, converge=converge)
+
+        return self.fov.uv_from_los_t(obs_event.neg_arr_ap, time=obs_time,
+                                      derivs=derivs)
+
+    #===========================================================================
+    def uv_from_coords(self, surface, coords, tfrac=0.5, time=None,
+                             underside=False, derivs=False,
+                             quick={}, converge={}):
+        """The (u,v) indices of a surface point, given its coordinates.
+
+        Input:
+            surface     a Surface object.
+            coords      a tuple containing two or three Scalars of surface
+                        coordinates. The Scalars need not be the same shape,
+                        but must broadcast to the same shape.
+            tfrac       Scalar of fractional times during the exposure, where
+                        tfrac=0 at the beginning and 1 at the end. Default is
+                        0.5.
+            time        Scalar of optional absolute time in seconds. Only one of
+                        tfrac and time can be specified; the other must be None.
+            underside   True for the underside of the surface (emission > 90
+                        degrees) to be unmasked.
+            derivs      True to propagate derivatives of the link time and
+                        position into the returned event.
+            quick       an optional dictionary to override the configured
+                        default parameters for QuickPaths and QuickFrames; False
+                        to disable the use of QuickPaths and QuickFrames. The
+                        default configuration is defined in config.py.
+            converge    an optional dictionary of parameters to override the
+                        configured default convergence parameters. The default
+                        configuration is defined in config.py.
+
+        Return:         the (u,v) indices of the pixel in which the point was
+                        found.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.uv_from_coords '
+                                  'is not implemented')
+
+    #===========================================================================
+    def inventory(self, bodies, tfrac=0.5, time=None, expand=0.,
+                        return_type='list', fov=None, quick={}, converge={}):
+        """Info about the bodies that appear unobscured inside the FOV.
+
+        Restrictions: All inventory calculations are performed at a single
+        observation time specified by tfrac. All bodies are assumed to be
+        spherical.
+
+        Input:
+            bodies      a list of the names of the body objects to be included
+                        in the inventory.
+            tfrac       fractional time from the beginning to the end of the
+                        observation for which the inventory applies. 0 for the
+                        beginning; 0.5 for the midtime, 1 for the end time.
+                        Ignored if time is specified.
+            time        Scalar of optional absolute time in seconds.
+            expand      an optional angle in radians by which to extend the
+                        limits of the field of view. This can be used to
+                        accommodate pointing uncertainties. XXX NOT IMPLEMENTED XXX
+            return_type 'list' returns the inventory as a list of names.
+                        'flags' returns the inventory as an array of boolean
+                                flag values in the same order as bodies.
+                        'full' returns the inventory as a dictionary of
+                                dictionaries. The main dictionary is indexed by
+                                body name. The subdictionaries contain
+                                attributes of the body in the FOV.
+            fov         use this fov; if None, use self.fov.
+            quick       an optional dictionary to override the configured
+                        default parameters for QuickPaths and QuickFrames; False
+                        to disable the use of QuickPaths and QuickFrames. The
+                        default configuration is defined in config.py.
+            converge    an optional dictionary of parameters to override the
+                        configured default convergence parameters. The default
+                        configuration is defined in config.py.
+
+        Return:         list, array, or dictionary
+
+            If return_type is 'list', it returns a list of the names of all the
+            body objects that fall at least partially inside the FOV and are
+            not completely obscured by another object in the list.
+
+            If return_type is 'flags', it returns a boolean array containing
+            True everywhere that the body falls at least partially inside the
+            FOV and is not completely obscured.
+
+            If return_type is 'full', it returns a dictionary with one entry
+            per body that falls at least partially inside the FOV and is not
+            completely obscured. Each dictionary entry is itself a dictionary
+            containing data about the body in the FOV:
+
+                body_data['name']          The body name
+                body_data['center_uv']     The U,V coord of the center point
+                body_data['center']        The Vector3 direction of the center
+                                           point
+                body_data['range']         The range in km
+                body_data['outer_radius']  The outer radius of the body in km
+                body_data['inner_radius']  The inner radius of the body in km
+                body_data['resolution']    The resolution (km/pix) in the (U,V)
+                                           directions at the given range.
+                body_data['u_min']         The minimum U value covered by the
+                                           body (clipped to the FOV size)
+                body_data['u_max']         The maximum U value covered by the
+                                           body (clipped to the FOV size)
+                body_data['v_min']         The minimum V value covered by the
+                                           body (clipped to the FOV size)
+                body_data['v_max']         The maximum V value covered by the
+                                           body (clipped to the FOV size)
+                body_data['u_min_unclipped']  Same as above, but not clipped
+                body_data['u_max_unclipped']  to the FOV size.
+                body_data['v_min_unclipped']
+                body_data['v_max_unclipped']
+                body_data['u_pixel_size']  The number of pixels (non-integer)
+                body_data['v_pixel_size']  covered by the diameter of the body
+                                           in each direction.
+        """
+
+        raise NotImplementedError(type(self).__name__ + '.inventory '
+                                  'is not implemented')
+
+    ############################################################################
+    # Support for parallel observations
+    ############################################################################
+
+    def parallel_los(self, parallel, los, time=None, derivs=False):
+        """The line of sight in a parallel observation's FOV given a line of
+        sight in this observation.
+
+        Input:
+            parallel    a parallel observation (same origin and time, different
+                        frame and FOV).
+            los         a line of sight in this observation.
+            time        absolute time in seconds TDB; None to assume this
+                        observation's midtime.
+            derivs      True to include the derivatives of the los in the
+                        result.
+        """
+
+        # Define the relative frame (assuming a common origin)
+        # This frame rotates vectors from this frame to the parallel frame.
+        frame = self.frame.wrt(parallel.frame)
+
+        # Convert the LOS to the frame of the this observation
+        time = self.midtime if time is None else time
+        xform = frame.transform_at_time(time)
+        return xform.rotate(los, derivs=derivs)
+
+    def parallel_uv(self, parallel, uv, time=None, derivs=False):
+        """The (u,v) pixel coordinates in a parallel observation's FOV given
+        pixel coordinates in the FOV of this observation.
+
+        Input:
+            parallel    a parallel observation (same origin and time, different
+                        frame and FOV).
+            uv          (u,v) pixel coordinates in this observation.
+            time        absolute time in seconds TDB; None to assume this
+                        observation's midtime.
+            derivs      True to include the derivatives of uv in the result.
+        """
+
+        # Convert the coordinates to a line of sight
+        time = self.midtime if time is None else time
+        los = self.fov.los_from_uvt(uv, time=time, derivs=derivs)
+
+        # Transform to the parallel observation
+        los = self.parallel_los(los, parallel, time=time, derivs=derivs)
+
+        # Convert to coordinates in the new FOV
+        return parallel.fov.uv_from_los_t(los, time=time, derivs=derivs)
+
+    def parallel_offset_angles(self, parallel, angles, time=None):
+        """The offset angles in a parallel observation's FOV and frame, given
+        the pointing offset in this observation.
+
+        Input:
+            parallel    a parallel observation (same origin and time, different
+                        frame and FOV). Alternatively, a tuple of two values:
+                        (frame, fov).
+            angles      a tuple or list of two offset angles in radians. The
+                        first rotation is about the Y axis of this observation's
+                        frame and the second is about the X axis.
+            time        absolute time in seconds TDB; None to assume this
+                        observation's midtime.
+            derivs      True to include the derivatives of uv in the result.
+        """
+
+        if isinstance(parallel, Observation):
+            parallel_frame = parallel.frame
+            parallel_fov = parallel.fov
+        else:
+            (parallel_frame, parallel_fov) = parallel
+
+        # Define the relative frame (assuming a common origin)
+        # This frame rotates vectors from this observation's frame to the parallel
+        # frame.
+        frame = self.frame.wrt(parallel_frame)
+        time = self.midtime if time is None else time
+        xform = frame.transform_at_time(time)
+
+        # Get the parallel observation's line of sight in this frame
+        uv = parallel_fov.uv_shape/2.
+        los0_parallel = parallel_fov.los_from_uvt(uv, time=time)
+        los0 = xform.unrotate(los0_parallel)
+
+        # Perform the rotations in this frame
+        # The angles refer to rotations of the axes, not the vectors, so they
+        # need to be reversed here.
+        los1 = los0.spin(Vector3.YAXIS, angles[0])
+        los1 = los1.spin(Vector3.XAXIS, angles[1])
+
+        # Convert back to the parallel's frame
+        los1_parallel = xform.rotate(los1)
+
+        # Return the new rotation angles
+        return los0_parallel.offset_angles(los1_parallel)
+
+    def parallel_offset_duv(self, parallel, duv, time=None, origin=None):
+        """The (u,v) pixel coordinate offset from the center of a parallel
+        observation's FOV, given a pointing offset for this observation.
+
+        Input:
+            parallel    a parallel observation (same origin and time, different
+                        frame and FOV).
+            duv         the (u,v) coordinate offset from the predicted location
+                        of a feature to its actual location.
+            time        absolute time in seconds TDB; None to assume this
+                        observation's midtime.
+            origin      the (u,v) coordinates of the reference point in this
+                        observation's FOV, from which the offset is measured. If
+                        unspecified, the center of the FOV is assumed.
+        """
+
+        angles = self.fov.offset_angles_from_duv(duv, time=time, origin=origin)
+        angles = self.parallel_offset_angles(parallel, angles, time=time)
+        return parallel.fov.duv_from_offset_angles(angles, time=time)
 
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/spheroid.py` & `rms_oops-0.0.4/oops/backplane/spheroid.py`

 * *Files 22% similar despite different names*

```diff
@@ -420,163 +420,7 @@
 
 ################################################################################
 
 # Add these functions to the Backplane module
 Backplane._define_backplane_names(globals().copy())
 
 ################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-from oops.backplane.gold_master import register_test_suite
-from oops.body import Body
-from oops.constants import DPR
-import numpy as np
-
-def spheroid_test_suite(bpt):
-
-    bp = bpt.backplane
-    for name in bpt.body_names + bpt.limb_names:
-
-        radius = 1.5 if name in bpt.limb_names else 1.
-            # The extra flexibility in the testing of limb calculations seems to
-            # reduce the number of false positives.
-
-        # Longitude
-        cos_lat = bp.latitude(name).cos().min(builtins=True)
-        bpt.gmtest(bp.longitude(name, 'iau'),
-                   name + ' longitude, IAU (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, 'obs'),
-                   name + ' longitude wrt observer (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, reference='obs', minimum=-180),
-                   name + ' longitude wrt observer, minimum -180 (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, 'oha'),
-                   name + ' longitude wrt OHA (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, 'sun'),
-                   name + ' longitude wrt Sun (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, 'sha'),
-                   name + ' longitude wrt SHA (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-        bpt.gmtest(bp.longitude(name, direction='east'),
-                   name + ' longitude eastward (deg)',
-                   limit=0.001/cos_lat, method='mod360', radius=radius)
-
-        # Latitude
-        bpt.gmtest(bp.latitude(name, lat_type='centric'),
-                   name + ' latitude, planetocentric (deg)',
-                   limit=0.001, method='degrees', radius=radius)
-        bpt.gmtest(bp.latitude(name, lat_type='graphic'),
-                   name + ' latitude, planetographic (deg)',
-                   limit=0.001, method='degrees', radius=radius)
-
-    for name in bpt.body_names:
-
-        # Sub-observer longitude and latitude
-        cos_lat = bp.sub_observer_latitude(name).cos().mean(builtins=True)
-        bpt.gmtest(bp.sub_observer_longitude(name, reference='iau'),
-                   name + ' sub-observer longitude, IAU (deg)',
-                   limit=0.001/cos_lat, method='mod360')
-        bpt.gmtest(bp.sub_observer_longitude(name, reference='sun', minimum=-180),
-                   name + ' sub-observer longitude wrt Sun (deg)',
-                   limit=0.001/cos_lat, method='mod360')
-        bpt.compare(bp.sub_observer_longitude(name, reference='obs', minimum=-180),
-                    0.,
-                    name + ' sub-observer longitude wrt observer (deg)',
-                    method='mod360')
-
-        bpt.gmtest(bp.sub_observer_latitude(name, lat_type='centric'),
-                   name + ' sub-observer latitude, planetocentric (deg)',
-                   limit=0.001, method='degrees')
-        bpt.gmtest(bp.sub_observer_latitude(name, lat_type='graphic'),
-                   name + ' sub-observer latitude, planetographic (deg)',
-                   limit=0.001, method='degrees')
-
-        # Sub-solar longitude and latitude
-        cos_lat = bp.sub_solar_latitude(name).cos().mean(builtins=True)
-        bpt.gmtest(bp.sub_solar_longitude(name, reference='iau'),
-                   name + ' sub-solar longitude wrt IAU (deg)',
-                   limit=0.001/cos_lat, method='mod360')
-        bpt.gmtest(bp.sub_solar_longitude(name, reference='obs', minimum=-180),
-                   name + ' sub-solar longitude wrt observer (deg)',
-                   limit=0.001/cos_lat, method='mod360')
-        bpt.compare(bp.sub_solar_longitude(name, reference='sun', minimum=-180),
-                    0.,
-                    name + ' sub-solar longitude wrt Sun (deg)',
-                    method='mod360')
-
-        bpt.gmtest(bp.sub_solar_latitude(name, lat_type='centric'),
-                   name + ' sub-solar latitude, planetocentric (deg)',
-                   limit=0.001, method='degrees')
-        bpt.gmtest(bp.sub_solar_latitude(name, lat_type='graphic'),
-                   name + ' sub-solar latitude, planetographic (deg)',
-                   limit=0.001, method='degrees')
-
-    # Test of an empty backplane
-    for (planet, name) in bpt.planet_moon_pairs:
-        if planet != 'PLUTO':
-            bpt.compare(bp.longitude('STYX'),
-                        0.,
-                        'Styx longitude (deg)')
-            break   # no need to repeat this test!
-
-    # Derivative tests
-    if bpt.derivs:
-      (bp, bp_u0, bp_u1, bp_v0, bp_v1) = bpt.backplanes
-      pixel_duv = np.abs(bp.obs.fov.uv_scale.vals)
-
-      for name in bpt.body_names:
-
-        # Get approximate projected surface scale in degrees lat/lon per pixel
-        km_per_fov_radian = bp.distance(name) / bp.mu(name)
-        rad_per_fov_radian = km_per_fov_radian / Body.lookup(name).radius
-        deg_per_fov_radian = rad_per_fov_radian * DPR
-
-        # longitude
-        cos_lat = bp.latitude(name).cos()
-        (ulimit,
-         vlimit) = (deg_per_fov_radian/cos_lat).median() * pixel_duv * 0.01
-
-        lon = bp.longitude(name)
-        dlon_duv = lon.d_dlos.chain(bp.dlos_duv)
-        (dlon_du, dlon_dv) = dlon_duv.extract_denoms()
-
-        dlon = (bp_u1.longitude(name) - bp_u0.longitude(name)).abs()
-        dlon = Scalar.PI - (dlon.wod - Scalar.PI).abs()
-        if not np.all(dlon.mask):
-            bpt.compare((dlon/bpt.duv - dlon_du).abs().median(), 0.,
-                        name + ' longitude d/du self-check (deg/pix)',
-                        limit=ulimit, method='degrees')
-
-        dlon = (bp_v1.longitude(name) - bp_v0.longitude(name)).abs()
-        dlon = Scalar.PI - (dlon.wod - Scalar.PI).abs()
-        if not np.all(dlon.mask):
-            bpt.compare((dlon/bpt.duv - dlon_dv).abs().median(), 0.,
-                        name + ' longitude d/dv self-check (deg/pix)',
-                        limit=vlimit, method='degrees')
-
-        (ulimit, vlimit) = deg_per_fov_radian.median() * pixel_duv * 0.01
-
-        # latitude
-        lat = bp.latitude(name)
-        dlat_duv = lat.d_dlos.chain(bp.dlos_duv)
-        (dlat_du, dlat_dv) = dlat_duv.extract_denoms()
-
-        dlat = bp_u1.latitude(name) - bp_u0.latitude(name)
-        if not np.all(dlat.mask):
-            bpt.compare((dlat.wod/bpt.duv - dlat_du).abs().median(), 0.,
-                        name + ' latitude d/du self-check (deg/pix)',
-                        limit=ulimit, radius=1, method='degrees')
-
-        dlat = bp_v1.latitude(name) - bp_v0.latitude(name)
-        if not np.all(dlat.mask):
-            bpt.compare((dlat.wod/bpt.duv - dlat_dv).abs().median(), 0.,
-                        name + ' latitude d/dv self-check (deg/pix)',
-                        limit=vlimit, radius=1, method='degrees')
-
-register_test_suite('spheroid', spheroid_test_suite)
-
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/backplane/where.py` & `rms_oops-0.0.4/oops/backplane/where.py`

 * *Files 18% similar despite different names*

```diff
@@ -267,14 +267,16 @@
     """A mask where the backplane is <= the specified value.
 
     If tvl is True, this uses three-valued logic, where masked backplane values
     remain masked; otherwise, they are False.
     """
 
     backplane_key = self.standardize_backplane_key(backplane_key)
+
+    value = value.vals if isinstance(value, Scalar) else value
     key = ('where_below', backplane_key, value, tvl)
 
     if key not in self.backplanes:
         backplane = self.evaluate(backplane_key)
         tvl_result = backplane.tvl_le(value)
 
         # Set the internal values to False at every masked location
@@ -291,14 +293,16 @@
     """A mask where the backplane is >= the specified value.
 
     If tvl is True, this uses three-valued logic, where masked backplane values
     remain masked; otherwise, they are False.
     """
 
     backplane_key = self.standardize_backplane_key(backplane_key)
+
+    value = value.vals if isinstance(value, Scalar) else value
     key = ('where_above', backplane_key, value, tvl)
 
     if key not in self.backplanes:
         backplane = self.evaluate(backplane_key)
         tvl_result = backplane.tvl_ge(value)
 
         # Set the internal values to False at every masked location
@@ -315,14 +319,17 @@
     """A mask where the backplane is between the given values, inclusive.
 
     If tvl is True, this uses three-valued logic, where masked backplane values
     remain masked; otherwise, they are False.
     """
 
     backplane_key = self.standardize_backplane_key(backplane_key)
+
+    low  = low.vals  if isinstance(low,  Scalar) else low
+    high = high.vals if isinstance(high, Scalar) else high
     key = ('where_between', backplane_key, low, high, tvl)
 
     if key not in self.backplanes:
         backplane = self.evaluate(backplane_key)
         tvl_result = backplane.tvl_ge(low) & backplane.tvl_le(high)
 
         # Set the internal values to False at every masked location
@@ -407,131 +414,7 @@
 
 ################################################################################
 
 # Add these functions to the Backplane module
 Backplane._define_backplane_names(globals().copy())
 
 ################################################################################
-# GOLD MASTER TESTS
-################################################################################
-
-from oops.backplane.gold_master import register_test_suite
-from oops.constants import PI, HALFPI
-
-def where_test_suite(bpt):
-
-    bp = bpt.backplane
-    for name in bpt.body_names:
-        intercepted = bp.where_intercepted(name)
-        sunward     = bp.where_sunward(name, tvl=True)
-        antisunward = bp.where_antisunward(name, tvl=True)
-
-        bpt.gmtest(intercepted,
-                   name + ' where intercepted',
-                   radius=1.5)
-        bpt.gmtest(sunward,
-                   name + ' where sunward',
-                   radius=1.5)
-        bpt.gmtest(antisunward,
-                   name + ' where anti-sunward',
-                   radius=1.5)
-        bpt.compare(intercepted == (sunward.vals | antisunward.vals),
-                    True,
-                    name + ' mask eq sunward|antisunward')
-        bpt.compare(sunward.tvl_eq(bp.where_below(('incidence_angle', name),
-                                                  HALFPI, tvl=True)),
-                    True,
-                    name + ' where sunward eq incidence below 90 deg')
-        bpt.compare(antisunward.tvl_eq(bp.where_above(('incidence_angle', name),
-                                                      HALFPI, tvl=True)),
-                    True,
-                    name + ' where antisunward eq incidence above 90 deg')
-        bpt.compare(bp.where_above(('phase_angle', name), PI, tvl=False),
-                    False,
-                    name + ' where phase angle below 180 deg')
-        bpt.compare(intercepted == bp.evaluate(('where_intercepted', name)),
-                    True,
-                    name + ' mask eq via evaluate')
-
-    for (planet, ring) in bpt.planet_ring_pairs:
-
-        # Planet first
-        intercepted = bp.where_intercepted(planet)
-        in_front = bp.where_in_front(planet, ring, tvl=True)
-        in_back  = bp.where_in_back(planet, ring, tvl=True)
-        bpt.gmtest(in_front,
-                   planet + ' where in front of ' + ring,
-                   radius=1.5)
-        bpt.gmtest(in_back,
-                   planet + ' where behind ' + ring,
-                   radius=1.5)
-        bpt.compare(intercepted == (in_front.vals | in_back.vals),
-                    True,
-                    planet + ' mask eq in front|behind ' + ring)
-
-        inside  = bp.where_inside_shadow(planet, ring, tvl=True)
-        outside = bp.where_outside_shadow(planet, ring, tvl=True)
-        bpt.gmtest(inside,
-                   planet + ' where shadowed by ' + ring,
-                   radius=1.5)
-        bpt.gmtest(outside,
-                   planet + ' where un-shadowed by ' + ring,
-                   radius=1.5)
-        bpt.compare(intercepted == (inside.vals | outside.vals),
-                    True,
-                    planet + ' mask eq inside|outside shadow of ' + ring)
-
-        # Ring first
-        intercepted = bp.where_intercepted(ring)
-        in_front = bp.where_in_front(ring, planet, tvl=True)
-        in_back  = bp.where_in_back(ring, planet, tvl=True)
-        bpt.gmtest(in_front,
-                   ring + ' where in front of ' + planet,
-                   radius=1.5)
-        bpt.gmtest(in_back,
-                   ring + ' where behind ' + planet,
-                   radius=1.5)
-        bpt.compare(intercepted == (in_front.vals | in_back.vals),
-                    True,
-                    ring + ' mask eq in front|behind ' + planet)
-
-        inside  = bp.where_inside_shadow(ring, planet, tvl=True)
-        outside = bp.where_outside_shadow(ring, planet, tvl=True)
-        bpt.gmtest(inside,
-                   ring + ' where inside shadow of ' + planet,
-                   radius=1.5)
-        bpt.gmtest(outside,
-                   ring + ' where outside shadow of ' + planet,
-                   radius=1.5)
-        bpt.compare(intercepted == (inside.vals | outside.vals),
-                    True,
-                    ring + ' mask eq inside|outside shadow of ' + planet)
-
-        # Ring inside planet test
-        if ':' in ring:             # just consider the unmasked ring
-            interior = bp.where_inside(ring, planet, tvl=True)
-            bpt.gmtest(interior,
-                       ring + ' where inside ' + planet,
-                       radius=1.5)
-
-    for name in bpt.ring_names:
-        intercepted = bp.where_intercepted(name)
-        sunward     = bp.where_sunward(name, tvl=True)
-        antisunward = bp.where_antisunward(name, tvl=True)
-
-        bpt.gmtest(intercepted,
-                   name + ' where intercepted',
-                   radius=1.5)
-        bpt.gmtest(sunward,
-                   name + ' where sunward',
-                   radius=1.5)
-        bpt.gmtest(antisunward,
-                   name + ' where anti-sunward',
-                   radius=1.5)
-
-        bpt.compare(bp.where_below(('ring_radius', ring), 0.),
-                    False,
-                    name + ' where radius is negative')
-
-register_test_suite('where', where_test_suite)
-
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/body.py` & `rms_oops-0.0.4/oops/body.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 ################################################################################
 # oops/body.py: Body class
 ################################################################################
 
-import numpy as np
 import numbers
+import numpy as np
 
 import cspyce
 import spicedb
 
 from polymath                    import Vector3
-from oops.frame                  import Frame, AliasFrame
+from oops.frame.frame_           import Frame, AliasFrame
 from oops.frame.poleframe        import PoleFrame
 from oops.frame.ringframe        import RingFrame
 from oops.frame.spiceframe       import SpiceFrame
 from oops.frame.synchronousframe import SynchronousFrame
 from oops.frame.twovectorframe   import TwoVectorFrame
-from oops.gravity                import Gravity
+from oops.gravity.gravity_       import Gravity
 from oops.gravity.oblategravity  import OblateGravity
-from oops.path                   import Path
+from oops.path.path_             import Path
 from oops.path.multipath         import MultiPath
 from oops.path.spicepath         import SpicePath
 from oops.surface.nullsurface    import NullSurface
 from oops.surface.orbitplane     import OrbitPlane
 from oops.surface.ringplane      import RingPlane
 from oops.surface.spice_shape    import spice_shape
 
@@ -1653,74 +1653,7 @@
             shape = NullSurface(path, frame)
             body.apply_surface(shape, 0., 0.)
 
         body.is_standard = bool(is_standard)
         body.spk = spk
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Body(unittest.TestCase):
-
-    def runTest(self):
-
-        # Imports are here to avoid conflicts
-        Path.reset_registry()
-        Frame.reset_registry()
-        Body.reset_registry()
-
-        Body.define_solar_system('2000-01-01', '2020-01-01')
-
-        self.assertEqual(Body.lookup('DAPHNIS').barycenter.name,
-                         'SATURN')
-        self.assertEqual(Body.lookup('PHOEBE').barycenter.name,
-                         'SATURN BARYCENTER')
-
-        mars = Body.lookup('MARS')
-        moons = mars.select_children(include_all=['SATELLITE'])
-        self.assertEqual(len(moons), 2)     # Phobos, Deimos
-
-        saturn = Body.lookup('SATURN')
-        moons = saturn.select_children(include_all=['CLASSICAL', 'IRREGULAR'])
-        self.assertEqual(len(moons), 1)     # Phoebe
-
-        moons = saturn.select_children(exclude=['IRREGULAR','RING'], radius=160)
-        self.assertEqual(len(moons), 8)     # Mimas-Iapetus
-
-        rings = saturn.select_children(include_any=('RING'))
-        self.assertEqual(len(rings), 8)     # A, B, C, AB, Main, all, plane,
-                                            # system
-
-        moons = saturn.select_children(include_all='SATELLITE',
-                                       exclude=('IRREGULAR'), radius=1000)
-        self.assertEqual(len(moons), 1)     # Titan only
-
-        sun = Body.lookup('SUN')
-        planets = sun.select_children(include_any=['PLANET'])
-        self.assertEqual(len(planets), 9)
-
-        sun = Body.lookup('SUN')
-        planets = sun.select_children(include_any=['PLANET', 'EARTH'])
-        self.assertEqual(len(planets), 9)
-
-        sun = Body.lookup('SUN')
-        planets = sun.select_children(include_any=['PLANET', 'EARTH'],
-                                      recursive=True)
-        self.assertEqual(len(planets), 10)  # 9 planets plus Earth's moon
-
-        sun = Body.lookup('SUN')
-        planets = sun.select_children(include_any=['PLANET', 'JUPITER'],
-                                      exclude=['IRREGULAR', 'BARYCENTER', 'IO'],
-                                      recursive=True)
-        self.assertEqual(len(planets), 16)  # 9 planets + 7 Jovian moons
-
-        Path.reset_registry()
-        Frame.reset_registry()
-        Body.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/__init__.py` & `rms_oops-0.0.4/oops/cadence/cadence_.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 ################################################################################
-# oops/cadence/__init__.py: Abstract class Cadence
+# oops/cadence/cadence_: Abstract class Cadence
 ################################################################################
 
 from polymath import Scalar, Pair
 
 class Cadence(object):
     """Cadence is an abstract class that defines the timing of an observation.
 
@@ -242,24 +242,7 @@
             return tstride
 
         raise NotImplementedError(type(self).__name__ + '.tstride_at_tstep '
                                   'is not implemented for %d-D cadences'
                                   % len(self.shape))
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Cadence(unittest.TestCase):
-
-    def runTest(self):
-
-        # No tests here - this is just an abstract superclass
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/all.py` & `rms_oops-0.0.4/tests/cadence/unittester.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,16 +1,17 @@
-################################################################################
-# oops/cadence/all.py
+###############################################################################
+# tests/cadence/unittester.py
 ################################################################################
 
-# Import the Cadence class and all its subclasses into a common name space
+import unittest
 
-from oops.cadence                 import Cadence
-from oops.cadence.dualcadence     import DualCadence
-from oops.cadence.instant         import Instant
-from oops.cadence.metronome       import Metronome
-from oops.cadence.reshapedcadence import ReshapedCadence
-from oops.cadence.reversedcadence import ReversedCadence
-from oops.cadence.sequence        import Sequence
-from oops.cadence.tdicadence      import TDICadence
+from tests.cadence.test_dualcadence     import Test_DualCadence
+from tests.cadence.test_metronome       import Test_Metronome
+from tests.cadence.test_reshapedcadence import Test_ReshapedCadence
+from tests.cadence.test_reversedcadence import Test_ReversedCadence
+from tests.cadence.test_sequence        import Test_Sequence
+from tests.cadence.test_tdicadence      import Test_TDICadence
 
+########################################
+if __name__ == '__main__':
+    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/dualcadence.py` & `rms_oops-0.0.4/tests/cadence/test_tdicadence.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,683 +1,475 @@
 ################################################################################
-# oops/cadence/dualcadence.py: DualCadence subclass of class Cadence
+# oops/cadence/tdicadence.py: TDICadence subclass of class Cadence
 ################################################################################
 
-from polymath               import Qube, Boolean, Scalar, Pair, Vector
-from oops.cadence           import Cadence
-from oops.cadence.metronome import Metronome
-
-class DualCadence(Cadence):
-    """A Cadence subclass in which time steps are defined by a pair of cadences.
-    """
-
-    #===========================================================================
-    def __init__(self, long, short):
-        """Constructor for a DualCadence.
-
-        Input:
-            long        the long or outer cadence. It defines the larger steps
-                        of the cadence, including the overall start time.
-            short       the short or inner cadence. It defines the time steps
-                        that break up the outer cadence, including the exposure
-                        time.
-        """
-
-        self.long = long
-        self.short = short.time_shift(-short.time[0])   # starts at time 0
-
-        self.shape = self.long.shape + self.short.shape
-        if len(self.long.shape) != 1 or len(self.short.shape) != 1:
-            raise ValueError('long and short cadences must be 1-D')
-
-        self.time = (self.long.time[0],
-                     self.long.lasttime + self.short.time[1])
-        self.midtime = (self.time[0] + self.time[1]) * 0.5
-        self.lasttime = self.long.lasttime + self.short.lasttime
-
-        self.is_continuous = (self.short.is_continuous and
-                              self.time[0] >= self.long.max_tstride)
-
-        self.is_unique = (self.short.is_unique and
-                          self.short.time[0] <= self.long.min_tstride)
-
-        self.min_tstride = self.short.min_tstride
-        self.max_tstride = max(self.long.max_tstride - self.short.time[1],
-                               self.short.max_tstride)
-
-        self._max_long_tstep = self.long.shape[0] - 1
-
-    def __getstate__(self):
-        return (self.long, self.short)
-
-    def __setstate__(self, state):
-        self.__init__(*state)
-
-    #===========================================================================
-    def time_at_tstep(self, tstep, remask=False, derivs=False, inclusive=True):
-        """The time associated with the given time step.
-
-        This method supports non-integer time step values.
-
-        Input:
-            tstep       a Pair of time step index values.
-            remask      True to mask values outside the time limits.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar of times in seconds TDB.
-        """
-
-        tstep = Pair.as_pair(tstep, recursive=derivs)
-        (long_tstep, short_tstep) = tstep.to_scalars()
-
-        # Determine long start time
-        long_time = self.long.time_range_at_tstep(long_tstep, remask=remask,
-                                                  inclusive=inclusive)[0]
-
-        # Determine short time
-        short_time = self.short.time_at_tstep(short_tstep, remask=remask,
-                                              derivs=derivs,
-                                              inclusive=inclusive)
-
-        return long_time + short_time
-
-    #===========================================================================
-    def time_range_at_tstep(self, tstep, remask=False, inclusive=True):
-        """The range of times for the given time step.
-
-        Input:
-            tstep       a Pair of time step index values.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (time_min, time_max)
-            time_min    a Scalar defining the minimum time associated with the
-                        index. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
-        """
-
-        tstep = Pair.as_pair(tstep, recursive=False)
-        (long_tstep, short_tstep) = tstep.to_scalars()
-
-        # Determine long start time
-        long_time0 = self.long.time_range_at_tstep(long_tstep, remask=remask,
-                                                   inclusive=inclusive)[0]
-
-        # Determine short time range
-        short_times = self.short.time_range_at_tstep(short_tstep,
-                                                     remask=remask,
-                                                     inclusive=inclusive)
-
-        return (long_time0 + short_times[0], long_time0 + short_times[1])
-
-    #===========================================================================
-    def tstep_at_time(self, time, remask=False, derivs=False, inclusive=True):
-        """Time step for the given time.
-
-        This method returns non-integer time steps.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Pair of time step index values.
-        """
-
-        time = Scalar.as_scalar(time, recursive=derivs)
-
-        # Determine long tstep
-        # We need remask=False because the end time of each long cadence is
-        # ignored; remask=True might mask some times incorrectly.
-        tstep0 = self.long.tstep_range_at_time(time, remask=False,
-                                               inclusive=inclusive)[0]
-
-        # Determine short tstep
-        time0 = self.long.time_at_tstep(tstep0, remask=remask,
-                                        inclusive=inclusive)
-        tstep1 = self.short.tstep_at_time(time - time0, remask=remask,
-                                          derivs=derivs,
-                                          inclusive=inclusive)
-
-        # Revise long time step above the time limits
-        if inclusive:
-            tstep0[time.vals > self.time[1]] = self.shape[0]
-        else:
-            tstep0[time.vals >= self.time[1]] = self.shape[0]
-
-        return Pair.from_scalars(tstep0, tstep1)
-
-    #===========================================================================
-    def tstep_range_at_time(self, time, remask=False, inclusive=True):
-        """Integer range of time steps active at the given time.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (tstep_min, tstep_max)
-            tstep_min   minimum Pair time step containing the given time.
-            tstep_max   maximum Pair time step containing the given time
-                        (inclusive).
-
-        All returned indices will be in the allowed range for the cadence,
-        inclusive, regardless of mask. If the time is not inside the cadence,
-        tstep_max < tstep_min.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-
-        # Find integer tsteps at or below the time values, unmasked.
-        # Times before the start time map to tstep0_min = 0;
-        # Times during or after the last time step map to shape[0]-1.
-        tstep0_min = self.long.tstep_range_at_time(time, remask=False,
-                                                   inclusive=False)[0]
-        tstep0_max = tstep0_min + 1
-
-        # Unique case is MUCH easier
-        if self.is_unique:
-
-            # Determine short tstep range
-            time0 = self.long.time_at_tstep(tstep0_min, remask=remask,
-                                            inclusive=inclusive)
-
-            # Note: exclude the last moment of each short cadence
-            # We address the last moment of the cadence overall below
-            (tstep1_min,
-             tstep1_max) = self.short.tstep_range_at_time(time - time0,
-                                                          remask=remask,
-                                                          inclusive=False)
-
-            # Time step ranges outside time limits are already zero-length
-
-            # Handle the last moment of the cadence
-            if inclusive:
-                mask = (time.vals == self.time[1]) & time.antimask
-                tstep1_min[mask] = self.shape[1] - 1    # this also unmasks
-                tstep1_max[mask] = self.shape[1]
-
-        else:
-            raise NotImplementedError('tstep_range_at_time is not implemented '+
-                                      'for a non-unique DualCadence')
-
-        # This step merges the tstep1 mask over the incomplete tstep0 masks
-        tstep_min = Pair.from_scalars(tstep0_min, tstep1_min)
-        tstep_max = Pair.from_scalars(tstep0_max, tstep1_max)
-        return (tstep_min, tstep_max)
-
-    #===========================================================================
-    def time_is_outside(self, time, inclusive=True):
-        """A Boolean mask of times that fall outside the cadence.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            inclusive   True to treat the end time of an interval as inside the
-                        cadence; False to treat it as outside. The start time of
-                        an interval is always treated as inside.
-
-        Return:         a Boolean array indicating which time values are not
-                        sampled by the cadence.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-
-        # Easier case
-        if self.is_continuous:
-            if inclusive:
-                return (time < self.time[0]) | (time > self.time[1])
-            else:
-                return (time < self.time[0]) | (time >= self.time[1])
-
-        # Determine long tstep
-        tstep0 = self.long.tstep_range_at_time(time, inclusive=inclusive)[0]
-
-        # Test for short tstep
-        time0 = self.long.time_at_tstep(tstep0, inclusive=inclusive)
-        return self.short.time_is_outside(time - time0, inclusive=inclusive)
-
-    #===========================================================================
-    def time_shift(self, secs):
-        """Construct a duplicate of this Cadence with all times shifted by given
-        amount.
-
-        Input:
-            secs        the number of seconds to shift the time later.
-        """
-
-        return DualCadence(self.long.time_shift(secs), self.short)
-
-    #===========================================================================
-    def as_continuous(self):
-        """Construct a shallow copy of this Cadence, forced to be continuous.
-
-        For DualCadence, this is accomplished by forcing the stride of
-        the short cadence to be continuous.
-        """
-
-        if self.time[0] >= self.long._max_tstride:
-            return DualCadence(self.long, self.short.as_continuous())
-
-        raise ValueError('short internal cadence cannot be extended to make ' +
-                         'this DualCadence continuous')
-
-    #===========================================================================
-    @staticmethod
-    def for_array2d(samples, lines, tstart, texp, intersample_delay=0.,
-                                                  interline_delay=None):
-        """Alternative constructor for a DualCadence involving two Metronome
-        classes, with streamlined input.
-
-        Input:
-            samples             number of samples (along fast axis).
-            lines               number of lines (along slow axis).
-            tstart              start time of observation in TDB seconds.
-            texp                single-sample integration time in seconds.
-            intersample_delay   deadtime in seconds between consecutive samples;
-                                default 0.
-            interline_delay     deadtime in seconds between consecutive lines,
-                                i.e., the delay between the end of the last
-                                sample integration on one line and the start of
-                                the first sample integration on the next line.
-                                If not specified, the interline_delay is assumed
-                                to match the intersample_delay.
-        """
-
-        fast_cadence = Metronome(tstart, texp + intersample_delay, texp,
-                                 samples)
-
-        if interline_delay is None:
-            interline_delay = intersample_delay
-
-        long_texp = samples * texp + (samples-1) * intersample_delay
-        long_stride = long_texp + interline_delay
-
-        slow_cadence = Metronome(tstart, long_stride, long_texp, lines)
-
-        return DualCadence(slow_cadence, fast_cadence)
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
 import numpy as np
+import unittest
 
-class Test_DualCadence(unittest.TestCase):
-
-    @staticmethod
-    def meshgrid(*args):
-        """A new Vector constructed by combining every possible set of
-        components provided as a list of scalars. The returned Vector will
-        have a shape defined by concatenating the shapes of all the arguments.
-
-        This routine was stolen from the old array_ module and is not optimized
-        for use with polymath.
-        """
-
-        scalars = []
-        newshape = []
-        dtype = 'int'
-        for arg in args:
-            scalar = Scalar.as_scalar(arg)
-            scalars.append(scalar)
-            newshape += scalar.shape
-            if scalar.vals.dtype.kind == 'f':
-                dtype = 'float'
-
-        buffer = np.empty(newshape + [len(args)], dtype=dtype)
-
-        newaxes = []
-        count = 0
-        for scalar in scalars[::-1]:
-            newaxes.append(count)
-            count += len(scalar.shape)
-
-        newaxes.reverse()
-
-        for i in range(len(scalars)):
-            scalars[i] = scalars[i].reshape(scalars[i].shape +
-                                            newaxes[i] * (1,))
-
-        reshaped = Qube.broadcast(*scalars)
+from polymath import Scalar
+import oops
 
-        for i in range(len(reshaped)):
-            buffer[...,i] = reshaped[i].vals
 
-        return Vector(buffer)
+class Test_TDICadence(unittest.TestCase):
 
     def runTest(self):
 
-        np.random.seed(4305)
-
-        # cad2d has shape (10,5)
-        # cad1d has shape (50,)
-        # We define them so that cad2d[i,j] = cad1d[5*i+j]
+        ########################################
+        # 10 lines, 2 stages, TDI downward, 100-120
+        ########################################
 
-        # These should be equivalent except for 1-D vs. 2-D indexing
+        cad = oops.cadence.TDICadence(10, 100., 10., 2)
+        case_tdicadence_10_100_10_2_down(self, cad)
 
-        # cad1d: 100-101, 102-103, 104-105, ... 198-199.
-        cad1d = Metronome(100., 2., 1., 50)
+        ########################################
+        # 10 lines, 2 stages, TDI upward
+        ########################################
 
-        # 100-101, 110-111, 120-121, ... 190-191. (End time doesn't matter)
-        long = Metronome(100., 10., 1., 10)
+        cad = oops.cadence.TDICadence(10, 100., 10., 2, tdi_sign=1)
+        case_tdicadence_10_100_10_2_up(self, cad)
 
-        # 0-1, 2-3, 4-5, 6-7, 8-9
-        short = Metronome(0, 2., 1., 5)
+        ########################################
+        # 100 lines, 100 stages, TDI downward
+        ########################################
 
-        cad2d = DualCadence(long, short)
-        case_dual_metronome(self, cad1d, cad2d)
+        cad = oops.cadence.TDICadence(100, 1000., 10., 100)
+        case_tdicadence_100_1000_10_100_down(self, cad)
 
-def case_dual_metronome(self, cad1d, cad2d):
+        ########################################
+        # 10 lines, one stage
+        ########################################
 
-    self.assertEqual(cad1d.shape, (50,))
-    self.assertEqual(cad2d.shape, (10,5))
+        cad = oops.cadence.TDICadence(10, 100., 10., 1)
+#         print(cad.time_at_tstep(10))
+        case_tdicadence_10_100_10_1(self, cad)
 
-    grid2d = Test_DualCadence.meshgrid(np.arange(10),np.arange(5))
-    grid1d = 5. * grid2d.to_scalar(0) + grid2d.to_scalar(1)
+def case_tdicadence_10_100_10_2_down(self, cad):
 
-    # time_at_tstep, grid
-    times1d = cad1d.time_at_tstep(grid1d, remask=False)
-    times2d = cad2d.time_at_tstep(grid2d, remask=False)
-    self.assertEqual(times1d, times2d)
-    self.assertEqual(times1d.flatten(),
-                     cad2d.time_at_tstep(grid2d.flatten(), remask=False))
+    # time_range_at_tstep
+    self.assertEqual(cad.time_range_at_tstep(-1), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(-1, remask=True), (Scalar.MASKED, Scalar.MASKED))
+    self.assertEqual(cad.time_range_at_tstep(0), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(8), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(9), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(9.5),(110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(10), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
+                                                 remask=False), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
+                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
+    self.assertEqual(cad.time_range_at_tstep(11), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
+                                                 remask=False), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
+                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
+
+    tstep = Scalar(([0,1],[2,9]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].vals ==
+                           [[100,100],[100,110]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].vals ==
+                           [[100,100],[100,110]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].vals ==
+                           [[100,100],[100,110]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[0].vals == [[100,100],[100,110]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[0].mask == [[0,0],[1,1]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[1].mask == [[0,0],[1,1]]))
+
+    # time_at_tstep
+    self.assertEqual(cad.time_at_tstep(-1.), 100.)
+    self.assertEqual(cad.time_at_tstep(-1., remask=True), Scalar.MASKED)
+    self.assertEqual(cad.time_at_tstep(0. ), 100.)
+    self.assertEqual(cad.time_at_tstep(0.5), 110.)
+    self.assertEqual(cad.time_at_tstep(0.9), 118.)
+    self.assertEqual(cad.time_at_tstep(1. ), 100.)
+    self.assertEqual(cad.time_at_tstep(1.5), 110.)
+    self.assertEqual(cad.time_at_tstep(1.9), 118.)
+    self.assertEqual(cad.time_at_tstep(9. ), 110.)
+    self.assertEqual(cad.time_at_tstep(9.5), 115.)
+    self.assertEqual(cad.time_at_tstep(10.), 120.)
+    self.assertEqual(cad.time_at_tstep(10., remask=True,
+                                            inclusive=True), 120.)
+    self.assertEqual(cad.time_at_tstep(10., remask=True,
+                                            inclusive=False), Scalar.MASKED)
+
+    tstep = Scalar(([0,1],[9,10]),([False,True],[False,False]))
+    self.assertTrue(np.all(cad.time_at_tstep(tstep).vals == [[100,100],[110,120]]))
+    self.assertTrue(np.all(cad.time_at_tstep(tstep).mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_at_tstep(tstep, remask=True,
+                                             inclusive=False).mask == [[0,1],[0,1]]))
+
+    # time_at_tstep, derivs
+    tstep = Scalar([-1, 0, 0.5, 0.9, 1.,1.5, 1.9, 9, 9.5, 10])
+    tstep.insert_deriv('t', Scalar(np.arange(10.)))
+    self.assertEqual(cad.time_at_tstep(tstep),
+                    [100,100,110,118,100,110,118,110,115,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True),
+                    [100,100,110,118,100,110,118,110,115,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True),
+                    [Scalar.MASKED,100,110,118,100,110,118,110,115,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False),
+                    [Scalar.MASKED,100,110,118,100,110,118,110,115,Scalar.MASKED])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt,
+                    [0,20,40,60,80,100,120,70,80,90])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True).d_dt,
+                    [Scalar.MASKED,20,40,60,80,100,120,70,80,90])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False).d_dt,
+                    [Scalar.MASKED,20,40,60,80,100,120,70,80,Scalar.MASKED])
+
+    # tstep_range_at_time
+    self.assertEqual(cad.tstep_range_at_time(100.), (0, 9))
+    self.assertEqual(cad.tstep_range_at_time(109.), (0, 9))
+    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
+
+    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
+    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
+    self.assertEqual(test0, test1)
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=True), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
+
+    time = Scalar([100,110,120],[False,False,False])
+    self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (0,0,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (9,10,10)))
+
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (0,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (9,10,0)))
+    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
+    self.assertTrue(np.all(test0.vals[:2] == (0,0)))
+    self.assertTrue(np.all(test1.vals[:2] == (9,10)))
+    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
+
+    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[0].mask))
+    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[1].mask))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (0,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (9,10,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,0,1)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,0,1)))
+
+    time = Scalar([100,110,120],[True,False,False])
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (0,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (0,10,10)))
+    (test0, test1) = cad.tstep_range_at_time(time)
+    self.assertEqual(test0.vals[0], test1.vals[0])  # zero range is required, specific values are not
+    self.assertTrue(np.all(test0.vals[1:] == (0,0)))
+    self.assertTrue(np.all(test1.vals[1:] == (10,10)))
+
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (0,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (0,10,0)))
+    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
+    self.assertEqual(test0.vals[0], test1.vals[0])  # zero range is required, specific values are not
+    self.assertEqual(test0.vals[1], 0)
+    self.assertEqual(test1.vals[1], 10)
+    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
+
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].mask == (1,0,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].mask == (1,0,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (1,0,1)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (1,0,1)))
+
+    # tstride_at_tstep
+    self.assertEqual(cad.tstride_at_tstep(0), 0)
+    self.assertEqual(cad.tstride_at_tstep(8), 10)
+    self.assertEqual(cad.tstride_at_tstep(8, sign=-1), 0)
+    self.assertEqual(cad.tstride_at_tstep(9), 10)
+    self.assertEqual(cad.tstride_at_tstep(9, sign=-1), 10)
+    self.assertEqual(cad.tstride_at_tstep(10), 10)
 
-    times1d = cad1d.time_at_tstep(grid1d, remask=True)
-    times2d = cad2d.time_at_tstep(grid2d, remask=True)
-    self.assertEqual(times1d, times2d)
-    self.assertEqual(times1d.flatten(),
-                     cad2d.time_at_tstep(grid2d.flatten()))
+def case_tdicadence_10_100_10_2_up(self, cad):
 
     # time_range_at_tstep
-    range1d = cad1d.time_range_at_tstep(grid1d, remask=False)
-    range2d = cad2d.time_range_at_tstep(grid2d, remask=False)
-    self.assertEqual(range1d[0], range2d[0])
-    self.assertEqual(range1d[1], range2d[1])
-
-    range1d = cad1d.time_range_at_tstep(grid1d, remask=True)
-    range2d = cad2d.time_range_at_tstep(grid2d, remask=True)
-    self.assertEqual(range1d[0], range2d[0])
-    self.assertEqual(range1d[1], range2d[1])
-
-    # tstep_at_time
-    test1d = cad1d.tstep_at_time(times1d, remask=False)
-    test2d = cad2d.tstep_at_time(times2d, remask=False)
-    self.assertEqual(test1d // 5, test2d.to_scalar(0))
-    self.assertEqual(test1d %  5, test2d.to_scalar(1))
-
-    test1d = cad1d.tstep_at_time(times1d, remask=True)
-    test2d = cad2d.tstep_at_time(times2d, remask=True)
-    self.assertEqual(test1d // 5, test2d.to_scalar(0))
-    self.assertEqual(test1d %  5, test2d.to_scalar(1))
-
-    time_seq = Scalar(np.arange(90,220,10) + 0.5)
-    test1d = cad1d.time_is_inside(time_seq)
-    test2d = cad2d.time_is_inside(time_seq)
-    self.assertTrue(test1d == test2d)
-
-    # Test masked values
-    tstep = Pair(((0,0),(1,1),(2,2)), [False,True,False])
-    time = Scalar((100,110,120), [False,True,False])
-    self.assertTrue(Boolean(cad2d.time_at_tstep(tstep).mask) ==
-                    [False,True,False])
-    self.assertTrue(Boolean(cad2d.tstep_at_time(time).to_scalar(0).mask) ==
-                    [False,True,False])
-    self.assertTrue(Boolean(cad2d.tstep_at_time(time).to_scalar(1).mask) ==
-                    [False,True,False])
-    self.assertTrue(Boolean(cad2d.time_is_inside(time).mask) == [False,True,False])
-    self.assertTrue(Boolean(cad2d.time_range_at_tstep(tstep)[0].mask) ==
-                    [False,True,False])
-    self.assertTrue(Boolean(cad2d.time_range_at_tstep(tstep)[1].mask) ==
-                    [False,True,False])
-
-    # time_shift()
-    shifted = cad2d.time_shift(0.5)
-    self.assertEqual(cad2d.time_at_tstep(grid2d, remask=True),
-                     shifted.time_at_tstep(grid2d, remask=True) - 0.5)
-
-    # tstride_at_tstep()
-    self.assertEqual(cad2d.tstride_at_tstep(Pair((0,0))), Pair((10,2)))
-    self.assertEqual(cad2d.tstride_at_tstep(Pair((5,3))), Pair((10,2)))
-
-    # Random tsteps, using random floats
-    values = np.random.rand(10,10,10,10,2)  # random values 0-1
-    values[...,0] *= 12     # above 10 is out of range
-    values[...,1] *= 7      # above 5 is out of range
-    values -= 1             # shift so some values are negative
-    # First index is now -1 to 11; second is -1 to 6.
-
-    random2d = Pair(values)
-    random1d = 5. * random2d.to_scalar(0).as_int() + random2d.to_scalar(1)
-    outside = ((values[...,0] < 0) | (values[...,0] >= 10) |
-               (values[...,1] < 0) | (values[...,1] >= 5))
-
-    times1d = cad1d.time_at_tstep(random1d, remask=False)
-    times2d = cad2d.time_at_tstep(random2d, remask=False)
-    self.assertTrue((abs(times1d - times2d)[~outside] < 1.e-13).all())
-
-    range1d = cad1d.time_range_at_tstep(random1d, remask=False)
-    range2d = cad2d.time_range_at_tstep(random2d, remask=False)
-    self.assertEqual(range1d[0][~outside], range2d[0][~outside])
-    self.assertEqual(range1d[1][~outside], range2d[1][~outside])
-
-    test1d = cad1d.tstep_at_time(times1d, remask=False)
-    test2d = cad2d.tstep_at_time(times2d, remask=False)
-    self.assertEqual(test1d[~outside] // 5, test2d.to_scalar(0)[~outside])
-    self.assertTrue((abs(test1d[~outside] % 5 - test2d[~outside].to_scalar(1)) < 1.e-13).all())
-
-    times1d = cad1d.time_at_tstep(random1d, remask=True)
-    times2d = cad2d.time_at_tstep(random2d, remask=True)
-    self.assertTrue(np.all(outside == times2d.mask))
-    self.assertTrue((abs(times1d - times2d)[~times2d.mask] < 1.e-13).all())
-
-    range1d = cad1d.time_range_at_tstep(random1d, remask=False)
-    range2d = cad2d.time_range_at_tstep(random2d, remask=False)
-    self.assertEqual(range1d[0][~outside], range2d[0][~outside])
-    self.assertEqual(range1d[1][~outside], range2d[1][~outside])
-
-    test1d = cad1d.tstep_at_time(times1d, remask=False)
-    test2d = cad2d.tstep_at_time(times2d, remask=False)
-    self.assertEqual(test1d[~outside] // 5, test2d.to_scalar(0)[~outside])
-    self.assertTrue((abs(test1d[~outside] % 5 - test2d[~outside].to_scalar(1)) < 1.e-13).all())
-
-    # Make sure everything works with scalars
-    for count in range(100):
-        random1d = np.random.random()
-        random2d = Vector((random1d//5, random1d%5))
-
-        time1d = cad1d.time_at_tstep(random1d, remask=True)
-        time2d = cad2d.time_at_tstep(random2d, remask=True)
-        self.assertTrue(abs(time1d - time2d) < 1.e-12)
-
-        range1d = cad1d.time_range_at_tstep(random1d, remask=True)
-        range2d = cad2d.time_range_at_tstep(random2d, remask=True)
-        self.assertEqual(range1d, range2d)
-
-        test1d = cad1d.tstep_at_time(time1d, remask=True)
-        test2d = cad2d.tstep_at_time(time2d, remask=True)
-        self.assertEqual(test1d // 5, test2d.to_scalar(0))
-        self.assertTrue(abs(test1d % 5 - test2d.to_scalar(1)) < 1.e-12)
-
-    # Random tsteps, using random floats, with derivs
-    N = 200
-    values = np.random.rand(N,2)  # random values 0-1
-    values[...,0] *= 10
-    values[...,1] *= 5
-
-    mask = np.random.rand(N) < 0.2
-    random2d = Pair(values, mask)
-
-    array = np.random.randn(N,2)
-    array[...,0] = 0.
-    d_dt = Pair(array, mask)
-
-    array = np.random.randn(N,2,2)
-    array[...,0,:] = 0.
-    d_dxy = Pair(array, mask, drank=1)
-    random2d.insert_deriv('t', d_dt)
-    random2d.insert_deriv('xy', d_dxy)
-
-    random1d = 5. * random2d.to_scalar(0).as_int() + random2d.to_scalar(1)
-
-    times1d = cad1d.time_at_tstep(random1d, derivs=True)
-    times2d = cad2d.time_at_tstep(random2d, derivs=True)
-    self.assertTrue((abs(times1d - times2d)[~mask] < 1.e-13).all())
-    self.assertEqual(times2d.d_dt[~mask], d_dt.vals[...,1][~mask])
-    self.assertEqual(times2d.d_dxy[~mask], d_dxy[~mask].vals[...,1,:])
-    self.assertEqual(type(times2d.d_dt), Scalar)
-    self.assertEqual(type(times2d.d_dxy), Scalar)
-    self.assertEqual(times2d.d_dt.denom, ())
-    self.assertEqual(times2d.d_dxy.denom, (2,))
-    self.assertEqual(times2d.d_dt.shape, random2d.shape)
-    self.assertEqual(times2d.d_dxy.shape, random2d.shape)
-
-    test1d = cad1d.tstep_at_time(times1d, derivs=True)
-    test2d = cad2d.tstep_at_time(times2d, derivs=True)
-    self.assertEqual(test1d // 5, test2d.to_scalar(0))
-    self.assertTrue((abs(test1d[~mask] % 5 - test2d[~mask].to_scalar(1)) < 1.e-13).all())
-    self.assertEqual(test2d.d_dt[~mask], d_dt[~mask])
-    self.assertEqual(test2d.d_dxy[~mask], d_dxy[~mask])
-    self.assertEqual(type(test2d.d_dt), Pair)
-    self.assertEqual(type(test2d.d_dxy), Pair)
-    self.assertEqual(test2d.d_dt.denom, ())
-    self.assertEqual(test2d.d_dxy.denom, (2,))
-    self.assertEqual(test2d.d_dt.shape, random2d.shape)
-    self.assertEqual(test2d.d_dxy.shape, random2d.shape)
-
-    #### tstep_range_at_time, random
-
-    time = 80 + 140 * np.random.rand(200)
-    (tstep1a, tstep1b) = cad1d.tstep_range_at_time(time, remask=True)
-    (tstep2a, tstep2b) = cad2d.tstep_range_at_time(time, remask=True)
-
-    mask = tstep2a.mask
-    self.assertTrue(np.all(tstep1a.vals[~mask]   == tstep1b.vals[~mask] - 1))
-    self.assertTrue(np.all(tstep2a.vals[~mask,1] == tstep2b.vals[~mask,1] - 1))
-
-    self.assertTrue(np.all(tstep1a.vals[tstep1a.mask] == tstep1b.vals[tstep1a.mask]))
-    self.assertTrue(np.all(tstep2a.vals[tstep2a.mask,0] == tstep2b.vals[tstep2a.mask,0] - 1))
-    self.assertTrue(np.all(tstep2a.vals[tstep2a.mask,1] == tstep2b.vals[tstep2a.mask,1]))
-
-    test2a = 5.*tstep2a.vals[:,0] + tstep2a.vals[:,1]
-    self.assertTrue(tstep1a[~mask] == test2a[~mask])
-
-    test2b = 5.*(tstep2b.vals[:,0] - 1) + tstep2b.vals[:,1]
-    self.assertTrue(tstep1b[~mask] == test2b[~mask])
-
-    #### tstep_range_at_time, orderly, exclusive
-
-    (tstep1a, tstep1b) = cad1d.tstep_range_at_time(time, remask=True, inclusive=False)
-    (tstep2a, tstep2b) = cad2d.tstep_range_at_time(time, remask=True, inclusive=False)
-
-    mask = tstep2a.mask
-    self.assertTrue(np.all(tstep1a.vals[~mask] == tstep1b.vals[~mask] - 1))
-    self.assertTrue(np.all(tstep2a.vals[~mask,1] == tstep2b.vals[~mask,1] - 1))
-
-    self.assertTrue(np.all(tstep1a.vals[tstep1a.mask] == tstep1b.vals[tstep1a.mask]))
-    self.assertTrue(np.all(tstep2a.vals[tstep2a.mask,1] == tstep2b.vals[tstep2a.mask,1]))
-
-    test2a = 5.*tstep2a.vals[:,0] + tstep2a.vals[:,1]
-    self.assertTrue(tstep1a[~mask] == test2a[~mask])
-
-    test2b = 5.*(tstep2b.vals[:,0] - 1) + tstep2b.vals[:,1]
-    self.assertTrue(tstep1b[~mask] == test2b[~mask])
-
-    #### tstep_range_at_time, orderly, inclusive
-
-    time = np.arange(80., 220., 0.125)
-    (tstep1a, tstep1b) = cad1d.tstep_range_at_time(time, remask=True, inclusive=True)
-    (tstep2a, tstep2b) = cad2d.tstep_range_at_time(time, remask=True, inclusive=True)
-
-    mask = tstep2a.mask
-    self.assertTrue(np.all(mask == tstep2b.mask))
-    self.assertTrue(np.all(tstep1a.vals[~mask] == tstep1b.vals[~mask] - 1))
-    self.assertTrue(np.all(tstep2a.vals[~mask,1] == tstep2b.vals[~mask,1] - 1))
-
-    self.assertTrue(np.all(tstep1a.vals[tstep1a.mask] == tstep1b.vals[tstep1a.mask]))
-    self.assertTrue(np.all(tstep2a.vals[tstep2a.mask,1] == tstep2b.vals[tstep2a.mask,1]))
-
-    test2a = 5.*tstep2a.vals[:,0] + tstep2a.vals[:,1]
-    self.assertTrue(tstep1a[~mask] == test2a[~mask])
-
-    test2b = 5.*(tstep2b.vals[:,0] - 1) + tstep2b.vals[:,1]
-    self.assertTrue(tstep1b[~mask] == test2b[~mask])
-
-    #### out-of-range indices and times
-
-    for i in range(-1,cad2d.shape[0]+2):
-        self.assertEqual(cad2d.time_at_tstep((i,-0.5)),
-                         cad2d.time_at_tstep((i, 0  )))
-        self.assertEqual(cad2d.time_at_tstep((i, 5.5)),
-                         cad2d.time_at_tstep((i, 5.0)))
-        self.assertEqual(cad2d.time_range_at_tstep((i,-0.5)),
-                         cad2d.time_range_at_tstep((i, 0  )))
-        self.assertEqual(cad2d.time_range_at_tstep((i, 5.5)),
-                         cad2d.time_range_at_tstep((i, 5.0)))
-
-    for j in range(-1,cad2d.shape[1]+2):
-        self.assertEqual(cad2d.time_at_tstep((-0.5, j)),
-                         cad2d.time_at_tstep(( 0  , j)))
-        self.assertEqual(cad2d.time_at_tstep((10.5, j)),
-                         cad2d.time_at_tstep((10.0, j)))
-        self.assertEqual(cad2d.time_range_at_tstep((-0.5, j)),
-                         cad2d.time_range_at_tstep(( 0  , j)))
-        self.assertEqual(cad2d.time_range_at_tstep((10.5, j)),
-                         cad2d.time_range_at_tstep((10.0, j)))
-
-    self.assertEqual(cad2d.tstep_at_time(99.), (0,0))
-    self.assertEqual(cad2d.tstep_at_time(99., remask=True), (Scalar.MASKED, Scalar.MASKED))
-
-    self.assertEqual(cad2d.tstep_at_time(190), (9,0))
-    self.assertEqual(cad2d.tstep_at_time(190, inclusive=False), (9,0))
-    self.assertEqual(cad2d.tstep_at_time(190, remask=True), (9,0))
-    self.assertEqual(cad2d.tstep_at_time(190, inclusive=False,
-                                              remask=True), (9,0))
-
-    self.assertEqual(cad2d.tstep_at_time(198), (9,4))
-    self.assertEqual(cad2d.tstep_at_time(198, inclusive=False), (9,4))
-    self.assertEqual(cad2d.tstep_at_time(198, remask=True), (9,4))
-    self.assertEqual(cad2d.tstep_at_time(198, inclusive=False,
-                                              remask=True), (9,4))
-
-    self.assertEqual(cad2d.tstep_at_time(199), (9,5))
-    self.assertEqual(cad2d.tstep_at_time(199, inclusive=False), (10,5))
-    self.assertEqual(cad2d.tstep_at_time(199, remask=True), (9,5))
-    self.assertEqual(cad2d.tstep_at_time(199, inclusive=False,
-                                              remask=True), (Scalar.MASKED, Scalar.MASKED))
-
-    self.assertEqual(cad2d.tstep_at_time(200), (10,5))
-    self.assertEqual(cad2d.tstep_at_time(200, remask=True), (Scalar.MASKED, Scalar.MASKED))
-
-    self.assertEqual(cad2d.tstep_range_at_time(99.), ((0,0), (1,0)))
-    self.assertEqual(cad2d.tstep_range_at_time(99., remask=True), (Pair.MASKED, Pair.MASKED))
-
-    self.assertEqual(cad2d.tstep_range_at_time(190), ((9,0), (10,1)))
-    self.assertEqual(cad2d.tstep_range_at_time(190, inclusive=False), ((9,0), (10,1)))
-    self.assertEqual(cad2d.tstep_range_at_time(190, remask=True), ((9,0), (10,1)))
-    self.assertEqual(cad2d.tstep_range_at_time(190, inclusive=False,
-                                                    remask=True), ((9,0), (10,1)))
-
-    self.assertEqual(cad2d.tstep_range_at_time(198), ((9,4), (10,5)))
-    self.assertEqual(cad2d.tstep_range_at_time(198, inclusive=False), ((9,4), (10,5)))
-    self.assertEqual(cad2d.tstep_range_at_time(198, remask=True), ((9,4), (10,5)))
-    self.assertEqual(cad2d.tstep_range_at_time(198, inclusive=False,
-                                                    remask=True), ((9,4), (10,5)))
-
-    self.assertEqual(cad2d.tstep_range_at_time(199), ((9,4), (10,5)))
-    self.assertEqual(cad2d.tstep_range_at_time(199, inclusive=False), ((9,4), (10,4)))
-    self.assertEqual(cad2d.tstep_range_at_time(199, remask=True), ((9,4), (10,5)))
-    self.assertEqual(cad2d.tstep_range_at_time(199, inclusive=False,
-                                                    remask=True), (Pair.MASKED, Pair.MASKED))
+    self.assertEqual(cad.time_range_at_tstep(-1), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(-1, remask=True), (Scalar.MASKED, Scalar.MASKED))
+    self.assertEqual(cad.time_range_at_tstep(0), (110., 120.))
+    self.assertEqual(cad.time_range_at_tstep(8), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(9), (100., 120.))
+
+    self.assertEqual(cad.time_range_at_tstep(10), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
+                                                 remask=False), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
+                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
+    self.assertEqual(cad.time_range_at_tstep(11), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
+                                                 remask=False), (100., 120.))
+    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
+                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
+
+    tstep = Scalar(([0,1],[2,9]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].vals ==
+                           [[110,100],[100,100]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].vals ==
+                           [[110,100],[100,100]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].vals ==
+                           [[110,100],[100,100]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].mask == tstep.mask))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].mask == tstep.mask))
+
+    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[0].vals == [[110,100],[100,100]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[1].vals == 120))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[0].mask == [[0,0],[1,1]]))
+    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
+                                                   remask=True)[1].mask == [[0,0],[1,1]]))
+
+    # time_at_tstep
+    self.assertEqual(cad.time_at_tstep(-1.), 110.)
+    self.assertEqual(cad.time_at_tstep(-1., remask=True), Scalar.MASKED)
+    self.assertEqual(cad.time_at_tstep(0. ), 110.)
+    self.assertEqual(cad.time_at_tstep(0.5), 115.)
+    self.assertEqual(cad.time_at_tstep(0.9), 119.)
+    self.assertEqual(cad.time_at_tstep(1. ), 100.)
+    self.assertEqual(cad.time_at_tstep(1.5), 110.)
+    self.assertEqual(cad.time_at_tstep(1.9), 118.)
+    self.assertEqual(cad.time_at_tstep(9. ), 100.)
+    self.assertEqual(cad.time_at_tstep(9.5), 110.)
+    self.assertEqual(cad.time_at_tstep(10.), 120.)
+    self.assertEqual(cad.time_at_tstep(10., remask=True,
+                                            inclusive=True), 120.)
+    self.assertEqual(cad.time_at_tstep(10., remask=True,
+                                            inclusive=False), Scalar.MASKED)
+
+    self.assertEqual(cad.tstep_range_at_time(100.), (1, 10))
+    self.assertEqual(cad.tstep_range_at_time(109.), (1, 10))
+    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
+
+    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
+    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
+    self.assertEqual(test0, test1)  # zero range is required; specific values are not
+
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=True), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
+
+    # time_at_tstep, derivs
+    tstep = Scalar([-1, 0, 0.5, 0.9, 1.,1.5, 1.9, 9, 9.5, 10])
+    tstep.insert_deriv('t', Scalar(np.arange(10.)))
+    self.assertEqual(cad.time_at_tstep(tstep),
+                    [110,110,115,119,100,110,118,100,110,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True),
+                    [110,110,115,119,100,110,118,100,110,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True),
+                    [Scalar.MASKED,110,115,119,100,110,118,100,110,120])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False),
+                    [Scalar.MASKED,110,115,119,100,110,118,100,110,Scalar.MASKED])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt,
+                    [0,10,20,30,80,100,120,140,160,180])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True).d_dt,
+                    [Scalar.MASKED,10,20,30,80,100,120,140,160,180])
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False).d_dt,
+                    [Scalar.MASKED,10,20,30,80,100,120,140,160,Scalar.MASKED])
+
+    # tstep_range_at_time
+    self.assertEqual(cad.tstep_range_at_time(100.), (1, 10))
+    self.assertEqual(cad.tstep_range_at_time(109.), (1, 10))
+    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
+
+    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
+    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
+    self.assertEqual(test0, test1)  # zero range is required; specific values are not
+
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=True), (0, 10))
+    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
+                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
+
+    time = Scalar([100,110,120],[False,False,False])
+    self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (1,0,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (10,10,10)))
+
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (1,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (10,10,0)))
+    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
+    self.assertTrue(np.all(test0.vals[:2] == (1,0)))
+    self.assertTrue(np.all(test1.vals[:2] == (10,10)))
+    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
+
+    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[0].mask))
+    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[1].mask))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (1,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (10,10,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,0,1)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,0,1)))
+
+    time = Scalar([100,110,120],[False,True,False])
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (1,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (10,0,10)))
+    (test0, test1) = cad.tstep_range_at_time(time)
+    self.assertEqual(test0.vals[1], test1.vals[1])  # zero range is required, specific values are not
+    self.assertTrue(np.all(test0.vals[0::2] == (1,0)))
+    self.assertTrue(np.all(test1.vals[0::2] == (10,10)))
+
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (1,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (10,0,0)))
+    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
+    self.assertEqual(test0.vals[0], 1)
+    self.assertEqual(test1.vals[0], 10)
+    self.assertEqual(test0.vals[1], test1.vals[1])  # zero range is required, specific values are not
+    self.assertEqual(test0.vals[2], test1.vals[2])
+
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].mask == (0,1,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].mask == (0,1,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (1,0,0)))
+    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (10,0,0)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,1,1)))
+    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,1,1)))
+
+def case_tdicadence_100_1000_10_100_down(self, cad):
+
+    tstep = Scalar(np.arange(100))
+    (time0, time1) = cad.time_range_at_tstep(tstep)
+    self.assertEqual(time1, 2000.)
+    self.assertEqual(time0, 1000. + 10. * tstep)
+
+    self.assertEqual(cad.tstep_range_at_time(1000.), (0, 1))
+    self.assertEqual(cad.tstep_range_at_time(1010.), (0, 2))
+    self.assertEqual(cad.tstep_range_at_time(1990.), (0, 100))
+    # self.assertEqual(cad.tstep_range_at_time(2000., inclusive=False), (0, 0))
+    (test0, test1) = cad.tstep_range_at_time(2000., inclusive=False)
+    self.assertEqual(test0, test1)
+    self.assertEqual(cad.tstep_range_at_time(2000., remask=True,
+                                                    inclusive=True), (0, 100))
+    self.assertEqual(cad.tstep_range_at_time(2000., remask=True,
+                                                    inclusive=False), (Scalar.MASKED, Scalar.MASKED))
+
+    # time_is_inside()
+    self.assertEqual(cad.time_is_inside([1000,2000], inclusive=True ), [1,1])
+    self.assertEqual(cad.time_is_inside([1000,2000], inclusive=False), [1,0])
+
+def case_tdicadence_10_100_10_1(self, cad):
+
+    self.assertTrue(cad.is_continuous)
+    self.assertTrue(cad.is_unique)
+
+    # time_at_tstep()
+    self.assertEqual(cad.time_at_tstep(-0.1), 100.)
+    self.assertEqual(cad.time_at_tstep(-0.1, remask=False), 100.)
+    self.assertEqual(cad.time_at_tstep(-0.1, remask=True ), Scalar.MASKED)
+    self.assertEqual(cad.time_at_tstep( 0  ), 100.)
+    self.assertEqual(cad.time_at_tstep( 9.5), 105.)
+    self.assertEqual(cad.time_at_tstep(10, remask=False), 110.)
+    self.assertEqual(cad.time_at_tstep(10, remask=True ), 110.)
+    self.assertEqual(cad.time_at_tstep(10, remask=True, inclusive=False), Scalar.MASKED)
+
+    # time_at_tstep(), derivs
+    tstep = Scalar((0., 0.5, 10., 20.))
+    tstep.insert_deriv('t', Scalar((2,3,4,5)))
+
+    self.assertEqual(cad.time_at_tstep(tstep, remask=False), (100,105,110,110))
+    self.assertEqual(cad.time_at_tstep(tstep, remask=True), (100,105,110,Scalar.MASKED))
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt, (20,30,40,0))
+    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, inclusive=False).d_dt, (20,30,0,0))
+
+    # time_is_inside()
+    time = ([99,100],[120,140],[145,150])
+    self.assertFalse(cad.time_is_inside(90))
+    self.assertTrue (cad.time_is_inside(100))
+    self.assertTrue (cad.time_is_inside(110))
+    self.assertFalse(cad.time_is_inside(110, inclusive=False))
+    self.assertFalse(cad.time_is_inside(111))
+
+    # tstep_at_time()
+    self.assertEqual(cad.tstep_at_time( 99), 0.)
+    self.assertEqual(cad.tstep_at_time( 99, remask=True), Scalar.MASKED)
+    self.assertEqual(cad.tstep_at_time(100), 0.)
+    self.assertEqual(cad.tstep_at_time(105), 0.5)
+    self.assertEqual(cad.tstep_at_time(110), 1.)
+    self.assertEqual(cad.tstep_at_time(110, remask=True), 1.)
+    self.assertEqual(cad.tstep_at_time(110, remask=True, inclusive=False), Scalar.MASKED)
+    self.assertEqual(cad.tstep_at_time(111), 1.)
+    self.assertEqual(cad.tstep_at_time(111, remask=True), Scalar.MASKED)
+
+    # tstep_at_time(), derivs
+    time = Scalar((90,100,110,140), derivs={'t': Scalar((100,200,300,400))})
+    self.assertEqual(cad.tstep_at_time(time, remask=False, derivs=True).d_dt, (0, 20, 30, 0))
+    self.assertEqual(cad.tstep_at_time(time, remask=False, derivs=True,
+                                                 inclusive=False).d_dt, (0, 20, 0, 0))
+
+    # tstep_range_at_time()
+    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
+    self.assertEqual(cad.tstep_range_at_time( 99.), (0,0))
+    self.assertEqual(cad.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
+    self.assertEqual(cad.tstep_range_at_time(100.), (0,10))
+    self.assertEqual(cad.tstep_range_at_time(105.), (0,10))
+    self.assertEqual(cad.tstep_range_at_time(110.), (0,10))
+    self.assertEqual(cad.tstep_range_at_time(110., remask=True), (0,10))
+    self.assertEqual(cad.tstep_range_at_time(110., remask=True, inclusive=False), MASKED_TUPLE)
+    self.assertEqual(cad.tstep_range_at_time(135., remask=True), MASKED_TUPLE)
+
+    tstep0, tstep1 = cad.tstep_range_at_time(110., inclusive=False)
+    self.assertEqual(tstep0, tstep1)    # indicates zero range
+
+    tstep0, tstep1 = cad.tstep_range_at_time(135.)
+    self.assertEqual(tstep0, tstep1)
+
+    # time_range_at_tstep()
+    tstep = Scalar((-1,0,0.5,10,12))
+    self.assertEqual(cad.time_range_at_tstep(tstep)[0], 5*[100])
+    self.assertEqual(cad.time_range_at_tstep(tstep)[1], 5*[110])
+
+    self.assertEqual(cad.time_range_at_tstep(tstep[0], remask=True), MASKED_TUPLE)
+    self.assertEqual(cad.time_range_at_tstep(tstep[1:4], remask=True)[0], 3*[100])
+    self.assertEqual(cad.time_range_at_tstep(tstep[1:4], remask=True)[1], 3*[110])
+    self.assertEqual(cad.time_range_at_tstep(tstep[4], remask=True), MASKED_TUPLE)
+
+    self.assertEqual(cad.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[0], 2*[100])
+    self.assertEqual(cad.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[1], 2*[110])
+
+    self.assertEqual(cad.time_range_at_tstep(tstep[3], remask=True, inclusive=False), MASKED_TUPLE)
+
+    # tstride_at_tstep
+    self.assertEqual(cad.tstride_at_tstep(0), 0)
+    self.assertEqual(cad.tstride_at_tstep(0.5), 0)
+    self.assertEqual(cad.tstride_at_tstep(9), 10)
+    self.assertEqual(cad.tstride_at_tstep(9, sign=-1), 0)
+    self.assertEqual(cad.tstride_at_tstep(10), 10)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/instant.py` & `rms_oops-0.0.4/oops/cadence/instant.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 ################################################################################
 # oops/cadence/instant.py: Class Instant
 ################################################################################
 
 import numpy as np
-from polymath import Scalar
+
+from polymath     import Scalar
 from oops.cadence import Cadence
 
 class Instant(Cadence):
     """TODO: This is a work in progress. Not fully tested. To be used by the
     InSitu Observation subclass. DO NOT USE.
 
     A Cadence subclas that represents the timing of an observation as a Scalar
@@ -146,24 +147,7 @@
         """Construct a shallow copy of this Cadence, forced to be continuous."""
 
         instant = Instant(self.tdb)
         instant.is_continuoue = True
         return instant
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Instant(unittest.TestCase):
-
-    def runTest(self):
-
-        # No tests here - TBD - WORK IN PROGRESS
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/metronome.py` & `rms_oops-0.0.4/tests/observation/test_timedimage.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,1255 +1,1177 @@
 ################################################################################
-# oops/cadence/metronome.py: Metronome subclass of class Cadence
+# tests/observation/test_timedimage.py
 ################################################################################
 
-from polymath     import Scalar, Qube
-from oops.cadence import Cadence
-
-class Metronome(Cadence):
-    """A Cadence subclass where time steps occur at uniform intervals."""
-
-    def __init__(self, tstart, tstride, texp, steps, clip=True):
-        """Constructor for a Metronome.
-
-        Input:
-            tstart      the start time of the observation in seconds TDB.
-            tstride     the interval in seconds from the start of one time step
-                        to the start of the next.
-            texp        the exposure time in seconds associated with each step.
-                        This may be shorter than tstride due to readout times,
-                        etc. It may also be longer.
-            steps       the number of time steps.
-            clip        if True (the default), times and index values are always
-                        clipped into the valid range.
-        """
-
-        self.tstart = float(tstart)
-        self.tstride = float(tstride)
-        self.texp = float(texp)
-        self.steps = int(steps)
-        self.clip = bool(clip)
-
-        if self.steps == 1:
-            self.tstride = self.texp
-
-        # Required attributes
-        self.lasttime = self.tstart + self.tstride * (self.steps - 1)
-        self.time = (self.tstart, self.lasttime + self.texp)
-        self.midtime = (self.time[0] + self.time[1]) * 0.5
-        self.shape = (self.steps,)
-        self.is_continuous = (self.texp >= self.tstride)
-        self.is_unique = (self.texp <= self.tstride)
-        self.min_tstride = self.tstride
-        self.max_tstride = self.tstride
-
-        self._gapless = (self.texp == self.tstride)
-        self._tscale = self.tstride / self.texp
-        self._tspan = self.texp / self.tstride
-        self._tspan1 = self._tspan - 1
-        self._max_step = self.steps - 1
-
-    def __getstate__(self):
-        return (self.tstart, self.tstride, self.texp, self.steps,
-                             self.clip)
-
-    def __setstate__(self, state):
-        self.__init__(*state)
-
-    #===========================================================================
-    def time_at_tstep(self, tstep, remask=False, derivs=False, inclusive=True):
-        """The time associated with the given time step.
-
-        This method supports non-integer time step values via interpolation.
-
-        Input:
-            tstep       a Scalar of time step index values.
-            remask      True to mask values outside the time limits.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar of times in seconds TDB.
-        """
-
-        tstep = Scalar.as_scalar(tstep, recursive=derivs)
-
-        # One case is especially easy
-        if not remask and not self.clip and self._gapless:
-            return self.time[0] + self.tstride * tstep
-
-        # Other cases
-        tstep_int = tstep.int(top=self.steps, remask=remask,
-                              inclusive=inclusive, clip=self.clip)
-        tstep_frac = (tstep - tstep_int).clip(0, 1, remask=remask,
-                                                    inclusive=False)
-            # inclusive is False because the end moments of discontinuous time
-            # steps are never included, except for the end of the final time
-            # step, which is included when inclusive=True.
-
-        # End moment might require special handling
-        if inclusive and (remask or derivs):
-            mask = (tstep == self.steps)
-            tstep_frac[mask] = tstep[mask] - self._max_step
-                # this sets the value to 1 but preserves derivatives
-
-        return (self.time[0] + tstep_int * self.tstride
-                             + tstep_frac * self.texp)
-
-    #===========================================================================
-    def time_range_at_tstep(self, tstep, remask=False, inclusive=True):
-        """The range of times for the given time step.
-
-        Input:
-            tstep       a Pair of time step index values.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (time_min, time_max)
-            time_min    a Scalar defining the minimum time associated with the
-                        index. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
-        """
-
-        tstep = Scalar.as_scalar(tstep, recursive=False)
-        tstep_int = tstep.int(top=self.steps, remask=remask,
-                              inclusive=inclusive, clip=self.clip)
-        time_min = self.time[0] + tstep_int * self.tstride
-
-        return (time_min, time_min + self.texp)
-
-    #===========================================================================
-    def tstep_at_time(self, time, remask=False, derivs=False, inclusive=True):
-        """Time step for the given time.
-
-        This method returns non-integer time steps via interpolation.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            derivs      True to include derivatives of time in the returned
-                        tstep.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar of time step indices.
-        """
-
-        time = Scalar.as_scalar(time, recursive=derivs)
-        tstep = (time - self.time[0]) / self.tstride
-
-        if self._gapless:
-            if self.clip:
-                tstep = tstep.clip(0, self.steps, remask=remask,
-                                   inclusive=inclusive)
-            elif remask:
-                tstep = tstep.mask_where_outside(0, self.steps, remask=True,
-                                                 mask_endpoints=(False,
-                                                                 not inclusive))
-
-        elif self.is_unique:
-            tstep_int = tstep.int(top=self.steps, remask=remask,
-                                  inclusive=inclusive, clip=self.clip)
-            tstep_diff = tstep - tstep_int
-                # Regardless of self.clip, at the top...
-                # If inclusive, tstep_int = self.steps-1 and tstep_diff = texp
-                # Otherwise, tstep_int = self.steps and tstep_diff = 0.
-
-            # If self.clip is True, then tstep_diff < 0. before the start time.
-            # Otherwise, tstep_diff cannot be negative.
-            if self.clip:
-                tstep_diff[tstep_diff.vals < 0.] = Scalar(0., remask)
-
-            # Don't let an interior fractional part match or exceed tspan, which
-            # happens in the gaps between tsteps. However, if inclusive is True,
-            # then the fractional part is allowed to equal tspan at the end
-            # time.
-            if inclusive:
-                mask = ((tstep_diff.vals >= self._tspan)
-                        & (time.vals != self.time[1]))
-            else:
-                mask = (tstep_diff.vals >= self._tspan)
-
-            tstep_diff[mask] = Scalar(self._tspan, remask)
-
-            # Now we can add the integer and fractional parts
-            tstep = tstep_int + tstep_diff * self._tscale
-
-        else:
-            # Because time steps can overlap, avoid remask for now
-            tstep_int = tstep.int(top=self.steps, remask=False,
-                                  inclusive=False, clip=False)
-
-            # Handle the last, extended time step
-            is_last = Qube.is_inside(time.vals, self.lasttime, self.time[1],
-                                     inclusive=inclusive)
-            tstep_int[is_last] = self.steps - 1
-
-            # Combine with fractional part
-            tstep = tstep_int + (tstep - tstep_int) * self._tscale
-
-            # Clip and remask necessary
-            if self.clip:
-                tstep = tstep.clip(0, self.steps,
-                                   remask=remask, inclusive=inclusive)
-            elif remask:
-                endpoints = (False, not inclusive)
-                tstep = tstep.mask_where_outside(0, self.steps,
-                                                 mask_endpoints=endpoints)
-
-        return tstep
-
-    #===========================================================================
-    def tstep_range_at_time(self, time, remask=False, inclusive=True):
-        """Integer range of time steps active at the given time.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (tstep_min, tstep_max)
-            tstep_min   minimum Scalar time step containing the given time.
-            tstep_max   maximum Scalar time step after the given time.
-
-        Returned tstep_min will always be in the allowed range for the cadence,
-        inclusive, regardless of masking. If the time is not inside the cadence,
-        tstep_max == tstep_min.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-        tstep = (time - self.time[0]) / self.tstride
-
-        # Set mask=True here; restore mask later if remask is False
-        tstep_min = tstep.int(top=self.steps, remask=True,
-                              inclusive=inclusive, clip=True)
-        new_mask = tstep_min.mask       # Note: not a copy so modify cautiously
-
-        # For discontinuous or gapless cases...
-        if self.is_unique:
-            tstep_max = tstep_min + 1
-
-            # Expand mask for discontinuous cadences
-            if not self.is_continuous:
-                # Determine active time within each time step
-                time_frac = (time.vals - self.time[0]
-                                       - self.tstride * tstep_min.vals)
-
-                # Mask times when integration is not happening
-                if inclusive:       # extra care needed at end time
-                    not_integrating = ((time_frac >= self.texp) &
-                                       (time.vals != self.time[1]))
-                else:
-                    not_integrating = (time_frac >= self.texp)
-
-                new_mask = Qube.or_(new_mask, not_integrating)
-
-        else:
-            # For overlapping cases...
-            tstep_max = tstep_min + 1
-            tstep_min = (tstep - self._tspan1).int(top=self.steps, remask=True,
-                                                   inclusive=inclusive,
-                                                   clip=True)
-            # The new mask only applies if _both_ min and max are masked;
-            # Otherwise, it is just a time near the beginning or end, and is
-            # associated with fewer time steps, not no time steps.
-            new_mask = Qube.and_(new_mask, tstep_min.mask)
-
-        # Masked tstep ranges must have zero length
-        tstep_max[new_mask] = tstep_min[new_mask]
-
-        # Make sure both endpoints share a common mask
-        if remask:
-            tstep_min = tstep_min.remask(new_mask)
-            tstep_max = tstep_max.remask(new_mask)
-        else:
-            # Without remasking, revert to the original mask
-            tstep_min = tstep_min.remask(time.mask)
-            tstep_max = tstep_max.remask(time.mask)
-
-        return (tstep_min, tstep_max)
-
-    #===========================================================================
-    def time_is_outside(self, time, inclusive=True):
-        """A Boolean mask of times that fall outside the cadence.
-
-        Masked time values return masked results.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Boolean array indicating which time values are not
-                        sampled by the cadence.
-        """
-
-        if self.is_continuous:
-            return Cadence.time_is_outside(self, time, inclusive=inclusive)
-
-        time = Scalar.as_scalar(time, recursive=False)
-        time_mod = (time - self.time[0]) % self.tstride
-
-        # Use TVL comparison to propagate the mask of time_mod
-        if inclusive:
-            return (time_mod.tvl_gt(self.texp) | time.tvl_lt(self.time[0])
-                                               | time.tvl_gt(self.time[1]))
-        else:
-            return (time_mod.tvl_gt(self.texp) | time.tvl_lt(self.time[0])
-                                               | time.tvl_ge(self.time[1]))
-
-    #===========================================================================
-    def time_shift(self, secs):
-        """Construct a duplicate of this Cadence with all times shifted by given
-        amount.
-
-        Input:
-            secs        the number of seconds to shift the time later.
-        """
-
-        return Metronome(self.tstart + secs,
-                         self.tstride, self.texp, self.steps)
-
-    #===========================================================================
-    def as_continuous(self):
-        """Construct a shallow copy of this Cadence, forced to be continuous.
-
-        For Metronome this is accomplished by forcing the exposure times to
-        be equal to the stride.
-        """
-
-        return Metronome(self.tstart, self.tstride, self.tstride, self.steps)
-
-    #===========================================================================
-    def tstride_at_tstep(self, tstep, sign=1, remask=False):
-        """The time interval(s) between the times of adjacent time steps.
-
-        Input:
-            tstep       a Scalar or Pair time step index, which need not be
-                        integral.
-            sign        +1 for the time interval to the next time step;
-                        -1 for the time interval since the previous time step.
-            remask      True to mask time tsteps that are out of range.
-
-        Return:         a Scalar or Pair of strides in seconds.
-        """
-
-        tstep = Scalar.as_scalar(tstep, recursive=False)
-
-        if remask:
-            tstep = tstep.clip(0, self.steps, remask=remask)
-            if np.any(tstep.mask):
-                return Scalar.filled(tstep.shape, self.tstride, mask=tstep.mask)
-
-        if np.shape(tstep.mask):
-            return Scalar.filled(tstep.shape, self.tstride, mask=tstep.mask)
-
-        return Scalar(self.tstride)
-
-    #===========================================================================
-    @staticmethod
-    def for_array1d(steps, tstart, texp, interstep_delay=0.):
-        """Alternative constructor.
-
-        Input:
-            steps               number of time steps.
-            tstart              start time in seconds TDB.
-            texp                exposure duration in second for each sample.
-            interstep_delay     time delay in seconds between the end of one
-                                integration and the beginning of the next, in
-                                seconds. Default is 0.
-        """
-
-        return Metronome(tstart, texp + interstep_delay, texp, steps)
-
-    #===========================================================================
-    @staticmethod
-    def for_array0d(tstart, texp):
-        """Alternative constructor for a product with no time-axis.
-
-        Input:
-            tstart              start time in seconds TDB.
-            texp                exposure duration in seconds.
-        """
-
-        return Metronome(tstart, texp, texp, 1)
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
 import numpy as np
-from polymath import Boolean
-
-# Tests are defined here as separate functions so they can also be used for
-# testing Sequences that are defined to simulate the behavior of Metronomes.
+import unittest
 
-class Test_Metronome(unittest.TestCase):
+from polymath         import Pair, Vector, Boolean, Scalar
+from oops.cadence     import DualCadence, Metronome, TDICadence
+from oops.fov         import FlatFOV
+from oops.observation import TimedImage
+
+
+
+class Test_TimedImage(unittest.TestCase):
+
+    def runTest(self):
+
+        ########################################################################
+        # Old RasterScan unit tests
+        ########################################################################
+
+        RasterScan = TimedImage
+
+        ####################################################
+        # Continuous observation, shape (10,20)
+        # Axes are (fast,slow)
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=1., steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                         path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(0,21),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, [0, 100, 190, 10, 110, 200, 190, 200])
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + 2*[True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], [0, 100, 190, 10, 110, 200])
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, [0, 100, 190,  9, 109, 199, 190, 199])
+        self.assertEqual(time_max, [1, 101, 191, 10, 110, 200, 191, 200])
+
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices, remask=True)
+
+        self.assertEqual(Boolean(uv_min.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(uv_max.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(time_min.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(time_max.mask), 6*[False] + 2*[True])
+
+        self.assertEqual(uv_min[:6], Pair.as_pair(indices_)[:6])
+        self.assertEqual(uv_max[:6], Pair.as_pair(indices_)[:6] + (1,1))
+        self.assertEqual(time_min[:6], [0, 100, 190,  9, 109, 199])
+        self.assertEqual(time_max[:6], time_min[:6] + fast_cadence.texp)
+
+        # uvt() with remask == False, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv, time) = obs.uvt(non_ints)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, cadence.time_at_tstep(uv.swapxy()))
+        self.assertEqual(uv, Pair.as_pair(non_ints))
+
+        # uvt() with remask == True, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv, time) = obs.uvt(non_ints, remask=True)
+
+        self.assertEqual(Boolean(uv.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time.mask), 2*[False] + 6*[True])
+        self.assertEqual(time[:2],
+                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
+                          fast_cadence.tstride * non_ints.to_scalar(0))[:2])
+        self.assertEqual(uv[:2], Pair.as_pair(non_ints)[:2])
+
+        # uvt_range() with remask == False, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(Pair.as_pair(non_ints).swapxy())[0])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        # uvt_range() with remask == True, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints, remask=True)
+
+        self.assertEqual(Boolean(uv_min.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(uv_max.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time_min.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time_max.mask), 2*[False] + 6*[True])
+
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2],
+                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
+                          fast_cadence.tstride * non_ints.to_scalar(0).int())[:2])
+        self.assertEqual(time_max[:2], time_min[:2] + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+
+        self.assertEqual(time0, [0, 190, 9, 199, 199])
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], [0, 190, 9, 199])
+        self.assertEqual(time1[:4], time0[:4] + fast_cadence.texp)
+
+        ####################################################
+        # Fast cadence is discontinuous
+        # Axes are (slow,fast)
+        # Shape (10,20)
+        # [[0-1, 10-11, 20-21, ..., 190-191],
+        #  [1000-1001, 1010-1011, ..., 1190-1191],
+        #  ...
+        #  [9000-9001, 9010-9011, ..., 9190, 9191]]
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=1000., texp=1., steps=10)
+        fast_cadence = Metronome(tstart=0., tstride=10., texp=1., steps=20)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('uslow','vfast'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, [0, 100, 191, 9000, 9100, 9191, 9191])
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        (time0,time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        ####################################################
+        # Fast cadence is discontinuous
+        # Axes are (fast,slow)
+        # Shape (10,20)
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.8)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 55.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 55.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 55.4)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6.     ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.0) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((6.     ,0))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ))[0] - (1.,0.0)) < delta)
+        self.assertTrue(abs(obs.uvt((2, 1.2    ))[0] - (2.,1.2)) < delta)
+        self.assertTrue(abs(obs.uvt((3, 2.5    ))[0] - (3.,2.5)) < delta)
+        self.assertTrue(abs(obs.uvt((4, 3.8    ))[0] - (4.,3.8)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5.     ))[0] - (5.,5.0)) < delta)
+
+        ############################################################
+        # Alternative tstride for even more discontinuous indices
+        ############################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=11., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 218.8)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 60.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 60.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 60.4)
+        self.assertEqual(obs.uvt((5.5, 5.5))[1], 60.4)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue((obs.uvt((6.     ,0.))[1] - 6.0).abs() < delta)
+        self.assertTrue((obs.uvt((6.25   ,0.))[1] - 6.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.5    ,0.))[1] - 6.4).abs() < delta)
+        self.assertTrue((obs.uvt((6.75   ,0.))[1] - 6.6).abs() < delta)
+        self.assertTrue((obs.uvt((7. -eps,0.))[1] - 6.8).abs() < delta)
+        self.assertTrue((obs.uvt((7.     ,0.))[1] - 7.0).abs() < delta)
+
+        self.assertTrue((obs.uvt((9.      ,0.))[1] -  9.0).abs() < delta)
+        self.assertTrue((obs.uvt((9.25    ,0.))[1] -  9.2).abs() < delta)
+        self.assertTrue((obs.uvt((9.5     ,0.))[1] -  9.4).abs() < delta)
+        self.assertTrue((obs.uvt((9.75    ,0.))[1] -  9.6).abs() < delta)
+        self.assertTrue((obs.uvt((10 - eps,0.))[1] -  9.8).abs() < delta)
+        self.assertTrue((obs.uvt((0.      ,1.))[1] - 11.0).abs() < delta)
+
+        self.assertTrue((obs.uvt((6.00, 0.    ))[1] -  6.0).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 0.    ))[1] -  6.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 1.    ))[1] - 17.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 2.-eps))[1] - 17.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 2.    ))[1] - 28.2).abs() < delta)
+
+        # Test the upper edge
+        pair = (10-eps, 20-eps)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10, 20-eps)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10-eps, 20)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10, 20)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        self.assertTrue(obs.uvt((10+eps, 20), True)[0].mask)
+        self.assertTrue(obs.uvt((10, 20+eps), True)[0].mask)
+
+        # Try all at once
+        indices = Pair([(10-eps,20-eps), (10,20-eps), (10-eps,20), (10,20),
+                        (10+eps,20), (10,20+eps)])
+        (test_uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertEqual(Boolean(test_uv.mask), 4*[False] + 2*[True])
+        self.assertEqual(test_uv[:4], indices[:4])
+        self.assertTrue(((time[:4] - 218.8).abs() < delta).all())
+        self.assertEqual(Boolean(time.mask), test_uv.mask)
+
+        ############################################################
+        # Alternative texp and axes
+        ############################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('a','vslow','b','ufast','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.8)
+
+        self.assertEqual(obs.uvt((1,0,3,0,4))[1],   0.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1],   5.)
+        self.assertEqual(obs.uvt((1,0,3,5.5,4))[1], 5.4)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 7.0) < delta)
+
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6   ,7))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2 ,7))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4 ,7))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6 ,7))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8 ,7))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.  ,7))[0] - (7.0,6.)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ,4,1,7))[0] - (1.,0.0)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 1.2    ,4,2,7))[0] - (2.,1.2)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 2.5    ,4,3,7))[0] - (3.,2.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 3.7    ,4,4,7))[0] - (4.,3.7)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5.     ,4,5,7))[0] - (5.,5.0)) < delta)
+
+        ########################################################################
+        # Old Pushbroom unit tests
+        ########################################################################
+
+        Pushbroom = TimedImage
+
+        ########################################
+        # Overall shape (10,20)
+        # Time is second axis; time = v * 10.
+        ########################################
+
+        flatfov = FlatFOV((0.001,0.001), (10,20))
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        obs = Pushbroom(axes=('u','vt'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
+
+        indices_ = indices.copy()   # clipped at top
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, cadence.time_at_tstep(tstep))
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], cadence.tstride * indices.to_scalar(1)[:6])
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        # uvt_range() with remask == False, new indices
+        non_ints = indices + (0.2,0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        # uvt_range() with remask == True, new indices
+        non_ints = indices + (0.2,0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints,
+                                                             remask=True)
+
+        self.assertTrue(np.all(uv_min.mask == np.array(2*[False] + 5*[True])))
+        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
+        self.assertTrue(np.all(time_min.mask == uv_min.mask))
+        self.assertTrue(np.all(time_max.mask == uv_min.mask))
+
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
+        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+        tstep = uv.to_scalar(1)
+
+        uv_ = uv.copy()
+        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
+        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, time0 + cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], cadence.tstride * uv_.to_scalar(1)[:4])
+        self.assertEqual(time1[:4], time0[:4] + cadence.texp)
+
+        ########################################
+        # Alternative axis order ('ut','v')
+        # Overall shape (10,20)
+        # Time is first axis; time = v * 10.
+        ########################################
+
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
+        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        (uv, time) = obs.uvt(indices)
+
+        uv_ = uv.copy()
+        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
+        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
+
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, cadence.tstride * indices.to_scalar(0))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.tstride * indices_.to_scalar(0))
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        (time0, time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.tstride * uv_.to_scalar(0))
+        self.assertEqual(time1, time0 + cadence.texp)
+
+        ########################################################
+        # Alternative texp for discontinuous time index
+        # Overall shape (10,20)
+        # Time is first axis; time = [0-8, 10-18, ..., 90-98]
+        ########################################################
+
+        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
+        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 98.)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1], 50.)
+        self.assertEqual(obs.uvt((5,5))[1], 50.)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6      ,0))[1] - 60.) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 62.) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 64.) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 66.) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 68.) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 70.) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((6      ,0))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,5))[0] - (7.0,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
+
+        # Test the upper edge
+        uv_list = []
+        uvt_list = []
+        for i,u in enumerate([10.-eps, 10., 10.+eps]):
+          for j,v in enumerate([20.-eps, 20., 20.+eps]):
+            uv_list.append((u,v))
+
+            uvt = obs.uvt((u,v), remask=True)
+            uvt_list.append(uvt)
+            if (i < 2) and (j < 2):
+                self.assertEqual(uvt[0], (u,v))
+            else:
+                self.assertEqual(uvt[0], Pair.MASKED)
 
-  def runTest(self):
+            if (i < 2) and (j < 2):
+                self.assertTrue((uvt[1] - (10. * u - 2.)).abs() < delta)
+            else:
+                self.assertEqual(uvt[1], Scalar.MASKED)
 
-    np.random.seed(4182)
-
-    ############################################
-    # Tests for continuous case
-    # 100-110, 110-120, 120-130, 130-140
-    ############################################
-
-    cadence = Metronome(100., 10., 10., 4)
-    case_continuous(self, cadence)
-
-    # tstride_at_tstep
-    tstep = Scalar(7 * np.random.rand(100) - 1.)
-    tstride = cadence.tstride_at_tstep(tstep, remask=False)
-    self.assertEqual(tstride, cadence.tstride)
-
-    tstride = cadence.tstride_at_tstep(tstep, remask=True)
-    outside = (tstep < 0.) | (tstep > 4.)
-    self.assertEqual(tstride[~outside], cadence.tstride)
-    self.assertEqual(tstride[outside], Scalar.MASKED)
-
-    # Unclipped Metronome tests
-    cadence = Metronome(100., 10., 10., 4, clip=False)
-    self.assertEqual(cadence.time_at_tstep(-0.5, remask=False),  95.)
-    self.assertEqual(cadence.time_at_tstep( 4.5, remask=False), 145.)
-
-    self.assertEqual(cadence.tstep_at_time( 95., remask=False), -0.5)
-    self.assertEqual(cadence.tstep_at_time(145., remask=False),  4.5)
-
-    ############################################
-    # Discontinuous case
-    # 100-107.5, 110-117.5, 120-127.5, 130-137.5
-    ############################################
-
-    cadence = Metronome(100., 10., 7.5, 4)
-    case_discontinuous(self, cadence)
-
-    # Unclipped Metronome tests
-    cadence = Metronome(100., 10., 8., 4, clip=False)
-    self.assertEqual(cadence.time_at_tstep(-0.5, remask=False),  94.)
-    self.assertEqual(cadence.time_at_tstep( 4.5, remask=False), 144.)
-    self.assertEqual(cadence.time_at_tstep(3.5), 134.)
-    self.assertEqual(cadence.time_at_tstep(4), 138.)
-    self.assertEqual(cadence.time_at_tstep((3,4)), (130.,138.))
-
-    self.assertEqual(cadence.tstep_at_time(139., remask=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(140., remask=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(144., remask=False), 4.5)
-    self.assertEqual(cadence.tstep_at_time(154., remask=False), 5.5)
-    self.assertEqual(cadence.tstep_at_time( 90., remask=False), -1.)
-    self.assertEqual(cadence.tstep_at_time( 94., remask=False), -0.5)
-
-    ############################################
-    # Non-unique case
-    # 100-140, 110-150, 120-160, 130-170
-    ############################################
-
-    cadence = Metronome(100., 10., 40., 4)
-    case_non_unique(self, cadence)
-
-    # Unclipped Metronome tests
-    cadence = Metronome(100., 10., 40., 4, clip=False)
-    self.assertEqual(cadence.time_at_tstep(-0.5,remask=False), 110.)
-    self.assertEqual(cadence.time_at_tstep( 4.5,remask=False), 160.)
-    self.assertEqual(cadence.tstep_at_time(170., inclusive=False), 7.)
-    self.assertEqual(cadence.tstep_at_time(171., remask=False), 7.025)
-    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False), (3,3))
-
-    ############################################
-    # Partial overlap case
-    # 100-140, 130-170, 160-200, 190-230
-    ############################################
-
-    cadence = Metronome(100., 30., 40., 4)
-    case_partial_overlap(self, cadence)
-
-    # Unclipped Metronome tests
-    cadence = Metronome(100., 30., 40., 4, clip=False)
-    self.assertEqual(cadence.time_at_tstep(-0.5,remask=False),  90.)
-    self.assertEqual(cadence.time_at_tstep( 4.5,remask=False), 240.)
-    self.assertEqual(cadence.tstep_at_time(230., inclusive=False), 4.25)
-    self.assertEqual(cadence.tstep_at_time(235., remask=False), 4.375)
-
-    ############################################
-    # One time step, 100-110
-    ############################################
-
-    cadence = Metronome(100., 22., 10., 1)
-    one_time_step(self, cadence)
-
-############################################
-# Tests for continuous case
-# 100-110, 110-120, 120-130, 130-140
-############################################
-
-def case_continuous(self, cadence):
-
-    self.assertTrue(cadence.is_continuous)
-    self.assertTrue(cadence.is_unique)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(0, remask=True ), 100.)
-    self.assertEqual(cadence.time_at_tstep(0, remask=False), 100.)
-    self.assertEqual(cadence.time_at_tstep(1, remask=True ), 110.)
-    self.assertEqual(cadence.time_at_tstep(1, remask=False), 110.)
-    self.assertEqual(cadence.time_at_tstep(4, remask=True ), 140.)
-    self.assertEqual(cadence.time_at_tstep(4, remask=False), 140.)
-    self.assertEqual(cadence.time_at_tstep((3,4), remask=True ), (130.,140.))
-    self.assertEqual(cadence.time_at_tstep((3,4), remask=False), (130.,140.))
-    self.assertEqual(cadence.time_at_tstep(0.5, remask=True ), 105.)
-    self.assertEqual(cadence.time_at_tstep(0.5, remask=False), 105.)
-    self.assertEqual(cadence.time_at_tstep(3.5, remask=True ), 135.)
-    self.assertEqual(cadence.time_at_tstep(3.5, remask=False), 135.)
-
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
-                     [False,True,False])
-
-    tstep = ([0,1],[2,3],[3,4])
-    time  = ([100,110],[120,130],[130,140])
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
-
-    tstep = ([-1,0],[2,4],[4.5,5])
-    test = cadence.time_at_tstep(tstep, remask=False)
-    self.assertEqual(test.masked(), 0)
-    self.assertEqual(test, [[100,100],[120,140],[140,140]])
-
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(test.mask) ==
-                    [[True,False],[False,False],[True,True]])
-
-    test = cadence.time_at_tstep(tstep, remask=True, inclusive=False)
-    self.assertTrue(Boolean(test.mask) ==
-                    [[True,False],[False,True],[True,True]])
-
-    # time_at_tstep(), derivs
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
-                     [False,True,False])
-
-    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
-                     (20, Scalar.MASKED, 40))
-
-    tstep = Scalar((0.,1.,2.))
-    tstep.insert_deriv('t', Scalar((2,3,4)))
-    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
-                     [(0,10), (20,30), (40,50)])
-
-    # time_is_inside()
-    time = ([99,100],[120,140],[145,150])
-    self.assertTrue(cadence.time_is_inside(time) ==
-                     [[False,True],[True,True],[False,False]])
-    self.assertTrue(Boolean(cadence.time_is_inside(time, inclusive=False)) ==
-                     [[False,True],[True,False],[False,False]])
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_is_inside(time).mask), time.mask)
-
-    # tstep_at_time()
-    self.assertEqual(cadence.tstep_at_time(100., remask=True ), 0.)
-    self.assertEqual(cadence.tstep_at_time(100., remask=False), 0.)
-    self.assertEqual(cadence.tstep_at_time(105., remask=True ), 0.5)
-    self.assertEqual(cadence.tstep_at_time(105., remask=False), 0.5)
-    self.assertEqual(cadence.tstep_at_time(135., remask=True ), 3.5)
-    self.assertEqual(cadence.tstep_at_time(135., remask=False), 3.5)
-    self.assertEqual(cadence.tstep_at_time(140., remask=False), 4.0)
-    self.assertEqual(cadence.tstep_at_time(140., remask=True ), 4.0)
-    self.assertEqual(cadence.tstep_at_time(140., remask=True,
-                                                 inclusive=False), Scalar.MASKED)
-
-    tstep = [100.,105.,108.,109.,110]
-    self.assertEqual(cadence.tstep_at_time(tstep, remask=True).count_masked(), 0)
-
-    tstep = [95,100.,105.,110.,140.,145.]
-    self.assertFalse(np.any(cadence.tstep_at_time(tstep, remask=False).mask))
-    self.assertTrue(np.all(cadence.tstep_at_time(tstep,
-                                                 remask=True).mask == (1,0,0,0,0,1)))
-    self.assertTrue(np.all(cadence.tstep_at_time(tstep, remask=True,
-                                                 inclusive=False).mask == (1,0,0,0,1,1)))
-    self.assertTrue(np.all(cadence.tstep_at_time(tstep, remask=False,
-                                                 inclusive=True).vals == [0,0,0.5,1,4,4]))
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
-                     time.mask)
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
-                     time.mask)
-
-    # tstep_at_time(), derivs
-    time = Scalar((90,100,110,140), derivs={'t': Scalar((100,200,300,400))})
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt,
-                     (0, 20, 30, 40))
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
-                                                 inclusive=False).d_dt,
-                     (0, 20, 30, 0))
-
-    # tstep_range_at_time()
-    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(110.), (1,2))
-    self.assertEqual(cadence.tstep_range_at_time(135.), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(140.), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(140., remask=True), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(140., remask=True,
-                                                       inclusive=True), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(140., remask=False,
-                                                       inclusive=False), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(140., remask=True,
-                                                       inclusive=False), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(140., remask=False,
-                                                       inclusive=True), (3,4))
-
-    self.assertEqual(cadence.tstep_range_at_time(140.001), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(140.001, remask=True), MASKED_TUPLE)
-
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(100., remask=True), (0,1))
-
-    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=False), (0,0))
-    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=True), MASKED_TUPLE)
-
-    tstep = [95.,100.,105.,110.,140.,145.]
-    self.assertEqual(cadence.tstep_range_at_time(tstep, remask=False,
-                                                 inclusive=True), ([0,0,0,1,3,3],
-                                                                   [0,1,1,2,4,3]))
-    self.assertEqual(cadence.tstep_range_at_time(tstep, remask=False,
-                                                 inclusive=False), ([0,0,0,1,3,3],
-                                                                    [0,1,1,2,3,3]))
-
-    # Conversion and back
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-    time = cadence.time_at_tstep(tstep, remask=False)
-    test = cadence.tstep_at_time(time, remask=False)
-    mask = (tstep.vals < 0) | (tstep.vals > 4)
-    self.assertTrue((abs(tstep - test)[~mask] < 1.e-14).all())
-    self.assertTrue(np.all(time[tstep.vals < 0] == 100.))
-    self.assertTrue(np.all(time[tstep.vals > 4] == 140.))
-    self.assertEqual(test.masked(), 0)
-
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue((abs(time - test).mvals < 1.e-14).all())
-    self.assertTrue(np.all(test.mask == mask))
-    self.assertTrue(cadence.time_is_inside(time).all_true_or_masked())
-
-    time = Scalar(70 * np.random.rand(100,100) + 90.)
-    tstep = cadence.tstep_at_time(time, remask=False)
-    test = cadence.time_at_tstep(tstep, remask=False)
-    mask = (time.vals < 100) | (time.vals > 140)
-    self.assertTrue((abs(time - test)[~mask] < 1.e-14).all())
-    self.assertEqual(tstep.masked(), 0)
-    self.assertEqual(test.masked(), 0)
-
-    # time_range_at_tstep()
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep)[0].mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep)[1].mask),
-                     [False,True,False])
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-    time = cadence.time_at_tstep(tstep, remask=False)
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
-    self.assertEqual(time0, 10*((time0/10).int()))
-    self.assertEqual(time1, 10*((time1/10).int()))
-
-    self.assertTrue((abs(time1 - time0 - 10.) < 1.e-14).all())
-
-    mask = (tstep < 0) | (tstep > cadence.steps)
-    unmasked = ~mask
-    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
-    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
-    self.assertTrue((time0[unmasked] <= cadence.time[1]).all())
-    self.assertTrue((time1[unmasked] <= cadence.time[1]).all())
-    self.assertTrue((time0[unmasked] <= time[unmasked]).all())
-    self.assertTrue((time1[unmasked] >= time[unmasked]).all())
-
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(time0.mask) == mask)
-    self.assertTrue(Boolean(time1.mask) == mask)
-
-    # time_shift()
-    shifted = cadence.time_shift(1.)
-    time_shifted = shifted.time_at_tstep(tstep, remask=False)
-
-    self.assertTrue((abs(time_shifted-time-1.) < 1.e-13).all())
-
-    # tstride_at_tstep
-    tstep = Scalar(7 * np.random.rand(100) - 1.)
-    outside = (tstep < 0.) | (tstep > 4.)
-    tstep = tstep.remask(50*[False] + 50*[True])
-
-    tstride = cadence.tstride_at_tstep(tstep, remask=False)
-    self.assertTrue(not np.any(tstride.mask[:50]))
-    self.assertTrue(np.all(tstride.mask[50:]))
-
-    tstride = cadence.tstride_at_tstep(tstep, remask=True)
-    self.assertTrue(np.all(tstride.mask[:50] == outside[:50]))
-    self.assertTrue(np.all(tstride.mask[50:]))
-
-############################################
-# Discontinuous case
-# 100-107.5, 110-117.5, 120-127.5, 130-137.5
-############################################
-
-def case_discontinuous(self, cadence):
-
-    self.assertFalse(cadence.is_continuous)
-    self.assertTrue(cadence.is_unique)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(0, remask=True ), 100.)
-    self.assertEqual(cadence.time_at_tstep(0, remask=False), 100.)
-    self.assertEqual(cadence.time_at_tstep(1, remask=True ), 110.)
-    self.assertEqual(cadence.time_at_tstep(1, remask=False), 110.)
-    self.assertEqual(cadence.time_at_tstep(4, remask=True ), 137.5)
-    self.assertEqual(cadence.time_at_tstep(4, remask=False), 137.5)
-    self.assertEqual(cadence.time_at_tstep((3,4), remask=True ), (130.,137.5))
-    self.assertEqual(cadence.time_at_tstep((3,4), remask=False), (130.,137.5))
-    self.assertEqual(cadence.time_at_tstep(0.5, remask=True ), 103.75)
-    self.assertEqual(cadence.time_at_tstep(0.5, remask=False), 103.75)
-    self.assertEqual(cadence.time_at_tstep(3.5, remask=True ), 133.75)
-    self.assertEqual(cadence.time_at_tstep(3.5, remask=False), 133.75)
-
-    tstep = ([0,1],[2,3],[3,4])
-    time  = ([100,110],[120,130],[130,137.5])
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
-
-    tstep = ([-1,0],[2,4],[4.5,5])
-    test = cadence.time_at_tstep(tstep, remask=False)
-    self.assertEqual(test.masked(), 0)
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(test.mask) ==
-                    [[True,False],[False,False],[True,True]])
-
-    # time_at_tstep(), derivs
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
-                     [False,True,False])
-
-    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
-                     (15, Scalar.MASKED, 30))
-
-    tstep = Scalar((0.,1.,2.))
-    tstep.insert_deriv('t', Scalar((2,3,4)))
-    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
-                     [(0,7.5), (15,22.5), (30,37.5)])
-
-    # time_is_inside()
-    time  = ([99,100],[120,137.5],[145,150])
-    self.assertTrue(cadence.time_is_inside(time) ==
-                    [[False,True],[True,True],[False,False]])
-    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
-                    [[False,True],[True,False],[False,False]])
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_is_inside(time).mask), time.mask)
-
-    # tstep_at_time()
-    self.assertEqual(cadence.tstep_at_time(100.  , remask=True ), 0.)
-    self.assertEqual(cadence.tstep_at_time(100.  , remask=False), 0.)
-    self.assertEqual(cadence.tstep_at_time(103.75, remask=True ), 0.5)
-    self.assertEqual(cadence.tstep_at_time(103.75, remask=False), 0.5)
-    self.assertEqual(cadence.tstep_at_time(110.  , remask=False), 1.)
-    self.assertEqual(cadence.tstep_at_time(107.5 , remask=False), 1.)
-    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True, inclusive=False), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True, inclusive=True) , Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(107.5 , remask=False), 1.)
-    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True) , Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(133.75, remask=True ), 3.5)
-    self.assertEqual(cadence.tstep_at_time(133.75, remask=False), 3.5)
-    self.assertEqual(cadence.tstep_at_time(137.5 , remask=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(137.5 , remask=False, inclusive=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(137.5 , remask=True , inclusive=True ), 4.)
-    self.assertEqual(cadence.tstep_at_time(137.5 , remask=True , inclusive=False), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(138.  , remask=False, inclusive=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(138.  , remask=True), Scalar.MASKED)
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
-                     time.mask)
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
-                     time.mask)
-
-    time = [100.,103.75,107.5,109.,110.]
-    self.assertTrue(cadence.tstep_at_time(time, remask=False) ==
-                    [0., 0.5, 1., 1., 1.])
-    self.assertTrue(Boolean(cadence.tstep_at_time(time, remask=True).mask) ==
-                    [False,False,True,True,False])
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
-                     time.mask)
-    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
-                     time.mask)
-
-    # tstep_at_time(), derivs
-    time = Scalar((90,100,113.75,137.5,140), derivs={'t': Scalar((15,30,45,60,75))})
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt,
-                     (0,4,6,8,0))
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
-                                                 inclusive=False).d_dt,
-                     (0,4,6,0,0))
-
-    # tstep_range_at_time()
-    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(135.), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(108.)[0],  # indicates empty range
-                     cadence.tstep_range_at_time(108.)[1])
-    self.assertEqual(cadence.tstep_range_at_time(108., remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(107.5)[0],  # indicates empty range
-                     cadence.tstep_range_at_time(107.5)[1])
-    self.assertEqual(cadence.tstep_range_at_time(107.5, remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(117.5)[0],  # indicates empty range
-                     cadence.tstep_range_at_time(117.5)[1])
-    self.assertEqual(cadence.tstep_range_at_time(117.5, remask=True), MASKED_TUPLE)
-
-    self.assertEqual(cadence.tstep_range_at_time(140. ), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(137.5), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True,
-                                                        inclusive=True), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=False,
-                                                        inclusive=False), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True,
-                                                        inclusive=False), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=False,
-                                                        inclusive=True), (3,4))
-
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(100., remask=True), (0,1))
-
-    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=False), (0,0))
-    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=True), MASKED_TUPLE)
-
-    # Conversion and back
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-    time = cadence.time_at_tstep(tstep, remask=False)
-    test = cadence.tstep_at_time(time, remask=False)
-    mask = (tstep.vals < 0) | (tstep.vals > 4)
-    self.assertTrue((abs(tstep - test)[~mask] < 1.e-14).all())
-    self.assertTrue(np.all(time[tstep.vals < 0] == 100.))
-    self.assertTrue(np.all(time[tstep.vals > 4] == 137.5))
-    self.assertEqual(test.masked(), 0)
-
-    mask = (tstep < 0) | (tstep > cadence.steps)
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue((abs(time - test).mvals < 1.e-14).all())
-    self.assertTrue(Boolean(test.mask) == mask)
-    self.assertTrue(cadence.time_is_inside(time).all_true_or_masked())
-
-    time = Scalar(70 * np.random.rand(100,100) + 90.)
-    tstep = cadence.tstep_at_time(time, remask=True)
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue((abs(time - test)[~test.mask] < 1.e-13).all())
-    self.assertTrue(Boolean(test.mask) == tstep.mask)
-    self.assertTrue(cadence.time_is_inside(time[~test.mask]).all())
-    self.assertTrue(cadence.time_is_outside(time.vals[test.mask]).all())
-
-    # time_range_at_tstep()
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[0].mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[1].mask),
-                     [False,True,False])
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-    tstep = tstep.int() # time_range_at_tstep requires an int input
-    time = cadence.time_at_tstep(tstep, remask=False)
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
-    self.assertEqual(time0, 10*((time0/10).int()))
-    self.assertEqual(time1, 10*((time1/10).int())+7.5)
-
-    self.assertTrue((abs(time1 - time0 - 7.5) < 1.e-14).all())
-
-    mask = (tstep < 0) | (tstep > cadence.steps)
-    unmasked = ~mask
-    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
-    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
-# These are not actually true with Metronome because we're happy to keep
-# on computing time beyond the end of the time limits on both ends
-#        self.assertTrue((time0[unmasked] <= cadence.time[1]).all())
-#        self.assertTrue((time1[unmasked] <= cadence.time[1]).all())
-#        self.assertTrue((time0[unmasked] <= time[unmasked]).all())
-    self.assertTrue((time1[unmasked] >= time[unmasked]).all())
-
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(time0.mask) == mask)
-    self.assertTrue(Boolean(time1.mask) == mask)
-
-    # time_shift()
-    shifted = cadence.time_shift(1.)
-    time_shifted = shifted.time_at_tstep(tstep, remask=False)
-
-    self.assertTrue((abs(time_shifted-time-1.) < 1.e-13).all())
-
-    ############################################
-    # Converted-to-continuous case
-    # We just do spot-checking here
-    ############################################
-
-    cadence = cadence.as_continuous()
-    self.assertTrue(cadence.is_continuous)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(0), 100.)
-    self.assertEqual(cadence.time_at_tstep(1), 110.)
-
-    tstep = ([0,1],[2,3],[3,3])
-    time  = ([100,110],[120,130],[130,130])
-    self.assertEqual(cadence.time_at_tstep(tstep), time)
-
-    tstep = ([-1,0],[2,4],[4.5,5])
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(test.mask) ==
-                    [[True,False],[False,False],[True,True]])
-
-    self.assertEqual(cadence.time_at_tstep(0.5), 105.)
-
-############################################
-# Non-unique case
-# 100-140, 110-150, 120-160, 130-170
-############################################
-
-def case_non_unique(self, cadence):
-
-    self.assertTrue(cadence.is_continuous)
-    self.assertFalse(cadence.is_unique)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(0), 100.)
-    self.assertEqual(cadence.time_at_tstep(1), 110.)
-    self.assertEqual(cadence.time_at_tstep(1.025), 111.)
-    self.assertEqual(cadence.time_at_tstep(1.975), 149.)
-    self.assertEqual(cadence.time_at_tstep((3,4)), (130.,170.))
-    self.assertEqual(cadence.time_at_tstep(3.5,), 150.)
-
-    tstep = ([0,1],[2,3],[3,4])
-    time  = ([100,110],[120,130],[130,170])
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
-
-    tstep = ([-1,0],[2,4],[4.5,5])
-    test = cadence.time_at_tstep(tstep, remask=False)
-    self.assertEqual(test.masked(), 0)
-    test = cadence.time_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(test.mask) ==
-                    [[True,False],[False,False],[True,True]])
-
-    # time_at_tstep(), derivs
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
-                     [False,True,False])
-
-    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
-                     (80, Scalar.MASKED, 160))
-
-    tstep = Scalar((0.,1.,2.))
-    tstep.insert_deriv('t', Scalar((2,3,4)))
-    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
-                     [(0,40), (80,120), (160,200)])
-
-    # time_is_inside()
-    time  = ([99,100],[150,170],[171,200])
-    self.assertTrue(cadence.time_is_inside(time) ==
-                    [[False,True],[True,True],[False,False]])
-    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
-                    [[False,True],[True,False],[False,False]])
-
-    # tstep_at_time()
-    self.assertEqual(cadence.tstep_at_time(100.), 0.)
-    self.assertEqual(cadence.tstep_at_time(105.), 0.125)
-    self.assertEqual(cadence.tstep_at_time(110.), 1.)
-    self.assertEqual(cadence.tstep_at_time(140.), 3.25)
-
-    self.assertEqual(cadence.tstep_at_time(170., inclusive=True), 4.)
-    self.assertEqual(cadence.tstep_at_time(170., remask=True,
-                                                 inclusive=False), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(170., remask=False,
-                                                 inclusive=False), 4.)
-    self.assertEqual(cadence.tstep_at_time(171., remask=True), Scalar.MASKED)
-
-    time = Scalar((100.,110.,120.), [False,True,False])
-    self.assertEqual(cadence.tstep_at_time(time), (0., Scalar.MASKED, 2.))
-
-    # tstep_range_at_time()
-    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
-    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(135.), (0,4))
-    self.assertEqual(cadence.tstep_range_at_time(140.), (1,4))
-    self.assertEqual(cadence.tstep_range_at_time(159.), (2,4))
-    self.assertEqual(cadence.tstep_range_at_time(160.), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=True ), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False,
-                                                       remask=True), MASKED_TUPLE)
-
-    time = Scalar(90 + 90. * np.random.rand(100))   # 90 to 180
-    (tstep_min, tstep_max) = cadence.tstep_range_at_time(time, remask=True)
-    self.assertEqual(Boolean(tstep_min.mask), tstep_max.mask)
-    outside = (time < 100.) | (time > 170.)
-    self.assertEqual(Boolean(tstep_min.mask), outside)
-
-    for t in time:
-        tstep_min, tstep_max = cadence.tstep_range_at_time(t)
-        for tstep in range(tstep_min.vals, tstep_max.vals):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertTrue(time0 < t < time1)
-        for tstep in range(0, tstep_min.vals):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertFalse(time0 < t < time1)
-        for tstep in range(tstep_max.vals, cadence.steps):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertFalse(time0 < t < time1)
-
-    # time_range_at_tstep()
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[0].mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[1].mask),
-                     [False,True,False])
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-
-    time = cadence.time_at_tstep(tstep, remask=True)
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
-    self.assertTrue((time - time0 >= 0.)[~time.mask].all())
-    self.assertTrue((time1 - time >= 0.)[~time.mask].all())
-    self.assertTrue(cadence.time_is_inside(time[~time.mask]).all())
-
-    mask = (tstep.vals < 0) | (tstep.vals > cadence.steps)
-    self.assertTrue(np.all(mask == time.mask))
-
-    unmasked = ~mask
-    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
-    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
-
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
-    self.assertTrue(Boolean(time0.mask) == mask)
-    self.assertTrue(Boolean(time1.mask) == mask)
-
-    # time_shift()
-    shifted = cadence.time_shift(1.)
-    time_shifted = shifted.time_at_tstep(tstep, remask=False)
-
-    self.assertTrue((abs(time_shifted-time-1.)[~time.mask] < 1.e-13).all())
-
-############################################
-# Partial overlap case
-# 100-140, 130-170, 160-200, 190-230
-############################################
-
-def case_partial_overlap(self, cadence):
-
-    self.assertTrue(cadence.is_continuous)
-    self.assertFalse(cadence.is_unique)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(0), 100.)
-    self.assertEqual(cadence.time_at_tstep(1), 130.)
-    self.assertEqual(cadence.time_at_tstep(1.025), 131.)
-    self.assertEqual(cadence.time_at_tstep(1.975), 169.)
-    self.assertEqual(cadence.time_at_tstep((3,4)), (190.,230.))
-    self.assertEqual(cadence.time_at_tstep(3.5,), 210.)
-
-    # time_at_tstep(), derivs
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
-                     [False,True,False])
-
-    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
-                     (80, Scalar.MASKED, 160))
-
-    tstep = Scalar((0.,1.,2.))
-    tstep.insert_deriv('t', Scalar((2,3,4)))
-    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
-                     [(0,40), (80,120), (160,200)])
-
-    # time_range_at_tstep()
-    tstep = Scalar((0.,1.,2.), [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[0].mask),
-                     [False,True,False])
-    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
-                                                         remask=True)[1].mask),
-                     [False,True,False])
-    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
-    time = cadence.time_at_tstep(tstep, remask=True)
-    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
-    self.assertTrue((time - time0 >= 0.)[~time.mask].all())
-    self.assertTrue((time1 - time >= 0.)[~time.mask].all())
-
-    # time_is_inside()
-    time  = ([99,100],[150,230],[241,260])
-    self.assertTrue(cadence.time_is_inside(time) ==
-                    [[False,True],[True,True],[False,False]])
-    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
-                    [[False,True],[True,False],[False,False]])
-
-    # tstep_at_time()
-    self.assertEqual(cadence.tstep_at_time(100.), 0.)
-    self.assertEqual(cadence.tstep_at_time(110.), 0.25)
-    self.assertEqual(cadence.tstep_at_time(135.), 1.125)
-
-    self.assertEqual(cadence.tstep_at_time(230., inclusive=True), 4.)
-    self.assertEqual(cadence.tstep_at_time(230., remask=True,
-                                                 inclusive=False), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(231., remask=True), Scalar.MASKED)
-
-    time = Scalar((100.,130.,160.), [False,True,False])
-    self.assertEqual(cadence.tstep_at_time(time), (0., Scalar.MASKED, 2.))
-
-    # tstep_range_at_time()
-    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
-    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(136.), (0,2))
-    self.assertEqual(cadence.tstep_range_at_time(170.), (2,3))
-    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=True ), (3,4))
-    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=False), (3,3))
-    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=False,
-                                                        remask=True), MASKED_TUPLE)
-
-    time = Scalar(90 + (240-90) * np.random.rand(100))  # 90 to 240
-    (tstep_min, tstep_max) = cadence.tstep_range_at_time(time, remask=True)
-    self.assertEqual(Boolean(tstep_min.mask), tstep_max.mask)
-    outside = (time < 100.) | (time > 230.)
-    self.assertEqual(Boolean(tstep_min.mask), outside)
-
-    for t in time:
-        tstep_min, tstep_max = cadence.tstep_range_at_time(t)
-        for tstep in range(tstep_min.vals, tstep_max.vals):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertTrue(time0 < t < time1)
-        for tstep in range(0, tstep_min.vals):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertFalse(time0 < t < time1)
-        for tstep in range(tstep_max.vals, cadence.steps):
-            time0, time1 = cadence.time_range_at_tstep(tstep)
-            self.assertFalse(time0 < t < time1)
-
-############################################
-# One time step, 100-110
-############################################
-
-def one_time_step(self, cadence):
-
-    self.assertTrue(cadence.is_continuous)
-    self.assertTrue(cadence.is_unique)
-
-    # time_at_tstep()
-    self.assertEqual(cadence.time_at_tstep(-0.1), 100.)
-    self.assertEqual(cadence.time_at_tstep(-0.1, remask=False), 100.)
-    self.assertEqual(cadence.time_at_tstep(-0.1, remask=True ), Scalar.MASKED)
-    self.assertEqual(cadence.time_at_tstep( 0  ), 100.)
-    self.assertEqual(cadence.time_at_tstep( 0.5), 105.)
-    self.assertEqual(cadence.time_at_tstep( 1, remask=False), 110.)
-    self.assertEqual(cadence.time_at_tstep( 1, remask=True ), 110.)
-    self.assertEqual(cadence.time_at_tstep(1, remask=True, inclusive=False), Scalar.MASKED)
-
-    # time_at_tstep(), derivs
-    tstep = Scalar((0., 0.5, 1., 2.))
-    tstep.insert_deriv('t', Scalar((2,3,4,5)))
-
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), (100,105,110,110))
-    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), (100,105,110,Scalar.MASKED))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt, (20,30,40,0))
-    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True, inclusive=False).d_dt, (20,30,0,0))
-
-    # time_is_inside()
-    time = ([99,100],[120,140],[145,150])
-    self.assertFalse(cadence.time_is_inside(90))
-    self.assertTrue (cadence.time_is_inside(100))
-    self.assertTrue (cadence.time_is_inside(110))
-    self.assertFalse(cadence.time_is_inside(110, inclusive=False))
-    self.assertFalse(cadence.time_is_inside(111))
-
-    # tstep_at_time()
-    self.assertEqual(cadence.tstep_at_time( 99), 0.)
-    self.assertEqual(cadence.tstep_at_time( 99, remask=True), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(100), 0.)
-    self.assertEqual(cadence.tstep_at_time(105), 0.5)
-    self.assertEqual(cadence.tstep_at_time(110), 1.)
-    self.assertEqual(cadence.tstep_at_time(110, remask=True), 1.)
-    self.assertEqual(cadence.tstep_at_time(110, remask=True, inclusive=False), Scalar.MASKED)
-    self.assertEqual(cadence.tstep_at_time(111), 1.)
-    self.assertEqual(cadence.tstep_at_time(111, remask=True), Scalar.MASKED)
-
-    # tstep_at_time(), derivs
-    time = Scalar((90,100,110,140), derivs={'t': Scalar((100,200,300,400))})
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt, (0, 20, 30, 0))
-    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
-                                                 inclusive=False).d_dt, (0, 20, 0, 0))
-
-    # tstep_range_at_time()
-    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
-    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(110.), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(110., remask=True), (0,1))
-    self.assertEqual(cadence.tstep_range_at_time(110., remask=True, inclusive=False), MASKED_TUPLE)
-    self.assertEqual(cadence.tstep_range_at_time(135., remask=True), MASKED_TUPLE)
-
-    tstep0, tstep1 = cadence.tstep_range_at_time(110., inclusive=False)
-    self.assertEqual(tstep0, tstep1)    # indicates zero range
-
-    tstep0, tstep1 = cadence.tstep_range_at_time(135.)
-    self.assertEqual(tstep0, tstep1)
-
-    # time_range_at_tstep()
-    tstep = Scalar((-1,0,0.5,1,2))
-    self.assertEqual(cadence.time_range_at_tstep(tstep)[0], 5*[100])
-    self.assertEqual(cadence.time_range_at_tstep(tstep)[1], 5*[110])
-
-    self.assertEqual(cadence.time_range_at_tstep(tstep[0], remask=True), MASKED_TUPLE)
-    self.assertEqual(cadence.time_range_at_tstep(tstep[1:4], remask=True)[0], 3*[100])
-    self.assertEqual(cadence.time_range_at_tstep(tstep[1:4], remask=True)[1], 3*[110])
-    self.assertEqual(cadence.time_range_at_tstep(tstep[4], remask=True), MASKED_TUPLE)
-
-    self.assertEqual(cadence.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[0], 2*[100])
-    self.assertEqual(cadence.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[1], 2*[110])
-
-    self.assertEqual(cadence.time_range_at_tstep(tstep[3], remask=True, inclusive=False), MASKED_TUPLE)
-
-    # tstride_at_tstep
-    self.assertEqual(cadence.tstride_at_tstep(0), 10)
-    self.assertEqual(cadence.tstride_at_tstep(0.5), 10)
-    self.assertEqual(cadence.tstride_at_tstep(1), 10)
+        # Try all at once
+        uvt = obs.uvt(uv_list, remask=True)
+        self.assertEqual(uvt[0], [a[0] for a in uvt_list])
+        self.assertEqual(uvt[1], [a[1] for a in uvt_list])
+
+        ########################################################################
+        # Old Slit unit tests
+        ########################################################################
+
+        Slit = TimedImage
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        obs = Slit(axes=('u','vt'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, cadence.time_at_tstep(tstep))
+        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv.to_scalar(1), 0.5)
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], cadence.tstride * indices.to_scalar(1)[:6])
+        self.assertEqual(uv[:6].to_scalar(0), indices[:6].to_scalar(0))
+        self.assertEqual(uv[:6].to_scalar(1), 0.5)
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min.to_scalar(0), indices_.to_scalar(0))
+        self.assertEqual(uv_min.to_scalar(1), 0)
+        self.assertEqual(uv_max.to_scalar(0), indices_.to_scalar(0) + 1)
+        self.assertEqual(uv_max.to_scalar(1), 1)
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices,
+                                                             remask=True)
+
+        self.assertTrue(np.all(uv_min.mask == np.array(6*[False] + [True])))
+        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
+        self.assertTrue(np.all(time_min.mask == uv_min.mask))
+        self.assertTrue(np.all(time_max.mask == uv_min.mask))
+
+        self.assertEqual(uv_min.to_scalar(0)[:6], indices_.to_scalar(0)[:6])
+        self.assertEqual(uv_min.to_scalar(1)[:6], 0)
+        self.assertEqual(uv_max.to_scalar(0)[:6], indices_.to_scalar(0)[:6] + 1)
+        self.assertEqual(uv_max.to_scalar(1)[:6], 1)
+        self.assertEqual(time_min[:6], cadence.tstride * indices_.to_scalar(1)[:6])
+        self.assertEqual(time_max[:6], time_min[:6] + cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+        uv_ = uv.copy()
+        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
+        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
+
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, time0 + cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+
+        self.assertTrue(np.all(time0.mask == 6*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == time0.mask))
+        self.assertEqual(time0[:6], cadence.time_range_at_tstep(tstep)[0][:6])
+        self.assertEqual(time1[:6], time0[:6] + cadence.texp)
+
+        ####################################
+
+        # Alternative axis order ('ut','v')
+
+        fov = FlatFOV((0.001,0.001), (1,20))
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
+        obs = Slit(axes=('ut','v'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        (uv,time) = obs.uvt(indices)
+
+        self.assertEqual(uv.to_scalar(0), 0.5)
+        self.assertEqual(uv.to_scalar(1), indices.to_scalar(1))
+        self.assertEqual(time, cadence.tstride * indices.to_scalar(0))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min.to_scalar(0), 0)
+        self.assertEqual(uv_min.to_scalar(1), indices_.to_scalar(1))
+        self.assertEqual(uv_max.to_scalar(0), 1)
+        self.assertEqual(uv_max.to_scalar(1), indices_.to_scalar(1) + 1)
+        self.assertEqual(time_min, cadence.tstride * indices_.to_scalar(0))
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        ####################################
+
+        # Alternative texp for discontinuous indices
+
+        fov = FlatFOV((0.001,0.001), (1,20))
+        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
+        obs = Slit(axes=('ut','v'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 98.)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1], 50.)
+        self.assertEqual(obs.uvt((5,5))[1], 50.)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6      ,0))[1] - 60.) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 62.) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 64.) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 66.) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 68.) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 70.) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (0.5,5.))
+
+        self.assertTrue(abs(obs.uvt((6      ,0))[0] - (0.5,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (0.5,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (0.5,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (0.5,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (0.5,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,5))[0] - (0.5,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (0.5,6.)) < delta)
+
+        # Test using scalar indices
+        below = obs.uvt((0,20 - eps), remask=True)[0].to_scalar(1)
+        exact = obs.uvt((0,20      ), remask=True)[0].to_scalar(1)
+        above = obs.uvt((0,20 + eps), remask=True)[0].to_scalar(1)
+
+        self.assertTrue(below < 20.)
+        self.assertTrue(20. - below < delta)
+        self.assertTrue(exact == 20.)
+        self.assertTrue(above == Scalar.MASKED)
+        self.assertTrue(above.mask)
+
+        # Test using a Vector index
+        indices = Vector([(0,20 - eps), (0,20), (0,20 + eps)])
+
+        u = obs.uvt(indices, remask=True)[0].to_scalar(1)
+        self.assertTrue(u == (below, exact, above))
+
+        # Alternative texp and axes
+        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
+        obs = Slit(axes=('a','v','b','ut','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 98.)
+
+        self.assertEqual(obs.uvt((1,0,3,0,4))[1],  0.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1], 50.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1], 50.)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 60.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 62.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 64.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 66.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 68.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 70.) < delta)
+
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (0.5,5.))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6      ,7))[0] - (0.5,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2    ,7))[0] - (0.5,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4    ,7))[0] - (0.5,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6    ,7))[0] - (0.5,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8    ,7))[0] - (0.5,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,5,4,7 - eps,7))[0] - (0.5,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.     ,7))[0] - (0.5,6.)) < delta)
+
+        ########################################################################
+        # Old RasterSlit unit tests
+        ########################################################################
+
+        RasterSlit = TimedImage
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=1., steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                         path='SSB', frame='J2000')
+
+        indices = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, [0, 100, 190, 10, 110, 200, 200])
+        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv.to_scalar(1), 0.5)
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], [0, 100, 190, 10, 110, 200])
+        self.assertEqual(uv[:6].to_scalar(0), indices[:6].to_scalar(0))
+        self.assertEqual(uv[:6].to_scalar(1), 0.5)
+
+        # uvt() with remask == True, new indices
+        non_ints = indices + (0.2, 0.9)
+        (uv, time) = obs.uvt(non_ints, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(2*[False] + 5*[True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv_min.to_scalar(1), 0)
+        self.assertEqual(uv_max.to_scalar(0), indices.to_scalar(0) + 1)
+        self.assertEqual(uv_max.to_scalar(1), 1)
+        self.assertEqual(time_min, [0, 100, 190,  9, 109, 199, 199])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints,
+                                                             remask=True)
+
+        self.assertEqual(Boolean(uv_min.mask), 2*[False] + 5*[True])
+        self.assertEqual(Boolean(uv_max.mask), uv_min.mask)
+        self.assertEqual(Boolean(time_min.mask), uv_min.mask)
+        self.assertEqual(Boolean(time_max.mask), uv_min.mask)
+
+        self.assertEqual(uv_min.to_scalar(0)[:2], indices.to_scalar(0)[:2])
+        self.assertEqual(uv_min.to_scalar(1)[:2], 0)
+        self.assertEqual(uv_max.to_scalar(0)[:2], indices.to_scalar(0)[:2] + 1)
+        self.assertEqual(uv_max.to_scalar(1)[:2], 1)
+        self.assertEqual(time_min[:2],
+                         (slow_cadence.tstride * indices.to_scalar(1) +
+                          fast_cadence.tstride * indices.to_scalar(0))[:2])
+        self.assertEqual(time_max[:2], time_min[:2] + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+
+        self.assertEqual(time0, [0, 190, 9, 199, 199])
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], [0, 190, 9, 199])
+        self.assertEqual(time1[:4], time0[:4] + fast_cadence.texp)
+
+        ####################################
+        # Alternative axis order ('uslow','vfast')
+        ####################################
+
+        fov = FlatFOV((0.001,0.001), (1,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
+        fast_cadence = Metronome(tstart=0., tstride=0.5, texp=0.5, steps=20)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterSlit(axes=('uslow','vfast'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        indices = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        (uv, time) = obs.uvt(indices)
+
+        self.assertEqual(uv.to_scalar(0), 0.5)
+        self.assertEqual(uv.to_scalar(1), indices.to_scalar(1))
+        self.assertEqual(time, [0, 5, 10, 90, 95, 100, 100])
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min.to_scalar(0), 0)
+        self.assertEqual(uv_min.to_scalar(1), indices_.to_scalar(1))
+        self.assertEqual(uv_max.to_scalar(0), 1)
+        self.assertEqual(uv_max.to_scalar(1), indices_.to_scalar(1) + 1)
+        self.assertEqual(time_min, [0, 5, 9.5, 90, 95, 99.5, 99.5])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        (time0, time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, time_min)
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        ################################################
+        # Alternative texp for discontinuous indices
+        ################################################
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=8., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.5, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.5)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 55.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 55.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 55.25)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6.     ,0))[1] - 6.000) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.125) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.250) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.375) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.500) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.000) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.5))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.5))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,0.5))
+
+        self.assertTrue(abs(obs.uvt((6.     ,0))[0] - (6.0,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,0.5)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ))[0] - (1.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((2, 1.25   ))[0] - (2.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((3, 2.5    ))[0] - (3.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((4, 3.75   ))[0] - (4.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5 - eps))[0] - (5.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5.     ))[0] - (5.,0.5)) < delta)
+
+        ################################################
+        # Alternative tstride for even more discontinuous indices
+        ################################################
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        slow_cadence = Metronome(tstart=0., tstride=11., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 218.8)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 60.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 60.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 60.4)
+        self.assertEqual(obs.uvt((5.5, 5.5))[1], 60.4)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6      ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.0) < delta)
+
+        self.assertTrue(abs(obs.uvt((9       ,0))[1] -  9. ) < delta)
+        self.assertTrue(abs(obs.uvt((9.25    ,0))[1] -  9.2) < delta)
+        self.assertTrue(abs(obs.uvt((9.5     ,0))[1] -  9.4) < delta)
+        self.assertTrue(abs(obs.uvt((9.75    ,0))[1] -  9.6) < delta)
+        self.assertTrue(abs(obs.uvt((10 - eps,0))[1] -  9.8) < delta)
+        self.assertTrue(abs(obs.uvt((0.      ,1))[1] - 11. ) < delta)
+
+        self.assertTrue(abs(obs.uvt((6.00, 0.   ))[1] -  6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 0.   ))[1] -  6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 1.   ))[1] - 17.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 2-eps))[1] - 17.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 2    ))[1] - 28.2) < delta)
+
+        # Test the upper edge
+        pair = (10-eps, 0)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 0)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10+eps, 0)
+        self.assertTrue(obs.uvt(pair, True)[0].mask)
+
+        pair = (10-eps, 1-eps)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 1)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 20.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 20)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 218.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 20+eps)
+        self.assertTrue(obs.uvt(pair, True)[0].mask)
+
+        ################################################
+        # Alternative, discontinuous and weird axes
+        ################################################
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterSlit(axes=('a','vslow','b','ufast','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.8)
+
+        self.assertEqual(obs.uvt((1,0,3,0,4))[1],   0.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1],   5.)
+        self.assertEqual(obs.uvt((1,0,3,5.5,4))[1], 5.4)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 7.0) < delta)
+
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.,0.5))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (5.,0.5))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (5.,0.5))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6      ,7))[0] - (6.0,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2    ,7))[0] - (6.2,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4    ,7))[0] - (6.4,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6    ,7))[0] - (6.6,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8    ,7))[0] - (6.8,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.     ,7))[0] - (7.0,0.5)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ,4,1,7))[0] - (1.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 1.25   ,4,2,7))[0] - (2.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 2.5    ,4,3,7))[0] - (3.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 3.75   ,4,4,7))[0] - (4.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5 - eps,4,5,7))[0] - (5.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5.     ,4,5,7))[0] - (5.,0.5)) < delta)
+
+        ########################################################################
+        # Old Pushframe unit tests
+        ########################################################################
+
+        Pushframe = TimedImage
+
+        flatfov = FlatFOV((0.001,0.001), (10,20))
+        cadence = TDICadence(lines=20, tstart=100., tdi_texp=10., tdi_stages=2,
+                             tdi_sign=-1)
+        obs = Pushframe(axes=('u','vt'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
+
+        indices = Vector([( 0,0),( 0,1),( 0,10),( 0,18),( 0,19),( 0,20),( 0,21),
+                          (10,0),(10,1),(10,10),(10,18),(10,19),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
+
+        # uvt() with remask == False
+        (uv,time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, 2*[100,100,100,100,110,120,120])
+
+        # uvt() with remask == True
+        (uv,time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(2*(6*[False]+[True]))))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time, cadence.time_at_tstep(tstep, remask=True))
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min,
+                         [(0,0),(0,1),(0,10),(0,18),(0,19),(0,19),(0,21),
+                          (9,0),(9,1),(9,10),(9,18),(9,19),(9,19),(9,21)])
+        self.assertEqual(uv_max, uv_min + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
+
+        # uvt_range() with remask == False, new indices
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9))
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
+
+        # uvt_range() with remask == True, new indices
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9),
+                                                             remask=True)
+
+        self.assertTrue(np.all(uv_min.mask == np.array(5*[False] + 9*[True])))
+        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
+        self.assertTrue(np.all(time_min.mask == uv_min.mask))
+        self.assertTrue(np.all(time_max.mask == uv_min.mask))
+
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
+        self.assertEqual(time_max[:2], cadence.time_range_at_tstep(tstep)[1][:2])
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+        tstep = uv.to_scalar(1)
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], cadence.time_range_at_tstep(tstep)[0][:4])
+        self.assertEqual(time1[:4], cadence.time_range_at_tstep(tstep)[1][:4])
+
+        # Alternative axis order ('ut','v')
+        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
+                             tdi_sign=-1)
+        obs = Pushframe(axes=('ut','v'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
+
+        indices = Vector([(-1,0),(0,-1),(0,0),(0,20),(9,0),(10,0),(11,0),(11,20)])
+        tstep = indices.to_scalar(0)
+
+        (uv,time) = obs.uvt(indices)
+
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, cadence.time_at_tstep(tstep))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min,
+                         [(-1,0),(0,-1),(0,0),(0,19),(9,0),(9,0),(11,0),(11,19)])
+        self.assertEqual(uv_max, uv_min + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
+
+        (time0,time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
+
+        # Alternative texp for discontinuous indices
+        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
+                                       tdi_sign=1)
+        obs = Pushframe(axes=('ut','v'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[0], 100.)
+
+        self.assertEqual(obs.uvt((-1,0))[0], (-1,0))
+        self.assertEqual(obs.uvt(( 0,0))[0], ( 0,0))
+        self.assertEqual(obs.uvt(( 5,0))[0], ( 5,0))
+        self.assertEqual(obs.uvt(( 5,5))[0], ( 5,5))
+        self.assertEqual(obs.uvt(( 9,5))[0], ( 9,5))
+        self.assertEqual(obs.uvt((9.5,5))[0],(9.5,5))
+        self.assertEqual(obs.uvt((10,5))[0], (10,5))
+
+        self.assertEqual(obs.uvt((-1,0))[1], 190.)
+        self.assertEqual(obs.uvt(( 0,0))[1], 190.)
+        self.assertEqual(obs.uvt(( 5,0))[1], 140.)
+        self.assertEqual(obs.uvt(( 5,5))[1], 140.)
+        self.assertEqual(obs.uvt(( 9,5))[1], 100.)
+        self.assertEqual(obs.uvt((9.5,5))[1],150.)
+        self.assertEqual(obs.uvt((10,5))[1], 200.)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/reshapedcadence.py` & `rms_oops-0.0.4/ideas/deprecated/rasterscan.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,709 +1,630 @@
 ################################################################################
-# oops/cadence/reshapedcadence.py: ReshapedCadence subclass of class Cadence
+# oops/observation/rasterscan.py: Subclass RasterScan of class Observation
 ################################################################################
 
 import numpy as np
-from polymath     import Qube, Scalar, Pair, Vector
-from oops.cadence import Cadence
+from polymath import Boolean, Pair, Vector
 
-class ReshapedCadence(Cadence):
-    """A Cadence that has been reshaped.
-
-    The time steps are defined by another cadence with a different shape.
-    This can be used, for example, to convert a 1-D cadence into an N-D cadence.
+from oops.observation          import Observation
+from oops.observation.snapshot import Snapshot
+from oops.cadence              import Cadence
+from oops.cadence.dualcadence  import DualCadence
+from oops.frame                import Frame
+from oops.path                 import Path
+
+from oops.observation.timedimage import TimedImage
+
+class RasterScan(TimedImage):
+    """A subclass of Observation consisting of a 2-D image generated by sweeping
+    a single sensor within a 2-D field of view.
+
+    The FOV object defines the entire field of view, although each pixel is
+    sampled at a different time step. The sampling time of each pixel is defined
+    by a 2-D cadence.
     """
 
-    #===========================================================================
-    def __init__(self, cadence, shape):
-        """Constructor for a ReshapedCadence.
-
-        Input:
-            cadence     the cadence to re-shape.
-            shape       a tuple defining the new shape of the cadence.
-        """
-
-        self.cadence = cadence
-        self.shape = tuple(shape)
-        self._rank = len(self.shape)
-        self._size = int(np.prod(self.shape))
-
-        if self._size != np.prod(self.cadence.shape):
-            raise ValueError('ReshapedCadence size and shape are incompatible')
-
-        if self._rank > 2:
-            raise ValueError('%d-D cadences are not supported' % self._rank)
-
-        self.time = self.cadence.time
-        self.midtime = self.cadence.midtime
-        self.lasttime = self.cadence.lasttime
-        self.is_continuous = self.cadence.is_continuous
-        self.is_unique = self.cadence.is_unique
-        self.min_tstride = self.cadence.min_tstride
-        self.max_tstride = self.cadence.max_tstride
-
-        self._stride = np.cumprod((self.shape + (1,))[::-1])[-2::-1]
-                                                        # trust me, it works!
-
-        self._old_shape = self.cadence.shape
-        self._old_rank = len(self.cadence.shape)
-        self._old_stride = np.cumprod((self._old_shape + (1,))[::-1])[-2::-1]
-
-    def __getstate__(self):
-        return (self.cadence, self.shape)
-
-    def __setstate__(self, state):
-        self.__init__(*state)
-
-    #===========================================================================
-    @staticmethod
-    def _reshape_tstep(tstep, old_shape, old_stride, old_rank,
-                              new_shape, new_stride, new_rank, size,
-                              remask=False, derivs=False, inclusive=True):
-        """Translate a cadence index from old shape to new."""
-
-        # Convert old tstep to integer offset + fraction; remask for now
-        if old_rank == 1:
-            tstep = Scalar.as_scalar(tstep, recursive=derivs)
-            index_1d = tstep.int(old_shape[0], remask=True,
-                                 inclusive=inclusive, clip=True)
-            remainder = tstep - index_1d
-            frac = remainder.clip(0, 1, remask=True)
-            index_1d = index_1d.vals
-        else:
-            tstep = Vector.as_vector(tstep, recursive=derivs)
-            tstep_int = tstep.int(old_shape, remask=True, inclusive=inclusive,
-                                             clip=True)
-            remainder = (tstep - tstep_int).to_scalar(-1)
-            frac = remainder.clip(0, 1, remask=True)
-            index_1d = np.sum(old_stride * tstep_int.vals, axis=-1)
-
-        # If the conversion is to a cadence of rank one, we're done
-        if new_rank == 1:
-            result = index_1d + frac
-            if not remask:
-                result = result.remask(tstep.mask)
-
-            return result
-
-        # Convert the offset to an integer index using the new stride
-        # Trust me, this works
-        new_offset = np.reshape(index_1d, np.shape(index_1d) + (1,))
-        indices = (new_offset // new_stride) % new_shape
-
-        # Convert to float if necessary
-        if tstep.is_float():
-            indices = np.asfarray(indices)
-
-        # Restore fractional part
-        indices[...,-1] += frac.vals
-
-        # Select the new mask
-        if remask:
-            mask = frac.mask
-        else:
-            mask = tstep.mask
-
-        # Convert indices to the proper class
-        if new_rank == 2:
-            class_ = Pair
-        else:                   # not currently supported
-            class_ = Vector
-
-        new_tstep = class_(indices, mask)
-
-        # Restore derivatives if necessary
-        if derivs:
-            for key, deriv in tstep.derivs.items():
-                # Construct the new derivative
-
-                # When a derivative has a numerator, the derivatives are always
-                # required/expected to be zero along every axis except the last.
-
-                shape = new_tstep.shape + new_tstep.numer + deriv.denom
-                new_deriv_vals = np.zeros(shape)
-
-                new_index = ((Ellipsis,) + (new_tstep.nrank-1) * (slice(None),)
-                             + ((-1,) if new_tstep.nrank else ())
-                             + deriv.drank * (slice(None),))
-
-                old_index = ((Ellipsis,) + (deriv.nrank-1) * (slice(None),)
-                             + ((-1,) if deriv.nrank else ())
-                             + deriv.drank * (slice(None),))
-
-                new_deriv_vals[new_index] = deriv.vals[old_index]
-                    # Note that the above works if new_deriv_vals has no shape,
-                    # because indx is an Ellipsis, which is a valid index, and
-                    # because the constructor converts a shapeless array value
-                    # to a scalar.
-
-                # Prepare the new mask
-                if isinstance(deriv.mask, (bool, np.bool_)):
-                    new_deriv_mask = mask
-                elif deriv.mask is tstep.mask:  # it's common for derivs
-                                                # to share the parent's mask
-                    new_deriv_mask = mask
-                else:
-                    new_deriv_mask = deriv.mask.reshape(new_tstep.shape)
-                    new_deriv_mask = Qube.or_(mask, new_deriv_mask)
-
-                # Construct and insert the new derivative
-                new_deriv = class_(new_deriv_vals, new_deriv_mask,
-                                   nrank=new_tstep.nrank, drank=deriv.drank)
-                new_tstep.insert_deriv(key, new_deriv)
-
-        return new_tstep
-
-    #===========================================================================
-    def _old_tstep_from_new(self, tstep, remask=False, derivs=False,
-                                         inclusive=True):
-        """Convert a tstep index for the old cadence to the new."""
-
-        return ReshapedCadence._reshape_tstep(
-                            tstep,
-                            self.shape, self._stride, self._rank,
-                            self._old_shape, self._old_stride, self._old_rank,
-                            self._size,
-                            remask=remask, derivs=derivs, inclusive=inclusive)
-
-    #===========================================================================
-    def _new_tstep_from_old(self, tstep, remask=False, derivs=False,
-                                         inclusive=True):
-        """Convert a tstep index for the new cadence to the old."""
-
-        return ReshapedCadence._reshape_tstep(
-                            tstep,
-                            self._old_shape, self._old_stride, self._old_rank,
-                            self.shape, self._stride, self._rank, self._size,
-                            remask=remask, derivs=derivs, inclusive=inclusive)
-
-    #===========================================================================
-    def time_at_tstep(self, tstep, remask=False, derivs=False, inclusive=True):
-        """The time associated with the given time step.
-
-        This method supports non-integer time step values.
-
-        In multidimensional cadences, indexing beyond the dimensions of the
-        cadence returns the time at the nearest edge of the cadence's shape.
-
-        Input:
-            tstep       a Scalar or Pair of time step index values.
-            remask      True to mask values outside the time limits.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar of times in seconds TDB.
-        """
-
-        tstep = self._old_tstep_from_new(tstep, remask=remask, derivs=derivs,
-                                                inclusive=inclusive)
-
-        return self.cadence.time_at_tstep(tstep, remask=remask, derivs=derivs,
-                                                 inclusive=inclusive)
-
-    #===========================================================================
-    def time_range_at_tstep(self, tstep, remask=False, inclusive=True):
-        """The range of times for the given time step.
-
-        Input:
-            tstep       a Pair of time step index values.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (time_min, time_max)
-            time_min    a Scalar defining the minimum time associated with the
-                        index. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
-        """
-
-        tstep = self._old_tstep_from_new(tstep, derivs=False, remask=remask,
-                                                inclusive=inclusive)
-
-        return self.cadence.time_range_at_tstep(tstep, remask=remask,
-                                                       inclusive=inclusive)
-
-    #===========================================================================
-    def tstep_at_time(self, time, remask=False, derivs=False, inclusive=True):
-        """Time step for the given time.
-
-        This method returns non-integer time steps.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            derivs      True to include derivatives of time in the returned
-                        tstep.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar or Pair of time step index values.
-        """
-
-        time = Scalar.as_scalar(time, recursive=derivs)
-
-        # Converting to 1-D or continuous cadences, this is fairly easy...
-        if self._rank == 1 or self.is_continuous:
-            tstep = self.cadence.tstep_at_time(time, remask=remask,
-                                               derivs=derivs,
-                                               inclusive=inclusive)
-            tstep = self._new_tstep_from_old(tstep, remask=remask,
-                                             derivs=derivs,
-                                             inclusive=inclusive)
-
-        # Otherwise...
-        else:
-
-            # Remove the time mask and remask, so tstep is masked if and only if
-            # a time is out of range, including in a gap between discontinuous
-            # time steps.
-            tstep = self.cadence.tstep_at_time(time.without_mask(), remask=True,
-                                               derivs=derivs,
-                                               inclusive=inclusive)
-            tstep = self._new_tstep_from_old(tstep, remask=True, derivs=derivs,
-                                             inclusive=inclusive)
-
-            # For masked tsteps that have wrapped forward to the next line,
-            # shift them back to the end of the previous line.
-
-            # Note--this only works correctly for 2-D
-            wrapped = (tstep.mask & (tstep.vals[...,-1] == 0)
-                                  & (tstep.vals[...,-2] >  0))
-            if np.shape(wrapped):
-                tstep.vals[wrapped,-2] -= 1
-                tstep.vals[wrapped,-1] = self.shape[-1]
-            elif wrapped:
-                tstep.vals[-2] -= 1
-                tstep.vals[-1] = self.shape[-1]
-
-            # Now repair the mask
-            if remask:
-                tstep = tstep.remask_or(time.mask)
-            else:
-                tstep = tstep.remask(time.mask)
-
-        # Times beyond the end of a 2-D cadence require special handling
-        if self._rank > 1:
-            above = Qube.is_above(time, self.time[1], inclusive=inclusive)
-            tstep[above] = type(tstep)(self.shape, remask)
-
-        return tstep
-
-    #===========================================================================
-    def tstep_range_at_time(self, time, remask=False, inclusive=True):
-        """Integer range of time steps active at the given time.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (tstep_min, tstep_max)
-            tstep_min   minimum Scalar or Pair time step index for time range.
-            tstep_max   maximum Scalar or Pair time step index for time range.
-
-        All returned indices will be in the allowed range for the cadence,
-        inclusive, regardless of mask. If the time is not inside the cadence,
-        tstep_max < tstep_min.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-
-        # Mask here; update the mask later if necessary
-        (old_tstep_min,
-         old_tstep_max) = self.cadence.tstep_range_at_time(time, remask=True,
-                                                           inclusive=inclusive)
-
-        if self.shape == self._old_shape:
-            return (old_tstep_min, old_tstep_max)
-
-        # Calculate the number of tsteps in each old range
-        if self._old_rank == 1:
-            count = old_tstep_max.vals - old_tstep_min.vals
-        else:
-            diffs = old_tstep_max.vals - old_tstep_min.vals - 1
-            count = np.sum(self._old_stride * diffs, axis=-1) + 1
-
-        # Get the new minimum tstep
-        new_tstep_min = self._new_tstep_from_old(old_tstep_min, remask=False,
-                                                 derivs=False, inclusive=True)
-
-        # Calculate the tstep offset for each new range
-        if self._rank == 1:
-            new_tstep_max = new_tstep_min + count
-
-        else:
-            index_1d = (np.sum(self._stride * new_tstep_min.vals, axis=-1)
-                        + np.maximum(count-1, 0))
-            max_vals = (index_1d[...,np.newaxis] // self._stride) % self.shape
-            max_vals += 1
-
-            # Handle count == 0, where last axis of range must have size 0
-            mask = (count == 0)
-            if np.shape(mask):
-                max_vals[mask,-1] = new_tstep_min.vals[mask,-1]
-            elif mask:
-                max_vals[-1] = new_tstep_min.vals[-1]
-
-            new_tstep_max = new_tstep_min.clone()
-            new_tstep_max._set_values_(max_vals)
-
-            # Make sure that the new tstep range will be continuous
-            if not self.is_unique and self._rank > 1:
-                multiple_rows = np.any((new_tstep_min.vals[...,:-1] !=
-                                        new_tstep_max.vals[...,:-1] - 1))
-                incomplete_lines = ((new_tstep_min.vals[...,-1] != 0) |
-                                 (new_tstep_max.vals[...,-1] != self.shape[-1]))
-                unmasked = new_tstep_min.antimask
-                problems = multiple_rows & incomplete_lines & unmasked
-                if np.any(problems):
-                    if np.isscalar(problems):
-                        timeval = time.vals
-                        minval = new_tstep_min
-                        maxval = new_tstep_max
-                    else:
-                        timeval = time[problems][0]
-                        minval = new_tstep_min[problems][0]
-                        maxval = new_tstep_max[problems][0]
-
-                    raise ValueError('returned tstep range is discontinuous ' +
-                                     'at %s: %s, %s' % (timeval, minval,
-                                                                 maxval))
-
-        # Make sure that the old tstep range was continuous
-        if not self.is_unique and self._old_rank > 1:
-            multiple_rows = np.any(old_tstep_min.vals[...,:-1] !=
-                                   old_tstep_max.vals[...,:-1] - 1)
-            incomplete_lines = ((old_tstep_min.vals[...,-1] != 0) |
-                                (old_tstep_max.vals[...,-1] != self.shape[-1]))
-            unmasked = old_tstep_min.antimask
-            problems = multiple_rows & incomplete_lines & unmasked
-            if np.any(problems):
-                if np.isscalar(problems):
-                    timeval = time.vals
-                    minval = new_tstep_min
-                    maxval = new_tstep_max
-                else:
-                    timeval = time[problems][0]
-                    minval = old_tstep_min[problems][0]
-                    maxval = old_tstep_max[problems][0]
-
-                raise ValueError('input tstep range is discontinuous at ' +
-                                 '%s: %s, %s' % (timeval, minval, maxval))
-
-        # Restore the original mask if necessary
-        if not remask:
-            new_tstep_min = new_tstep_min.remask(time.mask)
-            new_tstep_max = new_tstep_max.remask(time.mask)
-
-        return (new_tstep_min, new_tstep_max)
-
-    #===========================================================================
-    def time_is_outside(self, time, inclusive=True):
-        """A Boolean mask of times that fall outside the cadence.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Boolean mask indicating which time values are not
-                        sampled by the cadence.
-        """
-
-        return self.cadence.time_is_outside(time, inclusive=inclusive)
-
-    #===========================================================================
-    def time_shift(self, secs):
-        """Construct a duplicate of this Cadence with all times shifted by given
-        amount.
-
-        Input:
-            secs        the number of seconds to shift the time later.
-        """
-
-        return ReshapedCadence(self.cadence.time_shift(secs), self.shape)
-
-    #===========================================================================
-    def as_continuous(self):
-        """A shallow copy of this cadence, forced to be continuous.
-
-        For Sequence this is accomplished by forcing the exposure times to
-        be equal to the stride for each step.
-        """
+    pass
 
-        return ReshapedCadence(self.cadence.as_continuous(), self.shape)
+#     INVENTORY_IMPLEMENTED = True
+#
+#     # Relates these axes to Snapshot axes
+#     AXIS_REPLACEMENTS = {
+#         'ufast':  'u',
+#         'uslow':  'u',
+#         'vfast':  'v',
+#         'vslow':  'v',
+#     }
+#
+#     #===========================================================================
+#     def __init__(self, axes, cadence, fov, path, frame, **subfields):
+#         """Constructor for a RasterScan observation.
+#
+#         Input:
+#             axes        a list or tuple of strings, with one value for each axis
+#                         in the associated data array. A value of 'ufast' or
+#                         'uslow' should appear at the location of the array's
+#                         u-axis; 'vslow' or 'vfast' should appear at the location
+#                         of the array's v-axis. The 'fast' suffix identifies
+#                         which of these is in the fast-scan direction; the 'slow'
+#                         suffix identifies the slow-scan direction.
+#
+#             cadence     a 2-D Cadence object defining the start time and
+#                         duration of each sample. Alternatively, a tuple or
+#                         dictionary providing input arguments to the function
+#                         DualCadence.for_array2d() (excluding the numbers of
+#                         samples and lines, which are defined by the FOV):
+#                           (tstart, texp, [intersample_delay[, interline_delay]])
+#
+#             fov         a FOV (field-of-view) object, which describes the field
+#                         of view including any spatial distortion. It maps
+#                         between spatial coordinates (u,v) and instrument
+#                         coordinates (x,y).
+#
+#             path        the path waypoint co-located with the instrument.
+#
+#             frame       the wayframe of a coordinate frame fixed to the optics
+#                         of the instrument. This frame should have its Z-axis
+#                         pointing outward near the center of the line of sight,
+#                         with the X-axis pointing rightward and the y-axis
+#                         pointing downward.
+#
+#             subfields   a dictionary containing all of the optional attributes.
+#                         Additional subfields may be included as needed.
+#         """
+#
+#         # Basic properties
+#         self.path = Path.as_waypoint(path)
+#         self.frame = Frame.as_wayframe(frame)
+#
+#         # FOV
+#         self.fov = fov
+#         self.uv_shape = tuple(self.fov.uv_shape.vals)
+#
+#         # Axes
+#         self.axes = list(axes)
+#         assert (('ufast' in self.axes and 'vslow' in self.axes) or
+#                 ('vfast' in self.axes and 'uslow' in self.axes))
+#
+#         if 'ufast' in self.axes:
+#             self.u_axis = self.axes.index('ufast')
+#             self.v_axis = self.axes.index('vslow')
+#             self._fast_axis = self.u_axis
+#             self._slow_axis = self.v_axis
+#             self._fast_uv_axis = 0
+#             self._slow_uv_axis = 1
+#         else:
+#             self.u_axis = self.axes.index('uslow')
+#             self.v_axis = self.axes.index('vfast')
+#             self._fast_axis = self.v_axis
+#             self._slow_axis = self.u_axis
+#             self._fast_uv_axis = 1
+#             self._slow_uv_axis = 0
+#
+#         self.swap_uv = (self.u_axis > self.v_axis)
+#
+#         self.t_axis = (self._slow_axis, self._fast_axis)
+#
+#         # Shape / Size
+#         self.shape = len(axes) * [0]
+#         self.shape[self.u_axis] = self.uv_shape[0]
+#         self.shape[self.v_axis] = self.uv_shape[1]
+#
+#         # Cadence
+#         samples = self.uv_shape[self._fast_uv_axis]
+#         lines   = self.uv_shape[self._slow_uv_axis]
+#
+#         if isinstance(cadence, (tuple,list)):
+#             self.cadence = DualCadence.for_array2d(samples, lines, *cadence)
+#         elif isinstance(cadence, dict):
+#             self.cadence = DualCadence.for_array2d(samples, lines, **cadence)
+#         elif isinstance(cadence, Cadence):
+#             self.cadence = cadence
+#             assert self.cadence.shape == (lines, samples)
+#         else:
+#             raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
+#
+#         # Timing
+#         self.time = self.cadence.time
+#         self.midtime = self.cadence.midtime
+#
+#         # Optional subfields
+#         self.subfields = {}
+#         for key in subfields.keys():
+#             self.insert_subfield(key, subfields[key])
+#
+#         # Snapshot class proxy (for inventory)
+#         snapshot_axes = [RasterScan.AXIS_REPLACEMENTS.get(axis, axis)
+#                          for axis in axes]
+#         snapshot_tstart = self.cadence.time[0]
+#         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
+#
+#         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
+#                                  self.fov, self.path, self.frame, **subfields)
+#
+#     def __getstate__(self):
+#         return (self.axes, self.cadence, self.fov, self.path, self.frame,
+#                 self.subfields)
+#
+#     def __setstate__(self, state):
+#         self.__init__(*state[:-1], **state[-1])
+#
+#     #===========================================================================
+#     def uvt(self, indices, remask=False, derivs=True):
+#         """Coordinates (u,v) and time t for indices into the data array.
+#
+#         This method supports non-integer index values.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#             derivs      True to include derivatives in the returned values.
+#
+#         Return:         (uv, time)
+#             uv          a Pair defining the values of (u,v) within the FOV that
+#                         are associated with the array indices.
+#             time        a Scalar defining the time in seconds TDB associated
+#                         with the array indices.
+#         """
+#
+#         indices = Vector.as_vector(indices, recursive=derivs)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#
+#         # Create the time Scalar
+#         tstep = indices.to_pair(self.t_axis)
+#         time = self.cadence.time_at_tstep(tstep, remask=remask)
+#
+#         # Handle masking
+#         if remask:
+#             uv = uv.remask_or(self.fov.uv_is_outside(uv).vals)
+#             time = time.remask(uv.mask)
+#
+#         return (uv, time)
+#
+#     #===========================================================================
+#     def uvt_range(self, indices, remask=False):
+#         """Ranges of (u,v) spatial coordinates and time for integer array
+#         indices.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         (uv_min, uv_max, time_min, time_max)
+#             uv_min      a Pair defining the minimum values of FOV (u,v)
+#                         associated the pixel.
+#             uv_max      a Pair defining the maximum values of FOV (u,v)
+#                         associated the pixel.
+#             time_min    a Scalar defining the minimum time associated with the
+#                         array indices. It is given in seconds TDB.
+#             time_max    a Scalar defining the maximum time value.
+#         """
+#
+#         indices = Vector.as_vector(indices, recursive=False)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#         uv_min = uv.int(self.uv_shape, remask=remask)
+#
+#         tstep = indices.to_pair(self.t_axis)
+#         (time_min,
+#          time_max) = self.cadence.time_range_at_tstep(tstep, remask=remask)
+#
+#         if remask:
+#             time_min = time_min.remask_or(uv_min.mask)
+#             time_max = time_max.remask(time_min.mask)
+#
+#         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
+#
+#     #===========================================================================
+#     def time_range_at_uv(self, uv_pair, remask=False):
+#         """The start and stop times of the specified spatial pixel (u,v).
+#
+#         Input:
+#             uv_pair     a Pair of spatial (u,v) data array coordinates,
+#                         truncated to integers if necessary.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         a tuple containing Scalars of the start time and stop
+#                         time of each (u,v) pair, as seconds TDB.
+#         """
+#
+#         uv_pair = Pair.as_pair(uv_pair)
+#         uv_pair_int = uv_pair.int(top=self.uv_shape, remask=remask)
+#
+#         tstep = uv_pair.to_pair((self._slow_uv_axis, self._fast_uv_axis))
+#
+#         if self._slow_uv_axis == 0:
+#             tstep = uv_pair_int
+#         else:
+#             tstep = uv_pair_int.swapxy()
+#
+#         return self.cadence.time_range_at_tstep(tstep, remask=False)
+#
+#     #===========================================================================
+#     def uv_range_at_time(self, time, remask=False):
+#         """The (u,v) range of spatial pixels observed at the specified time.
+#
+#         Input:
+#             time        a Scalar of time values in seconds TDB.
+#             remask      True to mask values outside the time limits.
+#
+#         Return:         (uv_min, uv_max)
+#             uv_min      the lower (u,v) corner Pair of the area observed at the
+#                         specified time.
+#             uv_max      the upper (u,v) corner Pair of the area observed at the
+#                         specified time.
+#         """
+#
+#         return Observation.uv_range_at_time_2d(self, time,
+#                                                      uv_shape=Pair.INT11,
+#                                                      slow=self._slow_uv_axis,
+#                                                      fast=self._fast_uv_axis,
+#                                                      remask=remask)
+#
+#     #===========================================================================
+#     def time_shift(self, dtime):
+#         """A copy of the observation object with a time-shift.
+#
+#         Input:
+#             dtime       the time offset to apply to the observation, in units of
+#                         seconds. A positive value shifts the observation later.
+#
+#         Return:         a (shallow) copy of the object with a new time.
+#         """
+#
+#         return RasterScan(self.axes, self.cadence.time_shift(dtime),
+#                           self.fov, self.path, self.frame, **self.subfields)
+#
+#     #===========================================================================
+#     def inventory(self, *args, **kwargs):
+#         """Info about the bodies that appear unobscured inside the FOV. See
+#         Snapshot.inventory() for details.
+#
+#         WARNING: Not properly updated for class RasterScan. Use at your own
+#         risk. This operates by returning every body that would have been inside
+#         the FOV of this observation if it were instead a Snapshot, evaluated at
+#         the given tfrac.
+#         """
+#
+#         return self.snapshot.inventory(*args, **kwargs)
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
-from oops.cadence.dualcadence import case_dual_metronome
-
-class Test_ReshapedCadence(unittest.TestCase):
-
-    # A complete test there-and-back of _reshape_tstep()
-
-    def TEST(self, oldshape, newshape, arg):
-
-        oldstride = np.cumprod((oldshape + (1,))[::-1])[-2::-1]
-        newstride = np.cumprod((newshape + (1,))[::-1])[-2::-1]
-        oldrank = len(oldshape)
-        newrank = len(newshape)
-
-        arg1 = ReshapedCadence._reshape_tstep(arg,
-                                              oldshape, oldstride, oldrank,
-                                              newshape, newstride, newrank,
-                                              np.prod(oldshape))
-        arg2 = ReshapedCadence._reshape_tstep(arg1,
-                                              newshape, newstride, newrank,
-                                              oldshape, oldstride, oldrank,
-                                              np.prod(oldshape))
-
-        self.assertEqual(arg, arg2)
-
-        self.assertEqual(type(arg), type(arg2))
 
-        if arg.is_int():
-            self.assertTrue(arg2.is_int())
-        else:
-            self.assertTrue(arg2.is_float())
+class Test_RasterScan(unittest.TestCase):
 
     def runTest(self):
 
         from oops.cadence.metronome import Metronome
+        from oops.cadence.dualcadence import DualCadence
+        from oops.fov.flatfov import FlatFOV
 
-        self.TEST((10,), (10,), Scalar(1))
-        self.TEST((10,), (2,5), Scalar(1))
-        self.TEST((10,), (2,5), Scalar(1.5))
-        self.TEST((10,), (2,5), Scalar(np.arange(10)))
-        self.TEST((10,), (2,5), Scalar(np.arange(20)/2.))
-        self.TEST((10,), (2,5), Scalar(np.arange(10).reshape(5,2)))
-        self.TEST((10,), (2,5), Scalar((np.arange(20)/2.).reshape(2,5,2)))
-
-        self.TEST((2,3,4), (24,), Vector((1,2,3)))
-        self.TEST((2,3,4), (24,), Vector((1,2,3.5)))
-        self.TEST((2,3,4), (24,), Vector([(1,2,3),(1,2,3.5),(0,0,0.25)]))
-
-        self.TEST((2,3,4), (4,6), Vector((1,2,3)))
-        self.TEST((2,3,4), (4,6), Vector((1,2,3.5)))
-        self.TEST((2,3,4), (4,6), Vector([(1,2,3),(1,2,3.5),(0,0,0.25)]))
-
-        ########################################################################
-        # Compare a Metronome reshaped to 2-D to an equivalent DualCadence
-        # cad1d: 100-101, 102-103, 104-105, ... 198-199.
-
-        cad1d = Metronome(100., 2., 1., 50)
-
-#         long = Metronome(100., 10., 1., 10)
-#         short = Metronome(0, 2., 1., 5)
-#         cad2d = DualCadence(long, short)
-        cad2d = ReshapedCadence(cad1d, (10,5))
-
-        case_dual_metronome(self, cad1d, cad2d)
-
-        ############################################
-        # Weirdly reshaped case, 100 -> (25,4)
-        # 100-110, 110-120, 120-130, ...
-        ############################################
-
-        cadence = Metronome(100., 10., 10., 100)
-        reshaped = ReshapedCadence(cadence, (25,4))
-
-        self.assertTrue(reshaped.is_continuous)
-        self.assertTrue(reshaped.is_unique)
-
-        self.assertEqual(reshaped.time_at_tstep((0,0)), 100.)
-        self.assertEqual(reshaped.time_at_tstep((0,1)), 110.)
-        self.assertEqual(reshaped.time_at_tstep((1,0)), 140.)
-        self.assertEqual(reshaped.time_at_tstep((1,1)), 150.)
-        self.assertEqual(reshaped.time_at_tstep((1,1.5)), 155.)
-
-        tstep = Pair([[(0,0),(0,1)],[(1,0),(1,1)]])
-        self.assertEqual(reshaped.time_at_tstep(tstep), [[100,110],[140,150]])
-
-        tstep = Pair([[(0,0),(0,1)],[(1,0),(1,1)]], [[1,0],[0,0]])
-        time = reshaped.time_at_tstep(tstep)
-        self.assertTrue(np.all(tstep.mask == time.mask))
-        self.assertEqual(time[0,0], Scalar.MASKED)
-        self.assertEqual(reshaped.time_at_tstep(tstep), [[Scalar.MASKED,110],[140,150]])
-
-        self.assertEqual(reshaped.tstep_at_time(100.), (0,0))
-        self.assertEqual(reshaped.tstep_at_time(110.), (0,1))
-        self.assertEqual(reshaped.tstep_at_time(140.), (1,0))
-        self.assertEqual(reshaped.tstep_at_time(150.), (1,1))
-        self.assertEqual(reshaped.tstep_at_time(155.), (1,1.5))
-
-        for i in np.arange(-2., 28., 0.5):
-          for j in np.arange(-1., 5., 0.25):
-            k = 4*np.floor(i) + j
-            (time1a, time1b) = cadence.time_range_at_tstep(k)
-            (time2a, time2b) = reshaped.time_range_at_tstep((i,j), remask=True,
-                                                            inclusive=False)
-            if not time2a.mask:
-                self.assertEqual(time1a, time2a)
-                self.assertEqual(time1b, time2b)
-
-                time = reshaped.time_at_tstep((i,j), remask=True)
-                tstep = reshaped.tstep_at_time(time)
-                self.assertEqual(tstep, (np.floor(i),j))
-
-        ############################################
-        # Weirdly reshaped case, 100 -> (25,4), discontinuous
-        # [100-108, 116-124, 132-140, 148-156], [164-172, ...], [..., 1684-1692]
-        ############################################
-
-        cadence = Metronome(100., 16., 8., 100)
-        reshaped = ReshapedCadence(cadence, (25,4))
-        self.assertFalse(reshaped.is_continuous)
-        self.assertTrue(reshaped.is_unique)
-        self.assertEqual(reshaped.time_at_tstep((0,0)), 100.)
-        self.assertEqual(reshaped.time_at_tstep((0,1)), 116.)
-        self.assertEqual(reshaped.time_at_tstep((1,0)), 164.)
-        self.assertEqual(reshaped.time_at_tstep((1,1)), 180.)
-        self.assertEqual(reshaped.time_at_tstep((1,1.5)), 184.)
-        self.assertEqual(reshaped.time_at_tstep((1.5,1.5)), 184.)
-
-        new_cadence = reshaped.as_continuous()
-        self.assertTrue(new_cadence.is_continuous)
-        self.assertEqual(new_cadence.time_at_tstep((0,0)), 100.)
-        self.assertEqual(new_cadence.time_at_tstep((1,0)), 164.)
-        self.assertEqual(new_cadence.time_at_tstep((1,1)), 180.)
-        self.assertEqual(new_cadence.time_at_tstep((1,1.5)), 188)
-        self.assertEqual(new_cadence.time_at_tstep((1.5,1.5)), 188)
-
-        self.assertEqual(reshaped.tstep_at_time( 99.), (0,0))
-        self.assertEqual(reshaped.tstep_at_time( 99., remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(100.), (0,0))
-        self.assertEqual(reshaped.tstep_at_time(106.), (0,0.75))
-        self.assertEqual(reshaped.tstep_at_time(116.), (0,1))
-        self.assertEqual(reshaped.tstep_at_time(108.), (0,1))
-        self.assertEqual(reshaped.tstep_at_time(108., remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(132.), (0,2))
-        self.assertEqual(reshaped.tstep_at_time(148.), (0,3))
-        self.assertEqual(reshaped.tstep_at_time(140.), (0,3))
-        self.assertEqual(reshaped.tstep_at_time(140., remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(155.), (0,3.875))
-        self.assertEqual(reshaped.tstep_at_time(156.), (0,4))
-        self.assertEqual(reshaped.tstep_at_time(156., remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(163.99999), (0,4))
-        self.assertEqual(reshaped.tstep_at_time(163.99999, remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(164.), (1,0))
-        self.assertEqual(reshaped.tstep_at_time(1684), (24,3))
-        self.assertEqual(reshaped.tstep_at_time(1692), (24,4))
-        self.assertEqual(reshaped.tstep_at_time(1692, inclusive=False), (25,4))
-        self.assertEqual(reshaped.tstep_at_time(1692, inclusive=False,
-                                                      remask=True), Pair.MASKED)
-
-        self.assertEqual(reshaped.tstep_range_at_time( 99.), ((0,0), (1,0)))
-        self.assertEqual(reshaped.tstep_range_at_time( 99., remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(100.), ((0,0), (1,1)))
-        self.assertEqual(reshaped.tstep_range_at_time(106.), ((0,0), (1,1)))
-        self.assertEqual(reshaped.tstep_range_at_time(108.), ((0,0), (1,0)))
-        self.assertEqual(reshaped.tstep_range_at_time(108., remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(115.999), ((0,0), (1,0)))
-        self.assertEqual(reshaped.tstep_range_at_time(115.999, remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(116.), ((0,1), (1,2)))
-        self.assertEqual(reshaped.tstep_range_at_time(148.), ((0,3), (1,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(140.), ((0,2), (1,2)))
-        self.assertEqual(reshaped.tstep_range_at_time(140., remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(156.), ((0,3), (1,3)))
-        self.assertEqual(reshaped.tstep_range_at_time(156., remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(163.999), ((0,3), (1,3)))
-        self.assertEqual(reshaped.tstep_range_at_time(163.999, remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(164.), ((1,0), (2,1)))
-        self.assertEqual(reshaped.tstep_range_at_time(1684), ((24,3), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1692), ((24,3), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1692, inclusive=False), ((24,3), (25,3)))
-        self.assertEqual(reshaped.tstep_range_at_time(1692, inclusive=False,
-                                                      remask=True)[0], Pair.MASKED)
-
-        for i in np.arange(-2., 28., 0.5):
-          for j in np.arange(-1., 5., 0.25):
-            k = 4*np.floor(i) + j
-            (time1a, time1b) = cadence.time_range_at_tstep(k)
-            (time2a, time2b) = reshaped.time_range_at_tstep((i,j), remask=True,
-                                                            inclusive=False)
-            if not time2a.mask:
-                self.assertEqual(time1a, time2a)
-                self.assertEqual(time1b, time2b)
-
-                time = reshaped.time_at_tstep((i,j), remask=True)
-                tstep = reshaped.tstep_at_time(time)
-                self.assertEqual(tstep, (np.floor(i),j))
-
-        ############################################
-        # Weirdly reshaped case, 100 -> (25,4), overlapping
-        # [100-116, 110-126, 120-136, 130-146], [140-156, ...], [..., 1090-1106]
-        ############################################
-
-        cadence = Metronome(100., 10., 16., 100)
-        reshaped = ReshapedCadence(cadence, (25,4))
-        self.assertTrue(reshaped.is_continuous)
-        self.assertFalse(reshaped.is_unique)
-        self.assertEqual(reshaped.time_at_tstep((0,0)), 100.)
-        self.assertEqual(reshaped.time_at_tstep((0,1)), 110.)
-        self.assertEqual(reshaped.time_at_tstep((1,0)), 140.)
-        self.assertEqual(reshaped.time_at_tstep((1,1)), 150.)
-        self.assertEqual(reshaped.time_at_tstep((1,1.5)), 158.)
-        self.assertEqual(reshaped.time_at_tstep((1.5,1.5)), 158.)
-
-        tstep = Pair([(0,0),(0,1),(1,0),(1,1),(1,1.5),(1.5,1.5)],
-                     [True] + 5*[False])
-        self.assertEqual(reshaped.time_at_tstep(tstep),
-                         (Scalar.MASKED, 110, 140, 150, 158, 158))
-        tstep.insert_deriv('t' , Pair(np.arange(12).reshape(6,2)))
-        tstep.insert_deriv('xy', Pair(np.ones((6,2,2)), drank=1))
-        self.assertEqual(reshaped.time_at_tstep(tstep),
-                         (Scalar.MASKED, 110, 140, 150, 158, 158))
-        self.assertEqual(reshaped.time_at_tstep(tstep, derivs=True).d_dt,
-                         (Scalar.MASKED, 48, 80, 112, 144, 176))
-        self.assertEqual(reshaped.time_at_tstep(tstep, derivs=True).d_dxy,
-                         Scalar(16 * np.ones((6,2)), [True] + 5*[False], drank=1))
-
-        self.assertEqual(reshaped.time_range_at_tstep((0,0)), (100, 116))
-        self.assertEqual(reshaped.time_range_at_tstep((0,1)), (110, 126))
-        self.assertEqual(reshaped.time_range_at_tstep((1,0)), (140, 156))
-        self.assertEqual(reshaped.time_range_at_tstep((1,1)), (150, 166))
-        self.assertEqual(reshaped.time_range_at_tstep((1,1.5)), (150, 166))
-        self.assertEqual(reshaped.time_range_at_tstep((1.5,1.5)), (150, 166))
-
-        self.assertEqual(reshaped.time_range_at_tstep(tstep),
-                         ((Scalar.MASKED, 110, 140, 150, 150, 150),
-                          (Scalar.MASKED, 126, 156, 166, 166, 166)))
-
-        self.assertEqual(reshaped.tstep_at_time( 99.), (0,0))
-        self.assertEqual(reshaped.tstep_at_time( 99., remask=True), Pair.MASKED)
-        self.assertEqual(reshaped.tstep_at_time(100.), (0,0))
-        self.assertEqual(reshaped.tstep_at_time(108.), (0,0.5))
-        self.assertEqual(reshaped.tstep_at_time(110.), (0,1))
-        self.assertEqual(reshaped.tstep_at_time(140.), (1,0))
-        self.assertEqual(reshaped.tstep_at_time(1090), (24,3))
-        self.assertEqual(reshaped.tstep_at_time(1106), (24,4))
-        self.assertEqual(reshaped.tstep_at_time(1106, inclusive=False), (25,4))
-        self.assertEqual(reshaped.tstep_at_time(1106, inclusive=False,
-                                                      remask=True), Pair.MASKED)
-
-        self.assertEqual(reshaped.tstep_range_at_time( 99.), ((0,0), (1,0)))
-        self.assertEqual(reshaped.tstep_range_at_time( 99., remask=True)[0], Pair.MASKED)
-        self.assertEqual(reshaped.tstep_range_at_time(100.), ((0,0), (1,1)))
-        self.assertEqual(reshaped.tstep_range_at_time(106.), ((0,0), (1,1)))
-        self.assertEqual(reshaped.tstep_range_at_time(110.), ((0,0), (1,2)))
-        self.assertEqual(reshaped.tstep_range_at_time(139.999), ((0,3), (1,4)))
-        self.assertRaises(ValueError, reshaped.tstep_range_at_time, 140)
-
-        self.assertEqual(reshaped.tstep_range_at_time(1090), ((24,2), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1095.999), ((24,2), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1096), ((24,3), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1106), ((24,3), (25,4)))
-        self.assertEqual(reshaped.tstep_range_at_time(1106, inclusive=False), ((24,3), (25,3)))
-        self.assertEqual(reshaped.tstep_range_at_time(1106, inclusive=False,
-                                                      remask=True)[0], Pair.MASKED)
+        ####################################################
+        # Continuous observation, shape (10,20)
+        # Axes are (fast,slow)
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=1., steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(0,21),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, [0, 100, 190, 10, 110, 200, 190, 200])
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + 2*[True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], [0, 100, 190, 10, 110, 200])
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, [0, 100, 190,  9, 109, 199, 190, 199])
+        self.assertEqual(time_max, [1, 101, 191, 10, 110, 200, 191, 200])
+
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices, remask=True)
+
+        self.assertEqual(Boolean(uv_min.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(uv_max.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(time_min.mask), 6*[False] + 2*[True])
+        self.assertEqual(Boolean(time_max.mask), 6*[False] + 2*[True])
+
+        self.assertEqual(uv_min[:6], Pair.as_pair(indices_)[:6])
+        self.assertEqual(uv_max[:6], Pair.as_pair(indices_)[:6] + (1,1))
+        self.assertEqual(time_min[:6], [0, 100, 190,  9, 109, 199])
+        self.assertEqual(time_max[:6], time_min[:6] + fast_cadence.texp)
+
+        # uvt() with remask == False, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv, time) = obs.uvt(non_ints)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, cadence.time_at_tstep(uv.swapxy()))
+        self.assertEqual(uv, Pair.as_pair(non_ints))
+
+        # uvt() with remask == True, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv, time) = obs.uvt(non_ints, remask=True)
+
+        self.assertEqual(Boolean(uv.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time.mask), 2*[False] + 6*[True])
+        self.assertEqual(time[:2],
+                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
+                          fast_cadence.tstride * non_ints.to_scalar(0))[:2])
+        self.assertEqual(uv[:2], Pair.as_pair(non_ints)[:2])
+
+        # uvt_range() with remask == False, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(Pair.as_pair(non_ints).swapxy())[0])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        # uvt_range() with remask == True, non-integer indices
+        non_ints = indices + (0.2, 0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints, remask=True)
+
+        self.assertEqual(Boolean(uv_min.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(uv_max.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time_min.mask), 2*[False] + 6*[True])
+        self.assertEqual(Boolean(time_max.mask), 2*[False] + 6*[True])
+
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2],
+                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
+                          fast_cadence.tstride * non_ints.to_scalar(0).int())[:2])
+        self.assertEqual(time_max[:2], time_min[:2] + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+
+        self.assertEqual(time0, [0, 190, 9, 199, 199])
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], [0, 190, 9, 199])
+        self.assertEqual(time1[:4], time0[:4] + fast_cadence.texp)
+
+        ####################################################
+        # Fast cadence is discontinuous
+        # Axes are (slow,fast)
+        # Shape (10,20)
+        # [[0-1, 10-11, 20-21, ..., 190-191],
+        #  [1000-1001, 1010-1011, ..., 1190-1191],
+        #  ...
+        #  [9000-9001, 9010-9011, ..., 9190, 9191]]
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=1000., texp=1., steps=10)
+        fast_cadence = Metronome(tstart=0., tstride=10., texp=1., steps=20)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('uslow','vfast'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
+
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, [0, 100, 191, 9000, 9100, 9191, 9191])
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(time_max, time_min + fast_cadence.texp)
+
+        (time0,time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(time1, time0 + fast_cadence.texp)
+
+        ####################################################
+        # Fast cadence is discontinuous
+        # Axes are (fast,slow)
+        # Shape (10,20)
+        ####################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.8)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 55.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 55.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 55.4)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6.     ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.0) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((6.     ,0))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ))[0] - (1.,0.0)) < delta)
+        self.assertTrue(abs(obs.uvt((2, 1.2    ))[0] - (2.,1.2)) < delta)
+        self.assertTrue(abs(obs.uvt((3, 2.5    ))[0] - (3.,2.5)) < delta)
+        self.assertTrue(abs(obs.uvt((4, 3.8    ))[0] - (4.,3.8)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5.     ))[0] - (5.,5.0)) < delta)
+
+        ############################################################
+        # Alternative tstride for even more discontinuous indices
+        ############################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=11., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 218.8)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1],  5.)
+        self.assertEqual(obs.uvt((5,5))[1], 60.)
+        self.assertEqual(obs.uvt((5.0, 5.5))[1], 60.)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 60.4)
+        self.assertEqual(obs.uvt((5.5, 5.5))[1], 60.4)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue((obs.uvt((6.     ,0.))[1] - 6.0).abs() < delta)
+        self.assertTrue((obs.uvt((6.25   ,0.))[1] - 6.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.5    ,0.))[1] - 6.4).abs() < delta)
+        self.assertTrue((obs.uvt((6.75   ,0.))[1] - 6.6).abs() < delta)
+        self.assertTrue((obs.uvt((7. -eps,0.))[1] - 6.8).abs() < delta)
+        self.assertTrue((obs.uvt((7.     ,0.))[1] - 7.0).abs() < delta)
+
+        self.assertTrue((obs.uvt((9.      ,0.))[1] -  9.0).abs() < delta)
+        self.assertTrue((obs.uvt((9.25    ,0.))[1] -  9.2).abs() < delta)
+        self.assertTrue((obs.uvt((9.5     ,0.))[1] -  9.4).abs() < delta)
+        self.assertTrue((obs.uvt((9.75    ,0.))[1] -  9.6).abs() < delta)
+        self.assertTrue((obs.uvt((10 - eps,0.))[1] -  9.8).abs() < delta)
+        self.assertTrue((obs.uvt((0.      ,1.))[1] - 11.0).abs() < delta)
+
+        self.assertTrue((obs.uvt((6.00, 0.    ))[1] -  6.0).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 0.    ))[1] -  6.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 1.    ))[1] - 17.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 2.-eps))[1] - 17.2).abs() < delta)
+        self.assertTrue((obs.uvt((6.25, 2.    ))[1] - 28.2).abs() < delta)
+
+        # Test the upper edge
+        pair = (10-eps, 20-eps)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10, 20-eps)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10-eps, 20)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        pair = (10, 20)
+        self.assertEqual(obs.uvt(pair)[0], pair)
+        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+
+        self.assertTrue(obs.uvt((10+eps, 20), True)[0].mask)
+        self.assertTrue(obs.uvt((10, 20+eps), True)[0].mask)
+
+        # Try all at once
+        indices = Pair([(10-eps,20-eps), (10,20-eps), (10-eps,20), (10,20),
+                        (10+eps,20), (10,20+eps)])
+        (test_uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertEqual(Boolean(test_uv.mask), 4*[False] + 2*[True])
+        self.assertEqual(test_uv[:4], indices[:4])
+        self.assertTrue(((time[:4] - 218.8).abs() < delta).all())
+        self.assertEqual(Boolean(time.mask), test_uv.mask)
+
+        ############################################################
+        # Alternative texp and axes
+        ############################################################
+
+        fov = FlatFOV((0.001,0.001), (10,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        cadence = DualCadence(slow_cadence, fast_cadence)
+        obs = RasterScan(axes=('a','vslow','b','ufast','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 199.8)
+
+        self.assertEqual(obs.uvt((1,0,3,0,4))[1],   0.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1],   5.)
+        self.assertEqual(obs.uvt((1,0,3,5.5,4))[1], 5.4)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 7.0) < delta)
+
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6   ,7))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2 ,7))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4 ,7))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6 ,7))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8 ,7))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.  ,7))[0] - (7.0,6.)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ,4,1,7))[0] - (1.,0.0)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 1.2    ,4,2,7))[0] - (2.,1.2)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 2.5    ,4,3,7))[0] - (3.,2.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 3.7    ,4,4,7))[0] - (4.,3.7)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5.     ,4,5,7))[0] - (5.,5.0)) < delta)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/reversedcadence.py` & `rms_oops-0.0.4/oops/cadence/reversedcadence.py`

 * *Files 21% similar despite different names*

```diff
@@ -205,94 +205,7 @@
         For DualCadence, this is accomplished by forcing the stride of
         the short cadence to be continuous.
         """
 
         return ReversedCadence(self.cadence.as_continuous())
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_ReversedCadence(unittest.TestCase):
-
-  # Test using TDICadence, which already has the feature that the "up" and the
-  # "down" versions are index-reversed.
-
-  def runTest(self):
-
-    import numpy as np
-    from oops.cadence.tdicadence import (TDICadence,
-                                         case_tdicadence_10_100_10_2_down,
-                                         case_tdicadence_10_100_10_2_up,
-                                         case_tdicadence_100_1000_10_100_down)
-    from oops.cadence.metronome import (Metronome,
-                                        case_continuous, case_discontinuous,
-                                        case_non_unique, case_partial_overlap)
-
-    np.random.seed(3547)
-
-    ########################################
-    # 10 lines, 2 stages, TDI downward, 100-120
-    ########################################
-
-    tdicad = TDICadence(10, 100., 10., 2, tdi_sign=1)
-    cad = ReversedCadence(tdicad)
-    case_tdicadence_10_100_10_2_down(self, cad)
-
-    ########################################
-    # 10 lines, 2 stages, TDI upward
-    ########################################
-
-    tdicad = TDICadence(10, 100., 10., 2, tdi_sign=-1)
-    cad = ReversedCadence(tdicad)
-    case_tdicadence_10_100_10_2_up(self, cad)
-
-    ########################################
-    # 100 lines, 100 stages, TDI downward
-    ########################################
-
-    tdicad = TDICadence(100, 1000., 10., 100, tdi_sign=1)
-    cad = ReversedCadence(tdicad)
-    case_tdicadence_100_1000_10_100_down(self, cad)
-
-    ############################################
-    # Doubly-reversed Metronome, continuous
-    # 100-110, 110-120, 120-130, 130-140
-    ############################################
-
-    cadence = Metronome(100., 10., 10., 4)
-    cadence = ReversedCadence(ReversedCadence(cadence))
-    case_continuous(self, cadence)
-
-    ############################################
-    # Doubly-reversed Metronome, discontinuous case
-    # 100-107.5, 110-117.5, 120-127.5, 130-137.5
-    ############################################
-
-    cadence = Metronome(100., 10., 7.5, 4)
-    cadence = ReversedCadence(ReversedCadence(cadence))
-    case_discontinuous(self, cadence)
-
-    ############################################
-    # Doubly-reversed Metronome, non-unique case
-    # 100-140, 110-150, 120-160, 130-170
-    ############################################
-
-    cadence = Metronome(100., 10., 40., 4)
-    cadence = ReversedCadence(ReversedCadence(cadence))
-    case_non_unique(self, cadence)
-
-    ############################################
-    # Doubly-reversed Metronome, partial overlap case
-    # 100-140, 130-170, 160-200, 190-230
-    ############################################
-
-    cadence = Metronome(100., 30., 40., 4)
-    cadence = ReversedCadence(ReversedCadence(cadence))
-    case_partial_overlap(self, cadence)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/sequence.py` & `rms_oops-0.0.4/oops/cadence/sequence.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 ################################################################################
 # oops/cadence/sequence.py: Sequence subclass of class Cadence
 ################################################################################
 
 import numpy as np
-from polymath import Boolean, Scalar, Qube
 
+from polymath     import Boolean, Scalar, Qube
 from oops.cadence import Cadence
 
 class Sequence(Cadence):
     """Cadence subclass in which time steps are defined by a list."""
 
     def __init__(self, tlist, texp):
         """Constructor for a Sequence.
@@ -369,81 +369,7 @@
         texp[ -1] = self.texp[-1].vals
 
         result = Sequence(self.tlist, texp)
         result.is_continuous = True  # forced, in case of roundoff error in texp
         return result
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-from oops.cadence.metronome import (case_continuous, case_discontinuous,
-                                    case_non_unique, case_partial_overlap)
-
-class Test_Sequence(unittest.TestCase):
-
-    def runTest(self):
-
-        import numpy.random as random
-
-        random.seed(5995)
-
-        # These are the tests for subclass Metronome. We define Sequences so
-        # that behavior should be identical, except in the out-of-bound cases
-
-        ############################################
-        # Tests for continuous case
-        # 100-110, 110-120, 120-130, 130-140
-        ############################################
-
-        # cadence = Metronome(100., 10., 10., 4)
-        cadence = Sequence([100.,110.,120.,130.,140.], 0.)
-        case_continuous(self, cadence)
-
-        ############################################
-        # Discontinuous case, simulating the equivalent Metronome
-        # 100-107.5, 110-117.5, 120-127.5, 130-137.5
-        ############################################
-
-        # cadence = Metronome(100., 10., 7.5, 4)
-        cadence = Sequence([100.,110.,120.,130.], 7.5)
-        case_discontinuous(self, cadence)
-
-        ############################################
-        # Non-unique case, simulating the equivalent Metronome
-        # 100-140, 110-150, 120-160, 130-170
-        ############################################
-
-        # cadence = Metronome(100., 10., 40., 4)
-        cadence = Sequence([100.,110.,120.,130.], 40.)
-        case_non_unique(self, cadence)
-
-        ############################################
-        # Partial overlap case, simulating the equivalent Metronome
-        # 100-140, 130-170, 160-200, 190-230
-        ############################################
-
-        # cadence = Metronome(100., 30., 40., 4)
-        cadence = Sequence([100.,130.,160.,190.], 40.)
-        case_partial_overlap(self, cadence)
-
-        ############################################
-        # Other cases
-        ############################################
-
-        cadence = Sequence([100.,110.,120.,130.], [10.,10.,5.,10.])
-        self.assertFalse(cadence.is_continuous)
-        cadence = Sequence([100.,110.,125.,130.], [10.,15.,5.,10.])
-        self.assertTrue(cadence.is_continuous)
-
-        self.assertEqual(cadence.tstep_at_time(105., remask=True), 0.5)
-        self.assertEqual(cadence.tstep_at_time(115., remask=True), 4./3.)
-        self.assertEqual(cadence.tstep_at_time(127., remask=True), 2.4)
-        self.assertEqual(cadence.time_at_tstep(0.5 , remask=True), 105.)
-        self.assertEqual(cadence.time_at_tstep(4./3., remask=True), 115.)
-        self.assertEqual(cadence.time_at_tstep(2.4 , remask=True), 127.)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/cadence/tdicadence.py` & `rms_oops-0.0.4/tests/cadence/test_metronome.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,745 +1,879 @@
 ################################################################################
-# oops/cadence/tdicadence.py: TDICadence subclass of class Cadence
+# oops/cadence/metronome.py: Metronome subclass of class Cadence
 ################################################################################
 
-from polymath     import Scalar
-from oops.cadence import Cadence
+import numpy as np
+import unittest
 
-class TDICadence(Cadence):
-    """A Cadence subclass defining the integration intervals of lines in a TDI
-    ("Time Delay and Integration") camera. The tstep index matches the line
-    index in the TDI detector.
-    """
-
-    def __init__(self, lines, tstart, tdi_texp, tdi_stages, tdi_sign=-1):
-        """Constructor for a TDICadence.
-
-        Input:
-            lines       the number of lines in the detector. This corresponds to
-                        the number of time steps in the cadence.
-            tstart      the start time of the observation in seconds TDB.
-            tdi_texp    the interval in seconds from the start of one TDI step
-                        to the start of the next.
-            tdi_stages  the number of TDI time steps, 1 to number of lines.
-            tdi_sign    +1 if pixel DNs are shifted in the positive direction
-                        along the 'ut' or 'vt' axis; -1 if DNs are shifted in
-                        the negative direction. Default is -1, suitable for
-                        JunoCam.
-        """
-
-        # Save the input parameters
-        self.lines = int(lines)
-        self.tstart = float(tstart)
-        self.tdi_texp = float(tdi_texp)
-        self.tdi_stages = int(tdi_stages)
-        self.tdi_sign = 1 if tdi_sign > 0 else -1
-
-        if self.tdi_stages < 1 or self.tdi_stages > self.lines:
-            raise ValueError('invalid TDICadence inputs: ' +
-                             'lines=%d; tdi_stages=%d' % (lines, tdi_stages))
-
-        self._tdi_upward = (self.tdi_sign > 0)
-        self._max_shifts = self.tdi_stages - 1
-        self._max_line = self.lines - 1
-
-        # Number of lines that are always active
-        self._perm_lines = self.lines - self._max_shifts
-
-        # Fill in the required attributes
-        self.time = (self.tstart, self.tstart + self.tdi_texp * self.tdi_stages)
-        self.midtime = 0.5 * (self.time[0] + self.time[1])
-        self.lasttime = self.time[-1] - self.tdi_texp
-        self.shape = (self.lines,)
-        self.is_continuous = True
-        self.is_unique = (self.tdi_stages == 1)
-        self.min_tstride = 0.
-        self.max_tstride = tdi_texp
-
-        self._scalar_end_time = Scalar(self.time[1])
-
-    def __getstate__(self):
-        return (self.lines, self.tstart, self.tdi_texp, self.tdi_stages,
-                self.tdi_sign)
-
-    def __setstate__(self, state):
-        self.__init__(*state)
-
-    ############################################################################
-    # Methods unique to this class
-    ############################################################################
-
-    def tdi_shifts_at_line(self, line, remask=False, inclusive=True):
-        """The number of TDI shifts at the given image line (or tstep).
-
-        Input:
-            line        a Scalar line number.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as inside the
-                        cadence. If inclusive is False and remask is True, the
-                        end time will be masked.
-
-        Return:         an integer Scalar defining the number of TDI shifts at
-                        this line number.
-        """
-
-        line = Scalar.as_scalar(line, recursive=False)
-        line = line.int(top=self.lines, remask=remask, inclusive=inclusive)
-
-        if self._tdi_upward:
-            shifts = line
-        else:
-            shifts = self._max_line - line
-
-        return shifts.clip(0, self._max_shifts, remask=False)
-
-    #===========================================================================
-    def tdi_shifts_after_time(self, time, remask=False, inclusive=True):
-        """The number of TDI shifts at the given time.
-
-        Input:
-            time        Scalar of optional absolute time in seconds.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as inside the
-                        cadence. If inclusive is False and remask is True, the
-                        end time will be masked.
-
-        Return:         an integer Scalar defining the number of TDI shifts that
-                        will occur after this time in the exposure.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-        tstep = (time - self.time[0]) / self.tdi_texp
-        tstep_int = tstep.int(top=self.tdi_stages,
-                              remask=remask, inclusive=inclusive)
-        return (self._max_shifts - tstep_int).clip(0, self.tdi_stages,
-                                                      remask=remask)
-
-    ############################################################################
-    # Standard Cadence methods
-    ############################################################################
-
-    def time_at_tstep(self, tstep, remask=False, derivs=False, inclusive=True):
-        """The time associated with the given time step.
-
-        This method supports non-integer time step values.
-
-        Input:
-            tstep       a Scalar of time step index values.
-            remask      True to mask values outside the time limits.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         a Scalar of times in seconds TDB.
-        """
-
-        tstep = Scalar.as_scalar(tstep, recursive=derivs)
-        tstep_int = tstep.int(top=self.lines, remask=remask,
-                              inclusive=inclusive, clip=True)
-        tstep_frac = (tstep - tstep_int).clip(0, 1, inclusive=inclusive,
-                                                    remask=False)
-
-        (time_min,
-         time_max) = self.time_range_at_tstep(tstep_int, remask=False)
-
-        return time_min + tstep_frac * (time_max - time_min)
-
-    #===========================================================================
-    def time_range_at_tstep(self, tstep, remask=False, inclusive=True):
-        """The range of times for the given time step.
-
-        Input:
-            tstep       a Scalar of time step index values.
-            remask      True to mask values outside the time limits.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (time_min, time_max)
-            time_min    a Scalar defining the minimum time associated with the
-                        index. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
-        """
-
-        stages = self.tdi_shifts_at_line(tstep, remask=remask,
-                                                inclusive=inclusive) + 1
-
-        time0 = self.time[1] - stages * self.tdi_texp
-        time1 = Scalar.filled(time0.shape, self.time[1], mask=time0.mask)
-        return (time0, time1)
-
-    #===========================================================================
-    def tstep_at_time(self, time, remask=False, derivs=False, inclusive=True):
-        """Time step for the given time.
-
-        This method returns non-integer time steps.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            derivs      True to include derivatives of tstep in the returned
-                        time.
-            inclusive   True to treat the end time of an interval as inside the
-                        cadence; False to treat it as outside. The start time of
-                        an interval is always treated as inside.
-
-        Return:         a Scalar of time step index values.
-        """
-
-        if self.tdi_stages > 1:
-            raise NotImplementedError('TDICadence.tstep_at_time cannot be ' +
-                                      'implemented; time values are not unique')
-
-        time = Scalar.as_scalar(time, recursive=derivs)
-        tstep = (time - self.time[0]) / self.tdi_texp
-        return tstep.clip(0, 1, inclusive=inclusive, remask=remask)
-
-    #===========================================================================
-    def tstep_range_at_time(self, time, remask=False, inclusive=True):
-        """Integer range of time steps active at the given time.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            remask      True to mask time values not sampled within the cadence.
-            inclusive   True to treat the end time of the cadence as part of the
-                        cadence; False to exclude it.
-
-        Return:         (tstep_min, tstep_max)
-            tstep_min   minimum Scalar time step containing the given time.
-            tstep_max   minimum Scalar time step after the given time.
-
-        Returned tstep_min will always be in the allowed range for the cadence,
-        inclusive, regardless of masking. If the time is not inside the cadence,
-        tstep_max == tstep_min.
-        """
-
-        time = Scalar.as_scalar(time, recursive=False)
-        shifts = (time - self.time[0]) / self.tdi_texp
-
-        # remask = True here; fix it below
-        shifts = shifts.int(top=self.tdi_stages, remask=True,
-                            inclusive=inclusive, clip=True)
-
-        if self._tdi_upward:
-            line_min = self._max_shifts - shifts
-            line_max = Scalar.filled(shifts.shape, self.lines)
-            line_max[shifts.mask] = line_min[shifts.mask]
-        else:
-            line_min = Scalar.zeros(shifts.shape, dtype='int', mask=shifts.mask)
-            line_max = self._perm_lines + shifts
-            line_max[shifts.mask] = line_min[shifts.mask]
-
-        if remask:
-            line_min = line_min.remask(shifts.mask)
-            line_max = line_max.remask(shifts.mask)
-        else:
-            line_min = line_min.remask(time.mask)
-            line_max = line_max.remask(time.mask)
-
-        return (line_min, line_max)
-
-    #===========================================================================
-    def time_is_outside(self, time, inclusive=True):
-        """A Boolean mask of time(s) that fall outside the cadence.
-
-        Input:
-            time        a Scalar of times in seconds TDB.
-            inclusive   True to treat the end time of an interval as inside;
-                        False to treat it as outside. The start time of an
-                        interval is always treated as inside.
-
-        Return:         a Boolean array indicating which time values are not
-                        sampled by the cadence.
-        """
-
-        return Cadence.time_is_outside(self, time, inclusive)
-
-    #===========================================================================
-    def time_shift(self, secs):
-        """Construct a duplicate of this Cadence with all times shifted by given
-        amount.
-
-        Input:
-            secs        the number of seconds to shift the time later.
-        """
-
-        return TDICadence(self.tstart + secs, self.tdi_texp, self.tdi_stages,
-                          self.tdi_sign, self.lines)
-
-    #===========================================================================
-    def as_continuous(self):
-        """A shallow copy of this cadence, forced to be continuous."""
+from polymath import Boolean, Scalar
+import oops
 
-        return self
+# Tests are defined here as separate functions so they can also be used for
+# testing Sequences that are defined to simulate the behavior of Metronomes.
 
-################################################################################
-# UNIT TESTS
-################################################################################
+class Test_Metronome(unittest.TestCase):
 
-import unittest
-import numpy as np
+  def runTest(self):
+
+    np.random.seed(4182)
+
+    ############################################
+    # Tests for continuous case
+    # 100-110, 110-120, 120-130, 130-140
+    ############################################
+
+    cadence = oops.cadence.Metronome(100., 10., 10., 4)
+    case_continuous(self, cadence)
+
+    # tstride_at_tstep
+    tstep = Scalar(7 * np.random.rand(100) - 1.)
+    tstride = cadence.tstride_at_tstep(tstep, remask=False)
+    self.assertEqual(tstride, cadence.tstride)
+
+    tstride = cadence.tstride_at_tstep(tstep, remask=True)
+    outside = (tstep < 0.) | (tstep > 4.)
+    self.assertEqual(tstride[~outside], cadence.tstride)
+    self.assertEqual(tstride[outside], Scalar.MASKED)
+
+    # Unclipped Metronome tests
+    cadence = oops.cadence.Metronome(100., 10., 10., 4, clip=False)
+    self.assertEqual(cadence.time_at_tstep(-0.5, remask=False),  95.)
+    self.assertEqual(cadence.time_at_tstep( 4.5, remask=False), 145.)
+
+    self.assertEqual(cadence.tstep_at_time( 95., remask=False), -0.5)
+    self.assertEqual(cadence.tstep_at_time(145., remask=False),  4.5)
+
+    ############################################
+    # Discontinuous case
+    # 100-107.5, 110-117.5, 120-127.5, 130-137.5
+    ############################################
+
+    cadence = oops.cadence.Metronome(100., 10., 7.5, 4)
+    case_discontinuous(self, cadence)
+
+    # Unclipped Metronome tests
+    cadence = oops.cadence.Metronome(100., 10., 8., 4, clip=False)
+    self.assertEqual(cadence.time_at_tstep(-0.5, remask=False),  94.)
+    self.assertEqual(cadence.time_at_tstep( 4.5, remask=False), 144.)
+    self.assertEqual(cadence.time_at_tstep(3.5), 134.)
+    self.assertEqual(cadence.time_at_tstep(4), 138.)
+    self.assertEqual(cadence.time_at_tstep((3,4)), (130.,138.))
+
+    self.assertEqual(cadence.tstep_at_time(139., remask=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(140., remask=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(144., remask=False), 4.5)
+    self.assertEqual(cadence.tstep_at_time(154., remask=False), 5.5)
+    self.assertEqual(cadence.tstep_at_time( 90., remask=False), -1.)
+    self.assertEqual(cadence.tstep_at_time( 94., remask=False), -0.5)
+
+    ############################################
+    # Non-unique case
+    # 100-140, 110-150, 120-160, 130-170
+    ############################################
+
+    cadence = oops.cadence.Metronome(100., 10., 40., 4)
+    case_non_unique(self, cadence)
+
+    # Unclipped Metronome tests
+    cadence = oops.cadence.Metronome(100., 10., 40., 4, clip=False)
+    self.assertEqual(cadence.time_at_tstep(-0.5,remask=False), 110.)
+    self.assertEqual(cadence.time_at_tstep( 4.5,remask=False), 160.)
+    self.assertEqual(cadence.tstep_at_time(170., inclusive=False), 7.)
+    self.assertEqual(cadence.tstep_at_time(171., remask=False), 7.025)
+    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False), (3,3))
+
+    ############################################
+    # Partial overlap case
+    # 100-140, 130-170, 160-200, 190-230
+    ############################################
+
+    cadence = oops.cadence.Metronome(100., 30., 40., 4)
+    case_partial_overlap(self, cadence)
+
+    # Unclipped Metronome tests
+    cadence = oops.cadence.Metronome(100., 30., 40., 4, clip=False)
+    self.assertEqual(cadence.time_at_tstep(-0.5,remask=False),  90.)
+    self.assertEqual(cadence.time_at_tstep( 4.5,remask=False), 240.)
+    self.assertEqual(cadence.tstep_at_time(230., inclusive=False), 4.25)
+    self.assertEqual(cadence.tstep_at_time(235., remask=False), 4.375)
+
+    ############################################
+    # One time step, 100-110
+    ############################################
+
+    cadence = oops.cadence.Metronome(100., 22., 10., 1)
+    one_time_step(self, cadence)
+
+############################################
+# Tests for continuous case
+# 100-110, 110-120, 120-130, 130-140
+############################################
+
+def case_continuous(self, cadence):
+
+    self.assertTrue(cadence.is_continuous)
+    self.assertTrue(cadence.is_unique)
+
+    # time_at_tstep()
+    self.assertEqual(cadence.time_at_tstep(0, remask=True ), 100.)
+    self.assertEqual(cadence.time_at_tstep(0, remask=False), 100.)
+    self.assertEqual(cadence.time_at_tstep(1, remask=True ), 110.)
+    self.assertEqual(cadence.time_at_tstep(1, remask=False), 110.)
+    self.assertEqual(cadence.time_at_tstep(4, remask=True ), 140.)
+    self.assertEqual(cadence.time_at_tstep(4, remask=False), 140.)
+    self.assertEqual(cadence.time_at_tstep((3,4), remask=True ), (130.,140.))
+    self.assertEqual(cadence.time_at_tstep((3,4), remask=False), (130.,140.))
+    self.assertEqual(cadence.time_at_tstep(0.5, remask=True ), 105.)
+    self.assertEqual(cadence.time_at_tstep(0.5, remask=False), 105.)
+    self.assertEqual(cadence.time_at_tstep(3.5, remask=True ), 135.)
+    self.assertEqual(cadence.time_at_tstep(3.5, remask=False), 135.)
+
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
+                     [False,True,False])
+
+    tstep = ([0,1],[2,3],[3,4])
+    time  = ([100,110],[120,130],[130,140])
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
+
+    tstep = ([-1,0],[2,4],[4.5,5])
+    test = cadence.time_at_tstep(tstep, remask=False)
+    self.assertEqual(test.masked(), 0)
+    self.assertEqual(test, [[100,100],[120,140],[140,140]])
+
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(test.mask) ==
+                    [[True,False],[False,False],[True,True]])
+
+    test = cadence.time_at_tstep(tstep, remask=True, inclusive=False)
+    self.assertTrue(Boolean(test.mask) ==
+                    [[True,False],[False,True],[True,True]])
+
+    # time_at_tstep(), derivs
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
+                     [False,True,False])
+
+    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
+                     (20, Scalar.MASKED, 40))
+
+    tstep = Scalar((0.,1.,2.))
+    tstep.insert_deriv('t', Scalar((2,3,4)))
+    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
+                     [(0,10), (20,30), (40,50)])
+
+    # time_is_inside()
+    time = ([99,100],[120,140],[145,150])
+    self.assertTrue(cadence.time_is_inside(time) ==
+                     [[False,True],[True,True],[False,False]])
+    self.assertTrue(Boolean(cadence.time_is_inside(time, inclusive=False)) ==
+                     [[False,True],[True,False],[False,False]])
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_is_inside(time).mask), time.mask)
 
-class Test_TDICadence(unittest.TestCase):
+    # tstep_at_time()
+    self.assertEqual(cadence.tstep_at_time(100., remask=True ), 0.)
+    self.assertEqual(cadence.tstep_at_time(100., remask=False), 0.)
+    self.assertEqual(cadence.tstep_at_time(105., remask=True ), 0.5)
+    self.assertEqual(cadence.tstep_at_time(105., remask=False), 0.5)
+    self.assertEqual(cadence.tstep_at_time(135., remask=True ), 3.5)
+    self.assertEqual(cadence.tstep_at_time(135., remask=False), 3.5)
+    self.assertEqual(cadence.tstep_at_time(140., remask=False), 4.0)
+    self.assertEqual(cadence.tstep_at_time(140., remask=True ), 4.0)
+    self.assertEqual(cadence.tstep_at_time(140., remask=True,
+                                                 inclusive=False), Scalar.MASKED)
+
+    tstep = [100.,105.,108.,109.,110]
+    self.assertEqual(cadence.tstep_at_time(tstep, remask=True).count_masked(), 0)
+
+    tstep = [95,100.,105.,110.,140.,145.]
+    self.assertFalse(np.any(cadence.tstep_at_time(tstep, remask=False).mask))
+    self.assertTrue(np.all(cadence.tstep_at_time(tstep,
+                                                 remask=True).mask == (1,0,0,0,0,1)))
+    self.assertTrue(np.all(cadence.tstep_at_time(tstep, remask=True,
+                                                 inclusive=False).mask == (1,0,0,0,1,1)))
+    self.assertTrue(np.all(cadence.tstep_at_time(tstep, remask=False,
+                                                 inclusive=True).vals == [0,0,0.5,1,4,4]))
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
+                     time.mask)
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
+                     time.mask)
 
-    def runTest(self):
+    # tstep_at_time(), derivs
+    time = Scalar((90,100,110,140), derivs={'t': Scalar((100,200,300,400))})
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt,
+                     (0, 20, 30, 40))
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
+                                                 inclusive=False).d_dt,
+                     (0, 20, 30, 0))
 
-        ########################################
-        # 10 lines, 2 stages, TDI downward, 100-120
-        ########################################
-
-        cad = TDICadence(10, 100., 10., 2)
-        case_tdicadence_10_100_10_2_down(self, cad)
-
-        ########################################
-        # 10 lines, 2 stages, TDI upward
-        ########################################
-
-        cad = TDICadence(10, 100., 10., 2, tdi_sign=1)
-        case_tdicadence_10_100_10_2_up(self, cad)
-
-        ########################################
-        # 100 lines, 100 stages, TDI downward
-        ########################################
-
-        cad = TDICadence(100, 1000., 10., 100)
-        case_tdicadence_100_1000_10_100_down(self, cad)
-
-        ########################################
-        # 10 lines, one stage
-        ########################################
-
-        cad = TDICadence(10, 100., 10., 1)
-#         print(cad.time_at_tstep(10))
-        case_tdicadence_10_100_10_1(self, cad)
-
-def case_tdicadence_10_100_10_2_down(self, cad):
-
-    # time_range_at_tstep
-    self.assertEqual(cad.time_range_at_tstep(-1), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(-1, remask=True), (Scalar.MASKED, Scalar.MASKED))
-    self.assertEqual(cad.time_range_at_tstep(0), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(8), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(9), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(9.5),(110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(10), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
-                                                 remask=False), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
-                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
-    self.assertEqual(cad.time_range_at_tstep(11), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
-                                                 remask=False), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
-                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
-
-    tstep = Scalar(([0,1],[2,9]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].vals ==
-                           [[100,100],[100,110]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].vals ==
-                           [[100,100],[100,110]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].vals ==
-                           [[100,100],[100,110]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[0].vals == [[100,100],[100,110]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[0].mask == [[0,0],[1,1]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[1].mask == [[0,0],[1,1]]))
-
-    # time_at_tstep
-    self.assertEqual(cad.time_at_tstep(-1.), 100.)
-    self.assertEqual(cad.time_at_tstep(-1., remask=True), Scalar.MASKED)
-    self.assertEqual(cad.time_at_tstep(0. ), 100.)
-    self.assertEqual(cad.time_at_tstep(0.5), 110.)
-    self.assertEqual(cad.time_at_tstep(0.9), 118.)
-    self.assertEqual(cad.time_at_tstep(1. ), 100.)
-    self.assertEqual(cad.time_at_tstep(1.5), 110.)
-    self.assertEqual(cad.time_at_tstep(1.9), 118.)
-    self.assertEqual(cad.time_at_tstep(9. ), 110.)
-    self.assertEqual(cad.time_at_tstep(9.5), 115.)
-    self.assertEqual(cad.time_at_tstep(10.), 120.)
-    self.assertEqual(cad.time_at_tstep(10., remask=True,
-                                            inclusive=True), 120.)
-    self.assertEqual(cad.time_at_tstep(10., remask=True,
-                                            inclusive=False), Scalar.MASKED)
-
-    tstep = Scalar(([0,1],[9,10]),([False,True],[False,False]))
-    self.assertTrue(np.all(cad.time_at_tstep(tstep).vals == [[100,100],[110,120]]))
-    self.assertTrue(np.all(cad.time_at_tstep(tstep).mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_at_tstep(tstep, remask=True,
-                                             inclusive=False).mask == [[0,1],[0,1]]))
-
-    # time_at_tstep, derivs
-    tstep = Scalar([-1, 0, 0.5, 0.9, 1.,1.5, 1.9, 9, 9.5, 10])
-    tstep.insert_deriv('t', Scalar(np.arange(10.)))
-    self.assertEqual(cad.time_at_tstep(tstep),
-                    [100,100,110,118,100,110,118,110,115,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True),
-                    [100,100,110,118,100,110,118,110,115,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True),
-                    [Scalar.MASKED,100,110,118,100,110,118,110,115,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False),
-                    [Scalar.MASKED,100,110,118,100,110,118,110,115,Scalar.MASKED])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt,
-                    [0,20,40,60,80,100,120,70,80,90])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True).d_dt,
-                    [Scalar.MASKED,20,40,60,80,100,120,70,80,90])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False).d_dt,
-                    [Scalar.MASKED,20,40,60,80,100,120,70,80,Scalar.MASKED])
-
-    # tstep_range_at_time
-    self.assertEqual(cad.tstep_range_at_time(100.), (0, 9))
-    self.assertEqual(cad.tstep_range_at_time(109.), (0, 9))
-    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
-
-    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
-    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
-    self.assertEqual(test0, test1)
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=True), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
-
-    time = Scalar([100,110,120],[False,False,False])
-    self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (0,0,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (9,10,10)))
-
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (0,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (9,10,0)))
-    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
-    self.assertTrue(np.all(test0.vals[:2] == (0,0)))
-    self.assertTrue(np.all(test1.vals[:2] == (9,10)))
-    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
-
-    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[0].mask))
-    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[1].mask))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (0,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (9,10,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,0,1)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,0,1)))
-
-    time = Scalar([100,110,120],[True,False,False])
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (0,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (0,10,10)))
-    (test0, test1) = cad.tstep_range_at_time(time)
-    self.assertEqual(test0.vals[0], test1.vals[0])  # zero range is required, specific values are not
-    self.assertTrue(np.all(test0.vals[1:] == (0,0)))
-    self.assertTrue(np.all(test1.vals[1:] == (10,10)))
-
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (0,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (0,10,0)))
-    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
-    self.assertEqual(test0.vals[0], test1.vals[0])  # zero range is required, specific values are not
-    self.assertEqual(test0.vals[1], 0)
-    self.assertEqual(test1.vals[1], 10)
-    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
-
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].mask == (1,0,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].mask == (1,0,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (1,0,1)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (1,0,1)))
+    # tstep_range_at_time()
+    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(110.), (1,2))
+    self.assertEqual(cadence.tstep_range_at_time(135.), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(140.), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(140., remask=True), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(140., remask=True,
+                                                       inclusive=True), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(140., remask=False,
+                                                       inclusive=False), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(140., remask=True,
+                                                       inclusive=False), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(140., remask=False,
+                                                       inclusive=True), (3,4))
+
+    self.assertEqual(cadence.tstep_range_at_time(140.001), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(140.001, remask=True), MASKED_TUPLE)
+
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(100., remask=True), (0,1))
+
+    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=False), (0,0))
+    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=True), MASKED_TUPLE)
+
+    tstep = [95.,100.,105.,110.,140.,145.]
+    self.assertEqual(cadence.tstep_range_at_time(tstep, remask=False,
+                                                 inclusive=True), ([0,0,0,1,3,3],
+                                                                   [0,1,1,2,4,3]))
+    self.assertEqual(cadence.tstep_range_at_time(tstep, remask=False,
+                                                 inclusive=False), ([0,0,0,1,3,3],
+                                                                    [0,1,1,2,3,3]))
+
+    # Conversion and back
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+    time = cadence.time_at_tstep(tstep, remask=False)
+    test = cadence.tstep_at_time(time, remask=False)
+    mask = (tstep.vals < 0) | (tstep.vals > 4)
+    self.assertTrue((abs(tstep - test)[~mask] < 1.e-14).all())
+    self.assertTrue(np.all(time[tstep.vals < 0] == 100.))
+    self.assertTrue(np.all(time[tstep.vals > 4] == 140.))
+    self.assertEqual(test.masked(), 0)
+
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue((abs(time - test).mvals < 1.e-14).all())
+    self.assertTrue(np.all(test.mask == mask))
+    self.assertTrue(cadence.time_is_inside(time).all_true_or_masked())
+
+    time = Scalar(70 * np.random.rand(100,100) + 90.)
+    tstep = cadence.tstep_at_time(time, remask=False)
+    test = cadence.time_at_tstep(tstep, remask=False)
+    mask = (time.vals < 100) | (time.vals > 140)
+    self.assertTrue((abs(time - test)[~mask] < 1.e-14).all())
+    self.assertEqual(tstep.masked(), 0)
+    self.assertEqual(test.masked(), 0)
+
+    # time_range_at_tstep()
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep)[0].mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep)[1].mask),
+                     [False,True,False])
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+    time = cadence.time_at_tstep(tstep, remask=False)
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
+    self.assertEqual(time0, 10*((time0/10).int()))
+    self.assertEqual(time1, 10*((time1/10).int()))
+
+    self.assertTrue((abs(time1 - time0 - 10.) < 1.e-14).all())
+
+    mask = (tstep < 0) | (tstep > cadence.steps)
+    unmasked = ~mask
+    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
+    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
+    self.assertTrue((time0[unmasked] <= cadence.time[1]).all())
+    self.assertTrue((time1[unmasked] <= cadence.time[1]).all())
+    self.assertTrue((time0[unmasked] <= time[unmasked]).all())
+    self.assertTrue((time1[unmasked] >= time[unmasked]).all())
+
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(time0.mask) == mask)
+    self.assertTrue(Boolean(time1.mask) == mask)
+
+    # time_shift()
+    shifted = cadence.time_shift(1.)
+    time_shifted = shifted.time_at_tstep(tstep, remask=False)
+
+    self.assertTrue((abs(time_shifted-time-1.) < 1.e-13).all())
 
     # tstride_at_tstep
-    self.assertEqual(cad.tstride_at_tstep(0), 0)
-    self.assertEqual(cad.tstride_at_tstep(8), 10)
-    self.assertEqual(cad.tstride_at_tstep(8, sign=-1), 0)
-    self.assertEqual(cad.tstride_at_tstep(9), 10)
-    self.assertEqual(cad.tstride_at_tstep(9, sign=-1), 10)
-    self.assertEqual(cad.tstride_at_tstep(10), 10)
-
-def case_tdicadence_10_100_10_2_up(self, cad):
-
-    # time_range_at_tstep
-    self.assertEqual(cad.time_range_at_tstep(-1), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(-1, remask=True), (Scalar.MASKED, Scalar.MASKED))
-    self.assertEqual(cad.time_range_at_tstep(0), (110., 120.))
-    self.assertEqual(cad.time_range_at_tstep(8), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(9), (100., 120.))
-
-    self.assertEqual(cad.time_range_at_tstep(10), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
-                                                 remask=False), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(10, inclusive=False,
-                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
-    self.assertEqual(cad.time_range_at_tstep(11), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
-                                                 remask=False), (100., 120.))
-    self.assertEqual(cad.time_range_at_tstep(11, inclusive=False,
-                                                 remask=True), (Scalar.MASKED, Scalar.MASKED))
-
-    tstep = Scalar(([0,1],[2,9]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].vals ==
-                           [[110,100],[100,100]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].vals ==
-                           [[110,100],[100,100]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=True)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].vals ==
-                           [[110,100],[100,100]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[0].mask == tstep.mask))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False)[1].mask == tstep.mask))
-
-    tstep = Scalar(([0,1],[2,10]),([False,False],[True,False]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[0].vals == [[110,100],[100,100]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[1].vals == 120))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[0].mask == [[0,0],[1,1]]))
-    self.assertTrue(np.all(cad.time_range_at_tstep(tstep, inclusive=False,
-                                                   remask=True)[1].mask == [[0,0],[1,1]]))
-
-    # time_at_tstep
-    self.assertEqual(cad.time_at_tstep(-1.), 110.)
-    self.assertEqual(cad.time_at_tstep(-1., remask=True), Scalar.MASKED)
-    self.assertEqual(cad.time_at_tstep(0. ), 110.)
-    self.assertEqual(cad.time_at_tstep(0.5), 115.)
-    self.assertEqual(cad.time_at_tstep(0.9), 119.)
-    self.assertEqual(cad.time_at_tstep(1. ), 100.)
-    self.assertEqual(cad.time_at_tstep(1.5), 110.)
-    self.assertEqual(cad.time_at_tstep(1.9), 118.)
-    self.assertEqual(cad.time_at_tstep(9. ), 100.)
-    self.assertEqual(cad.time_at_tstep(9.5), 110.)
-    self.assertEqual(cad.time_at_tstep(10.), 120.)
-    self.assertEqual(cad.time_at_tstep(10., remask=True,
-                                            inclusive=True), 120.)
-    self.assertEqual(cad.time_at_tstep(10., remask=True,
-                                            inclusive=False), Scalar.MASKED)
-
-    self.assertEqual(cad.tstep_range_at_time(100.), (1, 10))
-    self.assertEqual(cad.tstep_range_at_time(109.), (1, 10))
-    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
-
-    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
-    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
-    self.assertEqual(test0, test1)  # zero range is required; specific values are not
-
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=True), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
-
-    # time_at_tstep, derivs
-    tstep = Scalar([-1, 0, 0.5, 0.9, 1.,1.5, 1.9, 9, 9.5, 10])
-    tstep.insert_deriv('t', Scalar(np.arange(10.)))
-    self.assertEqual(cad.time_at_tstep(tstep),
-                    [110,110,115,119,100,110,118,100,110,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True),
-                    [110,110,115,119,100,110,118,100,110,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True),
-                    [Scalar.MASKED,110,115,119,100,110,118,100,110,120])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False),
-                    [Scalar.MASKED,110,115,119,100,110,118,100,110,Scalar.MASKED])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt,
-                    [0,10,20,30,80,100,120,140,160,180])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True).d_dt,
-                    [Scalar.MASKED,10,20,30,80,100,120,140,160,180])
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, remask=True, inclusive=False).d_dt,
-                    [Scalar.MASKED,10,20,30,80,100,120,140,160,Scalar.MASKED])
-
-    # tstep_range_at_time
-    self.assertEqual(cad.tstep_range_at_time(100.), (1, 10))
-    self.assertEqual(cad.tstep_range_at_time(109.), (1, 10))
-    self.assertEqual(cad.tstep_range_at_time(110.), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120.), (0, 10))
-
-    # self.assertEqual(cad.tstep_range_at_time(120., inclusive=False), (0, 0))
-    (test0, test1) = cad.tstep_range_at_time(120., inclusive=False)
-    self.assertEqual(test0, test1)  # zero range is required; specific values are not
-
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=True), (0, 10))
-    self.assertEqual(cad.tstep_range_at_time(120., remask=True,
-                                                   inclusive=False), (Scalar.MASKED, Scalar.MASKED))
-
-    time = Scalar([100,110,120],[False,False,False])
-    self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (1,0,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (10,10,10)))
-
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (1,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (10,10,0)))
-    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
-    self.assertTrue(np.all(test0.vals[:2] == (1,0)))
-    self.assertTrue(np.all(test1.vals[:2] == (10,10)))
-    self.assertEqual(test0.vals[2], test1.vals[2])  # zero range is required, specific values are not
-
-    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[0].mask))
-    self.assertTrue(not np.any(cad.tstep_range_at_time(time, inclusive=False)[1].mask))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (1,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (10,10,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,0,1)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,0,1)))
-
-    time = Scalar([100,110,120],[False,True,False])
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[0].vals == (1,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time)[1].vals == (10,0,10)))
-    (test0, test1) = cad.tstep_range_at_time(time)
-    self.assertEqual(test0.vals[1], test1.vals[1])  # zero range is required, specific values are not
-    self.assertTrue(np.all(test0.vals[0::2] == (1,0)))
-    self.assertTrue(np.all(test1.vals[0::2] == (10,10)))
-
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].vals == (1,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].vals == (10,0,0)))
-    (test0, test1) = cad.tstep_range_at_time(time, inclusive=False)
-    self.assertEqual(test0.vals[0], 1)
-    self.assertEqual(test1.vals[0], 10)
-    self.assertEqual(test0.vals[1], test1.vals[1])  # zero range is required, specific values are not
-    self.assertEqual(test0.vals[2], test1.vals[2])
-
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[0].mask == (0,1,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False)[1].mask == (0,1,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == (1,0,0)))
-    # self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == (10,0,0)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].vals == test0.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].vals == test1.vals))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[0].mask == (0,1,1)))
-    self.assertTrue(np.all(cad.tstep_range_at_time(time, inclusive=False, remask=True)[1].mask == (0,1,1)))
-
-def case_tdicadence_100_1000_10_100_down(self, cad):
-
-    tstep = Scalar(np.arange(100))
-    (time0, time1) = cad.time_range_at_tstep(tstep)
-    self.assertEqual(time1, 2000.)
-    self.assertEqual(time0, 1000. + 10. * tstep)
-
-    self.assertEqual(cad.tstep_range_at_time(1000.), (0, 1))
-    self.assertEqual(cad.tstep_range_at_time(1010.), (0, 2))
-    self.assertEqual(cad.tstep_range_at_time(1990.), (0, 100))
-    # self.assertEqual(cad.tstep_range_at_time(2000., inclusive=False), (0, 0))
-    (test0, test1) = cad.tstep_range_at_time(2000., inclusive=False)
-    self.assertEqual(test0, test1)
-    self.assertEqual(cad.tstep_range_at_time(2000., remask=True,
-                                                    inclusive=True), (0, 100))
-    self.assertEqual(cad.tstep_range_at_time(2000., remask=True,
-                                                    inclusive=False), (Scalar.MASKED, Scalar.MASKED))
+    tstep = Scalar(7 * np.random.rand(100) - 1.)
+    outside = (tstep < 0.) | (tstep > 4.)
+    tstep = tstep.remask(50*[False] + 50*[True])
+
+    tstride = cadence.tstride_at_tstep(tstep, remask=False)
+    self.assertTrue(not np.any(tstride.mask[:50]))
+    self.assertTrue(np.all(tstride.mask[50:]))
+
+    tstride = cadence.tstride_at_tstep(tstep, remask=True)
+    self.assertTrue(np.all(tstride.mask[:50] == outside[:50]))
+    self.assertTrue(np.all(tstride.mask[50:]))
+
+############################################
+# Discontinuous case
+# 100-107.5, 110-117.5, 120-127.5, 130-137.5
+############################################
+
+def case_discontinuous(self, cadence):
+
+    self.assertFalse(cadence.is_continuous)
+    self.assertTrue(cadence.is_unique)
+
+    # time_at_tstep()
+    self.assertEqual(cadence.time_at_tstep(0, remask=True ), 100.)
+    self.assertEqual(cadence.time_at_tstep(0, remask=False), 100.)
+    self.assertEqual(cadence.time_at_tstep(1, remask=True ), 110.)
+    self.assertEqual(cadence.time_at_tstep(1, remask=False), 110.)
+    self.assertEqual(cadence.time_at_tstep(4, remask=True ), 137.5)
+    self.assertEqual(cadence.time_at_tstep(4, remask=False), 137.5)
+    self.assertEqual(cadence.time_at_tstep((3,4), remask=True ), (130.,137.5))
+    self.assertEqual(cadence.time_at_tstep((3,4), remask=False), (130.,137.5))
+    self.assertEqual(cadence.time_at_tstep(0.5, remask=True ), 103.75)
+    self.assertEqual(cadence.time_at_tstep(0.5, remask=False), 103.75)
+    self.assertEqual(cadence.time_at_tstep(3.5, remask=True ), 133.75)
+    self.assertEqual(cadence.time_at_tstep(3.5, remask=False), 133.75)
+
+    tstep = ([0,1],[2,3],[3,4])
+    time  = ([100,110],[120,130],[130,137.5])
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
+
+    tstep = ([-1,0],[2,4],[4.5,5])
+    test = cadence.time_at_tstep(tstep, remask=False)
+    self.assertEqual(test.masked(), 0)
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(test.mask) ==
+                    [[True,False],[False,False],[True,True]])
+
+    # time_at_tstep(), derivs
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
+                     [False,True,False])
+
+    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
+                     (15, Scalar.MASKED, 30))
+
+    tstep = Scalar((0.,1.,2.))
+    tstep.insert_deriv('t', Scalar((2,3,4)))
+    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
+                     [(0,7.5), (15,22.5), (30,37.5)])
+
+    # time_is_inside()
+    time  = ([99,100],[120,137.5],[145,150])
+    self.assertTrue(cadence.time_is_inside(time) ==
+                    [[False,True],[True,True],[False,False]])
+    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
+                    [[False,True],[True,False],[False,False]])
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_is_inside(time).mask), time.mask)
+
+    # tstep_at_time()
+    self.assertEqual(cadence.tstep_at_time(100.  , remask=True ), 0.)
+    self.assertEqual(cadence.tstep_at_time(100.  , remask=False), 0.)
+    self.assertEqual(cadence.tstep_at_time(103.75, remask=True ), 0.5)
+    self.assertEqual(cadence.tstep_at_time(103.75, remask=False), 0.5)
+    self.assertEqual(cadence.tstep_at_time(110.  , remask=False), 1.)
+    self.assertEqual(cadence.tstep_at_time(107.5 , remask=False), 1.)
+    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True, inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True, inclusive=True) , Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(107.5 , remask=False), 1.)
+    self.assertEqual(cadence.tstep_at_time(107.5 , remask=True) , Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(133.75, remask=True ), 3.5)
+    self.assertEqual(cadence.tstep_at_time(133.75, remask=False), 3.5)
+    self.assertEqual(cadence.tstep_at_time(137.5 , remask=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(137.5 , remask=False, inclusive=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(137.5 , remask=True , inclusive=True ), 4.)
+    self.assertEqual(cadence.tstep_at_time(137.5 , remask=True , inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(138.  , remask=False, inclusive=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(138.  , remask=True), Scalar.MASKED)
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
+                     time.mask)
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
+                     time.mask)
+
+    time = [100.,103.75,107.5,109.,110.]
+    self.assertTrue(cadence.tstep_at_time(time, remask=False) ==
+                    [0., 0.5, 1., 1., 1.])
+    self.assertTrue(Boolean(cadence.tstep_at_time(time, remask=True).mask) ==
+                    [False,False,True,True,False])
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=True).mask),
+                     time.mask)
+    self.assertEqual(Boolean(cadence.tstep_at_time(time, remask=False).mask),
+                     time.mask)
+
+    # tstep_at_time(), derivs
+    time = Scalar((90,100,113.75,137.5,140), derivs={'t': Scalar((15,30,45,60,75))})
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt,
+                     (0,4,6,8,0))
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
+                                                 inclusive=False).d_dt,
+                     (0,4,6,0,0))
+
+    # tstep_range_at_time()
+    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(135.), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(108.)[0],  # indicates empty range
+                     cadence.tstep_range_at_time(108.)[1])
+    self.assertEqual(cadence.tstep_range_at_time(108., remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(107.5)[0],  # indicates empty range
+                     cadence.tstep_range_at_time(107.5)[1])
+    self.assertEqual(cadence.tstep_range_at_time(107.5, remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(117.5)[0],  # indicates empty range
+                     cadence.tstep_range_at_time(117.5)[1])
+    self.assertEqual(cadence.tstep_range_at_time(117.5, remask=True), MASKED_TUPLE)
+
+    self.assertEqual(cadence.tstep_range_at_time(140. ), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(137.5), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True,
+                                                        inclusive=True), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=False,
+                                                        inclusive=False), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=True,
+                                                        inclusive=False), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(137.5, remask=False,
+                                                        inclusive=True), (3,4))
+
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(100., remask=True), (0,1))
+
+    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=False), (0,0))
+    self.assertEqual(cadence.tstep_range_at_time(99.999, remask=True), MASKED_TUPLE)
+
+    # Conversion and back
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+    time = cadence.time_at_tstep(tstep, remask=False)
+    test = cadence.tstep_at_time(time, remask=False)
+    mask = (tstep.vals < 0) | (tstep.vals > 4)
+    self.assertTrue((abs(tstep - test)[~mask] < 1.e-14).all())
+    self.assertTrue(np.all(time[tstep.vals < 0] == 100.))
+    self.assertTrue(np.all(time[tstep.vals > 4] == 137.5))
+    self.assertEqual(test.masked(), 0)
+
+    mask = (tstep < 0) | (tstep > cadence.steps)
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue((abs(time - test).mvals < 1.e-14).all())
+    self.assertTrue(Boolean(test.mask) == mask)
+    self.assertTrue(cadence.time_is_inside(time).all_true_or_masked())
+
+    time = Scalar(70 * np.random.rand(100,100) + 90.)
+    tstep = cadence.tstep_at_time(time, remask=True)
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue((abs(time - test)[~test.mask] < 1.e-13).all())
+    self.assertTrue(Boolean(test.mask) == tstep.mask)
+    self.assertTrue(cadence.time_is_inside(time[~test.mask]).all())
+    self.assertTrue(cadence.time_is_outside(time.vals[test.mask]).all())
+
+    # time_range_at_tstep()
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[0].mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[1].mask),
+                     [False,True,False])
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+    tstep = tstep.int() # time_range_at_tstep requires an int input
+    time = cadence.time_at_tstep(tstep, remask=False)
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
+    self.assertEqual(time0, 10*((time0/10).int()))
+    self.assertEqual(time1, 10*((time1/10).int())+7.5)
+
+    self.assertTrue((abs(time1 - time0 - 7.5) < 1.e-14).all())
+
+    mask = (tstep < 0) | (tstep > cadence.steps)
+    unmasked = ~mask
+    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
+    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
+# These are not actually true with Metronome because we're happy to keep
+# on computing time beyond the end of the time limits on both ends
+#        self.assertTrue((time0[unmasked] <= cadence.time[1]).all())
+#        self.assertTrue((time1[unmasked] <= cadence.time[1]).all())
+#        self.assertTrue((time0[unmasked] <= time[unmasked]).all())
+    self.assertTrue((time1[unmasked] >= time[unmasked]).all())
+
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(time0.mask) == mask)
+    self.assertTrue(Boolean(time1.mask) == mask)
+
+    # time_shift()
+    shifted = cadence.time_shift(1.)
+    time_shifted = shifted.time_at_tstep(tstep, remask=False)
+
+    self.assertTrue((abs(time_shifted-time-1.) < 1.e-13).all())
+
+    ############################################
+    # Converted-to-continuous case
+    # We just do spot-checking here
+    ############################################
+
+    cadence = cadence.as_continuous()
+    self.assertTrue(cadence.is_continuous)
+
+    # time_at_tstep()
+    self.assertEqual(cadence.time_at_tstep(0), 100.)
+    self.assertEqual(cadence.time_at_tstep(1), 110.)
+
+    tstep = ([0,1],[2,3],[3,3])
+    time  = ([100,110],[120,130],[130,130])
+    self.assertEqual(cadence.time_at_tstep(tstep), time)
+
+    tstep = ([-1,0],[2,4],[4.5,5])
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(test.mask) ==
+                    [[True,False],[False,False],[True,True]])
+
+    self.assertEqual(cadence.time_at_tstep(0.5), 105.)
+
+############################################
+# Non-unique case
+# 100-140, 110-150, 120-160, 130-170
+############################################
+
+def case_non_unique(self, cadence):
+
+    self.assertTrue(cadence.is_continuous)
+    self.assertFalse(cadence.is_unique)
+
+    # time_at_tstep()
+    self.assertEqual(cadence.time_at_tstep(0), 100.)
+    self.assertEqual(cadence.time_at_tstep(1), 110.)
+    self.assertEqual(cadence.time_at_tstep(1.025), 111.)
+    self.assertEqual(cadence.time_at_tstep(1.975), 149.)
+    self.assertEqual(cadence.time_at_tstep((3,4)), (130.,170.))
+    self.assertEqual(cadence.time_at_tstep(3.5,), 150.)
+
+    tstep = ([0,1],[2,3],[3,4])
+    time  = ([100,110],[120,130],[130,170])
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), time)
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), time)
+
+    tstep = ([-1,0],[2,4],[4.5,5])
+    test = cadence.time_at_tstep(tstep, remask=False)
+    self.assertEqual(test.masked(), 0)
+    test = cadence.time_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(test.mask) ==
+                    [[True,False],[False,False],[True,True]])
+
+    # time_at_tstep(), derivs
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
+                     [False,True,False])
+
+    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
+                     (80, Scalar.MASKED, 160))
+
+    tstep = Scalar((0.,1.,2.))
+    tstep.insert_deriv('t', Scalar((2,3,4)))
+    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
+                     [(0,40), (80,120), (160,200)])
+
+    # time_is_inside()
+    time  = ([99,100],[150,170],[171,200])
+    self.assertTrue(cadence.time_is_inside(time) ==
+                    [[False,True],[True,True],[False,False]])
+    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
+                    [[False,True],[True,False],[False,False]])
+
+    # tstep_at_time()
+    self.assertEqual(cadence.tstep_at_time(100.), 0.)
+    self.assertEqual(cadence.tstep_at_time(105.), 0.125)
+    self.assertEqual(cadence.tstep_at_time(110.), 1.)
+    self.assertEqual(cadence.tstep_at_time(140.), 3.25)
+
+    self.assertEqual(cadence.tstep_at_time(170., inclusive=True), 4.)
+    self.assertEqual(cadence.tstep_at_time(170., remask=True,
+                                                 inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(170., remask=False,
+                                                 inclusive=False), 4.)
+    self.assertEqual(cadence.tstep_at_time(171., remask=True), Scalar.MASKED)
+
+    time = Scalar((100.,110.,120.), [False,True,False])
+    self.assertEqual(cadence.tstep_at_time(time), (0., Scalar.MASKED, 2.))
+
+    # tstep_range_at_time()
+    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
+    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
+    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(135.), (0,4))
+    self.assertEqual(cadence.tstep_range_at_time(140.), (1,4))
+    self.assertEqual(cadence.tstep_range_at_time(159.), (2,4))
+    self.assertEqual(cadence.tstep_range_at_time(160.), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=True ), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(170., inclusive=False,
+                                                       remask=True), MASKED_TUPLE)
+
+    time = Scalar(90 + 90. * np.random.rand(100))   # 90 to 180
+    (tstep_min, tstep_max) = cadence.tstep_range_at_time(time, remask=True)
+    self.assertEqual(Boolean(tstep_min.mask), tstep_max.mask)
+    outside = (time < 100.) | (time > 170.)
+    self.assertEqual(Boolean(tstep_min.mask), outside)
+
+    for t in time:
+        tstep_min, tstep_max = cadence.tstep_range_at_time(t)
+        for tstep in range(tstep_min.vals, tstep_max.vals):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertTrue(time0 < t < time1)
+        for tstep in range(0, tstep_min.vals):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertFalse(time0 < t < time1)
+        for tstep in range(tstep_max.vals, cadence.steps):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertFalse(time0 < t < time1)
+
+    # time_range_at_tstep()
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[0].mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[1].mask),
+                     [False,True,False])
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+
+    time = cadence.time_at_tstep(tstep, remask=True)
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
+    self.assertTrue((time - time0 >= 0.)[~time.mask].all())
+    self.assertTrue((time1 - time >= 0.)[~time.mask].all())
+    self.assertTrue(cadence.time_is_inside(time[~time.mask]).all())
+
+    mask = (tstep.vals < 0) | (tstep.vals > cadence.steps)
+    self.assertTrue(np.all(mask == time.mask))
+
+    unmasked = ~mask
+    self.assertTrue((time0[unmasked] >= cadence.time[0]).all())
+    self.assertTrue((time1[unmasked] >= cadence.time[0]).all())
+
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=True)
+    self.assertTrue(Boolean(time0.mask) == mask)
+    self.assertTrue(Boolean(time1.mask) == mask)
+
+    # time_shift()
+    shifted = cadence.time_shift(1.)
+    time_shifted = shifted.time_at_tstep(tstep, remask=False)
+
+    self.assertTrue((abs(time_shifted-time-1.)[~time.mask] < 1.e-13).all())
+
+############################################
+# Partial overlap case
+# 100-140, 130-170, 160-200, 190-230
+############################################
+
+def case_partial_overlap(self, cadence):
+
+    self.assertTrue(cadence.is_continuous)
+    self.assertFalse(cadence.is_unique)
+
+    # time_at_tstep()
+    self.assertEqual(cadence.time_at_tstep(0), 100.)
+    self.assertEqual(cadence.time_at_tstep(1), 130.)
+    self.assertEqual(cadence.time_at_tstep(1.025), 131.)
+    self.assertEqual(cadence.time_at_tstep(1.975), 169.)
+    self.assertEqual(cadence.time_at_tstep((3,4)), (190.,230.))
+    self.assertEqual(cadence.time_at_tstep(3.5,), 210.)
+
+    # time_at_tstep(), derivs
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=True).mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_at_tstep(tstep, remask=False).mask),
+                     [False,True,False])
+
+    tstep.insert_deriv('t', Scalar((2,3,4), tstep.mask))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt,
+                     (80, Scalar.MASKED, 160))
+
+    tstep = Scalar((0.,1.,2.))
+    tstep.insert_deriv('t', Scalar((2,3,4)))
+    tstep.insert_deriv('xy', Scalar(np.arange(6).reshape(3,2), drank=1))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dxy,
+                     [(0,40), (80,120), (160,200)])
+
+    # time_range_at_tstep()
+    tstep = Scalar((0.,1.,2.), [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[0].mask),
+                     [False,True,False])
+    self.assertEqual(Boolean(cadence.time_range_at_tstep(tstep,
+                                                         remask=True)[1].mask),
+                     [False,True,False])
+    tstep = Scalar(7 * np.random.rand(100,100) - 1.)
+    time = cadence.time_at_tstep(tstep, remask=True)
+    (time0, time1) = cadence.time_range_at_tstep(tstep, remask=False)
+    self.assertTrue((time - time0 >= 0.)[~time.mask].all())
+    self.assertTrue((time1 - time >= 0.)[~time.mask].all())
 
     # time_is_inside()
-    self.assertEqual(cad.time_is_inside([1000,2000], inclusive=True ), [1,1])
-    self.assertEqual(cad.time_is_inside([1000,2000], inclusive=False), [1,0])
+    time  = ([99,100],[150,230],[241,260])
+    self.assertTrue(cadence.time_is_inside(time) ==
+                    [[False,True],[True,True],[False,False]])
+    self.assertTrue(cadence.time_is_inside(time, inclusive=False) ==
+                    [[False,True],[True,False],[False,False]])
+
+    # tstep_at_time()
+    self.assertEqual(cadence.tstep_at_time(100.), 0.)
+    self.assertEqual(cadence.tstep_at_time(110.), 0.25)
+    self.assertEqual(cadence.tstep_at_time(135.), 1.125)
+
+    self.assertEqual(cadence.tstep_at_time(230., inclusive=True), 4.)
+    self.assertEqual(cadence.tstep_at_time(230., remask=True,
+                                                 inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(231., remask=True), Scalar.MASKED)
+
+    time = Scalar((100.,130.,160.), [False,True,False])
+    self.assertEqual(cadence.tstep_at_time(time), (0., Scalar.MASKED, 2.))
+
+    # tstep_range_at_time()
+    MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
+    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
+    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(136.), (0,2))
+    self.assertEqual(cadence.tstep_range_at_time(170.), (2,3))
+    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=True ), (3,4))
+    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=False), (3,3))
+    self.assertEqual(cadence.tstep_range_at_time(230., inclusive=False,
+                                                        remask=True), MASKED_TUPLE)
+
+    time = Scalar(90 + (240-90) * np.random.rand(100))  # 90 to 240
+    (tstep_min, tstep_max) = cadence.tstep_range_at_time(time, remask=True)
+    self.assertEqual(Boolean(tstep_min.mask), tstep_max.mask)
+    outside = (time < 100.) | (time > 230.)
+    self.assertEqual(Boolean(tstep_min.mask), outside)
+
+    for t in time:
+        tstep_min, tstep_max = cadence.tstep_range_at_time(t)
+        for tstep in range(tstep_min.vals, tstep_max.vals):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertTrue(time0 < t < time1)
+        for tstep in range(0, tstep_min.vals):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertFalse(time0 < t < time1)
+        for tstep in range(tstep_max.vals, cadence.steps):
+            time0, time1 = cadence.time_range_at_tstep(tstep)
+            self.assertFalse(time0 < t < time1)
+
+############################################
+# One time step, 100-110
+############################################
 
-def case_tdicadence_10_100_10_1(self, cad):
+def one_time_step(self, cadence):
 
-    self.assertTrue(cad.is_continuous)
-    self.assertTrue(cad.is_unique)
+    self.assertTrue(cadence.is_continuous)
+    self.assertTrue(cadence.is_unique)
 
     # time_at_tstep()
-    self.assertEqual(cad.time_at_tstep(-0.1), 100.)
-    self.assertEqual(cad.time_at_tstep(-0.1, remask=False), 100.)
-    self.assertEqual(cad.time_at_tstep(-0.1, remask=True ), Scalar.MASKED)
-    self.assertEqual(cad.time_at_tstep( 0  ), 100.)
-    self.assertEqual(cad.time_at_tstep( 9.5), 105.)
-    self.assertEqual(cad.time_at_tstep(10, remask=False), 110.)
-    self.assertEqual(cad.time_at_tstep(10, remask=True ), 110.)
-    self.assertEqual(cad.time_at_tstep(10, remask=True, inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.time_at_tstep(-0.1), 100.)
+    self.assertEqual(cadence.time_at_tstep(-0.1, remask=False), 100.)
+    self.assertEqual(cadence.time_at_tstep(-0.1, remask=True ), Scalar.MASKED)
+    self.assertEqual(cadence.time_at_tstep( 0  ), 100.)
+    self.assertEqual(cadence.time_at_tstep( 0.5), 105.)
+    self.assertEqual(cadence.time_at_tstep( 1, remask=False), 110.)
+    self.assertEqual(cadence.time_at_tstep( 1, remask=True ), 110.)
+    self.assertEqual(cadence.time_at_tstep(1, remask=True, inclusive=False), Scalar.MASKED)
 
     # time_at_tstep(), derivs
-    tstep = Scalar((0., 0.5, 10., 20.))
+    tstep = Scalar((0., 0.5, 1., 2.))
     tstep.insert_deriv('t', Scalar((2,3,4,5)))
 
-    self.assertEqual(cad.time_at_tstep(tstep, remask=False), (100,105,110,110))
-    self.assertEqual(cad.time_at_tstep(tstep, remask=True), (100,105,110,Scalar.MASKED))
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True).d_dt, (20,30,40,0))
-    self.assertEqual(cad.time_at_tstep(tstep, derivs=True, inclusive=False).d_dt, (20,30,0,0))
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=False), (100,105,110,110))
+    self.assertEqual(cadence.time_at_tstep(tstep, remask=True), (100,105,110,Scalar.MASKED))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True).d_dt, (20,30,40,0))
+    self.assertEqual(cadence.time_at_tstep(tstep, derivs=True, inclusive=False).d_dt, (20,30,0,0))
 
     # time_is_inside()
     time = ([99,100],[120,140],[145,150])
-    self.assertFalse(cad.time_is_inside(90))
-    self.assertTrue (cad.time_is_inside(100))
-    self.assertTrue (cad.time_is_inside(110))
-    self.assertFalse(cad.time_is_inside(110, inclusive=False))
-    self.assertFalse(cad.time_is_inside(111))
+    self.assertFalse(cadence.time_is_inside(90))
+    self.assertTrue (cadence.time_is_inside(100))
+    self.assertTrue (cadence.time_is_inside(110))
+    self.assertFalse(cadence.time_is_inside(110, inclusive=False))
+    self.assertFalse(cadence.time_is_inside(111))
 
     # tstep_at_time()
-    self.assertEqual(cad.tstep_at_time( 99), 0.)
-    self.assertEqual(cad.tstep_at_time( 99, remask=True), Scalar.MASKED)
-    self.assertEqual(cad.tstep_at_time(100), 0.)
-    self.assertEqual(cad.tstep_at_time(105), 0.5)
-    self.assertEqual(cad.tstep_at_time(110), 1.)
-    self.assertEqual(cad.tstep_at_time(110, remask=True), 1.)
-    self.assertEqual(cad.tstep_at_time(110, remask=True, inclusive=False), Scalar.MASKED)
-    self.assertEqual(cad.tstep_at_time(111), 1.)
-    self.assertEqual(cad.tstep_at_time(111, remask=True), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time( 99), 0.)
+    self.assertEqual(cadence.tstep_at_time( 99, remask=True), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(100), 0.)
+    self.assertEqual(cadence.tstep_at_time(105), 0.5)
+    self.assertEqual(cadence.tstep_at_time(110), 1.)
+    self.assertEqual(cadence.tstep_at_time(110, remask=True), 1.)
+    self.assertEqual(cadence.tstep_at_time(110, remask=True, inclusive=False), Scalar.MASKED)
+    self.assertEqual(cadence.tstep_at_time(111), 1.)
+    self.assertEqual(cadence.tstep_at_time(111, remask=True), Scalar.MASKED)
 
     # tstep_at_time(), derivs
     time = Scalar((90,100,110,140), derivs={'t': Scalar((100,200,300,400))})
-    self.assertEqual(cad.tstep_at_time(time, remask=False, derivs=True).d_dt, (0, 20, 30, 0))
-    self.assertEqual(cad.tstep_at_time(time, remask=False, derivs=True,
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True).d_dt, (0, 20, 30, 0))
+    self.assertEqual(cadence.tstep_at_time(time, remask=False, derivs=True,
                                                  inclusive=False).d_dt, (0, 20, 0, 0))
 
     # tstep_range_at_time()
     MASKED_TUPLE = (Scalar.MASKED, Scalar.MASKED)
-    self.assertEqual(cad.tstep_range_at_time( 99.), (0,0))
-    self.assertEqual(cad.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
-    self.assertEqual(cad.tstep_range_at_time(100.), (0,10))
-    self.assertEqual(cad.tstep_range_at_time(105.), (0,10))
-    self.assertEqual(cad.tstep_range_at_time(110.), (0,10))
-    self.assertEqual(cad.tstep_range_at_time(110., remask=True), (0,10))
-    self.assertEqual(cad.tstep_range_at_time(110., remask=True, inclusive=False), MASKED_TUPLE)
-    self.assertEqual(cad.tstep_range_at_time(135., remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time( 99.), (0,0))
+    self.assertEqual(cadence.tstep_range_at_time( 99., remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(100.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(105.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(110.), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(110., remask=True), (0,1))
+    self.assertEqual(cadence.tstep_range_at_time(110., remask=True, inclusive=False), MASKED_TUPLE)
+    self.assertEqual(cadence.tstep_range_at_time(135., remask=True), MASKED_TUPLE)
 
-    tstep0, tstep1 = cad.tstep_range_at_time(110., inclusive=False)
+    tstep0, tstep1 = cadence.tstep_range_at_time(110., inclusive=False)
     self.assertEqual(tstep0, tstep1)    # indicates zero range
 
-    tstep0, tstep1 = cad.tstep_range_at_time(135.)
+    tstep0, tstep1 = cadence.tstep_range_at_time(135.)
     self.assertEqual(tstep0, tstep1)
 
     # time_range_at_tstep()
-    tstep = Scalar((-1,0,0.5,10,12))
-    self.assertEqual(cad.time_range_at_tstep(tstep)[0], 5*[100])
-    self.assertEqual(cad.time_range_at_tstep(tstep)[1], 5*[110])
-
-    self.assertEqual(cad.time_range_at_tstep(tstep[0], remask=True), MASKED_TUPLE)
-    self.assertEqual(cad.time_range_at_tstep(tstep[1:4], remask=True)[0], 3*[100])
-    self.assertEqual(cad.time_range_at_tstep(tstep[1:4], remask=True)[1], 3*[110])
-    self.assertEqual(cad.time_range_at_tstep(tstep[4], remask=True), MASKED_TUPLE)
+    tstep = Scalar((-1,0,0.5,1,2))
+    self.assertEqual(cadence.time_range_at_tstep(tstep)[0], 5*[100])
+    self.assertEqual(cadence.time_range_at_tstep(tstep)[1], 5*[110])
+
+    self.assertEqual(cadence.time_range_at_tstep(tstep[0], remask=True), MASKED_TUPLE)
+    self.assertEqual(cadence.time_range_at_tstep(tstep[1:4], remask=True)[0], 3*[100])
+    self.assertEqual(cadence.time_range_at_tstep(tstep[1:4], remask=True)[1], 3*[110])
+    self.assertEqual(cadence.time_range_at_tstep(tstep[4], remask=True), MASKED_TUPLE)
 
-    self.assertEqual(cad.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[0], 2*[100])
-    self.assertEqual(cad.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[1], 2*[110])
+    self.assertEqual(cadence.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[0], 2*[100])
+    self.assertEqual(cadence.time_range_at_tstep(tstep[1:3], remask=True, inclusive=False)[1], 2*[110])
 
-    self.assertEqual(cad.time_range_at_tstep(tstep[3], remask=True, inclusive=False), MASKED_TUPLE)
+    self.assertEqual(cadence.time_range_at_tstep(tstep[3], remask=True, inclusive=False), MASKED_TUPLE)
 
     # tstride_at_tstep
-    self.assertEqual(cad.tstride_at_tstep(0), 0)
-    self.assertEqual(cad.tstride_at_tstep(0.5), 0)
-    self.assertEqual(cad.tstride_at_tstep(9), 10)
-    self.assertEqual(cad.tstride_at_tstep(9, sign=-1), 0)
-    self.assertEqual(cad.tstride_at_tstep(10), 10)
+    self.assertEqual(cadence.tstride_at_tstep(0), 10)
+    self.assertEqual(cadence.tstride_at_tstep(0.5), 10)
+    self.assertEqual(cadence.tstride_at_tstep(1), 10)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/calibration/__init__.py` & `rms_oops-0.0.4/oops/calibration/calibration_.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 ################################################################################
-# oops/calibration/__init__.py
+# oops/calibration/calibration_.py
 ################################################################################
 
 import numpy as np
 from polymath import Pair
 
 class Calibration(object):
     """Calibration is an abstract class that defines a relationship between the
@@ -168,24 +168,7 @@
             uv_pair = Pair.as_pair(uv_pair, recursive=False)
             uv = uv_pair.int(self.fov.shape, clip=True)
             return self.fov[uv.vals[...,0], uv.vals[...,1]]
 
         return self.fov.area_factor(uv_pair)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Calibration(unittest.TestCase):
-
-    def runTest(self):
-
-        # No tests here - this is just an abstract superclass
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/calibration/all.py` & `rms_oops-0.0.4/oops/calibration/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,15 +1,11 @@
 ################################################################################
-# oops/calibration/all.py
+# oops/calibration/__init__.py
 ################################################################################
 
-# Import the Calibration class and all its subclasses into a common name space
-
-from oops.calibration                import Calibration
-from oops.calibration.extendedsource import ExtendedSource  # DEPRECATED
-from oops.calibration.flatcalib      import FlatCalib
-from oops.calibration.nullcalib      import NullCalib
-from oops.calibration.pointsource    import PointSource     # DEPRECATED
-from oops.calibration.radiance       import Radiance
-from oops.calibration.rawcounts      import RawCounts
+from oops.calibration.calibration_ import Calibration
+from oops.calibration.flatcalib    import FlatCalib
+from oops.calibration.nullcalib    import NullCalib
+from oops.calibration.radiance     import Radiance
+from oops.calibration.rawcounts    import RawCounts
 
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/calibration/extendedsource.py` & `rms_oops-0.0.4/ideas/deprecated/extendedsource.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/calibration/nullcalib.py` & `rms_oops-0.0.4/oops/calibration/nullcalib.py`

 * *Files 22% similar despite different names*

```diff
@@ -104,22 +104,7 @@
                         incorporated.
         """
 
         # Pre-scaling requires a FlatCalib instead
         return FlatCalib(name or self.name, factor, baseline)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_NullCalib(unittest.TestCase):
-
-    def runTest(self):
-
-        pass
-
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/calibration/pointsource.py` & `rms_oops-0.0.4/ideas/deprecated/pointsource.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/config.py` & `rms_oops-0.0.4/oops/config.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/constants.py` & `rms_oops-0.0.4/oops/constants.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/event.py` & `rms_oops-0.0.4/oops/event.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 ################################################################################
 # oops/event.py: Event class
 ################################################################################
 
 import numpy as np
 
-from polymath       import Qube, Scalar, Vector3
-from oops.config    import EVENT_CONFIG, LOGGING
-from oops.constants import C_INVERSE
-from oops.frame     import Frame
-from oops.transform import Transform
+from polymath          import Qube, Scalar, Vector3
+from oops.config       import EVENT_CONFIG, LOGGING
+from oops.constants    import C_INVERSE
+from oops.frame.frame_ import Frame
+from oops.transform    import Transform
 
 class Event(object):
     """An Event is defined by a time, position and velocity. It always has these
     attributes:
 
         _time_      event time as a Scalar of arbitrary shape. Times are
                     measured in seconds TDB relative to noon TDB on January 1,
@@ -99,19 +99,19 @@
     define the photon directions with either apparent or actual values, but not
     both; whichever you define, the other will be generated as needed.
 
     Note that the attributes of an object need not have the same shape, but they
     must all be broadcastable to the same shape.
     """
 
-    ############################################################################
-    # Note:
-    # Class constant Event.PATH_CLASS is defined at the end of __init__.py
-    ############################################################################
+    # To avoid circular imports; filled in by oops/__init__.py
+    PATH_CLASS = None
+    SSB = None
 
+    # Property names, categorized
     ARR_VEC3_PROPERTIES = ['arr', 'arr_ap', 'arr_j2000', 'arr_ap_j2000',
                    'neg_arr', 'neg_arr_ap', 'neg_arr_j2000', 'neg_arr_ap_j2000']
 
     DEP_VEC3_PROPERTIES = ['dep', 'dep_ap', 'dep_j2000', 'dep_ap_j2000']
 
     SPECIAL_PROPERTIES = ARR_VEC3_PROPERTIES + DEP_VEC3_PROPERTIES
     SPECIAL_PROPERTIES += ['arr_lt', 'dep_lt', 'perp', 'vflat']
@@ -360,16 +360,15 @@
         """Transform that rotates from event coordinates to J2000 coordinates.
         """
 
         if self._xform_to_j2000_ is None:
             if self._ssb_ is None:
                 _ = self.wrt_ssb(derivs=True)
             else:
-                self._xform_to_j2000_ = self.wrt(Event.PATH_CLASS.SSB,
-                                                 Frame.J2000,
+                self._xform_to_j2000_ = self.wrt(Event.SSB, Frame.J2000,
                                                  derivs=True, quick={},
                                                  include_xform=True)[1]
 
         return self._xform_to_j2000_
 
     @property
     def wod(self):
@@ -999,20 +998,18 @@
         # Change the origin or frame if requested
         if origin:
             result._origin_ = origin
         if frame:
             result._frame_ = frame
 
         # Fill in _ssb_, also masked
-        if (result._origin_ == Event.PATH_CLASS.SSB and
-            result._frame_ == Frame.J2000):
+        if (result._origin_ == Event.SSB and result._frame_ == Frame.J2000):
                 result._ssb_ == result
         else:
-                result._ssb_ = result.all_masked(Event.PATH_CLASS.SSB,
-                                                  Frame.J2000)
+                result._ssb_ = result.all_masked(Event.SSB, Frame.J2000)
                 result._ssb_._xform_to_j2000_ = Transform.IDENTITY
 
         if result._xform_to_j2000_ is None:
             result._xform_to_j2000_ = Transform.IDENTITY
 
         return result
 
@@ -1276,27 +1273,25 @@
 
         if self._ssb_ is not None:
             if derivs:
                 return self._ssb_
             else:
                 return self._ssb_.wod
 
-        if (self._origin_ == Event.PATH_CLASS.SSB) and \
-           (self._frame_ == Frame.J2000):
+        if self._origin_ == Event.SSB and self._frame_ == Frame.J2000:
                 self._ssb_ = self
                 self._ssb_._ssb_ = self
                 self._xform_to_j2000_ = Transform.identity(Frame.J2000)
                 if derivs:
                     return self._ssb_
                 else:
                     return self._ssb_.wod
 
         (self._ssb_,
-         self._xform_to_j2000_) = self.wrt(Event.PATH_CLASS.SSB,
-                                           Frame.J2000,
+         self._xform_to_j2000_) = self.wrt(Event.SSB, Frame.J2000,
                                            derivs=derivs, quick=quick,
                                            include_xform=True)
 
         if self._ssb_ is not self:
             self._ssb_._ssb_ = self._ssb_
             self._ssb_._xform_to_j2000_ = Transform.IDENTITY
 
@@ -1319,15 +1314,15 @@
                         retained.
             quick       an optional dictionary to override the configured
                         default parameters for QuickPaths and QuickFrames; False
                         to disable the use of QuickPaths and QuickFrames. The
                         default configuration is defined in config.py.
         """
 
-        if self._frame_ != Frame.J2000 or self._origin_ != Event.PATH_CLASS.SSB:
+        if self._frame_ != Frame.J2000 or self._origin_ != Event.SSB:
             raise ValueError('Event.from_ssb requires a SSB/J2000 event')
 
         event = self.wrt(path, frame, derivs=True, quick=quick)
         event._ssb_ = self
         event._ssb_._ssb_ = self
 
         if derivs:
@@ -2104,733 +2099,7 @@
         if ray is None:
             raise ValueError('Undefined light ray vector in ' + str(self))
 
         # Convert to RA and dec
         return ray.to_ra_dec_length(recursive=derivs)[:2]
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-from oops.constants import RPD, C
-
-class Test_Event(unittest.TestCase):
-
-    def setUp(self):
-        from oops.body import Body
-        Body.reset_registry()
-        Body.define_solar_system('1990-01-01', '2010-01-01')
-
-    def tearDown(self):
-        pass
-
-    def runTest(self):
-        import cspyce
-
-        np.random.seed(5531)
-
-        # This is the exact formula for stellar aberration
-        #   beta = v/c
-        #   angle is measured from the direction of motion to the actual (not
-        #       time-reversed) direction of the incoming ray.
-        def aberrate(angle, beta):
-            tan_half_angle_prime = np.sqrt((1.+beta) /
-                                           (1.-beta)) * np.tan(angle/2.)
-            return 2. * np.arctan(tan_half_angle_prime)
-
-        def unaberrate(angle_prime, beta):
-            tan_half_angle = np.sqrt((1.+beta) /
-                                     (1.-beta)) * np.tan(angle_prime/2.)
-            return 2. * np.arctan(tan_half_angle)
-
-        # Test against the approximation sin(delta) = beta * sin(angle)
-        # where angle_prime = angle + delta
-        BETA = 0.001
-        angles = np.arange(181.) * RPD
-        exact_prime = aberrate(angles, BETA)
-        delta = exact_prime - angles
-        for k in range(181):
-            self.assertTrue(abs(np.sin(delta[k]) - BETA * np.sin(angles[k])) <
-                            1.e-6)
-
-        ########################################################################
-        # Test aberration magnitudes and directions to first order
-        ########################################################################
-
-        BETA = 0.001
-        DEL = 3.e-9
-        SPEED = BETA * C        # largest speed we care about is 300 km/s
-        HALFPI = np.pi/2
-
-        # Incoming aberration in the forward direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), 'SSB', 'J2000')
-        ev.arr = -Vector3.ZAXIS
-        self.assertEqual(Vector3.ZAXIS.sep(ev.neg_arr_ap), 0.)
-
-        # Incoming aberration in the side direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.arr = -Vector3.YAXIS
-        self.assertTrue(abs(Vector3.XAXIS.sep(ev.neg_arr_ap) - (HALFPI-BETA)) < DEL)
-
-        # Outgoing aberration in the forward direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.dep = Vector3.XAXIS
-        self.assertEqual(Vector3.XAXIS.sep(ev.dep_ap), 0.)
-
-        # Incoming aberration in the side direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.dep = Vector3.YAXIS
-        self.assertTrue(abs(Vector3.XAXIS.sep(ev.dep_ap) - (HALFPI+BETA)) < DEL)
-
-        # Incoming aberration in the forward direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.arr_ap = -Vector3.XAXIS
-        self.assertEqual(Vector3.XAXIS.sep(ev.neg_arr_ap), 0.)
-
-        # Incoming aberration in the side direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.arr_ap = -Vector3.YAXIS
-        self.assertTrue(abs(Vector3.XAXIS.sep(ev.neg_arr) - (HALFPI+BETA)) < DEL)
-
-        # Outgoing aberration in the forward direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.dep = Vector3.XAXIS
-        self.assertEqual(Vector3.XAXIS.sep(ev.dep_ap), 0.)
-
-        # Incoming aberration in the side direction
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ev.dep_ap = Vector3.YAXIS
-        self.assertTrue(abs(Vector3.XAXIS.sep(ev.dep) - (HALFPI-BETA)) < DEL)
-
-        ########################################################################
-        # Test compatibility with SPICE toolkit and with the exact calculation
-        ########################################################################
-
-        angles = np.arange(181.)
-        cspyce_arr_ap = []
-        cspyce_dep_ap = []
-        for angle in angles:
-            vobs = np.array([SPEED, 0., 0.])
-
-            # Note the sign change on pobj, because we consider the photon's
-            # direction, not the direction to the target
-            pobj = np.array([-np.cos(angle * RPD),
-                             -np.sin(angle * RPD), 0.])
-            appobj = cspyce.stelab(pobj, vobs)
-            cspyce_arr_ap.append(np.arctan2(-appobj[1], -appobj[0]))
-
-            pobj = np.array([np.cos(angle * RPD),
-                             np.sin(angle * RPD), 0.])
-            appobj = cspyce.stlabx(pobj, vobs)
-            cspyce_dep_ap.append(np.arctan2(appobj[1], appobj[0]))
-
-        ev = Event(0., (Vector3.ZERO, SPEED * Vector3.XAXIS), 'SSB', 'J2000')
-        ray = Vector3.from_scalars(np.cos(angles * RPD),
-                                   np.sin(angles * RPD), 0.)
-        ev.arr = ray
-        ev.dep = ray
-
-        exact_arr_ap = aberrate(angles * RPD, BETA)
-        exact_dep_ap = aberrate(angles * RPD, BETA)
-
-        for k in range(181):
-            arr_ap = np.arctan2(ev.arr_ap[k].vals[1], ev.arr_ap[k].vals[0])
-            self.assertTrue(abs(cspyce_arr_ap[k] - exact_arr_ap[k]) < 1.e-6)
-            self.assertTrue(abs(arr_ap - exact_arr_ap[k]) < 1.e-15)
-
-        for k in range(181):
-            dep_ap = np.arctan2(ev.dep_ap[k].vals[1], ev.dep_ap[k].vals[0])
-            self.assertTrue(abs(cspyce_dep_ap[k] - exact_dep_ap[k]) < 1.e-6)
-            self.assertTrue(abs(dep_ap - exact_dep_ap[k]) < 1.e-15)
-
-        ########################################################################
-        # Test aberration inversions
-        ########################################################################
-
-        COUNT = 2000
-        ev1 = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), 'SSB', 'J2000')
-        ev1.arr_ap = Vector3.from_scalars(np.random.randn(COUNT),
-                                          np.random.randn(COUNT),
-                                          np.random.randn(COUNT))
-        ev1.dep_ap = Vector3.from_scalars(np.random.randn(COUNT),
-                                          np.random.randn(COUNT),
-                                          np.random.randn(COUNT))
-
-        ev2 = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), 'SSB', 'J2000')
-        ev2.arr = ev1.arr
-        ev2.dep = ev1.dep
-
-        self.assertTrue((ev2.arr_ap.unit() -
-                         ev1.arr_ap.unit()).norm().max() < 1.e-15)
-
-        ev1 = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), 'SSB', 'J2000')
-        ev1.arr = Vector3.from_scalars(np.random.randn(COUNT),
-                                       np.random.randn(COUNT),
-                                       np.random.randn(COUNT))
-        ev1.dep = Vector3.from_scalars(np.random.randn(COUNT),
-                                       np.random.randn(COUNT),
-                                       np.random.randn(COUNT))
-
-        ev2 = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), 'SSB', 'J2000')
-        ev2.arr_ap = ev1.arr_ap
-        ev2.dep_ap = ev1.dep_ap
-
-        self.assertTrue((ev2.arr_ap.unit() -
-                         ev1.arr_ap.unit()).norm().max() < 1.e-15)
-
-        ########################################################################
-        # Subfield checks
-        ########################################################################
-
-        for (origin, frame) in [('SSB', 'J2000'),
-                                ('EARTH', 'IAU_EARTH'),
-                                ('PLUTO', 'IAU_EARTH')]:
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ########################
-            # Define arr
-            ########################
-
-            ev.arr = (1,2,3)
-            self.assertEqual(ev._arr_, Vector3((1.,2.,3.)))
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            self.assertIsNone(ev._neg_arr_)
-            self.assertEqual(ev.neg_arr, Vector3((-1.,-2.,-3.)))
-            self.assertIs(ev.neg_arr, ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.neg_arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            # Let arr_ap and ssb be filled in
-            _ = ev.arr_ap
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define arr_ap
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.arr_ap = (1,2,3)
-            self.assertEqual(ev._arr_ap_, Vector3((1.,2.,3.)))
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            self.assertEqual(ev.neg_arr_ap, Vector3((-1.,-2.,-3.)))
-            self.assertEqual(ev._arr_ap_, Vector3((1.,2.,3.)))
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._ssb_)
-
-            # Let arr and ssb be filled in
-            _ = ev.arr
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertIs(ev.arr_j2000, ev.arr)
-                self.assertIs(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define arr_j2000
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.arr_j2000 = (1,2,3)
-            self.assertIsNotNone(ev._ssb_)
-            self.assertEqual(ev.ssb._arr_, Vector3((1.,2.,3.)))
-            self.assertIsNone(ev.ssb._arr_ap_)
-            self.assertIsNone(ev.ssb._neg_arr_)
-            self.assertIsNone(ev.ssb._neg_arr_ap_)
-
-            self.assertIsNotNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNotNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            try:
-                ev.neg_arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            # Let arr_ap and ssb be filled in
-            _ = ev.arr_ap
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define arr_ap_j2000
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.arr_ap_j2000 = (1,2,3)
-            self.assertIsNotNone(ev._ssb_)
-            self.assertEqual(ev.ssb._arr_ap_, Vector3((1.,2.,3.)))
-            self.assertIsNone(ev.ssb._arr_)
-            self.assertIsNone(ev.ssb._neg_arr_)
-            self.assertIsNone(ev.ssb._neg_arr_ap_)
-
-            self.assertIsNotNone(ev._arr_ap_)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNotNone(ev._arr_ap_)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            try:
-                ev.neg_arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-
-            # Let arr and ssb be filled in
-            _ = ev.arr_ap
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define neg_arr
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.neg_arr = (-1,-2,-3)
-            self.assertEqual(ev._arr_, Vector3((1.,2.,3.)))
-            self.assertEqual(ev._neg_arr_, Vector3((-1.,-2.,-3.)))
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.neg_arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            # Let arr_ap and ssb be filled in
-            _ = ev.arr_ap
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define neg_arr_ap
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.neg_arr_ap = (-1,-2,-3)
-            self.assertEqual(ev._arr_ap_, Vector3((1.,2.,3.)))
-            self.assertEqual(ev._neg_arr_ap_, Vector3((-1.,-2.,-3.)))
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.neg_arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._ssb_)
-
-            # Let arr and ssb be filled in
-            _ = ev.arr
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define neg_arr_j2000
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.neg_arr_j2000 = (-1,-2,-3)
-            self.assertIsNotNone(ev._ssb_)
-            self.assertEqual(ev.ssb._arr_, Vector3((1.,2.,3.)))
-            self.assertEqual(ev.ssb._neg_arr_, Vector3((-1.,-2.,-3.)))
-            self.assertIsNone(ev.ssb._arr_ap_)
-            self.assertIsNone(ev.ssb._neg_arr_ap_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.neg_arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            # Let arr_ap and ssb be filled in
-            _ = ev.arr_ap
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define neg_arr_ap_j2000
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._arr_)
-            self.assertIsNone(ev._arr_ap_)
-            self.assertIsNone(ev._neg_arr_)
-            self.assertIsNone(ev._neg_arr_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            ev.neg_arr_ap_j2000 = (-1,-2,-3)
-            self.assertIsNotNone(ev._ssb_)
-            self.assertEqual(ev.ssb._arr_ap_, Vector3((1.,2.,3.)))
-            self.assertEqual(ev.ssb._neg_arr_ap_, Vector3((-1.,-2.,-3.)))
-            self.assertIsNotNone(ev.ssb._arr_ap_)
-            self.assertIsNotNone(ev.ssb._neg_arr_ap_)
-
-            try:
-                ev.arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.arr_ap = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            try:
-                ev.neg_arr = (1,2,3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            # Let arr and ssb be filled in
-            _ = ev.arr
-            self.assertTrue((ev.arr_ap - ev.arr).norm() < 5*BETA)
-            self.assertEqual(ev.neg_arr, -ev.arr)
-            self.assertEqual(ev.neg_arr_ap, -ev.arr_ap)
-            self.assertEqual(ev.neg_arr_j2000, -ev.arr_j2000)
-            self.assertEqual(ev.neg_arr_ap_j2000, -ev.arr_ap_j2000)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.arr_j2000, ev.arr)
-                self.assertEqual(ev.arr_ap_j2000, ev.arr_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.arr)
-                self.assertIsNotNone(ev._ssb_.arr_ap)
-
-            ########################
-            # Define dep
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._dep_)
-            self.assertIsNone(ev._dep_ap_)
-
-            ev.dep = (-1,2,-3)
-            self.assertEqual(ev._dep_, Vector3((-1.,2.,-3.)))
-            self.assertIsNone(ev._dep_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.dep_ap = (-1,2,-3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._dep_ap_)
-            self.assertIsNone(ev._ssb_)
-
-            # Fill in dep_ap and ssb
-            _ = ev.dep_ap
-            self.assertTrue((ev.dep_ap - ev.dep).norm() < 5*BETA)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.dep_j2000, ev.dep)
-                self.assertEqual(ev.dep_ap_j2000, ev.dep_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.dep)
-                self.assertIsNotNone(ev._ssb_.dep_ap)
-
-            ########################
-            # Define dep_ap
-            ########################
-
-            ev = Event(0., (Vector3.ZERO, SPEED * Vector3.ZAXIS), origin, frame)
-            self.assertIsNone(ev._dep_)
-            self.assertIsNone(ev._dep_ap_)
-
-            ev.dep_ap = (-1,2,-3)
-            self.assertEqual(ev._dep_ap_, Vector3((-1.,2.,-3.)))
-            self.assertIsNone(ev._dep_)
-            self.assertIsNone(ev._ssb_)
-
-            try:
-                ev.dep_ap = (-1,2,-3)
-                self.assertTrue(False, msg='ValueError not raised')
-            except ValueError:
-                pass
-
-            self.assertIsNone(ev._dep_)
-            self.assertIsNone(ev._ssb_)
-
-            # Fill in dep and ssb
-            _ = ev.dep
-            self.assertTrue((ev.dep_ap - ev.dep).norm() < 5*BETA)
-
-            if (origin, frame) == ('SSB', 'J2000'):
-                self.assertIs(ev, ev._ssb_)
-                self.assertEqual(ev.dep_j2000, ev.dep)
-                self.assertEqual(ev.dep_ap_j2000, ev.dep_ap)
-            else:
-                self.assertIsNotNone(ev._ssb_)
-                self.assertIsNotNone(ev._ssb_.dep)
-                self.assertIsNotNone(ev._ssb_.dep_ap)
-
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fittable.py` & `rms_oops-0.0.4/oops/fittable.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/fov/__init__.py` & `rms_oops-0.0.4/oops/fov/fov_.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
-# oops/fov/__init__.py: Abstract class FOV (Field-of-View)
+# oops/fov/fov_.py: Abstract class FOV (Field-of-View)
 ################################################################################
 
 import numpy as np
+
 from polymath    import Boolean, Scalar, Pair, Vector3, Qube
 from oops.config import AREA_FACTOR
 
 class FOV(object):
     """The FOV (Field of View) abstract class provides a description of the
     geometry of a field of view.
 
@@ -815,35 +816,7 @@
         nearest_fov_uv  = self.nearest_uv(sphere_center_uv)
         nearest_fov_los = self.los_from_uvt(nearest_fov_uv, time=time)
 
         # Allow for the border region when returning True or False
         return nearest_fov_los.sep(sphere_center_los) <= radius_angle + border
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_FOV(unittest.TestCase):
-
-    def runTest(self):
-
-        from oops.fov.flatfov import FlatFOV
-
-        fov = FlatFOV((1/2048.,-1/2048.), (101,101), (50,75))
-
-        # Test offset_angles_from_duv and offset_duv_from_angles
-        uvlist = ([0,0], [0,101], [101,0], [50,75], fov.uv_shape/2., fov.uv_shape)
-        uvlist = [Pair.as_pair(uv) for uv in uvlist]
-
-        for uv0 in uvlist:
-            for uv1 in uvlist:
-                duv = uv1 - uv0
-                angles = fov.offset_angles_from_duv(duv, origin=uv0)
-                test = fov.offset_duv_from_angles(angles, origin=uv0)
-                self.assertLess((test - duv).norm(), 1.e-13)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/all.py` & `rms_oops-0.0.4/oops/fov/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,17 @@
 ################################################################################
-# oops/fov/all.py
+# oops/fov/__init__.py
 ################################################################################
 
-# Import FOV and all its subclasses into a common name space
-
-from oops.fov               import FOV
+from oops.fov.fov_          import FOV
 from oops.fov.barrelfov     import BarrelFOV
 from oops.fov.flatfov       import FlatFOV
 from oops.fov.nullfov       import NullFOV
 from oops.fov.offsetfov     import OffsetFOV
-from oops.fov.polyfov       import PolyFOV
 from oops.fov.polynomialfov import PolynomialFOV
-from oops.fov.radialfov     import RadialFOV
 from oops.fov.slicefov      import SliceFOV
 from oops.fov.subarray      import Subarray
 from oops.fov.subsampledfov import SubsampledFOV
 from oops.fov.tdifov        import TDIFOV
 from oops.fov.wcsfov        import WCSFOV
 
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/barrelfov.py` & `rms_oops-0.0.4/ideas/deprecated/polynomialfov.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,643 +1,659 @@
 ################################################################################
-# oops/fov/barrelfov.py: Barrel distortion subclass of FOV
+# oops/fov/polynomialfov.py: PolynomialFOV subclass of FOV
 ################################################################################
 
-import numpy as np
-import sys
+from __future__ import print_function
 
-from polymath         import Scalar, Pair
-from oops.config      import LOGGING
-from oops.fov         import FOV
-from oops.fov.flatfov import FlatFOV
+import numpy as np
+from polymath import Pair
 
-EPSILON = sys.float_info.epsilon/2.         # actual machine precision
+from oops.fov import FOV
 
-class BarrelFOV(FOV):
+class PolynomialFOV(FOV):
     """Subclass of FOV that describes a field of view in which the distortion is
-    described by a 1-D polynomial in distance from the image center.
+    described by a 2-D polynomial.
+
+    This is the approached used by Space Telescope Science Institute to describe
+    the Hubble instrument fields of view. A PolynomialFOV has no dependence on
+    the optional extra indices that can be associated with time, wavelength
+    band, etc.
     """
 
-    # True to print convergence steps in _solve_polynomial()
-    DEBUG = False
+    DEBUG = False       # True to print(convergence steps on xy_from_uv())
 
     #===========================================================================
-    def __init__(self, uv_scale, uv_shape, coefft_xy_from_uv=None,
+    def __init__(self, uv_shape, coefft_xy_from_uv=None,
                  coefft_uv_from_xy=None, uv_los=None, uv_area=None,
-                 iters=8, fast=True):
-        """Constructor for a BarrelFOV.
+                 iters=8):
+        """Constructor for a PolynomialFOV.
 
         Inputs:
-            uv_scale    a single value, tuple or Pair defining the ratios dx/du
-                        and dy/dv. At the center of the FOV.  For example, if
-                        (u,v) are in units of  arcseconds, then
-                            uv_scale = Pair((pi/180/3600.,pi/180/3600.))
-                        Use the sign of the second element to define the
-                        direction of increasing V: negative for up, positive for
-                        down.
-
             uv_shape    a single value, tuple or Pair defining size of the field
                         of view in pixels. This number can be non-integral if
                         the detector is not composed of a rectangular array of
                         pixels.
 
             coefft_xy_from_uv
-                        the polynomial coefficient array describing the radial
-                        distortion from U,V to X,Y. It is a function of r,
-                        defined as
-                            r = sqrt(((u-uv_los[0]) * uv_scale[0])**2 +
-                                     ((v-uv_los[1]) * uv_scale[1])**2))
-                        In other words, r is in units of radians and measures
-                        the distance from the center of the FOV if there were no
-                        distortion. The polynomial f(r) returns the distorted
-                        distance given the un-distorted distance. Because this
-                        polynomial cannot have a constant term, the coefficients
-                        begin with the linear term, which is typically ~ 1. In
-                        other words, coefft_xy_from_uv[i] is the coefficient on
-                        r**(i+1). If this input is None, the distortion
-                        polynomial for uv_from_xy is inverted.
+                        the coefficient array of the polynomial to convert U,V
+                        to X,Y. The array has shape [order+1,order+1,2], where
+                        coefft[i,j,0] is the coefficient on (u**i * v**j)
+                        yielding x(u,v), and coefft[i,j,1] is the coefficient
+                        yielding y(u,v). All coefficients are 0 for (i+j) >
+                        order. If None, then the polynomial for uv_from_xy is
+                        inverted.
 
             coefft_uv_from_xy
-                        the polynomial coefficient array describing the radial
-                        distortion scale factor from X,Y to U,V. It is a
-                        function of r, defined as
-                            r = sqrt(x**2 + y**2),
-                        in units of radians. The array has shape (order,) under
-                        the assumption that there can be no constant term, so
-                        coefft_uv_from_xy[i] is the coefficient on r**(i+1). The
-                        first coefficient is typically ~ 1, implying no
-                        distortion at the center of the FOV. If None, the
-                        distortion polynomial for xy_from_uv is inverted.
+                        the coefficient array of the polynomial to convert X,Y
+                        to U,V. The array has shape [order+1,order+1,2], where
+                        coefft[i,j,0] is the coefficient on (x**i * y**j)
+                        yielding u(x,y), and coefft[i,j,1] is the coefficient
+                        yielding v(x,y). All coefficients are 0 for (i+j) >
+                        order. If None, then the polynomial for xy_from_uv is
+                        inverted.
 
             uv_los      a single value, tuple or Pair defining the (u,v)
                         coordinates of the nominal line of sight. By default,
                         this is the midpoint of the rectangle, i.e, uv_shape/2.
 
             uv_area     an optional parameter defining the nominal area of a
                         pixel in steradians after distortion has been removed.
 
             iters       the number of iterations of Newton's method to use when
-                        inverting the distortion polynomial.
-
-            fast        if True and both sets of coefficients are provided, the
-                        polynomials will be used in both directions, meaning
-                        that the conversions xy_from_uv and uv_from_xy might be
-                        inconsistent, although probably at the sub-pixel level.
-                        If False, then uv_from_xy is refined further using one
-                        or two steps of Newton's method, which provides
-                        consistency at the level of machine precision, but
-                        uv_from_xy will be somewhat slower.
+                        inverting the polynomial.
         """
 
         self.coefft_xy_from_uv = None
         self.coefft_uv_from_xy = None
 
-        # Save the coefficients
-        #
-        # The function we evaluate is actually polynomial(r)/r, which is very well
-        # behaved (nearly constant) in both directions.
-
         if coefft_xy_from_uv is not None:
-            order = len(coefft_xy_from_uv)
-            self.coefft_xy_from_uv = np.asfarray(coefft_xy_from_uv)
-            self.dcoefft_xy_from_uv = (self.coefft_xy_from_uv *
-                                       np.arange(order))
-
+            self.coefft_xy_from_uv = np.asarray(coefft_xy_from_uv)
         if coefft_uv_from_xy is not None:
-            order = len(coefft_uv_from_xy)
-            self.coefft_uv_from_xy = np.asfarray(coefft_uv_from_xy)
-            self.dcoefft_uv_from_xy = (self.coefft_uv_from_xy *
-                                       np.arange(order))
-
-        if (self.coefft_xy_from_uv is None and
-            self.coefft_uv_from_xy is None):
-                raise ValueError('at least one of coefft_xy_from_uv and '
-                                 + 'coefft_uv_from_xy must be specified')
+            self.coefft_uv_from_xy = np.asarray(coefft_uv_from_xy)
+
+        assert (self.coefft_xy_from_uv is not None or
+                self.coefft_uv_from_xy is not None)
 
-        self.uv_scale = Pair.as_pair(uv_scale).as_readonly()
         self.uv_shape = Pair.as_pair(uv_shape).as_readonly()
 
         if uv_los is None:
             self.uv_los = self.uv_shape / 2.
         else:
             self.uv_los = Pair.as_pair(uv_los).as_float()
             self.uv_los.as_readonly()
 
-        self.iters = max(int(iters), 2)
-        self.fast = bool(fast) and (self.coefft_uv_from_xy is not None)
+        self.iters = iters
 
-        self.flat_fov = FlatFOV(self.uv_scale, self.uv_shape, self.uv_los)
+        # Required attribute
+        if self.coefft_uv_from_xy is not None:
+            self.uv_scale = Pair.as_pair((1./self.coefft_uv_from_xy[1,0,0],
+                                          1./self.coefft_uv_from_xy[0,1,1]))
+        else:
+            self.uv_scale = Pair.as_pair((self.coefft_xy_from_uv[1,0,0],
+                                          self.coefft_xy_from_uv[0,1,1]))
 
         if uv_area is None:
             self.uv_area = np.abs(self.uv_scale.vals[0] * self.uv_scale.vals[1])
         else:
             self.uv_area = uv_area
 
-        # Reference values for precision determinations
-        # The goal is full precision in pixel coordinates
-        self.uv_precision = EPSILON
-        self.xy_precision = EPSILON * np.min(self.uv_scale.vals)
-
     def __getstate__(self):
-        return (self.uv_scale, self.uv_shape, self.coefft_xy_from_uv,
-                self.coefft_uv_from_xy, self.uv_los, self.uv_area, self.iters)
+        return (self.uv_shape, self.coefft_xy_from_uv, self.coefft_uv_from_xy,
+                self.uv_los, self.uv_area, self.iters)
 
     def __setstate__(self, state):
         self.__init__(*state)
 
     #===========================================================================
-    def xy_from_uvt(self, uv, time=None, derivs=False, remask=False):
+    def xy_from_uvt(self, uv, time=None, derivs=False, remask=False,
+                                                       fast=False):
         """The (x,y) camera frame coordinates given the FOV coordinates (u,v) at
         the specified time.
 
         Input:
             uv          (u,v) coordinate Pair in the FOV.
-            time        Scalar of optional absolute times. Ignored by BarrelFOV.
-            derivs      if True, any derivatives in (u,v) get propagated into
+            time        Scalar of optional absolute times. Ignored by
+                        PolynomialFOV.
+            derivs      If True, any derivatives in (u,v) get propagated into
                         the returned (x,y) Pair.
             remask      True to mask (u,v) coordinates outside the field of
                         view; False to leave them unmasked.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.
 
         Return:         Pair of same shape as uv_pair, giving the transformed
                         (x,y) coordinates in the camera's frame.
         """
 
-        # Convert to xy using flat FOV model
-        flat_xy = self.flat_fov.xy_from_uv(uv, derivs=derivs, remask=remask)
-        r_flat = flat_xy.norm(derivs)
+        # Subtract off the center of the field of view
+        uv = Pair.as_pair(uv, derivs) - self.uv_los
 
-        # Distort based on which types of coefficients are given
+        # Transform based on which types of coeffs are given
         if self.coefft_xy_from_uv is not None:
-            true_over_flat = BarrelFOV._eval_ratio(r_flat,
-                                                   self.coefft_xy_from_uv,
-                                                   self.dcoefft_xy_from_uv,
-                                                   derivs=derivs)
+            xy = self._apply_polynomial(uv, self.coefft_xy_from_uv,
+                                        derivs=derivs, from_='uv')
         else:
-            r_true_guess = r_flat.wod
-            true_over_flat = BarrelFOV._solve_ratio(r_flat, r_true_guess,
-                                                    self.coefft_uv_from_xy,
-                                                    self.dcoefft_uv_from_xy,
-                                                    derivs=derivs,
-                                                    iters=self.iters,
-                                                    precision=self.xy_precision)
+            xy = self._solve_polynomial(uv, self.coefft_uv_from_xy,
+                                        derivs=derivs, from_='uv', fast=fast)
 
-        return flat_xy * true_over_flat
+        return xy
 
     #===========================================================================
-    def uv_from_xyt(self, xy, time=None, derivs=False, remask=False):
+    def uv_from_xyt(self, xy, time=None, derivs=False, remask=False,
+                                                       fast=False):
         """The (u,v) FOV coordinates given the (x,y) camera frame coordinates at
         the specified time.
 
         Input:
             xy          (x,y) Pair in FOV coordinates.
-            time        Scalar of optional absolute times. Ignored by BarrelFOV.
+            time        Scalar of optional absolute times. Ignored by
+                        PolynomialFOV.
             derivs      If True, any derivatives in (x,y) get propagated into
                         the returned (u,v) Pair.
             remask      True to mask (u,v) coordinates outside the field of
                         view; False to leave them unmasked.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.
 
         Return:         Pair of same shape as xy_pair, giving the computed (u,v)
                         FOV coordinates.
         """
 
-        true_xy = Pair.as_pair(xy, derivs)
-        r_true = true_xy.norm(derivs)
+        xy = Pair.as_pair(xy, derivs)
 
-        # Distort based on which types of coefficients are given
-        if self.fast and self.coefft_uv_from_xy is not None:
-            flat_over_true = BarrelFOV._eval_ratio(r_true,
-                                                   self.coefft_uv_from_xy,
-                                                   self.dcoefft_uv_from_xy,
-                                                   derivs=derivs)
+        # Transform based on which types of coeffs are given
+        if self.coefft_uv_from_xy is not None:
+            uv = self._apply_polynomial(xy, self.coefft_uv_from_xy,
+                                        derivs=derivs, from_='xy')
         else:
-            # If both sets of coefficients are available, use uv_from_xy as the
-            # guess. Otherwise, use a flat FOV
-            if self.coefft_uv_from_xy is not None:
-                flat_over_true = BarrelFOV._eval_ratio(r_true,
-                                                       self.coefft_uv_from_xy,
-                                                       self.dcoefft_uv_from_xy,
-                                                       derivs=False)
-                r_flat_guess = r_true.wod / flat_over_true
-            else:
-                r_flat_guess = r_true.wod
+            uv = self._solve_polynomial(xy, self.coefft_xy_from_uv,
+                                        derivs=derivs, from_='xy', fast=fast)
 
-            flat_over_true = BarrelFOV._solve_ratio(r_true, r_flat_guess,
-                                                    self.coefft_xy_from_uv,
-                                                    self.dcoefft_xy_from_uv,
-                                                    derivs=derivs,
-                                                    iters=self.iters,
-                                                    precision=self.uv_precision)
+        # Add back the center of the field of view
+        uv = uv + self.uv_los
 
-        flat_xy = true_xy * flat_over_true
-        return self.flat_fov.uv_from_xy(flat_xy, derivs=derivs, remask=remask)
+        return uv
 
     #===========================================================================
-    @staticmethod
-    def _eval_ratio(r, coefft, dcoefft, derivs=False, d_dr=False):
-        """Compute the ratio polynomial(r)/r.
-
-        By returning the ratio instead of the polynomial value directly, it is
-        easier to handle r = polynomial(r) = 0.
+    def _apply_polynomial(self, pq, coefft, derivs, from_):
+        """Apply the polynomial to pair (p,q) to return (a,b).
 
         Input:
-            r           Scalar of arbitrary shape specifying the points at which
+            pq          Pairs of arbitrary shape specifying the points at which
                         to evaluate the polynomial.
-            coefft      The coefficient array defining the polynomial, with the
-                        leading zero-valued constant term omitted.
-            dcoefft     The coefficients of the derivatives of the ratio, i.e.,
-                            coefft * [0,1,2,...]
-            derivs      True to include the derivatives embedded in r in the
+            coefft      The coefficient array defining the polynomial.
+            derivs      If True, derivatives are computed and included in the
                         result.
-            d_dr        If True, the returned quantity is a tuple (f, df/dr);
-                        otherwise, only f is returned.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
 
-        Return          ratio or (ratio, dratio_dr), depending on d_dr input.
-            ratio       value of the polynomial(r)/r.
-            dratio_dr   optional derivative of the ratio with respect to r.
+        Output:         ab
+            ab          Pairs of the same shape as pq giving the values of
+                        the polynomial at each input point.
         """
 
-        # Construct the powers of radius, starting at 1
-        r = Scalar.as_scalar(r, derivs)
+        assert from_ in ('uv', 'xy')
+        dkey = from_
+
+        order = coefft.shape[0]-1
+
+        (p,q) = pq.to_scalars()
+        if pq.shape:
+            p = p.vals[..., np.newaxis]
+            q = q.vals[..., np.newaxis]
+        else:
+            p = p.vals
+            q = q.vals
+
+        # Construct the powers of line and sample
+        p_powers = [1.]
+        q_powers = [1.]
+        for k in range(1, order + 1):
+            p_powers.append(p_powers[-1] * p)
+            q_powers.append(q_powers[-1] * q)
 
-        powers = np.empty(r.shape + coefft.shape)
-        powers[...,0] = 1.
-        powers[...,1] = r.vals
-        for k in range(2, coefft.shape[0]):
-            powers[...,k] = powers[...,k-1] * r.vals
-
-        # Evaluate the polynomial; start from higher order to (maybe) improve
-        ratio = Scalar(np.sum(powers * coefft, axis=-1), r.mask)
-
-        # Evaluate the derivative with respect to r if necessary
-        # Note that dcoefft[0] is always 0.
-        if d_dr or derivs:
-            dratio_dr = Scalar(np.sum(dcoefft[1:] * powers[...,:-1],
-                               axis=-1))    # unmasked is OK
+        # Evaluate the polynomials
+        #
+        # Start with the high-order terms and work downward, because this
+        # improves accuracy. Stop at one because there are no zero-order terms.
+        ab_vals = np.zeros(pq.shape + (2,))
+        for k in range(order, -1, -1):
+          for i in range(k+1):
+            j = k - i
+            ab_vals += coefft[i,j,:] * p_powers[i] * q_powers[j]
+        ab = Pair(ab_vals, pq.mask)
 
-        # Calculate additional derivatives if necessary
+        # Calculate derivatives if necessary
         if derivs:
-            new_derivs = {}
-            for key, deriv in r.derivs.items():
-                new_derivs[key] = dratio_dr * deriv
-            ratio.insert_derivs(new_derivs)
 
-        if d_dr:
-            return (ratio, dratio_dr)
-        else:
-            return ratio
+            # Compute derivatives
+            dab_dpq_vals = np.zeros(pq.shape + (2,2))
 
-    #===========================================================================
-    @staticmethod
-    def _solve_ratio(f, r_guess, coefft, dcoefft, derivs=False, iters=8,
-                                                                precision=0.):
-        """Invert a 1-D polynomial to find r where polynomial(r) = f, but then
-        return r/f.
+            for k in range(order, 0, -1):
+              for i in range(k+1):
+                j = k - i
+                dab_dpq_vals[...,:,0] += (coefft[i,j,:] *
+                                          i*p_powers[i-1] * q_powers[j])
+                dab_dpq_vals[...,:,1] += (coefft[i,j,:] *
+                                          p_powers[i] * j*q_powers[j-1])
+            dab_dpq = Pair(dab_dpq_vals, pq.mask, drank=1)
+
+            # Propagate derivatives
+#            ab.propagate_deriv(pq, dkey, dab_dpq, derivs)
+            new_derivs = {dkey:dab_dpq}
+            if pq.derivs:
+                for (key, pq_deriv) in pq.derivs.items():
+                    new_derivs[key] = dab_dpq.chain(pq_deriv)
+            ab.insert_derivs(new_derivs)
+
+        return ab
 
-        Using the ratio r/f instead of r itself makes it easier to handle
-        r = f = 0.
+    #===========================================================================
+    def _guess(self, ab, coefft, from_):
+        """Compute the initial guess for polynomial inversion.
 
         Input:
-            f           Scalar of arbitrary shape specifying the values of the
-                        polynomial.
-            r_guess     initial guess at the values to return.
-            coefft      coefficient array defining the polynomial, with the
-                        leading zero-valued constant term omitted.
-            dcoefft     coefficients of the derivatives, i.e.,
-                            coefft[1:] * [1,2,3,...]
-            derivs      True to include the derivatives embedded in f in the
-                        result.
-            d_dr        if True, the tuple (r, d_dr) is returned insteadu of r
-                        alone.
-            iters       maximum number of iterations of Newton's method.
-            precision   absolute precision desired. Approximate limit is OK, and
-                        the only down-side of zero (the default) is that the
-                        solution will require one extra iteration.
-
-        Output:         r or (r, df_dr) depending on input d_dr.
-            r           Scalar of the same shape as f giving the values at which
-                        the polynomial evaluates to f.
-            df_dr       the derivative df/dr at r.
+            ab          Pairs of arbitrary shape specifying the points at which
+                        to compute the guess.
+            coefft      The coefficient array defining the polynomial.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
+
+        Output:         pq
+            pq          Pairs of of the same shape as ab giving the values of
+                        the inverted polynomial at each input point.
         """
 
-        f = Scalar.as_scalar(f, derivs)
+        if from_ == 'xy':
+          return (ab - coefft[0,0]).element_div(self.uv_scale, recursive=False)
+        if from_ == 'uv':
+          return (ab - coefft[0,0]).element_mul(self.uv_scale, recursive=False)
 
-        # Handle fully-masked case
-        if np.all(f.mask):
-            return Pair(np.ones(f.shape), True)
-
-        # Because convergence is quadratic in Newton's method, once we get half-
-        # way to convergence, the next iteration should be exact.
-        eps = 2*[precision * 2] + (iters-2) * [np.sqrt(precision) / 30]
-            # Don't assume the convergence is quadratic till the third iteration
-            # Division by 30 is just for extra safety
-
-        # Make sure the initial r guess is an array copy and uses f's mask
-        r = r_guess.copy().remask(f.mask)
-
-        max_dr = 1.e99
-        converged = False
-        for count in range(iters):
-            (f_over_r,
-             d_f_over_r_dr) = BarrelFOV._eval_ratio(r, coefft, dcoefft,
-                                                       derivs=False, d_dr=True)
-            f_test = f_over_r * r
-            df_dr = f_over_r + r * d_f_over_r_dr
-
-            # Perform one step of Newton's Method
-            dr = (f.wod - f_test) / df_dr
-                # Note that df_dr should never be zero, so this is safe
-            new_max_dr = abs(dr).max(builtins=True, masked=-1.)
-
-            if LOGGING.fov_iterations or BarrelFOV.DEBUG:
-                LOGGING.convergence('BarrelFOV._solve_ratio:',
-                                    'iter=%d; change=%.6g' % (count+1,
-                                                              new_max_dr))
-
-            # Quit when convergence stops
-            if new_max_dr <= eps[count]:
-                r += dr
-                converged = True
-                break
-
-            if new_max_dr >= max_dr:
-                break
-
-            r += dr
-            max_dr = new_max_dr
-
-        if not converged:
-            LOGGING.warn('BarrelFOV._solve_ratio did not converge;',
-                         'iter=%d; change=%.6g' % (count+1, max_dt))
+    #===========================================================================
+    def _solve_polynomial(self, ab, coefft, derivs, from_, fast=False):
+        """Solve the polynomial for an (a,b) pair to return (p,q).
 
-        # Prepare ratio r/f
-        ratio = 1. / f_over_r       # f_over_r can't be zero
+        Input:
+            ab          Pairs of arbitrary shape specifying the points at which
+                        to invert the polynomial.
+            coefft      The coefficient array defining the polynomial to invert.
+            derivs      If True, derivatives are included in the output.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.  The unittests with SpeedTest = True
+                        produced the folowing results:
+
+                        Slow Newton's method: convergence: 6.68551206589 ms
+                        Fast Newton's method: convergence: 5.97627162933 ms
+                        Slow/Fast =  1.11867607106
+
+        Output:         pq
+            pq          Pairs of of the same shape as ab giving the values of
+                        the inverted polynomial at each input point.
+        """
 
-        # Propagate derivatives if necessary
-        if derivs:
-            new_derivs = {}
-            for key, df_dx in f.derivs.items():
+        src = {'uv','xy'}
+        assert from_ in src
+        to_ = (src^{from_}).pop()
+        dkey = from_
+
+        ab = Pair.as_pair(ab, derivs)
+        ab_wod = ab.wod
+
+        # Make a rough initial guess
+        pq = self._guess(ab_wod, coefft, from_)
+        pq.insert_deriv(dkey, Pair.IDENTITY)
+
+        # Iterate until convergence...
+        epsilon = 1.e-15
+        prev_dpq_max = 1.e99
+        for count in range(self.iters):
+
+            # Evaluate the forward transform and its partial derivatives
+            ab0 = self._apply_polynomial(pq, coefft, derivs=True, from_=to_)
+            dab_dpq = ab0.derivs[dkey]
+
+            # Apply one step of Newton's method in 2-D
+            dab = ab_wod - ab0.wod
+
+            dpq_dab = dab_dpq.reciprocal()
+            dpq = dpq_dab.chain(dab)
+            pq += dpq
+
+            # Convergence tests...
+
+            # simpler, but faster convergence
+            if fast:
+
+                # Compare the max step size with the max coordinate value
+                # This removes any positional dependence of the relative
+                # error.  The denominator can only be zero if the entire
+                # grid is (0,0).
+                error_max = abs(dpq.vals).max() / abs(pq.vals).max()
+                if PolynomialFOV.DEBUG:
+                   print(count+1, error_max)
+
+                # Test for root
+                #  This eliminates cases where the iteration bounces
+                #  around within epsilon of a solution.
+                if abs(dab).max() <= epsilon:
+                    break
+
+                # Relative correction below epsilon.
+                if error_max <= epsilon:
+                    break
 
-                # We need to obtain dratio_dx while avoiding divide-by-zero
+            # slower convergence, but more robust
+            else:
 
-                dr_dx = df_dx / df_dr           # df_dr cannot equal zero
+                # The old convergence test below was looking for the correction
+                # to overshoot.  This may in principle be a more robust way to
+                # ensure machine precision is achieved, but it requires some
+                # additonal iterations conmpared to the simpler test above.
+                dpq_max = abs(dpq).max()
+                if PolynomialFOV.DEBUG:
+                    print(iter, dpq_max)
+
+                if dpq_max >= prev_dpq_max:
+                    break
 
-                # d(ratio)/dx = d(1/f_over_r)/dx
-                #   = -d(f_over_r)/dx / f_over_r**2
-                #   = -d(f_over_r)/dr * dr/dx / f_over_r**2
+            prev_dpq_max = dpq_max
 
-                new_derivs[key] = -d_f_over_r_dr * dr_dx * ratio**2
+        if PolynomialFOV.DEBUG:
+            print(iter+1, 'iterations')
 
-            ratio.insert_derivs(new_derivs)
+        pq = pq.wod
 
-        return ratio
+        # Propagate derivatives if necessary
+#        pq.propagate_deriv(ab, dkey, dpq_dab, derivs)
+        if derivs:
+            new_derivs = {dkey:dpq_dab}
+            if ab.derivs:
+                for (key, ab_deriv) in ab.derivs.items():
+                    new_derivs[key] = dpq_dab.chain(ab_deriv)
+            pq.insert_derivs(new_derivs)
+
+        return pq
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
 import time
 
-class Test_BarrelFOV(unittest.TestCase):
+class Test_PolynomialFOV(unittest.TestCase):
 
     def runTest(self):
 
-        np.random.seed(8372)
+        import time
+        from oops.fov.polyfov import PolyFOV
 
-        BarrelFOV.DEBUG = False
+        np.random.seed(5294)
+
+        PolynomialFOV.DEBUG = False
         SpeedTest = False
 
         ########################################
         # Only xy_from_uv defined
         ########################################
 
-        # These are JunoCam parameters
-        coefft_xy_from_uv = np.array([1.,
-                                      0.,
-                                     -5.9624209455667325e-08,
-                                      0.,
-                                      2.7381910042256151e-14])
-        scale = 0.00067540618
-        shape = (1648,128)
-        fov = BarrelFOV(scale, shape, coefft_xy_from_uv=coefft_xy_from_uv)
+        coefft_xy_from_uv = np.zeros((3,3,2))
+        coefft_xy_from_uv[...,0] = np.array([[ 5.00, -0.10, -0.01],
+                                             [ 1.20, -0.01,  0.00],
+                                             [-0.02,  0.00,  0.00]])
+        coefft_xy_from_uv[...,1] = np.array([[ 0.00, -1.10,  0.01],
+                                             [-0.20, -0.03,  0.00],
+                                             [-0.02,  0.00,  0.00]])
 
-        self.assertTrue(fov.max_inversion_error() < 3.e-13)
+        fov = PolynomialFOV((20,15), coefft_xy_from_uv=coefft_xy_from_uv)
 
         #### uv -> xy -> uv, with derivs
 
-        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
-        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
-        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+        uv = Pair.combos(np.arange(20), np.arange(15))
+        uv.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
 
         if SpeedTest:
-            iters = 200
-            t0 = time.time()
-            for k in range(iters):
-                xy = fov.xy_from_uv(uv, derivs=True)
-                uv_test = fov.uv_from_xy(xy, derivs=True)
-            t1 = time.time()
-            LOGGING.print('time = %.2f ms' % ((t1-t0)/iters*1000.))
+            iters = 100
+            for fast in (True, False):
+                t0 = time.time()
+                for k in range(iters):
+                    xy = fov.xy_from_uv(uv, derivs=True)
+                    uv_test = fov.uv_from_xy(xy, derivs=True, fast=fast)
+                t1 = time.time()
+                print('%s time = %.2f ms' % ('fast' if fast else 'slow',
+                                             (t1-t0)/iters*1000.))
         else:
             xy = fov.xy_from_uv(uv, derivs=True)
             uv_test = fov.uv_from_xy(xy, derivs=False)
 
-        uv_test = fov.uv_from_xy(xy)
-        self.assertTrue(abs(uv - uv_test).max() < 3.e-13)
+        self.assertTrue(abs(uv - uv_test).max() < 1.e-14)
 
         EPS = 1.e-6
         xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
         xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
         dxy_du = (xy1 - xy0) / (2. * EPS)
 
         xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
         xy1 = fov.xy_from_uv(uv + (0, EPS), False)
         dxy_dv = (xy1 - xy0) / (2. * EPS)
 
-        dxy_dt = dxy_du * uv.d_dt.vals[...,0]    + dxy_dv * uv.d_dt.vals[...,1]
+        dxy_dt = dxy_du * uv.d_dt.vals[...,0] + dxy_dv * uv.d_dt.vals[...,1]
         dxy_dr = dxy_du * uv.d_drs.vals[...,0,0] + dxy_dv * uv.d_drs.vals[...,1,0]
         dxy_ds = dxy_du * uv.d_drs.vals[...,0,1] + dxy_dv * uv.d_drs.vals[...,1,1]
 
         DEL = 1.e-6
-        self.assertTrue(abs(xy.d_dt.vals         - dxy_dt.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_dt.vals - dxy_dt.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
 
         #### xy -> uv -> xy, with derivs
 
         xy = fov.xy_from_uv(uv, derivs=False)
-        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
-        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+        xy.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
         uv = fov.uv_from_xy(xy, derivs=True)
 
+        xy_test = fov.xy_from_uv(uv)
+        self.assertTrue(abs(xy - xy_test).max() < 1.e-14)
+
         EPS = 1.e-6
-        uv0 = fov.uv_from_xy(xy + (-EPS,0), False)
-        uv1 = fov.uv_from_xy(xy + ( EPS,0), False)
-        duv_dx = (uv1 - uv0) / (2. * EPS)
-
-        uv0 = fov.uv_from_xy(xy + (0,-EPS), False)
-        uv1 = fov.uv_from_xy(xy + (0, EPS), False)
-        duv_dy = (uv1 - uv0) / (2. * EPS)
-
-        duv_dt = duv_dx * xy.d_dt.vals[...,0]    + duv_dy * xy.d_dt.vals[...,1]
-        duv_dr = duv_dx * xy.d_drs.vals[...,0,0] + duv_dy * xy.d_drs.vals[...,1,0]
-        duv_ds = duv_dx * xy.d_drs.vals[...,0,1] + duv_dy * xy.d_drs.vals[...,1,1]
+        xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
+        xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
+        dxy_du = (xy1 - xy0) / (2. * EPS)
+
+        xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
+        xy1 = fov.xy_from_uv(uv + (0, EPS), False)
+        dxy_dv = (xy1 - xy0) / (2. * EPS)
+
+        dxy_dt = dxy_du * uv.d_dt.vals[...,0]    + dxy_dv * uv.d_dt.vals[...,1]
+        dxy_dr = dxy_du * uv.d_drs.vals[...,0,0] + dxy_dv * uv.d_drs.vals[...,1,0]
+        dxy_ds = dxy_du * uv.d_drs.vals[...,0,1] + dxy_dv * uv.d_drs.vals[...,1,1]
 
         DEL = 1.e-6
-        self.assertTrue(abs(uv.d_dt.vals         - duv_dt.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,0] - duv_dr.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,1] - duv_ds.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_dt.vals - dxy_dt.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
 
         ########################################
-        # Only xy_from_uv defined
+        # Only uv_from_xy defined
         ########################################
 
-        coefft_uv_from_xy = np.array([1.000,
-                                      0,
-                                     -5.9624209455667325e-08,
-                                      0,
-                                      2.7381910042256151e-14])
-        scale = 0.00067540618
-        shape = (1648,128)
-        fov = BarrelFOV(scale, shape, coefft_uv_from_xy=coefft_uv_from_xy)
+        coefft_uv_from_xy = np.zeros((3,3,2))
+        coefft_uv_from_xy[...,0] = np.array([[ 5.00, -0.10, -0.01],
+                                             [ 1.20, -0.01,  0.00],
+                                             [-0.02,  0.00,  0.00]])
+        coefft_uv_from_xy[...,1] = np.array([[ 0.00, -1.10,  0.01],
+                                             [-0.20, -0.03,  0.00],
+                                             [-0.02,  0.00,  0.00]])
 
-        self.assertTrue(fov.max_inversion_error() < 3.e-13)
+        fov = PolynomialFOV((20,15), coefft_uv_from_xy=coefft_uv_from_xy,
+                                     uv_los=(7,7), uv_area=1.)
 
         #### uv -> xy -> uv, with derivs
 
         uv = Pair.combos(np.arange(20), np.arange(15))
         uv.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
         uv.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
         xy = fov.xy_from_uv(uv, derivs=True)
 
         uv_test = fov.uv_from_xy(xy)
-        self.assertTrue(abs(uv - uv_test).max() < 3.e-13)
+        self.assertTrue(abs(uv - uv_test).max() < 1.e-14)
 
         EPS = 1.e-6
         xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
         xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
         dxy_du = (xy1 - xy0) / (2. * EPS)
 
         xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
         xy1 = fov.xy_from_uv(uv + (0, EPS), False)
         dxy_dv = (xy1 - xy0) / (2. * EPS)
 
-        dxy_dt = dxy_du * uv.d_dt.vals[...,0]    + dxy_dv * uv.d_dt.vals[...,1]
+        dxy_dt = dxy_du * uv.d_dt.vals[...,0] + dxy_dv * uv.d_dt.vals[...,1]
         dxy_dr = dxy_du * uv.d_drs.vals[...,0,0] + dxy_dv * uv.d_drs.vals[...,1,0]
         dxy_ds = dxy_du * uv.d_drs.vals[...,0,1] + dxy_dv * uv.d_drs.vals[...,1,1]
 
         DEL = 1.e-6
-        self.assertTrue(abs(xy.d_dt.vals         - dxy_dt.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_dt.vals - dxy_dt.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
 
         #### xy -> uv -> xy, with derivs
 
         xy = fov.xy_from_uv(uv, derivs=False)
         xy.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
         xy.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
         uv = fov.uv_from_xy(xy, derivs=True)
 
         xy_test = fov.xy_from_uv(uv)
         self.assertTrue(abs(xy - xy_test).max() < 1.e-14)
 
         EPS = 1.e-6
-        uv0 = fov.uv_from_xy(xy + (-EPS,0), False)
-        uv1 = fov.uv_from_xy(xy + ( EPS,0), False)
-        duv_dx = (uv1 - uv0) / (2. * EPS)
-
-        uv0 = fov.uv_from_xy(xy + (0,-EPS), False)
-        uv1 = fov.uv_from_xy(xy + (0, EPS), False)
-        duv_dy = (uv1 - uv0) / (2. * EPS)
-
-        duv_dt = duv_dx * xy.d_dt.vals[...,0]    + duv_dy * xy.d_dt.vals[...,1]
-        duv_dr = duv_dx * xy.d_drs.vals[...,0,0] + duv_dy * xy.d_drs.vals[...,1,0]
-        duv_ds = duv_dx * xy.d_drs.vals[...,0,1] + duv_dy * xy.d_drs.vals[...,1,1]
+        xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
+        xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
+        dxy_du = (xy1 - xy0) / (2. * EPS)
+
+        xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
+        xy1 = fov.xy_from_uv(uv + (0, EPS), False)
+        dxy_dv = (xy1 - xy0) / (2. * EPS)
+
+        dxy_dt = dxy_du * uv.d_dt.vals[...,0]    + dxy_dv * uv.d_dt.vals[...,1]
+        dxy_dr = dxy_du * uv.d_drs.vals[...,0,0] + dxy_dv * uv.d_drs.vals[...,1,0]
+        dxy_ds = dxy_du * uv.d_drs.vals[...,0,1] + dxy_dv * uv.d_drs.vals[...,1,1]
 
         DEL = 1.e-6
-        self.assertTrue(abs(uv.d_dt.vals         - duv_dt.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,0] - duv_dr.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,1] - duv_ds.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_dt.vals - dxy_dt.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
+        self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
 
         ########################################
-        # Both directions
+        # Only xy_from_uv defined, comparison to PolyFOV
         ########################################
 
-        coefft_xy_from_uv = np.array([1., 6.e-04, -3.e-07, 2.e-10, 7.e-10])
+        coefft_xy_from_uv = np.zeros((3,3,2))
+        coefft_xy_from_uv[...,0] = np.array([[ 5.00, -0.10, -0.01],
+                                             [ 1.20, -0.01,  0.00],
+                                             [-0.02,  0.00,  0.00]])
+        coefft_xy_from_uv[...,1] = np.array([[ 0.00, -1.10,  0.01],
+                                             [-0.20, -0.03,  0.00],
+                                             [-0.02,  0.00,  0.00]])
 
-        # From fitting...
-        coefft_uv_from_xy = np.array([ 1.00242964e+00,
-                                      -6.06115855e-04,
-                                      -8.13033063e-07,
-                                       5.65874210e-09,
-                                      -4.30619511e-10,
-                                       1.31761955e-12])
-
-        fov = BarrelFOV(0.001, (100,100),
-                        coefft_xy_from_uv=coefft_xy_from_uv,
-                        coefft_uv_from_xy=coefft_uv_from_xy, fast=False)
-
-        fov_fast = BarrelFOV(0.001, (100,100),
-                             coefft_xy_from_uv=coefft_xy_from_uv,
-                             coefft_uv_from_xy=coefft_uv_from_xy, fast=True)
-
-        self.assertTrue(fov.max_inversion_error() < 3.e-14)
-        self.assertTrue(fov_fast.max_inversion_error() < 0.3)
+        fov = PolynomialFOV((20,15), coefft_xy_from_uv=coefft_xy_from_uv)
+        polyfov = PolyFOV((20,15), coefft_xy_from_uv=coefft_xy_from_uv)
 
         #### uv -> xy -> uv, with derivs
 
-        uv = Pair.combos(np.arange(0,101,10), np.arange(0,101,10))
-        uv.insert_deriv('t' , Pair(np.random.randn(11,11,2)))
-        uv.insert_deriv('rs', Pair(np.random.randn(11,11,2,2), drank=1))
+        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
+        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
 
-        xy = fov.xy_from_uv(uv, derivs=True)
-        uv_test = fov.uv_from_xy(xy, derivs=False)
+        xy1 = fov.xy_from_uv(uv, derivs=True)
+        xy2 = polyfov.xy_from_uv(uv, derivs=True)
 
-        uv_test = fov.uv_from_xy(xy)
-        self.assertTrue(abs(uv - uv_test).max() < 3.e-13)
+        DEL = 1.e-11
+        self.assertTrue(abs(xy1.vals       - xy2.vals      ).max() <= DEL)
+        self.assertTrue(abs(xy1.d_dt.vals  - xy2.d_dt.vals ).max() <= DEL)
+        self.assertTrue(abs(xy1.d_drs.vals - xy2.d_drs.vals).max() <= DEL)
 
-        EPS = 1.e-6
-        xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
-        xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
-        dxy_du = (xy1 - xy0) / (2. * EPS)
+        #### xy -> uv -> xy, with derivs
 
-        xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
-        xy1 = fov.xy_from_uv(uv + (0, EPS), False)
-        dxy_dv = (xy1 - xy0) / (2. * EPS)
+        xy = fov.xy_from_uv(uv, derivs=False)
+        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
 
-        dxy_dt = dxy_du * uv.d_dt.vals[...,0]    + dxy_dv * uv.d_dt.vals[...,1]
-        dxy_dr = dxy_du * uv.d_drs.vals[...,0,0] + dxy_dv * uv.d_drs.vals[...,1,0]
-        dxy_ds = dxy_du * uv.d_drs.vals[...,0,1] + dxy_dv * uv.d_drs.vals[...,1,1]
+# Failure of PolynomialFOV
+#         uv1 = fov.uv_from_xy(xy, derivs=True)
+#         uv2 = polyfov.uv_from_xy(xy, derivs=True)
+#
+#         print(abs(uv1.vals       - uv2.vals      ).max())
+#         print(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max())
+#         print(abs(uv1.d_drs.vals - uv2.d_drs.vals).max())
+# 7737.898863616556
+# 10.64042327053394
+# 20.83167707967607
+#
+#         DEL = 3.e-12
+#         self.assertTrue(abs(uv1.vals       - uv2.vals      ).max() <= DEL)
+#         self.assertTrue(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max() <= DEL)
+#         self.assertTrue(abs(uv1.d_drs.vals - uv2.d_drs.vals).max() <= DEL)
 
-        DEL = 0.02
-        self.assertTrue(abs(xy.d_dt.vals         - dxy_dt.vals).max() <= DEL)
-        self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
-        self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
+        ########################################
+        # Only uv_from_xy defined, comparison to PolyFOV
+        ########################################
+
+        coefft_uv_from_xy = np.zeros((3,3,2))
+        coefft_uv_from_xy[...,0] = np.array([[ 5.00, -0.10, -0.01],
+                                             [ 1.20, -0.01,  0.00],
+                                             [-0.02,  0.00,  0.00]])
+        coefft_uv_from_xy[...,1] = np.array([[ 0.00, -1.10,  0.01],
+                                             [-0.20, -0.03,  0.00],
+                                             [-0.02,  0.00,  0.00]])
+
+        fov = PolynomialFOV((20,15), coefft_uv_from_xy=coefft_uv_from_xy)
+        polyfov = PolyFOV((20,15), coefft_uv_from_xy=coefft_uv_from_xy)
+
+        #### uv -> xy -> uv, with derivs
+
+        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
+        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+
+# Failure of PolynomialFOV
+#         xy1 = fov.xy_from_uv(uv, derivs=True)
+#         xy2 = polyfov.xy_from_uv(uv, derivs=True)
+#
+#         print(abs(xy1.vals       - xy2.vals      ).max())
+#         print(abs(xy1.d_dt.vals  - xy2.d_dt.vals ).max())
+#         print(abs(xy1.d_drs.vals - xy2.d_drs.vals).max())
+# 64902.23479578221
+# 960.3106247521578
+# 1099.824786459409
+#
+#         DEL = 1.e-11
+#         self.assertTrue(abs(xy1.vals       - xy2.vals      ).max() <= DEL)
+#         self.assertTrue(abs(xy1.d_dt.vals  - xy2.d_dt.vals ).max() <= DEL)
+#         self.assertTrue(abs(xy1.d_drs.vals - xy2.d_drs.vals).max() <= DEL)
 
         #### xy -> uv -> xy, with derivs
 
         xy = fov.xy_from_uv(uv, derivs=False)
-        xy.insert_deriv('t' , Pair(np.random.randn(11,11,2)))
-        xy.insert_deriv('rs', Pair(np.random.randn(11,11,2,2), drank=1))
-        uv = fov.uv_from_xy(xy, derivs=True)
+        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
 
-        EPS = 1.e-6
-        uv0 = fov.uv_from_xy(xy + (-EPS,0), False)
-        uv1 = fov.uv_from_xy(xy + ( EPS,0), False)
-        duv_dx = (uv1 - uv0) / (2. * EPS)
-
-        uv0 = fov.uv_from_xy(xy + (0,-EPS), False)
-        uv1 = fov.uv_from_xy(xy + (0, EPS), False)
-        duv_dy = (uv1 - uv0) / (2. * EPS)
-
-        duv_dt = duv_dx * xy.d_dt.vals[...,0]    + duv_dy * xy.d_dt.vals[...,1]
-        duv_dr = duv_dx * xy.d_drs.vals[...,0,0] + duv_dy * xy.d_drs.vals[...,1,0]
-        duv_ds = duv_dx * xy.d_drs.vals[...,0,1] + duv_dy * xy.d_drs.vals[...,1,1]
+        uv1 = fov.uv_from_xy(xy, derivs=True)
+        uv2 = polyfov.uv_from_xy(xy, derivs=True)
 
-        DEL = 1.e-6
-        self.assertTrue(abs(uv.d_dt.vals         - duv_dt.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,0] - duv_dr.vals).max() <= DEL)
-        self.assertTrue(abs(uv.d_drs.vals[...,1] - duv_ds.vals).max() <= DEL)
+        DEL = 3.e-12
+        self.assertTrue(abs(uv1.vals       - uv2.vals      ).max() <= 2.e-8)
+        self.assertTrue(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max() <= 3.e-13)
+        self.assertTrue(abs(uv1.d_drs.vals - uv2.d_drs.vals).max() <= 3.e-13)
+
+        xy.insert_deriv('t', Pair((1,1)))
+        uv_test = fov.uv_from_xy(xy, derivs=False)
+        self.assertEqual(uv_test.derivs, {})
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/gapfov.py` & `rms_oops-0.0.4/oops/fov/gapfov.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 ################################################################################
 # oops/fov/gapfov.py: GapFOV subclass of FOV
 ################################################################################
 
-import numpy as np
 import numbers
+import numpy as np
 
 from polymath import Pair
 from oops.fov import FOV
 
 class GapFOV(FOV):
     """A subclass of FOV in which there gaps between the individual pixels."""
 
@@ -114,23 +114,7 @@
             else:
                 uv_frac.vals[...,k][mask] = 1.
                 uv_frac.mask != remask
 
         return uv_int + uv_frac
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_GapFOV(unittest.TestCase):
-
-    def runTest(self):
-
-        #### TBD
-        print('GapFOV unit tests are needed!')
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/nullfov.py` & `rms_oops-0.0.4/oops/fov/nullfov.py`

 * *Files 2% similar despite different names*

```diff
@@ -270,24 +270,7 @@
 
         Return:         a new Pair of (u,v) coordinates.
         """
 
         return Pair.ZEROS
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_NullFOV(unittest.TestCase):
-
-    def runTest(self):
-
-        # No tests here - TBD
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/offsetfov.py` & `rms_oops-0.0.4/oops/fov/offsetfov.py`

 * *Files 2% similar despite different names*

```diff
@@ -141,23 +141,7 @@
 
         The copy can be safely modified without affecting the original.
         """
 
         return OffsetFOV(self.fov, self.uv_offset.copy(), xy_offset=None)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_OffsetFOV(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/polyfov.py` & `rms_oops-0.0.4/ideas/deprecated/radialfov.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,480 +1,457 @@
 ################################################################################
-# oops/fov/polyfov.py: PolyFOV subclass of FOV, and WCS FOV support.
+# oops/fov/radial.py: Radial subclass of FOV
 ################################################################################
 
+from __future__ import print_function
+
 import numpy as np
+from polymath import Scalar, Pair
 
-from polymath         import Pair
-from oops.config      import LOGGING
 from oops.fov         import FOV
 from oops.fov.flatfov import FlatFOV
 
-import sys
-EPSILON = sys.float_info.epsilon/2.         # actual machine precision
-
-class PolyFOV(FOV):
+class RadialFOV(FOV):
     """Subclass of FOV that describes a field of view in which the distortion is
-    described by a 2-D polynomial.
-
-    This is the approached used by Space Telescope Science Institute to describe
-    the Hubble instrument fields of view. A PolyFOV has no dependence on
-    the optional extra indices that can be associated with time, wavelength
-    band, etc.
+    described by a 1-D polynomial in distance from the image center.
     """
 
-    DEBUG = False       # Set True to print convergence steps of Newton's Method
+    DEBUG = False       # True to print(convergence steps on xy_from_uv())
 
     #===========================================================================
-    def __init__(self, uv_shape, coefft_xy_from_uv=None,
+    def __init__(self, uv_scale, uv_shape, coefft_xy_from_uv=None,
                  coefft_uv_from_xy=None, uv_los=None, uv_area=None,
-                 iters=8, fast=True):
-        """Constructor for a PolyFOV.
+                 iters=8):
+        """Constructor for a RadialFOV.
 
         Inputs:
+            uv_scale    a single value, tuple or Pair defining the ratios dx/du
+                        and dy/dv. At the center of the FOV.  For example, if
+                        (u,v) are in units of  arcseconds, then
+                            uv_scale = Pair((pi/180/3600.,pi/180/3600.))
+                        Use the sign of the second element to define the
+                        direction of increasing V: negative for up, positive for
+                        down.
+
             uv_shape    a single value, tuple or Pair defining size of the field
                         of view in pixels. This number can be non-integral if
                         the detector is not composed of a rectangular array of
                         pixels.
 
             coefft_xy_from_uv
-                        the coefficient array of the polynomial to convert U,V
-                        to X,Y. The array has shape (order+1,order+1,2), where
-                        coefft[i,j,0] is the coefficient on (u**i * v**j)
-                        yielding x(u,v), and coefft[i,j,1] is the coefficient
-                        yielding y(u,v). If None, then the polynomial for
-                        uv_from_xy is inverted.
+                        the coefficient array of the polynomial to convert
+                        U,V to X,Y. The array has shape [order+2], where
+                        coefft[i] is the coefficient on r**i, where
+                        r = sqrt((u-ulos)**2 + (v-vlos)**2), yielding x(u,v)
+                        and y(u,v). All coefficients are 0 for i > order. If
+                        None, then the polynomial for uv_from_xy is inverted.
 
             coefft_uv_from_xy
-                        the coefficient array of the polynomial to convert X,Y
-                        to U,V. The array has shape (order+1,order+1,2), where
-                        coefft[i,j,0] is the coefficient on (x**i * y**j)
-                        yielding u(x,y), and coefft[i,j,1] is the coefficient
-                        yielding v(x,y). If None, then the polynomial for
-                        xy_from_uv is inverted.
+                        the coefficient array of the polynomial to convert
+                        X,Y to U,V. The array has shape [order+1], where
+                        coefft[i] is the coefficient on r**i, where
+                        r = sqrt((u-ulos)**2 + (v-vlos)**2), yielding x(u,v)
+                        and y(u,v). All coefficients are 0 for i > order. If
+                        None, then the polynomial for xy_from_uv is inverted.
 
             uv_los      a single value, tuple or Pair defining the (u,v)
                         coordinates of the nominal line of sight. By default,
                         this is the midpoint of the rectangle, i.e, uv_shape/2.
 
             uv_area     an optional parameter defining the nominal area of a
                         pixel in steradians after distortion has been removed.
 
             iters       the number of iterations of Newton's method to use when
-                        inverting the polynomial; default is 8.
-
-            fast        if True and both sets of coefficients are provided, the
-                        polynomials will be used in both directions, meaning
-                        that the conversions xy_from_uv and uv_from_xy might be
-                        inconsistent, although probably at the sub-pixel level.
-                        If False, then uv_from_xy is refined further using one
-                        or two steps of Newton's method; which provides
-                        consistency at the level of machine precision, but
-                        uv_from_xy will be slightly slower.
+                        inverting the distortion polynomial.
         """
 
-        # Prepare coefficients
         self.coefft_xy_from_uv = None
         self.coefft_uv_from_xy = None
 
         if coefft_xy_from_uv is not None:
-            self.coefft_xy_from_uv = np.asfarray(coefft_xy_from_uv)
-            order = self.coefft_xy_from_uv.shape[0] - 1
-            self.coefft_dxy_du = (self.coefft_xy_from_uv[1:] *
-                                  np.arange(1,order+1)[:,np.newaxis,np.newaxis])
-            self.coefft_dxy_dv = (self.coefft_xy_from_uv[:,1:] *
-                                  np.arange(1,order+1)[np.newaxis,:,np.newaxis])
-
+            self.coefft_xy_from_uv = np.asarray(coefft_xy_from_uv)
         if coefft_uv_from_xy is not None:
-            self.coefft_uv_from_xy = np.asfarray(coefft_uv_from_xy)
-            order = self.coefft_uv_from_xy.shape[0] - 1
-            self.coefft_duv_dx = (self.coefft_uv_from_xy[1:] *
-                                  np.arange(1,order+1)[:,np.newaxis,np.newaxis])
-            self.coefft_duv_dy = (self.coefft_uv_from_xy[:,1:] *
-                                  np.arange(1,order+1)[np.newaxis,:,np.newaxis])
-
-        if (self.coefft_xy_from_uv is None and
-            self.coefft_uv_from_xy is None):
-                raise ValueError('at least one of coefft_xy_from_uv and '
-                                 + 'coefft_uv_from_xy must be specified')
+            self.coefft_uv_from_xy = np.asarray(coefft_uv_from_xy)
 
-        self.iters = max(int(iters), 2)
-        self.fast = bool(fast) and (self.coefft_uv_from_xy is not None)
+        assert (self.coefft_xy_from_uv is not None or
+                self.coefft_uv_from_xy is not None)
 
-        # Required attributes uv_shape and uv_los
+        self.uv_scale = Pair.as_pair(uv_scale).as_readonly()
         self.uv_shape = Pair.as_pair(uv_shape).as_readonly()
 
         if uv_los is None:
             self.uv_los = self.uv_shape / 2.
         else:
             self.uv_los = Pair.as_pair(uv_los).as_float()
             self.uv_los.as_readonly()
 
-        # Required attribute uv_scale...
+        self.iters = iters
 
-        # This is a first guess at flat_fov
-        if self.coefft_uv_from_xy is None:
-            uv_scale = Pair.as_pair((self.coefft_xy_from_uv[1,0,0],
-                                     self.coefft_xy_from_uv[0,1,1]))
-        else:
-            uv_scale = Pair.as_pair((1./self.coefft_uv_from_xy[1,0,0],
-                                     1./self.coefft_uv_from_xy[0,1,1]))
-
-        self.flat_fov = FlatFOV(uv_scale, self.uv_shape, self.uv_los)
-        self.uv_precision = EPSILON
-        self.xy_precision = EPSILON * min(abs(uv_scale.vals))
-
-        # This is a refined estimate of flat_fov
-        (u0, v0) = 0.2 * self.uv_shape.vals
-        (u1, v1) = 0.5 * self.uv_shape.vals
-        (u2, v2) = 0.8 * self.uv_shape.vals
-
-        p0 = Pair((u0, v1))
-        p2 = Pair((u2, v1))
-        x0 = self.xy_from_uvt(p0).vals[0]
-        x2 = self.xy_from_uvt(p2).vals[0]
-        dx_du = (x2 - x0) / (u2 - u0)
-
-        p0 = Pair((u1, v0))
-        p2 = Pair((u1, v2))
-        y0 = self.xy_from_uvt(p0).vals[1]
-        y2 = self.xy_from_uvt(p2).vals[1]
-        dy_dv = (y2 - y0) / (v2 - v0)
-
-        self.uv_scale = Pair((dx_du, dy_dv))
         self.flat_fov = FlatFOV(self.uv_scale, self.uv_shape, self.uv_los)
 
         if uv_area is None:
             self.uv_area = np.abs(self.uv_scale.vals[0] * self.uv_scale.vals[1])
         else:
             self.uv_area = uv_area
 
-        # Reference values for precision determinations
-        # The goal is full precision in pixel coordinates
-        self.uv_precision = EPSILON
-        self.xy_precision = EPSILON * min(dx_du, abs(dy_dv))
-
     def __getstate__(self):
-        return (self.uv_shape, self.coefft_xy_from_uv, self.coefft_uv_from_xy,
-                self.uv_los, self.uv_area, self.iters)
+        return (self.uv_scale, self.uv_shape, self.coefft_xy_from_uv,
+                self.coefft_uv_from_xy, self.uv_los, self.uv_area, self.iters)
 
     def __setstate__(self, state):
         self.__init__(*state)
 
     #===========================================================================
-    def xy_from_uvt(self, uv, time=None, derivs=False, remask=False):
+    def xy_from_uvt(self, uv, time=None, derivs=False, remask=False,
+                                                       fast=False):
         """The (x,y) camera frame coordinates given the FOV coordinates (u,v) at
         the specified time.
 
         Input:
             uv          (u,v) coordinate Pair in the FOV.
-            time        Scalar of optional absolute times. Ignored by PolyFOV.
-            derivs      if True, any derivatives in (u,v) get propagated into
+            time        Scalar of optional absolute times. Ignored by RadialFOV.
+            derivs      If True, any derivatives in (u,v) get propagated into
                         the returned (x,y) Pair.
             remask      True to mask (u,v) coordinates outside the field of
                         view; False to leave them unmasked.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.
 
         Return:         Pair of same shape as uv_pair, giving the transformed
                         (x,y) coordinates in the camera's frame.
         """
 
-        # Mask if necessary
-        uv = Pair.as_pair(uv, recursive=derivs)
-        if remask:
-            uv = uv.mask_or(self.uv_is_outside(uv).vals)
-
-        # Subtract off the center of the field of view
-        duv = uv - self.uv_los
-
-        # Transform based on which types of coefficients are given
+        # Transform based on which types of coeffs are given
         if self.coefft_xy_from_uv is not None:
-            xy = PolyFOV._eval_polynomial(duv,
-                                          self.coefft_xy_from_uv,
-                                          self.coefft_dxy_du,
-                                          self.coefft_dxy_dv,
-                                          derivs=derivs)
+            xy = self._apply_polynomial(uv, self.coefft_xy_from_uv,
+                                        derivs=derivs, from_='uv')
         else:
-            xy_guess = self.flat_fov.xy_from_uv(uv, derivs=False)
-            xy = PolyFOV._solve_polynomial(duv, xy_guess,
-                                           self.coefft_uv_from_xy,
-                                           self.coefft_duv_dx,
-                                           self.coefft_duv_dy,
-                                           derivs=derivs,
-                                           iters=self.iters,
-                                           precision=self.xy_precision)
+            xy = self._solve_polynomial(uv, self.coefft_uv_from_xy,
+                                        derivs=derivs, from_='uv', fast=fast)
 
         return xy
 
     #===========================================================================
-    def uv_from_xyt(self, xy, time=None, derivs=False, remask=False):
+    def uv_from_xyt(self, xy, time=None, derivs=False, remask=False,
+                                                       fast=False):
         """The (u,v) FOV coordinates given the (x,y) camera frame coordinates at
         the specified time.
 
         Input:
             xy          (x,y) Pair in FOV coordinates.
-            time        Scalar of optional absolute times. Ignored by PolyFOV.
-            derivs      if True, any derivatives in (x,y) get propagated into
+            time        Scalar of optional absolute times. Ignored by RadialFOV.
+            derivs      If True, any derivatives in (x,y) get propagated into
                         the returned (u,v) Pair.
             remask      True to mask (u,v) coordinates outside the field of
                         view; False to leave them unmasked.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.
 
         Return:         Pair of same shape as xy_pair, giving the computed (u,v)
                         FOV coordinates.
         """
 
-        xy = Pair.as_pair(xy, recursive=derivs)
+        xy = Pair.as_pair(xy, derivs)
 
         # Transform based on which types of coeffs are given
-        if self.fast and self.coefft_uv_from_xy is not None:
-            duv = PolyFOV._eval_polynomial(xy,
-                                           self.coefft_uv_from_xy,
-                                           self.coefft_duv_dx,
-                                           self.coefft_duv_dy,
-                                           derivs=derivs)
-
+        if self.coefft_uv_from_xy is not None:
+            uv = self._apply_polynomial(xy, self.coefft_uv_from_xy,
+                                        derivs=derivs, from_='xy')
         else:
-            # If both sets of coefficients are available, use uv_from_xy as the
-            # guess. Otherwise, use a flat FOV
-            if self.coefft_uv_from_xy is not None:
-                duv_guess = PolyFOV._eval_polynomial(xy,
-                                                     self.coefft_uv_from_xy,
-                                                     self.coefft_duv_dx,
-                                                     self.coefft_duv_dy,
-                                                     derivs=False)
-            else:
-                duv_guess = (self.flat_fov.uv_from_xy(xy, derivs=False)
-                             - self.uv_los)
-
-            # Use the xy_from_uv coefficients to ensure that the polynomial
-            # inversion is exact.
-            duv = PolyFOV._solve_polynomial(xy, duv_guess,
-                                            self.coefft_xy_from_uv,
-                                            self.coefft_dxy_du,
-                                            self.coefft_dxy_dv,
-                                            derivs=derivs,
-                                            iters=self.iters,
-                                            precision=self.uv_precision)
-
-        # Add back the center of the field of view
-        uv = duv + self.uv_los
-
-        # Mask if necessary
-        if remask:
-            uv = uv.mask_or(self.uv_is_outside(uv).vals)
+            uv = self._solve_polynomial(xy, self.coefft_xy_from_uv,
+                                        derivs=derivs, from_='xy', fast=fast)
 
         return uv
 
     #===========================================================================
-    @staticmethod
-    def _eval_polynomial(pq, coefft, dcoefft_p, dcoefft_q,
-                         derivs=False, d_dpq=False):
-        """Evaluate the polynomial at pair (p,q) to return (a,b).
+    def _compute_polynomial(self, r, coefft, derivs):
+        """Compute the 1-D polynomial.
+
+        Input:
+            r        Scalar of arbitrary shape specifying the points at which
+                     to evaluate the polynomial.
+            coefft   The coefficient array defining the polynomial.
+            derivs   If True, derivatives are computed and included in the
+                     result.
+
+        Output:      (f, deriv)
+            f        Scalar of the same shape as r giving the values of
+                     the polynomial at each input point.
+        """
+
+        r = Scalar.as_scalar(r, derivs)
+        order = coefft.shape[0]-1
+
+        # Construct the powers of radius
+        r_powers = [1.]
+        for k in range(1, order+1):
+            r_powers.append(r_powers[-1] * r.vals)
+
+        # Evaluate the polynomial
+        #
+        # Start with the high-order terms and work downward, because this
+        # improves accuracy. Stop at one because there are no zero-order
+        # terms.
+        f_vals = np.zeros(r.shape)
+        for i in range(order, -1, -1):
+            f_vals += coefft[i] * r_powers[i]
+        f = Scalar(f_vals, r.mask)
+
+        # Calculate derivatives if necessary
+        if derivs:
+            df_dr_vals = np.zeros(r.shape)
+            for i in range(order, 0, -1):
+                df_dr_vals += i*coefft[i]*r_powers[i-1]
+            df_dr = Scalar(df_dr_vals, r.mask)#   , drank=1)
+
+#            f.propagate_deriv(r, 'dr', df_dr, derivs)
+            new_derivs = {'r':df_dr}
+            if r.derivs:
+                for (key, r_deriv) in r.derivs.items():
+                    new_derivs[key] = df_dr.chain(r_deriv)
+            f.insert_derivs(new_derivs)
+
+        return f
+
+    #===========================================================================
+    def _apply_polynomial(self, pq, coefft, derivs, from_):
+        """Apply the polynomial to pair (p,q) to return (a,b).
 
         Input:
             pq          Pairs of arbitrary shape specifying the points at which
                         to evaluate the polynomial.
-            coefft      coefficient array defining the polynomial.
-            dcoefft_p   coefficient array for the polynomial derivative with
-                        respect to p.
-            dcoefft_q   coefficient array for the polynomial derivative with
-                        respect to q.
-            derivs      if True, derivatives are computed and included in the
+            coefft      The coefficient array defining the polynomial.
+            derivs      If True, derivatives are computed and included in the
                         result.
-            d_dpq       if True, the returned quantity is a tuple (f, df/dpq);
-                        otherwise, only f is returned.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
 
-        Return          ab or (ab, dab_dpq), depending on df_dpq input.
-            ab          value of the polynomial.
-            dab_dpq     optional derivative of f with respect to pq.
+        Output:         ab
+            ab          Pairs of the same shape as pq giving the values of
+                        the polynomial at each input point.
         """
 
-        pq = Pair.as_pair(pq, derivs)
+        assert from_ in ('uv', 'xy')
+        dkey = from_
 
-        # Start with empty buffer
-        order_plus_1 = coefft.shape[0]
-        powers = np.empty((order_plus_1, order_plus_1) + pq.shape)
-
-        p = pq.vals[...,0]
-        q = pq.vals[...,1]
-
-        # Fill in powers[:,0] with powers of p
-        powers[0,0] = 1.
-        powers[1,0] = p
-        for k in range(2, order_plus_1):
-            powers[k,0] = powers[k-1,0] * p
-
-        # Fill in powers[:,1] with q times powers of p
-        powers[0,1] = q     # skip an unnecessary multiply by one
-        powers[1:,1] = q * powers[1:,0]
-
-        # Fill in powers[:,2:] with q times powers[:,1:]
-        for k in range(2, order_plus_1):
-            powers[:,k] = q * powers[:,k-1]
-
-        # Rotate the leading axes to the end
-        powers = np.moveaxis(powers, (0,1), (-2,-1))[..., np.newaxis]
-
-        # Evaluate the polynomials
-        ab = Pair(np.sum(coefft * powers, axis=(-3,-2)), pq.mask)
-
-        # Evaluate the derivatives with respect to pq if necessary
-        if d_dpq or derivs:
-            dab_dpq_vals = np.empty((2,) + pq.vals.shape)
-            _ = np.sum(dcoefft_p * powers[...,:-1,:,:], axis=(-3,-2),
-                       out=dab_dpq_vals[0])
-            _ = np.sum(dcoefft_q * powers[...,:,:-1,:], axis=(-3,-2),
-                       out=dab_dpq_vals[1])
-            dab_dpq = Pair(np.moveaxis(dab_dpq_vals, 0, -1), drank=1)
+        # Correct polynomial
+        if derivs:
+            pq.insert_deriv(dkey, Pair.IDENTITY)
 
-        # Calculate additional derivatives if necessary
+        if from_ == 'xy':
+            ab0 = pq.element_div(self.uv_scale, recursive=derivs)
+        else:
+            pq = pq - self.uv_los
+            ab0 = pq.element_mul(self.uv_scale, recursive=derivs)
+
+        r = ab0.norm(recursive=derivs)
+        c = self._compute_polynomial(r, coefft, derivs=derivs)
+
+        ab = ab0 * c
+        if from_ == 'xy':
+            ab = ab + self.uv_los
+
+        # Propagate derivatives if necessary
+#        ab.propagate_deriv(pq, dkey, test=derivs)
         if derivs:
             new_derivs = {}
-            for key, deriv in pq.derivs.items():
-                new_derivs[key] = dab_dpq.chain(deriv)
+            if pq.derivs:
+                for (key, pq_deriv) in pq.derivs.items():
+                    new_derivs[key] = ab.derivs[dkey].chain(pq_deriv)
             ab.insert_derivs(new_derivs)
 
-        if d_dpq:
-            return (ab, dab_dpq)
+        return ab
+
+    #===========================================================================
+    def _guess(self, ab, coefft, from_):
+        """Compute the initial guess for the polynomial inversion.
+
+        Input:
+            ab          Pairs of arbitrary shape specifying the points at which
+                        to compute the guess.
+            coefft      The coefficient array defining the polynomial.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
+
+        Output:         pq
+            pq          Pairs of of the same shape as ab giving the values of
+                        the inverted polynomial at each input point.
+        """
+
+        if from_ == 'xy':
+            return self.flat_fov.uv_from_xy(ab, derivs=False)
         else:
-            return ab
+            return self.flat_fov.xy_from_uv(ab, derivs=False)
 
     #===========================================================================
-    @staticmethod
-    def _solve_polynomial(ab, pq_guess, coefft, dcoefft_p, dcoefft_q,
-                          derivs=False, iters=8, precision=0.):
+    # NOTE: this is identical to _solve_polynomial in polynomial.py
+
+    def _solve_polynomial(self, ab, coefft, derivs, from_, fast=False):
         """Solve the polynomial for an (a,b) pair to return (p,q).
 
         Input:
-            ab          Pair of arbitrary shape specifying the values of the
-                        polynomial.
-            pq_guess    initial guess at the values to return.
-            coefft      coefficient array defining the polynomial.
-            dcoefft_p   coefficient array for the polynomial derivative with
-                        respect to p.
-            dcoefft_q   coefficient array for the polynomial derivative with
-                        respect to q.
-            derivs      if True, derivatives are included in the output.
-            iters       maximum number of iterations of Newton's method.
-            precision   absolute precision desired. Approximate limit is OK, and
-                        the only down-side of zero (the default) is that the
-                        solution will require one extra iteration.
-
-        Output:         Pair of the same shape as ab giving the values at which
-                        the polynomial evaluates to ab.
+            ab          Pairs of arbitrary shape specifying the points at which
+                        to invert the polynomial.
+            coefft      The coefficient array defining the polynomial to invert.
+            derivs      If True, derivatives are included in the output.
+            from_       Source system, for labeling the derivatives, e.g., 'uv'
+                        or 'xy'.
+            fast        If True, a faster, but possibly less robust, convergence
+                        criterion is used.  The unittests with SpeedTest = True
+                        produced the folowing results:
+
+                        Slow Newton's method: convergence: 8.81250858307 ms
+                        Fast Newton's method: convergence: 4.69124555588 ms
+                        Slow/Fast =  1.87850081137
+
+        Output:         pq
+            pq          Pairs of of the same shape as ab giving the values of
+                        the inverted polynomial at each input point.
         """
 
+        src = {'uv','xy'}
+        assert from_ in src
+        to_ = (src^{from_}).pop()
+        dkey = from_
+
         ab = Pair.as_pair(ab, derivs)
+        ab_wod = ab.wod
 
-        # Handle fully-masked case
-        if np.all(ab.mask):
-            return Pair(np.zeros(ab.shape), True)
-
-        # Because convergence is quadratic in Newton's method, once we get half-
-        # way to convergence, the next iteration should be exact.
-        eps = np.sqrt(precision) / 10.         # /10 is just for extra safety
-
-        # Make sure the initial pq guess is an array copy and uses ab's mask
-        pq = Pair(pq_guess.vals.copy(), ab.mask)
-
-        max_dpq = 1.e99
-        converged = False
-        for count in range(iters):
-            ab_test, dab_dpq = PolyFOV._eval_polynomial(pq, coefft,
-                                                            dcoefft_p,
-                                                            dcoefft_q,
-                                                            derivs=False,
-                                                            d_dpq=True)
-
-            # Perform one step of Newton's Method
-            dpq_dab = dab_dpq.reciprocal(nozeros=True)
-                # nozeros=True is safe because dab_dpq can't be zero-valued
-            dpq = dpq_dab.chain(ab.wod - ab_test)
-            new_max_dpq = dpq.norm().max(builtins=True, masked=-1.)
-
-            if LOGGING.fov_iterations or PolyFOV.DEBUG:
-                LOGGING.convergence('PolyFOV._solve_polynomial:',
-                                    'iter=%d; change=%.6g' % (count+1,
-                                                              new_max_dpq))
-
-            # Quit when convergence stops
-            if new_max_dpq <= eps:
-                pq += dpq
-                converged = True
-                break
-
-            if new_max_dpq >= max_dpq:
-                break
-
-            pq += dpq.vals
-            max_dpq = new_max_dpq
-
-        if not converged:
-            LOGGING.warn('PolyFOV._solve_polynomial did not converge;',
-                         'iter=%d; change=%.6g' % (count+1, new_max_dpq))
+        # Make a rough initial guess
+        pq = self._guess(ab_wod, coefft, from_)
+        pq.insert_deriv(dkey, Pair.IDENTITY)
+
+        # Iterate until convergence...
+        epsilon = 1.e-15
+        prev_dpq_max = 1.e99
+        for count in range(self.iters):
+
+            # Evaluate the forward transform and its partial derivatives
+            ab0 = self._apply_polynomial(pq, coefft, derivs=True, from_=to_)
+            dab_dpq = ab0.derivs[dkey]
+
+            # Apply one step of Newton's method in 2-D
+            dab = ab_wod - ab0.wod
+
+            dpq_dab = dab_dpq.reciprocal()
+            dpq = dpq_dab.chain(dab)
+            pq += dpq
+
+            # Convergence tests...
+
+            # simpler, but faster convergence
+            if fast:
+
+                # Compare the max step size with the max coordinate value
+                # This removes any positional dependence of the relative
+                # error.  The denominator can only be zero if the entire
+                # grid is (0,0).
+                error_max = abs(dpq.vals).max() / abs(pq.vals).max()
+                if RadialFOV.DEBUG:
+                   print(count+1, error_max)
+
+                # Test for root
+                #  This eliminates cases where the iteration bounces
+                #  around near the solution, as long as it's within
+                #  epsilon.
+                if abs(dab).max() <= epsilon:
+                    break
+
+                # Relative correction below epsilon.
+                if error_max <= epsilon:
+                    break
 
-        # Propagate derivatives if necessary
-        if derivs:
-            new_derivs = {}
-            for key, deriv in ab.derivs.items():
-                new_derivs[key] = dpq_dab.chain(deriv)
+            # slower convergence, but more robust
+            else:
+
+                # The old convergence test below was looking for the correction
+                # to overshoot.  This may in principle be a more robust way to
+                # ensure machine precision is achieved, but it requires some
+                # additonal iterations conmpared to the simpler test above.
+                dpq_max = abs(dpq).max()
+                if RadialFOV.DEBUG:
+                    print(count+1, dpq_max)
+
+                if dpq_max >= prev_dpq_max:
+                    break
+
+                prev_dpq_max = dpq_max
+
+        if RadialFOV.DEBUG:
+            print(iter+1, 'iterations')
 
+        pq = pq.wod
+
+        # Fill in derivatives if necessary
+#        pq.propagate_deriv(ab, dkey, dpq_dab, derivs)
+        if derivs:
+            new_derivs = {dkey:dpq_dab}
+            if ab.derivs:
+                for (key, ab_deriv) in ab.derivs.items():
+                    new_derivs[key] = dpq_dab.chain(ab_deriv)
             pq.insert_derivs(new_derivs)
 
         return pq
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
-import time
 
-class Test_PolyFOV(unittest.TestCase):
+class Test_RadialFOV(unittest.TestCase):
 
     def runTest(self):
 
-        np.random.seed(5294)
+        import time
+        from oops.fov.barrelfov import BarrelFOV
+
+        np.random.seed(1208)
 
-        PolyFOV.DEBUG = False
+        RadialFOV.DEBUG = False
         SpeedTest = False
 
         ########################################
         # Only xy_from_uv defined
         ########################################
 
-        coefft_xy_from_uv = np.zeros((3,3,2))
-        coefft_xy_from_uv[...,0] = np.array([[ 5.00, -0.10, -0.01],
-                                             [ 1.20, -0.01,  0.00],
-                                             [-0.02,  0.00,  0.00]])
-        coefft_xy_from_uv[...,1] = np.array([[ 0.00, -1.10,  0.01],
-                                             [-0.20, -0.03,  0.00],
-                                             [-0.02,  0.00,  0.00]])
+        # These are JunoCam parameters
+        coefft_xy_from_uv = np.array([1.,
+                                      0.,
+                                     -5.9624209455667325e-08,
+                                      0.,
+                                      2.7381910042256151e-14])
+        scale = 0.00067540618
+        shape = (1648,128)
+        fov = RadialFOV(scale, shape, coefft_xy_from_uv=coefft_xy_from_uv)
 
-        fov = PolyFOV((20,15), coefft_xy_from_uv=coefft_xy_from_uv)
+        self.assertTrue(fov.max_inversion_error() < 3.e-13)
 
         #### uv -> xy -> uv, with derivs
 
-        uv = Pair.combos(np.arange(20), np.arange(15))
-        uv.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
-        uv.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
+        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
+        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
 
         if SpeedTest:
-            iters = 100
-            t0 = time.time()
-            for k in range(iters):
-                xy = fov.xy_from_uv(uv, derivs=True)
-                uv_test = fov.uv_from_xy(xy, derivs=True)
-            t1 = time.time()
-            LOGGING.info('time = %.2f ms' % ((t1-t0)/iters*1000.), literal=True)
+            iters = 50
+            for fast in (True, False):
+                t0 = time.time()
+                for k in range(iters):
+                    xy = fov.xy_from_uv(uv, derivs=True)
+                    uv_test = fov.uv_from_xy(xy, derivs=True, fast=fast)
+                t1 = time.time()
+                print('%s time = %.2f ms' % ('fast' if fast else 'slow',
+                                             (t1-t0)/iters*1000.))
         else:
             xy = fov.xy_from_uv(uv, derivs=True)
             uv_test = fov.uv_from_xy(xy, derivs=False)
 
         uv_test = fov.uv_from_xy(xy)
-        self.assertTrue(abs(uv - uv_test).max() < 1.e-14)
+        self.assertTrue(abs(uv - uv_test).max() < 3.e-13)
 
         EPS = 1.e-6
         xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
         xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
         dxy_du = (xy1 - xy0) / (2. * EPS)
 
         xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
@@ -489,62 +466,60 @@
         self.assertTrue(abs(xy.d_dt.vals         - dxy_dt.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,0] - dxy_dr.vals).max() <= DEL)
         self.assertTrue(abs(xy.d_drs.vals[...,1] - dxy_ds.vals).max() <= DEL)
 
         #### xy -> uv -> xy, with derivs
 
         xy = fov.xy_from_uv(uv, derivs=False)
-        xy.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
-        xy.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
+        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
         uv = fov.uv_from_xy(xy, derivs=True)
 
-        xy_test = fov.xy_from_uv(uv)
-        self.assertTrue(abs(xy - xy_test).max() < 1.e-14)
-
         EPS = 1.e-6
         uv0 = fov.uv_from_xy(xy + (-EPS,0), False)
         uv1 = fov.uv_from_xy(xy + ( EPS,0), False)
         duv_dx = (uv1 - uv0) / (2. * EPS)
 
         uv0 = fov.uv_from_xy(xy + (0,-EPS), False)
         uv1 = fov.uv_from_xy(xy + (0, EPS), False)
         duv_dy = (uv1 - uv0) / (2. * EPS)
 
         duv_dt = duv_dx * xy.d_dt.vals[...,0]    + duv_dy * xy.d_dt.vals[...,1]
         duv_dr = duv_dx * xy.d_drs.vals[...,0,0] + duv_dy * xy.d_drs.vals[...,1,0]
         duv_ds = duv_dx * xy.d_drs.vals[...,0,1] + duv_dy * xy.d_drs.vals[...,1,1]
 
-        DEL = 1.e-7
+        DEL = 1.e-6
         self.assertTrue(abs(uv.d_dt.vals         - duv_dt.vals).max() <= DEL)
         self.assertTrue(abs(uv.d_drs.vals[...,0] - duv_dr.vals).max() <= DEL)
         self.assertTrue(abs(uv.d_drs.vals[...,1] - duv_ds.vals).max() <= DEL)
 
         ########################################
         # Only uv_from_xy defined
         ########################################
 
-        coefft_uv_from_xy = np.zeros((3,3,2))
-        coefft_uv_from_xy[...,0] = np.array([[ 5.00, -0.10, -0.01],
-                                             [ 1.20, -0.01,  0.00],
-                                             [-0.02,  0.00,  0.00]])
-        coefft_uv_from_xy[...,1] = np.array([[ 0.00, -1.10,  0.01],
-                                             [-0.20, -0.03,  0.00],
-                                             [-0.02,  0.00,  0.00]])
+        coefft_uv_from_xy = np.array([1.000,
+                                      0,
+                                     -5.9624209455667325e-08,
+                                      0,
+                                      2.7381910042256151e-14])
+        scale = 0.00067540618
+        shape = (1648,128)
+        fov = RadialFOV(scale, shape, coefft_uv_from_xy=coefft_uv_from_xy)
 
-        fov = PolyFOV((20,15), coefft_uv_from_xy=coefft_uv_from_xy)
+        self.assertTrue(fov.max_inversion_error() < 3.e-13)
 
         #### uv -> xy -> uv, with derivs
 
         uv = Pair.combos(np.arange(20), np.arange(15))
         uv.insert_deriv('t' , Pair(np.random.randn(20,15,2)))
         uv.insert_deriv('rs', Pair(np.random.randn(20,15,2,2), drank=1))
         xy = fov.xy_from_uv(uv, derivs=True)
 
         uv_test = fov.uv_from_xy(xy)
-        self.assertTrue(abs(uv - uv_test).max() < 1.e-14)
+        self.assertTrue(abs(uv - uv_test).max() < 3.e-13)
 
         EPS = 1.e-6
         xy0 = fov.xy_from_uv(uv + (-EPS,0), False)
         xy1 = fov.xy_from_uv(uv + ( EPS,0), False)
         dxy_du = (xy1 - xy0) / (2. * EPS)
 
         xy0 = fov.xy_from_uv(uv + (0,-EPS), False)
@@ -579,16 +554,109 @@
         uv1 = fov.uv_from_xy(xy + (0, EPS), False)
         duv_dy = (uv1 - uv0) / (2. * EPS)
 
         duv_dt = duv_dx * xy.d_dt.vals[...,0]    + duv_dy * xy.d_dt.vals[...,1]
         duv_dr = duv_dx * xy.d_drs.vals[...,0,0] + duv_dy * xy.d_drs.vals[...,1,0]
         duv_ds = duv_dx * xy.d_drs.vals[...,0,1] + duv_dy * xy.d_drs.vals[...,1,1]
 
-        DEL = 1.e-7
+        DEL = 1.e-6
         self.assertTrue(abs(uv.d_dt.vals         - duv_dt.vals).max() <= DEL)
         self.assertTrue(abs(uv.d_drs.vals[...,0] - duv_dr.vals).max() <= DEL)
         self.assertTrue(abs(uv.d_drs.vals[...,1] - duv_ds.vals).max() <= DEL)
 
+        ########################################
+        # Only xy_from_uv defined, comparison to BarrelFOV
+        ########################################
+
+        coefft_xy_from_uv = np.array([1.,
+                                      0.,
+                                     -5.9624209455667325e-08,
+                                      0.,
+                                      2.7381910042256151e-14])
+        scale = 0.00067540618
+        shape = (1648,128)
+        radial = RadialFOV(scale, shape, coefft_xy_from_uv=coefft_xy_from_uv)
+        barrel = BarrelFOV(scale, shape, coefft_xy_from_uv=coefft_xy_from_uv)
+
+        #### uv -> xy -> uv, with derivs
+
+        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
+        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+
+        xy1 = radial.xy_from_uv(uv, derivs=True)
+        xy2 = barrel.xy_from_uv(uv, derivs=True)
+
+        DEL = 1.e-15
+        self.assertTrue(abs(xy1.vals       - xy2.vals      ).max() <= DEL)
+        self.assertTrue(abs(xy1.d_dt.vals  - xy2.d_dt.vals ).max() <= DEL)
+        self.assertTrue(abs(xy1.d_drs.vals - xy2.d_drs.vals).max() <= DEL)
+
+        #### xy -> uv -> xy, with derivs
+
+        xy = fov.xy_from_uv(uv, derivs=False)
+        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+
+        uv1 = radial.uv_from_xy(xy, derivs=True)
+        uv2 = barrel.uv_from_xy(xy, derivs=True)
+
+        DEL = 3.e-12
+        self.assertTrue(abs(uv1.vals       - uv2.vals      ).max() <= DEL)
+        self.assertTrue(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max() <= DEL)
+        self.assertTrue(abs(uv1.d_drs.vals - uv2.d_drs.vals).max() <= DEL)
+
+        ########################################
+        # Only uv_from_xy defined, comparison to BarrelFOV
+        ########################################
+
+
+        coefft_uv_from_xy = np.array([1.000,
+                                      0,
+                                     -5.9624209455667325e-08,
+                                      0,
+                                      2.7381910042256151e-14])
+        scale = 0.00067540618
+        shape = (1648,128)
+        radial = RadialFOV(scale, shape, coefft_uv_from_xy=coefft_uv_from_xy)
+        barrel = BarrelFOV(scale, shape, coefft_uv_from_xy=coefft_uv_from_xy)
+
+        #### uv -> xy -> uv, with derivs
+
+        uv = Pair.combos(np.arange(0,1648,20), np.arange(0,129,8))
+        uv.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        uv.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+
+        xy1 = radial.xy_from_uv(uv, derivs=True)
+        xy2 = barrel.xy_from_uv(uv, derivs=True)
+
+        # Not great consistency with BarrelFOV, but in the ballpark...
+        self.assertTrue(abs(xy1.vals       - xy2.vals      ).max() <= 0.02)
+        self.assertTrue(abs(xy1.d_dt.vals  - xy2.d_dt.vals ).max() <= 0.0002)
+        self.assertTrue(abs(xy1.d_drs.vals - xy2.d_drs.vals).max() <= 0.0002)
+
+        #### xy -> uv -> xy, with derivs
+
+        xy = fov.xy_from_uv(uv, derivs=False)
+        xy.insert_deriv('t' , Pair(np.random.randn(83,17,2)))
+        xy.insert_deriv('rs', Pair(np.random.randn(83,17,2,2), drank=1))
+
+        uv1 = radial.uv_from_xy(xy, derivs=True)
+        uv2 = barrel.uv_from_xy(xy, derivs=True)
+
+# Poor results, but I have to believe the problem is here, not in BarrelFOV.
+#         print(abs(uv1.vals       - uv2.vals      ).max())
+#         print(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max())
+#         print(abs(uv1.d_drs.vals - uv2.d_drs.vals).max())
+# 24.451752616098474
+# 294.29459007040805
+# 247.03578477133442
+#
+#         DEL = 3.e-12
+#         self.assertTrue(abs(uv1.vals       - uv2.vals      ).max() <= DEL)
+#         self.assertTrue(abs(uv1.d_dt.vals  - uv2.d_dt.vals ).max() <= DEL)
+#         self.assertTrue(abs(uv1.d_drs.vals - uv2.d_drs.vals).max() <= DEL)
+
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/fov/slicefov.py` & `rms_oops-0.0.4/oops/fov/subarray.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,47 +1,63 @@
 ################################################################################
-# oops/fov/slicefov.py: SliceFOV subclass of FOV
+# oops/fov/subarray.py: Subarray subclass of FOV
 ################################################################################
 
 from polymath import Pair
 from oops.fov import FOV
 
-class SliceFOV(FOV):
-    """A subclass of FOV in which only a slice of another FOV's (u,v) array is
-    used, but the geometry is unchanged.
-
-    This differs from a Subarray in that the optic axis is not modified.
-    """
+class Subarray(FOV):
+    """Subclass of FOV that describes a rectangular region of a larger FOV."""
 
     #===========================================================================
-    def __init__(self, fov, origin, shape):
-        """Constructor for a SliceFOV.
+    def __init__(self, fov, new_los, uv_shape, uv_los=None):
+        """Constructor for a Subarray.
+
+        In the returned FOV object, the ICS origin and/or the optic axis have
+        been modified.
 
-        Inputs:
-            fov         the reference FOV object within which this slice is
-                        defined.
+        Input:
+            fov         the FOV object within which this subarray is defined.
 
-            origin      a tuple or Pair defining the location of the subarray's
-                        pixel (0,0) in the coordinates of the reference FOV.
+            new_los     a tuple or Pair defining the location of the subarray's
+                        line of sight in the (u,v) coordinates of the original
+                        FOV.
 
-            shape       a single value, tuple or Pair defining the new shape of
+            uv_shape    a single value, tuple or Pair defining the new size of
                         the field of view in pixels.
+
+            uv_los      a single value, tuple or Pair defining the (u,v)
+                        coordinates of the new line of sight. By default,
+                        this is the midpoint of the rectangle, i.e, uv_shape/2.
         """
 
         self.fov = fov
-        self.uv_origin = Pair.as_pair(origin).as_int().as_readonly()
-        self.uv_shape  = Pair.as_pair(shape).as_int().as_readonly()
+        self.new_los_in_old_uv  = Pair.as_pair(new_los).as_float()
+        self.new_los_wrt_old_xy = fov.xy_from_uv(self.new_los_in_old_uv)
+        self.uv_shape = Pair.as_pair(uv_shape).as_readonly()
+
+        if uv_los is None:
+            self.uv_los = self.uv_shape / 2.
+        else:
+            self.uv_los = Pair.as_pair(uv_los).as_readonly()
+
+        self.new_origin_in_old_uv = self.new_los_in_old_uv - self.uv_los
+
+        self.new_los_in_old_uv.as_readonly()
+        self.new_los_wrt_old_xy.as_readonly()
+        self.uv_shape.as_readonly()
+        self.uv_los.as_readonly()
+        self.new_origin_in_old_uv.as_readonly
 
         # Required fields
-        self.uv_los   = self.fov.uv_los - self.uv_origin
         self.uv_scale = self.fov.uv_scale
         self.uv_area  = self.fov.uv_area
 
     def __getstate__(self):
-        return (self.fov, self.uv_origin, self.shape)
+        return (self.fov, self.new_los, self.uv_shape, self.uv_los)
 
     def __setstate__(self, state):
         self.__init__(*state)
 
     #===========================================================================
     def xy_from_uvt(self, uv_pair, time=None, derivs=False, remask=False,
                                                             **keywords):
@@ -58,16 +74,18 @@
             **keywords  Additional keywords arguments are passed directly to the
                         reference FOV.
 
         Return:         Pair of same shape as uv_pair, giving the transformed
                         (x,y) coordinates in the camera's frame.
         """
 
-        return self.fov.xy_from_uvt(uv_pair + self.uv_origin, time=time,
-                                    derivs=derivs, remask=remask, **keywords)
+        old_xy = self.fov.xy_from_uvt(self.new_origin_in_old_uv + uv_pair,
+                                      time=time, derivs=derivs, remask=remask,
+                                      **keywords)
+        return old_xy - self.new_los_wrt_old_xy
 
     #===========================================================================
     def uv_from_xyt(self, xy_pair, time=None, derivs=False, remask=False,
                                                             **keywords):
         """The (u,v) FOV coordinates given the (x,y) camera frame coordinates at
         the specified time.
 
@@ -81,28 +99,13 @@
             **keywords  Additional keywords arguments are passed directly to the
                         reference FOV.
 
         Return:         Pair of same shape as xy_pair, giving the computed (u,v)
                         FOV coordinates.
         """
 
-        new_xy = self.fov.uv_from_xy(xy_pair, time=time, derivs=derivs,
-                                              remask=remask, **keywords)
-        return new_xy - self.uv_origin
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_SliceFOV(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
+        old_uv = self.fov.uv_from_xyt(self.new_los_wrt_old_xy + xy_pair,
+                                      time=time, derivs=derivs, remask=remask,
+                                      **keywords)
+        return old_uv - self.new_origin_in_old_uv
 
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/__init__.py` & `rms_oops-0.0.4/oops/frame/frame_.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,26 +1,31 @@
 ################################################################################
-# oops/frame/__init__.py: Abstract class Frame and its required subclasses
+# oops/frame/frame_.py: Abstract class Frame and its required subclasses
 ################################################################################
 
 import numpy as np
 from scipy.interpolate import InterpolatedUnivariateSpline
-from polymath          import Matrix3, Quaternion, Qube, Scalar, Vector3
-from oops.config       import QUICK, LOGGING, PICKLE_CONFIG
-from oops.transform    import Transform
+
+from polymath       import Matrix3, Quaternion, Qube, Scalar, Vector3
+from oops.config    import QUICK, LOGGING, PICKLE_CONFIG
+from oops.transform import Transform
 
 class Frame(object):
     """A Frame is an abstract class that returns a Transform (rotation matrix
     and spin vector) given a Scalar time.
 
     A Transform converts from a reference coordinate frame to a target
     coordinate frame, either of which could be non-inertial. All coordinate
     frames are ultimately referenced to J2000.
     """
 
+    # To avoid circular imports; filled in by oops/__init__.py
+    EVENT_CLASS = None
+    PATH_CLASS = None
+
     J2000 = None
     WAYFRAME_REGISTRY = {}
     FRAME_CACHE = {}
     TEMPORARY_FRAME_ID = 10000
 
     STANDARD_FRAMES = set()     # Frames that always have the same definition
 
@@ -498,15 +503,15 @@
         OVERHEAD = 500      # Assume it takes the equivalent time of this many
                             # evaluations just to set up the QuickFrame.
         SPEEDUP = 5.        # Assume that evaluations are this much faster once
                             # the QuickFrame is set up.
         SAVINGS = 0.2       # Require at least a 20% savings in evaluation time.
 
         # Make sure a QuickFrame has been requested
-        if type(quick) != dict:
+        if not isinstance(quick, dict):
             return self
 
         # These subclasses do not require QuickFrames
         if type(self) in (QuickFrame, Wayframe, AliasFrame):
             return self
 
         # Obtain the local QuickFrame dictionary
@@ -1233,156 +1238,7 @@
 Frame.J2000.wrt_j2000 = Frame.J2000
 
 # Initialize the registry
 Frame.initialize_registry()
 Frame.STANDARD_FRAMES.add(Frame.J2000)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Frame(unittest.TestCase):
-
-    def runTest(self):
-
-        # Re-import here to so modules all come from the oops tree
-        from oops.frame import Frame, QuickFrame
-
-        # More imports are here to avoid conflicts
-        import os
-        import cspyce
-        from oops.frame.rotation     import Rotation
-        from oops.frame.spiceframe   import SpiceFrame
-        from oops.path.spicepath     import SpicePath
-        from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
-
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/naif0009.tls'))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/pck00010.tpc'))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/de421.bsp'))
-
-        Frame.reset_registry()
-
-        # QuickFrame tests
-
-        _ = SpicePath('EARTH', 'SSB')
-        _ = SpicePath('MOON', 'SSB')
-        _ = SpiceFrame('IAU_EARTH', 'J2000')
-        moon  = SpiceFrame('IAU_MOON', 'IAU_EARTH')
-        quick = QuickFrame(moon, (-5.,5.),
-                        dict(QUICK.dictionary, **{'frame_self_check':3.e-14}))
-
-        # Perfect precision is impossible
-        try:
-            quick = QuickFrame(moon, (-5.,5.),
-                        dict(QUICK.dictionary, **{'frame_self_check':0.}))
-            self.assertTrue(False, 'No ValueError raised for PRECISION = 0.')
-        except ValueError:
-            pass
-
-        # Timing tests...
-        test = np.zeros(200000)
-        # _ = moon.transform_at_time(test, quick=False)   # takes about 10 sec
-        _ = quick.transform_at_time(test)           # takes way less than 1 sec
-
-        Frame.reset_registry()
-
-        ################################
-        # Test unregistered frames
-        ################################
-
-        j2000 = Frame.as_wayframe('J2000')
-        rot_180 = Rotation(np.pi, 2, j2000)
-        self.assertTrue(rot_180.frame_id.startswith('TEMPORARY'))
-
-        xform = rot_180.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0], -1, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1],  0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0],  0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1], -1, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-        rot_neg60 = Rotation(-np.pi/3, 2, rot_180)
-        self.assertTrue(rot_neg60.frame_id.startswith('TEMPORARY'))
-
-        c60 = 0.5
-        s60 = np.sqrt(0.75)
-
-        xform = rot_neg60.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0],  c60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1], -s60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0],  s60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1],  c60, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-        rot_neg120 = Rotation(-np.pi/1.5, 2, rot_neg60)
-        self.assertTrue(rot_neg120.frame_id.startswith('TEMPORARY'))
-
-        xform = rot_neg120.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0], -c60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1], -s60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0],  s60, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1], -c60, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-        # Attempt to register a frame defined relative to an unregistered frame
-        self.assertRaises(ValueError, Rotation, -np.pi, 2, rot_neg60, 'NEG180')
-
-        # Link unregistered frame to registered frame
-        identity = rot_neg120.wrt('J2000')
-
-        xform = identity.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0], 1, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1], 0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0], 0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1], 1, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-        # Link registered frame to unregistered frame
-        identity = Frame.J2000.wrt(rot_neg120)
-
-        xform = identity.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0], 1, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1], 0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0], 0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1], 1, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-        # Link unregistered frame to registered frame
-        identity = rot_neg120.wrt(rot_180)
-
-        xform = identity.transform_at_time(0.)
-        self.assertAlmostEqual(xform.matrix.vals[0,0], -1, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[0,1],  0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,0],  0, delta=1.e-14)
-        self.assertAlmostEqual(xform.matrix.vals[1,1], -1, delta=1.e-14)
-        self.assertEqual(xform.matrix.vals[2,0], 0)
-        self.assertEqual(xform.matrix.vals[2,1], 0)
-        self.assertEqual(xform.matrix.vals[0,2], 0)
-        self.assertEqual(xform.matrix.vals[1,2], 0)
-        self.assertEqual(xform.matrix.vals[2,2], 1)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/all.py` & `rms_oops-0.0.4/tests/frame/all.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,16 @@
 ################################################################################
 # oops/frame/all.py
 ################################################################################
 
 # Import the Frame class and its core components into a common name space
 
-from oops.frame import (Frame, Wayframe, AliasFrame, LinkedFrame,
-                        RelativeFrame, ReversedFrame, QuickFrame)
+from oops.frame                  import (Frame, Wayframe, AliasFrame,
+                                         LinkedFrame, RelativeFrame,
+                                         ReversedFrame, QuickFrame)
 from oops.frame.cmatrix          import Cmatrix
 from oops.frame.inclinedframe    import InclinedFrame
 from oops.frame.laplaceframe     import LaplaceFrame
 from oops.frame.navigation       import Navigation
 from oops.frame.poleframe        import PoleFrame
 from oops.frame.postargframe     import PosTargFrame
 from oops.frame.ringframe        import RingFrame
```

### Comparing `rms_oops-0.0.3/oops/frame/inclinedframe.py` & `rms_oops-0.0.4/oops/frame/inclinedframe.py`

 * *Files 8% similar despite different names*

```diff
@@ -126,23 +126,7 @@
         """The longitude of ascending node at the specified time."""
 
         # Locate the ascending nodes in the reference frame
         return (self.node + self.rate * (Scalar.as_scalar(time)
                                          - self.epoch)) % Scalar.TWOPI
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_InclinedFrame(unittest.TestCase):
-
-    def runTest(self):
-
-        # Note: Unit testing is performed in surface/orbitplane.py
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/laplaceframe.py` & `rms_oops-0.0.4/oops/frame/laplaceframe.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
 # oops/frame/laplaceframe.py: Subclass LaplaceFrame of class Frame
 ################################################################################
 
 import numpy as np
+
 from polymath             import Matrix3, Qube, Scalar, Vector3
 from oops.frame           import Frame
 from oops.frame.poleframe import PoleFrame
 from oops.transform       import Transform
 
 class LaplaceFrame(Frame):
     """A Frame subclass defined by a Kepler Path and a tilt angle.
@@ -90,15 +91,15 @@
         if (not unpickled and self.shape == ()
             and self.frame_id in Frame.WAYFRAME_REGISTRY):
                 key = (self.orbit.path_id, self.tilt.vals)
                 LaplaceFrame.FRAME_IDS[key] = self.frame_id
 
     # Unpickled frames will always have temporary IDs to avoid conflicts
     def __getstate__(self):
-        return (Path.as_primary_path(self.orbit),
+        return (Frame.PATH_CLASS.as_primary_path(self.orbit),
                 self.tilt, self.given_cache_size, self.shape)
 
     def __setstate__(self, state):
         # If this frame matches a pre-existing frame, re-use its ID
         (orbit, tilt, cache_size, shape) = state
         if shape == ():
             key = (orbit.path_id, tilt.vals)
@@ -218,22 +219,7 @@
             self.cache_counter += 1
             count = np.array([self.cache_counter])
             self.cache[key] = (count, key, xform)
 
         return xform
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_LaplaceFrame(unittest.TestCase):
-
-    def runTest(self):
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/navigation.py` & `rms_oops-0.0.4/oops/frame/navigation.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
 # oops/frame/navigation.py: Fittable subclass Navigation of class Frame
 ################################################################################
 
 import numpy as np
+
 from polymath       import Matrix3, Vector, Vector3
 from oops.fittable  import Fittable
 from oops.frame     import Frame
 from oops.transform import Transform
 
 class Navigation(Frame, Fittable):
     """A Frame subclass describing a fittable, fixed offset from another frame,
@@ -137,23 +138,7 @@
         without affecting the original.
         """
 
         return Navigation(self.angles.copy(), self.reference,
                           matrix=self.transform.matrix.copy())
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Navigation(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/poleframe.py` & `rms_oops-0.0.4/ideas/deprecated/pushbroom.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,455 +1,495 @@
 ################################################################################
-# oops/frame/poleframe.py: Subclass PoleFrame of class Frame
+# oops/observation/pushbroom.py: Subclass Pushbroom of class Observation
 ################################################################################
 
 import numpy as np
-from polymath       import Matrix3, Qube, Scalar, Vector3
-from oops.frame     import Frame
-from oops.transform import Transform
-
-class PoleFrame(Frame):
-    """A Frame subclass describing a non-rotating frame centered on the Z-axis
-    of a body's pole vector.
-
-    This differs from RingFrame in that the pole may precess around a separate,
-    invariable pole for the system. Because of this behavior, the reference
-    longitude is defined as the ascending node of the invariable plane rather
-    than as the ascending node of the ring plane. This frame is recommended for
-    Neptune in particular.
-    """
-
-    FRAME_IDS = {}  # frame_id to use if a frame already exists upon un-pickling
-
-    #===========================================================================
-    def __init__(self, frame, pole, retrograde=False, aries=False, frame_id='+',
-                       cache_size=1000, unpickled=False):
-        """Constructor for a PoleFrame.
-
-        Input:
-            frame       a (possibly) rotating frame, or its ID, describing the
-                        central planet relative to J2000. This is typically a
-                        body's rotating SpiceFrame.
-
-            pole        The pole of the invariable plane, about which planet's
-                        pole precesses. This enables the reference longitude to
-                        be defined properly. Defined in J2000 coordinates.
-
-            retrograde  True to flip the sign of the Z-axis. Necessary for
-                        retrograde systems like Uranus.
-
-            aries       True to use the First Point of Aries as the longitude
-                        reference; False to use the ascending node of the
-                        invariable plane. Note that the former might be
-                        preferred in a situation where the invariable pole is
-                        uncertain, because small changes in the invariable pole
-                        will have only a limited effect on the absolute
-                        reference longitude.
-
-            frame_id    the ID under which the frame will be registered. None to
-                        leave the frame unregistered. If the value is "+", then
-                        the registered name is the planet frame's name with the
-                        suffix "_POLE". Note that this default ID will not be
-                        unique if frames are defined for multiple Laplace Planes
-                        around the same planet.
-
-            cache_size  number of transforms to cache. This can be useful
-                        because it avoids unnecessary SPICE calls when the frame
-                        is being used repeatedly at a finite set of times.
-
-            unpickled   True if this frame has been read from a pickle file.
-        """
-
-        # Rotates from J2000 to the invariable frame
-        pole = Vector3.as_vector3(pole)
-        (ra, dec, _) = pole.to_ra_dec_length(recursive=False)
-        self.invariable_matrix = Matrix3.pole_rotation(ra,dec)
-            # Rotates J2000 coordinates into a frame where the Z-axis is the
-            # invariable pole and the X-axis is the ascending node of the
-            # invariable plane on J2000
-        self.invariable_pole = pole
-        self.invariable_node = Vector3.ZAXIS.ucross(pole)
-
-        self.aries = bool(aries)
-        if self.aries:
-            # The ascending node of the invariable plane falls 90 degrees ahead
-            # pole's RA
-            self.invariable_node_lon = ra + np.pi/2.
-        else:
-            self.invariable_node_lon = 0.
-
-        self.planet_frame = Frame.as_frame(frame).wrt(Frame.J2000)
-        self.origin = self.planet_frame.origin
-        self.retrograde = bool(retrograde)
-        self.keys = set()
-        self.reference = Frame.J2000
-        self.shape = Qube.broadcasted_shape(self.invariable_pole,
-                                            self.planet_frame)
-
-        # Define cache
-        self.cache = {}
-        self.trim_size = max(cache_size//10, 1)
-        self.given_cache_size = cache_size
-        self.cache_size = cache_size + self.trim_size
-        self.cache_counter = 0
-        self.cached_value_returned = False          # Just used for debugging
-
-        # Fill in the frame ID
-        if frame_id is None:
-            self.frame_id = Frame.temporary_frame_id()
-        elif frame_id == '+':
-            self.frame_id = self.planet_frame.frame_id + '_POLE'
-        elif frame_id.startswith('+'):
-            self.frame_id = self.planet_frame.frame_id + '_' + frame_id[1:]
-        else:
-            self.frame_id = frame_id
-
-        # Register if necessary
-        self.register(unpickled=unpickled)
-
-        # Save in internal dict for name lookup upon serialization
-        if (not unpickled and self.shape == ()
-            and self.frame_id in Frame.WAYFRAME_REGISTRY):
-                key = (self.planet_frame.frame_id,
-                       tuple(self.invariable_pole.vals),
-                       retrograde, aries)
-                PoleFrame.FRAME_IDS[key] = self.frame_id
-
-    # Unpickled frames will always have temporary IDs to avoid conflicts
-    def __getstate__(self):
-        return (Frame.as_primary_frame(self.planet_frame),
-                self.invariable_pole, self.retrograde,
-                self.aries, self.given_cache_size, self.shape)
-
-    def __setstate__(self, state):
-        # If this frame matches a pre-existing frame, re-use its ID
-        (frame, pole, retrograde, aries, cache_size, shape) = state
-        if shape == ():
-            key = (frame.frame_id, tuple(pole.vals), retrograde, aries)
-            frame_id = PoleFrame.FRAME_IDS.get(key, None)
-        else:
-            frame_id = None
-
-        self.__init__(frame, pole, retrograde, aries, frame_id=frame_id,
-                      cache_size=cache_size, unpickled=True)
-
-    #===========================================================================
-    def transform_at_time(self, time, quick={}):
-        """The Transform into the this Frame at a Scalar of times."""
-
-        time = Scalar.as_scalar(time)
-
-        # Check cache first if time is a Scalar
-        if time.shape == ():
-            key = time.values
-
-            if key in self.cache:
-                self.cached_value_returned = True
-                (count, key, xform) = self.cache[key]
-                self.cache_counter += 1
-                count[0] = self.cache_counter
-                return xform
-
-        self.cached_value_returned = False
-
-        # Calculate the planet frame for the current time in J2000
-        xform = self.planet_frame.transform_at_time(time, quick=quick)
-
-        # The bottom row of the matrix is the Z-axis of the ring frame in J2000
-        z_axis = xform.matrix.row_vector(2)
-
-        # For a retrograde ring, reverse Z
-        if self.retrograde:
-            z_axis = -z_axis
-
-        planet_matrix = Matrix3.twovec(z_axis, 2,
-                                       Vector3.ZAXIS.cross(z_axis), 0)
-
-        # This is the RingFrame matrix. It rotates from J2000 to the frame where
-        # the pole at epoch is along the Z-axis and the ascending node relative
-        # to the J2000 equator is along the X-axis.
-
-        # Locate the J2000 ascending node of the RingFrame on the invariable
-        # plane.
-        planet_pole_j2000 = planet_matrix.inverse() * Vector3.ZAXIS
-        joint_node_j2000 = self.invariable_pole.cross(planet_pole_j2000)
-
-        joint_node_wrt_planet = planet_matrix * joint_node_j2000
-        joint_node_wrt_frame = self.invariable_matrix * joint_node_j2000
-
-        node_lon_wrt_planet = joint_node_wrt_planet.to_ra_dec_length()[0]
-        node_lon_wrt_frame = joint_node_wrt_frame.to_ra_dec_length()[0]
-
-        # Align the X-axis with the node of the invariable plane
-        matrix = Matrix3.z_rotation(node_lon_wrt_planet - node_lon_wrt_frame +
-                                    self.invariable_node_lon) * planet_matrix
-
-        # Create the transform
-        xform = Transform(Matrix3(matrix, xform.matrix.mask), Vector3.ZERO,
-                          self.wayframe, self.reference, self.origin)
-
-        # Cache the transform if necessary
-        if time.shape == () and self.given_cache_size > 0:
-
-            # Trim the cache, removing the values used least recently
-            if len(self.cache) >= self.cache_size:
-                all_keys = list(self.cache.values())
-                all_keys.sort()
-                for (_, old_key, _) in all_keys[:self.trim_size]:
-                    del self.cache[old_key]
-
-            # Insert into the cache
-            key = time.values
-            self.cache_counter += 1
-            count = np.array([self.cache_counter])
-            self.cache[key] = (count, key, xform)
-
-        return xform
-
-    #===========================================================================
-    def node_at_time(self, time, quick={}):
-        """Angle from the frame's X-axis to the ring plane ascending node on the
-        invariable plane.
-        """
-
-        # Calculate the pole for the current time
-        xform = self.planet_frame.transform_at_time(time, quick=quick)
-
-        # The bottom row of the matrix is the pole in J2000 coordinates
-        z_axis = xform.matrix.row_vector(2)
-        if self.retrograde:
-            z_axis = -z_axis
+from polymath import Scalar, Pair, Vector
 
-        # Locate this pole relative to the invariable plane
-        z_axis_wrt_invar = self.invariable_matrix * z_axis
+from oops.observation          import Observation
+from oops.observation.snapshot import Snapshot
+from oops.cadence              import Cadence
+from oops.cadence.metronome    import Metronome
+from oops.frame                import Frame
+from oops.path                 import Path
+
+from oops.observation.timedimage import TimedImage
+
+class Pushbroom(TimedImage):
+    """A subclass of Observation consisting of a 2-D image generated by sweeping
+    a 1-D strip of sensors across a field of view.
+
+    The FOV object is assumed to define the entire 2-D field of view, even if
+    the reality is that a 1-D array was swept in a (roughly) perpendicular
+    direction. The virtual array of data is assumed to have a t-dimension of 1,
+    while the number of time steps is equal to the number of samples in the u
+    or v direction, depending on the direction of sweep. In effect, then, the
+    virtual array samples a diagonal ramp through the (u,v,t) cube.
+    """
 
-        # The ascending node is 90 degrees ahead of the pole
-        (x, y, _) = z_axis_wrt_invar.to_scalars()
+    pass
 
-        node = (y.arctan2(x) + Scalar.HALFPI + self.invariable_node_lon)
-        return node % Scalar.TWOPI
+#     INVENTORY_IMPLEMENTED = True
+#
+#     # Relates these axes to Snapshot axes
+#     AXIS_REPLACEMENTS = {
+#         'ut':  'u',
+#         'vt':  'v',
+#     }
+#
+#     #===========================================================================
+#     def __init__(self, axes, cadence, fov, path, frame, **subfields):
+#         """Constructor for a Pushbroom observation.
+#
+#         Input:
+#             axes        a list or tuple of strings, with one value for each axis
+#                         in the associated data array. A value of 'u' or 'ut'
+#                         should appear at the location of the array's u-axis;
+#                         'vt' or 'v' should appear at the location of the array's
+#                         v-axis. The 't' suffix is used for the one of these axes
+#                         that is emulated by time-sampling the slit.
+#
+#             cadence     a 1-D Cadence object defining the start time and
+#                         duration of each consecutive position in the sweep of
+#                         the pushbroom. Alternatively, a tuple or dictionary
+#                         providing input arguments to the constructor
+#                         Metronome.for_array1d() (excluding the number of
+#                         lines, which is defined by the FOV)
+#                             (tstart, texp, interstep_delay)
+#
+#             fov         a FOV (field-of-view) object, which describes the field
+#                         of view including any spatial distortion. It maps
+#                         between spatial coordinates (u,v) and instrument
+#                         coordinates (x,y).
+#
+#             path        the path waypoint co-located with the instrument.
+#
+#             frame       the wayframe of a coordinate frame fixed to the optics
+#                         of the instrument. This frame should have its Z-axis
+#                         pointing outward near the center of the line of sight,
+#                         with the X-axis pointing rightward and the y-axis
+#                         pointing downward.
+#
+#             subfields   a dictionary containing all of the optional attributes.
+#                         Additional subfields may be included as needed.
+#         """
+#
+#         # Basic properties
+#         self.path = Path.as_waypoint(path)
+#         self.frame = Frame.as_wayframe(frame)
+#
+#         # FOV
+#         self.fov = fov
+#         self.uv_shape = tuple(self.fov.uv_shape.vals)
+#
+#         # Axes
+#         self.axes = list(axes)
+#         assert (('u' in self.axes and 'vt' in self.axes) or
+#                 ('v' in self.axes and 'ut' in self.axes))
+#
+#         if 'ut' in self.axes:
+#             self.u_axis = self.axes.index('ut')
+#             self.v_axis = self.axes.index('v')
+#             self.t_axis = self.u_axis
+#             self._cross_slit_uv_index = 0
+#             self._along_slit_uv_index = 1
+#         else:
+#             self.u_axis = self.axes.index('u')
+#             self.v_axis = self.axes.index('vt')
+#             self.t_axis = self.v_axis
+#             self._cross_slit_uv_index = 1
+#             self._along_slit_uv_index = 0
+#
+#         self.swap_uv = (self.u_axis > self.v_axis)
+#
+#         # Shape / Size
+#         self.shape = len(axes) * [0]
+#         self.shape[self.u_axis] = self.uv_shape[0]
+#         self.shape[self.v_axis] = self.uv_shape[1]
+#
+#         lines = self.uv_shape[self._cross_slit_uv_index]
+#         samples = self.uv_shape[self._along_slit_uv_index]
+#         self._cross_slit_len = lines
+#         self._along_slit_len = samples
+#
+#         slit_uv_shape = [1,1]
+#         slit_uv_shape[self._along_slit_uv_index] = samples
+#         self._slit_uv_shape = Pair(slit_uv_shape)
+#
+#         # Cadence
+#         if isinstance(cadence, (tuple,list)):
+#             self.cadence = Metronome.for_array1d(lines, *cadence)
+#         elif isinstance(cadence, dict):
+#             self.cadence = Metronome.for_array1d(lines, **cadence)
+#         elif isinstance(cadence, Cadence):
+#             self.cadence = cadence
+#             assert self.cadence.shape == (lines,)
+#         else:
+#             raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
+#
+#         # Timing
+#         self.time = self.cadence.time
+#         self.midtime = self.cadence.midtime
+#
+#         # Optional subfields
+#         self.subfields = {}
+#         for key in subfields.keys():
+#             self.insert_subfield(key, subfields[key])
+#
+#         # Snapshot class proxy
+#         snapshot_axes = [Pushbroom.AXIS_REPLACEMENTS.get(axis, axis)
+#                          for axis in axes]
+#         snapshot_tstart = self.cadence.time[0]
+#         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
+#
+#         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
+#                                  self.fov, self.path, self.frame, **subfields)
+#
+#     def __getstate__(self):
+#         return (self.axes, self.cadence, self.fov, self.path, self.frame,
+#                 self.subfields)
+#
+#     def __setstate__(self, state):
+#         self.__init__(*state[:-1], **state[-1])
+#
+#     #===========================================================================
+#     def uvt(self, indices, remask=False, derivs=True):
+#         """Coordinates (u,v) and time t for indices into the data array.
+#
+#         This method supports non-integer index values.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#             derivs      True to include derivatives in the returned values.
+#
+#         Return:         (uv, time)
+#             uv          a Pair defining the values of (u,v) within the FOV that
+#                         are associated with the array indices.
+#             time        a Scalar defining the time in seconds TDB associated
+#                         with the array indices.
+#         """
+#
+#         indices = Vector.as_vector(indices, recursive=derivs)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#
+#         # Mask based on (u,v) if necessary
+#         if remask:
+#             mask = ((uv.vals[...,0] < 0) | (uv.vals[...,0] > self.uv_shape[0]) |
+#                     (uv.vals[...,1] < 0) | (uv.vals[...,1] > self.uv_shape[1]))
+#             if np.any(mask):
+#                 uv = uv.remask_or(mask)
+#
+#         # Get the time, inheriting the mask of uv
+#         tstep = uv.to_scalar(self._cross_slit_uv_index)
+#         time = self.cadence.time_at_tstep(tstep, remask=False, derivs=derivs)
+#
+#         return (uv, time)
+#
+#     #===========================================================================
+#     def uvt_range(self, indices, remask=False):
+#         """Ranges of (u,v) spatial coordinates and time for integer array
+#         indices.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         (uv_min, uv_max, time_min, time_max)
+#             uv_min      a Pair defining the minimum values of FOV (u,v)
+#                         associated the pixel.
+#             uv_max      a Pair defining the maximum values of FOV (u,v)
+#                         associated the pixel.
+#             time_min    a Scalar defining the minimum time associated with the
+#                         array indices. It is given in seconds TDB.
+#             time_max    a Scalar defining the maximum time value.
+#         """
+#
+#         # Interpret the (u,v) range
+#         indices = Vector.as_vector(indices, recursive=False)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#         uv_min = uv.int(top=self.uv_shape, remask=remask)
+#
+#         # Intepret the time range, inheriting the mask of uv_min
+#         tstep = uv_min.to_scalar(self._cross_slit_uv_index)
+#         (time_min,
+#          time_max) = self.cadence.time_range_at_tstep(tstep, remask=False)
+#
+#         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
+#
+#     #===========================================================================
+#     def time_range_at_uv(self, uv_pair, remask=False):
+#         """The start and stop integration times for the spatial pixel (u,v).
+#
+#         Input:
+#             uv_pair     a Pair of spatial (u,v) data array coordinates,
+#                         truncated to integers if necessary.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         a tuple containing Scalars of the start time and stop
+#                         time of each (u,v) pair, as seconds TDB.
+#         """
+#
+#         return self.time_range_at_uv_1d(uv_pair, remask=remask)
+#         uv_pair = Pair.as_pair(uv_pair, recursive=False)
+#         tstep = uv_pair.to_scalar(self._cross_slit_uv_index)
+#         return self.cadence.time_range_at_tstep(tstep, remask=remask)
+#
+#     #===========================================================================
+#     def uv_range_at_time(self, time, remask=False):
+#         """The (u,v) range of spatial pixels active at the specified time.
+#
+#         Input:
+#             time        a Scalar of time values in seconds TDB.
+#             remask      True to mask values outside the time limits.
+#
+#         Return:         (uv_min, uv_max)
+#             uv_min      the lower (u,v) corner Pair of the area observed at the
+#                         specified time.
+#             uv_max      the upper (u,v) corner Pair of the area observed at the
+#                         specified time.
+#         """
+#
+#         return Observation.uv_range_at_time_1d(self, time, self._slit_uv_shape,
+#                                                axis=self._cross_slit_uv_index,
+#                                                remask=remask)
+#
+#     #===========================================================================
+#     def time_shift(self, dtime):
+#         """A copy of the observation object with a time-shift.
+#
+#         Input:
+#             dtime       the time offset to apply to the observation, in units of
+#                         seconds. A positive value shifts the observation later.
+#
+#         Return:         a (shallow) copy of the object with a new time.
+#         """
+#
+#         obs = Pushbroom(self.axes, self.cadence.time_shift(dtime),
+#                         self.fov, self.path, self.frame)
+#
+#         for key in self.subfields.keys():
+#             obs.insert_subfield(key, self.subfields[key])
+#
+#         return obs
+#
+#     #===========================================================================
+#     def inventory(self, *args, **kwargs):
+#         """Info about the bodies that appear unobscured inside the FOV. See
+#         Snapshot.inventory() for details.
+#
+#         WARNING: Not properly updated for class Pushbroom. Use at your own risk.
+#         This operates by returning every body that would have been inside the
+#         FOV of this observation if it were instead a Snapshot, evaluated at the
+#         given tfrac.
+#         """
+#
+#         return self.snapshot.inventory(*args, **kwargs)
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
 
-class Test_PoleFrame(unittest.TestCase):
+class Test_Pushbroom(unittest.TestCase):
 
     def runTest(self):
 
-        np.random.seed(1152)
-
-        # Imports are here to reduce conflicts
-        import os
-        import cspyce
-        from oops.event              import Event
-        from oops.frame.ringframe    import RingFrame
-        from oops.frame.spiceframe   import SpiceFrame
-        from oops.path               import Path
-        from oops.path.spicepath     import SpicePath
-        from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
-
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/naif0009.tls'))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/pck00010.tpc'))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/de421.bsp'))
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-        _ = SpicePath('MARS', 'SSB')
-        planet = SpiceFrame('IAU_MARS', 'J2000')
-        self.assertEqual(Frame.as_wayframe('IAU_MARS'), planet.wayframe)
-
-        # This invariable pole is aligned with the planet's pole, so this
-        # should behave just like a RingFrame
-        for aries in (False, True):
-            pole = planet.transform_at_time(0.).matrix.inverse() * Vector3.ZAXIS
-            poleframe = PoleFrame(planet, pole, cache_size=0, aries=aries)
-            ringframe = RingFrame(planet, epoch=0., aries=aries)
-            self.assertEqual(Frame.as_wayframe('IAU_MARS_POLE'), poleframe.wayframe)
-            vectors = Vector3(np.random.rand(3,4,2,3)).unit()
-
-            ring_vecs = ringframe.transform_at_time(0.).rotate(vectors)
-            pole_vecs = poleframe.transform_at_time(0.).rotate(vectors)
-            diffs = ring_vecs - pole_vecs
-            self.assertTrue(diffs.norm().max() < 1.e-15)
-
-            posvel = np.random.rand(3,4,2,6)
-            event = Event(0., (posvel[...,0:3], posvel[...,3:6]), 'SSB', 'J2000')
-            rotated = event.wrt_frame('IAU_MARS')
-            fixed   = event.wrt_frame(poleframe)
-
-            # Confirm Z axis is tied to planet's pole
-            diffs = Scalar(rotated.pos.vals[...,2]) - Scalar(fixed.pos.vals[...,2])
-            self.assertTrue(diffs.abs().max() < 1.e-15)
-
-            # Confirm X-axis is tied to the J2000 equator
-            xaxis = Event(0., Vector3.XAXIS, 'SSB', poleframe)
-            test = xaxis.wrt_frame('J2000').pos
-            self.assertTrue(abs(test.values[2]) < 1.e-15)
-
-            # Confirm it's the ascending node
-            xaxis = Event(0., (1,1.e-8,0), 'SSB', poleframe)
-            test = xaxis.wrt_frame('J2000').pos
-            self.assertTrue(test.values[2] > 0.)
-
-        # Test reference angles, Aries = True vs. False
-        vectors = Vector3(np.random.rand(100,3)).unit()
-        poleframe1 = PoleFrame(planet, pole, cache_size=0, aries=True)
-        poleframe2 = PoleFrame(planet, pole, cache_size=0, aries=False)
-        pole1_vecs = poleframe1.transform_at_time(0.).rotate(vectors)
-        pole2_vecs = poleframe2.transform_at_time(0.).rotate(vectors)
-        (x1,y1,z1) = pole1_vecs.to_scalars()
-        (x2,y2,z2) = pole2_vecs.to_scalars()
-
-        # Z axes are the same
-        self.assertTrue((z1 - z2).abs().max() < 1.e-15)
-
-        # Longitudes have a fixed, nonzero offset
-        dlon = (y1.arctan2(x1) - y2.arctan2(x2)) % (2.*np.pi)
-        self.assertTrue(dlon[0] != 0.)
-        self.assertTrue((dlon - dlon[0]).abs().max() < 1.e-15)
-
-        diff = dlon[0] - poleframe1.invariable_node_lon
-        diff = (diff - np.pi) % (2.*np.pi) - np.pi
-        self.assertTrue(diff.abs() < 1.e-15)
-
-        # Now try for Neptune
-        _ = SpicePath('NEPTUNE', 'SSB')
-        planet = SpiceFrame('IAU_NEPTUNE', 'J2000')
-
-        # This invariable pole is aligned with the planet's pole, so this
-        # should behave just like a RingFrame
-        for aries in (False, True):
-            pole = planet.transform_at_time(0.).matrix.inverse() * Vector3.ZAXIS
-            poleframe = PoleFrame(planet, pole, cache_size=0, aries=aries)
-            ringframe = RingFrame(planet, epoch=0., aries=aries)
-
-            vectors = Vector3(np.random.rand(3,4,2,3)).unit()
-
-            ring_vecs = ringframe.transform_at_time(0.).rotate(vectors)
-            pole_vecs = poleframe.transform_at_time(0.).rotate(vectors)
-            diffs = ring_vecs - pole_vecs
-            self.assertTrue(diffs.norm().max() < 3.e-15)
-
-            posvel = np.random.rand(3,4,2,6)
-            event = Event(0., (posvel[...,0:3], posvel[...,3:6]), 'SSB', 'J2000')
-            rotated = event.wrt_frame('IAU_NEPTUNE')
-            fixed   = event.wrt_frame(poleframe)
-
-            # Confirm Z axis is tied to planet's pole
-            diffs = Scalar(rotated.pos.vals[...,2]) - Scalar(fixed.pos.vals[...,2])
-            self.assertTrue(diffs.abs().max() < 1.e-15)
-
-            # Confirm X-axis is tied to the J2000 equator
-            xaxis = Event(0., Vector3.XAXIS, 'SSB', poleframe)
-            test = xaxis.wrt_frame('J2000').pos
-            self.assertTrue(abs(test.values[2]) < 1.e-15)
-
-            # Confirm it's the ascending node
-            xaxis = Event(0., (1,1.e-8,0), 'SSB', poleframe)
-            test = xaxis.wrt_frame('J2000').pos
-            self.assertTrue(test.values[2] > 0.)
-
-        # Test reference angles, Aries = True vs. False
-        vectors = Vector3(np.random.rand(100,3)).unit()
-        poleframe1 = PoleFrame(planet, pole, cache_size=0, aries=True)
-        poleframe2 = PoleFrame(planet, pole, cache_size=0, aries=False)
-        pole1_vecs = poleframe1.transform_at_time(0.).rotate(vectors)
-        pole2_vecs = poleframe2.transform_at_time(0.).rotate(vectors)
-        (x1,y1,z1) = pole1_vecs.to_scalars()
-        (x2,y2,z2) = pole2_vecs.to_scalars()
-
-        # Z axes are the same
-        self.assertTrue((z1 - z2).abs().max() < 1.e-15)
-
-        # Longitudes have a fixed, nonzero offset
-        dlon = (y1.arctan2(x1) - y2.arctan2(x2)) % (2.*np.pi)
-        self.assertTrue(dlon[0] != 0.)
-        self.assertTrue((dlon - dlon[0]).abs().max() < 1.e-15)
-
-        diff = dlon[0] - poleframe1.invariable_node_lon
-        diff = (diff - np.pi) % (2.*np.pi) - np.pi
-        self.assertTrue(diff.abs() < 1.e-15)
-
-        # Neptune at multiple times, with actual polar precession
-        times = Scalar(np.arange(1000) * 86400. * 365.)     # 1000 years
-        for aries in (False, True):
-            ra  = cspyce.bodvrd('NEPTUNE', 'POLE_RA')[0]  * np.pi/180
-            dec = cspyce.bodvrd('NEPTUNE', 'POLE_DEC')[0] * np.pi/180
-            pole = Vector3.from_ra_dec_length(ra,dec)
-            poleframe = PoleFrame(planet, pole, cache_size=0, aries=aries)
-
-            # Make sure Z-axis tracks Neptune pole
-            pole_vecs = poleframe.transform_at_time(times).unrotate(Vector3.ZAXIS)
-            test_vecs = planet.transform_at_time(times).unrotate(Vector3.ZAXIS)
-            diffs = pole_vecs - test_vecs
-            self.assertTrue(diffs.norm().max() < 1.e-15)
-
-            # Make sure Z-axis circles the pole at uniform distance
-            seps = pole_vecs.sep(pole)
-            sep_mean = seps.mean()
-            self.assertTrue((seps - sep_mean).abs().max() < 3.e-5)
-
-            # Make sure the X-axis stays close to the ecliptic
-            if not aries:
-                node_vecs = poleframe.transform_at_time(times).unrotate(Vector3.XAXIS)
-                min_node_z = np.min(node_vecs.values[:,2])
-                max_node_z = np.max(node_vecs.values[:,2])
-                self.assertTrue(min_node_z > -0.0062)
-                self.assertTrue(max_node_z <  0.0062)
-                self.assertTrue(abs(min_node_z + max_node_z) < 1.e-8)
-
-            # Make sure the X-axis stays in a generally fixed direction
-            diffs = node_vecs - node_vecs[0]
-            self.assertTrue(diffs.norm().max() < 0.02)
-
-        # Test cache
-        poleframe = PoleFrame(planet, pole, cache_size=3)
-        self.assertTrue(poleframe.cache_size == 4)
-        self.assertTrue(poleframe.trim_size == 1)
-        self.assertTrue(len(poleframe.cache) == 0)
-
-        pole_vecs = poleframe.transform_at_time(times).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 0)  # don't cache vectors
-        self.assertFalse(poleframe.cached_value_returned)
-
-        pole_vecs = poleframe.transform_at_time(100.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 1)
-        self.assertTrue(100. in poleframe.cache)
-        self.assertFalse(poleframe.cached_value_returned)
-
-        pole_vecs = poleframe.transform_at_time(100.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 1)
-        self.assertTrue(poleframe.cached_value_returned)
-
-        pole_vecs = poleframe.transform_at_time(200.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 2)
-
-        pole_vecs = poleframe.transform_at_time(300.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 3)
-
-        pole_vecs = poleframe.transform_at_time(400.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 4)
-
-        pole_vecs = poleframe.transform_at_time(500.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 4)
-        self.assertTrue(100. not in poleframe.cache)
-
-        pole_vecs = poleframe.transform_at_time(200.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 4)
-        self.assertTrue(poleframe.cached_value_returned)
-
-        pole_vecs = poleframe.transform_at_time(100.).unrotate(Vector3.ZAXIS)
-        self.assertTrue(len(poleframe.cache) == 4)
-        self.assertFalse(poleframe.cached_value_returned)
-        self.assertTrue(300. not in poleframe.cache)
+        from oops.cadence.metronome import Metronome
+        from oops.fov.flatfov import FlatFOV
 
-        Path.reset_registry()
-        Frame.reset_registry()
+        ########################################
+        # Overall shape (10,20)
+        # Time is second axis; time = v * 10.
+        ########################################
+
+        flatfov = FlatFOV((0.001,0.001), (10,20))
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
+        obs = Pushbroom(axes=('u','vt'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
+
+        indices_ = indices.copy()   # clipped at top
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        # uvt() with remask == False
+        (uv, time) = obs.uvt(indices)
+
+        self.assertFalse(np.any(uv.mask))
+        self.assertFalse(np.any(time.mask))
+        self.assertEqual(time, cadence.time_at_tstep(tstep))
+        self.assertEqual(uv, Pair.as_pair(indices))
+
+        # uvt() with remask == True
+        (uv, time) = obs.uvt(indices, remask=True)
+
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
+        self.assertEqual(time[:6], cadence.tstride * indices.to_scalar(1)[:6])
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+
+        # uvt_range() with remask == False
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        # uvt_range() with remask == False, new indices
+        non_ints = indices + (0.2,0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+
+        self.assertFalse(np.any(uv_min.mask))
+        self.assertFalse(np.any(uv_max.mask))
+        self.assertFalse(np.any(time_min.mask))
+        self.assertFalse(np.any(time_max.mask))
+
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        # uvt_range() with remask == True, new indices
+        non_ints = indices + (0.2,0.9)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints,
+                                                             remask=True)
+
+        self.assertTrue(np.all(uv_min.mask == np.array(2*[False] + 5*[True])))
+        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
+        self.assertTrue(np.all(time_min.mask == uv_min.mask))
+        self.assertTrue(np.all(time_max.mask == uv_min.mask))
+
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
+        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
+
+        # time_range_at_uv() with remask == False
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+        tstep = uv.to_scalar(1)
+
+        uv_ = uv.copy()
+        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
+        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
+
+        (time0, time1) = obs.time_range_at_uv(uv)
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, time0 + cadence.texp)
+
+        # time_range_at_uv() with remask == True
+        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
+        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], cadence.tstride * uv_.to_scalar(1)[:4])
+        self.assertEqual(time1[:4], time0[:4] + cadence.texp)
+
+        ########################################
+        # Alternative axis order ('ut','v')
+        # Overall shape (10,20)
+        # Time is first axis; time = v * 10.
+        ########################################
+
+        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
+        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices_ = indices.copy()
+        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
+        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
+
+        (uv, time) = obs.uvt(indices)
+
+        uv_ = uv.copy()
+        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
+        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
+
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, cadence.tstride * indices.to_scalar(0))
+
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
+
+        self.assertEqual(uv_min, Pair.as_pair(indices_))
+        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(time_min, cadence.tstride * indices_.to_scalar(0))
+        self.assertEqual(time_max, time_min + cadence.texp)
+
+        (time0, time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.tstride * uv_.to_scalar(0))
+        self.assertEqual(time1, time0 + cadence.texp)
+
+        ########################################################
+        # Alternative texp for discontinuous time index
+        # Overall shape (10,20)
+        # Time is first axis; time = [0-8, 10-18, ..., 90-98]
+        ########################################################
+
+        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
+        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
+                                         path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 98.)
+
+        self.assertEqual(obs.uvt((0,0))[1],  0.)
+        self.assertEqual(obs.uvt((5,0))[1], 50.)
+        self.assertEqual(obs.uvt((5,5))[1], 50.)
+
+        eps = 1.e-14
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((6      ,0))[1] - 60.) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 62.) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 64.) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 66.) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 68.) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 70.) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
+
+        self.assertTrue(abs(obs.uvt((6      ,0))[0] - (6.0,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,5))[0] - (7.0,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
+
+        # Test the upper edge
+        uv_list = []
+        uvt_list = []
+        for i,u in enumerate([10.-eps, 10., 10.+eps]):
+          for j,v in enumerate([20.-eps, 20., 20.+eps]):
+            uv_list.append((u,v))
+
+            uvt = obs.uvt((u,v), remask=True)
+            uvt_list.append(uvt)
+            if (i < 2) and (j < 2):
+                self.assertEqual(uvt[0], (u,v))
+            else:
+                self.assertEqual(uvt[0], Pair.MASKED)
+
+            if (i < 2) and (j < 2):
+                self.assertTrue((uvt[1] - (10. * u - 2.)).abs() < delta)
+            else:
+                self.assertEqual(uvt[1], Scalar.MASKED)
+
+        # Try all at once
+        uvt = obs.uvt(uv_list, remask=True)
+        self.assertEqual(uvt[0], [a[0] for a in uvt_list])
+        self.assertEqual(uvt[1], [a[1] for a in uvt_list])
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/ringframe.py` & `rms_oops-0.0.4/oops/frame/poleframe.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,139 +1,146 @@
 ################################################################################
-# oops/frame/ringframe.py: Subclass RingFrame of class Frame
+# oops/frame/poleframe.py: Subclass PoleFrame of class Frame
 ################################################################################
 
 import numpy as np
+
 from polymath       import Matrix3, Qube, Scalar, Vector3
 from oops.frame     import Frame
 from oops.transform import Transform
 
-class RingFrame(Frame):
+class PoleFrame(Frame):
     """A Frame subclass describing a non-rotating frame centered on the Z-axis
-    of another frame, but oriented with the X-axis fixed along the ascending
-    node of the equator within the reference frame.
+    of a body's pole vector.
+
+    This differs from RingFrame in that the pole may precess around a separate,
+    invariable pole for the system. Because of this behavior, the reference
+    longitude is defined as the ascending node of the invariable plane rather
+    than as the ascending node of the ring plane. This frame is recommended for
+    Neptune in particular.
     """
 
     FRAME_IDS = {}  # frame_id to use if a frame already exists upon un-pickling
 
     #===========================================================================
-    def __init__(self, frame, epoch=None, retrograde=False, aries=False,
-                       frame_id='+', cache_size=1000, unpickled=False):
-        """Constructor for a RingFrame Frame.
+    def __init__(self, frame, pole, retrograde=False, aries=False, frame_id='+',
+                       cache_size=1000, unpickled=False):
+        """Constructor for a PoleFrame.
 
         Input:
-            frame       a frame describing the central planet of the ring plane
-                        relative to J2000.
-
-            epoch       the time TDB at which the frame is to be evaluated. If
-                        this is specified, then the frame will be precisely
-                        inertial, based on the orientation of the pole at the
-                        specified epoch. If it is unspecified, then the frame
-                        could wobble or rotate slowly due to precession of the
-                        planet's pole.
+            frame       a (possibly) rotating frame, or its ID, describing the
+                        central planet relative to J2000. This is typically a
+                        body's rotating SpiceFrame.
+
+            pole        The pole of the invariable plane, about which planet's
+                        pole precesses. This enables the reference longitude to
+                        be defined properly. Defined in J2000 coordinates.
 
             retrograde  True to flip the sign of the Z-axis. Necessary for
                         retrograde systems like Uranus.
 
             aries       True to use the First Point of Aries as the longitude
-                        reference; False to use the ascending node of the ring
-                        plane. Note that the former might be preferred in a
-                        situation where the ring plane is uncertain, wobbles, or
-                        is nearly parallel to the celestial equator. In these
-                        situations, using Aries as a reference will reduce the
-                        uncertainties related to the pole orientation.
+                        reference; False to use the ascending node of the
+                        invariable plane. Note that the former might be
+                        preferred in a situation where the invariable pole is
+                        uncertain, because small changes in the invariable pole
+                        will have only a limited effect on the absolute
+                        reference longitude.
 
             frame_id    the ID under which the frame will be registered. None to
                         leave the frame unregistered. If the value is "+", then
                         the registered name is the planet frame's name with the
-                        suffix "_DESPUN" if epoch is None, or "_INERTIAL" if an
-                        epoch is specified.
+                        suffix "_POLE". Note that this default ID will not be
+                        unique if frames are defined for multiple Laplace Planes
+                        around the same planet.
 
             cache_size  number of transforms to cache. This can be useful
                         because it avoids unnecessary SPICE calls when the frame
                         is being used repeatedly at a finite set of times.
 
             unpickled   True if this frame has been read from a pickle file.
         """
 
-        self.planet_frame = Frame.as_frame(frame).wrt(Frame.J2000)
-        self.reference = Frame.J2000
-        self.epoch = None if epoch is None else Scalar.as_scalar(epoch)
-        self.retrograde = bool(retrograde)
-        self.shape = Qube.broadcasted_shape(self.planet_frame, self.epoch)
-        self.keys = set()
+        # Rotates from J2000 to the invariable frame
+        pole = Vector3.as_vector3(pole)
+        (ra, dec, _) = pole.to_ra_dec_length(recursive=False)
+        self.invariable_matrix = Matrix3.pole_rotation(ra,dec)
+            # Rotates J2000 coordinates into a frame where the Z-axis is the
+            # invariable pole and the X-axis is the ascending node of the
+            # invariable plane on J2000
+        self.invariable_pole = pole
+        self.invariable_node = Vector3.ZAXIS.ucross(pole)
 
         self.aries = bool(aries)
+        if self.aries:
+            # The ascending node of the invariable plane falls 90 degrees ahead
+            # pole's RA
+            self.invariable_node_lon = ra + np.pi/2.
+        else:
+            self.invariable_node_lon = 0.
 
-        # The frame might not be exactly inertial due to polar precession, but
-        # it is good enough
-        self.origin = None
+        self.planet_frame = Frame.as_frame(frame).wrt(Frame.J2000)
+        self.origin = self.planet_frame.origin
+        self.retrograde = bool(retrograde)
+        self.keys = set()
+        self.reference = Frame.J2000
+        self.shape = Qube.broadcasted_shape(self.invariable_pole,
+                                            self.planet_frame)
 
         # Define cache
         self.cache = {}
         self.trim_size = max(cache_size//10, 1)
         self.given_cache_size = cache_size
         self.cache_size = cache_size + self.trim_size
         self.cache_counter = 0
         self.cached_value_returned = False          # Just used for debugging
 
         # Fill in the frame ID
         if frame_id is None:
             self.frame_id = Frame.temporary_frame_id()
         elif frame_id == '+':
-            if self.epoch is None:
-                self.frame_id = self.planet_frame.frame_id + "_DESPUN"
-            else:
-                self.frame_id = self.planet_frame.frame_id + "_INERTIAL"
+            self.frame_id = self.planet_frame.frame_id + '_POLE'
+        elif frame_id.startswith('+'):
+            self.frame_id = self.planet_frame.frame_id + '_' + frame_id[1:]
         else:
             self.frame_id = frame_id
 
         # Register if necessary
         self.register(unpickled=unpickled)
 
-        # For a fixed epoch, derive the inertial tranform now
-        self.transform = None
-        if self.epoch is not None:
-            self.transform = self.transform_at_time(self.epoch)
-
         # Save in internal dict for name lookup upon serialization
         if (not unpickled and self.shape == ()
             and self.frame_id in Frame.WAYFRAME_REGISTRY):
                 key = (self.planet_frame.frame_id,
-                       None if self.epoch is None else self.epoch.vals,
-                       self.retrograde, self.aries)
-                RingFrame.FRAME_IDS[key] = self.frame_id
+                       tuple(self.invariable_pole.vals),
+                       retrograde, aries)
+                PoleFrame.FRAME_IDS[key] = self.frame_id
 
     # Unpickled frames will always have temporary IDs to avoid conflicts
     def __getstate__(self):
-        return (Frame.as_primary_frame(self.planet_frame), self.epoch,
-                self.retrograde, self.aries, self.given_cache_size, self.shape)
+        return (Frame.as_primary_frame(self.planet_frame),
+                self.invariable_pole, self.retrograde,
+                self.aries, self.given_cache_size, self.shape)
 
     def __setstate__(self, state):
         # If this frame matches a pre-existing frame, re-use its ID
-        (frame, epoch, retrograde, aries, cache_size, shape) = state
+        (frame, pole, retrograde, aries, cache_size, shape) = state
         if shape == ():
-            key = (frame.frame_id,
-                   None if epoch is None else epoch.vals,
-                   retrograde, aries)
-            frame_id = RingFrame.FRAME_IDS.get(key, None)
+            key = (frame.frame_id, tuple(pole.vals), retrograde, aries)
+            frame_id = PoleFrame.FRAME_IDS.get(key, None)
         else:
             frame_id = None
 
-        self.__init__(frame, epoch, retrograde, aries, frame_id=frame_id,
+        self.__init__(frame, pole, retrograde, aries, frame_id=frame_id,
                       cache_size=cache_size, unpickled=True)
 
     #===========================================================================
     def transform_at_time(self, time, quick={}):
         """The Transform into the this Frame at a Scalar of times."""
 
-        # For a fixed epoch, return the fixed transform
-        if self.transform is not None:
-            return self.transform
-
         time = Scalar.as_scalar(time)
 
         # Check cache first if time is a Scalar
         if time.shape == ():
             key = time.values
 
             if key in self.cache:
@@ -141,39 +148,49 @@
                 (count, key, xform) = self.cache[key]
                 self.cache_counter += 1
                 count[0] = self.cache_counter
                 return xform
 
         self.cached_value_returned = False
 
-        # Otherwise, calculate it for the current time
+        # Calculate the planet frame for the current time in J2000
         xform = self.planet_frame.transform_at_time(time, quick=quick)
 
         # The bottom row of the matrix is the Z-axis of the ring frame in J2000
         z_axis = xform.matrix.row_vector(2)
 
         # For a retrograde ring, reverse Z
         if self.retrograde:
             z_axis = -z_axis
 
-        x_axis = Vector3.ZAXIS.cross(z_axis)
-        matrix = Matrix3.twovec(z_axis, 2, x_axis, 0)
+        planet_matrix = Matrix3.twovec(z_axis, 2,
+                                       Vector3.ZAXIS.cross(z_axis), 0)
 
         # This is the RingFrame matrix. It rotates from J2000 to the frame where
         # the pole at epoch is along the Z-axis and the ascending node relative
         # to the J2000 equator is along the X-axis.
 
-        if self.aries:
-            (x,y,z) = x_axis.to_scalars()
-            node_lon = y.arctan2(x)
-            matrix = Matrix3.z_rotation(node_lon) * matrix
-
-        # Create transform
-        xform = Transform(matrix, Vector3.ZERO,
-                          self.wayframe, self.reference, None)
+        # Locate the J2000 ascending node of the RingFrame on the invariable
+        # plane.
+        planet_pole_j2000 = planet_matrix.inverse() * Vector3.ZAXIS
+        joint_node_j2000 = self.invariable_pole.cross(planet_pole_j2000)
+
+        joint_node_wrt_planet = planet_matrix * joint_node_j2000
+        joint_node_wrt_frame = self.invariable_matrix * joint_node_j2000
+
+        node_lon_wrt_planet = joint_node_wrt_planet.to_ra_dec_length()[0]
+        node_lon_wrt_frame = joint_node_wrt_frame.to_ra_dec_length()[0]
+
+        # Align the X-axis with the node of the invariable plane
+        matrix = Matrix3.z_rotation(node_lon_wrt_planet - node_lon_wrt_frame +
+                                    self.invariable_node_lon) * planet_matrix
+
+        # Create the transform
+        xform = Transform(Matrix3(matrix, xform.matrix.mask), Vector3.ZERO,
+                          self.wayframe, self.reference, self.origin)
 
         # Cache the transform if necessary
         if time.shape == () and self.given_cache_size > 0:
 
             # Trim the cache, removing the values used least recently
             if len(self.cache) >= self.cache_size:
                 all_keys = list(self.cache.values())
@@ -187,90 +204,29 @@
             count = np.array([self.cache_counter])
             self.cache[key] = (count, key, xform)
 
         return xform
 
     #===========================================================================
     def node_at_time(self, time, quick={}):
-        """Angle from the frame's X-axis to the ring plane ascending node on
-        the J2000 equator.
+        """Angle from the frame's X-axis to the ring plane ascending node on the
+        invariable plane.
         """
 
-        xform = self.transform_at_time(time, quick=quick)
-        z_axis_wrt_j2000 = xform.unrotate(Vector3.ZAXIS)
-        (x,y,_) = z_axis_wrt_j2000.to_scalars()
-
-        if (x,y) == (0.,0.):
-            return Scalar(0.)
-
-        return (y.arctan2(x) + np.pi/2.) % Scalar.TWOPI
+        # Calculate the pole for the current time
+        xform = self.planet_frame.transform_at_time(time, quick=quick)
 
-################################################################################
-# UNIT TESTS
-################################################################################
+        # The bottom row of the matrix is the pole in J2000 coordinates
+        z_axis = xform.matrix.row_vector(2)
+        if self.retrograde:
+            z_axis = -z_axis
 
-import unittest
+        # Locate this pole relative to the invariable plane
+        z_axis_wrt_invar = self.invariable_matrix * z_axis
 
-class Test_RingFrame(unittest.TestCase):
+        # The ascending node is 90 degrees ahead of the pole
+        (x, y, _) = z_axis_wrt_invar.to_scalars()
 
-    def runTest(self):
+        node = (y.arctan2(x) + Scalar.HALFPI + self.invariable_node_lon)
+        return node % Scalar.TWOPI
 
-        # Imports are here to reduce conflicts
-        import os
-        import cspyce
-        from oops.frame.spiceframe   import SpiceFrame
-        from oops.path.spicepath     import SpicePath
-        from oops.event              import Event
-        from oops.path               import Path
-        from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
-
-        np.random.seed(2492)
-
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, "SPICE/naif0009.tls"))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, "SPICE/pck00010.tpc"))
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, "SPICE/de421.bsp"))
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-        _ = SpicePath("MARS", "SSB")
-        planet = SpiceFrame("IAU_MARS", "J2000")
-        rings  = RingFrame(planet)
-        self.assertEqual(Frame.as_wayframe("IAU_MARS"), planet.wayframe)
-        self.assertEqual(Frame.as_wayframe("IAU_MARS_DESPUN"), rings.wayframe)
-
-        time = Scalar(np.random.rand(3,4,2) * 1.e8)
-        posvel = np.random.rand(3,4,2,6)
-        event = Event(time, (posvel[...,0:3], posvel[...,3:6]), "SSB", "J2000")
-        rotated = event.wrt_frame("IAU_MARS")
-        fixed   = event.wrt_frame("IAU_MARS_DESPUN")
-
-        # Confirm Z axis is tied to planet's pole
-        diff = Scalar(rotated.pos.mvals[...,2]) - Scalar(fixed.pos.mvals[...,2])
-        self.assertTrue(np.all(np.abs(diff.values < 1.e-14)))
-
-        # Confirm X-axis is always in the J2000 equator
-        xaxis = Event(time, Vector3.XAXIS, "SSB", rings.frame_id)
-        test = xaxis.wrt_frame("J2000")
-        self.assertTrue(np.all(np.abs(test.pos.mvals[...,2] < 1.e-14)))
-
-        # Confirm it's at the ascending node
-        xaxis = Event(time, (1,1.e-13,0), "SSB", rings.frame_id)
-        test = xaxis.wrt_frame("J2000")
-        self.assertTrue(np.all(test.pos.mvals[...,1] > 0.))
-
-        # Check that pole wanders when epoch is fixed
-        rings2 = RingFrame(planet, 0.)
-        self.assertEqual(Frame.as_wayframe("IAU_MARS_INERTIAL"), rings2.wayframe)
-        inertial = event.wrt_frame("IAU_MARS_INERTIAL")
-
-        diff = Scalar(rotated.pos.mvals[...,2]) - Scalar(inertial.pos.mvals[...,2])
-        self.assertTrue(np.all(np.abs(diff.values) < 1.e-4))
-        self.assertTrue(np.mean(np.abs(diff.values) > 1.e-8))
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/rotation.py` & `rms_oops-0.0.4/oops/frame/rotation.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
 # oops/frame/rotation.py: Subclass Rotation of class Frame
 ################################################################################
 
 import numpy as np
+
 from polymath       import Matrix3, Qube, Scalar, Vector3
 from oops.fittable  import Fittable
 from oops.frame     import Frame
 from oops.transform import Transform
 
 class Rotation(Frame, Fittable):
     """A Frame describing a fixed rotation about one axis of another frame."""
@@ -127,24 +128,7 @@
 
         The copy can be safely modified without affecting the original.
         """
 
         return Rotation(self.angle.copy(), self.axis, self.reference_id)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Rotation(unittest.TestCase):
-
-    def runTest(self):
-
-        # Note: Unit testing is performed in surface/orbitplane.py
-
-        pass
-
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/spicetype1frame.py` & `rms_oops-0.0.4/oops/frame/spicetype1frame.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,17 @@
 ################################################################################
 # oops/frame/spicetype1frame.py: Subclass SpiceType1Frame of Frame
 ################################################################################
 
 import numpy as np
+
 import cspyce
 
 from polymath            import Scalar, Vector3
 from oops.frame          import Frame
-from oops.path           import Path
-from oops.path.spicepath import SpicePath
 from oops.transform      import Transform
 import oops.spice_support as spice
 
 class SpiceType1Frame(Frame):
     """A Frame object defined within the SPICE toolkit as a Type 1 (discrete) C
     kernel.
     """
@@ -80,18 +79,18 @@
         self.reference = Frame.as_wayframe(reference_id)
 
         # Fill in the origin waypoint
         self.spice_origin_id   = cspyce.frinfo(self.spice_frame_id)[0]
         self.spice_origin_name = cspyce.bodc2n(self.spice_origin_id)
 
         try:
-            self.origin = Path.as_waypoint(self.spice_origin_id)
+            self.origin = Frame.PATH_CLASS.as_waypoint(self.spice_origin_id)
         except KeyError:
             # If the origin path was never defined, define it now
-            origin_path = SpicePath(self.spice_origin_id)
+            origin_path = Frame.SPICEPATH_CLASS(self.spice_origin_id)
             self.origin = origin_path.waypoint
 
         # No shape, no keys
         self.shape = ()
         self.keys = set()
 
         # Always register a SpiceType1Frame
@@ -191,21 +190,7 @@
         self.cached_shape = time.shape
         self.cached_time = true_times
         self.cached_transform = Transform(matrix, omega,
                                           self.frame_id, self.reference_id)
         return self.cached_transform
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_SpiceType1Frame(unittest.TestCase):
-
-    def runTest(self):
-        pass                # TBD
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/spinframe.py` & `rms_oops-0.0.4/oops/frame/ringframe.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,214 +1,208 @@
 ################################################################################
-# oops/frame/spinframe.py: Subclass SpinFrame of class Frame
+# oops/frame/ringframe.py: Subclass RingFrame of class Frame
 ################################################################################
 
 import numpy as np
+
 from polymath       import Matrix3, Qube, Scalar, Vector3
 from oops.frame     import Frame
-from oops.path      import Path
 from oops.transform import Transform
 
-class SpinFrame(Frame):
-    """A Frame subclass describing a frame in uniform rotation about one axis of
-    another frame.
-
-    It can be created without a frame_id, reference_id or origin_id; in this
-    case it is not registered and can therefore be used as a component of
-    another frame.
+class RingFrame(Frame):
+    """A Frame subclass describing a non-rotating frame centered on the Z-axis
+    of another frame, but oriented with the X-axis fixed along the ascending
+    node of the equator within the reference frame.
     """
 
     FRAME_IDS = {}  # frame_id to use if a frame already exists upon un-pickling
 
     #===========================================================================
-    def __init__(self, offset, rate, epoch, axis, reference, frame_id=None,
-                       unpickled=False):
-        """Constructor for a Spin Frame.
+    def __init__(self, frame, epoch=None, retrograde=False, aries=False,
+                       frame_id='+', cache_size=1000, unpickled=False):
+        """Constructor for a RingFrame Frame.
 
         Input:
-            offset      the angular offset of the frame at the epoch.
-            rate        the rotation rate of the frame in radians/second.
-            epoch       the time TDB at which the frame is defined.
-            axis        the rotation axis: 0 for x, 1 for y, 2 for z.
-            reference   the frame relative to which this frame is defined.
-            frame_id    the ID under which this frame is to be registered;
-                        None to use a temporary ID.
-            unpickled   True if this frame has been read from a pickle file.
+            frame       a frame describing the central planet of the ring plane
+                        relative to J2000.
+
+            epoch       the time TDB at which the frame is to be evaluated. If
+                        this is specified, then the frame will be precisely
+                        inertial, based on the orientation of the pole at the
+                        specified epoch. If it is unspecified, then the frame
+                        could wobble or rotate slowly due to precession of the
+                        planet's pole.
+
+            retrograde  True to flip the sign of the Z-axis. Necessary for
+                        retrograde systems like Uranus.
+
+            aries       True to use the First Point of Aries as the longitude
+                        reference; False to use the ascending node of the ring
+                        plane. Note that the former might be preferred in a
+                        situation where the ring plane is uncertain, wobbles, or
+                        is nearly parallel to the celestial equator. In these
+                        situations, using Aries as a reference will reduce the
+                        uncertainties related to the pole orientation.
+
+            frame_id    the ID under which the frame will be registered. None to
+                        leave the frame unregistered. If the value is "+", then
+                        the registered name is the planet frame's name with the
+                        suffix "_DESPUN" if epoch is None, or "_INERTIAL" if an
+                        epoch is specified.
+
+            cache_size  number of transforms to cache. This can be useful
+                        because it avoids unnecessary SPICE calls when the frame
+                        is being used repeatedly at a finite set of times.
 
-        Note that rate, offset and epoch can be Scalar values, in which case the
-        shape of the SpinFrame is defined by broadcasting the shapes of these
-        Scalars.
+            unpickled   True if this frame has been read from a pickle file.
         """
 
-        self.offset = Scalar.as_scalar(offset)
-        self.rate = Scalar.as_scalar(rate)
-        self.epoch = Scalar.as_scalar(epoch)
-
-        self.shape = Qube.broadcasted_shape(self.rate, self.offset, self.epoch)
-
-        self.axis2 = axis           # Most often, the Z-axis
-        self.axis0 = (self.axis2 + 1) % 3
-        self.axis1 = (self.axis2 + 2) % 3
-
-        omega_vals = np.zeros(list(self.shape) + [3])
-        omega_vals[..., self.axis2] = self.rate.vals
-        self.omega = Vector3(omega_vals, self.rate.mask)
-
-        # Required attributes
-        self.frame_id  = frame_id
-        self.reference = Frame.as_wayframe(reference)
-        self.origin    = self.reference.origin or Path.SSB
-        self.keys      = set()
+        self.planet_frame = Frame.as_frame(frame).wrt(Frame.J2000)
+        self.reference = Frame.J2000
+        self.epoch = None if epoch is None else Scalar.as_scalar(epoch)
+        self.retrograde = bool(retrograde)
+        self.shape = Qube.broadcasted_shape(self.planet_frame, self.epoch)
+        self.keys = set()
+
+        self.aries = bool(aries)
+
+        # The frame might not be exactly inertial due to polar precession, but
+        # it is good enough
+        self.origin = None
+
+        # Define cache
+        self.cache = {}
+        self.trim_size = max(cache_size//10, 1)
+        self.given_cache_size = cache_size
+        self.cache_size = cache_size + self.trim_size
+        self.cache_counter = 0
+        self.cached_value_returned = False          # Just used for debugging
+
+        # Fill in the frame ID
+        if frame_id is None:
+            self.frame_id = Frame.temporary_frame_id()
+        elif frame_id == '+':
+            if self.epoch is None:
+                self.frame_id = self.planet_frame.frame_id + "_DESPUN"
+            else:
+                self.frame_id = self.planet_frame.frame_id + "_INERTIAL"
+        else:
+            self.frame_id = frame_id
 
-        # Update wayframe and frame_id; register if not temporary
+        # Register if necessary
         self.register(unpickled=unpickled)
 
+        # For a fixed epoch, derive the inertial tranform now
+        self.transform = None
+        if self.epoch is not None:
+            self.transform = self.transform_at_time(self.epoch)
+
         # Save in internal dict for name lookup upon serialization
         if (not unpickled and self.shape == ()
             and self.frame_id in Frame.WAYFRAME_REGISTRY):
-                key = (self.offset.vals, self.rate.vals, self.epoch.vals,
-                       self.axis2, self.reference.frame_id)
-                SpinFrame.FRAME_IDS[key] = self.frame_id
+                key = (self.planet_frame.frame_id,
+                       None if self.epoch is None else self.epoch.vals,
+                       self.retrograde, self.aries)
+                RingFrame.FRAME_IDS[key] = self.frame_id
 
     # Unpickled frames will always have temporary IDs to avoid conflicts
     def __getstate__(self):
-        return (self.offset, self.rate, self.epoch, self.axis2,
-                Frame.as_primary_frame(self.reference), self.shape)
+        return (Frame.as_primary_frame(self.planet_frame), self.epoch,
+                self.retrograde, self.aries, self.given_cache_size, self.shape)
 
     def __setstate__(self, state):
         # If this frame matches a pre-existing frame, re-use its ID
-        (offset, rate, epoch, axis2, reference, shape) = state
+        (frame, epoch, retrograde, aries, cache_size, shape) = state
         if shape == ():
-            key = (offset.vals, rate.vals, epoch.vals, axis2,
-                   reference.frame_id)
-            frame_id = SpinFrame.FRAME_IDS.get(key, None)
+            key = (frame.frame_id,
+                   None if epoch is None else epoch.vals,
+                   retrograde, aries)
+            frame_id = RingFrame.FRAME_IDS.get(key, None)
         else:
             frame_id = None
 
-        self.__init__(offset, rate, epoch, axis2, reference, frame_id=frame_id,
-                      unpickled=True)
+        self.__init__(frame, epoch, retrograde, aries, frame_id=frame_id,
+                      cache_size=cache_size, unpickled=True)
 
     #===========================================================================
     def transform_at_time(self, time, quick={}):
-        """The Transform to this Frame at a specified Scalar of times.
+        """The Transform into the this Frame at a Scalar of times."""
 
-        QuickFrame options are ignored.
-        """
+        # For a fixed epoch, return the fixed transform
+        if self.transform is not None:
+            return self.transform
 
         time = Scalar.as_scalar(time)
-        angle = (time - self.epoch) * self.rate + self.offset
-
-        mat = np.zeros(list(angle.shape) + [3,3])
-        mat[..., self.axis2, self.axis2] = 1.
-        mat[..., self.axis0, self.axis0] = np.cos(angle.values)
-        mat[..., self.axis1, self.axis1] = mat[..., self.axis0, self.axis0]
-        mat[..., self.axis0, self.axis1] = np.sin(angle.values)
-        mat[..., self.axis1, self.axis0] = -mat[...,self.axis0,self.axis1]
-
-        matrix = Matrix3(mat, angle.mask)
-        return Transform(matrix, self.omega, self.wayframe, self.reference,
-                                 self.origin)
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_SpinFrame(unittest.TestCase):
-
-    def runTest(self):
-
-        np.random.seed(6521)
-
-        # Import here to avoid conflicts
-        from oops.event import Event
-
-        Frame.reset_registry()
-        Path.reset_registry()
 
-        spin1 = SpinFrame(0., 1., 0., 2, "J2000", "spin1")
-        _ = SpinFrame(0., 2., 0., 2, "J2000", "spin2")
-        _ = SpinFrame(0., 1., 0., 2, "spin2", "spin3")
-        _ = SpinFrame(1., 1., 1., 2, "J2000", "spin1a")
+        # Check cache first if time is a Scalar
+        if time.shape == ():
+            key = time.values
+
+            if key in self.cache:
+                self.cached_value_returned = True
+                (count, key, xform) = self.cache[key]
+                self.cache_counter += 1
+                count[0] = self.cache_counter
+                return xform
+
+        self.cached_value_returned = False
+
+        # Otherwise, calculate it for the current time
+        xform = self.planet_frame.transform_at_time(time, quick=quick)
+
+        # The bottom row of the matrix is the Z-axis of the ring frame in J2000
+        z_axis = xform.matrix.row_vector(2)
+
+        # For a retrograde ring, reverse Z
+        if self.retrograde:
+            z_axis = -z_axis
+
+        x_axis = Vector3.ZAXIS.cross(z_axis)
+        matrix = Matrix3.twovec(z_axis, 2, x_axis, 0)
+
+        # This is the RingFrame matrix. It rotates from J2000 to the frame where
+        # the pole at epoch is along the Z-axis and the ascending node relative
+        # to the J2000 equator is along the X-axis.
+
+        if self.aries:
+            (x,y,z) = x_axis.to_scalars()
+            node_lon = y.arctan2(x)
+            matrix = Matrix3.z_rotation(node_lon) * matrix
+
+        # Create transform
+        xform = Transform(matrix, Vector3.ZERO,
+                          self.wayframe, self.reference, None)
+
+        # Cache the transform if necessary
+        if time.shape == () and self.given_cache_size > 0:
+
+            # Trim the cache, removing the values used least recently
+            if len(self.cache) >= self.cache_size:
+                all_keys = list(self.cache.values())
+                all_keys.sort()
+                for (_, old_key, _) in all_keys[:self.trim_size]:
+                    del self.cache[old_key]
+
+            # Insert into the cache
+            key = time.values
+            self.cache_counter += 1
+            count = np.array([self.cache_counter])
+            self.cache[key] = (count, key, xform)
 
-        event = Event(Scalar.ZERO, Vector3.XAXIS, "SSB", "J2000")
-        self.assertEqual(event.pos, (1,0,0))
-        self.assertEqual(event.vel, (0,0,0))
+        return xform
 
-        event1 = event.wrt_frame("spin1")
-        self.assertEqual(event1.pos, (1, 0,0))
-        self.assertEqual(event1.vel, (0,-1,0))
-
-        self.assertEqual(event.pos, (1,0,0))
-        self.assertEqual(event.vel, (0,0,0))
-
-        event2 = event.wrt_frame("spin2")
-        self.assertEqual(event2.pos, (1, 0,0))
-        self.assertEqual(event2.vel, (0,-2,0))
-
-        event3 = event.wrt_frame("spin3")
-        self.assertEqual(event3.pos, (1, 0,0))
-        self.assertEqual(event3.vel, (0,-3,0))
-
-        event = Event(Scalar.ZERO, (Vector3.XAXIS,(1,2,3)), "SSB", "J2000")
-        self.assertEqual(event.pos, (1,0,0))
-        self.assertEqual(event.vel, (1,2,3))
-
-        event1 = event.wrt_frame("spin1")
-        self.assertEqual(event1.pos, (1,0,0))
-        self.assertEqual(event1.vel, (1,1,3))
-
-        eps = 1.e-10
-        event = Event(eps, Vector3.XAXIS, "SSB", "J2000")
-
-        event1 = event.wrt_frame("spin1")
-        self.assertEqual(event1.pos, (1, -eps,0))
-        self.assertEqual(event1.vel, (-eps,-1,0))
-
-        event2 = event.wrt_frame("spin2")
-        self.assertEqual(event2.pos, (1, -2*eps,0))
-        self.assertEqual(event2.vel, (-4*eps,-2,0))
-
-        event3 = event.wrt_frame("spin3")
-        self.assertEqual(event3.pos, (1, -3*eps,0))
-        self.assertEqual(event3.vel, (-9*eps,-3,0))
-
-        event1a = event.wrt_frame("spin1a")
-        self.assertTrue((event1a.pos - (1, -eps,0)).norm() < 1.e-15)
-        self.assertTrue((event1a.vel - (-eps,-1,0)).norm() < 1.e-15)
-
-        # Test time-derivatives of transforms
-        time = Scalar(np.random.randn(400))
-        pos  = Vector3(np.random.randn(400,3))
-        vel  = Vector3(np.random.randn(400,3))
-
-        dt = 1.e-6
-        tr0 = spin1.transform_at_time(time)
-        tr1 = spin1.transform_at_time(time + dt)
-
-        (pos0, vel0) = tr0.rotate_pos_vel(pos, vel)
-        (pos1, vel1) = tr1.rotate_pos_vel(pos + vel*dt, vel)
-        dpos_dt_test = (pos1 - pos0) / dt
-        self.assertTrue(abs(dpos_dt_test - vel0).max() < 1.e-5)
-
-        (pos0, vel0) = tr0.unrotate_pos_vel(pos, vel)
-        (pos1, vel1) = tr1.unrotate_pos_vel(pos + vel*dt, vel)
-        dpos_dt_test = (pos1 - pos0) / dt
-        self.assertTrue(abs(dpos_dt_test - vel0).max() < 1.e-5)
+    #===========================================================================
+    def node_at_time(self, time, quick={}):
+        """Angle from the frame's X-axis to the ring plane ascending node on
+        the J2000 equator.
+        """
 
-        pos0 = tr0.rotate(pos, derivs=True)
-        pos1 = tr1.rotate(pos, derivs=False)
-        dpos_dt_test = (pos1 - pos0) / dt
-        self.assertTrue(abs(dpos_dt_test - pos0.d_dt).max() < 1.e-5)
+        xform = self.transform_at_time(time, quick=quick)
+        z_axis_wrt_j2000 = xform.unrotate(Vector3.ZAXIS)
+        (x,y,_) = z_axis_wrt_j2000.to_scalars()
 
-        pos0 = tr0.unrotate(pos, derivs=True)
-        pos1 = tr1.unrotate(pos, derivs=False)
-        dpos_dt_test = (pos1 - pos0) / dt
-        self.assertTrue(abs(dpos_dt_test - pos0.d_dt).max() < 1.e-5)
+        if (x,y) == (0.,0.):
+            return Scalar(0.)
 
-        Frame.reset_registry()
+        return (y.arctan2(x) + np.pi/2.) % Scalar.TWOPI
 
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/synchronousframe.py` & `rms_oops-0.0.4/oops/path/multipath.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,128 +1,145 @@
 ################################################################################
-# oops/frame/synchronousframe.py: Subclass SynchronousFrame of class Frame
+# oops/path/multipath.py: Subclass MultiPath of class Path
 ################################################################################
 
 import numpy as np
-from polymath       import Matrix3, Qube, Scalar
-from oops.frame     import Frame
-from oops.path      import Path
-from oops.transform import Transform
-
-class SynchronousFrame(Frame):
-    """A Frame subclass describing a a body that always keeps the x-axis pointed
-    toward a central planet and the y-axis in the negative direction of motion.
-    """
 
-    FRAME_IDS = {}  # frame_id to use if a frame already exists upon un-pickling
+from polymath          import Qube, Scalar
+from oops.event        import Event
+from oops.frame.frame_ import Frame
+from oops.path.path_   import Path
+
+class MultiPath(Path):
+    """Gathers a set of paths into a single 1-D Path object."""
+
+    PATH_IDS = {}
 
     #===========================================================================
-    def __init__(self, body_path, planet_path, frame_id=None, unpickled=False):
-        """Constructor for a SynchronousFrame.
+    def __init__(self, paths, origin=None, frame=None, path_id='+',
+                       unpickled=False):
+        """Constructor for a MultiPath Path.
 
         Input:
-            body_path       the path or path ID followed by the body.
-            planet_path     the path or path ID followed by the central planet.
-            frame_id        the ID to use; None to leave the frame unregistered.
-            unpickled       True if this frame has been read from a pickle file.
+            paths       a tuple, list or 1-D ndarray of paths or path IDs.
+            origin      a path or path ID identifying the common origin of all
+                        paths. None to use the SSB.
+            frame       a frame or frame ID identifying the reference frame.
+                        None to use the default frame of the origin path.
+            path_id     the name or ID under which this path will be registered.
+                        A single '+' is changed to the ID of the first path with
+                        a '+' appended. None to leave the path unregistered.
+            unpickled   True if this path has been read from a pickle file.
         """
 
-        self.body_path = Path.as_path(body_path)
-        self.planet_path = Path.as_path(planet_path)
-        self.path = Path.wrt(self.planet_path, self.body_path)
-
-        if self.planet_path.shape:
-            raise ValueError('SynchronousFrame requires a shapeless body path')
-
-        self.frame_id  = frame_id
-        self.reference = Frame.as_wayframe(self.planet_path.frame)
-        self.origin    = self.planet_path.origin
-        self.shape     = Qube.broadcasted_shape(self.body_path,
-                                                self.planet_path)
-        self.keys      = set()
+        # Interpret the inputs
+        self.origin = Path.as_waypoint(origin) or Path.SSB
+        self.frame  = Frame.as_wayframe(frame) or self.origin.frame
+
+        self.paths = np.array(paths, dtype='object').ravel()
+        self.shape = self.paths.shape
+        self.keys = set()
+
+        for (index, path) in np.ndenumerate(self.paths):
+            self.paths[index] = Path.as_path(path).wrt(self.origin, self.frame)
+
+        # Fill in the path_id
+        self.path_id = path_id
 
-        # Update wayframe and frame_id; register if not temporary
+        if self.path_id == '+':
+            self.path_id = self.paths[0].path_id + '+others'
+
+        # Update waypoint and path_id; register only if necessary
         self.register(unpickled=unpickled)
 
         # Save in internal dict for name lookup upon serialization
-        if (not unpickled and self.shape == ()
-            and self.frame_id in Frame.WAYFRAME_REGISTRY):
-                key = (self.body_path.path_id, self.planet_path.path_id)
-                SynchronousFrame.FRAME_IDS[key] = self.frame_id
+        if not unpickled and self.path_id in Path.WAYPOINT_REGISTRY:
+            key = tuple([path.path_id for path in self.paths])
+            MultiPath.PATH_IDS[key] = self.path_id
 
-    # Unpickled frames will always have temporary IDs to avoid conflicts
+    # Unpickled paths will always have temporary IDs to avoid conflicts
     def __getstate__(self):
-        return (Path.as_primary_path(self.body_path),
-                Path.as_primary_path(self.planet_path), self.shape)
+        return (self.paths,
+                Path.as_primary_path(self.origin),
+                Frame.as_primary_frame(self.frame))
 
     def __setstate__(self, state):
-        # If this frame matches a pre-existing frame, re-use its ID
-        (body_path, planet_path, shape) = state
-        if shape == ():
-            key = (body_path.path_id, planet_path.path_id)
-            frame_id = SynchronousFrame.FRAME_IDS.get(key, None)
-        else:
-            frame_id = None
-
-        self.__init__(body_path, planet_path, frame_id=frame_id,
-                      unpickled=True)
+        # If this path matches a pre-existing path, re-use its ID
+        (paths, origin, frame) = state
+        key = tuple([path.path_id for path in paths])
+        path_id = MultiPath.PATH_IDS.get(key, None)
+        self.__init__(paths, origin, frame, path_id=path_id, unpickled=True)
 
     #===========================================================================
-    def transform_at_time(self, time, quick=False):
-        """The Transform into the this Frame at a Scalar of times."""
-
-        event = self.path.event_at_time(time, quick=quick)
-        matrix = Matrix3.twovec(event.pos, 0, event.vel, 1)
-        omega = event.pos.cross(event.vel) / event.pos.dot(event.pos)
+    def __getitem__(self, i):
+        slice = self.paths[i]
+        if np.shape(slice) == ():
+            return slice
+        return MultiPath(slice, self.origin, self.frame, path_id=None)
 
-        return Transform(matrix, omega, self.frame_id, self.reference,
-                                        self.body_path)
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_SynchronousFrame(unittest.TestCase):
+    #===========================================================================
+    def event_at_time(self, time, quick={}):
+        """An Event object corresponding to a specified Scalar time on this
+        path.
 
-    def setUp(self):
-        from oops.body import Body
+        The times are broadcasted across the shape of the MultiPath.
 
-        Body.reset_registry()
-        Body.define_solar_system('2000-01-01', '2020-01-01')
+        Input:
+            time        a time Scalar at which to evaluate the path.
+            quick       False to disable QuickPaths; a dictionary to override
+                        specific options.
 
-    def tearDown(self):
-        pass
+        Return:         an Event object containing the time, position and
+                        velocity of the paths.
+        """
 
-    def runTest(self):
-        from oops.path import Path
+        # Broadcast everything to the same shape
+        time = Qube.broadcast(Scalar.as_scalar(time), self.shape)[0]
 
-        # Path of Saturn relative to Enceladus
-        inward = Path.as_path('SATURN').wrt('ENCELADUS')
-        synchro = SynchronousFrame('ENCELADUS', 'SATURN', frame_id='SYNCHRO')
+        # Create the event object
+        pos = np.empty(time.shape + (3,))
+        vel = np.empty(time.shape + (3,))
+        mask = np.empty(time.shape, dtype='bool')
+        mask[...] = time.mask
+
+        for (index, path) in np.ndenumerate(self.paths):
+            event = path.event_at_time(time.values[...,index], quick=quick)
+            pos[...,index,:] = event.pos.values
+            vel[...,index,:] = event.vel.values
+            mask[...,index] |= (event.pos.mask | event.vel.mask)
+
+        if not np.any(mask):
+            mask = False
+        elif np.all(mask):
+            mask = True
 
-        time = Scalar(np.arange(1000.) * 86400.)
+        return Event(Scalar(time.values, mask), (pos,vel),
+                            self.origin, self.frame)
 
-        # Make sure direction to Saturn is along X-axis
-        pos = inward.event_at_time(time).wrt_frame(synchro).pos
-        self.assertTrue(np.all(pos.values[:,0] > 0.))
-        self.assertTrue(np.max(np.abs(pos.values[:,1])) < 1.e-10)
-        self.assertTrue(np.max(np.abs(pos.values[:,2])) < 1.e-10)
+    #===========================================================================
+    def quick_path(self, time, quick={}):
+        """Override of the default quick_path method to return a MultiPath of
+        quick_paths.
+
+        A QuickPath operates by sampling the given path and then setting up an
+        interpolation grid to evaluate in its place. It can substantially speed
+        up performance when the same path must be evaluated many times, e.g.,
+        for every pixel of an image.
 
-        # Make sure this frame and IAU_ENCELADUS are close
-        xform = synchro.wrt('IAU_ENCELADUS').transform_at_time(time)
+        Input:
+            time        a Scalar defining the set of times at which the frame is
+                        to be evaluated. Alternatively, a tuple (minimum time,
+                        maximum time, number of times)
+            quick       if None or False, no QuickPath is created and self is
+                        returned; if another dictionary, then the values
+                        provided override the values in the default dictionary
+                        QUICK.dictionary, and the merged dictionary is used.
+        """
 
-        self.assertTrue(np.max(np.abs(xform.omega.values[:,0])) < 5.e-8)
-        self.assertTrue(np.max(np.abs(xform.omega.values[:,1])) < 5.e-8)
-        self.assertTrue(np.max(np.abs(xform.omega.values[:,2])) < 1.e-6)
+        new_paths = []
+        for path in self.paths:
+            new_path = path.quick_path(time, quick=quick)
+            new_paths.append(new_path)
 
-        unit = np.array([[1,0,0],[0,1,0],[0,0,1]])
-        self.assertTrue(np.median(np.abs(xform.matrix.values - unit).ravel())
-                        < 5.e-4)
-        self.assertTrue(np.median(np.abs(xform.matrix.values - unit).ravel())
-                        < 0.1)
+        return MultiPath(new_paths, self.origin, self.frame)
 
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/trackerframe.py` & `rms_oops-0.0.4/oops/frame/trackerframe.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,17 +1,13 @@
 ################################################################################
 # oops/frame/trackerframe.py: Subclass TrackerFrame of class Frame
 ################################################################################
 
-import numpy as np
-from polymath import Qube, Scalar, Vector3, Matrix3
-
-from oops.event     import Event
+from polymath       import Qube, Scalar, Vector3, Matrix3
 from oops.frame     import Frame
-from oops.path      import Path
 from oops.transform import Transform
 
 class TrackerFrame(Frame):
     """A Frame subclass that ensures, via a small rotation, that a designated
     target path will remain in a fixed direction.
 
     The primary use of this frame is for observing moving targets with HST.
@@ -36,31 +32,32 @@
             observer    the observer's path or path ID.
             epoch       the epoch for which the given frame is defined.
             frame_id    the ID to use; None to use a temporary ID.
             unpickled   True if this frame has been read from a pickle file.
         """
 
         self.fixed_frame = Frame.as_frame(frame)
-        self.target_path = Path.as_path(target)
-        self.observer_path = Path.as_path(observer)
+        self.target_path = Frame.PATH_CLASS.as_path(target)
+        self.observer_path = Frame.PATH_CLASS.as_path(observer)
         self.epoch = Scalar.as_scalar(epoch)
         self.shape = Qube.broadcasted_shape(self.fixed_frame, self.target_path,
                                             self.observer_path, self.epoch)
 
         # Required attributes
         self.frame_id  = frame_id
         self.reference = self.fixed_frame.reference
         self.origin    = self.fixed_frame.origin
         self.keys      = set()
 
         # Update wayframe and frame_id; register if not temporary
         self.register(unpickled=unpickled)
 
         # Determine the apparent direction to the target path at epoch
-        obs_event = Event(epoch, Vector3.ZERO, self.observer_path, Frame.J2000)
+        obs_event = Frame.EVENT_CLASS(epoch, Vector3.ZERO, self.observer_path,
+                                      Frame.J2000)
         (path_event, obs_event) = self.target_path.photon_to_event(obs_event)
         self.trackpoint = obs_event.neg_arr_ap.unit()
 
         # Determine the transform at epoch
         fixed_xform = self.fixed_frame.transform_at_time(self.epoch)
         self.reference_xform = Transform(fixed_xform.matrix, Vector3.ZERO,
                                          self.wayframe, self.reference,
@@ -82,16 +79,16 @@
                 key = (self.fixed_frame.frame_id, self.target_path.path_id,
                        self.observer_path.path_id, self.epoch.vals)
                 TrackerFrame.FRAME_IDS[key] = self.frame_id
 
     # Unpickled frames will always have temporary IDs to avoid conflicts
     def __getstate__(self):
         return (Frame.as_primary_frame(self.fixed_frame),
-                Path.as_primary_path(self.target_path),
-                Path.as_primary_path(self.observer_path),
+                Frame.PATH_CLASS.as_primary_path(self.target_path),
+                Frame.PATH_CLASS.as_primary_path(self.observer_path),
                 self.epoch, self.shape)
 
     def __setstate__(self, state):
         # If this frame matches a pre-existing frame, re-use its ID
         (frame, target, observer, epoch, shape) = state
         if shape == ():
             key = (frame.frame_id, target.path_id, observer.path_id,
@@ -107,15 +104,16 @@
     def transform_at_time(self, time, quick=False):
         """The Transform into the this Frame at a Scalar of times."""
 
         if time == self.cached_time:
             return self.cached_xform
 
         # Determine the needed rotation
-        obs_event = Event(time, Vector3.ZERO, self.observer_path, Frame.J2000)
+        obs_event = Frame.EVENT_CLASS(time, Vector3.ZERO, self.observer_path,
+                                      Frame.J2000)
         (path_event, obs_event) = self.target_path.photon_to_event(obs_event)
         newpoint = obs_event.neg_arr_ap.unit()
 
         rotation = self.trackpoint.cross(newpoint)
         rotation = rotation.reshape(rotation.shape + (1,))
 
         # Rotate the three axis vectors accordingly
@@ -126,49 +124,7 @@
 
         # Cache the most recently used transform
         self.cached_time = time
         self.cached_xform = xform
         return xform
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_TrackerFrame(unittest.TestCase):
-
-    def setUp(self):
-        from oops.body import Body
-
-        Body.reset_registry()
-        Body.define_solar_system('1990-01-01', '2020-01-01')
-
-    def tearDown(self):
-        pass
-
-    def runTest(self):
-
-        _ = TrackerFrame("J2000", "MARS", "EARTH", 0., frame_id="TEST")
-        mars = Path.as_path("MARS")
-
-        obs_event = Event(0., Vector3.ZERO, "EARTH", "J2000")
-        (path_event, obs_event) = mars.photon_to_event(obs_event)
-        start_arr = obs_event.arr_ap.unit()
-
-        # Track Mars for 30 days
-        DAY = 86400
-        for t in range(0,30*DAY,DAY):
-            obs_event = Event(t, Vector3.ZERO, "EARTH", "TEST")
-            (path_event, obs_event) = mars.photon_to_event(obs_event)
-            self.assertTrue(abs(obs_event.arr_ap.unit() - start_arr) < 1.e-6)
-
-        # Try the test all at once
-        t = np.arange(0,30*DAY,DAY/40)
-        obs_event = Event(t, Vector3.ZERO, "EARTH", "TEST")
-        (path_event, obs_event) = mars.photon_to_event(obs_event)
-        self.assertTrue(abs(obs_event.arr_ap.unit() - start_arr).max() < 1.e-6)
-
-#########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/twovectorframe.py` & `rms_oops-0.0.4/oops/frame/twovectorframe.py`

 * *Files 6% similar despite different names*

```diff
@@ -123,22 +123,7 @@
 
     #===========================================================================
     def node_at_time(self, time, quick={}):
 
         return self.node
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_TwoVectorFrame(unittest.TestCase):
-
-    def runTest(self):
-
-        pass    # TBD
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/frame/unittester.py` & `rms_oops-0.0.4/oops/frame/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,26 +1,23 @@
 ################################################################################
-# oops/frame/unittester.py
+# oops/frame_/__init__.py
 ################################################################################
 
-import unittest
+from oops.frame.frame_           import (Frame, Wayframe, AliasFrame,
+                                         LinkedFrame, RelativeFrame,
+                                         ReversedFrame, QuickFrame)
+from oops.frame.cmatrix          import Cmatrix
+from oops.frame.inclinedframe    import InclinedFrame
+from oops.frame.laplaceframe     import LaplaceFrame
+from oops.frame.navigation       import Navigation
+from oops.frame.poleframe        import PoleFrame
+from oops.frame.postargframe     import PosTargFrame
+from oops.frame.ringframe        import RingFrame
+from oops.frame.rotation         import Rotation
+from oops.frame.spiceframe       import SpiceFrame
+from oops.frame.spicetype1frame  import SpiceType1Frame
+from oops.frame.spinframe        import SpinFrame
+from oops.frame.synchronousframe import SynchronousFrame
+from oops.frame.trackerframe     import TrackerFrame
+from oops.frame.twovectorframe   import TwoVectorFrame
 
-from oops.frame                  import Test_Frame
-from oops.frame.cmatrix          import Test_Cmatrix
-from oops.frame.inclinedframe    import Test_InclinedFrame
-from oops.frame.laplaceframe     import Test_LaplaceFrame
-from oops.frame.navigation       import Test_Navigation
-from oops.frame.poleframe        import Test_PoleFrame
-from oops.frame.postargframe     import Test_PosTargFrame
-from oops.frame.ringframe        import Test_RingFrame
-from oops.frame.rotation         import Test_Rotation
-from oops.frame.spiceframe       import Test_SpiceFrame
-from oops.frame.spicetype1frame  import Test_SpiceType1Frame
-from oops.frame.spinframe        import Test_SpinFrame
-from oops.frame.synchronousframe import Test_SynchronousFrame
-from oops.frame.trackerframe     import Test_TrackerFrame
-from oops.frame.twovectorframe   import Test_TwoVectorFrame
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/gravity/__init__.py` & `rms_oops-0.0.4/oops/gravity/gravity_.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,17 @@
 ################################################################################
-# oops/gravity/__init__.py: Abstract Gravity class
+# oops/gravity/gravity_.py: Abstract Gravity class
 ################################################################################
 
 class Gravity(object):
     """An abstract class describing the gravity field of a body."""
 
+    # To avoid circular imports...
+    BODY_CLASS = None               # filled in by oops/__init__.py
+
     GRAVITY_REGISTRY = {}           # global dictionary of gravity objects
                                     # Defined in OblateGravity
 
     def potential(self, a, e=0., sin_i=0.):
         """The potential energy at radius a, in the equatorial plane."""
         pass
```

### Comparing `rms_oops-0.0.3/oops/gravity/oblategravity.py` & `rms_oops-0.0.4/oops/gravity/oblategravity.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 ################################################################################
 # oops/gravity/oblategravity.py: OblateGravity subclass of class Gravity
 ################################################################################
 
 import numpy as np
 import warnings
+
 from oops.config    import LOGGING
 from oops.constants import TWOPI
 from oops.gravity   import Gravity
 
 class OblateGravity(Gravity):
     """A class describing the gravity field of an oblate planet using an
     expansion in gravity moments J2, J4, etc.
@@ -1079,97 +1080,8 @@
 Gravity.GRAVITY_REGISTRY["PLUTO BARYCENTER"  ] = PLUTO_CHARON
 
 # Define these as attributes of the Gravity superclass
 for name, value in Gravity.GRAVITY_REGISTRY.items():
     name = name.replace('+', '_').replace(' ', '_')
     setattr(Gravity, name, value)
 
-########################################
-# UNIT TESTS
-########################################
-
-import unittest
-
-ERROR_TOLERANCE = 1.e-15
-
-class Test_Gravity(unittest.TestCase):
-
-    def runTest(self):
-
-        np.random.seed(6950)
-
-        # Testing scalars in a loop...
-        tests = 100
-        planets = [JUPITER, SATURN, URANUS, NEPTUNE]
-        factors = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]
-
-        for test in range(tests):
-          for obj in planets:
-            for e in (0., 0.1):
-              for i in (0., 0.1):
-                a = obj.rp * 10. ** (np.random.rand() * 2.)
-                for f in factors:
-                    b = obj.solve_a(obj.combo(a,f,e,i), f, e, i)
-                    c = abs((b - a) / a)
-                    self.assertTrue(c < ERROR_TOLERANCE)
-
-        # PLUTO_CHARON with factors (1,0,0) and (0,0,1)
-        for test in range(tests):
-          for obj in [PLUTO_CHARON]:
-            for e in (0., 0.1):
-              for i in (0., 0.1):
-                a = obj.rp * 10. ** (np.random.rand() * 2.)
-                for f in [(1,0,0),(0,0,1)]:
-                    b = obj.solve_a(obj.combo(a,f,e,i), f, e, i)
-                    c = abs((b - a) / a)
-                    self.assertTrue(c < ERROR_TOLERANCE)
-
-        # PLUTO_CHARON with factors (0,1,0) can have duplicated values...
-        for test in range(tests):
-          for obj in [PLUTO_CHARON]:
-            a = obj.rp * 10. ** (np.random.rand() * 2.)
-            if obj.kappa2(a) < 0.:
-                continue        # this would raise RuntimeError
-
-            for f in [(0,1,0)]:
-                combo1 = obj.combo(a,f)
-                b = obj.solve_a(combo1, f)
-                combo2 = obj.combo(b,f)
-                c = abs((combo2 - combo1) / combo1)
-                self.assertTrue(c < ERROR_TOLERANCE)
-
-        # Testing a 100x100 array
-        for obj in planets:
-          a = obj.rp * 10. ** (np.random.rand(100,100) * 2.)
-          for e in (0., 0.1):
-            for i in (0., 0.1):
-              for f in factors:
-                b = obj.solve_a(obj.combo(a,f,e,i), f, e, i)
-                c = abs((b - a) / a)
-                self.assertTrue(np.all(c < ERROR_TOLERANCE))
-
-        # Testing with first-order cancellation
-        factors = [(1, -1, 0), (1, 0, -1), (0, 1, -1)]
-        planets = [JUPITER, SATURN, URANUS, NEPTUNE]
-
-        for obj in planets:
-            a = obj.rp * 10. ** (np.random.rand(100,100) * 2.)
-            for f in factors:
-                b = obj.solve_a(obj.combo(a, f), f)
-                c = abs((b - a) / a)
-                self.assertTrue(np.all(c < ERROR_TOLERANCE))
-
-        # Testing with second-order cancellation
-        factors = [(2, -1, -1)]
-        planets = [JUPITER, SATURN, URANUS, NEPTUNE]
-
-        for obj in planets:
-            a = obj.rp * 10. ** (np.random.rand(100,100) * 2.)
-            for f in factors:
-                b = obj.solve_a(obj.combo(a, f), f)
-                c = abs((b - a) / a)
-                self.assertTrue(np.all(c < ERROR_TOLERANCE))
-
-if __name__ == '__main__':
-    unittest.main()
-
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/__init__.py` & `rms_oops-0.0.4/tests/hosts/cassini/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/iss.py` & `rms_oops-0.0.4/oops/hosts/cassini/iss.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/iss_test_suite.py` & `rms_oops-0.0.4/ideas/deprecated/iss_test_suite.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/standard_obs.py` & `rms_oops-0.0.4/tests/hosts/cassini/standard_obs.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/uvis.py` & `rms_oops-0.0.4/tests/hosts/cassini/uvis.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/uvis_test_suite.py` & `rms_oops-0.0.4/ideas/deprecated/uvis_test_suite.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/vims.py` & `rms_oops-0.0.4/tests/hosts/cassini/vims.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/cassini/vims_test_suite.py` & `rms_oops-0.0.4/ideas/deprecated/vims_test_suite.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/galileo/__init__.py` & `rms_oops-0.0.4/oops/hosts/galileo/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/galileo/ssi/__init__.py` & `rms_oops-0.0.4/tests/hosts/galileo/ssi/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/galileo/ssi/standard_obs.py` & `rms_oops-0.0.4/tests/hosts/galileo/ssi/standard_obs.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/__init__.py` & `rms_oops-0.0.4/oops/hosts/hst/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/acs/__init__.py` & `rms_oops-0.0.4/oops/hosts/hst/acs/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/acs/hrc.py` & `rms_oops-0.0.4/oops/hosts/hst/acs/hrc.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/acs/sbc.py` & `rms_oops-0.0.4/oops/hosts/hst/acs/sbc.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/acs/wfc.py` & `rms_oops-0.0.4/oops/hosts/hst/acs/wfc.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/nicmos/__init__.py` & `rms_oops-0.0.4/oops/hosts/hst/nicmos/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/nicmos/nic1.py` & `rms_oops-0.0.4/oops/hosts/hst/nicmos/nic1.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/nicmos/nic2.py` & `rms_oops-0.0.4/oops/hosts/hst/nicmos/nic2.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/nicmos/nic3.py` & `rms_oops-0.0.4/oops/hosts/hst/nicmos/nic3.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3/__init__.py` & `rms_oops-0.0.4/oops/hosts/hst/wfc3/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3/ir.py` & `rms_oops-0.0.4/oops/hosts/hst/wfc3/ir.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3/uvis.py` & `rms_oops-0.0.4/oops/hosts/hst/wfc3/uvis.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3/wfc3_pointing_test.py` & `rms_oops-0.0.4/ideas/deprecated/wfc3_pointing_test copy.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3/wfc3_test_suite.py` & `rms_oops-0.0.4/ideas/deprecated/wfc3_test_suite copy.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3_pointing_test.py` & `rms_oops-0.0.4/ideas/deprecated/wfc3_pointing_test.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfc3_test_suite.py` & `rms_oops-0.0.4/ideas/deprecated/wfc3_test_suite.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/hst/wfpc2.py` & `rms_oops-0.0.4/oops/hosts/hst/wfpc2.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/__init__.py` & `rms_oops-0.0.4/oops/hosts/juno/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/jiram/__init__.py` & `rms_oops-0.0.4/oops/hosts/juno/jiram/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/jiram/img.py` & `rms_oops-0.0.4/oops/hosts/juno/jiram/img.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/jiram/spe.py` & `rms_oops-0.0.4/oops/hosts/juno/jiram/spe.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/junocam/__init__.py` & `rms_oops-0.0.4/oops/hosts/juno/junocam/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/junocam/standard_obs.py` & `rms_oops-0.0.4/tests/hosts/juno/junocam/standard_obs.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/juno/unittester.py` & `rms_oops-0.0.4/oops/hosts/juno/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/jwst/__init__.py` & `rms_oops-0.0.4/oops/hosts/jwst/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/jwst/nircam/__init__.py` & `rms_oops-0.0.4/oops/hosts/jwst/nircam/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/jwst/nircam/uncal.py` & `rms_oops-0.0.4/oops/hosts/jwst/nircam/uncal.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/keck/__init__.py` & `rms_oops-0.0.4/oops/hosts/keck/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/keck/nirc2/__init__.py` & `rms_oops-0.0.4/oops/hosts/keck/nirc2/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/keck/nirc2.py` & `rms_oops-0.0.4/oops/hosts/keck/nirc2.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/newhorizons/__init__.py` & `rms_oops-0.0.4/oops/hosts/newhorizons/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/newhorizons/lorri.py` & `rms_oops-0.0.4/oops/hosts/newhorizons/lorri.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/pds3.py` & `rms_oops-0.0.4/oops/hosts/pds3.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/unittester.py` & `rms_oops-0.0.4/oops/hosts/unittester.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/hosts/voyager/iss.py` & `rms_oops-0.0.4/oops/hosts/voyager/iss.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/lightsource.py` & `rms_oops-0.0.4/oops/lightsource.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 ################################################################################
 # oops/lightsource.py: Classes LightSource and DiskSource
 ################################################################################
 
 import numpy as np
-from polymath import Scalar, Pair, Vector, Vector3, Matrix3
 
+from polymath       import Scalar, Pair, Vector, Vector3, Matrix3
 from oops.body      import Body
 from oops.path      import Path
 from oops.constants import C, RPD, RPS
 from oops.event     import Event
 
 class LightSource(object):
     """Defines a source of illumination, such as the Sun, a star, or a radio
@@ -316,21 +316,7 @@
         else:
             new_event = event.wod.copy()
 
         new_event.neg_arr_j2000 = self.source
         return arrival
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_LightSource(unittest.TestCase):
-
-    #### TBD
-    pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/meshgrid.py` & `rms_oops-0.0.4/oops/meshgrid.py`

 * *Files 2% similar despite different names*

```diff
@@ -436,25 +436,7 @@
         return uv
 
     #===========================================================================
     def center_duv_dlos(self, time=None):
         return self.center_uv_w_derivs(time).d_dlos
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-# Tested by other modules, but here's a placeholder if we want to add more tests
-#
-# import unittest
-#
-# class Test_Meshgrid(unittest.TestCase):
-#
-#     def runTest(self):
-#
-#         # TBD
-#         pass
-#
-# ########################################
-# if __name__ == '__main__':
-#     unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/NOTES-ABOUT-OBSERVATION-CLASSES.txt` & `rms_oops-0.0.4/ideas/deprecated/NOTES-ABOUT-OBSERVATION-CLASSES.txt`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/oops/observation/insitu.py` & `rms_oops-0.0.4/oops/observation/insitu.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 ################################################################################
 # oops/observation/insitu.py: Subclass InSitu of class Observation
 ################################################################################
 
 import numpy as np
+
 from polymath             import Scalar
 from oops.cadence         import Cadence
 from oops.cadence.instant import Instant
 from oops.fov.nullfov     import NullFOV
 from oops.frame           import Frame
 from oops.observation     import Observation
 from oops.path            import Path
@@ -82,24 +83,7 @@
     def __getstate__(self):
         return (self.cadence, self.path, self.subfields)
 
     def __setstate__(self, state):
         self.__init__(*state[:-1], **state[-1])
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_InSitu(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/pixel.py` & `rms_oops-0.0.4/ideas/deprecated/pushframe.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,489 +1,472 @@
 ################################################################################
-# oops/observation/pixel.py: Subclass Pixel of class Observation
+# oops/observation/pushframe.py: Subclass Pushframe of class Observation
 ################################################################################
 
 import numpy as np
-from polymath import Scalar, Pair, Vector3
+from polymath import Pair, Vector, Qube
 
-from oops.observation import Observation
-from oops.cadence     import Cadence
-from oops.event       import Event
-from oops.frame       import Frame
-from oops.path        import Path
-
-class Pixel(Observation):
-    """A subclass of Observation consisting of one or more measurements obtained
-    from a single rectangular pixel.
+from oops.observation           import Observation
+from oops.observation.snapshot  import Snapshot
+from oops.cadence.tdicadence    import TDICadence
+from oops.fov.tdifov            import TDIFOV
+from oops.frame                 import Frame
+from oops.path                  import Path
 
-    Generalization to other FOV shapes is TODO.
-    """
+from oops.observation.timedimage import TimedImage
 
-    #===========================================================================
-    def __init__(self, axes, cadence, fov, path, frame, **subfields):
-        """Constructor for a Pixel observation.
-
-        Input:
-            axes        a list or tuple of strings, with one value for each axis
-                        in the associated data array. A value of 't' should
-                        appear at the location of the array's time-axis.
-
-            cadence     a 1-D Cadence object defining the start time and
-                        duration of each consecutive measurement. Note that it
-                        also defines the number of measurements.
-=
-            fov         a FOV (field-of-view) object, which describes the field
-                        of view including any spatial distortion. It maps
-                        between spatial coordinates (u,v) and instrument
-                        coordinates (x,y). For a Pixel object, both axes of the
-                        FOV must have length 1.
-
-            path        the path waypoint co-located with the instrument.
-
-            frame       the wayframe of a coordinate frame fixed to the optics
-                        of the instrument. This frame should have its Z-axis
-                        pointing outward near the center of the line of sight,
-                        with the X-axis pointing rightward and the y-axis
-                        pointing downward.
-
-            subfields   a dictionary containing all of the optional attributes.
-                        Additional subfields may be included as needed.
-        """
-
-        # Basic properties
-        self.path = Path.as_waypoint(path)
-        self.frame = Frame.as_wayframe(frame)
-
-        # FOV
-        self.fov = fov
-        if self.fov.uv_shape != (1,1):
-          raise ValueError('Pixel observation FOV must have shape (1,1)')
-
-        self.uv_shape = (1,1)
-
-        # Axes
-        self.axes = list(axes)
-        self.u_axis = -1
-        self.v_axis = -1
-        self.swap_uv = False
-        if 't' in self.axes:
-            self.t_axis = self.axes.index('t')
-        else:
-            self.t_axis = -1
-
-        # Cadence
-        self.cadence = cadence
-        if len(self.cadence.shape) != 1:
-            raise ValueError('Pixel observation requires a 1-D cadence')
-
-        samples = self.cadence.shape[0]
-
-        # Shape / Size
-        shape_list = len(axes) * [0]
-        if self.t_axis >= 0:
-            shape_list[self.t_axis] = samples
-        self.shape = tuple(shape_list)
-
-        # Timing
-        self.time = self.cadence.time
-        self.midtime = self.cadence.midtime
-        self._scalar_time = (Scalar(self.time[0]), Scalar(self.time[1]))
-        self._scalar_midtime = Scalar(self.cadence.midtime)
-
-        # Optional subfields
-        self.subfields = {}
-        for key in subfields.keys():
-            self.insert_subfield(key, subfields[key])
-
-    def __getstate__(self):
-        return (self.axes, self.cadence, self.fov, self.path, self.frame,
-                self.subfields)
-
-    def __setstate__(self, state):
-        self.__init__(*state[:-1], **state[-1])
-
-    #===========================================================================
-    def uvt(self, indices, remask=False, derivs=True):
-        """Coordinates (u,v) and time t for indices into the data array.
-
-        This method supports non-integer index values.
-
-        Input:
-            indices     a Scalar or Vector of array indices.
-            remask      True to mask values outside the field of view.
-            derivs      True to include derivatives in the returned values.
-
-        Return:         (uv, time)
-            uv          a Pair defining the values of (u,v) within the FOV that
-                        are associated with the array indices.
-            time        a Scalar defining the time in seconds TDB associated
-                        with the array indices.
-        """
-
-        # Works for a 1-D index or a multi-D index
-        tstep = Observation.scalar_from_indices(indices, self.t_axis,
-                                                derivs=derivs)
-
-        if tstep is None:       # if t_axis < 0
-            uv = Pair.filled(indices.shape, 0.5)
-            return (uv, self._scalar_midtime)
-
-        time = self.cadence.time_at_tstep(tstep, remask=remask)
-        uv = Pair.filled(time.shape, 0.5, mask=time.mask)
-        return (uv, time)
-
-    #===========================================================================
-    def uvt_range(self, indices, remask=False):
-        """Ranges of (u,v) spatial coordinates and time for integer array
-        indices.
-
-        Input:
-            indices     a Vector of array indices.
-            remask      True to mask values outside the field of view.
-
-        Return:         (uv_min, uv_max, time_min, time_max)
-            uv_min      a Pair defining the minimum values of (u,v) associated
-                        the pixel.
-            uv_max      a Pair defining the maximum values of (u,v).
-            time_min    a Scalar defining the minimum time associated with the
-                        pixel. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
-        """
-
-        if self.t_axis < 0:
-            return (Pair.INT00, self.fov.uv_shape) + self._scalar_time
-
-        # Works for a 1-D index or a multi-D index
-        tstep = Observation.scalar_from_indices(indices, self.t_axis)
-        (time_min,
-         time_max) = self.cadence.time_range_at_tstep(tstep, remask=remask)
-
-        # uv pair
-        uv_min = Pair.zeros(indices.shape, dtype='int', mask=time_min.mask)
-
-        return (uv_min, uv_min + self.fov.uv_shape, time_min, time_max)
-
-    #===========================================================================
-    def time_range_at_uv(self, uv_pair, remask=False):
-        """The start and stop times of the specified spatial pixel (u,v).
-
-        The Pixel observation subclass has no spatial axes, so the inputs here
-        are generally ignored, although they are expected to fall between 0 and
-        1 inclusive.
-
-        Input:
-            uv_pair     a Pair of spatial (u,v) data array coordinates,
-                        truncated to integers if necessary.
-            remask      True to mask values outside the field of view.
-
-        Return:         a tuple containing Scalars of the start time and stop
-                        time of each (u,v) pair, as seconds TDB.
-        """
-
-        return self.time_range_at_uv_0d(uv_pair, remask=remask)
-
-    #===========================================================================
-    def uv_range_at_time(self, time, remask=False):
-        """The (u,v) range of spatial pixels observed at the specified time.
-
-        For the Pixel observation subclass, the (u,v) ranges are always (0,1).
-        The time is largely ignored, although it is expected to fall within the
-        time limits of the observation and will be masked if remask == True.
-
-        Input:
-            time        a Scalar of time values in seconds TDB.
-            remask      True to mask values outside the time limits.
-
-        Return:         (uv_min, uv_max)
-            uv_min      the lower (u,v) corner Pair of the area observed at the
-                        specified time.
-            uv_max      the upper (u,v) corner Pair of the area observed at the
-                        specified time.
-        """
-
-        return Observation.uv_range_at_time_0d(self, time,
-                                               uv_shape=self.uv_shape,
-                                               remask=remask)
-
-    #===========================================================================
-    def time_shift(self, dtime):
-        """A copy of the observation object with a time-shift.
-
-        Input:
-            dtime       the time offset to apply to the observation, in units of
-                        seconds. A positive value shifts the observation later.
-
-        Return:         a (shallow) copy of the object with a new time.
-        """
-
-        obs = Pixel(axes=self.axes, cadence=self.cadence.time_shift(dtime),
-                    fov=self.fov, path=self.path, frame=self.frame)
-
-        for key in self.subfields.keys():
-            obs.insert_subfield(key, self.subfields[key])
-
-        return obs
-
-    ############################################################################
-    # Overrides of Observation class methods
-    ############################################################################
-
-    def event_at_grid(self, meshgrid, tfrac=0.5, time=None):
-        """An event object describing the arrival of a photon at a set of
-        locations defined by the given meshgrid. This version overrides the
-        default definition to apply the timing for each pixel of a time-sequence
-        by default.
-
-        Input:
-            meshgrid    a Meshgrid object describing the sampling of the field
-                        of view.
-            tfrac       Scalar of fractional times during the exposure, where
-                        tfrac=0 at the beginning and 1 at the end. Default is
-                        0.5.
-            time        optional Scalar of absolute time in seconds. Only one of
-                        tfrac and time can be specified.
-
-        Return:         the corresponding event.
-        """
-
-        if time is None:
-            tstep = np.arange(self.cadence.shape[0]) + tfrac
-            time = self.cadence.time_at_tstep(tstep)
-            time = time.append_axes(len(meshgrid.shape))
-
-        event = Event(time, Vector3.ZERO, self.path, self.frame)
-
-        # Insert the arrival directions
-        event.neg_arr_ap = meshgrid.los
-
-        return event
-
-    #===========================================================================
-    def gridless_event(self, meshgrid, tfrac=0.5, time=None,
-                             shapeless=False):
-        """An event object describing the arrival of a photon at a set of locations
-        defined by the given meshgrid. This version overrides the default
-        definition to apply the timing for each pixel of a time-sequence by
-        default.
-
-        Input:
-            meshgrid    a Meshgrid object describing the sampling of the field
-                        of view.
-            tfrac       Scalar of fractional times during the exposure, where
-                        tfrac=0 at the beginning and 1 at the end. Default is
-                        0.5.
-            time        optional Scalar of absolute time in seconds. Only one of
-                        tfrac and time can be specified; the other must be None.
-            shapeless   True to return a shapeless event, referring to the mean
-                        of all the times.
-
-        Return:         the corresponding event.
-        """
-
-        if tfrac is not None:
-            if time is not None:
-                raise ValueError('tfrac and time cannot both be defined')
-
-            tstep = np.arange(self.cadence.shape[0]) + tfrac
-            time = self.cadence.time_at_tstep(tstep)
-            time = time.append_axes(len(meshgrid.shape))
+class Pushframe(TimedImage):
+    """An Observation obtained with a TDI ("Time Delay and Integration") camera.
 
-        if shapeless:
-            time = time.mean()
+    It is a 2-D image made up of lines of pixels, each exposed and shifted
+    progressively to track a scene moving through the FOV at a constant rate.
+    """
 
-        event = Event(time, Vector3.ZERO, self.path, self.frame)
+    pass
 
-        return event
+#     INVENTORY_IMPLEMENTED = True
+#
+#     # Relates these axes to Snapshot axes
+#     AXIS_REPLACEMENTS = {
+#         'ut':  'u',
+#         'vt':  'v',
+#     }
+#
+#     #===========================================================================
+#     def __init__(self, axes, cadence, fov, path, frame, **subfields):
+#         """Constructor for a Pushframe.
+#
+#         Input:
+#             axes        a list or tuple of strings, with one value for each axis
+#                         in the associated data array. A value of 'u' or 'ut'
+#                         should appear at the location of the array's u-axis;
+#                         'vt' or 'v' should appear at the location of the array's
+#                         v-axis. The 't' suffix is used for the one of these axes
+#                         that is swept by the time-delayed integration.
+#
+#             cadence     a TDICadence object defining the start time and duration
+#                         of each consecutive line of the detector. Alternatively,
+#                         a tuple or dictionary providing input arguments to the
+#                         TDICadence constructor (after the number of lines, which
+#                         is defined by the FOV):
+#                             (tstart, tdi_texp, tdi_stages[, tdi_sign])
+#
+#             fov         a time-independent FOV (field-of-view) object, which
+#                         describes the field of view including any spatial
+#                         distortion. It maps between spatial coordinates (u,v)
+#                         and instrument coordinates (x,y).
+#
+#             path        the path waypoint co-located with the instrument.
+#
+#             frame       the wayframe of a coordinate frame fixed to the optics
+#                         of the instrument. This frame should have its Z-axis
+#                         pointing outward near the center of the line of sight,
+#                         with the X-axis pointing rightward and the y-axis
+#                         pointing downward.
+#
+#             subfields   a dictionary containing all of the optional attributes.
+#                         Additional subfields may be included as needed.
+#         """
+#
+#         # Basic properties
+#         self.path = Path.as_waypoint(path)
+#         self.frame = Frame.as_wayframe(frame)
+#
+#         # Static FOV
+#         self.staticfov = fov
+#         self.uv_shape = tuple(self.staticfov.uv_shape.vals)
+#
+#         # Axes
+#         self.axes = list(axes)
+#         assert (('u' in self.axes and 'vt' in self.axes) or
+#                 ('v' in self.axes and 'ut' in self.axes))
+#
+#         if 'ut' in self.axes:
+#             self.u_axis = self.axes.index('ut')
+#             self.v_axis = self.axes.index('v')
+#             self.t_axis = self.u_axis
+#             self._time_uv_index = 0
+#         else:
+#             self.u_axis = self.axes.index('u')
+#             self.v_axis = self.axes.index('vt')
+#             self.t_axis = self.v_axis
+#             self._time_uv_index = 1
+#
+#         self.tsteps = self.uv_shape[self.t_axis]
+#         self.swap_uv = (self.u_axis > self.v_axis)
+#
+#         # Shape / Size
+#         self.shape = len(axes) * [0]
+#         self.shape[self.u_axis] = self.uv_shape[0]
+#         self.shape[self.v_axis] = self.uv_shape[1]
+#
+#         # Cadence
+#         self._lines = self.uv_shape[self._time_uv_index]
+#         if isinstance(cadence, (tuple, list)):
+#             self.cadence = TDICadence(self._lines, *cadence)
+#         elif isinstance(cadence, dict):
+#             self.cadence = TDICadence(self._lines, **cadence)
+#         elif isinstance(cadence, TDICadence):
+#             self.cadence = cadence
+#             assert self.cadence.shape == (self._lines,)
+#         else:
+#             raise TypeError('Invalid cadence class for PushFrame: ' +
+#                             type(cadence).__name__)
+#
+#         # Timing
+#         self.time = self.cadence.time
+#         self.midtime = self.cadence.midtime
+#
+#         # TDI applied to FOV
+#         if self.staticfov.IS_TIME_INDEPENDENT:
+#             tdi_axis = (('-' if self.cadence.tdi_sign < 0 else '')
+#                         + self.axes[self.t_axis][0])
+#             self.fov = TDIFOV(self.staticfov, self.cadence.time[1],
+#                               self.cadence.tdi_texp, tdi_axis)
+#         else:
+#             self.fov = self.staticfov
+#
+#         # Optional subfields
+#         self.subfields = {}
+#         for key in subfields.keys():
+#             self.insert_subfield(key, subfields[key])
+#
+#         # Snapshot class proxy (for inventory)
+#         snapshot_axes = [Pushframe.AXIS_REPLACEMENTS.get(axis, axis)
+#                          for axis in axes]
+#         snapshot_tstart = self.cadence.time[0]
+#         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
+#
+#         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
+#                                  self.fov, self.path, self.frame, **subfields)
+#
+#     def __getstate__(self):
+#         return (self.axes, self.cadence, self.fov, self.path, self.frame,
+#                 self.subfields)
+#
+#     def __setstate__(self, state):
+#         self.__init__(*state[:-1], **state[-1])
+#
+#     #===========================================================================
+#     def uvt(self, indices, remask=False, derivs=True):
+#         """Coordinates (u,v) and time t for indices into the data array.
+#
+#         This method supports non-integer index values.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#             derivs      True to include derivatives in the returned values.
+#
+#         Return:         (uv, time)
+#             uv          a Pair defining the values of (u,v) within the FOV that
+#                         are associated with the array indices.
+#             time        a Scalar defining the time in seconds TDB associated
+#                         with the array indices.
+#         """
+#
+#         indices = Vector.as_vector(indices, recursive=derivs)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#
+#         tstep = uv.to_scalar(self._time_uv_index)
+#         time = self.cadence.time_at_tstep(tstep, remask=remask)
+#
+#         # Apply mask if necessary, because only one of (u,v) has been masked
+#         if remask:
+#             is_outside = self.uv_is_outside(uv, inclusive=True)
+#             if np.any(is_outside.vals):
+#                 uv = uv.remask_or(is_outside.vals)
+#                 time = time.remask(uv.mask)
+#
+#         return (uv, time)
+#
+#     #===========================================================================
+#     def uvt_range(self, indices, remask=False):
+#         """Ranges of (u,v) spatial coordinates and time for integer array
+#         indices.
+#
+#         Input:
+#             indices     a Scalar or Vector of array indices.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         (uv_min, uv_max, time_min, time_max)
+#             uv_min      a Pair defining the minimum values of FOV (u,v)
+#                         associated the pixel.
+#             uv_max      a Pair defining the maximum values of FOV (u,v)
+#                         associated the pixel.
+#             time_min    a Scalar defining the minimum time associated with the
+#                         array indices. It is given in seconds TDB.
+#             time_max    a Scalar defining the maximum time value.
+#         """
+#
+#         indices = Vector.as_vector(indices, recursive=False)
+#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#         uv_min = uv.int(top=self.uv_shape, remask=remask)
+#
+#         tstep = uv_min.to_scalar(self._time_uv_index)
+#         (time_min, time_max) = self.cadence.time_range_at_tstep(tstep,
+#                                                                 remask=remask)
+#
+#         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
+#
+#     #===========================================================================
+#     def uv_range_at_tstep(self, tstep, remask=False):
+#         """A tuple defining the range of spatial (u,v) pixels active at a
+#         particular time step.
+#
+#         Input:
+#             tstep       a Scalar time step index.
+#             remask      True to mask values outside the time interval.
+#
+#         Return:         a tuple (uv_min, uv_max)
+#             uv_min      a Pair defining the minimum values of FOV (u,v)
+#                         coordinates active at this time step.
+#             uv_min      a Pair defining the maximum values of FOV (u,v)
+#                         coordinates active at this time step (exclusive).
+#         """
+#
+#         tstep = Scalar.as_scalar(tstep, recursive=False)
+#         time = self.cadence.time_at_tstep(tstep, remask=remask)
+#         return self.uv_range_at_time(time)
+#
+#     #===========================================================================
+#     def time_range_at_uv(self, uv_pair, remask=False):
+#         """The start and stop times of the specified spatial pixel (u,v).
+#
+#         Input:
+#             uv_pair     a Pair of spatial (u,v) data array coordinates,
+#                         truncated to integers if necessary.
+#             remask      True to mask values outside the field of view.
+#
+#         Return:         a tuple containing Scalars of the start time and stop
+#                         time of each (u,v) pair, as seconds TDB.
+#         """
+#
+#         tstep = Pair.as_pair(uv_pair).to_scalar(self._time_uv_index)
+#         (time_min, time_max) = self.cadence.time_range_at_tstep(tstep,
+#                                                                 remask=remask)
+#
+#         # Apply mask if necessary (because remask above only handles 1-D)
+#         if remask:
+#             is_outside = self.uv_is_outside(uv_pair, inclusive=True)
+#             if np.any(is_outside.vals):
+#                 time_min = time_min.remask_or(is_outside.vals)
+#                 # time_max is shapeless so it can't take a mask
+#
+#         return (time_min, time_max)
+#
+#     #===========================================================================
+#     def uv_range_at_time(self, time, remask=False):
+#         """The (u,v) range of spatial pixels observed at the specified time.
+#
+#         Input:
+#             time        a Scalar of time values in seconds TDB.
+#             remask      True to mask values outside the time limits.
+#
+#         Return:         (uv_min, uv_max)
+#             uv_min      the lower (u,v) corner Pair of the area observed at the
+#                         specified time.
+#             uv_max      the upper (u,v) corner Pair of the area observed at the
+#                         specified time.
+#         """
+#
+#         (tstep_min,
+#          tstep_max) = self.cadence.tstep_range_at_time(time, remask=remask)
+#
+#         i_tdi = self._time_uv_index
+#         j_tdi = 1 - itdi
+#
+#         uv_min_vals = np.zeros(tstep_min.shape + (2,), dtype='int')
+#         uv_min_vals[..., i_tdi] = tstep_min.vals
+#
+#         uv_max_vals = np.empty(tstep_min.shape + (2,), dtype='int')
+#         uv_max_vals[..., i_tdi] = tstep_max.vals
+#         uv_max_vals[..., j_tdi] = self.uv_shape[j_tdi]
+#
+#         uv_min = Pair(uv_min_vals, mask=tstep_min.mask)
+#         uv_max = Pair(uv_max_vals, mask=tstep_min.mask)
+#         return (uv_min, uv_max)
+#
+#     #===========================================================================
+#     def time_shift(self, dtime):
+#         """A copy of the observation object with a time-shift.
+#
+#         Input:
+#             dtime       the time offset to apply to the observation, in units of
+#                         seconds. A positive value shifts the observation later.
+#
+#         Return:         a (shallow) copy of the object with a new time.
+#         """
+#
+#         obs = Pushframe(self.axes, self.cadence.time_shift(dtime),
+#                         self.fov, self.path, self.frame)
+#
+#         for key in self.subfields.keys():
+#             obs.insert_subfield(key, self.subfields[key])
+#
+#         return obs
+#
+#     #===========================================================================
+#     def inventory(self, *args, **kwargs):
+#         """Info about the bodies that appear unobscured inside the FOV. See
+#         Snapshot.inventory() for details.
+#
+#         WARNING: Not properly updated for class PushFrame. Use at your own risk.
+#         This operates by returning every body that would have been inside the
+#         FOV of this observation if it were instead a Snapshot, evaluated at the
+#         given tfrac.
+#         """
+#
+#         return self.snapshot.inventory(*args, **kwargs)
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
 
-class Test_Pixel(unittest.TestCase):
+class Test_Pushframe(unittest.TestCase):
 
     def runTest(self):
 
-        from oops.cadence.metronome import Metronome
+        from oops.cadence.tdicadence import TDICadence
         from oops.fov.flatfov import FlatFOV
 
-        fov = FlatFOV((0.001,0.001), (1,1))
-        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
-        obs = Pixel(axes=('t'),
-                    cadence=cadence, fov=fov, path='SSB', frame='J2000')
-
-        indices = Scalar([(0,),(1,),(20,),(21,)])
-        indices_ = indices.copy()
-        indices_.vals[indices_.vals == 20] -= 1         # clip the top
+        flatfov = FlatFOV((0.001,0.001), (10,20))
+        cadence = TDICadence(lines=20, tstart=100., tdi_texp=10., tdi_stages=2,
+                             tdi_sign=-1)
+        obs = Pushframe(axes=('u','vt'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
+
+        indices = Vector([( 0,0),( 0,1),( 0,10),( 0,18),( 0,19),( 0,20),( 0,21),
+                          (10,0),(10,1),(10,10),(10,18),(10,19),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
 
         # uvt() with remask == False
-        (uv, time) = obs.uvt(indices)
+        (uv,time) = obs.uvt(indices)
 
         self.assertFalse(np.any(uv.mask))
         self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, cadence.time_at_tstep(indices))
-        self.assertEqual(uv, (0.5,0.5))
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, 2*[100,100,100,100,110,120,120])
 
         # uvt() with remask == True
-        (uv, time) = obs.uvt(indices, remask=True)
+        (uv,time) = obs.uvt(indices, remask=True)
 
-        self.assertTrue(np.all(uv.mask == np.array([3*[[False]] + [[True]]])))
+        self.assertTrue(np.all(uv.mask == np.array(2*(6*[False]+[True]))))
         self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time[:3], cadence.tstride * indices[:3])
-        self.assertEqual(uv[:3], (0.5,0.5))
+        self.assertEqual(time, cadence.time_at_tstep(tstep, remask=True))
+        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
 
         # uvt_range() with remask == False
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
 
         self.assertFalse(np.any(uv_min.mask))
         self.assertFalse(np.any(uv_max.mask))
         self.assertFalse(np.any(time_min.mask))
         self.assertFalse(np.any(time_max.mask))
 
-        self.assertEqual(uv_min, (0,0))
-        self.assertEqual(uv_max, (1,1))
-
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_)[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
+        self.assertEqual(uv_min,
+                         [(0,0),(0,1),(0,10),(0,18),(0,19),(0,19),(0,21),
+                          (9,0),(9,1),(9,10),(9,18),(9,19),(9,19),(9,21)])
+        self.assertEqual(uv_max, uv_min + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
 
         # uvt_range() with remask == False, new indices
-        non_ints = indices + 0.2
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9))
 
         self.assertFalse(np.any(uv_min.mask))
         self.assertFalse(np.any(uv_max.mask))
         self.assertFalse(np.any(time_min.mask))
         self.assertFalse(np.any(time_max.mask))
 
-        self.assertEqual(uv_min, (0,0))
-        self.assertEqual(uv_max, (1,1))
-
-        self.assertEqual(time_min, cadence.time_range_at_tstep(non_ints)[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
+        self.assertEqual(uv_min, Pair.as_pair(indices))
+        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
 
         # uvt_range() with remask == True, new indices
-        non_ints = indices + 0.2
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints, remask=True)
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9),
+                                                             remask=True)
 
-        self.assertTrue(np.all(uv_min.mask == np.array(2*[[False]] + 2*[[True]])))
+        self.assertTrue(np.all(uv_min.mask == np.array(5*[False] + 9*[True])))
         self.assertTrue(np.all(uv_max.mask == uv_min.mask))
         self.assertTrue(np.all(time_min.mask == uv_min.mask))
         self.assertTrue(np.all(time_max.mask == uv_min.mask))
 
-        self.assertEqual(uv_min[:2], (0,0))
-        self.assertEqual(uv_max[:2], (1,1))
-        self.assertEqual(time_min[:2], indices[:2] * cadence.tstride)
-        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
+        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
+        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
+        self.assertEqual(time_max[:2], cadence.time_range_at_tstep(tstep)[1][:2])
 
         # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,1),(1,0),(1,1),(1,2)])
+        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
+        tstep = uv.to_scalar(1)
 
         (time0, time1) = obs.time_range_at_uv(uv)
-
-        self.assertEqual(time0, obs.time[0])
-        self.assertEqual(time1, obs.time[1])
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
 
         # time_range_at_uv() with remask == True
         (time0, time1) = obs.time_range_at_uv(uv, remask=True)
 
         self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == time0.mask))
-        self.assertEqual(time0[:4], obs.time[0])
-        self.assertEqual(time1[:4], obs.time[1])
-
-        ####################################
-
-        # Alternative axis order ('a','t')
-
-        fov = FlatFOV((0.001,0.001), (1,1))
-        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
-        obs = Pixel(axes=('a','t'),
-                    cadence=cadence, fov=fov, path='SSB', frame='J2000')
-
-        indices = Pair([(0,0),(1,1),(0,20,),(1,21)])
-        indices_ = indices.copy()
-        indices_.vals[indices_.vals == 20] -= 1         # clip the top
-
-        # uvt() with remask == False
-        (uv,time) = obs.uvt(indices)
+        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
+        self.assertEqual(time0[:4], cadence.time_range_at_tstep(tstep)[0][:4])
+        self.assertEqual(time1[:4], cadence.time_range_at_tstep(tstep)[1][:4])
+
+        # Alternative axis order ('ut','v')
+        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
+                             tdi_sign=-1)
+        obs = Pushframe(axes=('ut','v'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
 
-        self.assertFalse(uv.mask)
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(time.without_mask(),
-                         cadence.time_at_tstep(indices.to_scalar(1)))
-        self.assertEqual(uv, (0.5,0.5))
+        indices = Vector([(-1,0),(0,-1),(0,0),(0,20),(9,0),(10,0),(11,0),(11,20)])
+        tstep = indices.to_scalar(0)
 
-        # uvt() with remask == True
-        (uv,time) = obs.uvt(indices, remask=True)
+        (uv,time) = obs.uvt(indices)
 
-        self.assertTrue(np.all(uv.mask == np.array(3*[False] + [True])))
-        self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time[:3], cadence.tstride * indices[:3].to_scalar(1))
-        self.assertEqual(uv[:3], (0.5,0.5))
+        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, cadence.time_at_tstep(tstep))
 
-        # uvt_range() with remask == False
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
 
-        self.assertFalse(uv_min.mask)
-        self.assertFalse(uv_max.mask)
-        self.assertFalse(time_min.mask)
-        self.assertFalse(time_max.mask)
-
-        self.assertEqual(uv_min, (0,0))
-        self.assertEqual(uv_max, (1,1))
-
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices.to_scalar(1))[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
-
-        # uvt_range() with remask == False, new indices
-        non_ints = indices + (0.2,0.9)
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
-
-        self.assertFalse(uv_min.mask)
-        self.assertFalse(uv_max.mask)
-        self.assertFalse(time_min.mask)
-        self.assertFalse(time_max.mask)
-
-        self.assertEqual(uv_min, (0,0))
-        self.assertEqual(uv_max, (1,1))
-
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices.to_scalar(1))[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
-
-        # uvt_range() with remask == True, new indices
-        non_ints = indices + (0.2,0.2)
-        (uv_min, uv_max, time_min,
-                         time_max) = obs.uvt_range(non_ints, remask=True)
-
-        self.assertTrue(np.all(uv_min.mask == np.array(2*[False] + 2*[True])))
-        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
-        self.assertTrue(np.all(time_min.mask == uv_min.mask))
-        self.assertTrue(np.all(time_max.mask == uv_min.mask))
-
-        self.assertEqual(uv_min[:2], (0,0))
-        self.assertEqual(uv_max[:2], (1,1))
-        self.assertEqual(uv_min[2:], Pair.MASKED)
-        self.assertEqual(uv_max[2:], Pair.MASKED)
-
-        self.assertEqual(time_min[:2], indices.to_scalar(1)[:2] * cadence.tstride)
-        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
-
-        # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,1),(1,0),(1,1),(1,2)])
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-        self.assertEqual(time0, obs.time[0])
-        self.assertEqual(time1, obs.time[1])
-
-        # time_range_at_uv() with remask == True
-        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
-
-        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == time0.mask))
-        self.assertEqual(time0[:4], obs.time[0])
-        self.assertEqual(time1[:4], obs.time[1])
+        self.assertEqual(uv_min,
+                         [(-1,0),(0,-1),(0,0),(0,19),(9,0),(9,0),(11,0),(11,19)])
+        self.assertEqual(uv_max, uv_min + (1,1))
+        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
+
+        (time0,time1) = obs.time_range_at_uv(indices)
+
+        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
+        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
+
+        # Alternative texp for discontinuous indices
+        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
+                                       tdi_sign=1)
+        obs = Pushframe(axes=('ut','v'),
+                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[0], 100.)
+
+        self.assertEqual(obs.uvt((-1,0))[0], (-1,0))
+        self.assertEqual(obs.uvt(( 0,0))[0], ( 0,0))
+        self.assertEqual(obs.uvt(( 5,0))[0], ( 5,0))
+        self.assertEqual(obs.uvt(( 5,5))[0], ( 5,5))
+        self.assertEqual(obs.uvt(( 9,5))[0], ( 9,5))
+        self.assertEqual(obs.uvt((9.5,5))[0],(9.5,5))
+        self.assertEqual(obs.uvt((10,5))[0], (10,5))
+
+        self.assertEqual(obs.uvt((-1,0))[1], 190.)
+        self.assertEqual(obs.uvt(( 0,0))[1], 190.)
+        self.assertEqual(obs.uvt(( 5,0))[1], 140.)
+        self.assertEqual(obs.uvt(( 5,5))[1], 140.)
+        self.assertEqual(obs.uvt(( 9,5))[1], 100.)
+        self.assertEqual(obs.uvt((9.5,5))[1],150.)
+        self.assertEqual(obs.uvt((10,5))[1], 200.)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/pushbroom.py` & `rms_oops-0.0.4/ideas/deprecated/slit.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,69 +1,66 @@
 ################################################################################
-# oops/observation/pushbroom.py: Subclass Pushbroom of class Observation
+# oops/observation/slit.py: Subclass Slit of class Observation
 ################################################################################
 
 import numpy as np
 from polymath import Scalar, Pair, Vector
 
 from oops.observation          import Observation
 from oops.observation.snapshot import Snapshot
 from oops.cadence              import Cadence
 from oops.cadence.metronome    import Metronome
 from oops.frame                import Frame
 from oops.path                 import Path
 
 from oops.observation.timedimage import TimedImage
 
-class Pushbroom(TimedImage):
-    """A subclass of Observation consisting of a 2-D image generated by sweeping
-    a 1-D strip of sensors across a field of view.
-
-    The FOV object is assumed to define the entire 2-D field of view, even if
-    the reality is that a 1-D array was swept in a (roughly) perpendicular
-    direction. The virtual array of data is assumed to have a t-dimension of 1,
-    while the number of time steps is equal to the number of samples in the u
-    or v direction, depending on the direction of sweep. In effect, then, the
-    virtual array samples a diagonal ramp through the (u,v,t) cube.
+class Slit(TimedImage):
+    """A subclass of Observation consisting of a 2-D image constructed by
+    rotating an instrument that has a 1-D array of sensors.
+
+    The FOV describes the 1-D sensor array. The second axis of the image is
+    simulated by sampling the slit according to the cadence as the instrument
+    rotates.
     """
 
     pass
 
 #     INVENTORY_IMPLEMENTED = True
 #
 #     # Relates these axes to Snapshot axes
 #     AXIS_REPLACEMENTS = {
-#         'ut':  'u',
-#         'vt':  'v',
+#         'ut': 'u',
+#         'vt': 'v',
 #     }
 #
 #     #===========================================================================
 #     def __init__(self, axes, cadence, fov, path, frame, **subfields):
-#         """Constructor for a Pushbroom observation.
+#         """Constructor for a Slit observation.
 #
 #         Input:
 #             axes        a list or tuple of strings, with one value for each axis
 #                         in the associated data array. A value of 'u' or 'ut'
 #                         should appear at the location of the array's u-axis;
 #                         'vt' or 'v' should appear at the location of the array's
 #                         v-axis. The 't' suffix is used for the one of these axes
-#                         that is emulated by time-sampling the slit.
+#                         that is emulated by time-sampling perpendicular to the
+#                         slit.
 #
 #             cadence     a 1-D Cadence object defining the start time and
-#                         duration of each consecutive position in the sweep of
-#                         the pushbroom. Alternatively, a tuple or dictionary
-#                         providing input arguments to the constructor
-#                         Metronome.for_array1d() (excluding the number of
-#                         lines, which is defined by the FOV)
-#                             (tstart, texp, interstep_delay)
+#                         duration of each consecutive measurement. Alternatively,
+#                         a tuple or dictionary providing the input arguments to
+#                         the constructor Metronome.for_array1d():
+#                             (steps, tstart, texp, [interstep_delay])
 #
 #             fov         a FOV (field-of-view) object, which describes the field
 #                         of view including any spatial distortion. It maps
 #                         between spatial coordinates (u,v) and instrument
-#                         coordinates (x,y).
+#                         coordinates (x,y). For a Slit object, one of the axes of
+#                         the FOV must have length 1.
 #
 #             path        the path waypoint co-located with the instrument.
 #
 #             frame       the wayframe of a coordinate frame fixed to the optics
 #                         of the instrument. This frame should have its Z-axis
 #                         pointing outward near the center of the line of sight,
 #                         with the X-axis pointing rightward and the y-axis
@@ -75,72 +72,72 @@
 #
 #         # Basic properties
 #         self.path = Path.as_waypoint(path)
 #         self.frame = Frame.as_wayframe(frame)
 #
 #         # FOV
 #         self.fov = fov
-#         self.uv_shape = tuple(self.fov.uv_shape.vals)
+#         self._fov_uv_shape = tuple(self.fov.uv_shape.vals)
 #
-#         # Axes
+#         # Cadence
+#         if isinstance(cadence, (tuple,list)):
+#             self.cadence = Metronome.for_array1d(*cadence)
+#         elif isinstance(cadence, dict):
+#             self.cadence = Metronome.for_array1d(**cadence)
+#         elif isinstance(cadence, Cadence):
+#             self.cadence = cadence
+#             assert len(self.cadence.shape) == 1
+#         else:
+#             raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
+#
+#         # Axes / Shape / Size
 #         self.axes = list(axes)
 #         assert (('u' in self.axes and 'vt' in self.axes) or
 #                 ('v' in self.axes and 'ut' in self.axes))
 #
+#         lines = self.cadence.shape[0]
+#
 #         if 'ut' in self.axes:
 #             self.u_axis = self.axes.index('ut')
 #             self.v_axis = self.axes.index('v')
 #             self.t_axis = self.u_axis
-#             self._cross_slit_uv_index = 0
-#             self._along_slit_uv_index = 1
+#             self._along_slit_axis = self.v_axis
+#             self._cross_slit_uv_axis = 0
+#             self._along_slit_uv_axis = 1
+#             self.uv_shape = (lines, self._fov_uv_shape[self._along_slit_axis])
 #         else:
 #             self.u_axis = self.axes.index('u')
 #             self.v_axis = self.axes.index('vt')
 #             self.t_axis = self.v_axis
-#             self._cross_slit_uv_index = 1
-#             self._along_slit_uv_index = 0
+#             self._along_slit_axis = self.u_axis
+#             self._cross_slit_uv_axis = 1
+#             self._along_slit_uv_axis = 0
+#             self.uv_shape = (self._fov_uv_shape[self._along_slit_axis], lines)
 #
 #         self.swap_uv = (self.u_axis > self.v_axis)
 #
-#         # Shape / Size
+#         assert self._fov_uv_shape[self._cross_slit_uv_axis] == 1
+#         self._along_slit_len = self._fov_uv_shape[self._along_slit_uv_axis]
+#         self._cross_slit_len = lines
+#
 #         self.shape = len(axes) * [0]
 #         self.shape[self.u_axis] = self.uv_shape[0]
 #         self.shape[self.v_axis] = self.uv_shape[1]
 #
-#         lines = self.uv_shape[self._cross_slit_uv_index]
-#         samples = self.uv_shape[self._along_slit_uv_index]
-#         self._cross_slit_len = lines
-#         self._along_slit_len = samples
-#
-#         slit_uv_shape = [1,1]
-#         slit_uv_shape[self._along_slit_uv_index] = samples
-#         self._slit_uv_shape = Pair(slit_uv_shape)
-#
-#         # Cadence
-#         if isinstance(cadence, (tuple,list)):
-#             self.cadence = Metronome.for_array1d(lines, *cadence)
-#         elif isinstance(cadence, dict):
-#             self.cadence = Metronome.for_array1d(lines, **cadence)
-#         elif isinstance(cadence, Cadence):
-#             self.cadence = cadence
-#             assert self.cadence.shape == (lines,)
-#         else:
-#             raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
-#
 #         # Timing
 #         self.time = self.cadence.time
 #         self.midtime = self.cadence.midtime
 #
 #         # Optional subfields
 #         self.subfields = {}
 #         for key in subfields.keys():
 #             self.insert_subfield(key, subfields[key])
 #
-#         # Snapshot class proxy
-#         snapshot_axes = [Pushbroom.AXIS_REPLACEMENTS.get(axis, axis)
+#         # Snapshot class proxy (for inventory)
+#         snapshot_axes = [Slit.AXIS_REPLACEMENTS.get(axis, axis)
 #                          for axis in axes]
 #         snapshot_tstart = self.cadence.time[0]
 #         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
 #
 #         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
 #                                  self.fov, self.path, self.frame, **subfields)
 #
@@ -165,34 +162,39 @@
 #         Return:         (uv, time)
 #             uv          a Pair defining the values of (u,v) within the FOV that
 #                         are associated with the array indices.
 #             time        a Scalar defining the time in seconds TDB associated
 #                         with the array indices.
 #         """
 #
+#         # Get the slit coordinate
 #         indices = Vector.as_vector(indices, recursive=derivs)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
+#         slit_coord = indices.to_scalar(self._along_slit_axis)
+#
+#         # Get the times
+#         tstep = indices.to_scalar(self.t_axis)
+#         time = self.cadence.time_at_tstep(tstep, remask=remask)
 #
-#         # Mask based on (u,v) if necessary
+#         # Re-mask the time if necessary
 #         if remask:
-#             mask = ((uv.vals[...,0] < 0) | (uv.vals[...,0] > self.uv_shape[0]) |
-#                     (uv.vals[...,1] < 0) | (uv.vals[...,1] > self.uv_shape[1]))
-#             if np.any(mask):
-#                 uv = uv.remask_or(mask)
-#
-#         # Get the time, inheriting the mask of uv
-#         tstep = uv.to_scalar(self._cross_slit_uv_index)
-#         time = self.cadence.time_at_tstep(tstep, remask=False, derivs=derivs)
+#             is_outside = ((slit_coord.vals < 0) |
+#                           (slit_coord.vals > self._along_slit_len))
+#             time = time.remask_or(is_outside)
+#
+#         # Create (u,v) Pair
+#         uv_vals = np.empty(indices.shape + (2,))
+#         uv_vals[..., self._along_slit_uv_axis] = slit_coord.vals
+#         uv_vals[..., self._cross_slit_uv_axis] = 0.5
+#         uv = Pair(uv_vals, mask=time.mask)
 #
 #         return (uv, time)
 #
 #     #===========================================================================
 #     def uvt_range(self, indices, remask=False):
-#         """Ranges of (u,v) spatial coordinates and time for integer array
-#         indices.
+#         """Ranges of FOV coordinates and time for integer array indices.
 #
 #         Input:
 #             indices     a Scalar or Vector of array indices.
 #             remask      True to mask values outside the field of view.
 #
 #         Return:         (uv_min, uv_max, time_min, time_max)
 #             uv_min      a Pair defining the minimum values of FOV (u,v)
@@ -200,247 +202,231 @@
 #             uv_max      a Pair defining the maximum values of FOV (u,v)
 #                         associated the pixel.
 #             time_min    a Scalar defining the minimum time associated with the
 #                         array indices. It is given in seconds TDB.
 #             time_max    a Scalar defining the maximum time value.
 #         """
 #
-#         # Interpret the (u,v) range
+#         # Get the slit coordinate
 #         indices = Vector.as_vector(indices, recursive=False)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
-#         uv_min = uv.int(top=self.uv_shape, remask=remask)
+#         slit_coord = indices.to_scalar(self._along_slit_axis)
+#         slit_int = slit_coord.int(top=self._along_slit_len, remask=remask)
 #
-#         # Intepret the time range, inheriting the mask of uv_min
-#         tstep = uv_min.to_scalar(self._cross_slit_uv_index)
+#         # Get the times
+#         tstep = indices.to_scalar(self.t_axis)
 #         (time_min,
-#          time_max) = self.cadence.time_range_at_tstep(tstep, remask=False)
+#          time_max) = self.cadence.time_range_at_tstep(tstep, remask=remask)
+#
+#         # Merge masks if necessary
+#         if remask:
+#             time_min = time_min.remask(time_min.mask | slit_int.mask)
+#             time_max = time_max.remask(time_min.mask)
+#
+#         # Create (u,v) Pair
+#         uv_min_vals = np.zeros(indices.shape + (2,), dtype='int')
+#         uv_min_vals[..., self._along_slit_uv_axis] = slit_int.vals
+#         uv_min = Pair(uv_min_vals, mask=time_min.mask)
 #
 #         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
 #
 #     #===========================================================================
 #     def time_range_at_uv(self, uv_pair, remask=False):
-#         """The start and stop integration times for the spatial pixel (u,v).
+#         """The start and stop times of the specified spatial pixel (u,v).
 #
 #         Input:
 #             uv_pair     a Pair of spatial (u,v) data array coordinates,
 #                         truncated to integers if necessary.
 #             remask      True to mask values outside the field of view.
 #
 #         Return:         a tuple containing Scalars of the start time and stop
 #                         time of each (u,v) pair, as seconds TDB.
 #         """
 #
-#         return self.time_range_at_uv_1d(uv_pair, remask=remask)
-#         uv_pair = Pair.as_pair(uv_pair, recursive=False)
-#         tstep = uv_pair.to_scalar(self._cross_slit_uv_index)
+#         tstep = Pair.as_pair(uv_pair).to_scalar(self._cross_slit_uv_axis)
 #         return self.cadence.time_range_at_tstep(tstep, remask=remask)
 #
 #     #===========================================================================
 #     def uv_range_at_time(self, time, remask=False):
-#         """The (u,v) range of spatial pixels active at the specified time.
+#         """The (u,v) range of spatial pixels observed at the specified time.
 #
 #         Input:
 #             time        a Scalar of time values in seconds TDB.
 #             remask      True to mask values outside the time limits.
 #
 #         Return:         (uv_min, uv_max)
 #             uv_min      the lower (u,v) corner Pair of the area observed at the
 #                         specified time.
 #             uv_max      the upper (u,v) corner Pair of the area observed at the
 #                         specified time.
 #         """
 #
-#         return Observation.uv_range_at_time_1d(self, time, self._slit_uv_shape,
-#                                                axis=self._cross_slit_uv_index,
+#         return Observation.uv_range_at_time_1d(self, time,
+#                                                uv_shape=self.fov.uv_shape,
+#                                                axis=self._along_slit_uv_index,
 #                                                remask=remask)
 #
 #     #===========================================================================
 #     def time_shift(self, dtime):
 #         """A copy of the observation object with a time-shift.
 #
 #         Input:
 #             dtime       the time offset to apply to the observation, in units of
 #                         seconds. A positive value shifts the observation later.
 #
 #         Return:         a (shallow) copy of the object with a new time.
 #         """
 #
-#         obs = Pushbroom(self.axes, self.cadence.time_shift(dtime),
-#                         self.fov, self.path, self.frame)
+#         obs = Slit(axes=self.axes, cadence=self.cadence.time_shift(dtime),
+#                    fov=self.fov, path=self.path, frame=self.frame)
 #
 #         for key in self.subfields.keys():
 #             obs.insert_subfield(key, self.subfields[key])
 #
 #         return obs
 #
 #     #===========================================================================
 #     def inventory(self, *args, **kwargs):
 #         """Info about the bodies that appear unobscured inside the FOV. See
 #         Snapshot.inventory() for details.
 #
-#         WARNING: Not properly updated for class Pushbroom. Use at your own risk.
-#         This operates by returning every body that would have been inside the
-#         FOV of this observation if it were instead a Snapshot, evaluated at the
-#         given tfrac.
+#         WARNING: Not properly updated for class Slit. Use at your own risk. This
+#         operates by returning every body that would have been inside the FOV of
+#         this observation if it were instead a Snapshot, evaluated at the given
+#         tfrac.
 #         """
 #
 #         return self.snapshot.inventory(*args, **kwargs)
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
 
-class Test_Pushbroom(unittest.TestCase):
+class Test_Slit(unittest.TestCase):
 
     def runTest(self):
 
         from oops.cadence.metronome import Metronome
         from oops.fov.flatfov import FlatFOV
 
-        ########################################
-        # Overall shape (10,20)
-        # Time is second axis; time = v * 10.
-        ########################################
-
-        flatfov = FlatFOV((0.001,0.001), (10,20))
+        fov = FlatFOV((0.001,0.001), (10,1))
         cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
-        obs = Pushbroom(axes=('u','vt'), cadence=cadence, fov=flatfov,
-                                         path='SSB', frame='J2000')
+        obs = Slit(axes=('u','vt'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
 
         indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
         tstep = indices.to_scalar(1)
-
-        indices_ = indices.copy()   # clipped at top
+        indices_ = indices.copy()
         indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
         indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
 
         # uvt() with remask == False
         (uv, time) = obs.uvt(indices)
 
         self.assertFalse(np.any(uv.mask))
         self.assertFalse(np.any(time.mask))
         self.assertEqual(time, cadence.time_at_tstep(tstep))
-        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv.to_scalar(1), 0.5)
 
         # uvt() with remask == True
         (uv, time) = obs.uvt(indices, remask=True)
 
         self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
         self.assertTrue(np.all(time.mask == uv.mask))
         self.assertEqual(time[:6], cadence.tstride * indices.to_scalar(1)[:6])
-        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
+        self.assertEqual(uv[:6].to_scalar(0), indices[:6].to_scalar(0))
+        self.assertEqual(uv[:6].to_scalar(1), 0.5)
 
         # uvt_range() with remask == False
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
 
         self.assertFalse(np.any(uv_min.mask))
         self.assertFalse(np.any(uv_max.mask))
         self.assertFalse(np.any(time_min.mask))
         self.assertFalse(np.any(time_max.mask))
 
-        self.assertEqual(uv_min, Pair.as_pair(indices_))
-        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(uv_min.to_scalar(0), indices_.to_scalar(0))
+        self.assertEqual(uv_min.to_scalar(1), 0)
+        self.assertEqual(uv_max.to_scalar(0), indices_.to_scalar(0) + 1)
+        self.assertEqual(uv_max.to_scalar(1), 1)
         self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
         self.assertEqual(time_max, time_min + cadence.texp)
 
-        # uvt_range() with remask == False, new indices
-        non_ints = indices + (0.2,0.9)
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min, Pair.as_pair(indices))
-        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
-
-        # uvt_range() with remask == True, new indices
-        non_ints = indices + (0.2,0.9)
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints,
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices,
                                                              remask=True)
 
-        self.assertTrue(np.all(uv_min.mask == np.array(2*[False] + 5*[True])))
+        self.assertTrue(np.all(uv_min.mask == np.array(6*[False] + [True])))
         self.assertTrue(np.all(uv_max.mask == uv_min.mask))
         self.assertTrue(np.all(time_min.mask == uv_min.mask))
         self.assertTrue(np.all(time_max.mask == uv_min.mask))
 
-        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
-        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
-        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
-        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
+        self.assertEqual(uv_min.to_scalar(0)[:6], indices_.to_scalar(0)[:6])
+        self.assertEqual(uv_min.to_scalar(1)[:6], 0)
+        self.assertEqual(uv_max.to_scalar(0)[:6], indices_.to_scalar(0)[:6] + 1)
+        self.assertEqual(uv_max.to_scalar(1)[:6], 1)
+        self.assertEqual(time_min[:6], cadence.tstride * indices_.to_scalar(1)[:6])
+        self.assertEqual(time_max[:6], time_min[:6] + cadence.texp)
 
         # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
-        tstep = uv.to_scalar(1)
+        uv = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        tstep = indices.to_scalar(1)
 
+        (time0, time1) = obs.time_range_at_uv(uv)
         uv_ = uv.copy()
         uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
         uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
 
-        (time0, time1) = obs.time_range_at_uv(uv)
         self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
         self.assertEqual(time1, time0 + cadence.texp)
 
         # time_range_at_uv() with remask == True
         (time0, time1) = obs.time_range_at_uv(uv, remask=True)
-        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
-        self.assertEqual(time0[:4], cadence.tstride * uv_.to_scalar(1)[:4])
-        self.assertEqual(time1[:4], time0[:4] + cadence.texp)
 
-        ########################################
+        self.assertTrue(np.all(time0.mask == 6*[False] + [True]))
+        self.assertTrue(np.all(time1.mask == time0.mask))
+        self.assertEqual(time0[:6], cadence.time_range_at_tstep(tstep)[0][:6])
+        self.assertEqual(time1[:6], time0[:6] + cadence.texp)
+
+        ####################################
+
         # Alternative axis order ('ut','v')
-        # Overall shape (10,20)
-        # Time is first axis; time = v * 10.
-        ########################################
 
+        fov = FlatFOV((0.001,0.001), (1,20))
         cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
-        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
-                                         path='SSB', frame='J2000')
+        obs = Slit(axes=('ut','v'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
 
         indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
         indices_ = indices.copy()
         indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
         indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
 
-        (uv, time) = obs.uvt(indices)
+        (uv,time) = obs.uvt(indices)
 
-        uv_ = uv.copy()
-        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
-        uv_.vals[:,1][uv_.vals[:,1] == 20] -= 1
-
-        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(uv.to_scalar(0), 0.5)
+        self.assertEqual(uv.to_scalar(1), indices.to_scalar(1))
         self.assertEqual(time, cadence.tstride * indices.to_scalar(0))
 
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
 
-        self.assertEqual(uv_min, Pair.as_pair(indices_))
-        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
+        self.assertEqual(uv_min.to_scalar(0), 0)
+        self.assertEqual(uv_min.to_scalar(1), indices_.to_scalar(1))
+        self.assertEqual(uv_max.to_scalar(0), 1)
+        self.assertEqual(uv_max.to_scalar(1), indices_.to_scalar(1) + 1)
         self.assertEqual(time_min, cadence.tstride * indices_.to_scalar(0))
         self.assertEqual(time_max, time_min + cadence.texp)
 
-        (time0, time1) = obs.time_range_at_uv(indices)
+        ####################################
 
-        self.assertEqual(time0, cadence.tstride * uv_.to_scalar(0))
-        self.assertEqual(time1, time0 + cadence.texp)
-
-        ########################################################
-        # Alternative texp for discontinuous time index
-        # Overall shape (10,20)
-        # Time is first axis; time = [0-8, 10-18, ..., 90-98]
-        ########################################################
+        # Alternative texp for discontinuous indices
 
+        fov = FlatFOV((0.001,0.001), (1,20))
         cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
-        obs = Pushbroom(axes=('ut','v'), cadence=cadence, fov=flatfov,
-                                         path='SSB', frame='J2000')
+        obs = Slit(axes=('ut','v'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
 
         self.assertEqual(obs.time[1], 98.)
 
         self.assertEqual(obs.uvt((0,0))[1],  0.)
         self.assertEqual(obs.uvt((5,0))[1], 50.)
         self.assertEqual(obs.uvt((5,5))[1], 50.)
 
@@ -449,47 +435,71 @@
         self.assertTrue(abs(obs.uvt((6      ,0))[1] - 60.) < delta)
         self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 62.) < delta)
         self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 64.) < delta)
         self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 66.) < delta)
         self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 68.) < delta)
         self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 70.) < delta)
 
-        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
-        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
-        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
-
-        self.assertTrue(abs(obs.uvt((6      ,0))[0] - (6.0,0.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
-        self.assertTrue(abs(obs.uvt((7 - eps,5))[0] - (7.0,5.)) < delta)
-        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
-
-        # Test the upper edge
-        uv_list = []
-        uvt_list = []
-        for i,u in enumerate([10.-eps, 10., 10.+eps]):
-          for j,v in enumerate([20.-eps, 20., 20.+eps]):
-            uv_list.append((u,v))
-
-            uvt = obs.uvt((u,v), remask=True)
-            uvt_list.append(uvt)
-            if (i < 2) and (j < 2):
-                self.assertEqual(uvt[0], (u,v))
-            else:
-                self.assertEqual(uvt[0], Pair.MASKED)
-
-            if (i < 2) and (j < 2):
-                self.assertTrue((uvt[1] - (10. * u - 2.)).abs() < delta)
-            else:
-                self.assertEqual(uvt[1], Scalar.MASKED)
-
-        # Try all at once
-        uvt = obs.uvt(uv_list, remask=True)
-        self.assertEqual(uvt[0], [a[0] for a in uvt_list])
-        self.assertEqual(uvt[1], [a[1] for a in uvt_list])
+        self.assertEqual(obs.uvt((0,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((5,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((5,5))[0], (0.5,5.))
+
+        self.assertTrue(abs(obs.uvt((6      ,0))[0] - (0.5,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (0.5,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (0.5,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (0.5,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (0.5,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,5))[0] - (0.5,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (0.5,6.)) < delta)
+
+        # Test using scalar indices
+        below = obs.uvt((0,20 - eps), remask=True)[0].to_scalar(1)
+        exact = obs.uvt((0,20      ), remask=True)[0].to_scalar(1)
+        above = obs.uvt((0,20 + eps), remask=True)[0].to_scalar(1)
+
+        self.assertTrue(below < 20.)
+        self.assertTrue(20. - below < delta)
+        self.assertTrue(exact == 20.)
+        self.assertTrue(above == Scalar.MASKED)
+        self.assertTrue(above.mask)
+
+        # Test using a Vector index
+        indices = Vector([(0,20 - eps), (0,20), (0,20 + eps)])
+
+        u = obs.uvt(indices, remask=True)[0].to_scalar(1)
+        self.assertTrue(u == (below, exact, above))
+
+        # Alternative texp and axes
+        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
+        obs = Slit(axes=('a','v','b','ut','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+
+        self.assertEqual(obs.time[1], 98.)
+
+        self.assertEqual(obs.uvt((1,0,3,0,4))[1],  0.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1], 50.)
+        self.assertEqual(obs.uvt((1,0,3,5,4))[1], 50.)
+
+        eps = 1.e-15
+        delta = 1.e-13
+        self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 60.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 62.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 64.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 66.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 68.) < delta)
+        self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 70.) < delta)
+
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (0.5,0.))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (0.5,5.))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6      ,7))[0] - (0.5,0.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2    ,7))[0] - (0.5,1.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4    ,7))[0] - (0.5,2.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6    ,7))[0] - (0.5,3.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8    ,7))[0] - (0.5,4.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,5,4,7 - eps,7))[0] - (0.5,5.)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.     ,7))[0] - (0.5,6.)) < delta)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/pushframe.py` & `rms_oops-0.0.4/oops/cadence/reshapedcadence.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,472 +1,440 @@
 ################################################################################
-# oops/observation/pushframe.py: Subclass Pushframe of class Observation
+# oops/cadence/reshapedcadence.py: ReshapedCadence subclass of class Cadence
 ################################################################################
 
 import numpy as np
-from polymath import Pair, Vector, Qube
 
-from oops.observation           import Observation
-from oops.observation.snapshot  import Snapshot
-from oops.cadence.tdicadence    import TDICadence
-from oops.fov.tdifov            import TDIFOV
-from oops.frame                 import Frame
-from oops.path                  import Path
+from polymath     import Qube, Scalar, Pair, Vector
+from oops.cadence import Cadence
 
-from oops.observation.timedimage import TimedImage
+class ReshapedCadence(Cadence):
+    """A Cadence that has been reshaped.
 
-class Pushframe(TimedImage):
-    """An Observation obtained with a TDI ("Time Delay and Integration") camera.
-
-    It is a 2-D image made up of lines of pixels, each exposed and shifted
-    progressively to track a scene moving through the FOV at a constant rate.
+    The time steps are defined by another cadence with a different shape.
+    This can be used, for example, to convert a 1-D cadence into an N-D cadence.
     """
 
-    pass
-
-#     INVENTORY_IMPLEMENTED = True
-#
-#     # Relates these axes to Snapshot axes
-#     AXIS_REPLACEMENTS = {
-#         'ut':  'u',
-#         'vt':  'v',
-#     }
-#
-#     #===========================================================================
-#     def __init__(self, axes, cadence, fov, path, frame, **subfields):
-#         """Constructor for a Pushframe.
-#
-#         Input:
-#             axes        a list or tuple of strings, with one value for each axis
-#                         in the associated data array. A value of 'u' or 'ut'
-#                         should appear at the location of the array's u-axis;
-#                         'vt' or 'v' should appear at the location of the array's
-#                         v-axis. The 't' suffix is used for the one of these axes
-#                         that is swept by the time-delayed integration.
-#
-#             cadence     a TDICadence object defining the start time and duration
-#                         of each consecutive line of the detector. Alternatively,
-#                         a tuple or dictionary providing input arguments to the
-#                         TDICadence constructor (after the number of lines, which
-#                         is defined by the FOV):
-#                             (tstart, tdi_texp, tdi_stages[, tdi_sign])
-#
-#             fov         a time-independent FOV (field-of-view) object, which
-#                         describes the field of view including any spatial
-#                         distortion. It maps between spatial coordinates (u,v)
-#                         and instrument coordinates (x,y).
-#
-#             path        the path waypoint co-located with the instrument.
-#
-#             frame       the wayframe of a coordinate frame fixed to the optics
-#                         of the instrument. This frame should have its Z-axis
-#                         pointing outward near the center of the line of sight,
-#                         with the X-axis pointing rightward and the y-axis
-#                         pointing downward.
-#
-#             subfields   a dictionary containing all of the optional attributes.
-#                         Additional subfields may be included as needed.
-#         """
-#
-#         # Basic properties
-#         self.path = Path.as_waypoint(path)
-#         self.frame = Frame.as_wayframe(frame)
-#
-#         # Static FOV
-#         self.staticfov = fov
-#         self.uv_shape = tuple(self.staticfov.uv_shape.vals)
-#
-#         # Axes
-#         self.axes = list(axes)
-#         assert (('u' in self.axes and 'vt' in self.axes) or
-#                 ('v' in self.axes and 'ut' in self.axes))
-#
-#         if 'ut' in self.axes:
-#             self.u_axis = self.axes.index('ut')
-#             self.v_axis = self.axes.index('v')
-#             self.t_axis = self.u_axis
-#             self._time_uv_index = 0
-#         else:
-#             self.u_axis = self.axes.index('u')
-#             self.v_axis = self.axes.index('vt')
-#             self.t_axis = self.v_axis
-#             self._time_uv_index = 1
-#
-#         self.tsteps = self.uv_shape[self.t_axis]
-#         self.swap_uv = (self.u_axis > self.v_axis)
-#
-#         # Shape / Size
-#         self.shape = len(axes) * [0]
-#         self.shape[self.u_axis] = self.uv_shape[0]
-#         self.shape[self.v_axis] = self.uv_shape[1]
-#
-#         # Cadence
-#         self._lines = self.uv_shape[self._time_uv_index]
-#         if isinstance(cadence, (tuple, list)):
-#             self.cadence = TDICadence(self._lines, *cadence)
-#         elif isinstance(cadence, dict):
-#             self.cadence = TDICadence(self._lines, **cadence)
-#         elif isinstance(cadence, TDICadence):
-#             self.cadence = cadence
-#             assert self.cadence.shape == (self._lines,)
-#         else:
-#             raise TypeError('Invalid cadence class for PushFrame: ' +
-#                             type(cadence).__name__)
-#
-#         # Timing
-#         self.time = self.cadence.time
-#         self.midtime = self.cadence.midtime
-#
-#         # TDI applied to FOV
-#         if self.staticfov.IS_TIME_INDEPENDENT:
-#             tdi_axis = (('-' if self.cadence.tdi_sign < 0 else '')
-#                         + self.axes[self.t_axis][0])
-#             self.fov = TDIFOV(self.staticfov, self.cadence.time[1],
-#                               self.cadence.tdi_texp, tdi_axis)
-#         else:
-#             self.fov = self.staticfov
-#
-#         # Optional subfields
-#         self.subfields = {}
-#         for key in subfields.keys():
-#             self.insert_subfield(key, subfields[key])
-#
-#         # Snapshot class proxy (for inventory)
-#         snapshot_axes = [Pushframe.AXIS_REPLACEMENTS.get(axis, axis)
-#                          for axis in axes]
-#         snapshot_tstart = self.cadence.time[0]
-#         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
-#
-#         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
-#                                  self.fov, self.path, self.frame, **subfields)
-#
-#     def __getstate__(self):
-#         return (self.axes, self.cadence, self.fov, self.path, self.frame,
-#                 self.subfields)
-#
-#     def __setstate__(self, state):
-#         self.__init__(*state[:-1], **state[-1])
-#
-#     #===========================================================================
-#     def uvt(self, indices, remask=False, derivs=True):
-#         """Coordinates (u,v) and time t for indices into the data array.
-#
-#         This method supports non-integer index values.
-#
-#         Input:
-#             indices     a Scalar or Vector of array indices.
-#             remask      True to mask values outside the field of view.
-#             derivs      True to include derivatives in the returned values.
-#
-#         Return:         (uv, time)
-#             uv          a Pair defining the values of (u,v) within the FOV that
-#                         are associated with the array indices.
-#             time        a Scalar defining the time in seconds TDB associated
-#                         with the array indices.
-#         """
-#
-#         indices = Vector.as_vector(indices, recursive=derivs)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
-#
-#         tstep = uv.to_scalar(self._time_uv_index)
-#         time = self.cadence.time_at_tstep(tstep, remask=remask)
-#
-#         # Apply mask if necessary, because only one of (u,v) has been masked
-#         if remask:
-#             is_outside = self.uv_is_outside(uv, inclusive=True)
-#             if np.any(is_outside.vals):
-#                 uv = uv.remask_or(is_outside.vals)
-#                 time = time.remask(uv.mask)
-#
-#         return (uv, time)
-#
-#     #===========================================================================
-#     def uvt_range(self, indices, remask=False):
-#         """Ranges of (u,v) spatial coordinates and time for integer array
-#         indices.
-#
-#         Input:
-#             indices     a Scalar or Vector of array indices.
-#             remask      True to mask values outside the field of view.
-#
-#         Return:         (uv_min, uv_max, time_min, time_max)
-#             uv_min      a Pair defining the minimum values of FOV (u,v)
-#                         associated the pixel.
-#             uv_max      a Pair defining the maximum values of FOV (u,v)
-#                         associated the pixel.
-#             time_min    a Scalar defining the minimum time associated with the
-#                         array indices. It is given in seconds TDB.
-#             time_max    a Scalar defining the maximum time value.
-#         """
-#
-#         indices = Vector.as_vector(indices, recursive=False)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
-#         uv_min = uv.int(top=self.uv_shape, remask=remask)
-#
-#         tstep = uv_min.to_scalar(self._time_uv_index)
-#         (time_min, time_max) = self.cadence.time_range_at_tstep(tstep,
-#                                                                 remask=remask)
-#
-#         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
-#
-#     #===========================================================================
-#     def uv_range_at_tstep(self, tstep, remask=False):
-#         """A tuple defining the range of spatial (u,v) pixels active at a
-#         particular time step.
-#
-#         Input:
-#             tstep       a Scalar time step index.
-#             remask      True to mask values outside the time interval.
-#
-#         Return:         a tuple (uv_min, uv_max)
-#             uv_min      a Pair defining the minimum values of FOV (u,v)
-#                         coordinates active at this time step.
-#             uv_min      a Pair defining the maximum values of FOV (u,v)
-#                         coordinates active at this time step (exclusive).
-#         """
-#
-#         tstep = Scalar.as_scalar(tstep, recursive=False)
-#         time = self.cadence.time_at_tstep(tstep, remask=remask)
-#         return self.uv_range_at_time(time)
-#
-#     #===========================================================================
-#     def time_range_at_uv(self, uv_pair, remask=False):
-#         """The start and stop times of the specified spatial pixel (u,v).
-#
-#         Input:
-#             uv_pair     a Pair of spatial (u,v) data array coordinates,
-#                         truncated to integers if necessary.
-#             remask      True to mask values outside the field of view.
-#
-#         Return:         a tuple containing Scalars of the start time and stop
-#                         time of each (u,v) pair, as seconds TDB.
-#         """
-#
-#         tstep = Pair.as_pair(uv_pair).to_scalar(self._time_uv_index)
-#         (time_min, time_max) = self.cadence.time_range_at_tstep(tstep,
-#                                                                 remask=remask)
-#
-#         # Apply mask if necessary (because remask above only handles 1-D)
-#         if remask:
-#             is_outside = self.uv_is_outside(uv_pair, inclusive=True)
-#             if np.any(is_outside.vals):
-#                 time_min = time_min.remask_or(is_outside.vals)
-#                 # time_max is shapeless so it can't take a mask
-#
-#         return (time_min, time_max)
-#
-#     #===========================================================================
-#     def uv_range_at_time(self, time, remask=False):
-#         """The (u,v) range of spatial pixels observed at the specified time.
-#
-#         Input:
-#             time        a Scalar of time values in seconds TDB.
-#             remask      True to mask values outside the time limits.
-#
-#         Return:         (uv_min, uv_max)
-#             uv_min      the lower (u,v) corner Pair of the area observed at the
-#                         specified time.
-#             uv_max      the upper (u,v) corner Pair of the area observed at the
-#                         specified time.
-#         """
-#
-#         (tstep_min,
-#          tstep_max) = self.cadence.tstep_range_at_time(time, remask=remask)
-#
-#         i_tdi = self._time_uv_index
-#         j_tdi = 1 - itdi
-#
-#         uv_min_vals = np.zeros(tstep_min.shape + (2,), dtype='int')
-#         uv_min_vals[..., i_tdi] = tstep_min.vals
-#
-#         uv_max_vals = np.empty(tstep_min.shape + (2,), dtype='int')
-#         uv_max_vals[..., i_tdi] = tstep_max.vals
-#         uv_max_vals[..., j_tdi] = self.uv_shape[j_tdi]
-#
-#         uv_min = Pair(uv_min_vals, mask=tstep_min.mask)
-#         uv_max = Pair(uv_max_vals, mask=tstep_min.mask)
-#         return (uv_min, uv_max)
-#
-#     #===========================================================================
-#     def time_shift(self, dtime):
-#         """A copy of the observation object with a time-shift.
-#
-#         Input:
-#             dtime       the time offset to apply to the observation, in units of
-#                         seconds. A positive value shifts the observation later.
-#
-#         Return:         a (shallow) copy of the object with a new time.
-#         """
-#
-#         obs = Pushframe(self.axes, self.cadence.time_shift(dtime),
-#                         self.fov, self.path, self.frame)
-#
-#         for key in self.subfields.keys():
-#             obs.insert_subfield(key, self.subfields[key])
-#
-#         return obs
-#
-#     #===========================================================================
-#     def inventory(self, *args, **kwargs):
-#         """Info about the bodies that appear unobscured inside the FOV. See
-#         Snapshot.inventory() for details.
-#
-#         WARNING: Not properly updated for class PushFrame. Use at your own risk.
-#         This operates by returning every body that would have been inside the
-#         FOV of this observation if it were instead a Snapshot, evaluated at the
-#         given tfrac.
-#         """
-#
-#         return self.snapshot.inventory(*args, **kwargs)
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Pushframe(unittest.TestCase):
-
-    def runTest(self):
+    #===========================================================================
+    def __init__(self, cadence, shape):
+        """Constructor for a ReshapedCadence.
+
+        Input:
+            cadence     the cadence to re-shape.
+            shape       a tuple defining the new shape of the cadence.
+        """
+
+        self.cadence = cadence
+        self.shape = tuple(shape)
+        self._rank = len(self.shape)
+        self._size = int(np.prod(self.shape))
+
+        if self._size != np.prod(self.cadence.shape):
+            raise ValueError('ReshapedCadence size and shape are incompatible')
+
+        if self._rank > 2:
+            raise ValueError('%d-D cadences are not supported' % self._rank)
+
+        self.time = self.cadence.time
+        self.midtime = self.cadence.midtime
+        self.lasttime = self.cadence.lasttime
+        self.is_continuous = self.cadence.is_continuous
+        self.is_unique = self.cadence.is_unique
+        self.min_tstride = self.cadence.min_tstride
+        self.max_tstride = self.cadence.max_tstride
+
+        self._stride = np.cumprod((self.shape + (1,))[::-1])[-2::-1]
+                                                        # trust me, it works!
+
+        self._old_shape = self.cadence.shape
+        self._old_rank = len(self.cadence.shape)
+        self._old_stride = np.cumprod((self._old_shape + (1,))[::-1])[-2::-1]
+
+    def __getstate__(self):
+        return (self.cadence, self.shape)
+
+    def __setstate__(self, state):
+        self.__init__(*state)
+
+    #===========================================================================
+    @staticmethod
+    def _reshape_tstep(tstep, old_shape, old_stride, old_rank,
+                              new_shape, new_stride, new_rank, size,
+                              remask=False, derivs=False, inclusive=True):
+        """Translate a cadence index from old shape to new."""
+
+        # Convert old tstep to integer offset + fraction; remask for now
+        if old_rank == 1:
+            tstep = Scalar.as_scalar(tstep, recursive=derivs)
+            index_1d = tstep.int(old_shape[0], remask=True,
+                                 inclusive=inclusive, clip=True)
+            remainder = tstep - index_1d
+            frac = remainder.clip(0, 1, remask=True)
+            index_1d = index_1d.vals
+        else:
+            tstep = Vector.as_vector(tstep, recursive=derivs)
+            tstep_int = tstep.int(old_shape, remask=True, inclusive=inclusive,
+                                             clip=True)
+            remainder = (tstep - tstep_int).to_scalar(-1)
+            frac = remainder.clip(0, 1, remask=True)
+            index_1d = np.sum(old_stride * tstep_int.vals, axis=-1)
+
+        # If the conversion is to a cadence of rank one, we're done
+        if new_rank == 1:
+            result = index_1d + frac
+            if not remask:
+                result = result.remask(tstep.mask)
+
+            return result
+
+        # Convert the offset to an integer index using the new stride
+        # Trust me, this works
+        new_offset = np.reshape(index_1d, np.shape(index_1d) + (1,))
+        indices = (new_offset // new_stride) % new_shape
+
+        # Convert to float if necessary
+        if tstep.is_float():
+            indices = np.asfarray(indices)
+
+        # Restore fractional part
+        indices[...,-1] += frac.vals
+
+        # Select the new mask
+        if remask:
+            mask = frac.mask
+        else:
+            mask = tstep.mask
+
+        # Convert indices to the proper class
+        if new_rank == 2:
+            class_ = Pair
+        else:                   # not currently supported
+            class_ = Vector
+
+        new_tstep = class_(indices, mask)
+
+        # Restore derivatives if necessary
+        if derivs:
+            for key, deriv in tstep.derivs.items():
+                # Construct the new derivative
+
+                # When a derivative has a numerator, the derivatives are always
+                # required/expected to be zero along every axis except the last.
+
+                shape = new_tstep.shape + new_tstep.numer + deriv.denom
+                new_deriv_vals = np.zeros(shape)
+
+                new_index = ((Ellipsis,) + (new_tstep.nrank-1) * (slice(None),)
+                             + ((-1,) if new_tstep.nrank else ())
+                             + deriv.drank * (slice(None),))
+
+                old_index = ((Ellipsis,) + (deriv.nrank-1) * (slice(None),)
+                             + ((-1,) if deriv.nrank else ())
+                             + deriv.drank * (slice(None),))
+
+                new_deriv_vals[new_index] = deriv.vals[old_index]
+                    # Note that the above works if new_deriv_vals has no shape,
+                    # because indx is an Ellipsis, which is a valid index, and
+                    # because the constructor converts a shapeless array value
+                    # to a scalar.
+
+                # Prepare the new mask
+                if isinstance(deriv.mask, (bool, np.bool_)):
+                    new_deriv_mask = mask
+                elif deriv.mask is tstep.mask:  # it's common for derivs
+                                                # to share the parent's mask
+                    new_deriv_mask = mask
+                else:
+                    new_deriv_mask = deriv.mask.reshape(new_tstep.shape)
+                    new_deriv_mask = Qube.or_(mask, new_deriv_mask)
+
+                # Construct and insert the new derivative
+                new_deriv = class_(new_deriv_vals, new_deriv_mask,
+                                   nrank=new_tstep.nrank, drank=deriv.drank)
+                new_tstep.insert_deriv(key, new_deriv)
+
+        return new_tstep
+
+    #===========================================================================
+    def _old_tstep_from_new(self, tstep, remask=False, derivs=False,
+                                         inclusive=True):
+        """Convert a tstep index for the old cadence to the new."""
+
+        return ReshapedCadence._reshape_tstep(
+                            tstep,
+                            self.shape, self._stride, self._rank,
+                            self._old_shape, self._old_stride, self._old_rank,
+                            self._size,
+                            remask=remask, derivs=derivs, inclusive=inclusive)
+
+    #===========================================================================
+    def _new_tstep_from_old(self, tstep, remask=False, derivs=False,
+                                         inclusive=True):
+        """Convert a tstep index for the new cadence to the old."""
+
+        return ReshapedCadence._reshape_tstep(
+                            tstep,
+                            self._old_shape, self._old_stride, self._old_rank,
+                            self.shape, self._stride, self._rank, self._size,
+                            remask=remask, derivs=derivs, inclusive=inclusive)
+
+    #===========================================================================
+    def time_at_tstep(self, tstep, remask=False, derivs=False, inclusive=True):
+        """The time associated with the given time step.
+
+        This method supports non-integer time step values.
+
+        In multidimensional cadences, indexing beyond the dimensions of the
+        cadence returns the time at the nearest edge of the cadence's shape.
+
+        Input:
+            tstep       a Scalar or Pair of time step index values.
+            remask      True to mask values outside the time limits.
+            derivs      True to include derivatives of tstep in the returned
+                        time.
+            inclusive   True to treat the end time of the cadence as part of the
+                        cadence; False to exclude it.
+
+        Return:         a Scalar of times in seconds TDB.
+        """
+
+        tstep = self._old_tstep_from_new(tstep, remask=remask, derivs=derivs,
+                                                inclusive=inclusive)
+
+        return self.cadence.time_at_tstep(tstep, remask=remask, derivs=derivs,
+                                                 inclusive=inclusive)
+
+    #===========================================================================
+    def time_range_at_tstep(self, tstep, remask=False, inclusive=True):
+        """The range of times for the given time step.
+
+        Input:
+            tstep       a Pair of time step index values.
+            remask      True to mask values outside the time limits.
+            inclusive   True to treat the end time of the cadence as part of the
+                        cadence; False to exclude it.
+
+        Return:         (time_min, time_max)
+            time_min    a Scalar defining the minimum time associated with the
+                        index. It is given in seconds TDB.
+            time_max    a Scalar defining the maximum time value.
+        """
+
+        tstep = self._old_tstep_from_new(tstep, derivs=False, remask=remask,
+                                                inclusive=inclusive)
+
+        return self.cadence.time_range_at_tstep(tstep, remask=remask,
+                                                       inclusive=inclusive)
+
+    #===========================================================================
+    def tstep_at_time(self, time, remask=False, derivs=False, inclusive=True):
+        """Time step for the given time.
+
+        This method returns non-integer time steps.
+
+        Input:
+            time        a Scalar of times in seconds TDB.
+            remask      True to mask time values not sampled within the cadence.
+            derivs      True to include derivatives of time in the returned
+                        tstep.
+            inclusive   True to treat the end time of the cadence as part of the
+                        cadence; False to exclude it.
+
+        Return:         a Scalar or Pair of time step index values.
+        """
+
+        time = Scalar.as_scalar(time, recursive=derivs)
+
+        # Converting to 1-D or continuous cadences, this is fairly easy...
+        if self._rank == 1 or self.is_continuous:
+            tstep = self.cadence.tstep_at_time(time, remask=remask,
+                                               derivs=derivs,
+                                               inclusive=inclusive)
+            tstep = self._new_tstep_from_old(tstep, remask=remask,
+                                             derivs=derivs,
+                                             inclusive=inclusive)
+
+        # Otherwise...
+        else:
+
+            # Remove the time mask and remask, so tstep is masked if and only if
+            # a time is out of range, including in a gap between discontinuous
+            # time steps.
+            tstep = self.cadence.tstep_at_time(time.without_mask(), remask=True,
+                                               derivs=derivs,
+                                               inclusive=inclusive)
+            tstep = self._new_tstep_from_old(tstep, remask=True, derivs=derivs,
+                                             inclusive=inclusive)
+
+            # For masked tsteps that have wrapped forward to the next line,
+            # shift them back to the end of the previous line.
+
+            # Note--this only works correctly for 2-D
+            wrapped = (tstep.mask & (tstep.vals[...,-1] == 0)
+                                  & (tstep.vals[...,-2] >  0))
+            if np.shape(wrapped):
+                tstep.vals[wrapped,-2] -= 1
+                tstep.vals[wrapped,-1] = self.shape[-1]
+            elif wrapped:
+                tstep.vals[-2] -= 1
+                tstep.vals[-1] = self.shape[-1]
+
+            # Now repair the mask
+            if remask:
+                tstep = tstep.remask_or(time.mask)
+            else:
+                tstep = tstep.remask(time.mask)
+
+        # Times beyond the end of a 2-D cadence require special handling
+        if self._rank > 1:
+            above = Qube.is_above(time, self.time[1], inclusive=inclusive)
+            tstep[above] = type(tstep)(self.shape, remask)
+
+        return tstep
+
+    #===========================================================================
+    def tstep_range_at_time(self, time, remask=False, inclusive=True):
+        """Integer range of time steps active at the given time.
+
+        Input:
+            time        a Scalar of times in seconds TDB.
+            remask      True to mask time values not sampled within the cadence.
+            inclusive   True to treat the end time of the cadence as part of the
+                        cadence; False to exclude it.
+
+        Return:         (tstep_min, tstep_max)
+            tstep_min   minimum Scalar or Pair time step index for time range.
+            tstep_max   maximum Scalar or Pair time step index for time range.
+
+        All returned indices will be in the allowed range for the cadence,
+        inclusive, regardless of mask. If the time is not inside the cadence,
+        tstep_max < tstep_min.
+        """
+
+        time = Scalar.as_scalar(time, recursive=False)
+
+        # Mask here; update the mask later if necessary
+        (old_tstep_min,
+         old_tstep_max) = self.cadence.tstep_range_at_time(time, remask=True,
+                                                           inclusive=inclusive)
+
+        if self.shape == self._old_shape:
+            return (old_tstep_min, old_tstep_max)
+
+        # Calculate the number of tsteps in each old range
+        if self._old_rank == 1:
+            count = old_tstep_max.vals - old_tstep_min.vals
+        else:
+            diffs = old_tstep_max.vals - old_tstep_min.vals - 1
+            count = np.sum(self._old_stride * diffs, axis=-1) + 1
+
+        # Get the new minimum tstep
+        new_tstep_min = self._new_tstep_from_old(old_tstep_min, remask=False,
+                                                 derivs=False, inclusive=True)
+
+        # Calculate the tstep offset for each new range
+        if self._rank == 1:
+            new_tstep_max = new_tstep_min + count
+
+        else:
+            index_1d = (np.sum(self._stride * new_tstep_min.vals, axis=-1)
+                        + np.maximum(count-1, 0))
+            max_vals = (index_1d[...,np.newaxis] // self._stride) % self.shape
+            max_vals += 1
+
+            # Handle count == 0, where last axis of range must have size 0
+            mask = (count == 0)
+            if np.shape(mask):
+                max_vals[mask,-1] = new_tstep_min.vals[mask,-1]
+            elif mask:
+                max_vals[-1] = new_tstep_min.vals[-1]
+
+            new_tstep_max = new_tstep_min.clone()
+            new_tstep_max._set_values_(max_vals)
+
+            # Make sure that the new tstep range will be continuous
+            if not self.is_unique and self._rank > 1:
+                multiple_rows = np.any((new_tstep_min.vals[...,:-1] !=
+                                        new_tstep_max.vals[...,:-1] - 1))
+                incomplete_lines = ((new_tstep_min.vals[...,-1] != 0) |
+                                 (new_tstep_max.vals[...,-1] != self.shape[-1]))
+                unmasked = new_tstep_min.antimask
+                problems = multiple_rows & incomplete_lines & unmasked
+                if np.any(problems):
+                    if np.isscalar(problems):
+                        timeval = time.vals
+                        minval = new_tstep_min
+                        maxval = new_tstep_max
+                    else:
+                        timeval = time[problems][0]
+                        minval = new_tstep_min[problems][0]
+                        maxval = new_tstep_max[problems][0]
+
+                    raise ValueError('returned tstep range is discontinuous ' +
+                                     'at %s: %s, %s' % (timeval, minval,
+                                                                 maxval))
+
+        # Make sure that the old tstep range was continuous
+        if not self.is_unique and self._old_rank > 1:
+            multiple_rows = np.any(old_tstep_min.vals[...,:-1] !=
+                                   old_tstep_max.vals[...,:-1] - 1)
+            incomplete_lines = ((old_tstep_min.vals[...,-1] != 0) |
+                                (old_tstep_max.vals[...,-1] != self.shape[-1]))
+            unmasked = old_tstep_min.antimask
+            problems = multiple_rows & incomplete_lines & unmasked
+            if np.any(problems):
+                if np.isscalar(problems):
+                    timeval = time.vals
+                    minval = new_tstep_min
+                    maxval = new_tstep_max
+                else:
+                    timeval = time[problems][0]
+                    minval = old_tstep_min[problems][0]
+                    maxval = old_tstep_max[problems][0]
+
+                raise ValueError('input tstep range is discontinuous at ' +
+                                 '%s: %s, %s' % (timeval, minval, maxval))
+
+        # Restore the original mask if necessary
+        if not remask:
+            new_tstep_min = new_tstep_min.remask(time.mask)
+            new_tstep_max = new_tstep_max.remask(time.mask)
+
+        return (new_tstep_min, new_tstep_max)
+
+    #===========================================================================
+    def time_is_outside(self, time, inclusive=True):
+        """A Boolean mask of times that fall outside the cadence.
+
+        Input:
+            time        a Scalar of times in seconds TDB.
+            inclusive   True to treat the end time of the cadence as part of the
+                        cadence; False to exclude it.
+
+        Return:         a Boolean mask indicating which time values are not
+                        sampled by the cadence.
+        """
+
+        return self.cadence.time_is_outside(time, inclusive=inclusive)
+
+    #===========================================================================
+    def time_shift(self, secs):
+        """Construct a duplicate of this Cadence with all times shifted by given
+        amount.
+
+        Input:
+            secs        the number of seconds to shift the time later.
+        """
+
+        return ReshapedCadence(self.cadence.time_shift(secs), self.shape)
+
+    #===========================================================================
+    def as_continuous(self):
+        """A shallow copy of this cadence, forced to be continuous.
+
+        For Sequence this is accomplished by forcing the exposure times to
+        be equal to the stride for each step.
+        """
 
-        from oops.cadence.tdicadence import TDICadence
-        from oops.fov.flatfov import FlatFOV
+        return ReshapedCadence(self.cadence.as_continuous(), self.shape)
 
-        flatfov = FlatFOV((0.001,0.001), (10,20))
-        cadence = TDICadence(lines=20, tstart=100., tdi_texp=10., tdi_stages=2,
-                             tdi_sign=-1)
-        obs = Pushframe(axes=('u','vt'),
-                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
-
-        indices = Vector([( 0,0),( 0,1),( 0,10),( 0,18),( 0,19),( 0,20),( 0,21),
-                          (10,0),(10,1),(10,10),(10,18),(10,19),(10,20),(10,21)])
-        tstep = indices.to_scalar(1)
-
-        # uvt() with remask == False
-        (uv,time) = obs.uvt(indices)
-
-        self.assertFalse(np.any(uv.mask))
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(uv, Pair.as_pair(indices))
-        self.assertEqual(time, 2*[100,100,100,100,110,120,120])
-
-        # uvt() with remask == True
-        (uv,time) = obs.uvt(indices, remask=True)
-
-        self.assertTrue(np.all(uv.mask == np.array(2*(6*[False]+[True]))))
-        self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time, cadence.time_at_tstep(tstep, remask=True))
-        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
-
-        # uvt_range() with remask == False
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min,
-                         [(0,0),(0,1),(0,10),(0,18),(0,19),(0,19),(0,21),
-                          (9,0),(9,1),(9,10),(9,18),(9,19),(9,19),(9,21)])
-        self.assertEqual(uv_max, uv_min + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
-
-        # uvt_range() with remask == False, new indices
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9))
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min, Pair.as_pair(indices))
-        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
-
-        # uvt_range() with remask == True, new indices
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9),
-                                                             remask=True)
-
-        self.assertTrue(np.all(uv_min.mask == np.array(5*[False] + 9*[True])))
-        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
-        self.assertTrue(np.all(time_min.mask == uv_min.mask))
-        self.assertTrue(np.all(time_max.mask == uv_min.mask))
-
-        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
-        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
-        self.assertEqual(time_min[:2], cadence.time_range_at_tstep(tstep)[0][:2])
-        self.assertEqual(time_max[:2], cadence.time_range_at_tstep(tstep)[1][:2])
-
-        # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
-        tstep = uv.to_scalar(1)
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
-
-        # time_range_at_uv() with remask == True
-        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
-
-        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
-        self.assertEqual(time0[:4], cadence.time_range_at_tstep(tstep)[0][:4])
-        self.assertEqual(time1[:4], cadence.time_range_at_tstep(tstep)[1][:4])
-
-        # Alternative axis order ('ut','v')
-        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
-                             tdi_sign=-1)
-        obs = Pushframe(axes=('ut','v'),
-                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
-
-        indices = Vector([(-1,0),(0,-1),(0,0),(0,20),(9,0),(10,0),(11,0),(11,20)])
-        tstep = indices.to_scalar(0)
-
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv, Pair.as_pair(indices))
-        self.assertEqual(time, cadence.time_at_tstep(tstep))
-
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertEqual(uv_min,
-                         [(-1,0),(0,-1),(0,0),(0,19),(9,0),(9,0),(11,0),(11,19)])
-        self.assertEqual(uv_max, uv_min + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time_max, cadence.time_range_at_tstep(tstep)[1])
-
-        (time0,time1) = obs.time_range_at_uv(indices)
-
-        self.assertEqual(time0, cadence.time_range_at_tstep(tstep)[0])
-        self.assertEqual(time1, cadence.time_range_at_tstep(tstep)[1])
-
-        # Alternative texp for discontinuous indices
-        cadence = TDICadence(lines=10, tstart=100., tdi_texp=10., tdi_stages=10,
-                                       tdi_sign=1)
-        obs = Pushframe(axes=('ut','v'),
-                        cadence=cadence, fov=flatfov, path='SSB', frame='J2000')
-
-        self.assertEqual(obs.time[0], 100.)
-
-        self.assertEqual(obs.uvt((-1,0))[0], (-1,0))
-        self.assertEqual(obs.uvt(( 0,0))[0], ( 0,0))
-        self.assertEqual(obs.uvt(( 5,0))[0], ( 5,0))
-        self.assertEqual(obs.uvt(( 5,5))[0], ( 5,5))
-        self.assertEqual(obs.uvt(( 9,5))[0], ( 9,5))
-        self.assertEqual(obs.uvt((9.5,5))[0],(9.5,5))
-        self.assertEqual(obs.uvt((10,5))[0], (10,5))
-
-        self.assertEqual(obs.uvt((-1,0))[1], 190.)
-        self.assertEqual(obs.uvt(( 0,0))[1], 190.)
-        self.assertEqual(obs.uvt(( 5,0))[1], 140.)
-        self.assertEqual(obs.uvt(( 5,5))[1], 140.)
-        self.assertEqual(obs.uvt(( 9,5))[1], 100.)
-        self.assertEqual(obs.uvt((9.5,5))[1],150.)
-        self.assertEqual(obs.uvt((10,5))[1], 200.)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/rasterscan.py` & `rms_oops-0.0.4/ideas/deprecated/rasterslit.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,30 +1,31 @@
 ################################################################################
-# oops/observation/rasterscan.py: Subclass RasterScan of class Observation
+# oops/observation/rasterslit.py: Subclass RasterSlit of class Observation
 ################################################################################
 
 import numpy as np
 from polymath import Boolean, Pair, Vector
 
 from oops.observation          import Observation
 from oops.observation.snapshot import Snapshot
 from oops.cadence              import Cadence
 from oops.cadence.dualcadence  import DualCadence
 from oops.frame                import Frame
 from oops.path                 import Path
 
 from oops.observation.timedimage import TimedImage
 
-class RasterScan(TimedImage):
-    """A subclass of Observation consisting of a 2-D image generated by sweeping
-    a single sensor within a 2-D field of view.
-
-    The FOV object defines the entire field of view, although each pixel is
-    sampled at a different time step. The sampling time of each pixel is defined
-    by a 2-D cadence.
+class RasterSlit(TimedImage):
+    """A subclass of Observation consisting of a 2-D image in which one
+    dimension is constructed by sweeping a single pixel along a slit, and the
+    second dimension is simulated by rotation of the camera.
+
+    The FOV describes the 1-D slit. This differs from a Slit subclass in
+    that a single sensor is moving to emulate the 1-D slit. It differs from
+    a RasterScan in that the FOV describes a 1-D slit and not a 2-D image.
     """
 
     pass
 
 #     INVENTORY_IMPLEMENTED = True
 #
 #     # Relates these axes to Snapshot axes
@@ -33,36 +34,40 @@
 #         'uslow':  'u',
 #         'vfast':  'v',
 #         'vslow':  'v',
 #     }
 #
 #     #===========================================================================
 #     def __init__(self, axes, cadence, fov, path, frame, **subfields):
-#         """Constructor for a RasterScan observation.
+#         """Constructor for a RasterSlit observation.
 #
 #         Input:
 #             axes        a list or tuple of strings, with one value for each axis
 #                         in the associated data array. A value of 'ufast' or
 #                         'uslow' should appear at the location of the array's
 #                         u-axis; 'vslow' or 'vfast' should appear at the location
 #                         of the array's v-axis. The 'fast' suffix identifies
 #                         which of these is in the fast-scan direction; the 'slow'
 #                         suffix identifies the slow-scan direction.
 #
 #             cadence     a 2-D Cadence object defining the start time and
-#                         duration of each sample. Alternatively, a tuple or
-#                         dictionary providing input arguments to the function
-#                         DualCadence.for_array2d() (excluding the numbers of
-#                         samples and lines, which are defined by the FOV):
-#                           (tstart, texp, [intersample_delay[, interline_delay]])
+#                         duration of each consecutive measurement. Alternatively,
+#                         this input can be a tuple or dictionary providing input
+#                         arguments to the constructor DualCadence.for_array2d()
+#                         (excluding the number of samples, which is defined by
+#                         the FOV):
+#                             (lines, tstart, texp,
+#                                 [intersample_delay [, interline_delay]])
 #
 #             fov         a FOV (field-of-view) object, which describes the field
 #                         of view including any spatial distortion. It maps
 #                         between spatial coordinates (u,v) and instrument
-#                         coordinates (x,y).
+#                         coordinates (x,y). For a RasterSlit object, one of the
+#                         axes of the FOV must have length 1, and the other must
+#                         match the length of the cadence's fast axis.
 #
 #             path        the path waypoint co-located with the instrument.
 #
 #             frame       the wayframe of a coordinate frame fixed to the optics
 #                         of the instrument. This frame should have its Z-axis
 #                         pointing outward near the center of the line of sight,
 #                         with the X-axis pointing rightward and the y-axis
@@ -74,70 +79,82 @@
 #
 #         # Basic properties
 #         self.path = Path.as_waypoint(path)
 #         self.frame = Frame.as_wayframe(frame)
 #
 #         # FOV
 #         self.fov = fov
-#         self.uv_shape = tuple(self.fov.uv_shape.vals)
+#         fov_uv_shape = tuple(self.fov.uv_shape.vals)
 #
 #         # Axes
 #         self.axes = list(axes)
 #         assert (('ufast' in self.axes and 'vslow' in self.axes) or
 #                 ('vfast' in self.axes and 'uslow' in self.axes))
 #
 #         if 'ufast' in self.axes:
 #             self.u_axis = self.axes.index('ufast')
 #             self.v_axis = self.axes.index('vslow')
 #             self._fast_axis = self.u_axis
 #             self._slow_axis = self.v_axis
-#             self._fast_uv_axis = 0
-#             self._slow_uv_axis = 1
+#             self._cross_slit_uv_axis = 1
+#             self._along_slit_uv_axis = 0
 #         else:
 #             self.u_axis = self.axes.index('uslow')
 #             self.v_axis = self.axes.index('vfast')
 #             self._fast_axis = self.v_axis
 #             self._slow_axis = self.u_axis
-#             self._fast_uv_axis = 1
-#             self._slow_uv_axis = 0
+#             self._cross_slit_uv_axis = 0
+#             self._along_slit_uv_axis = 1
 #
 #         self.swap_uv = (self.u_axis > self.v_axis)
-#
 #         self.t_axis = (self._slow_axis, self._fast_axis)
 #
-#         # Shape / Size
-#         self.shape = len(axes) * [0]
-#         self.shape[self.u_axis] = self.uv_shape[0]
-#         self.shape[self.v_axis] = self.uv_shape[1]
-#
 #         # Cadence
-#         samples = self.uv_shape[self._fast_uv_axis]
-#         lines   = self.uv_shape[self._slow_uv_axis]
+#         samples = fov_uv_shape[self._along_slit_uv_axis]
 #
 #         if isinstance(cadence, (tuple,list)):
-#             self.cadence = DualCadence.for_array2d(samples, lines, *cadence)
+#             self.cadence = DualCadence.for_array2d(samples, *cadence)
 #         elif isinstance(cadence, dict):
-#             self.cadence = DualCadence.for_array2d(samples, lines, **cadence)
+#             self.cadence = DualCadence.for_array2d(samples, **cadence)
 #         elif isinstance(cadence, Cadence):
 #             self.cadence = cadence
-#             assert self.cadence.shape == (lines, samples)
+#             assert len(self.cadence.shape) == 2
+#             assert self.cadence.shape[1] == samples
 #         else:
 #             raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
 #
+#         # Shape / Size
+#         lines = self.cadence.shape[0]
+#
+#         uv_shape = [0, 0]
+#         uv_shape[self._cross_slit_uv_axis] = lines
+#         uv_shape[self._along_slit_uv_axis] = samples
+#         self.uv_shape = tuple(uv_shape)
+#
+#         self._cross_slit_len = lines
+#         self._along_slit_len = samples
+#
+#         assert fov_uv_shape[self._cross_slit_uv_axis] == 1
+#         assert fov_uv_shape[self._along_slit_uv_axis] == samples
+#
+#         self.shape = len(axes) * [0]
+#         self.shape[self.u_axis] = self.uv_shape[0]
+#         self.shape[self.v_axis] = self.uv_shape[1]
+#
 #         # Timing
 #         self.time = self.cadence.time
 #         self.midtime = self.cadence.midtime
 #
 #         # Optional subfields
 #         self.subfields = {}
 #         for key in subfields.keys():
 #             self.insert_subfield(key, subfields[key])
 #
 #         # Snapshot class proxy (for inventory)
-#         snapshot_axes = [RasterScan.AXIS_REPLACEMENTS.get(axis, axis)
+#         snapshot_axes = [RasterSlit.AXIS_REPLACEMENTS.get(axis, axis)
 #                          for axis in axes]
 #         snapshot_tstart = self.cadence.time[0]
 #         snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
 #
 #         self.snapshot = Snapshot(snapshot_axes, snapshot_tstart, snapshot_texp,
 #                                  self.fov, self.path, self.frame, **subfields)
 #
@@ -163,24 +180,28 @@
 #             uv          a Pair defining the values of (u,v) within the FOV that
 #                         are associated with the array indices.
 #             time        a Scalar defining the time in seconds TDB associated
 #                         with the array indices.
 #         """
 #
 #         indices = Vector.as_vector(indices, recursive=derivs)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
 #
-#         # Create the time Scalar
+#         # Create time Scalar
 #         tstep = indices.to_pair(self.t_axis)
 #         time = self.cadence.time_at_tstep(tstep, remask=remask)
+#             # tstep is 2-D so this re-masks where either axis is out of range
 #
-#         # Handle masking
-#         if remask:
-#             uv = uv.remask_or(self.fov.uv_is_outside(uv).vals)
-#             time = time.remask(uv.mask)
+#         # Interpret the slit coordinate as u or v
+#         slit_coord = indices.to_scalar(self._fast_axis)
+#
+#         # Create (u,v) Pair
+#         uv_vals = np.empty(indices.shape + (2,))
+#         uv_vals[..., self._along_slit_uv_axis] = slit_coord.vals
+#         uv_vals[..., self._cross_slit_uv_axis] = 0.5
+#         uv = Pair(uv_vals, mask=time.mask)
 #
 #         return (uv, time)
 #
 #     #===========================================================================
 #     def uvt_range(self, indices, remask=False):
 #         """Ranges of (u,v) spatial coordinates and time for integer array
 #         indices.
@@ -196,51 +217,83 @@
 #                         associated the pixel.
 #             time_min    a Scalar defining the minimum time associated with the
 #                         array indices. It is given in seconds TDB.
 #             time_max    a Scalar defining the maximum time value.
 #         """
 #
 #         indices = Vector.as_vector(indices, recursive=False)
-#         uv = indices.to_pair((self.u_axis, self.v_axis))
-#         uv_min = uv.int(self.uv_shape, remask=remask)
 #
+#         # Get the time range
 #         tstep = indices.to_pair(self.t_axis)
+#         tstep_int = tstep.int(top=self.cadence.shape, remask=remask)
+#             # tstep_int is 2-D so this re-masks for either axis out of range
+#
 #         (time_min,
-#          time_max) = self.cadence.time_range_at_tstep(tstep, remask=remask)
+#          time_max) = self.cadence.time_range_at_tstep(tstep_int, remask=False)
 #
-#         if remask:
-#             time_min = time_min.remask_or(uv_min.mask)
-#             time_max = time_max.remask(time_min.mask)
+#         # Interpret the slit coordinate as u or v
+#         slit_coord = indices.to_scalar(self._fast_axis)
+#         slit_int = slit_coord.int(top=self._along_slit_len, remask=False,
+#                                                             inclusive=True)
+#
+#         # Create (u,v) Pair
+#         uv_min_vals = np.zeros(indices.shape + (2,))
+#         uv_min_vals[..., self._along_slit_uv_axis] = slit_int.vals
+#         uv_min = Pair(uv_min_vals, mask=tstep_int.mask)
 #
 #         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
 #
 #     #===========================================================================
+#     def uv_range_at_tstep(self, tstep, remask=False):
+#         """A tuple defining the range of spatial (u,v) pixels active at a
+#         particular time step.
+#
+#         Input:
+#             tstep       a Pair time step index.
+#             remask      True to mask values outside the time interval.
+#
+#         Return:         a tuple (uv_min, uv_max)
+#             uv_min      a Pair defining the minimum values of FOV (u,v)
+#                         coordinates active at this time step.
+#             uv_min      a Pair defining the maximum values of FOV (u,v)
+#                         coordinates active at this time step (exclusive).
+#         """
+#
+#         tstep = Pair.as_pair(tstep)
+#         tstep_int = tstep.int(top=self.cadence.shape, remask=remask)
+#
+#         if self._slow_uv_axis == 0:
+#             uv_min = tstep_int
+#         else:
+#             uv_min = tstep_int.swapxy()
+#
+#         return (uv_min, uv_min + Pair.INT11)
+#
+#     #===========================================================================
 #     def time_range_at_uv(self, uv_pair, remask=False):
 #         """The start and stop times of the specified spatial pixel (u,v).
 #
 #         Input:
 #             uv_pair     a Pair of spatial (u,v) data array coordinates,
 #                         truncated to integers if necessary.
 #             remask      True to mask values outside the field of view.
 #
 #         Return:         a tuple containing Scalars of the start time and stop
 #                         time of each (u,v) pair, as seconds TDB.
 #         """
 #
 #         uv_pair = Pair.as_pair(uv_pair)
-#         uv_pair_int = uv_pair.int(top=self.uv_shape, remask=remask)
-#
-#         tstep = uv_pair.to_pair((self._slow_uv_axis, self._fast_uv_axis))
+#         uv_pair_int = uv_pair.int(shape=self.uv_shape, remask=remask)
 #
-#         if self._slow_uv_axis == 0:
-#             tstep = uv_pair_int
+#         if self._cross_slit_uv_axis == 0:
+#             tstep_int = uv_pair_int
 #         else:
-#             tstep = uv_pair_int.swapxy()
+#             tstep_int = uv_pair_int.swapxy()
 #
-#         return self.cadence.time_range_at_tstep(tstep, remask=False)
+#         return self.cadence.time_range_at_tstep(tstep_int, remask=remask)
 #
 #     #===========================================================================
 #     def uv_range_at_time(self, time, remask=False):
 #         """The (u,v) range of spatial pixels observed at the specified time.
 #
 #         Input:
 #             time        a Scalar of time values in seconds TDB.
@@ -250,166 +303,133 @@
 #             uv_min      the lower (u,v) corner Pair of the area observed at the
 #                         specified time.
 #             uv_max      the upper (u,v) corner Pair of the area observed at the
 #                         specified time.
 #         """
 #
 #         return Observation.uv_range_at_time_2d(self, time,
-#                                                      uv_shape=Pair.INT11,
-#                                                      slow=self._slow_uv_axis,
-#                                                      fast=self._fast_uv_axis,
-#                                                      remask=remask)
+#                                                uv_shape=Pair.INT11,
+#                                                slow=self._cross_slit_uv_axis,
+#                                                fast=self._along_slit_uv_axis,
+#                                                remask=remask)
 #
 #     #===========================================================================
 #     def time_shift(self, dtime):
 #         """A copy of the observation object with a time-shift.
 #
 #         Input:
 #             dtime       the time offset to apply to the observation, in units of
 #                         seconds. A positive value shifts the observation later.
 #
 #         Return:         a (shallow) copy of the object with a new time.
 #         """
 #
-#         return RasterScan(self.axes, self.cadence.time_shift(dtime),
-#                           self.fov, self.path, self.frame, **self.subfields)
+#         obs = RasterSlit(axes=self.axes, cadence=self.cadence.time_shift(dtime),
+#                          fov=self.fov, path=self.path, frame=self.frame)
+#
+#         for key in self.subfields.keys():
+#             obs.insert_subfield(key, self.subfields[key])
+#
+#         return obs
 #
 #     #===========================================================================
 #     def inventory(self, *args, **kwargs):
 #         """Info about the bodies that appear unobscured inside the FOV. See
 #         Snapshot.inventory() for details.
 #
-#         WARNING: Not properly updated for class RasterScan. Use at your own
+#         WARNING: Not properly updated for class RasterSlit. Use at your own
 #         risk. This operates by returning every body that would have been inside
 #         the FOV of this observation if it were instead a Snapshot, evaluated at
 #         the given tfrac.
 #         """
 #
 #         return self.snapshot.inventory(*args, **kwargs)
 
 ################################################################################
 # UNIT TESTS
 ################################################################################
 
 import unittest
 
-class Test_RasterScan(unittest.TestCase):
+class Test_RasterSlit(unittest.TestCase):
 
     def runTest(self):
 
         from oops.cadence.metronome import Metronome
         from oops.cadence.dualcadence import DualCadence
         from oops.fov.flatfov import FlatFOV
 
-        ####################################################
-        # Continuous observation, shape (10,20)
-        # Axes are (fast,slow)
-        ####################################################
-
-        fov = FlatFOV((0.001,0.001), (10,20))
+        fov = FlatFOV((0.001,0.001), (10,1))
         slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
         fast_cadence = Metronome(tstart=0., tstride=1., texp=1., steps=10)
         cadence = DualCadence(slow_cadence, fast_cadence)
-        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                         path='SSB', frame='J2000')
 
-        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(0,21),(10,21)])
+        indices = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
         indices_ = indices.copy()
         indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
         indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
 
         # uvt() with remask == False
         (uv, time) = obs.uvt(indices)
 
         self.assertFalse(np.any(uv.mask))
         self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, [0, 100, 190, 10, 110, 200, 190, 200])
-        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(time, [0, 100, 190, 10, 110, 200, 200])
+        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv.to_scalar(1), 0.5)
 
         # uvt() with remask == True
         (uv, time) = obs.uvt(indices, remask=True)
 
-        self.assertTrue(np.all(uv.mask == np.array(6*[False] + 2*[True])))
+        self.assertTrue(np.all(uv.mask == np.array(6*[False] + [True])))
         self.assertTrue(np.all(time.mask == uv.mask))
         self.assertEqual(time[:6], [0, 100, 190, 10, 110, 200])
-        self.assertEqual(uv[:6], Pair.as_pair(indices)[:6])
-
-        # uvt_range() with remask == False
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min, Pair.as_pair(indices_))
-        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
-        self.assertEqual(time_min, [0, 100, 190,  9, 109, 199, 190, 199])
-        self.assertEqual(time_max, [1, 101, 191, 10, 110, 200, 191, 200])
-
-        # uvt_range() with remask == True
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices, remask=True)
-
-        self.assertEqual(Boolean(uv_min.mask), 6*[False] + 2*[True])
-        self.assertEqual(Boolean(uv_max.mask), 6*[False] + 2*[True])
-        self.assertEqual(Boolean(time_min.mask), 6*[False] + 2*[True])
-        self.assertEqual(Boolean(time_max.mask), 6*[False] + 2*[True])
-
-        self.assertEqual(uv_min[:6], Pair.as_pair(indices_)[:6])
-        self.assertEqual(uv_max[:6], Pair.as_pair(indices_)[:6] + (1,1))
-        self.assertEqual(time_min[:6], [0, 100, 190,  9, 109, 199])
-        self.assertEqual(time_max[:6], time_min[:6] + fast_cadence.texp)
-
-        # uvt() with remask == False, non-integer indices
-        non_ints = indices + (0.2, 0.9)
-        (uv, time) = obs.uvt(non_ints)
-
-        self.assertFalse(np.any(uv.mask))
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, cadence.time_at_tstep(uv.swapxy()))
-        self.assertEqual(uv, Pair.as_pair(non_ints))
+        self.assertEqual(uv[:6].to_scalar(0), indices[:6].to_scalar(0))
+        self.assertEqual(uv[:6].to_scalar(1), 0.5)
 
-        # uvt() with remask == True, non-integer indices
+        # uvt() with remask == True, new indices
         non_ints = indices + (0.2, 0.9)
         (uv, time) = obs.uvt(non_ints, remask=True)
 
-        self.assertEqual(Boolean(uv.mask), 2*[False] + 6*[True])
-        self.assertEqual(Boolean(time.mask), 2*[False] + 6*[True])
-        self.assertEqual(time[:2],
-                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
-                          fast_cadence.tstride * non_ints.to_scalar(0))[:2])
-        self.assertEqual(uv[:2], Pair.as_pair(non_ints)[:2])
+        self.assertTrue(np.all(uv.mask == np.array(2*[False] + 5*[True])))
+        self.assertTrue(np.all(time.mask == uv.mask))
 
-        # uvt_range() with remask == False, non-integer indices
-        non_ints = indices + (0.2, 0.9)
+        # uvt_range() with remask == False
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
 
         self.assertFalse(np.any(uv_min.mask))
         self.assertFalse(np.any(uv_max.mask))
         self.assertFalse(np.any(time_min.mask))
         self.assertFalse(np.any(time_max.mask))
 
-        self.assertEqual(uv_min, Pair.as_pair(indices))
-        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(Pair.as_pair(non_ints).swapxy())[0])
+        self.assertEqual(uv_min.to_scalar(0), indices.to_scalar(0))
+        self.assertEqual(uv_min.to_scalar(1), 0)
+        self.assertEqual(uv_max.to_scalar(0), indices.to_scalar(0) + 1)
+        self.assertEqual(uv_max.to_scalar(1), 1)
+        self.assertEqual(time_min, [0, 100, 190,  9, 109, 199, 199])
         self.assertEqual(time_max, time_min + fast_cadence.texp)
 
-        # uvt_range() with remask == True, non-integer indices
-        non_ints = indices + (0.2, 0.9)
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints, remask=True)
-
-        self.assertEqual(Boolean(uv_min.mask), 2*[False] + 6*[True])
-        self.assertEqual(Boolean(uv_max.mask), 2*[False] + 6*[True])
-        self.assertEqual(Boolean(time_min.mask), 2*[False] + 6*[True])
-        self.assertEqual(Boolean(time_max.mask), 2*[False] + 6*[True])
+        # uvt_range() with remask == True
+        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints,
+                                                             remask=True)
 
-        self.assertEqual(uv_min[:2], Pair.as_pair(indices)[:2])
-        self.assertEqual(uv_max[:2], Pair.as_pair(indices)[:2] + (1,1))
+        self.assertEqual(Boolean(uv_min.mask), 2*[False] + 5*[True])
+        self.assertEqual(Boolean(uv_max.mask), uv_min.mask)
+        self.assertEqual(Boolean(time_min.mask), uv_min.mask)
+        self.assertEqual(Boolean(time_max.mask), uv_min.mask)
+
+        self.assertEqual(uv_min.to_scalar(0)[:2], indices.to_scalar(0)[:2])
+        self.assertEqual(uv_min.to_scalar(1)[:2], 0)
+        self.assertEqual(uv_max.to_scalar(0)[:2], indices.to_scalar(0)[:2] + 1)
+        self.assertEqual(uv_max.to_scalar(1)[:2], 1)
         self.assertEqual(time_min[:2],
-                         (slow_cadence.tstride * non_ints.to_scalar(1).int() +
-                          fast_cadence.tstride * non_ints.to_scalar(0).int())[:2])
+                         (slow_cadence.tstride * indices.to_scalar(1) +
+                          fast_cadence.tstride * indices.to_scalar(0))[:2])
         self.assertEqual(time_max[:2], time_min[:2] + fast_cadence.texp)
 
         # time_range_at_uv() with remask == False
         uv = Pair([(0,0),(0,20),(10,0),(10,20),(10,21)])
 
         (time0, time1) = obs.time_range_at_uv(uv)
 
@@ -420,181 +440,178 @@
         (time0, time1) = obs.time_range_at_uv(uv, remask=True)
 
         self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
         self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
         self.assertEqual(time0[:4], [0, 190, 9, 199])
         self.assertEqual(time1[:4], time0[:4] + fast_cadence.texp)
 
-        ####################################################
-        # Fast cadence is discontinuous
-        # Axes are (slow,fast)
-        # Shape (10,20)
-        # [[0-1, 10-11, 20-21, ..., 190-191],
-        #  [1000-1001, 1010-1011, ..., 1190-1191],
-        #  ...
-        #  [9000-9001, 9010-9011, ..., 9190, 9191]]
-        ####################################################
-
-        fov = FlatFOV((0.001,0.001), (10,20))
-        slow_cadence = Metronome(tstart=0., tstride=1000., texp=1., steps=10)
-        fast_cadence = Metronome(tstart=0., tstride=10., texp=1., steps=20)
+        ####################################
+        # Alternative axis order ('uslow','vfast')
+        ####################################
+
+        fov = FlatFOV((0.001,0.001), (1,20))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
+        fast_cadence = Metronome(tstart=0., tstride=0.5, texp=0.5, steps=20)
         cadence = DualCadence(slow_cadence, fast_cadence)
-        obs = RasterScan(axes=('uslow','vfast'), cadence=cadence, fov=fov,
-                                                 path='SSB', frame='J2000')
+        obs = RasterSlit(axes=('uslow','vfast'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
 
-        indices = Vector([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
+        indices = Pair([(0,0),(0,10),(0,20),(10,0),(10,10),(10,20),(10,21)])
         indices_ = indices.copy()
         indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
         indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
 
         (uv, time) = obs.uvt(indices)
 
-        self.assertFalse(np.any(uv.mask))
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, [0, 100, 191, 9000, 9100, 9191, 9191])
-        self.assertEqual(uv, Pair.as_pair(indices))
+        self.assertEqual(uv.to_scalar(0), 0.5)
+        self.assertEqual(uv.to_scalar(1), indices.to_scalar(1))
+        self.assertEqual(time, [0, 5, 10, 90, 95, 100, 100])
 
         (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
 
-        self.assertEqual(uv_min, Pair.as_pair(indices_))
-        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(uv_min.to_scalar(0), 0)
+        self.assertEqual(uv_min.to_scalar(1), indices_.to_scalar(1))
+        self.assertEqual(uv_max.to_scalar(0), 1)
+        self.assertEqual(uv_max.to_scalar(1), indices_.to_scalar(1) + 1)
+        self.assertEqual(time_min, [0, 5, 9.5, 90, 95, 99.5, 99.5])
         self.assertEqual(time_max, time_min + fast_cadence.texp)
 
-        (time0,time1) = obs.time_range_at_uv(indices)
+        (time0, time1) = obs.time_range_at_uv(indices)
 
-        self.assertEqual(time0, cadence.time_range_at_tstep(indices_)[0])
+        self.assertEqual(time0, time_min)
         self.assertEqual(time1, time0 + fast_cadence.texp)
 
-        ####################################################
-        # Fast cadence is discontinuous
-        # Axes are (fast,slow)
-        # Shape (10,20)
-        ####################################################
-
-        fov = FlatFOV((0.001,0.001), (10,20))
-        slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
-        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
+        ################################################
+        # Alternative texp for discontinuous indices
+        ################################################
+
+        fov = FlatFOV((0.001,0.001), (10,1))
+        slow_cadence = Metronome(tstart=0., tstride=10., texp=8., steps=20)
+        fast_cadence = Metronome(tstart=0., tstride=1., texp=0.5, steps=10)
         cadence = DualCadence(slow_cadence, fast_cadence)
-        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
 
-        self.assertEqual(obs.time[1], 199.8)
+        self.assertEqual(obs.time[1], 199.5)
 
         self.assertEqual(obs.uvt((0,0))[1],  0.)
         self.assertEqual(obs.uvt((5,0))[1],  5.)
         self.assertEqual(obs.uvt((5,5))[1], 55.)
         self.assertEqual(obs.uvt((5.0, 5.5))[1], 55.)
-        self.assertEqual(obs.uvt((5.5, 5.0))[1], 55.4)
+        self.assertEqual(obs.uvt((5.5, 5.0))[1], 55.25)
 
         eps = 1.e-15
         delta = 1.e-13
-        self.assertTrue(abs(obs.uvt((6.     ,0))[1] - 6. ) < delta)
-        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.2) < delta)
-        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.4) < delta)
-        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.6) < delta)
-        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.8) < delta)
-        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.0) < delta)
+        self.assertTrue(abs(obs.uvt((6.     ,0))[1] - 6.000) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.125) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.250) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.375) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.500) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.000) < delta)
+
+        self.assertEqual(obs.uvt((0,0))[0], (0.,0.5))
+        self.assertEqual(obs.uvt((5,0))[0], (5.,0.5))
+        self.assertEqual(obs.uvt((5,5))[0], (5.,0.5))
+
+        self.assertTrue(abs(obs.uvt((6.     ,0))[0] - (6.0,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,0.5)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ))[0] - (1.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((2, 1.25   ))[0] - (2.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((3, 2.5    ))[0] - (3.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((4, 3.75   ))[0] - (4.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5 - eps))[0] - (5.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((5, 5.     ))[0] - (5.,0.5)) < delta)
 
-        self.assertEqual(obs.uvt((0,0))[0], (0.,0.))
-        self.assertEqual(obs.uvt((5,0))[0], (5.,0.))
-        self.assertEqual(obs.uvt((5,5))[0], (5.,5.))
-
-        self.assertTrue(abs(obs.uvt((6.     ,0))[0] - (6.0,0.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.2    ,1))[0] - (6.2,1.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.4    ,2))[0] - (6.4,2.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.6    ,3))[0] - (6.6,3.)) < delta)
-        self.assertTrue(abs(obs.uvt((6.8    ,4))[0] - (6.8,4.)) < delta)
-        self.assertTrue(abs(obs.uvt((7.     ,6))[0] - (7.0,6.)) < delta)
-
-        self.assertTrue(abs(obs.uvt((1, 0      ))[0] - (1.,0.0)) < delta)
-        self.assertTrue(abs(obs.uvt((2, 1.2    ))[0] - (2.,1.2)) < delta)
-        self.assertTrue(abs(obs.uvt((3, 2.5    ))[0] - (3.,2.5)) < delta)
-        self.assertTrue(abs(obs.uvt((4, 3.8    ))[0] - (4.,3.8)) < delta)
-        self.assertTrue(abs(obs.uvt((5, 5.     ))[0] - (5.,5.0)) < delta)
-
-        ############################################################
+        ################################################
         # Alternative tstride for even more discontinuous indices
-        ############################################################
+        ################################################
 
-        fov = FlatFOV((0.001,0.001), (10,20))
+        fov = FlatFOV((0.001,0.001), (10,1))
         slow_cadence = Metronome(tstart=0., tstride=11., texp=10., steps=20)
         fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
         cadence = DualCadence(slow_cadence, fast_cadence)
-        obs = RasterScan(axes=('ufast','vslow'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+        obs = RasterSlit(axes=('ufast','vslow'), cadence=cadence, fov=fov,
+                                                 path='SSB', frame='J2000')
 
         self.assertEqual(obs.time[1], 218.8)
 
         self.assertEqual(obs.uvt((0,0))[1],  0.)
         self.assertEqual(obs.uvt((5,0))[1],  5.)
         self.assertEqual(obs.uvt((5,5))[1], 60.)
         self.assertEqual(obs.uvt((5.0, 5.5))[1], 60.)
         self.assertEqual(obs.uvt((5.5, 5.0))[1], 60.4)
         self.assertEqual(obs.uvt((5.5, 5.5))[1], 60.4)
 
         eps = 1.e-14
         delta = 1.e-13
-        self.assertTrue((obs.uvt((6.     ,0.))[1] - 6.0).abs() < delta)
-        self.assertTrue((obs.uvt((6.25   ,0.))[1] - 6.2).abs() < delta)
-        self.assertTrue((obs.uvt((6.5    ,0.))[1] - 6.4).abs() < delta)
-        self.assertTrue((obs.uvt((6.75   ,0.))[1] - 6.6).abs() < delta)
-        self.assertTrue((obs.uvt((7. -eps,0.))[1] - 6.8).abs() < delta)
-        self.assertTrue((obs.uvt((7.     ,0.))[1] - 7.0).abs() < delta)
-
-        self.assertTrue((obs.uvt((9.      ,0.))[1] -  9.0).abs() < delta)
-        self.assertTrue((obs.uvt((9.25    ,0.))[1] -  9.2).abs() < delta)
-        self.assertTrue((obs.uvt((9.5     ,0.))[1] -  9.4).abs() < delta)
-        self.assertTrue((obs.uvt((9.75    ,0.))[1] -  9.6).abs() < delta)
-        self.assertTrue((obs.uvt((10 - eps,0.))[1] -  9.8).abs() < delta)
-        self.assertTrue((obs.uvt((0.      ,1.))[1] - 11.0).abs() < delta)
-
-        self.assertTrue((obs.uvt((6.00, 0.    ))[1] -  6.0).abs() < delta)
-        self.assertTrue((obs.uvt((6.25, 0.    ))[1] -  6.2).abs() < delta)
-        self.assertTrue((obs.uvt((6.25, 1.    ))[1] - 17.2).abs() < delta)
-        self.assertTrue((obs.uvt((6.25, 2.-eps))[1] - 17.2).abs() < delta)
-        self.assertTrue((obs.uvt((6.25, 2.    ))[1] - 28.2).abs() < delta)
+        self.assertTrue(abs(obs.uvt((6      ,0))[1] - 6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25   ,0))[1] - 6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.5    ,0))[1] - 6.4) < delta)
+        self.assertTrue(abs(obs.uvt((6.75   ,0))[1] - 6.6) < delta)
+        self.assertTrue(abs(obs.uvt((7 - eps,0))[1] - 6.8) < delta)
+        self.assertTrue(abs(obs.uvt((7.     ,0))[1] - 7.0) < delta)
+
+        self.assertTrue(abs(obs.uvt((9       ,0))[1] -  9. ) < delta)
+        self.assertTrue(abs(obs.uvt((9.25    ,0))[1] -  9.2) < delta)
+        self.assertTrue(abs(obs.uvt((9.5     ,0))[1] -  9.4) < delta)
+        self.assertTrue(abs(obs.uvt((9.75    ,0))[1] -  9.6) < delta)
+        self.assertTrue(abs(obs.uvt((10 - eps,0))[1] -  9.8) < delta)
+        self.assertTrue(abs(obs.uvt((0.      ,1))[1] - 11. ) < delta)
+
+        self.assertTrue(abs(obs.uvt((6.00, 0.   ))[1] -  6. ) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 0.   ))[1] -  6.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 1.   ))[1] - 17.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 2-eps))[1] - 17.2) < delta)
+        self.assertTrue(abs(obs.uvt((6.25, 2    ))[1] - 28.2) < delta)
 
         # Test the upper edge
-        pair = (10-eps, 20-eps)
-        self.assertEqual(obs.uvt(pair)[0], pair)
-        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
-
-        pair = (10, 20-eps)
-        self.assertEqual(obs.uvt(pair)[0], pair)
-        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
-
-        pair = (10-eps, 20)
-        self.assertEqual(obs.uvt(pair)[0], pair)
-        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
+        pair = (10-eps, 0)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 0)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10+eps, 0)
+        self.assertTrue(obs.uvt(pair, True)[0].mask)
+
+        pair = (10-eps, 1-eps)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 9.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 1)
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 20.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
 
         pair = (10, 20)
-        self.assertEqual(obs.uvt(pair)[0], pair)
-        self.assertTrue((obs.uvt(pair)[1] - 218.8).abs() < delta)
-
-        self.assertTrue(obs.uvt((10+eps, 20), True)[0].mask)
-        self.assertTrue(obs.uvt((10, 20+eps), True)[0].mask)
-
-        # Try all at once
-        indices = Pair([(10-eps,20-eps), (10,20-eps), (10-eps,20), (10,20),
-                        (10+eps,20), (10,20+eps)])
-        (test_uv, time) = obs.uvt(indices, remask=True)
-
-        self.assertEqual(Boolean(test_uv.mask), 4*[False] + 2*[True])
-        self.assertEqual(test_uv[:4], indices[:4])
-        self.assertTrue(((time[:4] - 218.8).abs() < delta).all())
-        self.assertEqual(Boolean(time.mask), test_uv.mask)
-
-        ############################################################
-        # Alternative texp and axes
-        ############################################################
+        self.assertTrue((obs.uvt(pair, True)[0] - (10, 0.5)).rms() < delta)
+        self.assertTrue((obs.uvt(pair, True)[1] - 218.8).abs() < delta)
+        self.assertFalse(obs.uvt(pair, True)[0].mask)
+
+        pair = (10, 20+eps)
+        self.assertTrue(obs.uvt(pair, True)[0].mask)
+
+        ################################################
+        # Alternative, discontinuous and weird axes
+        ################################################
 
-        fov = FlatFOV((0.001,0.001), (10,20))
+        fov = FlatFOV((0.001,0.001), (10,1))
         slow_cadence = Metronome(tstart=0., tstride=10., texp=10., steps=20)
         fast_cadence = Metronome(tstart=0., tstride=1., texp=0.8, steps=10)
         cadence = DualCadence(slow_cadence, fast_cadence)
-        obs = RasterScan(axes=('a','vslow','b','ufast','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
+        obs = RasterSlit(axes=('a','vslow','b','ufast','c'), cadence=cadence, fov=fov, path='SSB', frame='J2000')
 
         self.assertEqual(obs.time[1], 199.8)
 
         self.assertEqual(obs.uvt((1,0,3,0,4))[1],   0.)
         self.assertEqual(obs.uvt((1,0,3,5,4))[1],   5.)
         self.assertEqual(obs.uvt((1,0,3,5.5,4))[1], 5.4)
 
@@ -603,28 +620,29 @@
         self.assertTrue(abs(obs.uvt((1,0,0,6      ,0))[1] - 6. ) < delta)
         self.assertTrue(abs(obs.uvt((1,0,0,6.25   ,0))[1] - 6.2) < delta)
         self.assertTrue(abs(obs.uvt((1,0,0,6.5    ,0))[1] - 6.4) < delta)
         self.assertTrue(abs(obs.uvt((1,0,0,6.75   ,0))[1] - 6.6) < delta)
         self.assertTrue(abs(obs.uvt((1,0,0,7 - eps,0))[1] - 6.8) < delta)
         self.assertTrue(abs(obs.uvt((1,0,0,7.     ,0))[1] - 7.0) < delta)
 
-        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.,0.))
-        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (5.,0.))
-        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (5.,5.))
-
-        self.assertTrue(abs(obs.uvt((1,0,4,6   ,7))[0] - (6.0,0.)) < delta)
-        self.assertTrue(abs(obs.uvt((1,1,4,6.2 ,7))[0] - (6.2,1.)) < delta)
-        self.assertTrue(abs(obs.uvt((1,2,4,6.4 ,7))[0] - (6.4,2.)) < delta)
-        self.assertTrue(abs(obs.uvt((1,3,4,6.6 ,7))[0] - (6.6,3.)) < delta)
-        self.assertTrue(abs(obs.uvt((1,4,4,6.8 ,7))[0] - (6.8,4.)) < delta)
-        self.assertTrue(abs(obs.uvt((1,6,4,7.  ,7))[0] - (7.0,6.)) < delta)
-
-        self.assertTrue(abs(obs.uvt((1, 0      ,4,1,7))[0] - (1.,0.0)) < delta)
-        self.assertTrue(abs(obs.uvt((1, 1.2    ,4,2,7))[0] - (2.,1.2)) < delta)
-        self.assertTrue(abs(obs.uvt((1, 2.5    ,4,3,7))[0] - (3.,2.5)) < delta)
-        self.assertTrue(abs(obs.uvt((1, 3.7    ,4,4,7))[0] - (4.,3.7)) < delta)
-        self.assertTrue(abs(obs.uvt((1, 5.     ,4,5,7))[0] - (5.,5.0)) < delta)
+        self.assertEqual(obs.uvt((0,0,0,0,0))[0], (0.,0.5))
+        self.assertEqual(obs.uvt((0,0,0,5,0))[0], (5.,0.5))
+        self.assertEqual(obs.uvt((0,5,0,5,0))[0], (5.,0.5))
+
+        self.assertTrue(abs(obs.uvt((1,0,4,6      ,7))[0] - (6.0,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,1,4,6.2    ,7))[0] - (6.2,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,2,4,6.4    ,7))[0] - (6.4,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,3,4,6.6    ,7))[0] - (6.6,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,4,4,6.8    ,7))[0] - (6.8,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1,6,4,7.     ,7))[0] - (7.0,0.5)) < delta)
+
+        self.assertTrue(abs(obs.uvt((1, 0      ,4,1,7))[0] - (1.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 1.25   ,4,2,7))[0] - (2.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 2.5    ,4,3,7))[0] - (3.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 3.75   ,4,4,7))[0] - (4.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5 - eps,4,5,7))[0] - (5.,0.5)) < delta)
+        self.assertTrue(abs(obs.uvt((1, 5.     ,4,5,7))[0] - (5.,0.5)) < delta)
 
 ########################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/rasterslit1d.py` & `rms_oops-0.0.4/oops/hosts/cassini/uvis.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,485 +1,576 @@
-################################################################################
-# oops/observation/rasterslit1d.py: Subclass RasterSlit1D of class Observation
-################################################################################
+##########################################################################################
+# oops/hosts/cassini/uvis.py
+##########################################################################################
 
 import numpy as np
-from polymath import Scalar, Pair
-
-from oops.observation       import Observation
-from oops.cadence           import Cadence
-from oops.cadence.metronome import Metronome
-from oops.frame             import Frame
-from oops.path              import Path
-
-class RasterSlit1D(Observation):
-    """A subclass of Observation consisting of a 1-D observation in which the
-    one dimension is constructed by sweeping a single pixel along a slit.
+import numbers
+import os
 
-    The FOV describes the 1-D slit.
+import julian
+import oops
+import pdsparser
+
+from oops.hosts.cassini import Cassini
+from oops.hosts         import pds3
+
+DEBUG = False       # True to assert that the data array must have null
+                    # values outside the active windows
+
+##########################################################################################
+# Standard class methods
+##########################################################################################
+
+def from_file(filespec, data=True, enclose=False, **parameters):
+    """A general, static method to return one or more Observation subclass
+    objects based on a label for a given Cassini UVIS file.
+
+    Input:
+        filespec        the full path to the PDS label of a UVIS data file.
+        data            True to include the data array.
+        enclose         True to return a single observation, regardless of how many
+                        windows are defined. If multiple windows are used, then the
+                        observation (and the optional data array) are are defined by the
+                        enclosing limits in line and band, and the binning is assumed to
+                        be 1. If False and multiple windows are used, the function returns
+                        a tuple of observations rather than a single observation.
     """
 
-    #===========================================================================
-    def __init__(self, axes, cadence, fov, path, frame, **subfields):
-        """Constructor for a RasterSlit observation.
-
-        Input:
-
-            axes        a list or tuple of strings, with one value for each axis
-                        in the associated data array. A value of 'ut' should
-                        appear at the location of the array's u-axis if any;
-                        'vt' should appear at the location of the array's v-axis
-                        if any. Only one of 'ut' or 'vt' can appear.
-
-            cadence     a 1-D Cadence object defining the start time and
-                        duration of each consecutive measurement. Alternatively,
-                        a tuple or dictionary providing the input arguments to
-                        the constructor Metronome.for_array1d() (except for the
-                        number of steps, which is defined by the FOV):
-                            (tstart, texp, [interstep_delay])
-
-            fov         a FOV (field-of-view) object, which describes the field
-                        of view including any spatial distortion. It maps
-                        between spatial coordinates (u,v) and instrument
-                        coordinates (x,y). For a RasterSlit object, one of the
-                        axes of the FOV must have length 1.
-
-            path        the path waypoint co-located with the instrument.
-
-            frame       the wayframe of a coordinate frame fixed to the optics
-                        of the instrument. This frame should have its Z-axis
-                        pointing outward near the center of the line of sight,
-                        with the X-axis pointing rightward and the y-axis
-                        pointing downward.
+    UVIS.initialize()   # Define everything the first time through; use defaults unless
+                        # initialize() is called explicitly.
 
-            subfields   a dictionary containing all of the optional attributes.
-                        Additional subfields may be included as needed.
-        """
+    # Get the label dictionary and data array dimensions
+    label = pds3.fast_dict(filespec)
 
-        # Basic properties
-        self.path = Path.as_waypoint(path)
-        self.frame = Frame.as_wayframe(frame)
-
-        # FOV
-        self.fov = fov
-        fov_uv_shape = tuple(self.fov.uv_shape.vals)
-
-        # Axes / Shape / Size
-        self.axes = list(axes)
-        count1 = ('ut' in self.axes) + ('vt' in self.axes)
-        count2 = ('t' in self.axes)
-        if (count1, count2) != (1,0):
-            raise ValueError('invalid axes for RasterSlit1D: '
-                             + repr(self.axes))
-
-        self.shape = len(axes) * [0]
-
-        if 'ut' in self.axes:
-            self.u_axis = self.axes.index('ut')
-            self.v_axis = -1
-            self.t_axis = self.u_axis
-            self.shape[self.u_axis] = fov_uv_shape[0]
-            self.uv_shape = (fov_uv_shape[0], 1)
-            self._along_slit_uv_index = 0
-            self._cross_slit_uv_index = 1
-        else:
-            self.u_axis = -1
-            self.v_axis = self.axes.index('vt')
-            self.t_axis = self.v_axis
-            self.shape[self.v_axis] = fov_uv_shape[1]
-            self.uv_shape = (1, fov_uv_shape[1])
-            self._along_slit_uv_index = 1
-            self._cross_slit_uv_index = 0
-
-        self.swap_uv = False
-
-        self._along_slit_len = fov_uv_shape[self._along_slit_uv_index]
-        if fov_uv_shape[self._cross_slit_uv_index] != 1:
-            raise ValueError('RasterSlit1D cross-slit axis must have length 1')
-
-        # Cadence
-        samples = self._along_slit_len
-
-        if isinstance(cadence, (tuple, list)):
-            self.cadence = Metronome.for_array1d(samples, *cadence)
-        elif isinstance(cadence, dict):
-            self.cadence = Metronome.for_array1d(samples, **cadence)
-        elif isinstance(cadence, Cadence):
-            self.cadence = cadence
-            if self.cadence.shape != (samples,):
-                raise ValueError('RasterSlit1D input Cadence and FOV shapes '
-                                 'are incompatible: %s, %s'
-                                 % (cadence.shape, tuple(fov.uv_shape.vals)))
+    # Load any needed SPICE kernels
+    tstart = julian.tdb_from_tai(julian.tai_from_iso(label['START_TIME']))
+    tstop  = julian.tdb_from_tai(julian.tai_from_iso(label['STOP_TIME']))
+    Cassini.load_cks( tstart, tstop)
+    Cassini.load_spks(tstart, tstop)
+
+    # Figure out the PDS object class and return the observation(s)
+    if 'QUBE' in label:
+        return get_qube(filespec, tstart, label, data, enclose)
+    elif 'TIME_SERIES' in label:
+        return get_time_series(filespec, tstart, label, data)
+    else:
+        return get_spectrum(filespec, tstart, label, data)
+
+#=========================================================================================
+def get_qube(filespec, tstart, label, data, enclose):
+    """The observation object given that it is a QUBE."""
+
+    global DEBUG
+
+    # Determine the detector and mode
+    detector = label['PRODUCT_ID'][:3]
+    assert detector in ('EUV', 'FUV')
+
+    resolution = label['SLIT_STATE']
+
+    # Define the instrument frame
+    frame_id = UVIS.frame_ids[detector]
+
+    # Get array shape
+    info = label['QUBE']
+    (bands,lines,samples) = info['CORE_ITEMS']
+    assert lines in (1,64), f'invalid lines = {lines}'
+
+    if lines == 1:
+        shape = (samples, bands)
+    else:
+        shape = (lines, samples, bands)
+
+    # Define the cadence
+    texp = label['INTEGRATION_DURATION']
+    cadence = oops.cadence.Metronome(tstart, texp, texp, samples)
+
+    # Define the full FOV
+    fov = UVIS.fovs[(detector, label['SLIT_STATE'], lines)]
+
+    # Load the data array if necessary
+    info = label['QUBE']
+    assert info['CORE_ITEM_TYPE'] == 'MSB_UNSIGNED_INTEGER'
+    assert info['CORE_ITEM_BYTES'] == 2
+    assert info['SUFFIX_ITEMS'] == [0,0,0]
+
+    if data:
+        array_null = 65535                  # Incorrectly -1 in many labels
+        array = load_data(filespec, label['^QUBE'], '>u2')
+
+        # Re-shape into something sensible
+        # Note that the axis order in the label is first-index-fastest
+        if lines > 1:
+            array = array.reshape((samples,lines,bands))
+            array = array.swapaxes(0,1)
         else:
-            raise TypeError('Invalid cadence class: ' + type(cadence).__name__)
-
-        # Timing
-        self.time = self.cadence.time
-        self.midtime = self.cadence.midtime
-
-        # Optional subfields
-        self.subfields = {}
-        for key in subfields.keys():
-            self.insert_subfield(key, subfields[key])
-
-    def __getstate__(self):
-        return (self.axes, self.cadence, self.fov, self.path, self.frame,
-                self.subfields)
+            array = array.reshape(shape)
+    else:
+        array = None
+
+    # Identify the window(s) used
+    # Note that these are either integers or lists of integers
+    line0 = info['UL_CORNER_LINE']
+    line1 = info['LR_CORNER_LINE']
+    line_bin = info['LINE_BIN']
+
+    band0 = info['UL_CORNER_BAND']
+    band1 = info['LR_CORNER_BAND']
+    band_bin = info['BAND_BIN']
+
+    # Check the outer periphery of the data array in DEBUG mode
+    if DEBUG and data:
+        assert np.all(array[:min(line0),    ...] == array_null)
+        assert np.all(array[ max(line1)+1:, ...] == array_null)
+
+        assert np.all(array[..., :min(band0)   ] == array_null)
+        assert np.all(array[...,  max(band1)+1:] == array_null)
+
+    # One window
+    if isinstance(line0, numbers.Integral):
+        return get_one_qube(label, detector, resolution,
+                            fov, cadence, frame_id,
+                            shape, array, samples,
+                            lines, line0, line1+1, line_bin,
+                            bands, band0, band1+1, band_bin,
+                            rebin=True)
+
+    # Multiple windows combined into one enclosure
+    elif enclose:
+        line0 = min(line0)
+        line1 = max(line1)
+        line_bin = min(line_bin)
+        band0 = min(band0)
+        band1 = max(band1)
+        band_bin = min(band_bin)
+        return get_one_qube(label, detector, resolution,
+                            fov, cadence, frame_id,
+                            shape, array, samples,
+                            lines, line0, line1+1, line_bin,
+                            bands, band0, band1+1, band_bin,
+                            rebin=False)
+
+    # Separate windows
+    else:
+        obslist = []
+        for w in len(line0):
+            obs = get_one_qube(label, detector, resolution,
+                               fov, cadence, frame_id,
+                               shape, array, samples,
+                               lines, line0[w], line1[w]+1, line_bin[w],
+                               bands, band0[w], band1[w]+1, band_bin[w],
+                               rebin=True)
+            obslist.append(obs)
+
+        return tuple(obslist)
+
+#=========================================================================================
+def get_one_qube(label, detector, resolution,
+                 fov, cadence, frame_id,
+                 shape, array, samples,
+                 lines, line0, line1, line_bin,
+                 bands, band0, band1, band_bin,
+                 rebin):
+    """A single Observation object for the identified window of the UVIS qube."""
+
+    global DEBUG
+
+    # Trim the lines
+    dline = line1 - line0
+    if (line0,line1) != (0,lines):
+        fov = oops.fov.SliceFOV(fov, (0,line0), (1,dline))
+        shape = (dline,) + shape[1:]
+
+        if array is not None:
+            array = array[line0:line1, :]
+
+    # Trim the bands
+    dband = band1 - band0
+    if (band0,band1) != (0,bands):
+        shape = shape[:-1] + (dband,)
+
+        if array is not None:
+            array = array[..., band0:band1]
+
+    # Bin the lines
+    if rebin and line_bin > 1:
+        assert dline % line_bin == 0
+        fov = oops.fov.SubsampledFOV(fov, (1,line_bin))
+        dline_binned = dline // line_bin
+        shape = (dline_binned,) + shape[1:]
+
+        if array is not None:
+            if DEBUG:
+                assert np.all(array[dline_binned:, ...] == array_null)
+
+            array = array[:dline_binned]
+
+    # Bin the bands
+    if rebin and band_bin > 1:
+        if DEBUG:
+            assert dband % band_bin == 0    # seen to fail occasionally
+
+        dband_binned = dband // band_bin
+        shape = shape[:-1] + (dband_binned,)
+
+        if array is not None:
+            if DEBUG:
+                assert np.all(array[..., dband_binned:] == array_null)
+
+            array = array[..., :dband_binned]
+
+    # Create the Observation
+    if lines == 1:
+        obs = oops.obs.Pixel(('t','b'), cadence, fov, 'CASSINI', frame_id)
+    else:
+        obs = oops.obs.TimedImage(('v','ut','b'), cadence, fov, 'CASSINI', frame_id)
+
+    obs.insert_subfield('dict', label)
+    obs.insert_subfield('instrument', 'UVIS')
+    obs.insert_subfield('detector', detector)
+    obs.insert_subfield('sampling', resolution)
+    obs.insert_subfield('product_type', 'QUBE')
+
+    obs.insert_subfield('line_window', (line0,line1))
+    obs.insert_subfield('line_bin', line_bin)
+
+    obs.insert_subfield('band_window', (band0,band1))
+    obs.insert_subfield('band_bin', band_bin)
+
+    obs.insert_subfield('samples', samples)
+
+    if array is not None:
+        obs.insert_subfield('data', array)
+
+    # Update the observation shape
+    obs.shape = shape
+
+    return obs
+
+#=========================================================================================
+def get_time_series(filespec, tstart, label, data):
+    """The observation object given that it is a TIME_SERIES."""
+
+    # Determine the detector
+    product_id = label['PRODUCT_ID']
+    if product_id.startswith('HSP'):
+        detector = 'HSP'
+    elif product_id.startswith('HDAC'):
+        detector = 'HDAC'
+    else:
+        raise ValueError('Time series is neither HSP nor HDAC: ' + filespec)
+
+    # Define the instrument frame
+    frame_id = UVIS.frame_ids[detector]
+
+    # Get the array shape
+    info = label['TIME_SERIES']
+    samples = info['ROWS']
+
+    # Define the cadence
+    assert info['COLUMNS'] == 1
+    assert (info['SAMPLING_PARAMETER_UNIT'] == 'MILLISECOND' or
+            info['SAMPLING_PARAMETER_UNIT'] == 'MILLISECONDS')
+    texp = info['SAMPLING_PARAMETER_INTERVAL'] * 0.001
+
+    cadence = oops.cadence.Metronome(tstart, texp, texp, samples)
+
+    # Define the observation
+    fov = UVIS.fovs[(detector, '', 1)]
+    obs = oops.obs.Pixel(('t',), cadence, fov, 'CASSINI', frame_id)
+
+    obs.insert_subfield('dict', label)
+    obs.insert_subfield('instrument', 'UVIS')
+    obs.insert_subfield('detector', detector)
+    obs.insert_subfield('product_type', 'TIME_SERIES')
+
+    obs.insert_subfield('line_window', None)
+    obs.insert_subfield('line_bin', None)
+
+    obs.insert_subfield('band_window', None)
+    obs.insert_subfield('band_bin', None)
+
+    obs.insert_subfield('samples', samples)
+
+    # Load the data array if necessary
+    if data:
+        column = info['PHOTOMETER_COUNTS']
+        assert column['DATA_TYPE'] == 'MSB_UNSIGNED_INTEGER'
+        assert column['BYTES'] == 2
+
+        array = load_data(filespec, label['^TIME_SERIES'], '>u2')
+        obs.insert_subfield('data', array)
+
+    # Update the observation shape
+    obs.shape = (samples,)
+
+    return obs
+
+#=========================================================================================
+def get_spectrum(filespec, tstart, label, data):
+    """The observation object given that it is a SPECTRUM."""
+
+    # Determine the detector
+    detector = label['PRODUCT_ID'][:3]
+    assert detector in ('EUV', 'FUV')
+
+    # Define the instrument frame
+    frame_id = UVIS.frame_ids[detector]
+
+    # Get array shape
+    info = label['SPECTRUM']
+    bands = info['ROWS']
+
+    # Define the cadence (such as it is)
+    assert info['COLUMNS'] == 1
+    texp = label['INTEGRATION_DURATION']
+    cadence = oops.cadence.Metronome(tstart, texp, texp, 1)
+
+    # Define the FOV
+    resolution = label['SLIT_STATE']
+    fov = UVIS.fovs[(detector, resolution, 64)]
+
+    line0 = info['UL_CORNER_SPATIAL']
+    line1 = info['LR_CORNER_SPATIAL'] + 1
+    if (line0,line1) != (0,64):
+        fov = oops.fov.SliceFOV(fov, (0,line0), (1,line1-line0))
+
+    line_bin = info['BIN_SPATIAL']
+    if line_bin != 1:
+        fov = oops.fov.SubsampledFOV(fov, (1,line_bin))
+
+    # Define the observation
+    obs = oops.obs.Pixel(('b',), cadence, fov, 'CASSINI', frame_id)
+
+    obs.insert_subfield('dict', label)
+    obs.insert_subfield('instrument', 'UVIS')
+    obs.insert_subfield('detector', detector)
+    obs.insert_subfield('sampling', resolution)
+    obs.insert_subfield('product_type', 'SPECTRUM')
+
+    obs.insert_subfield('line_window', (line0,line1))
+    obs.insert_subfield('line_bin', line_bin)
+
+    obs.insert_subfield('band_window', (info['UL_CORNER_SPECTRAL'],
+                                        info['LR_CORNER_SPECTRAL']+1))
+    obs.insert_subfield('band_bin', info['BIN_SPECTRAL'])
+
+    obs.insert_subfield('samples', 1)
+
+    # Load the data array if necessary
+    if data:
+        column = info['SPECTRUM']
+        assert column['DATA_TYPE'] == 'MSB_UNSIGNED_INTEGER'
+        assert column['BYTES'] == 2
+
+        array = load_data(filespec, label['^SPECTRUM'], '>u2')
+        obs.insert_subfield('data', array)
+
+    # Update the observation shape
+    obs.shape = (bands,)
+
+    return obs
+
+#=========================================================================================
+def load_data(filespec, body, dtype):
+
+    head = os.path.split(filespec)[0]
+
+    data_filespec = os.path.join(head, body)
+    if not os.path.exists(data_filespec):
+        data_filespec = os.path.join(head, body.lower())
+    if not os.path.exists(data_filespec):
+        f = open(data_filespec,'r')     # raise IOError
+
+    return np.fromfile(data_filespec, sep='', dtype=dtype)
+
+#=========================================================================================
+def initialize(ck='reconstructed', planets=None, asof=None,
+               spk='reconstructed', gapfill=True,
+               mst_pck=True, irregulars=True):
+    """Initialize key information about the VIMS instrument.
+
+    Must be called first. After the first call, later calls to this function are ignored.
+
+    Input:
+        ck,spk      'predicted', 'reconstructed', or 'none', depending on
+                    which kernels are to be used. Defaults are 'reconstructed'.
+                    Use 'none' if the kernels are to be managed manually.
+        planets     A list of planets to pass to define_solar_system. None or
+                    0 means all.
+        asof        Only use SPICE kernels that existed before this date;
+                    None to ignore.
+        gapfill     True to include gapfill CKs. False otherwise.
+        mst_pck     True to include MST PCKs, which update the rotation models
+                    for some of the small moons.
+        irregulars  True to include the irregular satellites;
+                    False otherwise.
+    """
+    UVIS.initialize(ck=ck, planets=planets, asof=asof, spk=spk, gapfill=gapfill,
+                    mst_pck=mst_pck, irregulars=irregulars)
 
-    def __setstate__(self, state):
-        self.__init__(*state[:-1], **state[-1])
+#=========================================================================================
+class UVIS(object):
+    """An instance-free class to hold Cassini UVIS instrument parameters."""
+
+    instrument_kernel = None
+    fovs = {}
+    initialized = False
+
+    # Map NAIF body names (following "CASSINI_UVIS_") to (detector, resolution)
+    abbrevs = {'CASSINI_UVIS_FUV_HI' : ('FUV', 'HIGH_RESOLUTION'),
+               'CASSINI_UVIS_FUV_LO' : ('FUV', 'LOW_RESOLUTION'),
+               'CASSINI_UVIS_FUV_OCC': ('FUV', 'OCCULTATION'),
+               'CASSINI_UVIS_EUV_HI' : ('EUV', 'HIGH_RESOLUTION'),
+               'CASSINI_UVIS_EUV_LO' : ('EUV', 'LOW_RESOLUTION'),
+               'CASSINI_UVIS_EUV_OCC': ('EUV', 'OCCULTATION'),
+               'CASSINI_UVIS_SOLAR'  : ('SOLAR',   ''),
+               'CASSINI_UVIS_SOL_OFF': ('SOL_OFF', ''),
+               'CASSINI_UVIS_HSP'    : ('HSP',     ''),
+               'CASSINI_UVIS_HDAC'   : ('HDAC',    '')}
+
+    # Map detector to NAIF frame ID
+    frame_ids = {'FUV'    : 'CASSINI_UVIS_FUV',
+                 'EUV'    : 'CASSINI_UVIS_EUV',
+                 'SOLAR'  : 'CASSINI_UVIS_SOLAR',
+                 'SOL_OFF': 'CASSINI_UVIS_SOL_OFF',
+                 'HSP'    : 'CASSINI_UVIS_HSP',
+                 'HDAC'   : 'CASSINI_UVIS_HDAC'}
+
+    #=====================================================================================
+    @staticmethod
+    def initialize(ck='reconstructed', planets=None, asof=None, spk='reconstructed',
+                   gapfill=True, mst_pck=True, irregulars=True):
+        """Fill in key information about the UVIS channels.
 
-    #===========================================================================
-    def uvt(self, indices, remask=False, derivs=True):
-        """Coordinates (u,v) and time t for indices into the data array.
-
-        This method supports non-integer index values.
+        Must be called first. After the first call, later calls to this function are
+        ignored.
 
         Input:
-            indices     a Scalar or Vector of array indices.
-            remask      True to mask values outside the field of view.
-            derivs      True to include derivatives in the returned values.
-
-        Return:         (uv, time)
-            uv          a Pair defining the values of (u,v) within the FOV that
-                        are associated with the array indices.
-            time        a Scalar defining the time in seconds TDB associated
-                        with the array indices.
+            ck,spk      'predicted', 'reconstructed', or 'none', depending on which
+                        kernels are to be used. Defaults are 'reconstructed'. Use 'none'
+                        if the kernels are to be managed manually.
+            planets     A list of planets to pass to define_solar_system. None or 0 means
+                        all.
+            asof        Only use SPICE kernels that existed before this date; None to
+                        ignore.
+            gapfill     True to include gapfill CKs. False otherwise.
+            mst_pck     True to include MST PCKs, which update the rotation models for
+                        some of the small moons.
+            irregulars  True to include the irregular satellites; False otherwise.
         """
 
-        # Interpret a 1-D index or a multi-D index
-        slit_coord = Observation.scalar_from_indices(indices, self.t_axis,
-                                                              derivs=derivs)
-
-        # Create time Scalar
-        time = self.cadence.time_at_tstep(slit_coord, remask=remask)
-            # there's only one relevant axis and remask has it covered now
-
-        # Create (u,v) Pair
-        uv_vals = np.empty(slit_coord.shape + (2,))
-        uv_vals[..., self._along_slit_uv_index] = slit_coord.vals
-        uv_vals[..., self._cross_slit_uv_index] = 0.5
-        uv = Pair(uv_vals, mask=time.mask)
-
-        return (uv, time)
-
-    #===========================================================================
-    def uvt_range(self, indices, remask=False):
-        """Ranges of (u,v) spatial coordinates and time for integer array
-        indices.
-
-        Input:
-            indices     a Scalar or Vector of array indices.
-            remask      True to mask values outside the field of view.
-
-        Return:         (uv_min, uv_max, time_min, time_max)
-            uv_min      a Pair defining the minimum values of FOV (u,v)
-                        associated the pixel.
-            uv_max      a Pair defining the maximum values of FOV (u,v)
-                        associated the pixel.
-            time_min    a Scalar defining the minimum time associated with the
-                        array indices. It is given in seconds TDB.
-            time_max    a Scalar defining the maximum time value.
+        # Quick exit after first call
+        if UVIS.initialized:
+            return
+
+        Cassini.initialize(ck=ck, planets=planets, asof=asof, spk=spk, gapfill=gapfill,
+                           mst_pck=mst_pck, irregulars=irregulars)
+        Cassini.load_instruments(asof=asof)
+
+        # Load the instrument kernel
+        UVIS.instrument_kernel = Cassini.spice_instrument_kernel('UVIS')[0]
+
+        # TEMPORARY FIX to a loader problem
+        ins = UVIS.instrument_kernel['INS']
+        ins['CASSINI_UVIS_FUV_HI']  = ins[-82840]
+        ins['CASSINI_UVIS_FUV_LO']  = ins[-82841]
+        ins['CASSINI_UVIS_FUV_OCC'] = ins[-82842]
+        ins['CASSINI_UVIS_EUV_HI']  = ins[-82843]
+        ins['CASSINI_UVIS_EUV_LO']  = ins[-82844]
+        ins['CASSINI_UVIS_EUV_OCC'] = ins[-82845]
+        ins['CASSINI_UVIS_HSP']     = ins[-82846]
+        ins['CASSINI_UVIS_HDAC']    = ins[-82847]
+        ins['CASSINI_UVIS_SOLAR']   = ins[-82848]
+        ins['CASSINI_UVIS_SOL_OFF'] = ins[-82848]
+
+        # Construct a flat FOV and load the frame for each detector
+        for key in UVIS.abbrevs.keys():
+            (detector, resolution) = UVIS.abbrevs[key]
+
+            # Construct the SpiceFrame
+            ignore = oops.frame.SpiceFrame(UVIS.frame_ids[detector])
+
+            # Get the FOV angles
+            info = UVIS.instrument_kernel['INS'][key]
+
+            if info['FOV_SHAPE'] == 'RECTANGLE':
+                u_angle = 2. * info['FOV_CROSS_ANGLE'] * oops.RPD
+                v_angle = 2. * info['FOV_REF_ANGLE'] * oops.RPD
+            elif info['FOV_SHAPE'] == 'CIRCLE':
+                u_angle = 2. * info['FOV_REF_ANGLE'] * oops.RPD
+                v_angle = u_angle
+            else:
+                raise ValueError('Unrecognized FOV_SHAPE: ' + info['FOV_SHAPE'])
+
+            # Define the frame for 1 or 64 lines
+            # Not every combination is really used but that doesn't matter
+            for lines in {1, 64}:
+                fov = oops.fov.FlatFOV((u_angle, v_angle/lines), (1,lines))
+                UVIS.fovs[(detector, resolution, lines)] = fov
+
+        UVIS.initialized = True
+
+    #=====================================================================================
+    @staticmethod
+    def reset():
+        """Resets the internal Cassini UVIS parameters. Can be useful for
+        debugging.
         """
 
-        # Works for a 1-D index or a multi-D index
-        slit_coord = Observation.scalar_from_indices(indices, self.t_axis,
-                                                     derivs=False)
-
-        # Get the time range
-        (time0,
-         time1) = self.cadence.time_range_at_tstep(slit_coord, remask=remask)
-            # there's only one relevant axis and remask has it covered now
-
-        # Create uv_min from the slit index
-        slit_int = slit_coord.int(top=self._along_slit_len, remask=False)
-
-        uv_min_vals = np.zeros(slit_coord.shape + (2,), dtype='int')
-        uv_min_vals[..., self._along_slit_uv_index] = slit_int.vals
-        uv_min = Pair(uv_min_vals, mask=time0.mask)
+        UVIS.instrument_kernel = None
+        UVIS.fovs = {}
+        UVIS.initialized = False
 
-        return (uv_min, uv_min + Pair.INT11, time0, time1)
+        Cassini.reset()
 
-    #===========================================================================
-    def time_range_at_uv(self, uv_pair, remask=False):
-        """The start and stop times of the specified spatial pixel (u,v).
+##########################################################################################
+# UNIT TESTS
+##########################################################################################
+import unittest
+import os.path
+import oops.gold_master as gm
 
-        Input:
-            uv_pair     a Pair of spatial (u,v) data array coordinates,
-                        truncated to integers if necessary.
-            remask      True to mask values outside the field of view.
+from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
 
-        Return:         a tuple containing Scalars of the start time and stop
-                        time of each (u,v) pair, as seconds TDB.
-        """
 
-        # We can't use super.time_range_at_uv_1d because the self.uv_shape is
-        # not the FOV shape, as that routine expects.
-        uv_pair = Pair.as_pair(uv_pair, recursive=False)
-        tstep = uv_pair.to_scalar(self._along_slit_uv_index)
-        return self.cadence.time_range_at_tstep(tstep, remask=remask)
+#===============================================================================
+class Test_Cassini_UVIS_GoldMaster_HSP2014_197_21_29(unittest.TestCase):
 
     #===========================================================================
-    def uv_range_at_time(self, time, remask=False):
-        """The (u,v) range of spatial pixels observed at the specified time.
-
-        Input:
-            time        a Scalar of time values in seconds TDB.
-            remask      True to mask values outside the time limits.
-
-        Return:         (uv_min, uv_max)
-            uv_min      the lower (u,v) corner Pair of the area observed at the
-                        specified time.
-            uv_max      the upper (u,v) corner Pair of the area observed at the
-                        specified time.
+    def runTest(self):
         """
+        **** fails because uvis needs updating ****
 
-        return Observation.uv_range_at_time_1d(self, time,
-                                               uv_shape=Pair.INT11,
-                                               axis=self._along_slit_uv_index,
-                                               remask=remask)
-
-    #===========================================================================
-    def time_shift(self, dtime):
-        """A copy of the observation object with a time-shift.
-
-        Input:
-            dtime       the time offset to apply to the observation, in units of
-                        seconds. A positive value shifts the observation later.
+        HSP2014_197_21_29 Compare w Gold Masters
 
-        Return:         a (shallow) copy of the object with a new time.
+        To preview and regenerate gold masters (from pds-oops/oops/backplane/):
+            python gold_master.py \
+                ~/Dropbox-SETI/OOPS-Resources/test_data/cassini/UVIS/HSP2014_197_21_29.DAT \
+                --module hosts.cassini.uvis \
+                --ring SATURN_MAIN_RINGS \
+                --no-inventory \
+                --preview
+
+            python gold_master.py \
+                ~/Dropbox-SETI/OOPS-Resources/test_data/cassini/UVIS/HSP2014_197_21_29.DAT \
+                --module hosts.cassini.uvis \
+                --ring SATURN_MAIN_RINGS \
+                --no-inventory \
+                --adopt
         """
 
-        obs = RasterSlit1D(axes=self.axes,
-                           cadence=self.cadence.time_shift(dtime),
-                           fov=self.fov, path=self.path, frame=self.frame)
-
-        for key in self.subfields.keys():
-            obs.insert_subfield(key, self.subfields[key])
-
-        return obs
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_RasterSlit1D(unittest.TestCase):
-
-    def runTest(self):
-
-        from oops.cadence.metronome import Metronome
-        from oops.fov.flatfov import FlatFOV
-
-        ############################################
-        # Continuous 2-D observation
-        # First axis = U and T with length 10
-        # Second axis ignored
-        ############################################
-
-        fov = FlatFOV((0.001,0.001), (10,1))
-        cadence = Metronome(tstart=0., tstride=10., texp=10., steps=10)
-        obs = RasterSlit1D(axes=('ut','a'), cadence=cadence,
-                           fov=fov, path='SSB', frame='J2000')
-
-        indices = Pair([(0,0),(10,0),(11,0)])
-        indices_ = indices.copy()   # clipped at top
-        indices_.vals[:,0][indices_.vals[:,0] == 10] -= 1
-
-        # uvt() with remask == False
-        (uv, time) = obs.uvt(indices)
-
-        self.assertFalse(np.any(uv.mask))
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, cadence.time_at_tstep(indices.to_scalar(0)))
-        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
-        self.assertEqual(uv.to_scalar(1), 0.5)
-
-        # uvt() with remask == True
-        (uv, time) = obs.uvt(indices, remask=True)
-
-        self.assertTrue(np.all(uv.mask == np.array(2*[False] + [True])))
-        self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time[:2], cadence.tstride * indices.to_scalar(0)[:2])
-        self.assertEqual(uv[:2].to_scalar(0), indices[:2].to_scalar(0))
-        self.assertEqual(uv[:2].to_scalar(1), 0.5)
-
-        # uvt() with remask == True, new indices
-        non_ints = indices + (0.2,0.9)
-        (uv, time) = obs.uvt(non_ints, remask=True)
-
-        self.assertTrue(np.all(uv.mask == np.array([False] + 2*[True])))
-        self.assertTrue(np.all(time.mask == uv.mask))
-
-        # uvt_range() with remask == False
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(non_ints)
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min.to_scalar(0), indices.to_scalar(0))
-        self.assertEqual(uv_min.to_scalar(1), 0)
-        self.assertEqual(uv_max.to_scalar(0), indices.to_scalar(0) + 1)
-        self.assertEqual(uv_max.to_scalar(1), 1)
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices.to_scalar(0))[0])
-        self.assertEqual(time_max, time_min + 10.)
-
-        # uvt_range() with remask == True
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices,
-                                                             remask=True)
-
-        self.assertTrue(np.all(uv_min.mask == np.array([False, False, True])))
-        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
-        self.assertTrue(np.all(time_min.mask == uv_min.mask))
-        self.assertTrue(np.all(time_max.mask == uv_min.mask))
-
-        self.assertEqual(uv_min.to_scalar(0)[:2], indices_.to_scalar(0)[:2])
-        self.assertEqual(uv_min.to_scalar(1)[:2], 0)
-        self.assertEqual(uv_max.to_scalar(0)[:2], indices_.to_scalar(0)[:2] + 1)
-        self.assertEqual(uv_max.to_scalar(1)[:2], 1)
-        self.assertEqual(time_min[:2], cadence.tstride*indices_.to_scalar(0)[:2])
-        self.assertEqual(time_max[:2], time_min[:2] + cadence.texp)
-
-        self.assertEqual(uv_min[2], Pair.MASKED)
-        self.assertEqual(time_min[2], Scalar.MASKED)
-        self.assertEqual(time_min[2], Scalar.MASKED)
-
-        # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,20),(10,0),(10,20),(11,21)])
-        uv_ = uv.copy()
-        uv_.vals[:,0][uv_.vals[:,0] == 10] -= 1
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-
-        self.assertEqual(time0, cadence.time_range_at_tstep(uv_.to_scalar(0))[0])
-        self.assertEqual(time1, time0 + cadence.texp)
-
-        # time_range_at_uv() with remask == True
-        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
-
-        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
-        self.assertEqual(time0[:4], cadence.tstride * uv_.to_scalar(0)[:4])
-        self.assertEqual(time1[:4], time0[:4] + cadence.texp)
-
-        ############################################################
-        # Alternative axis order ('a', 'vt')
-        # Second axis = V and T with length 10
-        # Discontinuous time sampling [0-8], [10-18], ..., [90-98]
-        # First axis ignored
-        ############################################################
-
-        fov = FlatFOV((0.001,0.001), (1,10))
-        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
-        obs = RasterSlit1D(axes=('a','vt'), cadence=cadence,
-                           fov=fov, path='SSB', frame='J2000')
-
-        indices = Pair([(0,0),(0,9),(0,10),(0,11)])
-        indices_ = indices.copy()   # clipped at top
-        indices_.vals[:,1][indices_.vals[:,1] == 10] -= 1
-
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv.to_scalar(0), 0.5)
-        self.assertEqual(uv.to_scalar(1), indices.to_scalar(1))
-        self.assertEqual(time, [0,90,98,98])
-
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertEqual(uv_min.to_scalar(0), 0)
-        self.assertEqual(uv_min.to_scalar(1), indices_.to_scalar(1))
-        self.assertEqual(uv_max.to_scalar(0), 1)
-        self.assertEqual(uv_max.to_scalar(1), indices_.to_scalar(1) + 1)
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_.to_scalar(1))[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
-
-        uv = Pair([(11,0),(11,9),(11,10),(11,11)])
-        uv_ = uv.copy()
-        uv_.vals[:,1][uv_.vals[:,1] == 10] -= 1
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-
-        self.assertEqual(time0, cadence.time_range_at_tstep(uv_.to_scalar(1))[0])
-        self.assertEqual(time1, time0 + cadence.texp)
-
-        ############################################################
-        # Similar to above but 1-D observation
-        # First axis = V and T with length 10
-        # Discontinuous time sampling [0-8], [10-18], ..., [90-98]
-        ############################################################
-
-        fov = FlatFOV((0.001,0.001), (1,10))
-        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
-        obs = RasterSlit1D(axes=('vt',), cadence=cadence,
-                           fov=fov, path='SSB', frame='J2000')
-
-        indices = Scalar([0,9,10,11])
-        indices_ = indices.copy()   # clipped at top
-        indices_.vals[indices_.vals == 10] -= 1
-
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv.to_scalar(0), 0.5)
-        self.assertEqual(uv.to_scalar(1), indices)
-        self.assertEqual(time, [0,90,98,98])
-
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertEqual(uv_min.to_scalar(0), 0)
-        self.assertEqual(uv_min.to_scalar(1), indices_)
-        self.assertEqual(uv_max.to_scalar(0), 1)
-        self.assertEqual(uv_max.to_scalar(1), indices_ + 1)
-        self.assertEqual(time_min, cadence.time_range_at_tstep(indices_)[0])
-        self.assertEqual(time_max, time_min + cadence.texp)
-
-        uv = Pair([(11,0),(11,9),(11,10),(11,11)])
-        uv_ = uv.copy()
-        uv_.vals[:,1][uv_.vals[:,1] == 10] -= 1
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-
-        self.assertEqual(time0, cadence.time_range_at_tstep(uv_.to_scalar(1))[0])
-        self.assertEqual(time1, time0 + cadence.texp)
-
-        ############################################################
-        # Alternative axis order ('ut',), 1-D
-        # First axis = U and T with length 10
-        # Discontinuous time sampling [0-8], [10-18], ..., [90-98]
-        ############################################################
-
-        fov = FlatFOV((0.001,0.001), (10,1))
-        cadence = Metronome(tstart=0., tstride=10., texp=8., steps=10)
-        obs = RasterSlit1D(axes=('ut',), cadence=cadence,
-                           fov=fov, path='SSB', frame='J2000')
-
-        self.assertEqual(obs.time[1], 98.)
-
-        self.assertEqual(obs.uvt(0,True)[1],    0.)
-        self.assertEqual(obs.uvt(5,True)[1],   50.)
-        self.assertEqual(obs.uvt(5.5,True)[1], 54.)
-        self.assertEqual(obs.uvt(9.5,True)[1], 94.)
-        self.assertEqual(obs.uvt(10.,True)[1], 98.)
-        self.assertTrue(obs.uvt(10.001,True)[1].mask)
-
-        eps = 1.e-14
-        delta = 1.e-13
-        self.assertTrue(abs(obs.uvt((6.     ),True)[0] - (6.0,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((6.2    ),True)[0] - (6.2,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((6.4    ),True)[0] - (6.4,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((6.6    ),True)[0] - (6.6,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((6.8    ),True)[0] - (6.8,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((7.     ),True)[0] - (7.0,0.5)) < delta)
-        self.assertTrue(abs(obs.uvt((10     ),True)[0] - (10.,0.5)) < delta)
-        self.assertTrue(obs.uvt(10.+eps,True)[0].mask)
-
-        indices = Scalar([10-eps, 10, 10+eps])
+        gm.execute_as_unittest(self,
+                obspath = os.path.join(TESTDATA_PARENT_DIRECTORY,
+                                       'cassini/UVIS/HSP2014_197_21_29.DAT'),
+                index   = None,
+                module  = 'oops.hosts.cassini.uvis',
+                planet  = '',
+                moon    = '',
+                ring    = 'SATURN_MAIN_RINGS',
+                inventory=False, border=10)
 
-        (uv,t) = obs.uvt(indices, remask=True)
-        self.assertTrue(np.all(t.mask == np.array(2*[False] + [True])))
 
-########################################
+############################################
 if __name__ == '__main__':
     unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/slit1d.py` & `rms_oops-0.0.4/oops/observation/timedimage.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,44 +1,53 @@
 ################################################################################
-# oops/observation/slit1d.py: Subclass Slit1D of class Observation
+# oops/observation/timedimage.py: Subclass TimedImage of class Observation
 ################################################################################
 
 import numpy as np
-from polymath import Scalar, Pair, Vector
 
+from polymath                  import Pair, Vector, Qube
 from oops.observation          import Observation
-from oops.cadence.metronome    import Metronome
+from oops.observation.snapshot import Snapshot
 from oops.frame                import Frame
 from oops.path                 import Path
 
-class Slit1D(Observation):
-    """A subclass of Observation consisting of a 1-D slit measurement with no
-    time-dependence. However, it may still have additional axes (e.g., bands).
+class TimedImage(Observation):
+    """An image in which the individual pixels have distinct timing.
+
+    Pixel timing is defined by a 1-D or 2-D cadence.
     """
 
+    # NOTE:
+    # This class now encompasses the earlier subclasses Pushbroom, Pushframe,
+    # RasterScan, RasterSlit, and Slit. (In other words, every observation
+    # subclass with two spatial dimensions except Snapshot.)
+
+    INVENTORY_IMPLEMENTED = True
+
     #===========================================================================
-    def __init__(self, axes, tstart, texp, fov, path, frame, **subfields):
-        """Constructor for a Slit1D observation.
+    def __init__(self, axes, cadence, fov, path, frame, **subfields):
+        """Constructor for a Pushframe.
 
         Input:
             axes        a list or tuple of strings, with one value for each axis
-                        in the associated data array. A value of 'u' should
-                        appear at the location of the array's u-axis if any;
-                        'v' should appear at the location of the array's v-axis
-                        if any. Only one of 'u' or 'v' can appear in a Slit1D.
+                        in the associated data array. One of these strings must
+                        begin with "u", and the other must begin with "v", to
+                        indicate the locations of the spatial axes. If the image
+                        has a 1-D cadence, then "t" should be appended to the
+                        name of the axis containing time dependence. If both
+                        axes have time dependence, one should have the suffix
+                        "fast" and the other should have suffix "slow".
 
-            tstart      the start time of the observation in seconds TDB.
-
-            texp        exposure duration of the observation in seconds.
+            cadence     a 1-D or 2-D Cadence object defining the start and stop
+                        time of each pixel.
 
             fov         a FOV (field-of-view) object, which describes the field
-                        of view including any spatial distortion. It maps
-                        between spatial coordinates (u,v) and instrument
-                        coordinates (x,y). For a Slit1D object, one of the axes
-                        of the FOV must have length 1.
+                        of view including any spatial distortion and possible
+                        time-dependence. It maps between spatial coordinates
+                        (u,v) and instrument coordinates (x,y).
 
             path        the path waypoint co-located with the instrument.
 
             frame       the wayframe of a coordinate frame fixed to the optics
                         of the instrument. This frame should have its Z-axis
                         pointing outward near the center of the line of sight,
                         with the X-axis pointing rightward and the y-axis
@@ -48,71 +57,137 @@
                         Additional subfields may be included as needed.
         """
 
         # Basic properties
         self.path = Path.as_waypoint(path)
         self.frame = Frame.as_wayframe(frame)
 
-        # FOV
+        # Static FOV
         self.fov = fov
-        self.uv_shape = tuple(self.fov.uv_shape.vals)
-
-        # Axes / Shape / Size
-        self.axes = list(axes)
-        if ('u' in self.axes) == ('v' in self.axes):
-            raise ValueError('axes are incompatible with Slit1D: '
-                             + repr(tuple(axes)))
-
-        self.shape = len(axes) * [0]
-
-        if 'u' in self.axes:
-            self.u_axis = self.axes.index('u')
-            self.v_axis = -1
-            self.shape[self.u_axis] = self.uv_shape[0]
-            self._along_slit_index = self.u_axis
-            self._along_slit_uv_axis = 0
-            self._cross_slit_uv_axis = 1
-            self._along_slit_len = self.shape[self.u_axis]
+        self.fov_shape = tuple(self.fov.uv_shape.vals)
+        self._has_unit_fov_axis = (self.fov_shape[0] == 1 or
+                                   self.fov_shape[1] == 1)
+
+        # Axes
+        self.axes = tuple(axes)
+
+        u_axes = [k for k in range(len(self.axes))
+                  if self.axes[k].startswith('u')]
+        v_axes = [k for k in range(len(self.axes))
+                  if self.axes[k].startswith('v')]
+        if len(u_axes) != 1 or len(v_axes) != 1:
+            raise ValueError('invalid axis labels for TimedImage: %s'
+                             % str(self.axes))
+
+        self.u_axis = u_axes[0]
+        self.v_axis = v_axes[0]
+
+        u_suffix = self.axes[self.u_axis][1:]
+        v_suffix = self.axes[self.v_axis][1:]
+
+        if u_suffix == 't' and v_suffix == '':
+            self.t_axis = self.u_axis
+            self._t_uv_axis = 0
+        elif u_suffix == '' and v_suffix == 't':
+            self.t_axis = self.v_axis
+            self._t_uv_axis = 1
+        elif u_suffix == 'fast' and v_suffix == 'slow':
+            self.t_axis = (self.v_axis, self.u_axis)
+            self._fast_t_uv_axis = 0
+        elif u_suffix == 'slow' and v_suffix == 'fast':
+            self.t_axis = (self.u_axis, self.v_axis)
+            self._fast_t_uv_axis = 1
         else:
-            self.u_axis = -1
-            self.v_axis = self.axes.index('v')
-            self.shape[self.v_axis] = self.uv_shape[1]
-            self._along_slit_index = self.v_axis
-            self._along_slit_uv_axis = 1
-            self._cross_slit_uv_axis = 0
-            self._along_slit_len = self.shape[self.v_axis]
-
-        self.swap_uv = False
-
-        if self.uv_shape[self._cross_slit_uv_axis] != 1:
-            raise ValueError('Slit1D cross-slit FOV axis must have length 1')
+            raise ValueError('invalid axis labels for TimedImage: "%s", "%s"'
+                             % (self.axes[self.u_axis], self.axes[self.v_axis]))
 
-        self.t_axis = -1
+        self.swap_uv = (self.u_axis > self.v_axis)
+        self._time_is_1d = not isinstance(self.t_axis, tuple)
 
         # Cadence
-        self.cadence = Metronome.for_array0d(tstart, texp)
+        self.cadence = cadence
+        if self._time_is_1d:
+            if len(self.cadence.shape) != 1:
+                raise ValueError('TimedImage axes requires 1-D cadence')
+        else:
+            if len(self.cadence.shape) != 2:
+                raise ValueError('TimedImage axes requires 2-D cadence')
 
         # Timing
-        self.tstart = self.cadence.tstart
-        self.texp = self.cadence.texp
-
         self.time = self.cadence.time
         self.midtime = self.cadence.midtime
 
-        self._scalar_time = (Scalar(self.time[0]), Scalar(self.time[1]))
-        self._scalar_midtime = Scalar(self.midtime)
+        # Shape / Size
+        self.shape = len(axes) * [0]
+        self.shape[self.u_axis] = self.fov_shape[0]
+        self.shape[self.v_axis] = self.fov_shape[1]
+
+        # This is the (u,v) shape of the observation, not necessarily that of
+        # the FOV.
+        self.uv_shape = [self.fov_shape[0], self.fov_shape[1]]
+
+        # Cadence overrides the shape as defined by the FOV
+        # However, the inventory method will require serious modification for
+        # observations in which the cadence defines one dimension, not the FOV.
+        if self._time_is_1d:
+            t_size = self.cadence.shape[0]
+            if t_size < self.shape[self.t_axis]:
+                raise ValueError('TimedImage FOV and cadence have incompatible '
+                                 + 'shapes')
+            self._extended_fov = (t_size > self.shape[self.t_axis])
+            self.shape[self.t_axis] = t_size
+            self.uv_shape[self._t_uv_axis] = t_size
+        else:
+            if self.shape[self.t_axis[0]] not in (self.cadence.shape[0], 1):
+                raise ValueError('TimedImage FOV and cadence have incompatible '
+                                 + 'shapes')
+            t_size = self.cadence.shape[1]
+            if t_size < self.shape[self.t_axis[1]]:
+                raise ValueError('TimedImage FOV and cadence have incompatible '
+                                 + 'shapes')
+            self._extended_fov = (t_size > self.shape[self.t_axis[1]])
+            self.shape[self.t_axis[1]] = t_size
+            self.uv_shape[self._fast_t_uv_axis] = t_size
+
+        # Let the user override the shape (to replace zeros if desired)
+        self.shape = tuple(self.shape)
+        if 'shape' in subfields:
+            self.shape = tuple(subfields['shape'])
+            del subfields['shape']
+
+        self.INVENTORY_IMPLEMENTED = not self._extended_fov
 
         # Optional subfields
         self.subfields = {}
         for key in subfields.keys():
             self.insert_subfield(key, subfields[key])
 
+        # TODO: implement inventory and related methods for an extended FOV.
+
+        if self._extended_fov:
+            self.snapshot = None
+        else:
+            snapshot_axes = list(self.axes)     # a copy
+            snapshot_axes[self.u_axis] = 'u'
+            snapshot_axes[self.v_axis] = 'v'
+            snapshot_tstart = self.cadence.time[0]
+            snapshot_texp = self.cadence.time[1] - self.cadence.time[0]
+
+            if 'texp' in subfields:             # this creates a conflict
+                subfields = subfields.copy()
+                subfields['texp_'] = subfields['texp']
+                del subfields['texp']
+
+            self.snapshot = Snapshot(snapshot_axes, snapshot_tstart,
+                                     snapshot_texp, self.fov,
+                                     self.path, self.frame, **subfields)
+
     def __getstate__(self):
-        return (self.axes, self.tstart, self.texp, self.fov, self.path,
-                self.frame, self.subfields)
+        return (self.axes, self.cadence, self.fov, self.path, self.frame,
+                self.subfields)
 
     def __setstate__(self, state):
         self.__init__(*state[:-1], **state[-1])
 
     #===========================================================================
     def uvt(self, indices, remask=False, derivs=True):
         """Coordinates (u,v) and time t for indices into the data array.
@@ -127,37 +202,50 @@
         Return:         (uv, time)
             uv          a Pair defining the values of (u,v) within the FOV that
                         are associated with the array indices.
             time        a Scalar defining the time in seconds TDB associated
                         with the array indices.
         """
 
-        # Interpret a 1-D index or a multi-D index
-        slit_coord = Observation.scalar_from_indices(indices,
-                                                     self._along_slit_index,
-                                                     derivs=derivs)
-        slit_coord = self.scalar_from_indices(indices, self._along_slit_index)
+        indices = Vector.as_vector(indices, recursive=derivs)
+        uv = indices.to_pair((self.u_axis, self.v_axis))
 
+        # If an FOV axis has unit length, we always land at 0.5
+        if self._has_unit_fov_axis:
+            if uv.is_float():
+                uv = uv.copy()
+            else:
+                uv = uv.as_float()
+
+            if self.fov_shape[0] == 1:
+                uv.vals[..., 0] = 0.5
+            if self.fov_shape[1] == 1:
+                uv.vals[..., 1] = 0.5
+
+        new_mask = False
+        if self._time_is_1d:
+            tstep = indices.to_scalar(self.t_axis)
+
+            # Re-mask the time-independent axis if necessary
+            if remask:
+                not_t_vals = uv.vals[..., 1 - self._t_uv_axis]
+                not_t_max = self.uv_shape[1 - self._t_uv_axis]
+                new_mask = (not_t_vals < 0) | (not_t_vals > not_t_max)
+                if not np.any(new_mask):
+                    new_mask = False
+        else:
+            tstep = indices.to_pair(self.t_axis)
+
+        time = self.cadence.time_at_tstep(tstep, remask=remask, derivs=derivs)
+
+        # Merge masks if necessary
         if remask:
-            is_outside = ((slit_coord.vals < 0) |
-                          (slit_coord.vals > self._along_slit_len))
-            slit_coord = slit_coord.remask_or(is_outside)
-
-        # Create the (u,v) Pair
-        uv_vals = np.empty(slit_coord.shape + (2,))
-        uv_vals[..., self._along_slit_uv_axis] = slit_coord.vals
-        uv_vals[..., self._cross_slit_uv_axis] = 0.5
-        uv = Pair(uv_vals, mask=slit_coord.mask)
-
-        # Create time Scalar; shapeless is OK unless there's a mask
-        time = self._scalar_midtime
-
-        # Apply mask to time if necessary
-        if remask and np.any(slit_coord.mask):
-            time = Scalar.filled(uv.shape, self.midtime, mask=slit_coord.mask)
+            new_mask = Qube.or_(new_mask, time.mask)
+            uv = uv.remask(new_mask)
+            time = time.remask(new_mask)
 
         return (uv, time)
 
     #===========================================================================
     def uvt_range(self, indices, remask=False):
         """Ranges of (u,v) spatial coordinates and time for integer array
         indices.
@@ -172,49 +260,72 @@
             uv_max      a Pair defining the maximum values of FOV (u,v)
                         associated the pixel.
             time_min    a Scalar defining the minimum time associated with the
                         array indices. It is given in seconds TDB.
             time_max    a Scalar defining the maximum time value.
         """
 
-        # Interpret a 1-D index or a multi-D index
-        slit_coord = Observation.scalar_from_indices(indices,
-                                                     self._along_slit_index)
-
-        slit_int = slit_coord.int(top=self._along_slit_len, remask=remask)
-
-        # Create the (u,v) Pair
-        uv_min_vals = np.zeros(slit_coord.shape + (2,), dtype='int')
-        uv_min_vals[..., self._along_slit_uv_axis] = slit_int.vals
-        uv_min = Pair(uv_min_vals, slit_int.mask)
-
-        # Time
-        time_min = Scalar.filled(uv_min.shape, self.time[0], mask=uv_min.mask)
-        time_max = Scalar.filled(uv_min.shape, self.time[1], mask=uv_min.mask)
+        indices = Vector.as_vector(indices, recursive=False)
+        uv = indices.to_pair((self.u_axis, self.v_axis))
+        uv_min = uv.int(top=self.uv_shape, remask=remask)
+
+        # If an FOV axis has unit length, we always land at range (0,1)
+        if self._has_unit_fov_axis:
+            uv_min = uv_min.copy()
+            if self.fov_shape[0] == 1:
+                uv_min.vals[..., 0] = 0
+            if self.fov_shape[1] == 1:
+                uv_min.vals[..., 1] = 0
+
+        new_mask = False
+        if self._time_is_1d:
+            tstep = indices.to_scalar(self.t_axis)
+
+            # Re-mask the time-independent axis if necessary
+            if remask:
+                not_t_vals = uv.vals[..., 1 - self._t_uv_axis]
+                not_t_max = self.uv_shape[1 - self._t_uv_axis]
+                new_mask = (not_t_vals < 0) | (not_t_vals > not_t_max)
+        else:
+            tstep = indices.to_pair(self.t_axis)
+
+        (time_min,
+         time_max) = self.cadence.time_range_at_tstep(tstep, remask=remask)
+
+        # Merge masks if necessary
+        if remask:
+            if np.any(new_mask):
+                new_mask = Qube.or_(new_mask, time_min.mask)
+                uv_min = uv_min.remask(new_mask)
+                time_min = time_min.remask(new_mask)
+                time_max = time_max.remask(new_mask)
+            else:
+                uv_min = uv_min.remask(time_min.mask)
 
         return (uv_min, uv_min + Pair.INT11, time_min, time_max)
 
     #===========================================================================
     def time_range_at_uv(self, uv_pair, remask=False):
         """The start and stop times of the specified spatial pixel (u,v).
 
-        For a 1-D slit, the index along the cross-slit axis is generally
-        ignored, although values outside the range 0-1 will be masked if remask
-        == True.
-
         Input:
             uv_pair     a Pair of spatial (u,v) data array coordinates,
                         truncated to integers if necessary.
             remask      True to mask values outside the field of view.
 
         Return:         a tuple containing Scalars of the start time and stop
                         time of each (u,v) pair, as seconds TDB.
         """
 
-        return self.time_range_at_uv_0d(uv_pair, remask=remask)
+        if self._time_is_1d:
+            return self.time_range_at_uv_1d(uv_pair, axis=self._t_uv_axis,
+                                                     remask=remask)
+        else:
+            return self.time_range_at_uv_2d(uv_pair, fast=self._fast_t_uv_axis,
+                                                     remask=remask)
 
     #===========================================================================
     def uv_range_at_time(self, time, remask=False):
         """The (u,v) range of spatial pixels observed at the specified time.
 
         Input:
             time        a Scalar of time values in seconds TDB.
@@ -223,146 +334,50 @@
         Return:         (uv_min, uv_max)
             uv_min      the lower (u,v) corner Pair of the area observed at the
                         specified time.
             uv_max      the upper (u,v) corner Pair of the area observed at the
                         specified time.
         """
 
-        return Observation.uv_range_at_time_0d(self, time,
-                                               uv_shape=self.fov.uv_shape,
-                                               remask=remask)
+        if self._time_is_1d:
+            return self.uv_range_at_time_1d(time, shape=self.uv_shape,
+                                                  axis=self._t_uv_axis,
+                                                  remask=remask)
+        else:
+            return self.uv_range_at_time_2d(time, shape=self.uv_shape,
+                                                  slow=(1-self._fast_t_uv_axis),
+                                                  fast=self._fast_t_uv_axis,
+                                                  remask=remask)
 
     #===========================================================================
     def time_shift(self, dtime):
         """A copy of the observation object with a time-shift.
 
         Input:
             dtime       the time offset to apply to the observation, in units of
                         seconds. A positive value shifts the observation later.
 
         Return:         a (shallow) copy of the object with a new time.
         """
 
-        obs = Slit1D(axes=self.axes, tstart=self.tstart + dtime, texp=self.texp,
-                     fov=self.fov, path=self.path, frame=self.frame)
-
-        for key in self.subfields.keys():
-            obs.insert_subfield(key, self.subfields[key])
-
-        return obs
+        return TimedImage(self.axes, self.cadence.time_shift(dtime),
+                          self.fov, self.path, self.frame, **self.subfields)
 
-################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Slit1D(unittest.TestCase):
+    #===========================================================================
+    def inventory(self, *args, **kwargs):
+        """Info about the bodies that appear unobscured inside the FOV. See
+        Snapshot.inventory() for details.
+
+        WARNING: Not properly updated for class PushFrame. Use at your own risk.
+        This operates by returning every body that would have been inside the
+        FOV of this observation if it were instead a Snapshot, evaluated at the
+        given tfrac.
+        """
 
-    def runTest(self):
+        # TODO
+        if self._extended_fov:
+            raise NotImplementedError('inventory is not implemented for '
+                                      'TimedImage with cadence-extended FOV')
 
-        from oops.fov.flatfov import FlatFOV
+        return self.snapshot.inventory(*args, **kwargs)
 
-        fov = FlatFOV((0.001,0.001), (20,1))
-        obs = Slit1D(('u'), tstart=0., texp=10., fov=fov, path='SSB', frame='J2000')
-
-        indices = Vector([(0,0),(1,0),(20,0),(21,0)])
-        indices_ = indices.copy()       # clipped at 20
-        indices_.vals[:,0][indices_.vals[:,0] == 20] -= 1
-
-        # uvt() with remask == False
-        (uv,time) = obs.uvt(indices)
-        self.assertFalse(np.any(uv.mask))
-        self.assertFalse(np.any(time.mask))
-        self.assertEqual(time, 5.)
-        self.assertEqual(uv.to_scalar(0), indices.to_scalar(0))
-        self.assertEqual(uv.to_scalar(1), 0.5)
-
-        # uvt() with remask == True
-        (uv,time) = obs.uvt(indices, remask=True)
-
-        self.assertTrue(np.all(uv.mask == np.array(3*[False] + [True])))
-        self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time[:3], (5,5,5))
-        self.assertEqual(uv[:3].to_scalar(0), indices[:3].to_scalar(0))
-        self.assertEqual(uv[:3].to_scalar(1), 0.5)
-
-        # uvt_range() with remask == False
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertFalse(np.any(uv_min.mask))
-        self.assertFalse(np.any(uv_max.mask))
-        self.assertFalse(np.any(time_min.mask))
-        self.assertFalse(np.any(time_max.mask))
-
-        self.assertEqual(uv_min.to_scalar(0), indices_.to_scalar(0))
-        self.assertEqual(uv_min.to_scalar(1), 0)
-        self.assertEqual(uv_max.to_scalar(0), indices_.to_scalar(0) + 1)
-        self.assertEqual(uv_max.to_scalar(1), 1)
-        self.assertEqual(time_min, 0.)
-        self.assertEqual(time_max, 10.)
-
-        # uvt_range() with remask == True
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices,
-                                                             remask=True)
-        self.assertTrue(np.all(uv_min.mask == np.array(3*[False] + [True])))
-        self.assertTrue(np.all(uv_max.mask == uv_min.mask))
-        self.assertTrue(np.all(time_min.mask == uv_min.mask))
-        self.assertTrue(np.all(time_max.mask == uv_min.mask))
-
-        self.assertEqual(uv_min.to_scalar(0)[:2], indices.to_scalar(0)[:2])
-        self.assertEqual(uv_min.to_scalar(1)[:2], 0)
-        self.assertEqual(uv_max.to_scalar(0)[:2], indices.to_scalar(0)[:2] + 1)
-        self.assertEqual(uv_max.to_scalar(1)[:2], 1)
-        self.assertEqual(time_min[:2], 0.)
-        self.assertEqual(time_max[:2], 10.)
-
-        # time_range_at_uv() with remask == False
-        uv = Pair([(0,0),(0,0.5),(0,1),(0,2),
-                   (20,0),(20,0.5),(20,1),(20,2),
-                   (21,0)])
-
-        (time0, time1) = obs.time_range_at_uv(uv)
-
-        self.assertEqual(time0, 0.)
-        self.assertEqual(time1, 10.)
-
-        # time_range_at_uv() with remask == True
-        (time0, time1) = obs.time_range_at_uv(uv, remask=True)
-
-        self.assertTrue(np.all(time0.mask == 3*[False] + [True] +
-                                             3*[False] + 2*[True]))
-        self.assertTrue(np.all(time1.mask == time0.mask))
-        self.assertEqual(time0[:3], 0.)
-        self.assertEqual(time1[:3], 10.)
-
-        ####################################
-
-        # Alternative axis order ('a','u','b')
-
-        fov = FlatFOV((0.001,0.001), (20,1))
-        obs = Slit1D(('a','u', 'b'), tstart=0., texp=10.,
-                     fov=fov, path='SSB', frame='J2000')
-
-        indices = Vector([(0,0,0),(0,1,99),(0,19,99),(10,20,99),(10,21,99)])
-        indices_ = indices.copy()       # clipped at 20
-        indices_.vals[:,1][indices_.vals[:,1] == 20] -= 1
-
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv.to_scalar(0), indices.to_scalar(1))
-        self.assertEqual(uv.to_scalar(1), 0.5)
-        self.assertEqual(time, 5.)
-
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertEqual(uv_min.to_scalar(0), indices_.to_scalar(1))
-        self.assertEqual(uv_max.to_scalar(0), indices_.to_scalar(1)+1)
-        self.assertEqual(uv_min.to_scalar(1), 0.)
-        self.assertEqual(uv_max.to_scalar(1), 1)
-        self.assertEqual(time_min, 0.)
-        self.assertEqual(time_max, 10.)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/observation/snapshot.py` & `rms_oops-0.0.4/oops/observation/snapshot.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 ################################################################################
 # oops/observation/snapshot.py: Subclass Snapshot of class Observation
 ################################################################################
 
 import numpy as np
-from polymath import Scalar, Pair, Vector, Vector3, Qube
 
+from polymath               import Scalar, Pair, Vector, Vector3, Qube
 from oops.observation       import Observation
 from oops.body              import Body
 from oops.cadence.metronome import Metronome
 from oops.event             import Event
 from oops.frame             import Frame
 from oops.path              import Path
 from oops.path.multipath    import MultiPath
@@ -588,131 +588,7 @@
             body_data['v_pixel_size'] = radius_angles[i].vals/v_scale*2
 
             returned_dict[body_names[i]] = body_data
 
         return returned_dict
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Snapshot(unittest.TestCase):
-
-    def runTest(self):
-
-        from oops.fov.flatfov import FlatFOV
-
-        fov = FlatFOV((0.001,0.001), (10,20))
-        obs = Snapshot(('u','v'), tstart=98., texp=2.,
-                       fov=fov, path='SSB', frame='J2000')
-
-        indices = Vector([(0.,0.),(0.,20.),(10.,0.),(10.,20.),(10.,21.)])
-        indices_ = indices.copy()
-        indices_.vals[:,0][indices.vals[:,0] == 10] -= 1
-        indices_.vals[:,1][indices.vals[:,1] == 20] -= 1
-
-        # uvt() with remask == False
-        (uv,time) = obs.uvt(indices)
-
-        self.assertFalse(uv.mask)
-        self.assertFalse(time.mask)
-        self.assertEqual(time, 99.)
-        self.assertEqual(uv, Pair.as_pair(indices))
-
-        # uvt() with remask == True
-        (uv,time) = obs.uvt(indices, remask=True)
-
-        self.assertTrue(np.all(uv.mask == np.array(4*[False] + [True])))
-        self.assertTrue(np.all(time.mask == uv.mask))
-        self.assertEqual(time[:4], 99.)
-        self.assertEqual(uv[:4], Pair.as_pair(indices)[:4])
-
-        # uvt_range() with remask == False
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices)
-
-        self.assertFalse(uv_min.mask)
-        self.assertFalse(uv_max.mask)
-        self.assertFalse(time_min.mask)
-        self.assertFalse(time_max.mask)
-
-        self.assertEqual(uv_min, Pair.as_pair(indices_))
-        self.assertEqual(uv_max, Pair.as_pair(indices_) + (1,1))
-        self.assertEqual(time_min,  98.)
-        self.assertEqual(time_max, 100.)
-
-        # uvt_range() with remask == False, new indices
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9))
-
-        self.assertFalse(uv_min.mask)
-        self.assertFalse(uv_max.mask)
-        self.assertFalse(time_min.mask)
-        self.assertFalse(time_max.mask)
-
-        self.assertEqual(uv_min, Pair.as_pair(indices))
-        self.assertEqual(uv_max, Pair.as_pair(indices) + (1,1))
-        self.assertEqual(time_min,  98.)
-        self.assertEqual(time_max, 100.)
-
-        # uvt_range() with remask == True, new indices
-        (uv_min, uv_max, time_min, time_max) = obs.uvt_range(indices+(0.2,0.9),
-                                                             remask=True)
-        self.assertTrue(np.all(uv_min.mask == [False] + 4*[True]))
-        self.assertTrue(np.all(uv_min.mask == uv_max.mask))
-        self.assertTrue(np.all(uv_min.mask == time_min.mask))
-        self.assertTrue(np.all(uv_min.mask == time_max.mask))
-
-        self.assertEqual(uv_min[0], Pair.as_pair(indices)[0])
-        self.assertEqual(uv_max[0], (Pair.as_pair(indices) + (1,1))[0])
-        self.assertEqual(time_min[0],  98.)
-        self.assertEqual(time_max[0], 100.)
-
-        # time_range_at_uv() with remask == False
-        uv_pair = Pair([(0.,0.),(0.,20.),(10.,0.),(10.,20.),(10.,21.)])
-
-        (time0, time1) = obs.time_range_at_uv(uv_pair)
-
-        self.assertEqual(time0,  98.)
-        self.assertEqual(time1, 100.)
-
-        # time_range_at_uv() with remask == True
-        (time0, time1) = obs.time_range_at_uv(uv_pair, remask=True)
-
-        self.assertTrue(np.all(time0.mask == 4*[False] + [True]))
-        self.assertTrue(np.all(time1.mask == 4*[False] + [True]))
-        self.assertEqual(time0[:4],  98.)
-        self.assertEqual(time1[:4], 100.)
-
-        # Alternative axis order ('v','u')
-        obs = Snapshot(('v','u'), tstart=98., texp=2.,
-                       fov=fov, path='SSB', frame='J2000')
-
-        indices = Pair([(0,0),(0,10),(20,0),(20,10),(20,11)])
-
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv, indices.to_pair((1,0)))
-
-        (uv,time) = obs.uvt(indices, remask=True)
-
-        self.assertEqual(uv[:4], indices.to_pair((1,0))[:4])
-        self.assertTrue(np.all(uv.mask == 4*[False] + [True]))
-
-        # Alternative axis order ('v', 'a', 'u')
-        obs = Snapshot(('v','a','u'), tstart=98., texp=2.,
-                       fov=fov, path='SSB', frame='J2000')
-
-        indices = Vector([(0,-1,0),(0,99,10),(20,-9,0),(20,77,10),(20,44,11)])
-        (uv,time) = obs.uvt(indices)
-
-        self.assertEqual(uv, indices.to_pair((2,0)))
-
-        (uv,time) = obs.uvt(indices, remask=True)
-
-        self.assertEqual(uv[:4], indices.to_pair((2,0))[:4])
-        self.assertTrue(np.all(uv.mask == 4*[False] + [True]))
-
-################################################################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/__init__.py` & `rms_oops-0.0.4/oops/path/path_.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,28 +1,30 @@
 ################################################################################
-# oops/path/__init__.py: Abstract class Path and its required subclasses
+# oops/path/path_.py: Abstract class Path and its required subclasses
 ################################################################################
 
 import numpy as np
 import scipy.interpolate as interp
 
-from polymath import Qube, Scalar, Vector3
-
-from oops.config import QUICK, PATH_PHOTONS, LOGGING, PICKLE_CONFIG
-from oops.event  import Event
-from oops.frame  import Frame
+from polymath          import Qube, Scalar, Vector3
+from oops.config       import QUICK, PATH_PHOTONS, LOGGING, PICKLE_CONFIG
+from oops.event        import Event
+from oops.frame.frame_ import Frame
 import oops.constants as constants
 
 class Path(object):
     """Path is an abstract class that returns an Event (time, position and
     velocity) given a Scalar time. The coordinates are specified in a particular
     frame and relative to another path. All paths are ultimately references to
     the Solar System Barycenter ("SSB") and the J2000 coordinate frame.
     """
 
+    # To avoid circular imports; filled in by oops/__init__.py
+    BODY_CLASS = None           # filled in by body.py
+
     WAYPOINT_REGISTRY = {}
     PATH_CACHE = {}
     TEMPORARY_PATH_ID = 10000
 
     ############################################################################
     # Each subclass must override...
     ############################################################################
@@ -1520,157 +1522,8 @@
 Path.SSB = Waypoint('SSB')
 Path.SSB.ancestry = []
 Path.SSB.wrt_ssb = Path.SSB
 
 # Initialize the registry
 Path.initialize_registry()
 
-Event.PATH_CLASS = Path
-
 ###############################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Path(unittest.TestCase):
-
-    def runTest(self):
-
-        # Re-import here to so modules all come from the oops tree
-        from oops.path import Path, LinkedPath, ReversedPath, \
-                              RelativePath, RotatedPath, QuickPath
-
-        # More imports are here to avoid conflicts
-        import os
-        import cspyce
-        from oops.path.spicepath     import SpicePath
-        from oops.path.linearpath    import LinearPath
-        from oops.frame.spiceframe   import SpiceFrame
-        from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
-
-        Path.USE_QUICKPATHS = False
-
-        cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, 'SPICE/de421.bsp'))
-
-        # Registry tests
-        Path.reset_registry()
-        Frame.reset_registry()
-
-        self.assertEqual(Path.WAYPOINT_REGISTRY['SSB'], Path.SSB)
-
-        # LinkedPath tests
-        _ = SpicePath('SUN', 'SSB')
-        earth = SpicePath('EARTH', 'SUN')
-
-        moon = SpicePath('MOON', 'EARTH')
-        linked = LinkedPath(moon, earth)
-
-        direct = SpicePath('MOON', 'SUN')
-
-        times = np.arange(-3.e8, 3.01e8, 0.5e7)
-
-        direct_event = direct.event_at_time(times)
-        linked_event = linked.event_at_time(times)
-
-        eps = 1.e-6
-        self.assertTrue(((linked_event.pos - direct_event.pos).norm() <= eps).all())
-        self.assertTrue(((linked_event.vel - direct_event.vel).norm() <= eps).all())
-
-        # RelativePath
-        relative = RelativePath(linked, SpicePath('MARS', 'SUN'))
-        direct = SpicePath('MOON', 'MARS')
-
-        direct_event = direct.event_at_time(times)
-        relative_event = relative.event_at_time(times)
-
-        eps = 1.e-6
-        self.assertTrue(((relative_event.pos - direct_event.pos).norm() <= eps).all())
-        self.assertTrue(((relative_event.vel - direct_event.vel).norm() <= eps).all())
-
-        # ReversedPath
-        reversed = ReversedPath(relative)
-        direct = SpicePath('MARS', 'MOON')
-
-        direct_event = direct.event_at_time(times)
-        reversed_event = reversed.event_at_time(times)
-
-        eps = 1.e-6
-        self.assertTrue(((reversed_event.pos - direct_event.pos).norm() <= eps).all())
-        self.assertTrue(((reversed_event.vel - direct_event.vel).norm() <= eps).all())
-
-        # RotatedPath
-        rotated = RotatedPath(reversed, SpiceFrame('B1950'))
-        direct = SpicePath('MARS', 'MOON', 'B1950')
-
-        direct_event = direct.event_at_time(times)
-        rotated_event = rotated.event_at_time(times)
-
-        eps = 1.e-6
-        self.assertTrue(((rotated_event.pos - direct_event.pos).norm() <= eps).all())
-        self.assertTrue(((rotated_event.vel - direct_event.vel).norm() <= eps).all())
-
-        # QuickPath tests
-        moon = SpicePath('MOON', 'EARTH')
-        quick = QuickPath(moon, (-5.,5.), QUICK.dictionary)
-
-        # Perfect precision is impossible
-        try:
-            quick = QuickPath(moon, np.arange(0.,100.,0.0001),
-                              dict(QUICK.dictionary, **{'path_self_check':0.}))
-            self.assertTrue(False, 'No ValueError raised for PRECISION = 0.')
-        except ValueError:
-            pass
-
-        # Timing tests...
-        test = np.zeros(3000000)
-        # _ = moon.event_at_time(test, quick=False)       # takes about 15 sec
-        _ = quick.event_at_time(test)                   # takes maybe 2 sec
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-        ################################
-        # Test unregistered paths
-        ################################
-
-        ssb = Path.as_waypoint('SSB')
-
-        slider1 = LinearPath(([3,0,0],[0,3,0]), 0., ssb)
-        self.assertTrue(slider1.path_id.startswith('TEMPORARY'))
-
-        event = slider1.event_at_time(1.)
-        self.assertEqual(event.pos, (3,3,0))
-        self.assertEqual(event.vel, (0,3,0))
-
-        slider2 = LinearPath(([-2,0,0],[0,0,-2]), 0., slider1)
-        self.assertTrue(slider2.path_id.startswith('TEMPORARY'))
-
-        event = slider2.event_at_time(1.)
-        self.assertEqual(event.pos, (-2,0,-2))
-        self.assertEqual(event.vel, (0,0,-2))
-
-        slider3 = LinearPath(([-1,0,0],[0,-3,2]), 0., slider2)
-        self.assertTrue(slider3.path_id.startswith('TEMPORARY'))
-
-        event = slider3.event_at_time(1.)
-        self.assertEqual(event.pos, (-1,-3,2))
-        self.assertEqual(event.vel, ( 0,-3,2))
-
-        # Link unregistered frame to registered frame
-        static = slider3.wrt(ssb)
-
-        event = static.event_at_time(1.)
-        self.assertEqual(event.pos, (0,0,0))
-        self.assertEqual(event.vel, (0,0,0))
-
-        # Link registered frame to unregistered frame
-        static = ssb.wrt(slider3)
-
-        event = static.event_at_time(1.)
-        self.assertEqual(event.pos, (0,0,0))
-        self.assertEqual(event.vel, (0,0,0))
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/circlepath.py` & `rms_oops-0.0.4/oops/path/circlepath.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,17 +1,16 @@
 ################################################################################
 # oops/path/circlepath.py: Subclass CirclePath of class Path
 ################################################################################
 
-import numpy as np
 from polymath import Qube, Scalar, Vector3
 
-from oops.event import Event
-from oops.frame import Frame
-from oops.path  import Path
+from oops.event        import Event
+from oops.frame.frame_ import Frame
+from oops.path.path_   import Path
 
 class CirclePath(Path):
     """A path describing uniform circular motion about another path.
 
     The orientation of the circle is defined by the z-axis of the given
     frame.
     """
@@ -105,40 +104,7 @@
         pos = Vector3.from_scalars(r_cos_lon, r_sin_lon, 0.)
         vel = Vector3.from_scalars(-r_sin_lon * self.rate,
                                     r_cos_lon * self.rate, 0.)
 
         return Event(time, (pos,vel), self.origin, self.frame)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_CirclePath(unittest.TestCase):
-
-    def runTest(self):
-
-        np.random.seed(2787)
-
-        # Note: Unit testing is performed in surface/orbitplane.py
-
-        ####################################
-        # __getstate__/__setstate__
-
-        radius = 100000.
-        lon = 5 * np.random.randn()
-        rate = 0.001 * np.random.randn()
-        epoch = 10. * 365. * 86400. * np.random.randn()
-        origin = Path.SSB
-        frame = Frame.J2000
-        path = CirclePath(radius, lon, rate, epoch, origin, frame)
-        state = path.__getstate__()
-
-        copied = Path.__new__(CirclePath)
-        copied.__setstate__(state)
-        self.assertEqual(copied.__getstate__(), state)
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/coordpath.py` & `rms_oops-0.0.4/oops/path/coordpath.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 ################################################################################
 # oops/path/coordpath.py: Subclass CoordPath of class Path
 ################################################################################
 
-from polymath import Qube, Scalar
-
-from oops.event   import Event
-from oops.path    import Path
-from oops.surface import Surface
+from polymath        import Qube, Scalar
+from oops.event      import Event
+from oops.path.path_ import Path
 
 class CoordPath(Path):
     """A path defined by fixed coordinates on a specified Surface."""
 
     # Note: CoordPaths are not generally re-used, so their IDs are expendable.
     # Their IDs are not preserved during pickling.
 
@@ -72,22 +70,7 @@
             obs_event = self.obs_path.event_at_time(time, quick=quick)
             self.pos = self.surface.vector3_from_coords(self.coords,
                                                         obs_event.pos)
 
         return Event(time, self.pos, self.origin, self.frame)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_CoordPath(unittest.TestCase):
-
-    def runTest(self):
-
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/fixedpath.py` & `rms_oops-0.0.4/oops/path/fixedpath.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 ################################################################################
 # oops/path/fixedpath.py: Subclass FixedPath of class Path
 ################################################################################
 
-from polymath import Qube, Vector3
-
-from oops.event import Event
-from oops.frame import Frame
-from oops.path  import Path
+from polymath          import Qube, Vector3
+from oops.event        import Event
+from oops.frame.frame_ import Frame
+from oops.path.path_   import Path
 
 class FixedPath(Path):
     """A path described by fixed coordinates relative to another path and frame.
     """
 
     # Note: FixedPaths are not generally re-used, so their IDs are expendable.
     # Their IDs are not preserved during pickling.
@@ -63,23 +62,7 @@
         Return:         an Event object containing (at least) the time, position
                         and velocity on the path.
         """
 
         return Event(time, self.pos, self.origin, self.frame)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_FixedPath(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/keplerpath.py` & `rms_oops-0.0.4/oops/path/keplerpath.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,20 +1,18 @@
 ################################################################################
 # oops/path/keplerpath.py: Subclass KeplerPath of class Path.
 ################################################################################
 
 import numpy as np
-from polymath import Scalar, Vector3, Matrix3
 
-from oops.body     import Body
-from oops.event    import Event
-from oops.fittable import Fittable
-from oops.frame    import Frame
-from oops.gravity  import Gravity
-from oops.path     import Path
+from polymath          import Scalar, Vector3, Matrix3
+from oops.event        import Event
+from oops.fittable     import Fittable
+from oops.frame.frame_ import Frame
+from oops.path.path_   import Path
 
 SEMIM = 0   # elements[SEMIM] = semimajor axis (km)
 MEAN0 = 1   # elements[MEAN0] = mean longitude at epoch (radians)
 DMEAN = 2   # elements[DMEAN] = mean motion (radians/s)
 ECCEN = 3   # elements[ECCEN] = eccentricity
 PERI0 = 4   # elements[PERI0] = pericenter at epoch (radians)
 DPERI = 5   # elements[DPERI] = pericenter precession rate (radians/s)
@@ -115,15 +113,15 @@
                 raise ValueError('invalid name for wobble in KeplerPath: '
                                  + repr(name))
 
         self.nparams = NELEMENTS + self.nwobbles * NWOBBLES
         self.param_name = "elements"
         self.cache = {}
 
-        self.planet = Body.as_body(body)
+        self.planet = Path.BODY_CLASS.as_body(body)
         self.center = self.planet.path
         self.gravity = self.planet.gravity
 
         if observer is None:
             self.observer = None
             self.origin = self.planet.path
             self.frame  = frame or self.planet.ring_frame
@@ -865,268 +863,7 @@
                            link_event.origin, link_event.frame)
         link_event.arr_lt = path_event.dep_lt
         link_event.arr_j2000 = path_event.dep_j2000
 
         return (path_event, link_event)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-def _xyz_planet_derivative_test(kep, t, delta=1.e-7):
-    """Error in position change based on numerical vs. analytic derivatives.
-    """
-
-    # Save the position and its derivatives
-    (xyz, _d_xyz_dt) = kep.xyz_planet(t, partials=True)
-    d_xyz_d_elem = xyz.d_delements.vals
-    pos_norm = xyz.norm().vals
-
-    # Create new Kepler objects for tweaking the parameters
-    khi = kep.copy()
-    klo = kep.copy()
-
-    params = kep.get_params()
-
-    # Loop through parameters...
-    errors = np.zeros(np.shape(t) + (3,kep.nparams))
-    for e in range(kep.nparams):
-
-        # Tweak one parameter
-        hi = params.copy()
-        lo = params.copy()
-
-        if params[e] == 0.:
-            hi[e] += delta
-            lo[e] -= delta
-        else:
-            hi[e] *= 1. + delta
-            lo[e] *= 1. - delta
-
-        denom = hi[e] - lo[e]
-
-        khi.set_params(hi)
-        klo.set_params(lo)
-
-        # Compare the change with that derived from the partial derivative
-        xyz_hi = khi.xyz_planet(t, partials=False)[0].vals
-        xyz_lo = klo.xyz_planet(t, partials=False)[0].vals
-        hi_lo_diff = xyz_hi - xyz_lo
-
-        errors[...,:,e] = ((d_xyz_d_elem[...,:,e] * denom - hi_lo_diff) /
-                           pos_norm[...,np.newaxis])
-
-    return errors
-
-#===============================================================================
-def _pos_derivative_test(kep, t, delta=1.e-5):
-    """Calculates numerical derivatives of (x,y,z) in the observer/J2000 frame
-    relative to the orbital elements, at time(s) t. It returns a tuple of
-    (numerical derivatives, analytic derivatives, relative errors). Used for
-    debugging.
-    """
-
-    # Save the position and its derivatives
-    event = kep.event_at_time(t, partials=True)
-    d_xyz_d_elem = event.pos.d_delements.vals
-    pos_norm = event.pos.norm().vals
-
-    # Create new Kepler objects for tweaking the parameters
-    khi = kep.copy()
-    klo = kep.copy()
-
-    params = kep.get_params()
-
-    # Loop through parameters...
-    errors = np.zeros(np.shape(t) + (3,kep.nparams))
-    for e in range(kep.nparams):
-
-        # Tweak one parameter
-        hi = params.copy()
-        lo = params.copy()
-
-        if params[e] == 0.:
-            hi[e] += delta
-            lo[e] -= delta
-        else:
-            hi[e] *= 1. + delta
-            lo[e] *= 1. - delta
-
-        denom = hi[e] - lo[e]
-
-        khi.set_params(hi)
-        klo.set_params(lo)
-
-        # Compare the change with that derived from the partial derivative
-        xyz_hi = khi.event_at_time(t, partials=False).pos.vals
-        xyz_lo = klo.event_at_time(t, partials=False).pos.vals
-        hi_lo_diff = xyz_hi - xyz_lo
-
-        errors[...,:,e] = ((d_xyz_d_elem[...,:,e] * denom - hi_lo_diff) /
-                           pos_norm[...,np.newaxis])
-
-    return errors
-
-#===============================================================================
-class Test_KeplerPath(unittest.TestCase):
-
-    def setUp(self):
-        from oops.body import Body
-
-        Body.reset_registry()
-        Body.define_solar_system("2000-01-01", "2010-01-01")
-
-    def tearDown(self):
-        pass
-
-    def runTest(self):
-        from oops.body import Body
-
-        # SEMIM = 0    elements[SEMIM] = semimajor axis (km)
-        # MEAN0 = 1    elements[MEAN0] = mean longitude at epoch (radians)
-        # DMEAN = 2    elements[DMEAN] = mean motion (radians/s)
-        # ECCEN = 3    elements[ECCEN] = eccentricity
-        # PERI0 = 4    elements[PERI0] = pericenter at epoch (radians)
-        # DPERI = 5    elements[DPERI] = pericenter precession rate (radians/s)
-        # INCLI = 6    elements[INCLI] = inclination (radians)
-        # NODE0 = 7    elements[NODE0] = longitude of ascending node at epoch
-        # DNODE = 8    elements[DNODE] = nodal regression rate (radians/s)
-
-        a = 140000.
-
-        saturn = Gravity.lookup('SATURN')
-        dmean_dt = saturn.n(a)
-        dperi_dt = saturn.dperi_dt(a)
-        dnode_dt = saturn.dnode_dt(a)
-
-        TIMESTEPS = 100
-        time = 3600. * np.arange(TIMESTEPS)
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt, 0.2, 3., dperi_dt, 0.1, 5., dnode_dt),
-                       Path.as_path("EARTH"))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-8)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-8)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        dmean_dt * 0.10, 2., dmean_dt / 100.,
-                        dperi_dt * 0.08, 4., dmean_dt / 50.,
-                        dnode_dt * 0.12, 6., dmean_dt / 200.),
-                       Path.as_path("EARTH"), wobbles=('mean', 'peri', 'node'))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-8)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-8)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        a * 0.10, 2., dmean_dt / 100.),
-                       Path.as_path("EARTH"), wobbles=('a',))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-7)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-5)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        0.1, 4., dmean_dt / 50.),
-                       Path.as_path("EARTH"), wobbles=('e',))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 3.e-7)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 3.e-5)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        0.15, 2., dmean_dt / 150.),
-                       Path.as_path("EARTH"), wobbles=('i',))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-7)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-5)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        1.e-4, 3., dperi_dt/100.),
-                       Path.as_path("EARTH"), wobbles=('e2d',))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-5)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-4)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        1.e-4, 2., dnode_dt/150.),
-                       Path.as_path("EARTH"), wobbles=('i2d',))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-6)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-5)
-
-        ####################
-
-        kep = KeplerPath(Body.lookup("SATURN"), 0.,
-                       (a, 1., dmean_dt,
-                        0.2, 3., dperi_dt,
-                        0.1, 5., dnode_dt,
-                        1.e-4, 2., dperi_dt/150.,
-                        2.e-4, 3., dnode_dt/200.,
-                        a * 1.e-3, 4., dmean_dt/150.),
-                       Path.as_path("EARTH"), wobbles=('i2d','e2d','a'))
-
-        errors = _xyz_planet_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-5)
-
-        errors = _pos_derivative_test(kep, time)
-        self.assertTrue(np.max(np.abs(errors)) < 1.e-4)
-
-        Frame.reset_registry()
-        Path.reset_registry()
-        Body.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/linearcoordpath.py` & `rms_oops-0.0.4/oops/path/linearcoordpath.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,16 +1,14 @@
 ################################################################################
 # oops/path/linearcoordpath.py: Subclass LinearCoordPath of class Path
 ################################################################################
 
-from polymath import Qube, Scalar
-
-from oops.event import Event
-from oops.frame import Frame
-from oops.path  import Path
+from polymath        import Qube, Scalar
+from oops.event      import Event
+from oops.path.path_ import Path
 
 class LinearCoordPath(Path):
     """A path defined by coordinates changing linearly on a specified Surface.
     """
 
     # Note: LinearCoordPaths are not generally re-used, so their IDs are
     # expendable. Their IDs are not preserved during pickling.
@@ -83,23 +81,7 @@
             obs = None
 
         pos = self.surface.vector3_from_coords(new_coords, obs, derivs=True)
 
         return Event(time, pos, self.origin, self.frame)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_LinearCoordPath(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/linearpath.py` & `rms_oops-0.0.4/oops/path/linearpath.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 ################################################################################
 # oops/path/linearpath.py: Subclass LinearPath of class Path
 ################################################################################
 
-from polymath import Qube, Scalar, Vector3
-
-from oops.event import Event
-from oops.frame import Frame
-from oops.path  import Path
+from polymath          import Qube, Scalar, Vector3
+from oops.event        import Event
+from oops.frame.frame_ import Frame
+from oops.path.path_   import Path
 
 class LinearPath(Path):
     """A path defining linear motion relative to another path and frame."""
 
     # Note: LinearPaths are not generally re-used, so their IDs are expendable.
     # Their IDs are not preserved during pickling.
 
@@ -80,23 +79,7 @@
                         and velocity on the path.
         """
 
         return Event(time, (self.pos + (time-self.epoch) * self.vel, self.vel),
                            self.origin, self.frame)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_LinearPath(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/path/spicepath.py` & `rms_oops-0.0.4/tests/path/test_spicepath.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,260 +1,29 @@
 ################################################################################
-# oops/path/spicepath.py: Subclass SpicePath of class Path
+# tests/path/test_spicepath.py
 ################################################################################
 
-import cspyce
 import numpy as np
+import os
+import unittest
 
-from polymath   import Scalar, Vector3
-from oops.event import Event
-from oops.frame import Frame
-from oops.path  import Path, AliasPath, ReversedPath, RotatedPath
+import cspyce
 import oops.spice_support as spice
+import oops.constants as constants
 
-class SpicePath(Path):
-    """A Path subclass that returns information based on an SPICE SP kernel.
-
-    It represents the geometric position of a single target body with respect to
-    a single origin.
-    """
-
-    # Set False to confirm that SpicePaths return the same results without
-    # shortcuts and with shortcuts
-    USE_SPICEPATH_SHORTCUTS = True
-
-    #===========================================================================
-    def __init__(self, spice_id, spice_origin="SSB", spice_frame="J2000",
-                       path_id=None, shortcut=None, unpickled=False):
-        """Constructor for a SpicePath object.
-
-        Input:
-            spice_id        the name or integer ID of the target body as used
-                            in the SPICE toolkit.
-            spice_origin    the name or integer ID of the origin body as
-                            used in the SPICE toolkit; "SSB" for the Solar
-                            System Barycenter by default. It may also be the
-                            registered name of another SpicePath.
-            spice_frame     the name or integer ID of the reference frame or of
-                            the a body with which the frame is primarily
-                            associated, as used in the SPICE toolkit.
-            path_id         the name or ID under which the path will be
-                            registered. By default, this will be the value of
-                            spice_id if that is given as a string; otherwise
-                            it will be the name as used by the SPICE toolkit.
-            shortcut        If a shortcut is specified, then this is registered
-                            as a shortcut definition; the other registered path
-                            definitions are unchanged.
-            unpickled       True if this object was read from a pickle file. If
-                            so, then it will be treated as a duplicate of a
-                            pre-existing SpicePath for the same SPICE ID.
-        """
-
-        # Preserve the inputs
-        self.spice_id = spice_id
-        self.spice_origin = spice_origin
-        self.spice_frame = spice_frame
-        self.shortcut = shortcut
-
-        # Interpret the SPICE IDs
-        (self.spice_target_id,
-         self.spice_target_name) = spice.body_id_and_name(spice_id)
-
-        (self.spice_origin_id,
-         self.spice_origin_name) = spice.body_id_and_name(spice_origin)
-
-        self.spice_frame_name = spice.frame_id_and_name(spice_frame)[1]
-
-        # Fill in the Path ID and save it in the global dictionary
-        if path_id is None:
-            if isinstance(spice_id, str):
-                self.path_id = spice_id
-            else:
-                self.path_id = self.spice_target_name
-        else:
-            self.path_id = path_id
-
-        # Only save info in the PATH_TRANSLATION dictionary if it is not already
-        # there. We do not want to overwrite original definitions with those
-        # just read from pickle files.
-        if not shortcut:
-            if self.spice_target_id not in spice.PATH_TRANSLATION:
-                spice.PATH_TRANSLATION[self.spice_target_id] = self.path_id
-            if self.spice_target_name not in spice.PATH_TRANSLATION:
-                spice.PATH_TRANSLATION[self.spice_target_name] = self.path_id
-
-        # Fill in the origin waypoint, which should already be in the dictionary
-        origin_id = spice.PATH_TRANSLATION[self.spice_origin_id]
-        self.origin = Path.as_waypoint(origin_id)
-
-        # Fill in the frame wayframe, which should already be in the dictionary
-        frame_id = spice.FRAME_TRANSLATION[self.spice_frame_name]
-        self.frame = Frame.as_wayframe(frame_id)
-
-        # No shape, no keys
-        self.shape = ()
-        self.keys = set()
-        self.shortcut = shortcut
-
-        # Register the SpicePath; fill in the waypoint
-        self.register(shortcut, unpickled=unpickled)
-
-    def __getstate__(self):
-        return (self.spice_target_id, self.spice_origin_id,
-                self.spice_frame_name)
-
-    def __setstate__(self, state):
-
-        (spice_target_id, spice_origin_id, spice_frame_name) = state
-
-        # If this is a duplicate of a pre-existing SpicePath, make sure it gets
-        # assigned the pre-existing path ID and Waypoint
-        path_id = spice.PATH_TRANSLATION.get(spice_target_id, None)
-        self.__init__(spice_target_id, spice_origin_id, spice_frame_name,
-                      path_id=path_id, unpickled=True)
-
-    #===========================================================================
-    def event_at_time(self, time, quick={}):
-        """An Event corresponding to a specified Scalar time on this path.
-
-        Input:
-            time        a time Scalar at which to evaluate the path.
-
-        Return:         an Event object containing (at least) the time, position
-                        and velocity of the path.
-        """
-
-        time = Scalar.as_scalar(time).as_float()
-
-        # A fully-masked time can be handled quickly
-        if time.mask is True:
-            return Event(time, Vector3.ZERO, self.origin, self.frame)
+from polymath   import Vector3
+from oops.frame import Frame, SpiceFrame
+from oops.path  import Path, AliasPath, SpicePath
+from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
 
-        # A single unmasked time can be handled quickly
-        if time.shape == ():
-            (state,
-             lighttime) = cspyce.spkez(self.spice_target_id,
-                                       time.vals,
-                                       self.spice_frame_name,
-                                       'NONE',
-                                       self.spice_origin_id)
-
-            return Event(time, (state[0:3],state[3:6]), self.origin, self.frame)
-
-        # Use a QuickPath if warranted, possibly making a recursive call
-        if isinstance(quick, dict):
-            return self.quick_path(time, quick).event_at_time(time, False)
-
-        # Fill in the states and light travel times using cspyce
-        if np.any(time.mask):
-            state = cspyce.spkez_vector(self.spice_target_id,
-                                        time.vals[time.antimask],
-                                        self.spice_frame_name,
-                                        'NONE',
-                                        self.spice_origin_id)[0]
-
-            pos = np.zeros(time.shape + (3,))
-            vel = np.zeros(time.shape + (3,))
-            pos[time.antimask] = state[...,0:3]
-            vel[time.antimask] = state[...,3:6]
-
-        else:
-            state = cspyce.spkez_vector(self.spice_target_id,
-                                        time.vals.ravel(),
-                                        self.spice_frame_name,
-                                        'NONE',
-                                        self.spice_origin_id)[0]
-            pos = state[:,0:3].reshape(time.shape + (3,))
-            vel = state[:,3:6].reshape(time.shape + (3,))
-
-        # Convert to an Event and return
-        return Event(time, (pos,vel), self.origin, self.frame)
-
-    #===========================================================================
-    def wrt(self, origin, frame=None):
-        """Construct a path pointing from an origin to this target in any frame.
-
-        SpicePath overrides the default method to create quicker "shortcuts"
-        between SpicePaths.
-
-        Input:
-            origin      an origin Path object or its registered name.
-            frame       a frame object or its registered ID. Default is to use
-                        the frame of the origin's path.
-        """
-
-        # Use the slow method if necessary, for debugging
-        if not SpicePath.USE_SPICEPATH_SHORTCUTS:
-            return Path.wrt(self, origin, frame)
-
-        # Interpret the origin path
-        origin = Path.as_primary_path(origin)
-        if origin in (Path.SSB, None):
-            spice_origin_id = 0
-        elif isinstance(origin, SpicePath):
-            spice_origin_id = origin.spice_target_id
-        else:
-            # If the origin is not a SpicePath, seek from the other direction
-            return ReversedPath(origin.wrt(self, frame))
-
-        origin_id = spice.PATH_TRANSLATION[spice_origin_id]
-
-        # Interpret the frame
-        frame = Frame.as_primary_frame(frame)
-        if frame in (Frame.J2000, None):
-            spice_frame_name = 'J2000'
-            uses_spiceframe = True
-        elif type(frame).__name__ == 'SpiceFrame':  # avoids a circular load
-            spice_frame_name = frame.spice_frame_name
-            uses_spiceframe = True
-        else:
-            uses_spiceframe = False     # not a SpiceFrame
-            spice_frame_name = 'J2000'
-
-        if uses_spiceframe:
-            frame_id = spice.FRAME_TRANSLATION[spice_frame_name]
-        else:
-            frame_id = 'J2000'
-
-        shortcut = ('SPICE_SHORTCUT[' + str(self.path_id) + ',' +
-                                        str(origin_id)    + ',' +
-                                        str(frame_id)     + ']')
-
-        result = SpicePath(self.spice_target_id, spice_origin_id,
-                           spice_frame_name, self.path_id, shortcut)
-
-        # If the path uses a non-spice frame, add a rotated version
-        if not uses_spiceframe:
-            shortcut = ('SHORTCUT_' + str(self.path_id) + '_' +
-                                      str(origin_id)    + '_' +
-                                      str(frame.frame_id))
-            result = RotatedPath(result, frame)
-            result.register(shortcut)
-
-        return result
-
-################################################################################
-# UNIT TESTS
-################################################################################
-
-# This is the opportunity to show that all Path and Frame operations produce
-# results that are consistent with the well-tested SPICE toolkit.
-
-import unittest
 
 class Test_SpicePath(unittest.TestCase):
 
     def runTest(self):
 
-      # Imports are here to avoid conflicts
-      import os
-      import oops.constants as constants
-      from oops.frame.spiceframe import SpiceFrame
-      from oops.unittester_support import TESTDATA_PARENT_DIRECTORY
-
       Path.USE_QUICKPATHS = False
       Frame.USE_QUICKFRAMES = False
 
       cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, "SPICE/pck00010.tpc"))
       cspyce.furnsh(os.path.join(TESTDATA_PARENT_DIRECTORY, "SPICE/de421.bsp"))
 
       # Repeat the tests without and then with shortcuts
```

### Comparing `rms_oops-0.0.3/oops/spice_support.py` & `rms_oops-0.0.4/oops/spice_support.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,16 +1,17 @@
 ################################################################################
 # oops/spice_support.py
 ################################################################################
 
 import numbers
+
 import cspyce
 import spicedb
 
-from oops.path import Path
+from oops.path.path_ import Path
 
 # Maintain dictionaries that translate names in the SPICE toolkit into their
 # corresponding names in the Frame and Path registries.
 
 FRAME_TRANSLATION = {'J2000':'J2000', cspyce.namfrm('J2000'):'J2000'}
 PATH_TRANSLATION = {'SSB':'SSB', 0:'SSB', 'SOLAR SYSTEM BARYCENTER':'SSB'}
 
@@ -136,23 +137,7 @@
 def initialize():
     global FRAME_TRANSLATION, PATH_TRANSLATION
 
     FRAME_TRANSLATION = {'J2000':'J2000', cspyce.namfrm('J2000'):'J2000'}
     PATH_TRANSLATION = {'SSB':'SSB', 0:'SSB', 'SOLAR SYSTEM BARYCENTER':'SSB'}
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_tools(unittest.TestCase):
-
-    def runTest(self):
-
-        # TBD
-        pass
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/surface/__init__.py` & `rms_oops-0.0.4/tests/surface/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 ################################################################################
-# oops/surface/__init__.py: Abstract class Surface
+# tests/surface/__init__.py: Abstract class Surface
 ################################################################################
 
 import numbers
 import numpy as np
 
 from polymath       import Boolean, Qube, Scalar, Vector3
 from oops.config    import SURFACE_PHOTONS, LOGGING
```

### Comparing `rms_oops-0.0.3/oops/surface/ansa.py` & `rms_oops-0.0.4/oops/surface/orbitplane.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,480 +1,425 @@
 ################################################################################
-# oops/surface/ansa.py: Ansa subclass of class Surface
+# oops/surface/orbitplane.py: OrbitPlane subclass of class Surface
 ################################################################################
 
 import numpy as np
-from polymath               import Scalar, Vector3
-from oops.frame             import Frame
-from oops.path              import Path
-from oops.surface           import Surface
-from oops.surface.ringplane import RingPlane
-
-class Ansa(Surface):
-    """This surface is defined as the locus of points where a radius vector from
-    the pole of the Z-axis is perpendicular to the line of sight. This provides
-    a convenient coordinate system for describing rings when viewed nearly
-    edge-on. The coordinates are (r,z,theta) where
-        r       radial distance from the Z-axis, positive on the "right" side
-                (if Z is pointing "up"); negative on the left side.
-        z       vertical distance from the (x,y) plane.
-        theta   angular distance from the ansa, with positive values further
-                away from the observer and negative values closer.
-    """
-
-    COORDINATE_TYPE = 'cylindrical'
-    IS_VIRTUAL = True
-
-    #===========================================================================
-    def __init__(self, origin, frame, gravity=None, ringplane=None, radii=None):
-        """Constructor for an Ansa Surface.
-
-        Input:
-            origin      a Path object or ID defining the motion of the center
-                        of the ring system.
 
-            frame       a Frame object or ID in which the ring plane is the
-                        (x,y) plane (where z == 0).
+from polymath                 import Scalar, Vector3
+from oops.constants           import PI, TWOPI
+from oops.frame.frame_        import Frame
+from oops.frame.inclinedframe import InclinedFrame
+from oops.frame.spinframe     import SpinFrame
+from oops.path.path_          import Path
+from oops.path.circlepath     import CirclePath
+from oops.surface.surface_    import Surface
+from oops.surface.ringplane   import RingPlane
+
+class OrbitPlane(Surface):
+    """A subclass of the Surface class describing a flat surface sharing its
+    geometric center and tilt with a body on an eccentric and/or inclined orbit.
+    The orbit is described as circle offset from the center of the planet by a
+    distance ae; this approximation is only accurate to first order in
+    eccentricty.
+
+    The coordinate system consists of cylindrical coordinates (a, theta, z)
+    where a is the mean radius of the orbit. The zero of longitude is aligned
+    with the pericenter.
 
-            gravity     an optional Gravity object, used to define the orbital
-                        velocities relative to the surface.
+    The system is masked outside the semimajor axis, but unmasked inside.
+    However, coordinates and intercepts are calculated at all locations.
+    """
 
-            ringplane   an optional RingPlane object associated with this Ansa
-                        surface. If provided, this surface inherits the gravity
-                        field and radial limits of the RingPlane, unless they
-                        are given as input.
+    COORDINATE_TYPE = 'polar'
+    IS_VIRTUAL = False
 
+    #===========================================================================
+    def __init__(self, elements, epoch, origin, frame, path_id=None,
+                       radii=None):
+        """Constructor for an OrbitPlane surface.
+
+            elements    a tuple containing three, six or nine orbital elements:
+                a           mean radius of orbit, km.
+                lon         mean longitude at epoch of a reference object, in
+                            radians. This is provided if the user wishes to
+                            track a moving body in the plane. However, it does
+                            not affect the surface or its coordinate system.
+                n           mean motion of a body orbiting within the ring, in
+                            radians/sec. This affects velocities returned by
+                            the surface but not the surface or its coordinate
+                            system.
+
+                e           orbital eccentricity.
+                peri        longitude of pericenter at epoch, radians.
+                prec        pericenter precession rate, radians/sec.
+
+                i           inclination, radians.
+                node        longitude of ascending node at epoch, radians.
+                regr        nodal regression rate, radians/sec, NEGATIVE!
+
+            epoch       the time TDB relative to which all orbital elements are
+                        defined.
+            origin      the path or ID of the planet center.
+            frame       the frame or ID of the frame in which the orbit is
+                        defined. Should be inertial.
+            path_id     the ID under which to register the orbit path; None to
+                        leave it unregistered
             radii       the nominal inner and outer radii of the ring, in km.
                         None for a ring with no radial limits.
+
+        Note that the origin and frame used by the returned OrbitPlane object
+        will differ from those used to define it here.
         """
 
-        self.origin  = Path.as_waypoint(origin)
-        self.frame   = Frame.as_wayframe(frame)
+        # Save the initial center path and frame. The frame should be inertial.
+        self.defined_origin = Path.as_waypoint(origin)
+        self.defined_frame  = Frame.as_wayframe(frame)
+        if self.defined_frame.origin is not None:
+            raise ValueError('frame of an OrbitPlane must be inertial')
+
+        # We will update the surface's actual path and frame as needed
+        self.internal_origin = self.defined_origin
+        self.internal_frame  = self.defined_frame
+
+        # Save the orbital elements
+        self.elements = np.asfarray(elements)
+        self.a     = elements[0]
+        self.lon   = elements[1]
+        self.n     = elements[2]
+        self.epoch = float(epoch)
 
         if radii is None:
             self.radii = None
         else:
-            self.radii = np.asfarray(radii)
+            self.radii    = np.asfarray(radii)
+            self.radii_sq = self.radii**2
+
+        # Interpret the inclination
+        self.has_inclination = (len(elements) >= 9)
+        if self.has_inclination:
+            self.i = elements[6]
+            self.has_inclination = (self.i != 0)
+
+        # If the orbit is inclined, define a special-purpose inclined frame
+        if self.has_inclination:
+            if path_id is None:
+                frame_id = None
+            else:
+                frame_id = path_id + '_INCLINATION'
+
+            self.inclined_frame = InclinedFrame(inc = elements[6],
+                                                node = elements[7],
+                                                rate = elements[8],
+                                                epoch = self.epoch,
+                                                reference = self.internal_frame,
+                                                despin = True,
+                                                frame_id = frame_id)
+            self.internal_frame = self.inclined_frame
+        else:
+            self.inclined_frame = None
+
+        # The inclined frame changes its tilt relative to the equatorial plane,
+        # accounting for nodal regression, but does not change the reference
+        # longitude from that used by the initial frame.
+
+        # Interpret the eccentricity
+        self.has_eccentricity = (len(elements) >= 6)
+        if self.has_eccentricity:
+            self.e = elements[3]
+            self.has_eccentricity = (self.e != 0)
+
+        # If the orbit is eccentric, construct a special-purpose path defining
+        # the center of the displaced ring
+        if self.has_eccentricity:
+            self.ae = self.a * self.e
+            self.lon_sub_peri = self.lon - elements[4]
+            self.n_sub_prec = self.n - elements[5]
+
+            if path_id is None:
+                new_path_id = None
+            else:
+                new_path_id = path_id + '_ECCENTRICITY'
+
+            self.peri_path = CirclePath(radius = elements[0] * elements[3],# a*e
+                                        lon = elements[4] + PI,     # apocenter
+                                        rate = elements[5],         # precession
+                                        epoch = self.epoch,
+                                        origin = self.internal_origin,
+                                        frame = self.internal_frame,
+                                        path_id = new_path_id)
+            self.internal_origin = self.peri_path
+
+            # The peri_path circulates around the initial origin but does not
+            # rotate.
+
+            if path_id is None:
+                frame_id = None
+            else:
+                frame_id = path_id + '_PERICENTER'
+
+            self.spin_frame = SpinFrame(offset = elements[4],       # pericenter
+                                        rate = elements[5],         # precession
+                                        epoch = self.epoch,
+                                        axis = 2,
+                                        reference = self.internal_frame,
+                                        frame_id = frame_id)
+            self.internal_frame = self.spin_frame
 
-        self._state_ringplane = ringplane
-        if ringplane is None:
-            self.ringplane = RingPlane(self.origin, self.frame, radii=radii,
-                                       gravity=gravity)
         else:
-            self.ringplane = ringplane
+            self.peri_path = None
+            self.spin_frame = None
+
+        self.ringplane = RingPlane(origin = self.internal_origin,
+                                   frame = self.internal_frame,
+                                   radii = self.radii,
+                                   gravity = None,
+                                   elevation = 0.)
+
+        # The primary origin and frame for the orbit
+        self.origin = self.internal_origin.waypoint
+        self.frame = self.internal_frame.wayframe
 
-        if gravity is None:
-            self.gravity = self.ringplane.gravity
+        # Unique key for intercept calculations
+        # ('ring', origin, frame, elevation, i, node, dnode_dt, epoch)
+        if self.has_inclination:
+            extras = tuple(elements[6:9]) + (self.epoch,)
         else:
-            self.gravity = gravity
+            extras = (0., 0., 0., 0.)
+
+        self.intercept_key = ('ring', self.defined_origin.waypoint,
+                                      self.defined_frame.wayframe,
+                                      0.) + extras
 
         # Save the unmasked version of this surface
         if self.radii is None:
             self.unmasked = self
         else:
-            self.unmasked = Ansa(self.origin, self.frame,
-                                 gravity=self.gravity,
-                                 ringplane=self.ringplane,
-                                 radii=None)
-
-        # Unique key for intercept calculations
-        self.intercept_key = ('ansa', self.origin.waypoint,
-                                      self.frame.wayframe)
+            self.unmasked = OrbitPlane.__new__(type(OrbitPlane))
+            self.unmasked.__dict__ = self.__dict__.copy()
+            self.unmasked.radii = None
 
     def __getstate__(self):
-        return (Path.as_primary_path(self.origin),
-                Frame.as_primary_frame(self.frame),
-                self.gravity, self._state_ringplane, tuple(self.radii))
+        return (tuple(self.elements), self.epoch,
+                Path.as_primary_path(self.defined_origin),
+                Frame.as_primary_frame(self.defined_frame),
+                None, self.radii)
 
     def __setstate__(self, state):
         self.__init__(*state)
 
     #===========================================================================
-    @staticmethod
-    def for_ringplane(ringplane):
-        """Construct an Ansa Surface associated with a given RingPlane, ignoring
-        any modes.
-
-        Input:
-            ringplane   a ringplane surface relative to which this ansa surface
-                        is to be defined.
-        """
-
-        return Ansa(ringplane.origin, ringplane.frame, gravity=ringplane.gravity,
-                    ringplane=ringplane, radii=ringplane.radii)
-
-    #===========================================================================
     def coords_from_vector3(self, pos, obs=None, time=None, axes=2,
-                                  derivs=False, hints=None):
+                                       derivs=False, hints=None):
         """Surface coordinates associated with a position vector.
 
         Input:
             pos         a Vector3 of positions at or near the surface, relative
                         to this surface's origin and frame.
             obs         a Vector3 of observer position relative to this
-                        surface's origin and frame.
+                        surface's origin and frame; ignored for this Surface
+                        subclass.
             time        a Scalar time at which to evaluate the surface.
             axes        2 or 3, indicating whether to return the first two
-                        coordinates (rad, z) or all three (rad, z, theta) as
+                        coordinates (rad, theta) or all three (rad, theta, z) as
                         Scalars.
             derivs      True to propagate any derivatives inside pos and obs
                         into the returned coordinates.
             hints       ignored. Provided for compatibility with other Surface
                         subclasses.
 
         Return:         coordinate values packaged as a tuple containing two or
                         three Scalars, one for each coordinate.
-            rad         projected distance from the body pole, in km.
-            z           projected vertical distance above the ring plane, in km.
-            theta       longitude of the intercept point, in radians; included
+            rad         mean orbital radius in the ring plane, in km.
+            theta       mean longitude in radians of the intercept point.
+            z           vertical distance in km above the orbit plane; included
                         if axes == 3.
         """
 
-        # Validate inputs
-        self._coords_from_vector3_check(axes)
-
-        pos = Vector3.as_vector3(pos, derivs)
-        obs = Vector3.as_vector3(obs, derivs)
-        (pos_x, pos_y, pos_z) = pos.to_scalars()
-        (obs_x, obs_y, obs_z) = obs.to_scalars()
-
-        rabs   = (pos_x**2 + pos_y**2).sqrt()
-        obs_xy = (obs_x**2 + obs_y**2).sqrt()
-
-        # Find the longitude of pos relative to obs
-        lon = pos_y.arctan2(pos_x) - obs_y.arctan2(obs_x)
-
-        # Put it in the range -pi to pi
-        lon = ((lon + Scalar.PI) % Scalar.TWOPI) - Scalar.PI
-        sign = lon.sign()
-        r = rabs * sign
-
-        # Apply mask as needed
-        if self.radii is not None:
-            mask = r.tvl_lt(self.radii[0]) | r.tvl_gt(self.radii[1])
-            if mask.any():
-                r = r.remask_or(mask.vals)
-                pos_z = pos_z.remask(r.mask)
-
-        # Fill in the third coordinate if necessary
-        if axes > 2:
-            # As discussed in the math found below with vector3_from_coords(),
-            # the ansa longitude relative to the observer is:
-
-            phi = (rabs / obs_xy).arccos()
-            theta = sign*lon - phi
-            if self.radii is not None:
-                theta.remask(r.mask)
-
-            return (r, pos_z, theta)
-
-        return (r, pos_z)
+        return self.ringplane.coords_from_vector3(pos, axes=axes, time=time,
+                                                  derivs=derivs)
 
     #===========================================================================
-    def vector3_from_coords(self, coords, obs, time=None, derivs=False):
+    def vector3_from_coords(self, coords, obs=None, time=None, derivs=False):
         """The position where a point with the given coordinates falls relative
         to this surface's origin and frame.
 
         Input:
             coords      a tuple of two or three Scalars defining coordinates at
                         or near this surface. These can have different shapes,
                         but must be broadcastable to a common shape.
-                rad     projected distance in km from the body pole.
-                z       projected vertical distance in km above the ring plane.
-                theta   longitude in radians of the intercept point.
+                rad     mean orbital radius in the ring plane, in km.
+                theta   mean longitude in radians of the intercept point.
+                z       vertical distance in km above the orbit plane.
             obs         a Vector3 of observer position relative to this
-                        surface's origin and frame.
-            time        a Scalar time at which to evaluate the surface; ignored
-                        by this Surface subclass.
+                        surface's origin and frame; ignored for this Surface
+                        subclass.
+            time        a Scalar time at which to evaluate the surface.
             derivs      True to propagate any derivatives inside the coordinates
                         and obs into the returned position vectors.
 
         Return:         a Vector3 of points defined by the coordinates, relative
                         to this surface's origin and frame.
         """
 
-        # Validate inputs
-        self._vector3_from_coords_check(coords)
-
-        # Given (r,z, theta) and the observer position, solve for position.
-        #   pos = (|r| cos(a), |r| sin(a), z)
-        # where angle a is defined by the location of the observer.
-        #
-        # theta = 0 at the ansa, where los and pos are perpendicular.
-        # theta < 0 for points closer along the los, > 0 for points further.
-        #
-        # First solve for a where theta = 0.
-        #
-        #   pos_xy dot (obs_xy - pos_xy) = 0
-        #   pos_xy dot pos_xy = pos_xy dot obs_xy
-        #   r**2 = |r| cos(a) obs_x + |r| sin(a) obs_y
-        #
-        # For convenience, define the coordinate system so that obs falls on the
-        # (x,z) plane, so obs_y = 0 and obs_x > 0.
-        #
-        #   r**2 = |r| obs_x cos(a)
-        #
-        #   cos(a) = |r| / obs_x
-        #
-        #   a = sign * arccos(|r| / obs_x)
-        #
-        # Define phi as the arccos term:
-        #
-        #   a = sign * phi(r,obs_x)
-        #
-        # Two solutions exist, symmetric about the (x,z) plane, as expected. The
-        # positive sign corresponds to ring longitudes ahead of the observer,
-        # which we define as the "right" ansa. The negative sign identifies the
-        # "left" ansa.
-        #
-        # Theta is an angular offset from phi, with smaller values closer to the
-        # observer and larger angles further away.
-
-        r = Scalar.as_scalar(coords[0], derivs)
-        z = Scalar.as_scalar(coords[1], derivs)
-
-        sign = r.sign()
-        rabs = r * sign
-
-        if len(coords) == 2:
-            theta = Scalar(0.)
-        else:
-            theta = Scalar.as_scalar(coords[2], derivs)
-
-        (obs_x, obs_y, obs_z) = Vector3.as_vector(obs, derivs).to_scalars()
-        obs_xy = (obs_x**2 + obs_y**2).sqrt()
-
-        phi = (rabs / obs_xy).arccos()
-
-        pos_lon = obs_y.arctan2(obs_x) + sign * (phi + theta)
-
-        pos = Vector3.from_scalars(rabs * pos_lon.cos(),
-                                   rabs * pos_lon.sin(), z)
-        return pos
+        return self.ringplane.vector3_from_coords(coords, time=time,
+                                                  derivs=derivs)
 
     #===========================================================================
     def intercept(self, obs, los, time=None, direction='dep', derivs=False,
                                   guess=None, hints=None):
         """The position where a specified line of sight intercepts the surface.
 
         Input:
             obs         observer position as a Vector3 relative to this
                         surface's origin and frame.
             los         line of sight as a Vector3 in this surface's frame.
-            time        a Scalar time at which to evaluate the surface; ignored
-                        by this Surface subclass.
+            time        a Scalar time at the surface.
             direction   'arr' for a photon arriving at the surface; 'dep' for a
-                        photon departing from the surface; ignored here.
+                        photon departing from the surface; ignored.
             derivs      True to propagate any derivatives inside obs and los
                         into the returned intercept point.
             guess       unused.
             hints       if not None (the default), this value is appended to the
                         returned tuple. Needed for compatibility with other
                         Surface subclasses.
 
         Return:         a tuple (pos, t) or (pos, t, hints), where
             pos         a Vector3 of intercept points on the surface relative
                         to this surface's origin and frame, in km.
             t           a Scalar such that:
-                            intercept = obs + t * los
+                            position = obs + t * los
             hints       the input value of hints, included if it is not None.
         """
 
-        obs = Vector3.as_vector3(obs, derivs)
-        los = Vector3.as_vector3(los, derivs)
-
-        # (obs_xy + t los_xy) dot los_xy = 0
-        # t = -(obs_xy dot los_xy) / (los_xy dot los_xy)
-        # pos = obs + t * los
-
-        obs_x = obs.to_scalar(0)
-        obs_y = obs.to_scalar(1)
-        los_x = los.to_scalar(0)
-        los_y = los.to_scalar(1)
-
-        los_sq = los_x**2 + los_y**2
-
-        obs_dot_los = obs_x * los_x + obs_y * los_y
-        t = -obs_dot_los / los_sq
-
-        pos = obs + t * los
-
-        if hints is not None:
-            return (pos, t, hints)
-
-        return (pos, t)
+        return self.ringplane.intercept(obs, los, time=time, derivs=derivs,
+                                        guess=guess, hints=hints)
 
     #===========================================================================
     def normal(self, pos, time=None, derivs=False):
         """The normal vector at a position at or near a surface.
 
         Input:
             pos         a Vector3 of positions at or near the surface relative
                         to this surface's origin and frame.
-            time        a Scalar time at which to evaluate the surface.
+            time        a Scalar time at which to evaluate the surface; ignored.
             derivs      True to propagate any derivatives of pos into the
                         returned normal vectors.
 
         Return:         a Vector3 containing directions normal to the surface
                         that pass through the position. Lengths are arbitrary.
+        """
+
+        return self.ringplane.normal(pos, time=time, derivs=derivs)
+
+    #===========================================================================
+    def velocity(self, pos, time=None):
+        """The local velocity vector at a point within the surface.
+
+        This can be used to describe the orbital motion of ring particles or
+        local wind speeds on a planet.
+
+        Input:
+            pos         a Vector3 of positions at or near the surface relative
+                        to this surface's origin and frame.
+            time        a Scalar time at which to evaluate the surface; ignored.
 
-        NOTE: We define this as the ansa normal as the ring plane normal so that
-        incidence and emission angles are the same as those for the associated
-        ring plane.
+        Return:         a Vector3 of velocities, in units of km/s.
         """
 
-        pos = Vector3.as_vector3(pos, derivs)
+        if self.has_eccentricity:
+            # For purposes of a first-order velocity calculation, we can assume
+            # that the difference between mean longitude and true longitude, in
+            # a planet-centered frame, is small.
+            #
+            # In an inertial, planet-centered frame:
+            #
+            # r = a - ae cos(lon - peri)
+            # lon = lon0 + n * (time - epoch) + 2ae sin(lon - peri)
+            #
+            # dr/dt = ae sin(lon - peri) (n - prec)
+            # dlon/dt = n + 2ae cos(n - peri) (n - prec)
+            #
+            # In a frame rotating at rate = prec:
+            #
+            # dr/dt = ae sin(lon - peri) (n - prec)
+            # dlon/dt = (n - prec) + 2ae cos(lon - peri) (n - prec)
+            #
+            # x = r cos(lon)
+            # y = r sin(lon)
+            #
+            # dx/dt = dr/dt * cos(lon) - r sin(lon) dlon/dt
+            # dy/dy = dr/dt * sin(lon) + r cos(lon) dlon/dt
+
+            (x,y,z) = pos.to_scalars()
+            x = x + self.ae         # shift origin to center of planet
+
+            r = (x**2 + y**2).sqrt()
+            cos_lon_sub_peri = x/r
+            sin_lon_sub_peri = y/r
 
-        # Always the Z-axis
-        return pos.all_constant((0.,0.,1.))
+            dr_dt = sin_lon_sub_peri * (self.ae * self.n_sub_prec)
+            r_dlon_dt = r * self.n_sub_prec * (cos_lon_sub_peri * 2*self.ae + 1)
 
-################################################################################
-# UNIT TESTS
-################################################################################
+            dx_dt = dr_dt * cos_lon_sub_peri - r_dlon_dt * sin_lon_sub_peri
+            dy_dt = dr_dt * sin_lon_sub_peri + r_dlon_dt * cos_lon_sub_peri
+
+            return Vector3.from_scalars(dx_dt, dy_dt, 0.)
+
+        else:
+            return self.n * Vector3.ZAXIS.cross(pos)
+
+    ############################################################################
+    # Longitude-anomaly conversions
+    ############################################################################
+
+    def from_mean_anomaly(self, anom):
+        """The longitude in this frame based on the mean anomaly.
+
+        Accurate to first order in eccentricity.
+        """
+
+        anom = Scalar.as_scalar(anom)
+
+        if not self.has_eccentricity:
+            return anom
+        else:
+            return anom + (2*self.ae) * anom.sin()
+
+    #===========================================================================
+    def to_mean_anomaly(self, lon):
+        """The mean anomaly given an orbital longitude.
+
+        Accurate to first order in eccentricity. Iteration is performed using
+        Newton's method to ensure that this function is an exact inverse of
+        from_mean_anomaly().
+        """
+
+        lon = Scalar.as_scalar(lon)
+        if not self.has_eccentricity:
+            return lon
+
+        # Solve lon = x + 2ae sin(x)
+        #
+        # Let
+        #   y(x) = x + 2ae sin(x) - lon
+        #
+        #   dy/dx = 1 + 2ae cos(x)
+        #
+        # For x[n] as a guess at n,
+        #   x[n+1] = x[n] - y(x[n]) / dy/dx
 
-import unittest
-from oops.constants import PI, HALFPI
+        ae_x2 = 2 * self.ae
+        x = lon - ae_x2 * lon.sin()
 
-class Test_Ansa(unittest.TestCase):
+        # Iterate until all improvement ceases. Should not take long
+        prev_max_abs_dx = TWOPI
+        max_abs_dx = PI
+        while (max_abs_dx < prev_max_abs_dx):
+            dx = (lon - x - ae_x2 * x.sin()) / (x.cos() * ae_x2 + 1)
+            x += dx
 
-    def runTest(self):
+            prev_max_abs_dx = max_abs_dx
+            max_abs_dx = abs(dx).max()
 
-        np.random.seed(7742)
+        return x
 
-        surface = Ansa('SSB', 'J2000')
-
-        # intercept()
-        obs = Vector3( np.random.rand(10,3) * 1.e5)
-        los = Vector3(-np.random.rand(10,3))
-
-        (pos,t) = surface.intercept(obs, los)
-        pos_xy = pos.element_mul((1,1,0))
-        los_xy = los.element_mul((1,1,0))
-
-        self.assertTrue(abs(pos_xy.sep(los_xy) - HALFPI).max() < 1.e-8)
-        self.assertTrue(abs(obs + t * los - pos).max() < 1.e-8)
-
-        # coords_from_vector3()
-        obs = Vector3(np.random.rand(100,3) * 1.e6)
-        pos = Vector3(np.random.rand(100,3) * 1.e5)
-
-        (r,z) = surface.coords_from_vector3(pos, obs, axes=2)
-
-        pos_xy = pos.element_mul(Vector3((1,1,0)))
-        pos_z  = pos.to_scalar(2)
-        self.assertTrue(abs(pos_xy.norm() - abs(r)).max() < 1.e-8)
-        self.assertTrue(abs(pos_z - z).max() < 1.e-8)
-
-        (r,z,theta) = surface.coords_from_vector3(pos, obs, axes=3)
-
-        pos_xy = pos.element_mul(Vector3((1,1,0)))
-        pos_z  = pos.to_scalar(2)
-        self.assertTrue(abs(pos_xy.norm() - abs(r)).max() < 1.e-8)
-        self.assertTrue(abs(pos_z - z).max() < 1.e-8)
-        self.assertTrue(abs(theta).max() <= PI)
-
-        # vector3_from_coords()
-        obs = Vector3(1.e-5 + np.random.rand(100,3) * 1.e6)
-        r = Scalar(1.e-4 + np.random.rand(100) * 9e-4)
-        z = Scalar((2 * np.random.rand(100) - 1) * 1.e5)
-        theta = Scalar(np.random.rand(100))
-
-        pos = surface.vector3_from_coords((r,z), obs)
-
-        pos_xy = pos.element_mul(Vector3((1,1,0)))
-        pos_z  = pos.to_scalar(2)
-        self.assertTrue(abs(pos_xy.norm() - abs(r)).max() < 1.e-8)
-        self.assertTrue(abs(pos_z - z).max() < 1.e-8)
-
-        obs_xy = obs.element_mul(Vector3((1,1,0)))
-        self.assertTrue(abs(pos_xy.sep(obs_xy - pos_xy) - HALFPI).max() < 1.e-5)
-
-        pos1 = surface.vector3_from_coords((r,z,theta), obs)
-        pos1_xy = pos1.element_mul(Vector3((1,1,0)))
-        self.assertTrue(abs(pos1_xy.sep(pos_xy) - theta).max() < 1.e-5)
-
-        pos1 = surface.vector3_from_coords((r,z,-theta), obs)
-        pos1_xy = pos1.element_mul(Vector3((1,1,0)))
-        self.assertTrue(abs(pos1_xy.sep(pos_xy) - theta).max() < 1.e-5)
-
-        pos = surface.vector3_from_coords((-r,z), obs)
-        pos_xy = pos.element_mul(Vector3((1,1,0)))
-
-        pos1 = surface.vector3_from_coords((-r,z,-theta), obs)
-        pos1_xy = pos1.element_mul(Vector3((1,1,0)))
-        self.assertTrue(abs(pos1_xy.sep(pos_xy) - theta).max() < 1.e-5)
-
-        pos1 = surface.vector3_from_coords((-r,z,theta), obs)
-        pos1_xy = pos1.element_mul(Vector3((1,1,0)))
-        self.assertTrue(abs(pos1_xy.sep(pos_xy) - theta).max() < 1.e-5)
-
-        # vector3_from_coords() & coords_from_vector3()
-        obs = Vector3((1.e6,0,0))
-        r = Scalar(1.e4 + np.random.rand(100) * 9.e4)
-        r *= np.sign(2 * np.random.rand(100) - 1)
-        z = Scalar((2 * np.random.rand(100) - 1) * 1.e5)
-        theta = Scalar((2 * np.random.rand(100) - 1) * 1.)
-
-        pos = surface.vector3_from_coords((r,z,theta), obs)
-        coords = surface.coords_from_vector3(pos, obs, axes=3)
-        self.assertTrue(abs(r - coords[0]).max() < 1.e-5)
-        self.assertTrue(abs(z - coords[1]).max() < 1.e-5)
-        self.assertTrue(abs(theta - coords[2]).max() < 1.e-8)
-
-        obs = Vector3(np.random.rand(100,3) * 1.e6)
-        pos = Vector3(np.random.rand(100,3) * 1.e5)
-        coords = surface.coords_from_vector3(pos, obs, axes=3)
-        test_pos = surface.vector3_from_coords(coords, obs)
-        self.assertTrue(abs(test_pos - pos).max() < 1.e-5)
-
-        # intercept() derivatives
-        obs = Vector3(np.random.rand(10,3))
-        obs.insert_deriv('obs', Vector3.IDENTITY)
-        los = Vector3(-np.random.rand(10,3))
-        los.insert_deriv('los', Vector3.IDENTITY)
-        (pos0,t0) = surface.intercept(obs, los, derivs=True)
-
-        eps = 1e-6
-        (pos1,t1) = surface.intercept(obs + (eps,0,0), los, derivs=False)
-        dpos_dobs_test = (pos1 - pos0) / eps
-        dt_dobs_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dobs_test - pos0.d_dobs.vals[...,0]).max() < 1.e-6)
-        self.assertTrue(abs(dt_dobs_test - t0.d_dobs.vals[...,0]).max() < 1.e-6)
-
-        (pos1,t1) = surface.intercept(obs + (0,eps,0), los, derivs=False)
-        dpos_dobs_test = (pos1 - pos0) / eps
-        dt_dobs_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dobs_test - pos0.d_dobs.vals[...,1]).max() < 1.e-5)
-        self.assertTrue(abs(dt_dobs_test - t0.d_dobs.vals[...,1]).max() < 1.e-6)
-
-        (pos1,t1) = surface.intercept(obs + (0,0,eps), los, derivs=False)
-        dpos_dobs_test = (pos1 - pos0) / eps
-        dt_dobs_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dobs_test - pos0.d_dobs.vals[...,2]).max() < 1.e-5)
-        self.assertTrue(abs(dt_dobs_test - t0.d_dobs.vals[...,2]).max() < 1.e-6)
-
-        eps = 1e-6
-        (pos1,t1) = surface.intercept(obs, los + (eps,0,0), derivs=False)
-        dpos_dlos_test = (pos1 - pos0) / eps
-        dt_dlos_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dlos_test - pos0.d_dlos.vals[...,0]).max() < 1.e-2)
-        self.assertTrue(abs(dt_dlos_test - t0.d_dlos.vals[...,0]).max() < 1.e-2)
-
-        (pos1,t1) = surface.intercept(obs, los + (0,eps,0), derivs=False)
-        dpos_dlos_test = (pos1 - pos0) / eps
-        dt_dlos_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dlos_test - pos0.d_dlos.vals[...,1]).max() < 1.e-2)
-        self.assertTrue(abs(dt_dlos_test - t0.d_dlos.vals[...,1]).max() < 1.e-2)
-
-        (pos1,t1) = surface.intercept(obs, los + (0,0,eps), derivs=False)
-        dpos_dlos_test = (pos1 - pos0) / eps
-        dt_dlos_test = (t1 - t0) / eps
-        self.assertTrue(abs(dpos_dlos_test - pos0.d_dlos.vals[...,2]).max() < 1.e-2)
-        self.assertTrue(abs(dt_dlos_test - t0.d_dlos.vals[...,2]).max() < 1.e-2)
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/surface/centricspheroid.py` & `rms_oops-0.0.4/oops/surface/ringplane.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,432 +1,384 @@
 ################################################################################
-# oops/surface/centricspheroid.py: CentricSpheroid subclass of class Surface.
+# oops/surface/ringplane.py: RingPlane subclass of class Surface
 ################################################################################
 
 import numpy as np
-from polymath   import Scalar, Vector3
-from oops.frame import Frame
-from oops.path  import Path
-
-from oops.surface.centricellipsoid import CentricEllipsoid
-from oops.surface.ellipsoid        import Ellipsoid
-from oops.surface.spheroid         import Spheroid
 
-class CentricSpheroid(Spheroid):
-    """A variant of Spheroid in which latitudes are planetocentric."""
+from polymath                   import Scalar, Vector3
+from oops.frame.frame_          import Frame
+from oops.path.path_            import Path
+from oops.surface.surface_      import Surface
+from oops.gravity.oblategravity import OblateGravity
+
+class RingPlane(Surface):
+    """A subclass of Surface describing a flat surface in the (x,y) plane, in
+    which the optional velocity field is defined by circular Keplerian motion
+    about the center point. Coordinates are cylindrical (radius, longitude,
+    elevation), with an optional offset in elevation from the equatorial (z=0)
+    plane.
+
+    Optional modes can be used to apply sinusoidal offset patterns in the radial
+    coordinate.
+    """
+
+    COORDINATE_TYPE = 'polar'
+    IS_VIRTUAL = False
+
+    #===========================================================================
+    def __init__(self, origin, frame, radii=None, gravity=None,
+                       elevation=0., modes=[], epoch=0.):
+        """Constructor for a RingPlane surface.
+
+        Input:
+            origin      a Path object or ID defining the motion of the center
+                        of the ring plane.
+
+            frame       a Frame object or ID in which the ring plane is the
+                        (x,y) plane (where z = 0).
+
+            radii       the nominal inner and outer radii of the ring, in km.
+                        None for a ring with no radial limits.
+
+            gravity     an optional Gravity object, used to define the orbital
+                        velocities within the plane.
+
+            elevation   an optional offset of the ring plane in the direction of
+                        positive rotation, in km.
+
+            modes       an optional list of zero or more radial modes in the
+                        ring. Each mode is described by a tuple of four
+                        parameters (cycles, amp, peri0, speed):
+                            cycles  the number of radial cycles around the ring.
+                            amp     radial amplitude in km.
+                            peri0   longitude of one radial minimum at epoch, in
+                                    radians.
+                            speed   the pattern speed in radians per second.
+
+            epoch       the epoch at which the radial mode parameters apply.
+                        Not used unless radial modes are present.
+         """
+
+        self.origin    = Path.as_waypoint(origin)
+        self.frame     = Frame.as_wayframe(frame)
+        self.gravity   = gravity
+        self.elevation = float(elevation)
+        self.modes     = modes
+        self.epoch     = float(epoch)
+
+        if radii is None:
+            self.radii = None
+        else:
+            self.radii    = np.asfarray(radii)
+            self.radii_sq = self.radii**2
+
+        # Save the unmasked version of this surface
+        if radii is None:
+            self.unmasked = self
+        else:
+            self.unmasked = RingPlane(self.origin, self.frame,
+                                      radii = None,
+                                      gravity = self.gravity,
+                                      elevation = self.elevation,
+                                      modes = self.modes,
+                                      epoch = self.epoch)
+
+        # Identify the maximum orbital rate by any means necessary; without this
+        # limit, speeds near the origin get ridiculous.
+        if self.radii is not None:
+            r = self.radii[0]
+            self.max_rate = self.gravity.n(r)
+        elif hasattr(self.gravity, 'rp'):
+            r = self.gravity.rp
+            self.max_rate = self.gravity.n(r)
+        else:
+            # If we can't figure out the planet, clamp the rate at that for an
+            # orbit skimming the surface of Neptune. (Note that this rate is
+            # faster than that for Jupiter, Saturn, or Uranus.)
+            neptune = OblateGravity.NEPTUNE
+            self.max_rate = neptune.n(neptune.rp)
+
+        # Unique key for intercept calculations
+        # ('ring', origin, frame, elevation, i, node, dnode_dt, epoch)
+        # Extra elements are so OrbitPlane and RingPlane can share the same
+        # key in situations where the orbit is not inclined.
+        self.intercept_key = ('ring', self.origin.waypoint,
+                                      self.frame.wayframe,
+                                      self.elevation, 0., 0., 0., 0.)
+
+    def __getstate__(self):
+        return (Path.as_primary_path(self.origin),
+                Frame.as_primary_frame(self.frame),
+                None if self.radii is None else tuple(self.radii),
+                self.gravity, self.elevation, self.modes, self.epoch)
+
+    def __setstate__(self, state):
+        self.__init__(*state)
 
     #===========================================================================
     def coords_from_vector3(self, pos, obs=None, time=None, axes=2,
-                                  derivs=False, hints=None, groundtrack=False):
+                                       derivs=False, hints=None):
         """Surface coordinates associated with a position vector.
 
         Input:
             pos         a Vector3 of positions at or near the surface, relative
                         to this surface's origin and frame.
             obs         a Vector3 of observer position relative to this
                         surface's origin and frame; ignored for this Surface
                         subclass.
             time        a Scalar time at which to evaluate the surface; ignored
-                        for this Surface subclass.
+                        unless this RingPlane contains radial modes.
             axes        2 or 3, indicating whether to return the first two
-                        coordinates (lon, lat) or all three (lon, lat, z) as
+                        coordinates (rad, theta) or all three (rad, theta, z) as
                         Scalars.
             derivs      True to propagate any derivatives inside pos and obs
                         into the returned coordinates.
-            hints       optionally, the value of the coefficient p such that
-                            ground + p * normal(ground) = pos;
-                        ignored if the value is None (the default) or True.
-            groundtrack True to return the intercept on the surface along with
-                        the coordinates.
-
-        Return:         a tuple of two to four items:
-            lon         longitude at the surface in radians.
-            lat         latitude at the surface in radians.
-            z           vertical altitude in km normal to the surface; included
+            hints       ignored. Provided for compatibility with other Surface
+                        subclasses.
+
+        Return:         coordinate values packaged as a tuple containing two or
+                        three Scalars, one for each coordinate.
+            rad         mean orbital radius in the ring plane, in km.
+            theta       longitude in radians of the intercept point.
+            z           vertical distance in km above the ring plane; included
                         if axes == 3.
-            track       intercept point on the surface (where z == 0); included
-                        if input groundtrack is True.
         """
 
-        return CentricEllipsoid.coords_from_vector3(self, pos, axes=axes,
-                                                    derivs=derivs, hints=hints,
-                                                    groundtrack=groundtrack)
+        # Validate inputs
+        self._coords_from_vector3_check(axes)
+        pos = Vector3.as_vector3(pos, derivs)
+
+        # Generate cylindrical coordinates
+        (r, theta, z) = pos.to_cylindrical()
+
+        if self.modes:
+            a = r - self._mode_offset(theta, time, derivs=derivs)
+        else:
+            a = r
+
+        # Apply mask as needed
+        if self.radii is not None:
+            mask = a.tvl_lt(self.radii[0]) | a.tvl_gt(self.radii[1])
+#            if mask.any():
+            if mask.any_true_or_masked():       # this allows for fully masked results
+                a = a.remask_or(mask.vals)
+                theta = theta.remask(a.mask)
+                if axes > 2:
+                    z = z.remask(r.mask)
+
+        if axes == 2:
+            return (a, theta)
+        elif self.elevation == 0:
+            return (a, theta, z)
+        else:
+            return (a, theta, z - self.elevation)
 
     #===========================================================================
-    def vector3_from_coords(self, coords, obs=None, time=None, derivs=False,
-                                          groundtrack=False):
+    def vector3_from_coords(self, coords, obs=None, time=0., derivs=False):
         """The position where a point with the given coordinates falls relative
         to this surface's origin and frame.
 
         Input:
             coords      a tuple of two or three Scalars defining coordinates at
                         or near this surface. These can have different shapes,
                         but must be broadcastable to a common shape.
-                lon     longitude at the surface in radians.
-                lat     latitude at the surface in radians.
-                z       vertical altitude in km normal to the body surface.
+                rad     mean orbital radius in the ring plane, in km.
+                theta   longitude in radians of the intercept point.
+                z       vertical distance in km above the ring plane.
             obs         a Vector3 of observer position relative to this
                         surface's origin and frame; ignored for this Surface
                         subclass.
             time        a Scalar time at which to evaluate the surface; ignored
-                        for this Surface subclass.
+                        unless this RingPlane contains radial modes.
             derivs      True to propagate any derivatives inside the coordinates
                         and obs into the returned position vectors.
-            groundtrack True to include the associated groundtrack points on the
-                        body surface in the returned result.
 
-        Return:         pos or (pos, track), where
-            pos         a Vector3 of points defined by the coordinates, relative
+        Return:         a Vector3 of points defined by the coordinates, relative
                         to this surface's origin and frame.
-            track       intercept point on the surface (where z == 0); included
-                        if input groundtrack is True.
         """
 
         # Validate inputs
         self._vector3_from_coords_check(coords)
 
-        (lon, lat) = coords[:2]
-        squashed_lat = Spheroid.lat_from_centric(self, lat, derivs=derivs)
-        new_coords = (lon, squashed_lat,) + coords[2:]
+        a = Scalar.as_scalar(coords[0], derivs)
+        theta = Scalar.as_scalar(coords[1], derivs)
 
-        return Ellipsoid.vector3_from_coords(self, new_coords, derivs=derivs,
-                                                   groundtrack=groundtrack)
+        if self.modes:
+            r = a + self._mode_offset(theta, time, derivs=derivs)
+        else:
+            r = a
+
+        if len(coords) > 2:
+            z = Scalar.as_scalar(coords[2] + self.elevation, derivs)
+        else:
+            z = Scalar.as_scalar(self.elevation, derivs)
 
-    ############################################################################
-    # Latitude conversions
-    ############################################################################
+        x = r * theta.cos()
+        y = r * theta.sin()
 
-    def lat_to_centric(self, lat, lon=None, derivs=False):
-        """Convert latitude in internal coordinates to planetocentric.
+        return Vector3.from_scalars(x, y, z)
 
-        Input:
-            lat         planetocentric latitide, radians.
-            lon         ignored, included for compatibility with Ellipsoids.
-            derivs      True to include derivatives in returned result.
+    #===========================================================================
+    def intercept(self, obs, los, time=None, direction='dep', derivs=False,
+                                  guess=None, hints=None):
+        """The position where a specified line of sight intercepts the surface.
 
-        Return          planetocentric latitude.
+        Input:
+            obs         observer position as a Vector3 relative to this
+                        surface's origin and frame.
+            los         line of sight as a Vector3 in this surface's frame.
+            time        a Scalar time at the surface; ignored here.
+            direction   'arr' for a photon arriving at the surface; 'dep' for a
+                        photon departing from the surface; ignored here.
+            derivs      True to propagate any derivatives inside obs and los
+                        into the returned intercept point.
+            guess       unused.
+            hints       if not None (the default), this value is appended to the
+                        returned tuple. Needed for compatibility with other
+                        Surface subclasses.
+
+        Return:         a tuple (pos, t) or (pos, t, hints), where
+            pos         a Vector3 of intercept points on the surface relative
+                        to this surface's origin and frame, in km.
+            t           a Scalar such that:
+                            intercept = obs + t * los
+            hints       the input value of hints, included if hints is not None.
         """
 
-        return Scalar.as_scalar(lat, recursive=derivs)
+        # Solve for obs + factor * los for scalar t, such that the z-component
+        # equals zero.
+        obs = Vector3.as_vector3(obs, derivs)
+        los = Vector3.as_vector3(los, derivs)
+
+        obs_z = obs.to_scalar(2)
+        los_z = los.to_scalar(2)
+
+        t = (self.elevation - obs_z)/los_z
+        pos = obs + t * los
+
+        # Mask based on radial limits if necessary
+        if self.radii is not None:
+            r_sq = pos.norm_sq(False)
+            mask = (r_sq < self.radii_sq[0]) | (r_sq > self.radii_sq[1])
+            if np.any(mask):
+                pos = pos.remask_or(mask)
+            t = t.remask(pos.mask)
+
+        if hints is not None:
+            return (pos, t, hints)
+
+        return (pos, t)
 
     #===========================================================================
-    def lat_from_centric(self, lat, lon=None, derivs=False):
-        """Convert planetocentric latitude to internal coordinates.
+    def normal(self, pos, time=0., derivs=False):
+        """The normal vector at a position at or near a surface.
 
         Input:
-            lat         planetocentric latitide, radians.
-            lon         ignored, included for compatibility with Ellipsoids.
-            derivs      True to include derivatives in returned result.
+            pos         a Vector3 of positions at or near the surface relative
+                        to this surface's origin and frame.
+            time        a Scalar time at which to evaluate the surface; ignored
+                        here.
+            derivs      True to propagate any derivatives of pos into the
+                        returned normal vectors.
 
-        Return          planetocentric latitude.
+        Return:         a Vector3 containing directions normal to the surface
+                        that pass through the position. Lengths are arbitrary.
         """
 
-        return Scalar.as_scalar(lat, recursive=derivs)
+        pos = Vector3.as_vector3(pos, derivs)
 
-    #===========================================================================
-    def lat_to_graphic(self, lat, lon=None, derivs=False):
-        """Convert latitude in internal coordinates to planetographic.
+        # Always the Z-axis
+        perp = pos.all_constant((0.,0.,1.))
 
-        Input:
-            lat         planetocentric latitide, radians.
-            lon         ignored, included for compatibility with Ellipsoids.
-            derivs      True to include derivatives in returned result.
+        # The normal is undefined outside the ring's radial limits
+        if self.radii is not None:
+            r_sq = pos.norm_sq(False)
+            mask = (r_sq < self.radii_sq[0]) | (r_sq > self.radii_sq[1])
+            if np.any(mask):
+                perp = perp.remask_or(mask)
 
-        Return          planetographic latitude.
-        """
-
-        lat = Scalar.as_scalar(lat, recursive=derivs)
-        return (lat.tan() * self.unsquash_z_sq).arctan()
+        return perp
 
     #===========================================================================
-    def lat_from_graphic(self, lat, lon=None, derivs=False):
-        """Convert a planetographic latitude to internal coordinates.
+    def velocity(self, pos, time=0.):
+        """The local velocity vector at a point within the surface.
+
+        This can be used to describe the orbital motion of ring particles or
+        local wind speeds on a planet.
 
         Input:
-            lat         planetographic latitide, radians.
-            lon         ignored, included for compatibility with Ellipsoids.
-            derivs      True to include derivatives in returned result.
+            pos         a Vector3 of positions at or near the surface relative
+                        to this surface's origin and frame.
+            time        a Scalar time at which to evaluate the surface; ignored
+                        unless this RingPlane contains radial modes.
 
-        Return          planetocentric latitude.
+        Return:         a Vector3 of velocities, in units of km/s.
         """
 
-        lat = Scalar.as_scalar(lat, recursive=derivs)
-        return (lat.tan() * self.squash_z_sq).arctan()
+        pos = Vector3.as_vector3(pos, False)
 
-################################################################################
-# UNIT TESTS
-################################################################################
+        # Handle special case that's easy
+        if self.gravity is None and not self.modes:
+            return Vector3.zeros(pos.shape, mask=pos.mask)
+
+        # Generate info about intercept points
+        (x,y,z) = pos.to_scalars(recursive=False)
+        radius = (x**2 + y**2).sqrt()
+        r_vector = Vector3.from_scalars(x,y,0.)
+
+        # Handle radial modes
+        if self.modes:
+            lon = y.arctan2(x)
+            (offset, dr_dt, dlon_dt) = self._mode_offset(lon, time, rates=True)
+            a = radius - offset
+
+            if self.gravity:
+                dlon_dt += Scalar.minimum(self.gravity.n(a.vals), self.max_rate)
+
+            v_radial = (dr_dt / radius) * r_vector
+            v_angular = dlon_dt * Vector3.ZAXIS.cross(r_vector)
+            vflat = v_radial + v_angular
+
+        # Handle simple gravity
+        else:
+            a = radius
+            n = Scalar.minimum(self.gravity.n(a.vals), self.max_rate)
+            vflat = n * Vector3.ZAXIS.cross(r_vector)
+
+        # The velocity is undefined outside the ring's radial limits
+        if self.radii is not None:
+            mask = (a < self.radii[0]) | (a > self.radii[1])
+            if np.any(mask):
+                vflat = vflat.remask_or(mask)
 
-import unittest
+        return vflat
+
+    ############################################################################
+    # Radius conversions
+    ############################################################################
+
+    def _mode_offset(self, lon, time, derivs=False, rates=False):
+        """Sum of the modes as a local radial offset from the mean epicyclic
+        radius to the actual radius.
+
+        If input rates==True, return a tuple (radial offset, epicyclic dr/dt,
+        epicyclic dlon/dt.
+        """
 
-class Test_CentricSpheroid(unittest.TestCase):
+        offset = 0.
+        dr_dt = 0.
+        dlon_dt = 0.
+        for mode in self.modes:
+            (cycles, amp, peri0, speed) = mode
+            arg = cycles * (lon - peri0) + speed * (time - self.epoch)
+            amp_cos_arg = amp * arg.cos(recursive=derivs)
+            offset = offset - amp_cos_arg
+            if rates:
+                dr_dt   = dr_dt   + (speed * amp) * arg.sin()
+                dlon_dt = dlon_dt + (2. * speed) * amp_cos_arg
 
-    def runTest(self):
+        if rates:
+            return (offset, dr_dt, dlon_dt)
 
-        np.random.seed(6738)
+        return offset
 
-        REQ  = 60268.
-        #RPOL = 54364.
-        RPOL = 50000.
-        planet = CentricSpheroid("SSB", "J2000", (REQ, RPOL))
-        spheroid = Spheroid("SSB", "J2000", (REQ, RPOL))
-
-        # Coordinate/vector conversions
-        NPTS = 10000
-        pos = (2 * np.random.rand(NPTS,3) - 1.) * REQ   # range is -REQ to REQ
-
-        lon = Scalar(np.random.rand(NPTS) * Scalar.TWOPI)
-        lat = Scalar(np.random.rand(NPTS) * Scalar.PI - Scalar.HALFPI)
-        track = planet.vector3_from_coords((lon,lat))
-        (lon2, lat2) = planet.coords_from_vector3(track, axes=2)
-        self.assertTrue((lon - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat - lat2).abs().max() < 1.e-11)
-
-        track2 = planet.vector3_from_coords((lon2,lat2))
-        self.assertTrue((track2 - track).norm() < 1.e-6)
-
-        lon = Scalar(np.random.rand(NPTS) * Scalar.TWOPI)
-        lat = Scalar(np.random.rand(NPTS) * Scalar.PI - Scalar.HALFPI)
-        z = Scalar(np.random.rand(NPTS) * 1000.)
-        test = planet.vector3_from_coords((lon,lat,z))
-        track = planet.vector3_from_coords((lon,lat))
-        diff = test - track
-        self.assertTrue((diff.norm()).abs() - z < 3.e-11)
-        self.assertTrue(diff.sep(planet.normal(track)).max() < 3.e-10)
-
-        (lon2, lat2, z2) = planet.coords_from_vector3(test, axes=3)
-        (lon3, lat3, z3) = planet.coords_from_vector3(track, axes=3)
-        self.assertTrue((lon - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat - lat2).abs().max() < 3.e-12)
-        self.assertTrue((lon3 - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat3 - lat2).abs().max() < 1.e-11)
-        self.assertTrue(z3.abs().max() < 1.e-10)
-        self.assertTrue((z2 - z).abs().max() < 1.e-10)
-
-        (_, track1) = planet.vector3_from_coords((lon,lat,z), groundtrack=True)
-        (_, _, track2) = planet.coords_from_vector3(test, axes=2, groundtrack=True)
-        self.assertTrue((track1 - track2).norm().max() < 1.e-10)
-
-        pos = (2 * np.random.rand(NPTS,3) - 1.) * REQ   # range is -REQ to REQ
-
-        (lon,lat,elev,track) = planet.coords_from_vector3(pos, axes=3, groundtrack=True)
-        test = planet.vector3_from_coords((lon,lat,elev))
-        self.assertTrue((test - pos).norm().max() < 1.e-8)
-
-        # Make sure longitudes convert to planetocentric and back
-        test_lon = np.arctan2(track.vals[...,1], track.vals[...,0]) % Scalar.TWOPI
-        centric_lon = planet.lon_to_centric(lon)
-        self.assertTrue(abs(centric_lon - test_lon).max() < 1.e-8)
-
-        test_lon2 = planet.lon_from_centric(centric_lon)
-        self.assertTrue(abs(test_lon2 - lon).max() < 1.e-8)
-
-        # Make sure latitudes convert to planetocentric and back
-        test_lat = np.arcsin(track.vals[...,2] / np.sqrt(np.sum(track.vals**2, axis=-1)))
-        centric_lat = planet.lat_to_centric(lat,lon)
-        self.assertTrue(abs(centric_lat - test_lat).max() < 1.e-8)
-
-        test_lat2 = planet.lat_from_centric(centric_lat, lon)
-        self.assertTrue(abs(test_lat2 - lat).max() < 1.e-8)
-
-        # Make sure longitudes convert to planetographic and back
-        normals = planet.normal(track)
-        test_lon = np.arctan2(normals.vals[...,1], normals.vals[...,0]) % Scalar.TWOPI
-        graphic_lon = planet.lon_to_graphic(lon)
-        diffs = (graphic_lon - test_lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue(abs(diffs).max() < 1.e-8)
-
-        test_lon2 = planet.lon_from_centric(centric_lon)
-        diffs = (test_lon2 - lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue(abs(diffs).max() < 1.e-8)
-
-        # Make sure latitudes convert to planetographic and back
-        test_lat = np.arcsin(normals.vals[...,2] / normals.norm().vals)
-        graphic_lat = planet.lat_to_graphic(lat,lon)
-        self.assertTrue(abs(graphic_lat - test_lat).max() < 1.e-8)
-
-        test_lat2 = planet.lat_from_graphic(graphic_lat, lon)
-        self.assertTrue(abs(test_lat2 - lat).max() < 1.e-8)
-
-        # Spheroid intercepts & normals
-        obs = REQ * (np.random.rand(NPTS,3) + 1.)       # range is REQ to 2*REQ
-        los = -np.random.rand(NPTS,3)                   # range is -1 to 0
-
-        (pts, t) = planet.intercept(obs, los)
-        test = t * Vector3(los) + Vector3(obs)
-        self.assertTrue(abs(test - pts).max() < 1.e-9)
-
-        self.assertTrue(np.all(t.mask == pts.mask))
-        self.assertTrue(np.all(pts.mask[t.vals < 0.]))
-
-        normals = planet.normal(pts)
-
-        pts.vals[...,2] *= REQ/RPOL
-        self.assertTrue(abs(pts.norm() - REQ).max() < 1.e-8)
-
-        normals.vals[...,2] *= RPOL/REQ
-        self.assertTrue(abs(normals.unit() - pts.unit()).max() < 1.e-14)
-
-        # Intercept derivatives
-
-        # Lines of sight with grazing incidence can have large numerical errors,
-        # but this is not to be considered an error in the analytic calculation.
-        # As a unit test, we ignore the largest 3% of the errors, but require
-        # that the rest of the errors be very small.
-
-        obs = REQ * (np.random.rand(NPTS,3) + 1.)       # range is REQ to 2*REQ
-        los = -np.random.rand(NPTS,3)                   # range is -1 to 0
-
-        obs = Vector3(obs)
-        los = Vector3(los).unit()
-        obs.insert_deriv('obs', Vector3.IDENTITY)
-        los.insert_deriv('los', Vector3.IDENTITY)
-
-        eps = 1.
-        frac = 0.97     # Ignore errors above this cutoff
-        dobs = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            (cept,t) = planet.intercept(obs, los, derivs=True)
-            (cept1,t1) = planet.intercept(obs + dobs[i], los, derivs=False)
-            (cept2,t2) = planet.intercept(obs - dobs[i], los, derivs=False)
-
-            dcept_dobs = (cept1 - cept2) / (2*eps)
-            ref = Vector3(cept.d_dobs.vals[...,i], cept.d_dobs.mask)
-
-            errors = abs(dcept_dobs - ref) / abs(ref)
-            sorted = np.sort(errors.vals[errors.antimask])
-                        # mask=True where the line of sight missed the surface
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-            dt_dobs = (t1 - t2) / (2*eps)
-            ref = t.d_dobs.vals[...,i]
-
-            errors = abs(dt_dobs/ref - 1)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-        eps = 1.e-6
-        frac = 0.97
-        dlos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            (cept,t) = planet.intercept(obs, los, derivs=True)
-            (cept1,t1) = planet.intercept(obs, los + dlos[i], derivs=False)
-            (cept2,t2) = planet.intercept(obs, los - dlos[i], derivs=False)
-
-            dcept_dlos = (cept1 - cept2) / (2*eps)
-            ref = Vector3(cept.d_dlos.vals[...,i], cept.d_dlos.mask)
-
-            errors = abs(dcept_dlos - ref) / abs(ref)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-            dt_dlos = (t1 - t2) / (2*eps)
-            ref = t.d_dlos.vals[...,i]
-
-            errors = abs(dt_dlos/ref - 1)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-        # Test normal()
-        cept = Vector3(np.random.random((100,3))).unit().element_mul(planet.radii)
-        perp = planet.normal(cept)
-        test1 = cept.element_mul(spheroid.unsquash).unit()
-        test2 = perp.element_mul(spheroid.squash).unit()
-
-        self.assertTrue(abs(test1 - test2).max() < 1.e-12)
-
-        eps = 1.e-7
-        (lon,lat) = planet.coords_from_vector3(cept, axes=2)
-        cept1 = planet.vector3_from_coords((lon+eps,lat,0.))
-        cept2 = planet.vector3_from_coords((lon-eps,lat,0.))
-
-        self.assertTrue(abs((cept2 - cept1).sep(perp) - Scalar.HALFPI).max() < 1.e-8)
-
-        (lon,lat) = planet.coords_from_vector3(cept, axes=2)
-        cept1 = planet.vector3_from_coords((lon,lat+eps,0.))
-        cept2 = planet.vector3_from_coords((lon,lat-eps,0.))
-
-        self.assertTrue(abs((cept2 - cept1).sep(perp) - Scalar.HALFPI).max() < 1.e-8)
-
-        # Test intercept_with_normal()
-        vector = Vector3(np.random.random((100,3)))
-        cept = planet.intercept_with_normal(vector)
-        sep = vector.sep(planet.normal(cept))
-        self.assertTrue(sep.max() < 1.e-14)
-
-        # Test intercept_normal_to()
-        pos = Vector3(np.random.random((100,3)) * 4.*REQ + REQ)
-        cept = planet.intercept_normal_to(pos)
-        sep = (pos - cept).sep(planet.normal(cept))
-        self.assertTrue(sep.max() < 3.e-12)
-        self.assertTrue(abs(cept.element_mul(spheroid.unsquash).norm() -
-                            spheroid.req).max() < 1.e-6)
-
-        # Test normal() derivative
-        cept = Vector3(np.random.random((100,3))).unit().element_mul(planet.radii)
-        cept.insert_deriv('pos', Vector3.IDENTITY, override=True)
-        perp = planet.normal(cept, derivs=True)
-        eps = 1.e-5
-        dpos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            perp1 = planet.normal(cept + dpos[i])
-            dperp_dpos = (perp1 - perp) / eps
-
-            ref = Vector3(perp.d_dpos.vals[...,i,:], perp.d_dpos.mask)
-            self.assertTrue(abs(dperp_dpos - ref).max() < 1.e-4)
-
-        # Test intercept_normal_to() derivative
-        pos = Vector3(np.random.random((3,3)) * 4.*REQ + REQ)
-        pos.insert_deriv('pos', Vector3.IDENTITY, override=True)
-        (cept,t) = planet.intercept_normal_to(pos, derivs=True, guess=True)
-        self.assertTrue(abs(cept.element_mul(spheroid.unsquash).norm() -
-                        spheroid.req).max() < 1.e-6)
-
-        eps = 1.
-        dpos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        perp = planet.normal(cept)
-        for i in range(3):
-            (cept1,t1) = planet.intercept_normal_to(pos + dpos[i], derivs=False,
-                                                    guess=t)
-            (cept2,t2) = planet.intercept_normal_to(pos - dpos[i], derivs=False,
-                                                    guess=t)
-            dcept_dpos = (cept1 - cept2) / (2*eps)
-            self.assertTrue(abs(dcept_dpos.sep(perp) - Scalar.HALFPI).max() < 1.e-5)
-
-            ref = Vector3(cept.d_dpos.vals[...,i], cept.d_dpos.mask)
-            self.assertTrue(abs(dcept_dpos - ref).max() < 1.e-5)
-
-            dt_dpos = (t1 - t2) / (2*eps)
-            ref = t.d_dpos.vals[...,i]
-            self.assertTrue(abs(dt_dpos/ref - 1).max() < 1.e-5)
-
-        # Confirm that latitudes are planetocentric
-        NPTS = 10000
-        pos = (2 * np.random.rand(NPTS,3) - 1.) * REQ   # range is -REQ to REQ
-
-        (lon,lat,elev,track) = planet.coords_from_vector3(pos, axes=3, groundtrack=True)
-        sep = Vector3.ZAXIS.sep(track)
-        test_lat = Scalar.HALFPI - sep
-        self.assertTrue(abs(lat - test_lat).max() < 1.e-8)
-
-        # Confirm that latitudes convert to planetographic
-        new_lat = planet.lat_to_graphic(lat)
-
-        sep = Vector3.ZAXIS.sep(planet.normal(track))
-        test_lat = Scalar.HALFPI - sep
-        self.assertTrue(abs(new_lat - test_lat).max() < 1.e-8)
-
-        # Confirm that planetographic latitudes convert back to planetocentric
-        newer_lat = planet.lat_from_graphic(new_lat)
-        self.assertTrue(abs(newer_lat - lat).max() < 1.e-8)
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/surface/ellipsoid.py` & `rms_oops-0.0.4/oops/surface/ellipsoid.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,17 +1,18 @@
 ################################################################################
 # oops/surface/ellipsoid.py: Ellipsoid subclass of class Surface
 ################################################################################
 
 import numpy as np
-from polymath     import Matrix, Scalar, Vector3
-from oops.config  import SURFACE_PHOTONS, LOGGING
-from oops.frame   import Frame
-from oops.path    import Path
-from oops.surface import Surface
+
+from polymath              import Matrix, Scalar, Vector3
+from oops.config           import SURFACE_PHOTONS, LOGGING
+from oops.frame.frame_     import Frame
+from oops.path.path_       import Path
+from oops.surface.surface_ import Surface
 
 class Ellipsoid(Surface):
     """An ellipsoidal surface centered on the given path and fixed with respect
     to the given frame. The short radius of the ellipsoid is oriented along the
     Z-axis of the frame and the long radius is along the X-axis.
 
     The coordinates defining the surface grid are (longitude, latitude).
@@ -707,267 +708,7 @@
         lat = Scalar.as_scalar(lat, recursive=derivs)
 
         factor = (lon.cos()**2 + (lon.sin() * self.unsquash_y)**2).sqrt()
 
         return (lat.tan() * self.squash_z * factor).arctan()
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Ellipsoid(unittest.TestCase):
-
-    def runTest(self):
-
-        np.random.seed(2610)
-
-        REQ  = 60268.
-        RMID = 54364.
-        RPOL = 50000.
-        planet = Ellipsoid('SSB', 'J2000', (REQ, RMID, RPOL))
-
-        # Coordinate/vector conversions
-        NPTS = 10000
-
-        lon = Scalar(np.random.rand(NPTS) * Scalar.TWOPI)
-        lat = Scalar(np.random.rand(NPTS) * Scalar.PI - Scalar.HALFPI)
-        track = planet.vector3_from_coords((lon,lat))
-        (lon2, lat2) = planet.coords_from_vector3(track, axes=2)
-        self.assertTrue((lon - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat - lat2).abs().max() < 1.e-11)
-
-        track2 = planet.vector3_from_coords((lon2,lat2))
-        self.assertTrue((track2 - track).norm() < 1.e-6)
-
-        lon = Scalar(np.random.rand(NPTS) * Scalar.TWOPI)
-        lat = Scalar(np.random.rand(NPTS) * Scalar.PI - Scalar.HALFPI)
-        z = Scalar(np.random.rand(NPTS) * 1000.)
-        test = planet.vector3_from_coords((lon,lat,z))
-        track = planet.vector3_from_coords((lon,lat))
-        diff = test - track
-        self.assertTrue((diff.norm()).abs() - z < 3.e-11)
-        self.assertTrue(diff.sep(planet.normal(track)).max() < 1.e-10)
-
-        (lon2, lat2, z2) = planet.coords_from_vector3(test, axes=3)
-        (lon3, lat3, z3) = planet.coords_from_vector3(track, axes=3)
-        self.assertTrue((lon - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat - lat2).abs().max() < 3.e-12)
-        self.assertTrue((lon3 - lon2).abs().max() < 1.e-15)
-        self.assertTrue((lat3 - lat2).abs().max() < 1.e-11)
-        self.assertTrue(z3.abs().max() < 1.e-10)
-        self.assertTrue((z2 - z).abs().max() < 1.e-10)
-
-        (_, track1) = planet.vector3_from_coords((lon,lat,z), groundtrack=True)
-        (_, _, track2) = planet.coords_from_vector3(test, axes=2, groundtrack=True)
-        self.assertTrue((track1 - track2).norm().max() < 1.e-10)
-
-        pos = (2 * np.random.rand(NPTS,3) - 1.) * REQ   # range is -REQ to REQ
-
-        (lon,lat,elev,track) = planet.coords_from_vector3(pos, axes=3, groundtrack=True)
-        test = planet.vector3_from_coords((lon,lat,elev))
-        self.assertTrue((test - pos).norm().max() < 1.e-8)
-
-        # Make sure longitudes convert to planetocentric and back
-        test_lon = np.arctan2(track.vals[...,1], track.vals[...,0]) % Scalar.TWOPI
-        centric_lon = planet.lon_to_centric(lon)
-        diffs = (centric_lon - test_lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue((diffs).abs().max() < 1.e-8)
-
-        test_lon2 = planet.lon_from_centric(centric_lon)
-        diffs = (test_lon2 - lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue((diffs).abs().max() < 1.e-8)
-
-        # Make sure latitudes convert to planetocentric and back
-        test_lat = np.arcsin(track.vals[...,2] / np.sqrt(np.sum(track.vals**2, axis=-1)))
-        centric_lat = planet.lat_to_centric(lat,lon)
-        self.assertTrue(abs(centric_lat - test_lat).max() < 1.e-8)
-
-        test_lat2 = planet.lat_from_centric(centric_lat, lon)
-        self.assertTrue(abs(test_lat2 - lat).max() < 1.e-8)
-
-        # Make sure longitudes convert to planetographic and back
-        normals = planet.normal(track)
-        test_lon = np.arctan2(normals.vals[...,1], normals.vals[...,0])
-        graphic_lon = planet.lon_to_graphic(lon)
-        diffs = (graphic_lon - test_lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue(abs(diffs).max() < 1.e-8)
-
-        test_lon2 = planet.lon_from_centric(centric_lon)
-        diffs = (test_lon2 - lon + Scalar.HALFPI) % Scalar.PI - Scalar.HALFPI
-        self.assertTrue(abs(diffs).max() < 1.e-8)
-
-        # Make sure latitudes convert to planetographic and back
-        test_lat = np.arcsin(normals.vals[...,2] / normals.norm().vals)
-        graphic_lat = planet.lat_to_graphic(lat,lon)
-        self.assertTrue(abs(graphic_lat - test_lat).max() < 1.e-8)
-
-        test_lat2 = planet.lat_from_graphic(graphic_lat, lon)
-        self.assertTrue(abs(test_lat2 - lat).max() < 1.e-8)
-
-        # Ellipsoid intercepts & normals
-        obs = REQ * (np.random.rand(NPTS,3) + 1.)       # range is REQ to 2*REQ
-        los = -np.random.rand(NPTS,3)                   # range is -1 to 0
-
-        (pts, t) = planet.intercept(obs, los)
-        test = t * Vector3(los) + Vector3(obs)
-        self.assertTrue(abs(test - pts).max() < 1.e-9)
-
-        self.assertTrue(np.all(t.mask == pts.mask))
-        self.assertTrue(np.all(pts.mask[t.vals < 0.]))
-
-        normals = planet.normal(pts)
-
-        pts.vals[...,1] *= REQ/RMID
-        pts.vals[...,2] *= REQ/RPOL
-        self.assertTrue(abs(pts.norm() - REQ).max() < 1.e-8)
-
-        normals.vals[...,1] *= RMID/REQ
-        normals.vals[...,2] *= RPOL/REQ
-        self.assertTrue(abs(normals.unit() - pts.unit()).max() < 1.e-14)
-
-        # Intercept derivatives
-
-        # Lines of sight with grazing incidence can have large numerical errors,
-        # but this is not to be considered an error in the analytic calculation.
-        # As a unit test, we ignore the largest 3% of the errors, but require
-        # that the rest of the errors be very small.
-
-        obs = REQ * (np.random.rand(NPTS,3) + 1.)       # range is REQ to 2*REQ
-        los = -np.random.rand(NPTS,3)                   # range is -1 to 0
-
-        obs = Vector3(obs)
-        los = Vector3(los).unit()
-        obs.insert_deriv('obs', Vector3.IDENTITY)
-        los.insert_deriv('los', Vector3.IDENTITY)
-
-        eps = 1.
-        frac = 0.97     # Ignore errors above this cutoff
-        dobs = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            (cept,t) = planet.intercept(obs, los, derivs=True)
-            (cept1,t1) = planet.intercept(obs + dobs[i], los, derivs=False)
-            (cept2,t2) = planet.intercept(obs - dobs[i], los, derivs=False)
-
-            dcept_dobs = (cept1 - cept2) / (2*eps)
-            ref = Vector3(cept.d_dobs.vals[...,i], cept.d_dobs.mask)
-
-            errors = abs(dcept_dobs - ref) / abs(ref)
-            sorted = np.sort(errors.vals[errors.antimask])
-                        # mask=True where the line of sight missed the surface
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-            dt_dobs = (t1 - t2) / (2*eps)
-            ref = t.d_dobs.vals[...,i]
-
-            errors = abs(dt_dobs/ref - 1)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-        eps = 1.e-6
-        frac = 0.97
-        dlos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            (cept,t) = planet.intercept(obs, los, derivs=True)
-            (cept1,t1) = planet.intercept(obs, los + dlos[i], derivs=False)
-            (cept2,t2) = planet.intercept(obs, los - dlos[i], derivs=False)
-
-            dcept_dlos = (cept1 - cept2) / (2*eps)
-            ref = Vector3(cept.d_dlos.vals[...,i], cept.d_dlos.mask)
-
-            errors = abs(dcept_dlos - ref) / abs(ref)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-            dt_dlos = (t1 - t2) / (2*eps)
-            ref = t.d_dlos.vals[...,i]
-
-            errors = abs(dt_dlos/ref - 1)
-            sorted = np.sort(errors.vals[errors.antimask])
-            selected_error = sorted[int(sorted.size * frac)]
-            self.assertTrue(selected_error < 1.e-5)
-
-        # Test normal()
-        cept = Vector3(np.random.random((100,3))).unit().element_mul(planet.radii)
-        perp = planet.normal(cept)
-        test1 = cept.element_mul(planet.unsquash).unit()
-        test2 = perp.element_mul(planet.squash).unit()
-
-        self.assertTrue(abs(test1 - test2).max() < 1.e-12)
-
-        eps = 1.e-7
-        (lon,lat) = planet.coords_from_vector3(cept, axes=2)
-        cept1 = planet.vector3_from_coords((lon+eps,lat,0.))
-        cept2 = planet.vector3_from_coords((lon-eps,lat,0.))
-
-        self.assertTrue(abs((cept2 - cept1).sep(perp) - Scalar.HALFPI).max() < 1.e-8)
-
-        (lon,lat) = planet.coords_from_vector3(cept, axes=2)
-        cept1 = planet.vector3_from_coords((lon,lat+eps,0.))
-        cept2 = planet.vector3_from_coords((lon,lat-eps,0.))
-
-        self.assertTrue(abs((cept2 - cept1).sep(perp) - Scalar.HALFPI).max() < 1.e-8)
-
-        # Test intercept_with_normal()
-        vector = Vector3(np.random.random((100,3)))
-        cept = planet.intercept_with_normal(vector)
-        sep = vector.sep(planet.normal(cept))
-        self.assertTrue(sep.max() < 1.e-14)
-
-        # Test intercept_normal_to()
-        pos = Vector3(np.random.random((100,3)) * 4.*REQ + REQ)
-        cept = planet.intercept_normal_to(pos)
-        sep = (pos - cept).sep(planet.normal(cept))
-        self.assertTrue(sep.max() < 3.e-12)
-        self.assertTrue(abs(cept.element_mul(planet.unsquash).norm() -
-                        planet.req).max() < 1.e-6)
-
-        # Test normal() derivative
-        cept = Vector3(np.random.random((100,3))).unit().element_mul(planet.radii)
-        cept.insert_deriv('pos', Vector3.IDENTITY, override=True)
-        perp = planet.normal(cept, derivs=True)
-        eps = 1.e-5
-        dpos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        for i in range(3):
-            perp1 = planet.normal(cept + dpos[i])
-            dperp_dpos = (perp1 - perp) / eps
-
-            ref = Vector3(perp.d_dpos.vals[...,i,:], perp.d_dpos.mask)
-            self.assertTrue(abs(dperp_dpos - ref).max() < 1.e-4)
-
-        # Test intercept_normal_to() derivative
-        N = 1000
-        pos = Vector3(np.random.random((N,3)) * 4.*REQ + REQ)
-        pos.insert_deriv('pos', Vector3.IDENTITY, override=True)
-        (cept,t) = planet.intercept_normal_to(pos, derivs=True, guess=True)
-        self.assertTrue(abs(cept.element_mul(planet.unsquash).norm() -
-                        planet.req).max() < 1.e-6)
-
-        eps = 1.
-        dpos = ((eps,0,0), (0,eps,0), (0,0,eps))
-        perp = planet.normal(cept)
-        for i in range(3):
-            (cept1,t1) = planet.intercept_normal_to(pos + dpos[i], derivs=False,
-                                                    guess=t)
-            (cept2,t2) = planet.intercept_normal_to(pos - dpos[i], derivs=False,
-                                                    guess=t)
-            dcept_dpos = (cept1 - cept2) / (2*eps)
-            self.assertTrue(abs(dcept_dpos.sep(perp) - Scalar.HALFPI).max() < 1.e-5)
-
-            ref = Vector3(cept.d_dpos.vals[...,i], cept.d_dpos.mask)
-            self.assertTrue(abs(dcept_dpos - ref).max() < 1.e-5)
-
-            dt_dpos = (t1 - t2) / (2*eps)
-            ref = t.d_dpos.vals[...,i]
-            self.assertTrue(abs(dt_dpos/ref - 1).max() < 1.e-5)
-
-        Path.reset_registry()
-        Frame.reset_registry()
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/surface/nullsurface.py` & `rms_oops-0.0.4/oops/surface/nullsurface.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 ################################################################################
 # oops/surface/nullsurface.py: NullSurface subclass of class Surface
 ################################################################################
 
-from polymath     import Scalar, Vector3
-from oops.frame   import Frame
-from oops.path    import Path
-from oops.surface import Surface
+from polymath              import Scalar, Vector3
+from oops.frame.frame_     import Frame
+from oops.path.path_       import Path
+from oops.surface.surface_ import Surface
 
 class NullSurface(Surface):
     """A subclass of Surface of describing an infinitesimal surface centered on
     the specified path, and using the specified coordinate frame.
     """
 
     COORDINATE_TYPE = 'rectangular'
@@ -193,20 +193,7 @@
         Return:         a Vector3 of velocities, in units of km/s.
         """
 
         # Always zero
         return Vector3.ZERO
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_NullSurface(unittest.TestCase):
-
-    pass        # TBD
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/oops/surface/polarlimb.py` & `rms_oops-0.0.4/oops/surface/centricellipsoid.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,212 +1,246 @@
 ################################################################################
-# oops/surface/polarlimb.py: PolarLimb subclass of class Surface
+# oops/surface/centricellipsoid.py: CentricEllipsoid subclass of class Surface
 ################################################################################
 
 import numpy as np
-from polymath          import Scalar, Vector3
-from oops.surface.limb import Limb
 
-class PolarLimb(Limb):
-    """This surface is defined as the locus of points where a surface normal
-    from a spheroid or ellipsoid is perpendicular to the line of sight. This
-    provides a convenient coordinate system for describing cloud features on the
-    limb of a body.
-
-    The coordinates of PolarLimb are (z, clock, d), where:
-        z       the vertical distance in km normal to the limb of the body
-                surface.
-        clock   the angle of the normal vector on the sky, measured clockwise
-                from the projected direction of the north pole.
-        d       an offset distance beyond the virtual limb plane along the line
-                of sight; usually zero.
+from polymath               import Scalar, Vector3
+from oops.surface.ellipsoid import Ellipsoid
+
+class CentricEllipsoid(Ellipsoid):
+    """A variant of Ellipsoid in which latitudes and longitudes are
+    planetocentric.
     """
 
     #===========================================================================
     def coords_from_vector3(self, pos, obs=None, time=None, axes=2,
                                   derivs=False, hints=None, groundtrack=False):
         """Surface coordinates associated with a position vector.
 
         Input:
             pos         a Vector3 of positions at or near the surface, relative
                         to this surface's origin and frame.
             obs         a Vector3 of observer position relative to this
-                        surface's origin and frame.
+                        surface's origin and frame; ignored for this Surface
+                        subclass.
             time        a Scalar time at which to evaluate the surface; ignored
                         for this Surface subclass.
             axes        2 or 3, indicating whether to return the first two
-                        coordinates (z, clock) or all three (z, clock, dist) as
+                        coordinates (lon, lat) or all three (lon, lat, z) as
                         Scalars.
             derivs      True to propagate any derivatives inside pos and obs
                         into the returned coordinates.
             hints       optionally, the value of the coefficient p such that
                             ground + p * normal(ground) = pos;
-                        for the ground point on the body surface. Ignored if the
-                        value is None (the default) or True.
+                        ignored if the value is None (the default) or True.
             groundtrack True to return the intercept on the surface along with
                         the coordinates.
 
-        Return:         a tuple containing two to four values.
-            z           the vertical distance in km normal to the limb of the
-                        body surface.
-            clock       the angle in radians of the normal vector on the sky,
-                        measured clockwise from the projected direction of the
-                        north pole.
-            dist        optional offset distance in km beyond the virtual limb
-                        plane along the line of sight, included if axes == 3.
+        Return:         a tuple of two to four items:
+            lon         longitude at the surface in radians.
+            lat         latitude at the surface in radians.
+            z           vertical altitude in km normal to the surface; included
+                        if axes == 3.
             track       intercept point on the surface (where z == 0); included
                         if input groundtrack is True.
         """
 
         # Validate inputs
         self._coords_from_vector3_check(axes)
 
         pos = Vector3.as_vector3(pos, recursive=derivs)
-        obs = Vector3.as_vector3(obs, recursive=derivs)
 
-        # There's a quick solution for the surface point if hints are provided
+        # Use the quick solution for the body points if hints are provided
         if isinstance(hints, (type(None), bool, np.bool_)):
-            los = pos - obs
-            (cept, _, p, track) = self.intercept(obs, los, derivs=derivs,
-                                                 hints=True, groundtrack=True)
-                # The returned value of p speeds up the next calculation
+            (track, p) = self.intercept_normal_to(pos, guess=True)
         else:
             p = Scalar.as_scalar(hints, recursive=derivs)
-            denom = Vector3.ONES + p * self.ground.unsquash_sq
+            denom = Vector3.ONES + p * self.unsquash_sq
             track = pos.element_div(denom)
-            cept = pos
 
-        results = self.z_clock_from_intercept(cept, obs, derivs=derivs, hints=p)
+        # Derive the coordinates
+        (x,y,z) = track.to_scalars()
+        lat = (z/track.norm()).arcsin()
+        lon = y.arctan2(x) % Scalar.TWOPI
+
+        results = (lon, lat)
 
         if axes == 3:
-            d = los.dot(pos - cept) / los.norm()
-            results += (d,)
+            r = (pos - track).norm() * p.sign()
+            results += (r,)
 
         if groundtrack:
             results += (track,)
 
         return results
 
     #===========================================================================
     def vector3_from_coords(self, coords, obs=None, time=None, derivs=False,
-                                  groundtrack=False):
+                                          groundtrack=False):
         """The position where a point with the given coordinates falls relative
         to this surface's origin and frame.
 
         Input:
             coords      a tuple of two or three Scalars defining coordinates at
                         or near this surface. These can have different shapes,
                         but must be broadcastable to a common shape.
-                z       the vertical distance in km normal to the limb of the
-                        body surface.
-                clock   the angle in radians of the normal vector on the sky,
-                        measured clockwise from the projected direction of the
-                        north pole.
-                dist    optional offset distance in km beyond the virtual limb
-                        plane along the line of sight.
-            obs         a Vector3 of observer positions relative to this
-                        surface's origin and frame.
+                lon     longitude at the surface in radians.
+                lat     latitude at the surface in radians.
+                z       vertical altitude in km normal to the body surface.
+            obs         a Vector3 of observer position relative to this
+                        surface's origin and frame; ignored for this Surface
+                        subclass.
             time        a Scalar time at which to evaluate the surface; ignored
                         for this Surface subclass.
-            derivs      True to include the partial derivatives of the intercept
-                        point with respect to observer and to the coordinates.
+            derivs      True to propagate any derivatives inside the coordinates
+                        and obs into the returned position vectors.
             groundtrack True to include the associated groundtrack points on the
                         body surface in the returned result.
 
-        Return:         pos or (pos, track), where:
+        Return:         pos or (pos, track), where
             pos         a Vector3 of points defined by the coordinates, relative
                         to this surface's origin and frame.
-            track       a Vector3 of associated points on the body surface;
-                        included if input groundtrack is True.
+            track       intercept point on the surface (where z == 0); included
+                        if input groundtrack is True.
         """
 
         # Validate inputs
         self._vector3_from_coords_check(coords)
 
-        (z, clock) = coords[:2]
-        (cept, track) = self.limb.intercept_from_z_clock(z, clock, obs,
-                                                         derivs=derivs,
-                                                         groundtrack=True)
-
-        if len(coords) > 2:
-            d = Scalar.as_scalar(clock, recursive=derivs)
-            los = cept - obs
-            cept += (d / los.norm()) * los
+        (lon, lat) = coords[:2]
+        squashed_lon = Ellipsoid.lon_from_centric(self, lon, derivs=derivs)
+        squashed_lat = Ellipsoid.lat_from_centric(self, lat, squashed_lon,
+                                                        derivs=derivs)
+        new_coords = (squashed_lon, squashed_lat,) + coords[2:]
+
+        return Ellipsoid.vector3_from_coords(self, new_coords, derivs=derivs,
+                                                   groundtrack=groundtrack)
+
+    ############################################################################
+    # Longitude conversions
+    ############################################################################
 
-        if groundtrack:
-            return (cept, track)
-        else:
-            return cept
+    def lon_to_centric(self, lon, derivs=False):
+        """Convert longitude in internal coordinates to planetocentric.
 
-################################################################################
-# UNIT TESTS
-################################################################################
+        Input:
+            lon         planetocentric longitude in radians.
+            derivs      True to include derivatives in returned result.
 
-import unittest
-from oops.constants import HALFPI
+        Return          planetocentric longitude.
+        """
 
-class Test_PolarLimb(unittest.TestCase):
+        return Scalar.as_scalar(lon, recursive=derivs)
 
-    def runTest(self):
+    #===========================================================================
+    def lon_from_centric(self, lon, derivs=False):
+        """Convert planetocentric longitude to internal coordinates.
 
-        from oops.frame             import Frame
-        from oops.path              import Path
-        from oops.surface.spheroid  import Spheroid
-        from oops.surface.ellipsoid import Ellipsoid
+        Input:
+            lon         planetocentric longitude in radians.
+            derivs      True to include derivatives in returned result.
 
-        REQ  = 60268.
-        RMID = 54364.
-        RPOL = 50000.
+        Return          planetocentric longitude.
+        """
 
-        ground = Spheroid('SSB', 'J2000', (REQ, RPOL))
-        limb = Limb(ground)
+        return Scalar.as_scalar(lon, recursive=derivs)
 
-        obs = Vector3([4*REQ,0,0])
+    #===========================================================================
+    def lon_to_graphic(self, lon, derivs=False):
+        """Convert longitude in internal coordinates to planetographic.
 
-        los_vals = np.empty((220,220,3))
-        los_vals[...,0] = -4 *REQ
-        los_vals[...,1] = np.arange(-1.10,1.10,0.01)[:,np.newaxis] * REQ
-        los_vals[...,2] = np.arange(-1.10,1.10,0.01) * REQ
-        los = Vector3(los_vals)
+        Input:
+            lon         planetocentric longitude in radians.
+            derivs      True to include derivatives in returned result.
 
-        (cept, t, track) = limb.intercept(obs, los, groundtrack=True)
+        Return          planetographic longitude.
+        """
 
-        perp = limb.normal(track)
-        self.assertTrue(abs(perp.sep(los) - HALFPI).max() < 1.e-12)
+        lon = Scalar.as_scalar(lon, recursive=derivs)
+        return (lon.sin() * self.unsquash_y_sq).arctan2(lon.cos())
 
-        coords = limb.coords_from_vector3(cept, obs, axes=3)
-        self.assertTrue(abs(coords[2]).max() < 1.e6)
+    #===========================================================================
+    def lon_from_graphic(self, lon, derivs=False):
+        """Convert planetographic longitude to internal coordinates.
 
-        cept2 = limb.vector3_from_coords(coords, obs)
-        self.assertTrue((cept2 - cept).norm().median() < 1.e-10)
+        Input:
+            lon         planetographic longitude in radians.
+            derivs      True to include derivatives in returned result.
 
-        ####################
+        Return          planetocentric longitude.
+        """
 
-        ground = Ellipsoid('SSB', 'J2000', (REQ, RMID, RPOL))
-        limb = Limb(ground)
+        lon = Scalar.as_scalar(lon, recursive=derivs)
+        return (lon.sin() * self.squash_y_sq).arctan2(lon.cos())
 
-        obs = Vector3([4*REQ,0,0])
+    ############################################################################
+    # Latitude conversions
+    ############################################################################
 
-        los_vals = np.empty((220,220,3))
-        los_vals[...,0] = -4 *REQ
-        los_vals[...,1] = np.arange(-1.10,1.10,0.01)[:,np.newaxis] * REQ
-        los_vals[...,2] = np.arange(-1.10,1.10,0.01) * REQ
-        los = Vector3(los_vals)
+    def lat_to_centric(self, lat, lon, derivs=False):
+        """Convert latitude in internal coordinates to planetocentric.
 
-        (cept, t, track) = limb.intercept(obs, los, groundtrack=True)
+        Input:
+            lat         squashed latitide, radians.
+            lon         planetocentric longitude, radians.
+            derivs      True to include derivatives in returned result.
 
-        perp = limb.normal(track)
-        self.assertTrue(abs(perp.sep(los) - HALFPI).max() < 1.e-12)
+        Return          planetocentric latitude.
+        """
 
-        coords = limb.coords_from_vector3(cept, obs, axes=3)
-        self.assertTrue(abs(coords[2]).max() < 1.e6)
+        return Scalar.as_scalar(lat, recursive=derivs)
+
+    #===========================================================================
+    def lat_from_centric(self, lat, lon, derivs=False):
+        """Convert planetocentric latitude to internal coordinates.
+
+        Input:
+            lat         planetocentric latitide, radians.
+            lon         planetocentric longitude, radians.
+            derivs      True to include derivatives in returned result.
+
+        Return          planetocentric latitude.
+        """
+
+        return Scalar.as_scalar(lat, recursive=derivs)
+
+    #===========================================================================
+    def lat_to_graphic(self, lat, lon, derivs=False):
+        """Convert latitude in internal coordinates to planetographic.
+
+        Input:
+            lat         squashed latitide, radians.
+            lon         planetocentric longitude, radians.
+            derivs      True to include derivatives in returned result.
+
+        Return          planetographic latitude.
+        """
+
+        # This could be done more efficiently I'm sure
+        squashed_lon = Ellipsoid.lon_from_centric(self, lon, derivs=derivs)
+        squashed_lat = Ellipsoid.lat_from_centric(self, lat, squashed_lon,
+                                                        derivs=derivs)
+
+        return Ellipsoid.lat_to_graphic(self, squashed_lat, squashed_lon,
+                                              derivs=derivs)
+
+    #===========================================================================
+    def lat_from_graphic(self, lat, lon, derivs=False):
+        """Convert a planetographic latitude to internal coordinates.
+
+        Input:
+            lat         planetographic latitide, radians.
+            lon         planetocentric longitude, radians.
+            derivs      True to include derivatives in returned result.
+
+        Return          planetocentric latitude.
+        """
 
-        cept2 = limb.vector3_from_coords(coords, obs)
-        self.assertTrue((cept2 - cept).norm().median() < 1.e-10)
+        squashed_lon = Ellipsoid.lon_from_centric(self, lon, derivs=derivs)
+        squashed_lat = Ellipsoid.lat_from_graphic(self, lat, squashed_lon,
+                                                        derivs=derivs)
 
-        Path.reset_registry()
-        Frame.reset_registry()
+        return Ellipsoid.lat_to_centric(self, squashed_lat, squashed_lon,
+                                              derivs=derivs)
 
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
 ################################################################################
```

### Comparing `rms_oops-0.0.3/oops/transform.py` & `rms_oops-0.0.4/oops/transform.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,14 +1,12 @@
 ################################################################################
 # oops/transform.py: Class Transform
 ################################################################################
 
-import numpy as np
-
-from polymath import Qube, Scalar, Vector3, Matrix3
+from polymath import Qube, Vector3, Matrix3
 
 class Transform(object):
     """An object describing a coordinate transformation, defined by a rotation
     matrix plus an optional angular rotation vector indicating how that frame is
     rotating. The components are interpreted as follows:
         matrix          rotates coordinates from the reference coordinate frame
                         into the target frame.
@@ -47,21 +45,18 @@
         origin_id       the path ID of the origin if this is a rotating frame;
                         None otherwise.
 
     This is a static property, generated only if needed
         shape           the intrinsic shape of the transform.
     """
 
-    ############################################################################
-    # Note:
-    # The class constants are defined at the end of __init__.py:
-    #   Transform.FRAME_CLASS
-    #   Transform.IDENTITY
-    ############################################################################
+    # Class constants to avoid circular references
+    FRAME_CLASS = None          # filled in by oops/__init__.py
 
+    #===========================================================================
     def __init__(self, matrix, omega, frame, reference, origin=None):
         """Constructor for a Transform object.
 
         Input:
             matrix      the Matrix3 object that is used to rotate coordinates
                         from the reference frame into the new frame.
             omega       the spin vector for the coordinate frame, given in
@@ -367,92 +362,7 @@
         this transform. I.e., if arg rotates A to B and self rotates C to B,
         then the result rotates A to C.
         """
 
         return self.invert().rotate_transform(arg)
 
 ################################################################################
-# UNIT TESTS
-################################################################################
-
-import unittest
-
-class Test_Transform(unittest.TestCase):
-
-    def runTest(self):
-
-        np.random.seed(5819)
-
-        # Additional imports needed for testing
-        from oops.frame import Frame, Wayframe
-
-        # Fake out the FRAME REGISTRY with something that has .shape = ()
-        Frame.WAYFRAME_REGISTRY["TEST"] = Wayframe("J2000")
-        Frame.WAYFRAME_REGISTRY["SPIN"] = Wayframe("J2000")
-
-        tr = Transform(Matrix3(np.array([[1.,0.,0.],[0.,1.,0.],[0.,0.,1.]])),
-                       Vector3(np.array([0.,0.,0.])), "J2000", "J2000")
-
-        p = Vector3(np.random.rand(2,1,4,3))
-        v = Vector3(np.random.rand(  3,4,3))
-
-        self.assertEqual(tr.rotate_pos_vel(p,v)[0], p)
-        self.assertEqual(tr.rotate_pos_vel(p,v)[1], v)
-
-        self.assertEqual(tr.unrotate_pos_vel(p,v)[0], p)
-        self.assertEqual(tr.unrotate_pos_vel(p,v)[1], v)
-
-        tr = tr.invert()
-
-        self.assertEqual(tr.rotate_pos_vel(p,v)[0], p)
-        self.assertEqual(tr.rotate_pos_vel(p,v)[1], v)
-
-        self.assertEqual(tr.unrotate_pos_vel(p,v)[0], p)
-        self.assertEqual(tr.unrotate_pos_vel(p,v)[1], v)
-
-        tr = Transform(Matrix3([[1,0,0],[0,1,0],[0,0,1]]),
-                       Vector3([0,0,1]), "SPIN", "J2000")
-
-        self.assertEqual(tr.unrotate_pos_vel(p,v)[0], p)
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,2]), Scalar(v.mvals[...,2]))
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,0]),
-                                                Scalar(v.mvals[...,0]) + Scalar(p.mvals[...,1]))
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,1]),
-                                                Scalar(v.mvals[...,1]) - Scalar(p.mvals[...,0]))
-
-        tr = tr.invert()
-
-        self.assertEqual(tr.rotate(p), p)
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,2]), Scalar(v.mvals[...,2]))
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,0]),
-                                                Scalar(v.mvals[...,0]) - Scalar(p.mvals[...,1]))
-        self.assertEqual(Scalar(tr.rotate_pos_vel(p,v)[1].mvals[...,1]),
-                                                Scalar(v.mvals[...,1]) + Scalar(p.mvals[...,0]))
-
-        a = Vector3(np.random.rand(3,1,3))
-        b = Vector3(np.random.rand(1,1,3))
-        m = Matrix3.twovec(a,0,b,1)
-        omega = Vector3(np.random.rand(3,1,3))
-
-        tr = Transform(m, omega, "TEST", "J2000")
-
-#         self.assertEqual(tr.unrotate(p), tr.invert().rotate(p))
-#         self.assertEqual(tr.rotate(p), tr.invert().unrotate(p))
-        eps = 1.e-15
-        self.assertTrue(np.all(np.abs(tr.unrotate(p).vals - tr.invert().rotate(p).vals)) < eps)
-        self.assertTrue(np.all(np.abs(tr.rotate(p).vals - tr.invert().unrotate(p).vals)) < eps)
-
-        eps = 1.e-15
-        diff = tr.unrotate_pos_vel(p,v)[1] - tr.invert().rotate_pos_vel(p,v)[1]
-        self.assertTrue(np.all(diff.vals > -eps))
-        self.assertTrue(np.all(diff.vals <  eps))
-
-        diff = tr.rotate_pos_vel(p,v)[1] - tr.invert().unrotate_pos_vel(p,v)[1]
-        self.assertTrue(np.all(diff.vals > -eps))
-        self.assertTrue(np.all(diff.vals <  eps))
-
-        # Transform derivatives are unit tested as part of the SpinFrame tests
-
-########################################
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
-################################################################################
```

### Comparing `rms_oops-0.0.3/pyproject.toml` & `rms_oops-0.0.4/pyproject.toml`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/rms_oops.egg-info/PKG-INFO` & `rms_oops-0.0.4/rms_oops.egg-info/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: rms-oops
-Version: 0.0.3
+Version: 0.0.4
 Summary: Object-Oriented Python and SPICE
 Maintainer-email: "Robert S. French" <rfrench@seti.org>, "Joseph N. Spitale" <jspitale@seti.org>
 License: Apache-2.0
 Project-URL: Homepage, https://github.com/SETI/rms-oops
 Project-URL: Repository, https://github.com/SETI/rms-oops
 Project-URL: Source, https://github.com/SETI/rms-oops
 Project-URL: Issues, https://github.com/SETI/rms-oops/issues
```

### Comparing `rms_oops-0.0.3/scripts/automated_tests/oops_main_test.sh` & `rms_oops-0.0.4/scripts/automated_tests/oops_main_test.sh`

 * *Files 8% similar despite different names*

```diff
@@ -42,15 +42,15 @@
 
 echo "================================================================"
 echo "OOPS TESTS"
 echo "================================================================"
 echo
 echo "Test start:" `date`
 echo
-python -m coverage run -a -m unittest oops/unittester.py -v
+python -m coverage run -a -m unittest tests/unittester.py -v
 if [ $? -ne 0 ]; then
     echo "******************************"
     echo "*** OOPS FAILED UNIT TESTS ***"
     echo "******************************"
     echo
     echo "Test end:" `date`
     exit -1
```

### Comparing `rms_oops-0.0.3/spicedb/__init__.py` & `rms_oops-0.0.4/spicedb/__init__.py`

 * *Files identical despite different names*

### Comparing `rms_oops-0.0.3/spicedb/sqlite_db.py` & `rms_oops-0.0.4/spicedb/sqlite_db.py`

 * *Files identical despite different names*

