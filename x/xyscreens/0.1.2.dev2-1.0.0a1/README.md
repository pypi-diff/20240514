# Comparing `tmp/xyscreens-0.1.2.dev2.tar.gz` & `tmp/xyscreens-1.0.0a1.tar.gz`

## Comparing `xyscreens-0.1.2.dev2.tar` & `xyscreens-1.0.0a1.tar`

### file list

```diff
@@ -1,15 +1,16 @@
--rw-r--r--   0        0        0    48808 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/usb-rs485.png
--rw-r--r--   0        0        0      705 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/.github/FUNDING.yml
--rw-r--r--   0        0        0      525 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/.github/dependabot.yml
--rw-r--r--   0        0        0     1084 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/.github/workflows/python-publish.yml
--rw-r--r--   0        0        0      484 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/tests/__init__.py
--rw-r--r--   0        0        0     9273 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/tests/test_xyscreens.py
--rw-r--r--   0        0        0      254 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/xyscreens/__init__.py
--rw-r--r--   0        0        0     2434 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/xyscreens/__main__.py
--rw-r--r--   0        0        0      424 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/xyscreens/_version.py
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/xyscreens/py.typed
--rw-r--r--   0        0        0    14254 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/xyscreens/xyscreens.py
--rw-r--r--   0        0        0    11357 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/LICENSE
--rw-r--r--   0        0        0     4503 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/README.md
--rw-r--r--   0        0        0     1396 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/pyproject.toml
--rw-r--r--   0        0        0     5409 2020-02-02 00:00:00.000000 xyscreens-0.1.2.dev2/PKG-INFO
+-rw-r--r--   0        0        0    48808 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/usb-rs485.png
+-rw-r--r--   0        0        0      705 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/.github/FUNDING.yml
+-rw-r--r--   0        0        0      525 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/.github/dependabot.yml
+-rw-r--r--   0        0        0     1084 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/.github/workflows/python-publish.yml
+-rw-r--r--   0        0        0      484 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/tests/__init__.py
+-rw-r--r--   0        0        0    10556 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/tests/test_xyscreens.py
+-rw-r--r--   0        0        0      317 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/xyscreens/__init__.py
+-rw-r--r--   0        0        0     2434 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/xyscreens/__main__.py
+-rw-r--r--   0        0        0      413 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/xyscreens/_version.py
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/xyscreens/py.typed
+-rw-r--r--   0        0        0    15414 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/xyscreens/xyscreens.py
+-rw-r--r--   0        0        0       14 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/.gitignore
+-rw-r--r--   0        0        0    11357 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/LICENSE
+-rw-r--r--   0        0        0     5160 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/README.md
+-rw-r--r--   0        0        0     1471 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/pyproject.toml
+-rw-r--r--   0        0        0     6063 2020-02-02 00:00:00.000000 xyscreens-1.0.0a1/PKG-INFO
```

### Comparing `xyscreens-0.1.2.dev2/usb-rs485.png` & `xyscreens-1.0.0a1/usb-rs485.png`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/.github/FUNDING.yml` & `xyscreens-1.0.0a1/.github/FUNDING.yml`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/.github/dependabot.yml` & `xyscreens-1.0.0a1/.github/dependabot.yml`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/.github/workflows/python-publish.yml` & `xyscreens-1.0.0a1/.github/workflows/python-publish.yml`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/tests/test_xyscreens.py` & `xyscreens-1.0.0a1/tests/test_xyscreens.py`

 * *Files 8% similar despite different names*

```diff
@@ -114,41 +114,47 @@
         time.sleep(10)
         self.assertEqual(100.0, screen.position())
 
     def test_position_halfway(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         screen.down()
         time.sleep(5)
-        self.assertAlmostEqual(50.0, screen.position(), delta=0.1)
+        self.assertAlmostEqual(50.0, screen.position(), delta=0.3)
 
     def test_change_direction_down(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10, 100)
         screen.up()
         time.sleep(5)
         screen.down()
-        self.assertIs(XYScreensState.DOWNWARD, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.DOWNWARD, state)
+        self.assertAlmostEqual(50.0, position, delta=0.6)
 
     def test_change_direction_up(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         screen.down()
         time.sleep(5)
         screen.up()
-        self.assertIs(XYScreensState.UPWARD, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.UPWARD, state)
+        self.assertAlmostEqual(50.0, position, delta=0.6)
 
     def test_set_position_downward(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         screen.set_position(50.0)
-        self.assertIs(XYScreensState.STOPPED, screen.state())
-        self.assertAlmostEqual(50.0, screen.position(), 0)
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
 
     def test_set_position_upward(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10, 100.0)
         screen.set_position(50.0)
-        self.assertIs(XYScreensState.STOPPED, screen.state())
-        self.assertAlmostEqual(50.0, screen.position(), 0)
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
 
     @async_test
     async def test_async_down(self):
         screen = XYScreens(_SERIAL_PORT, 5, 5)
         callback = Mock()
         screen.add_callback(callback)
         self.assertTrue(await screen.async_down())
@@ -179,28 +185,30 @@
         self.assertIs(XYScreensState.UP, screen.state())
 
     @async_test
     async def test_async_state_closing(self):
         screen = XYScreens(_SERIAL_PORT, 60, 60, 100)
         await screen.async_up()
         self.assertIs(XYScreensState.UPWARD, screen.state())
+        await screen.async_stop()
 
     @async_test
     async def test_async_state_stopped(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_down()
         await asyncio.sleep(5)
         await screen.async_stop()
         self.assertIs(XYScreensState.STOPPED, screen.state())
 
     @async_test
     async def test_async_state_downward(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_down()
         self.assertIs(XYScreensState.DOWNWARD, screen.state())
+        await screen.async_stop()
 
     @async_test
     async def test_async_state_down(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_down()
         await asyncio.sleep(10.1)
         self.assertIs(XYScreensState.DOWN, screen.state())
@@ -220,63 +228,86 @@
         self.assertEqual(100.0, screen.position())
 
     @async_test
     async def test_async_position_halfway(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_down()
         await asyncio.sleep(5)
-        self.assertAlmostEqual(50.0, screen.position(), delta=0.1)
+        self.assertAlmostEqual(50.0, screen.position(), delta=0.3)
+        await screen.async_stop()
 
     @async_test
     async def test_async_change_direction_down(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10, 100)
         await screen.async_up()
         await asyncio.sleep(5)
         await screen.async_down()
-        self.assertIs(XYScreensState.DOWNWARD, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.DOWNWARD, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
+        await screen.async_stop()
 
     @async_test
     async def test_async_change_direction_up(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_down()
         await asyncio.sleep(5)
         await screen.async_up()
-        self.assertIs(XYScreensState.UPWARD, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.UPWARD, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
+        await screen.async_stop()
 
     @async_test
     async def test_async_set_position_downward(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10)
         await screen.async_set_position(50.0)
         await asyncio.sleep(5.1)
-        self.assertIs(XYScreensState.STOPPED, screen.state())
-        self.assertAlmostEqual(50.0, screen.position(), 0)
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
 
     @async_test
     async def test_async_set_position_upward(self):
         screen = XYScreens(_SERIAL_PORT, 10, 10, 100.0)
         await screen.async_set_position(50.0)
         await asyncio.sleep(5.1)
-        self.assertIs(XYScreensState.STOPPED, screen.state())
-        self.assertAlmostEqual(50.0, screen.position(), 0)
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
+
+    @async_test
+    async def test_async_set_position_stop(self):
+        """Test stopping the screen while it is moving to a given position."""
+        screen = XYScreens(_SERIAL_PORT, 10, 10)
+        await screen.async_down()
+        await asyncio.sleep(5)
+        await screen.async_stop()
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertAlmostEqual(50.0, position, delta=0.3)
 
     def test_restore_position_up(self):
         screen = XYScreens(_SERIAL_PORT, 60)
         screen.restore_position(0.0)
-        self.assertEqual(0.0, screen.position())
-        self.assertIs(XYScreensState.UP, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.UP, state)
+        self.assertEqual(0.0, position)
 
     def test_restore_position_down(self):
         screen = XYScreens(_SERIAL_PORT, 60)
         screen.restore_position(100.0)
-        self.assertEqual(100.0, screen.position())
-        self.assertIs(XYScreensState.DOWN, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.DOWN, state)
+        self.assertEqual(100.0, position)
 
     def test_restore_position_halfway(self):
         screen = XYScreens(_SERIAL_PORT, 60)
         screen.restore_position(50.0)
-        self.assertAlmostEqual(50.0, screen.position())
-        self.assertIs(XYScreensState.STOPPED, screen.state())
+        (state, position) = screen.update_status()
+        self.assertIs(XYScreensState.STOPPED, state)
+        self.assertEqual(50.0, position)
 
 
 if __name__ == "__main__":
     # import sys;sys.argv = ['', 'Test.testConstructor']
     unittest.main()
```

### Comparing `xyscreens-0.1.2.dev2/xyscreens/__main__.py` & `xyscreens-1.0.0a1/xyscreens/__main__.py`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/xyscreens/xyscreens.py` & `xyscreens-1.0.0a1/xyscreens/xyscreens.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,14 +15,22 @@
 
 import serial
 import serial_asyncio
 
 logger = logging.getLogger(__name__)
 
 
+class XYScreensConnectionError(Exception):
+    """
+    XY Screens Connection Error.
+
+    When an error occurs while connecting to the projector screen or lift.
+    """
+
+
 class XYScreensCommand(StrEnum):
     "The commands needed to move and stop the screen"
 
     UP = "FFAAEEEEDD"
     STOP = "FFAAEEEECC"
     DOWN = "FFAAEEEEEE"
 
@@ -58,57 +66,57 @@
 
 class XYScreens:
     "XYScreens class for controlling XY Screens projector screens and projector lifts."
 
     # The serial port where the RS-485 interface and screen is connected to.
     _serial_port: str | None = None
     # The amount of time in seconds it takes the cover to close from the fully-open state.
-    _close_duration: float
+    _up_duration: float
     # The amount of time in seconds it takes the screen to open up from the fully-closed state.
-    _open_duration: float
+    _down_duration: float
 
     # Current state of the screen. Defaults to Up when object is created.
     _state: XYScreensState = XYScreensState.UP
     # Position of the screen where 0.0 is totally up and 100.0 is fully down.
     _position: float = 0.0
-    # Timestamp when the up or down command has been executed.
-    _timestamp: float
+    # Timestamp then the position was last recomputed
+    _last_recompute_time: int = 0
 
     # List of callbacks which need to be called when the screen status changes.
     _callbacks: list[Any] | None = None
     # The task that handles the set position functionality in async mode.
     _set_position_task: asyncio.Task | None = None
 
     def __init__(
         self,
         serial_port: str,  # The serial port where the RS-485 interface and screen is connected to.
-        open_duration: float,  # Duration in seconds for the screen to go down.
-        close_duration: (
+        down_duration: float,  # Duration in seconds for the screen to go down.
+        up_duration: (
             float | None
         ) = None,  # Duration in seconds for the screen to go up.
         position: float = 0.0,  # Position of the screen where 0.0 is totally up and 100.0 is
         # fully down.
     ):
         "Initialises the XYScreens object."
         # Validate the different arguments.
         assert serial_port is not None
-        assert open_duration > 0.0
-        assert close_duration is None or close_duration > 0.0
+        assert down_duration > 0.0
+        assert up_duration is None or up_duration > 0.0
 
         self._serial_port = serial_port
         # Set the duration for the screen to go down.
-        self._open_duration = open_duration
+        self._down_duration = down_duration
 
         # Set the duration for the screen to go up.
-        if close_duration is not None:
-            self._close_duration = close_duration
+        if up_duration is not None:
+            self._up_duration = up_duration
         # If no duration for the screen to go up is given use the same value as the duration for
         # the screen to go down.
         else:
-            self._close_duration = open_duration
+            self._up_duration = self._down_duration
 
         # Set the initial position of the screen.
         self.restore_position(position)
 
     def restore_position(self, position: float) -> None:
         """
         Restores the position of the screen, mainly introduced to restore the screen state in Home
@@ -129,14 +137,16 @@
         # If screen position is 100.0% it's in a totally extended position and the state is Down
         elif self._position == 100.0:
             self._state = XYScreensState.DOWN
         # If screen position is anywhere in between 0.0% and 100.0% the state is Stopped
         else:
             self._state = XYScreensState.STOPPED
 
+        self._last_recompute_time = time.time_ns()
+
     def add_callback(self, callback):
         """
         Adds an Event Occurred Callback to the UNii.
         """
 
         if self._callbacks is None:
             self._callbacks = []
@@ -151,89 +161,102 @@
                 baudrate=2400,
                 bytesize=serial.EIGHTBITS,
                 parity=serial.PARITY_NONE,
                 stopbits=serial.STOPBITS_ONE,
                 timeout=1,
             )
         except serial.SerialException as ex:
-            logger.exception(
-                "Unable to connect to the device %s: %s", self._serial_port, ex
-            )
-            return False
+            raise XYScreensConnectionError(
+                f"Unable to connect to device {self._serial_port}"
+            ) from ex
         logger.debug("Device %s connected", self._serial_port)
 
         try:
             # Open the connection.
             if not connection.is_open:
                 connection.open()
 
             # Send the command.
             connection.write(command)
             connection.flush()
             logger.info("Command successfully send")
 
             # Close the connection.
             connection.close()
-        except serial.SerialException as ex:
-            logger.exception("Error while writing device %s: %s", self._serial_port, ex)
-        else:
+
             return True
+        except serial.SerialException as ex:
+            raise XYScreensConnectionError(
+                f"Error while writing to device {self._serial_port}"
+            ) from ex
 
         return False
 
     async def _async_send_command(self, command: bytes) -> bool:
         try:
             _, writer = await serial_asyncio.open_serial_connection(
                 url=self._serial_port,
                 baudrate=2400,
                 bytesize=serial.EIGHTBITS,
                 parity=serial.PARITY_NONE,
                 stopbits=serial.STOPBITS_ONE,
                 timeout=1,
             )
         except serial.SerialException as ex:
-            logger.exception(
-                "Unable to connect to the device %s: %s", self._serial_port, ex
-            )
-            return False
+            raise XYScreensConnectionError(
+                f"Unable to connect to device {self._serial_port}"
+            ) from ex
         logger.debug("Device %s connected", self._serial_port)
 
         try:
             # Send the command.
             writer.write(command)
             await writer.drain()
             logger.info("Command successfully send")
 
             # Close the connection.
             writer.close()
 
             return True
         except serial.SerialException as ex:
-            logger.exception("Error while writing device %s: %s", self._serial_port, ex)
+            raise XYScreensConnectionError(
+                f"Error while writing to device {self._serial_port}"
+            ) from ex
 
         return False
 
     def update_status(self) -> Tuple[XYScreensState, float]:
         """
         Calculates and returns the status and position of the screen based on the direction the
         screen is moving.
         """
         if self._state == XYScreensState.DOWNWARD:
-            position = ((time.time() - self._timestamp) / self._open_duration) * 100.0
-            if position >= 100.0:
-                self._state = XYScreensState.DOWN
-                position = 100.0
-            self._position = position
+            direction = 1.0
+            action_duration = self._down_duration
         elif self._state == XYScreensState.UPWARD:
-            position = ((time.time() - self._timestamp) / self._close_duration) * 100.0
-            position = 100 - position
-            if position <= 0.0:
-                self._state = XYScreensState.UP
-                position = 0.0
-            self._position = position
+            direction = -1.0
+            action_duration = self._up_duration
+        else:
+            self._last_recompute_time = time.time_ns()
+            return (self._state, self._position)
+
+        now = time.time_ns()
+        time_delta = now - self._last_recompute_time
+        movement = direction * time_delta / (action_duration * 10000000)
+        position = self._position + movement
+        self._last_recompute_time = now
+
+        if position >= 100.0:
+            self._state = XYScreensState.DOWN
+            position = 100.0
+        if position <= 0.0:
+            self._state = XYScreensState.UP
+            position = 0.0
+
+        self._position = position
 
         return (self._state, self._position)
 
     def _update_callbacks(self):
         if self._callbacks is None:
             return
 
@@ -241,23 +264,16 @@
             try:
                 callback(self._state, self._position)
             # pylint: disable=broad-exception-caught
             except Exception as ex:
                 logger.error("Exception in callback: %s", ex)
 
     def _post_up(self) -> bool:
-        if self._state is XYScreensState.DOWNWARD:
-            self.update_status()
-
         if self._state not in (XYScreensState.UPWARD, XYScreensState.UP):
-            self._timestamp = time.time() - (
-                (100.0 - self._position) * (self._close_duration / 100)
-            )
-            logger.debug("up() time stamp: %s", self._timestamp)
-            logger.debug("up() position: %s", self._position)
+            self.update_status()
             self._state = XYScreensState.UPWARD
             return True
 
         return False
 
     # pylint: disable=C0103
     def up(self) -> bool:
@@ -293,33 +309,28 @@
             return self._post_stop()
 
         return False
 
     async def async_stop(self) -> bool:
         "Stop the screen."
 
+        await self._cancel_set_position()
+
         if (
             await self._async_send_command(XYScreensCommand.STOP.to_bytes())
             and self._post_stop()
         ):
             self._update_callbacks()
             return True
 
         return False
 
     def _post_down(self) -> bool:
-        if self._state is XYScreensState.UPWARD:
-            self.update_status()
-
         if self._state not in (XYScreensState.DOWNWARD, XYScreensState.DOWN):
-            self._timestamp = time.time() - (
-                self._position * (self._open_duration / 100)
-            )
-            logger.debug("down() time stamp: %s", self._timestamp)
-            logger.debug("down() position: %s", self._position)
+            self.update_status()
             self._state = XYScreensState.DOWNWARD
             return True
 
         return False
 
     def down(self) -> bool:
         "Move the screen down."
@@ -333,15 +344,14 @@
         "Move the screen down."
 
         return await self.async_set_position(100.0)
 
     def _target_position_reached(self, target_position: float) -> bool:
         """Calculates if the target position has been reached."""
         self.update_status()
-        self._update_callbacks()
 
         if self._state == XYScreensState.DOWNWARD:
             return self._position >= target_position
         if self._state == XYScreensState.UPWARD:
             return self._position <= target_position
 
         # Target position has been reached
@@ -355,63 +365,98 @@
             return self.stop()
 
         if self._position < target_position and not self.down():
             return False
         if self._position > target_position and not self.up():
             return False
 
-        sleep_duration = min(self._close_duration, self._open_duration) / 1000.0
+        sleep_duration = min(self._up_duration, self._down_duration) / 1000.0
         while True:
             if self._target_position_reached(target_position):
                 if self._state in (XYScreensState.UPWARD, XYScreensState.DOWNWARD):
                     self.stop()
                 break
 
             time.sleep(sleep_duration)
 
         return True
 
     async def async_set_position(self, target_position: float) -> bool:
         """Initiates the screen to move to a given position."""
         assert 0.0 <= target_position <= 100.0
 
-        if self._set_position_task is not None and not self._set_position_task.done():
-            if not self._set_position_task.cancel():
-                logger.error("Failed to cancel previous set position task")
-                return False
-            logger.debug("Canceled previous set position task")
-
         if round(self._position) == round(target_position):
             return await self.async_stop()
 
+        await self._cancel_set_position()
+
         if self._position < target_position:
-            await self._async_send_command(XYScreensCommand.DOWN.to_bytes())
+            if not await self._async_send_command(XYScreensCommand.DOWN.to_bytes()):
+                return False
             self._post_down()
         elif self._position > target_position:
-            await self._async_send_command(XYScreensCommand.UP.to_bytes())
+            if not await self._async_send_command(XYScreensCommand.UP.to_bytes()):
+                return False
             self._post_up()
 
         self._set_position_task = asyncio.create_task(
             self._set_position_coroutine(target_position)
         )
 
         return True
 
+    async def _cancel_set_position(self) -> bool:
+        if self._set_position_task is not None and not (
+            self._set_position_task.done() or self._set_position_task.cancelled()
+        ):
+            if not self._set_position_task.cancel():
+                logger.error("Failed to cancel set position task")
+                logger.debug("Set position task: %s", self._set_position_task)
+                return False
+            try:
+                await self._set_position_task
+            except asyncio.CancelledError:
+                logger.debug("Set position task was cancelled")
+
+        if self._set_position_task is not None:
+            if self._set_position_task.done() or self._set_position_task.cancelled():
+                self._set_position_task = None
+            else:
+                logger.error("Failed to cancel set position task")
+                logger.debug("Set position task: %s", self._set_position_task)
+                return False
+
+        self.update_status()
+        self._update_callbacks()
+
+        return self._set_position_task is None
+
     async def _set_position_coroutine(self, target_position: float):
-        sleep_duration = min(self._close_duration, self._open_duration) / 1000.0
+        sleep_duration = min(self._up_duration, self._down_duration) / 1000.0
         while True:
-            self._update_callbacks()
+            try:
+                target_position_reached = self._target_position_reached(target_position)
 
-            if self._target_position_reached(target_position):
-                if self._state in (XYScreensState.UPWARD, XYScreensState.DOWNWARD):
-                    await self._async_send_command(XYScreensCommand.STOP.to_bytes())
-                    self._post_stop()
-                break
+                self._update_callbacks()
 
-            await asyncio.sleep(sleep_duration)
+                if target_position_reached:
+                    if self._state in (
+                        XYScreensState.UPWARD,
+                        XYScreensState.DOWNWARD,
+                    ) and await self._async_send_command(
+                        XYScreensCommand.STOP.to_bytes()
+                    ):
+                        self._post_stop()
+                        self._update_callbacks()
+                    break
+
+                await asyncio.sleep(sleep_duration)
+            except asyncio.CancelledError:
+                logger.debug("Set position task was canceled")
+                break
 
     def state(self) -> XYScreensState:
         "Returns the current state of the screen."
         (state, _) = self.update_status()
 
         return state
```

### Comparing `xyscreens-0.1.2.dev2/LICENSE` & `xyscreens-1.0.0a1/LICENSE`

 * *Files identical despite different names*

### Comparing `xyscreens-0.1.2.dev2/README.md` & `xyscreens-1.0.0a1/README.md`

 * *Files 12% similar despite different names*

```diff
@@ -15,17 +15,26 @@
 interface.
 
 XY Screens is an OEM manufacturer of projector screens and lifts, their devices are sold around the
 world under various brand names.
 
 ## Features
 
-* Calculates screen position
-* Synchronous and asynchronous methods
-* Uses Callbacks for asynchronous methods
+- Position control, move the screen/lift to any position along the way
+- Synchronous and asynchronous methods
+- Uses Callbacks for asynchronous methods
+
+### About position control
+
+The XY Screens projector screens and lifts do not provide any positional feedback. The state of the
+screen is thus always an assumed one. The screen position is calculated based on the time the cover
+has moved and the configured up and down durations. This results in a potentioal error margin.
+Every time the screen reaches it maximum up or down position the position and thus any potential
+error is reset accordingly. If the screen is controlled outside of Home Assistant, for instance
+with the remote control, the screen position and state will no longer represent the actual state.
 
 ## Hardware
 
 I use a cheap USB RS-485 controller to talk to the projector screen where position 5 of the RJ25
 connector is connected to D+ and position 6 to the D-.
 
 ![image](https://raw.githubusercontent.com/rrooggiieerr/xyscreens.py/main/usb-rs485.png)
@@ -41,24 +50,24 @@
 Down command: 0xFF 0xAA 0xEE 0xEE 0xEE  
 Stop command: 0xFF 0xAA 0xEE 0xEE 0xCC
 
 ## Supported projector screens and lifts
 
 The following projector screens is known to work:
 
-* iVisions Electro M Series
+- iVisions Electro M Series
 
 The following projector screens and lifts are not tested but use the same protocol according to the
 documentation:
 
-* iVisions Electro L/XL/Pro/HD Series
-* iVisions PL Series projector lift
-* Elite Screens
-* KIMEX
-* DELUXX
+- iVisions Electro L/XL/Pro/HD Series
+- iVisions PL Series projector lift
+- Elite Screens
+- KIMEX
+- DELUXX
 
 Please let me know if your projector screen or projector lift works with this Python library so I
 can improve the overview of supported projector screens and lifts.
 
 ## Installation
 
 You can install the Python XY Screens library using the Python package manager PIP:
```

### Comparing `xyscreens-0.1.2.dev2/pyproject.toml` & `xyscreens-1.0.0a1/pyproject.toml`

 * *Files 22% similar despite different names*

```diff
@@ -34,22 +34,26 @@
     "pyserial_asyncio>=0.6"
 ]
 
 [project.urls]
 Homepage = "https://github.com/rrooggiieerr/xyscreens.py"
 Issues = "https://github.com/rrooggiieerr/xyscreens.py/issues"
 
-[tool.black]
-target-version = ["py311", "py312"]
-exclude = 'generated'
-
 [tool.isort]
 # https://github.com/PyCQA/isort/wiki/isort-Settings
 profile = "black"
+skip = "xyscreens/_version.py"
+
+[tool.black]
+exclude = "xyscreens/_version.py"
+
+[tool.pylint]
+ignore = "_version.py"
+recursive = "y"
 
 [tool.mypy]
 python_version = "3.11"
 mypy_path = "xyscreens"
 
 [[tool.mypy.overrides]]
-module = ["serial.*", "serial_asyncio.*"]
+module = ["serial.*", "serial_asyncio.*", "*._version"]
 ignore_missing_imports = true
```

### Comparing `xyscreens-0.1.2.dev2/PKG-INFO` & `xyscreens-1.0.0a1/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.3
 Name: xyscreens
-Version: 0.1.2.dev2
+Version: 1.0.0a1
 Summary: Library to control XY Screens projector screens and lifts.
 Project-URL: Homepage, https://github.com/rrooggiieerr/xyscreens.py
 Project-URL: Issues, https://github.com/rrooggiieerr/xyscreens.py/issues
 Author-email: Rogier van Staveren <rogier@batoid.com>
 License: Apache-2.0
 License-File: LICENSE
 Classifier: Development Status :: 4 - Beta
@@ -37,17 +37,26 @@
 interface.
 
 XY Screens is an OEM manufacturer of projector screens and lifts, their devices are sold around the
 world under various brand names.
 
 ## Features
 
-* Calculates screen position
-* Synchronous and asynchronous methods
-* Uses Callbacks for asynchronous methods
+- Position control, move the screen/lift to any position along the way
+- Synchronous and asynchronous methods
+- Uses Callbacks for asynchronous methods
+
+### About position control
+
+The XY Screens projector screens and lifts do not provide any positional feedback. The state of the
+screen is thus always an assumed one. The screen position is calculated based on the time the cover
+has moved and the configured up and down durations. This results in a potentioal error margin.
+Every time the screen reaches it maximum up or down position the position and thus any potential
+error is reset accordingly. If the screen is controlled outside of Home Assistant, for instance
+with the remote control, the screen position and state will no longer represent the actual state.
 
 ## Hardware
 
 I use a cheap USB RS-485 controller to talk to the projector screen where position 5 of the RJ25
 connector is connected to D+ and position 6 to the D-.
 
 ![image](https://raw.githubusercontent.com/rrooggiieerr/xyscreens.py/main/usb-rs485.png)
@@ -63,24 +72,24 @@
 Down command: 0xFF 0xAA 0xEE 0xEE 0xEE  
 Stop command: 0xFF 0xAA 0xEE 0xEE 0xCC
 
 ## Supported projector screens and lifts
 
 The following projector screens is known to work:
 
-* iVisions Electro M Series
+- iVisions Electro M Series
 
 The following projector screens and lifts are not tested but use the same protocol according to the
 documentation:
 
-* iVisions Electro L/XL/Pro/HD Series
-* iVisions PL Series projector lift
-* Elite Screens
-* KIMEX
-* DELUXX
+- iVisions Electro L/XL/Pro/HD Series
+- iVisions PL Series projector lift
+- Elite Screens
+- KIMEX
+- DELUXX
 
 Please let me know if your projector screen or projector lift works with this Python library so I
 can improve the overview of supported projector screens and lifts.
 
 ## Installation
 
 You can install the Python XY Screens library using the Python package manager PIP:
```

