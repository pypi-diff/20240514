# Comparing `tmp/hvl_ccb-0.8.5.tar.gz` & `tmp/hvl_ccb-0.9.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "dist/hvl_ccb-0.8.5.tar", last modified: Fri Nov  5 16:40:56 2021, max compression
+gzip compressed data, was "hvl_ccb-0.9.0.tar", last modified: Fri Jan  7 20:25:04 2022, max compression
```

## Comparing `hvl_ccb-0.8.5.tar` & `hvl_ccb-0.9.0.tar`

### file list

```diff
@@ -1,212 +1,294 @@
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:56.000000 hvl_ccb-0.8.5/
--rw-r--r--   0 mikolajr   (501) staff       (20)      794 2021-09-27 08:43:54.000000 hvl_ccb-0.8.5/AUTHORS.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)     6174 2021-11-05 16:30:00.000000 hvl_ccb-0.8.5/CONTRIBUTING.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)    10350 2021-11-05 16:18:04.000000 hvl_ccb-0.8.5/HISTORY.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)     3098 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/INSTALLATION.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)     1640 2020-08-14 09:42:42.000000 hvl_ccb-0.8.5/LICENSE
--rw-r--r--   0 mikolajr   (501) staff       (20)      287 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/MANIFEST.in
--rw-r--r--   0 mikolajr   (501) staff       (20)    29142 2021-11-05 16:40:56.000000 hvl_ccb-0.8.5/PKG-INFO
--rw-r--r--   0 mikolajr   (501) staff       (20)    10124 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/README.rst
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/docs/
--rw-r--r--   0 mikolajr   (501) staff       (20)      608 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/Makefile
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/docs/_build/
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/docs/_build/html/
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/docs/_build/html/_static/
--rw-r--r--   0 mikolajr   (501) staff       (20)      286 2021-11-05 15:22:01.000000 hvl_ccb-0.8.5/docs/_build/html/_static/file.png
--rw-r--r--   0 mikolajr   (501) staff       (20)       90 2021-11-05 15:22:01.000000 hvl_ccb-0.8.5/docs/_build/html/_static/minus.png
--rw-r--r--   0 mikolajr   (501) staff       (20)       90 2021-11-05 15:22:01.000000 hvl_ccb-0.8.5/docs/_build/html/_static/plus.png
--rw-r--r--   0 mikolajr   (501) staff       (20)       28 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/authors.rst
--rwxr-xr-x   0 mikolajr   (501) staff       (20)     5753 2021-09-27 08:43:54.000000 hvl_ccb-0.8.5/docs/conf.py
--rw-r--r--   0 mikolajr   (501) staff       (20)       33 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/contributing.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)       28 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/history.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      187 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.base.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      217 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.labjack_ljm.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      213 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.modbus_tcp.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      183 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.opc.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      383 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      195 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.serial.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      183 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.tcp.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      195 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.telnet.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      187 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.comm.visa.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      203 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.configuration.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      183 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.base.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      191 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.crylas.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      209 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.ea_psi9000.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      179 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.fug.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      207 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.heinzinger.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      195 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.labjack.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      187 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.lauda.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      191 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.mbw973.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      195 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.newport.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      217 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.pfeiffer_tpg.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      784 2021-11-05 16:30:44.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.picotech_pt104.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      209 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.rs_rto1024.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      730 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      201 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.se_ils2t.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      213 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.sst_luminox.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      223 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube.base.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      243 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube.constants.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      354 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      229 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube.typ_a.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      229 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube.typ_b.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      239 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube2015.base.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      259 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube2015.constants.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      347 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube2015.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      245 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.supercube2015.typ_a.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      195 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.technix.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      211 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.base.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      223 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.channel.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      219 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.device.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      231 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.generator.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      207 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.i2c.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      243 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.oscilloscope.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      425 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      215 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.tiepie.utils.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      187 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.utils.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      183 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.dev.visa.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      225 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.experiment_manager.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      344 2021-11-05 16:18:59.000000 hvl_ccb-0.8.5/docs/hvl_ccb.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      245 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.conversion_sensor.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      237 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.conversion_unit.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      191 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.enum.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      345 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      199 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.typing.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      215 2021-11-05 16:19:00.000000 hvl_ccb-0.8.5/docs/hvl_ccb.utils.validation.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      327 2019-04-09 08:55:15.000000 hvl_ccb-0.8.5/docs/index.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)       33 2019-05-10 09:04:49.000000 hvl_ccb-0.8.5/docs/installation.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)      769 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/make.bat
--rw-r--r--   0 mikolajr   (501) staff       (20)       78 2021-06-04 09:00:12.000000 hvl_ccb-0.8.5/docs/modules.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)       27 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/readme.rst
--rw-r--r--   0 mikolajr   (501) staff       (20)       82 2019-01-08 15:43:57.000000 hvl_ccb-0.8.5/docs/usage.rst
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/
--rw-r--r--   0 mikolajr   (501) staff       (20)      694 2021-11-05 16:31:56.000000 hvl_ccb-0.8.5/hvl_ccb/__init__.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/_dev/
--rw-r--r--   0 mikolajr   (501) staff       (20)      190 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/_dev/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     5960 2021-09-27 08:43:54.000000 hvl_ccb-0.8.5/hvl_ccb/_dev/labjack.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/comm/
--rw-r--r--   0 mikolajr   (501) staff       (20)     1447 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/hvl_ccb/comm/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    11003 2021-07-09 10:05:45.000000 hvl_ccb-0.8.5/hvl_ccb/comm/base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     9820 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/comm/labjack_ljm.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4978 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/comm/modbus_tcp.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    11886 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/comm/opc.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     7445 2021-07-09 10:05:45.000000 hvl_ccb-0.8.5/hvl_ccb/comm/serial.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2650 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/hvl_ccb/comm/tcp.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3852 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/comm/telnet.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    11791 2021-07-09 10:05:45.000000 hvl_ccb-0.8.5/hvl_ccb/comm/visa.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8490 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/hvl_ccb/configuration.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/dev/
--rw-r--r--   0 mikolajr   (501) staff       (20)     6091 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8802 2021-06-04 13:09:21.000000 hvl_ccb-0.8.5/hvl_ccb/dev/base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    36210 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/crylas.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    20198 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/hvl_ccb/dev/ea_psi9000.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    41564 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/fug.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    17409 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/dev/heinzinger.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    26207 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/hvl_ccb/dev/labjack.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    17641 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/hvl_ccb/dev/lauda.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8729 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/mbw973.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    45659 2021-09-27 08:43:54.000000 hvl_ccb-0.8.5/hvl_ccb/dev/newport.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    18496 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/pfeiffer_tpg.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    13846 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/hvl_ccb/dev/picotech_pt104.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    26785 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/dev/rs_rto1024.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    34297 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/se_ils2t.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    12360 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/dev/sst_luminox.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/
--rw-r--r--   0 mikolajr   (501) staff       (20)      343 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    21148 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    25622 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/constants.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4193 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/typ_a.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      887 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube/typ_b.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/
--rw-r--r--   0 mikolajr   (501) staff       (20)      337 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    15410 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    15490 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/constants.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3916 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/typ_a.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    12756 2021-06-04 09:00:12.000000 hvl_ccb-0.8.5/hvl_ccb/dev/technix.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/
--rw-r--r--   0 mikolajr   (501) staff       (20)     1817 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8213 2021-06-04 09:00:12.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    11281 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/channel.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      590 2021-06-04 09:00:12.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/device.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8860 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/generator.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2539 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/i2c.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    22040 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/oscilloscope.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1089 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/utils.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4612 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/dev/utils.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     6821 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/dev/visa.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     5659 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/experiment_manager.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb/utils/
--rw-r--r--   0 mikolajr   (501) staff       (20)       63 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/hvl_ccb/utils/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4911 2021-11-04 14:33:59.000000 hvl_ccb-0.8.5/hvl_ccb/utils/conversion_sensor.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4665 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/hvl_ccb/utils/conversion_unit.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1799 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/hvl_ccb/utils/enum.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1837 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/hvl_ccb/utils/typing.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3779 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/hvl_ccb/utils/validation.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/
--rw-r--r--   0 mikolajr   (501) staff       (20)    29142 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/PKG-INFO
--rw-r--r--   0 mikolajr   (501) staff       (20)     5462 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/SOURCES.txt
--rw-r--r--   0 mikolajr   (501) staff       (20)        1 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/dependency_links.txt
--rw-r--r--   0 mikolajr   (501) staff       (20)        1 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/not-zip-safe
--rw-r--r--   0 mikolajr   (501) staff       (20)      333 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/requires.txt
--rw-r--r--   0 mikolajr   (501) staff       (20)        8 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/hvl_ccb.egg-info/top_level.txt
--rw-r--r--   0 mikolajr   (501) staff       (20)      528 2021-11-05 16:40:56.000000 hvl_ccb-0.8.5/setup.cfg
--rw-r--r--   0 mikolajr   (501) staff       (20)     3491 2021-11-05 16:31:56.000000 hvl_ccb-0.8.5/setup.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/tests/
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:55.000000 hvl_ccb-0.8.5/tests/masked_comm/
--rw-r--r--   0 mikolajr   (501) staff       (20)      303 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/tests/masked_comm/__init__.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2212 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/masked_comm/labjack_ljm.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2182 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/masked_comm/serial.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3323 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/tests/masked_comm/tcp.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3577 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/masked_comm/telnet_mockup.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      289 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/masked_comm/uitls.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1495 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/masked_comm/visa.py
-drwxr-xr-x   0 mikolajr   (501) staff       (20)        0 2021-11-05 16:40:56.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/
--rw-r--r--   0 mikolajr   (501) staff       (20)      499 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/const.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2103 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/devicelist.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4306 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/devicelistitem.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2631 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/generator.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      261 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/i2chost.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     5608 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscope.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2140 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechannel.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1473 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechanneltrigger.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      690 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechanneltriggerhystereses.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      670 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechanneltriggerlevels.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      340 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/mock_libtiepie/server.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1221 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/opctools.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1632 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_comm_base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4260 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_comm_labjack_ljm.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1214 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_comm_modbus_tcp.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     6992 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_comm_opcua.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4777 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/tests/test_comm_serial.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2119 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_comm_tcp.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3357 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/tests/test_comm_telnet.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3431 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_comm_visa.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4649 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/tests/test_configuration.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     4571 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/tests/test_dev_base.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    28291 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_crylas.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    12093 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_ea_psi9000.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    14507 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_fug.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    12246 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_heinzinger.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    10852 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_labjack.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8011 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_lauda.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8053 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_mbw973.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    26044 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_newport.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    10592 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_pfeiffer_tpg.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1137 2021-07-30 07:26:11.000000 hvl_ccb-0.8.5/tests/test_dev_picotech_pt104.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    12746 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_rs_rto1024.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    14332 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/tests/test_dev_se_ils2t.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8156 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_sst_luminox.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    18021 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     8396 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube2015.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3545 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube2015_a.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3288 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube_a.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      379 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube_b.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2682 2021-11-04 09:42:19.000000 hvl_ccb-0.8.5/tests/test_dev_supercube_constants.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     7069 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/tests/test_dev_technix.py
--rw-r--r--   0 mikolajr   (501) staff       (20)    24952 2021-11-05 15:08:09.000000 hvl_ccb-0.8.5/tests/test_dev_tiepie.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2192 2021-09-27 10:44:08.000000 hvl_ccb-0.8.5/tests/test_dev_visa.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     2253 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_experiment_manager.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     3784 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/tests/test_utils_conversion.py
--rw-r--r--   0 mikolajr   (501) staff       (20)      969 2021-11-04 14:33:59.000000 hvl_ccb-0.8.5/tests/test_utils_conversion_sensor.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1868 2021-06-21 15:02:31.000000 hvl_ccb-0.8.5/tests/test_utils_enum.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1227 2021-05-31 16:38:36.000000 hvl_ccb-0.8.5/tests/test_utils_typing.py
--rw-r--r--   0 mikolajr   (501) staff       (20)     1724 2021-10-27 08:42:34.000000 hvl_ccb-0.8.5/tests/test_utils_validation.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.643365 hvl_ccb-0.9.0/
+-rw-rw-rw-   0        0        0      794 2022-01-07 19:38:34.000000 hvl_ccb-0.9.0/AUTHORS.rst
+-rw-rw-rw-   0        0        0     6233 2022-01-07 20:07:23.000000 hvl_ccb-0.9.0/CONTRIBUTING.rst
+-rw-rw-rw-   0        0        0    11161 2022-01-07 19:36:39.000000 hvl_ccb-0.9.0/HISTORY.rst
+-rw-rw-rw-   0        0        0     3191 2021-10-05 11:06:40.000000 hvl_ccb-0.9.0/INSTALLATION.rst
+-rw-rw-rw-   0        0        0     1673 2020-08-05 11:40:23.000000 hvl_ccb-0.9.0/LICENSE
+-rw-rw-rw-   0        0        0      299 2021-10-05 11:06:40.000000 hvl_ccb-0.9.0/MANIFEST.in
+-rw-rw-rw-   0        0        0    27335 2022-01-07 20:25:04.643365 hvl_ccb-0.9.0/PKG-INFO
+-rw-rw-rw-   0        0        0    11113 2022-01-07 19:47:27.000000 hvl_ccb-0.9.0/README.rst
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:03.982741 hvl_ccb-0.9.0/docs/
+-rw-rw-rw-   0        0        0      628 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/Makefile
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:03.844492 hvl_ccb-0.9.0/docs/_build/
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:03.845577 hvl_ccb-0.9.0/docs/_build/html/
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:03.986741 hvl_ccb-0.9.0/docs/_build/html/_static/
+-rw-rw-rw-   0        0        0      286 2021-08-30 15:26:01.000000 hvl_ccb-0.9.0/docs/_build/html/_static/file.png
+-rw-rw-rw-   0        0        0       90 2021-08-30 15:26:01.000000 hvl_ccb-0.9.0/docs/_build/html/_static/minus.png
+-rw-rw-rw-   0        0        0       90 2021-08-30 15:26:01.000000 hvl_ccb-0.9.0/docs/_build/html/_static/plus.png
+-rw-rw-rw-   0        0        0       29 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/authors.rst
+-rw-rw-rw-   0        0        0     5942 2021-09-10 12:16:41.000000 hvl_ccb-0.9.0/docs/conf.py
+-rw-rw-rw-   0        0        0       34 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/contributing.rst
+-rw-rw-rw-   0        0        0       29 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/history.rst
+-rw-rw-rw-   0        0        0      200 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.base.rst
+-rw-rw-rw-   0        0        0      230 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.labjack_ljm.rst
+-rw-rw-rw-   0        0        0      226 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.modbus_tcp.rst
+-rw-rw-rw-   0        0        0      196 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.opc.rst
+-rw-rw-rw-   0        0        0      409 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.rst
+-rw-rw-rw-   0        0        0      208 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.serial.rst
+-rw-rw-rw-   0        0        0      196 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.tcp.rst
+-rw-rw-rw-   0        0        0      208 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.telnet.rst
+-rw-rw-rw-   0        0        0      200 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.comm.visa.rst
+-rw-rw-rw-   0        0        0      216 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.configuration.rst
+-rw-rw-rw-   0        0        0      196 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.base.rst
+-rw-rw-rw-   0        0        0      204 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.crylas.rst
+-rw-rw-rw-   0        0        0      222 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.ea_psi9000.rst
+-rw-rw-rw-   0        0        0      192 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.fug.rst
+-rw-rw-rw-   0        0        0      220 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.heinzinger.rst
+-rw-rw-rw-   0        0        0      254 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.highland_t560.base.rst
+-rw-rw-rw-   0        0        0      266 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.highland_t560.channel.rst
+-rw-rw-rw-   0        0        0      262 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.highland_t560.device.rst
+-rw-rw-rw-   0        0        0      369 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.highland_t560.rst
+-rw-rw-rw-   0        0        0      208 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.labjack.rst
+-rw-rw-rw-   0        0        0      200 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.lauda.rst
+-rw-rw-rw-   0        0        0      204 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.mbw973.rst
+-rw-rw-rw-   0        0        0      208 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.newport.rst
+-rw-rw-rw-   0        0        0      230 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.pfeiffer_tpg.rst
+-rw-rw-rw-   0        0        0      808 2022-01-07 20:02:29.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.picotech_pt104.rst
+-rw-rw-rw-   0        0        0      222 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.rs_rto1024.rst
+-rw-rw-rw-   0        0        0      805 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.rst
+-rw-rw-rw-   0        0        0      214 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.se_ils2t.rst
+-rw-rw-rw-   0        0        0      226 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.sst_luminox.rst
+-rw-rw-rw-   0        0        0      236 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube.base.rst
+-rw-rw-rw-   0        0        0      256 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube.constants.rst
+-rw-rw-rw-   0        0        0      376 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube.rst
+-rw-rw-rw-   0        0        0      242 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube.typ_a.rst
+-rw-rw-rw-   0        0        0      242 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube.typ_b.rst
+-rw-rw-rw-   0        0        0      252 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube2015.base.rst
+-rw-rw-rw-   0        0        0      272 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube2015.constants.rst
+-rw-rw-rw-   0        0        0      368 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube2015.rst
+-rw-rw-rw-   0        0        0      258 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.supercube2015.typ_a.rst
+-rw-rw-rw-   0        0        0      228 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.technix.base.rst
+-rw-rw-rw-   0        0        0      236 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.technix.device.rst
+-rw-rw-rw-   0        0        0      299 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.technix.rst
+-rw-rw-rw-   0        0        0      224 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.base.rst
+-rw-rw-rw-   0        0        0      236 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.channel.rst
+-rw-rw-rw-   0        0        0      232 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.device.rst
+-rw-rw-rw-   0        0        0      244 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.generator.rst
+-rw-rw-rw-   0        0        0      220 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.i2c.rst
+-rw-rw-rw-   0        0        0      256 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.oscilloscope.rst
+-rw-rw-rw-   0        0        0      450 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.rst
+-rw-rw-rw-   0        0        0      228 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.tiepie.utils.rst
+-rw-rw-rw-   0        0        0      200 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.utils.rst
+-rw-rw-rw-   0        0        0      196 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.dev.visa.rst
+-rw-rw-rw-   0        0        0      200 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.exception.rst
+-rw-rw-rw-   0        0        0      238 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.experiment_manager.rst
+-rw-rw-rw-   0        0        0      396 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.rst
+-rw-rw-rw-   0        0        0      258 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.conversion_sensor.rst
+-rw-rw-rw-   0        0        0      250 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.conversion_unit.rst
+-rw-rw-rw-   0        0        0      204 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.enum.rst
+-rw-rw-rw-   0        0        0      368 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.rst
+-rw-rw-rw-   0        0        0      212 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.typing.rst
+-rw-rw-rw-   0        0        0      228 2022-01-07 19:51:54.000000 hvl_ccb-0.9.0/docs/hvl_ccb.utils.validation.rst
+-rw-rw-rw-   0        0        0      347 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/index.rst
+-rw-rw-rw-   0        0        0       34 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/installation.rst
+-rwxrwxrwx   0        0        0      805 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/make.bat
+-rw-rw-rw-   0        0        0       85 2021-08-25 11:47:26.000000 hvl_ccb-0.9.0/docs/modules.rst
+-rw-rw-rw-   0        0        0       28 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/readme.rst
+-rw-rw-rw-   0        0        0       89 2021-05-21 16:55:56.000000 hvl_ccb-0.9.0/docs/usage.rst
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:03.993741 hvl_ccb-0.9.0/hvl_ccb/
+-rw-rw-rw-   0        0        0      716 2022-01-07 20:02:54.000000 hvl_ccb-0.9.0/hvl_ccb/__init__.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.009103 hvl_ccb-0.9.0/hvl_ccb/_dev/
+-rw-rw-rw-   0        0        0      194 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/_dev/__init__.py
+-rw-rw-rw-   0        0        0     6218 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/_dev/labjack.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.024139 hvl_ccb-0.9.0/hvl_ccb/comm/
+-rw-rw-rw-   0        0        0     1506 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/__init__.py
+-rw-rw-rw-   0        0        0    11457 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/base.py
+-rw-rw-rw-   0        0        0    10149 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/labjack_ljm.py
+-rw-rw-rw-   0        0        0     5382 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/modbus_tcp.py
+-rw-rw-rw-   0        0        0    12584 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/opc.py
+-rw-rw-rw-   0        0        0     7741 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/serial.py
+-rw-rw-rw-   0        0        0     2915 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/tcp.py
+-rw-rw-rw-   0        0        0     4475 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/telnet.py
+-rw-rw-rw-   0        0        0    12406 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/comm/visa.py
+-rw-rw-rw-   0        0        0     8763 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/configuration.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.049103 hvl_ccb-0.9.0/hvl_ccb/dev/
+-rw-rw-rw-   0        0        0     6178 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/__init__.py
+-rw-rw-rw-   0        0        0     9205 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/base.py
+-rw-rw-rw-   0        0        0    37246 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/crylas.py
+-rw-rw-rw-   0        0        0    20867 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/ea_psi9000.py
+-rw-rw-rw-   0        0        0    42973 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/fug.py
+-rw-rw-rw-   0        0        0    17964 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/heinzinger.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.056106 hvl_ccb-0.9.0/hvl_ccb/dev/highland_t560/
+-rw-rw-rw-   0        0        0      842 2022-01-07 18:28:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/highland_t560/__init__.py
+-rw-rw-rw-   0        0        0     3218 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/highland_t560/base.py
+-rw-rw-rw-   0        0        0     5017 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/highland_t560/channel.py
+-rw-rw-rw-   0        0        0    10828 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/highland_t560/device.py
+-rw-rw-rw-   0        0        0    26999 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/labjack.py
+-rw-rw-rw-   0        0        0    18172 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/lauda.py
+-rw-rw-rw-   0        0        0     9064 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/mbw973.py
+-rw-rw-rw-   0        0        0    47023 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/newport.py
+-rw-rw-rw-   0        0        0    19066 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/pfeiffer_tpg.py
+-rw-rw-rw-   0        0        0    14453 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/picotech_pt104.py
+-rw-rw-rw-   0        0        0    27641 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/rs_rto1024.py
+-rw-rw-rw-   0        0        0    35303 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/se_ils2t.py
+-rw-rw-rw-   0        0        0    12884 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/sst_luminox.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.065136 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/
+-rw-rw-rw-   0        0        0      353 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/__init__.py
+-rw-rw-rw-   0        0        0    21759 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/base.py
+-rw-rw-rw-   0        0        0    26461 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/constants.py
+-rw-rw-rw-   0        0        0     4348 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/typ_a.py
+-rw-rw-rw-   0        0        0      924 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube/typ_b.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.071134 hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/
+-rw-rw-rw-   0        0        0      348 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/__init__.py
+-rw-rw-rw-   0        0        0    15881 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/base.py
+-rw-rw-rw-   0        0        0    15973 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/constants.py
+-rw-rw-rw-   0        0        0     4059 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/typ_a.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.075102 hvl_ccb-0.9.0/hvl_ccb/dev/technix/
+-rw-rw-rw-   0        0        0     1274 2022-01-07 18:47:38.000000 hvl_ccb-0.9.0/hvl_ccb/dev/technix/__init__.py
+-rw-rw-rw-   0        0        0     4019 2022-01-07 18:47:38.000000 hvl_ccb-0.9.0/hvl_ccb/dev/technix/base.py
+-rw-rw-rw-   0        0        0    14447 2022-01-07 18:47:38.000000 hvl_ccb-0.9.0/hvl_ccb/dev/technix/device.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.088190 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/
+-rw-rw-rw-   0        0        0     1868 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/__init__.py
+-rw-rw-rw-   0        0        0     8517 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/base.py
+-rw-rw-rw-   0        0        0    11645 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/channel.py
+-rw-rw-rw-   0        0        0      621 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/device.py
+-rw-rw-rw-   0        0        0     9162 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/generator.py
+-rw-rw-rw-   0        0        0     2648 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/i2c.py
+-rw-rw-rw-   0        0        0    22686 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/oscilloscope.py
+-rw-rw-rw-   0        0        0     1126 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/utils.py
+-rw-rw-rw-   0        0        0     4751 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/utils.py
+-rw-rw-rw-   0        0        0     7054 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/dev/visa.py
+-rw-rw-rw-   0        0        0      168 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/exception.py
+-rw-rw-rw-   0        0        0     5848 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/experiment_manager.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.097106 hvl_ccb-0.9.0/hvl_ccb/utils/
+-rw-rw-rw-   0        0        0       65 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/__init__.py
+-rw-rw-rw-   0        0        0     5176 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/conversion_sensor.py
+-rw-rw-rw-   0        0        0     4833 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/conversion_unit.py
+-rw-rw-rw-   0        0        0     1870 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/enum.py
+-rw-rw-rw-   0        0        0     1898 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/typing.py
+-rw-rw-rw-   0        0        0     5518 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/hvl_ccb/utils/validation.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.007101 hvl_ccb-0.9.0/hvl_ccb.egg-info/
+-rw-rw-rw-   0        0        0    27335 2022-01-07 20:25:02.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    10749 2022-01-07 20:25:03.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2022-01-07 20:25:02.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        2 2022-01-07 20:25:02.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0      323 2022-01-07 20:25:02.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        8 2022-01-07 20:25:02.000000 hvl_ccb-0.9.0/hvl_ccb.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0      561 2022-01-07 20:25:04.645364 hvl_ccb-0.9.0/setup.cfg
+-rw-rw-rw-   0        0        0     3589 2022-01-07 20:02:54.000000 hvl_ccb-0.9.0/setup.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.162956 hvl_ccb-0.9.0/tests/
+-rw-rw-rw-   0        0        0    53248 2021-03-18 17:03:24.000000 hvl_ccb-0.9.0/tests/.coverage
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.174499 hvl_ccb-0.9.0/tests/.idea/
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.178805 hvl_ccb-0.9.0/tests/.idea/inspectionProfiles/
+-rw-rw-rw-   0        0        0      774 2020-09-15 11:37:19.000000 hvl_ccb-0.9.0/tests/.idea/inspectionProfiles/Project_Default.xml
+-rw-rw-rw-   0        0        0      174 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/inspectionProfiles/profiles_settings.xml
+-rw-rw-rw-   0        0        0      294 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/misc.xml
+-rw-rw-rw-   0        0        0      269 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/modules.xml
+-rw-rw-rw-   0        0        0      566 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/tests.iml
+-rw-rw-rw-   0        0        0      188 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/vcs.xml
+-rw-rw-rw-   0        0        0     1920 2020-09-15 11:37:20.000000 hvl_ccb-0.9.0/tests/.idea/workspace.xml
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.614459 hvl_ccb-0.9.0/tests/htmlcov/
+-rw-rw-rw-   0        0        0     6762 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb___init___py.html
+-rw-rw-rw-   0        0        0     3427 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb__dev___init___py.html
+-rw-rw-rw-   0        0        0    48376 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb__dev_labjack_py.html
+-rw-rw-rw-   0        0        0    12658 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm___init___py.html
+-rw-rw-rw-   0        0        0    19645 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_base_py.html
+-rw-rw-rw-   0        0        0    73310 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_labjack_ljm_py.html
+-rw-rw-rw-   0        0        0    45841 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_modbus_tcp_py.html
+-rw-rw-rw-   0        0        0    93787 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_opc_py.html
+-rw-rw-rw-   0        0        0    72959 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_serial_py.html
+-rw-rw-rw-   0        0        0    47988 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_telnet_py.html
+-rw-rw-rw-   0        0        0    81642 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_comm_visa_py.html
+-rw-rw-rw-   0        0        0    65803 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_configuration_py.html
+-rw-rw-rw-   0        0        0    37973 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev___init___py.html
+-rw-rw-rw-   0        0        0    72256 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_base_py.html
+-rw-rw-rw-   0        0        0   253205 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_crylas_py.html
+-rw-rw-rw-   0        0        0   145018 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_ea_psi9000_py.html
+-rw-rw-rw-   0        0        0   331214 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_fug_py.html
+-rw-rw-rw-   0        0        0   131915 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_heinzinger_py.html
+-rw-rw-rw-   0        0        0   123366 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_labjack_py.html
+-rw-rw-rw-   0        0        0    73791 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_mbw973_py.html
+-rw-rw-rw-   0        0        0   307766 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_newport_py.html
+-rw-rw-rw-   0        0        0   134983 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_pfeiffer_tpg_py.html
+-rw-rw-rw-   0        0        0   190135 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_rs_rto1024_py.html
+-rw-rw-rw-   0        0        0   253452 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_se_ils2t_py.html
+-rw-rw-rw-   0        0        0    90327 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_sst_luminox_py.html
+-rw-rw-rw-   0        0        0     4924 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube2015___init___py.html
+-rw-rw-rw-   0        0        0   120046 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube2015_base_py.html
+-rw-rw-rw-   0        0        0   104825 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube2015_constants_py.html
+-rw-rw-rw-   0        0        0    34817 2021-03-18 17:03:43.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube2015_typ_a_py.html
+-rw-rw-rw-   0        0        0     4880 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube___init___py.html
+-rw-rw-rw-   0        0        0   158997 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube_base_py.html
+-rw-rw-rw-   0        0        0   186342 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube_constants_py.html
+-rw-rw-rw-   0        0        0    36017 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube_typ_a_py.html
+-rw-rw-rw-   0        0        0     9910 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_supercube_typ_b_py.html
+-rw-rw-rw-   0        0        0   104648 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_technix_py.html
+-rw-rw-rw-   0        0        0   376258 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_tiepie_py.html
+-rw-rw-rw-   0        0        0    36458 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_utils_py.html
+-rw-rw-rw-   0        0        0    56395 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_dev_visa_py.html
+-rw-rw-rw-   0        0        0    45741 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_experiment_manager_py.html
+-rw-rw-rw-   0        0        0     3002 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_utils___init___py.html
+-rw-rw-rw-   0        0        0    17295 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_utils_enum_py.html
+-rw-rw-rw-   0        0        0    15476 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/_Users_hjanssen_HOME_pyCharmProjects_ethz_hvl_hvl_ccb_hvl_ccb_utils_typing_py.html
+-rw-rw-rw-   0        0        0    20061 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/coverage_html.js
+-rw-rw-rw-   0        0        0     1732 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/favicon_32.png
+-rw-rw-rw-   0        0        0    20172 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/index.html
+-rw-rw-rw-   0        0        0      740 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/jquery.ba-throttle-debounce.min.js
+-rw-rw-rw-   0        0        0     3164 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/jquery.hotkeys.js
+-rw-rw-rw-   0        0        0     1555 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/jquery.isonscreen.js
+-rw-rw-rw-   0        0        0    95788 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/jquery.min.js
+-rw-rw-rw-   0        0        0    12796 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/jquery.tablesorter.min.js
+-rw-rw-rw-   0        0        0      112 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/keybd_closed.png
+-rw-rw-rw-   0        0        0      112 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/keybd_open.png
+-rw-rw-rw-   0        0        0    15925 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/status.json
+-rw-rw-rw-   0        0        0    11983 2021-03-18 17:03:44.000000 hvl_ccb-0.9.0/tests/htmlcov/style.css
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.626399 hvl_ccb-0.9.0/tests/masked_comm/
+-rw-rw-rw-   0        0        0      309 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/__init__.py
+-rw-rw-rw-   0        0        0     2287 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/labjack_ljm.py
+-rw-rw-rw-   0        0        0     2301 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/serial.py
+-rw-rw-rw-   0        0        0     3404 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/tcp.py
+-rw-rw-rw-   0        0        0     6290 2022-01-07 18:47:38.000000 hvl_ccb-0.9.0/tests/masked_comm/telnet_mockup.py
+-rw-rw-rw-   0        0        0      305 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/uitls.py
+-rw-rw-rw-   0        0        0     1552 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/masked_comm/visa.py
+drwxrwxrwx   0        0        0        0 2022-01-07 20:25:04.642361 hvl_ccb-0.9.0/tests/mock_libtiepie/
+-rw-rw-rw-   0        0        0      513 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/const.py
+-rw-rw-rw-   0        0        0     2176 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/devicelist.py
+-rw-rw-rw-   0        0        0     4448 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/devicelistitem.py
+-rw-rw-rw-   0        0        0     2736 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/generator.py
+-rw-rw-rw-   0        0        0      274 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/i2chost.py
+-rw-rw-rw-   0        0        0     5801 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscope.py
+-rw-rw-rw-   0        0        0     2218 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechannel.py
+-rw-rw-rw-   0        0        0     1525 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechanneltrigger.py
+-rw-rw-rw-   0        0        0      718 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechanneltriggerhystereses.py
+-rw-rw-rw-   0        0        0      698 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechanneltriggerlevels.py
+-rw-rw-rw-   0        0        0      366 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/mock_libtiepie/server.py
+-rw-rw-rw-   0        0        0     1267 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/opctools.py
+-rw-rw-rw-   0        0        0     1689 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_base.py
+-rw-rw-rw-   0        0        0     4401 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_labjack_ljm.py
+-rw-rw-rw-   0        0        0     1260 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_modbus_tcp.py
+-rw-rw-rw-   0        0        0     7066 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_opcua.py
+-rw-rw-rw-   0        0        0     4961 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_serial.py
+-rw-rw-rw-   0        0        0     2203 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_tcp.py
+-rw-rw-rw-   0        0        0     3495 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_telnet.py
+-rw-rw-rw-   0        0        0     3445 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_comm_visa.py
+-rw-rw-rw-   0        0        0     4837 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_configuration.py
+-rw-rw-rw-   0        0        0     4766 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_base.py
+-rw-rw-rw-   0        0        0    29078 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_crylas.py
+-rw-rw-rw-   0        0        0    12437 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_ea_psi9000.py
+-rw-rw-rw-   0        0        0    14986 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_fug.py
+-rw-rw-rw-   0        0        0    12632 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_heinzinger.py
+-rw-rw-rw-   0        0        0     5205 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_highland_t560.py
+-rw-rw-rw-   0        0        0    11184 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_labjack.py
+-rw-rw-rw-   0        0        0     8302 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_lauda.py
+-rw-rw-rw-   0        0        0     8311 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_mbw973.py
+-rw-rw-rw-   0        0        0    26779 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_newport.py
+-rw-rw-rw-   0        0        0    10908 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_pfeiffer_tpg.py
+-rw-rw-rw-   0        0        0     1159 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_picotech_pt104.py
+-rw-rw-rw-   0        0        0    13149 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_rs_rto1024.py
+-rw-rw-rw-   0        0        0    14785 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_se_ils2t.py
+-rw-rw-rw-   0        0        0     8425 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_sst_luminox.py
+-rw-rw-rw-   0        0        0    18563 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube.py
+-rw-rw-rw-   0        0        0     8629 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube2015.py
+-rw-rw-rw-   0        0        0     3663 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube2015_a.py
+-rw-rw-rw-   0        0        0     3400 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube_a.py
+-rw-rw-rw-   0        0        0      400 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube_b.py
+-rw-rw-rw-   0        0        0     2765 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_supercube_constants.py
+-rw-rw-rw-   0        0        0     7966 2022-01-07 18:47:38.000000 hvl_ccb-0.9.0/tests/test_dev_technix.py
+-rw-rw-rw-   0        0        0    25793 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_tiepie.py
+-rw-rw-rw-   0        0        0     2285 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_dev_visa.py
+-rw-rw-rw-   0        0        0     2355 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_experiment_manager.py
+-rw-rw-rw-   0        0        0     3897 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_utils_conversion.py
+-rw-rw-rw-   0        0        0     1016 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_utils_conversion_sensor.py
+-rw-rw-rw-   0        0        0     1981 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_utils_enum.py
+-rw-rw-rw-   0        0        0     1274 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_utils_typing.py
+-rw-rw-rw-   0        0        0     2453 2022-01-07 19:23:01.000000 hvl_ccb-0.9.0/tests/test_utils_validation.py
```

### filetype from file(1)

```diff
@@ -1 +1 @@
-POSIX tar archive (GNU)
+POSIX tar archive
```

### Comparing `hvl_ccb-0.8.5/AUTHORS.rst` & `hvl_ccb-0.9.0/AUTHORS.rst`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -15,17 +15,17 @@
 
 * Mikołaj Rybiński <mikolaj.rybinski@id.ethz.ch>
 * David Graber <dev@davidgraber.ch>
 * Henrik Menne <henrik.menne@eeh.ee.ethz.ch>
 * Alise Chachereau <chachereau@eeh.ee.ethz.ch>
 * Henning Janssen <janssen@eeh.ee.ethz.ch>
 * David Taylor <dtaylor@ethz.ch>
+* Joseph Engelbrecht <engelbrecht@eeh.ee.ethz.ch>
 
 Contributors
 ------------
 
 * Luca Nembrini <lucane@student.ethz.ch>
 * Maria Del <maria.del@id.ethz.ch>
 * Raphael Faerber <raphael.faerber@eeh.ee.ethz.ch>
 * Ruben Stadler <rstadler@student.ethz.ch>
-* Joseph Engelbrecht <engelbrecht@eeh.ee.ethz.ch>
 * Hanut Vemulapalli <vemulapalli@eeh.ee.ethz.ch>
```

### Comparing `hvl_ccb-0.8.5/CONTRIBUTING.rst` & `hvl_ccb-0.9.0/CONTRIBUTING.rst`

 * *Files 1% similar despite different names*

```diff
@@ -149,19 +149,19 @@
 A reminder for the maintainers on how to deploy. Create :code:`release-N.M.K` branch.
 Make sure all your changes are committed. Update or create entry in :code:`HISTORY.rst`
 file, and, if applicable, update :code:`AUTHORS.rst` file, update features tables in
 :code:`README.rst` file, and update API docs::
 
   $ make docs
 
-Commit all of the above, except for the :code:`docs/hvl_ccb.dev.picotech_pt104.rst`,
+Commit all of the above, except for the :code:`docs/hvl_ccb.dev.picotech_pt104.rst` (revert it afterwards),
 and then run::
 
   $ bumpversion patch # possible: major / minor / patch
-  $ git push
+  $ git push --set-upstream origin release-N.M.K
   $ git push --tags
 
 Go to https://readthedocs.org/projects/hvl-ccb/builds/ and check if RTD docs build for
 the pushed tag passed.
 
 Wait for the CI pipeline to finish successfully; afterwards, run a release check::
```

### Comparing `hvl_ccb-0.8.5/HISTORY.rst` & `hvl_ccb-0.9.0/HISTORY.rst`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,29 @@
 =======
 History
 =======
 
+0.9.0 (2022-01-07)
+------------------
+
+* New device: Highland T560 digital delay and pulse generator over Telnet.
+* Rework of the Technix Capacitor Charger.
+    * Moved into a separate sub-package
+    * NEW import over :code:`import hvl_ccb.dev.technix as XXX`
+    * Slightly adapted behaviour
+* Add :code:`validate_tcp_port` to validate port number.
+* Add :code:`validate_and_resolve_host` to validate and resolve host names and IPs.
+    * Remove requirement :code:`IPy`
+* Add a unified CCB Exception schema for all devices and communication protocols.
+* Add data conversion functions to README.
+* Update CI and devel images from Debian 10 buster to Debian 11 bullseye.
+* Fix typing due to numpy update.
+* Fix incorrect overloading of :code:`clean_values()` in classes of
+  type :code:`XCommunicationConfig`.
+
 0.8.5 (2021-11-05)
 ------------------
 
 * Added arbitrary waveform for TiePie signal generation, configurable via
   :code:`dev.tiepie.generator.TiePieGeneratorConfig.waveform` property.
 * In :code:`utils.conversion_sensor`: improvements for class constants; removed SciPy
   dependency.
```

### Comparing `hvl_ccb-0.8.5/INSTALLATION.rst` & `hvl_ccb-0.9.0/INSTALLATION.rst`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,93 +1,93 @@
-============
-Installation
-============
-
-
-Stable release
---------------
-
-To install HVL Common Code Base, run this command in your terminal:
-
-.. code-block:: console
-
-    $ pip install hvl_ccb
-
-To install HVL Common Code Base with optional Python libraries that require manual
-installations of additional system libraries, you need to specify on installation
-extra requirements corresponding to these controllers. For instance, to install
-Python requirements for LabJack and TiePie devices, run:
-
-.. code-block:: console
-
-    $ pip install "hvl_ccb[tiepie,labjack]"
-
-See below for the info about additional system libraries and the corresponding extra
-requirements.
-
-To install all extra requirements run:
-
-.. code-block:: console
-
-    $ pip install "hvl_ccb[all]"
-
-This is the preferred method to install HVL Common Code Base, as it will always install
-the most recent stable release.
-
-If you don't have `pip`_ installed, this `Python installation guide`_ can guide
-you through the process.
-
-.. _pip: https://pip.pypa.io
-.. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
-
-
-From sources
-------------
-
-The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
-
-You can either clone the repository:
-
-.. code-block:: console
-
-    $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
-
-Or download the `tarball`_:
-
-.. code-block:: console
-
-    $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-
-Once you have a copy of the source, you can install it with:
-
-.. code-block:: console
-
-    $ pip install .
-
-
-.. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
-.. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-
-
-Additional system libraries
----------------------------
-
-If you have installed `hvl_ccb` with any of the extra features corresponding to
-device controllers, you must additionally install respective system library; these are:
-
-+-------------------------+------------------------------------------------------------+
-| Extra feature           | Additional system library                                  |
-+=========================+============================================================+
-| :code:`labjack`         | `LJM Library`_                                             |
-+-------------------------+------------------------------------------------------------+
-| :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
-+-------------------------+------------------------------------------------------------+
-| :code:`tiepie`          | `LibTiePie SDK`_                                           |
-+-------------------------+------------------------------------------------------------+
-
-For more details on installation of the libraries see docstrings of the corresponding
-:code:`hvl_ccb` modules.
-
-.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
-.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
-.. _`LJM Library`: https://labjack.com/ljm
-.. _`PicoSDK`: https://www.picotech.com/downloads
+============
+Installation
+============
+
+
+Stable release
+--------------
+
+To install HVL Common Code Base, run this command in your terminal:
+
+.. code-block:: console
+
+    $ pip install hvl_ccb
+
+To install HVL Common Code Base with optional Python libraries that require manual
+installations of additional system libraries, you need to specify on installation
+extra requirements corresponding to these controllers. For instance, to install
+Python requirements for LabJack and TiePie devices, run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[tiepie,labjack]"
+
+See below for the info about additional system libraries and the corresponding extra
+requirements.
+
+To install all extra requirements run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[all]"
+
+This is the preferred method to install HVL Common Code Base, as it will always install
+the most recent stable release.
+
+If you don't have `pip`_ installed, this `Python installation guide`_ can guide
+you through the process.
+
+.. _pip: https://pip.pypa.io
+.. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
+
+
+From sources
+------------
+
+The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
+
+You can either clone the repository:
+
+.. code-block:: console
+
+    $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
+
+Or download the `tarball`_:
+
+.. code-block:: console
+
+    $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+Once you have a copy of the source, you can install it with:
+
+.. code-block:: console
+
+    $ pip install .
+
+
+.. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
+.. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+
+Additional system libraries
+---------------------------
+
+If you have installed `hvl_ccb` with any of the extra features corresponding to
+device controllers, you must additionally install respective system library; these are:
+
++-------------------------+------------------------------------------------------------+
+| Extra feature           | Additional system library                                  |
++=========================+============================================================+
+| :code:`labjack`         | `LJM Library`_                                             |
++-------------------------+------------------------------------------------------------+
+| :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
++-------------------------+------------------------------------------------------------+
+| :code:`tiepie`          | `LibTiePie SDK`_                                           |
++-------------------------+------------------------------------------------------------+
+
+For more details on installation of the libraries see docstrings of the corresponding
+:code:`hvl_ccb` modules.
+
+.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
+.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
+.. _`LJM Library`: https://labjack.com/ljm
+.. _`PicoSDK`: https://www.picotech.com/downloads
```

### Comparing `hvl_ccb-0.8.5/LICENSE` & `hvl_ccb-0.9.0/LICENSE`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-GNU GENERAL PUBLIC LICENSE
-                      Version 3, 29 June 2007
-
-    Python common code base to control devices used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
-    Copyright (C) 2019 ETH Zurich, SIS ID and HVL D-ITET
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
-
+GNU GENERAL PUBLIC LICENSE
+                      Version 3, 29 June 2007
+
+    Python common code base to control devices used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
+    Copyright (C) 2019 ETH Zurich, SIS ID and HVL D-ITET
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+
```

### Comparing `hvl_ccb-0.8.5/PKG-INFO` & `hvl_ccb-0.9.0/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,559 +1,604 @@
-Metadata-Version: 2.1
-Name: hvl_ccb
-Version: 0.8.5
-Summary: Python common code base to control devices high voltage research devices, in particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
-Home-page: https://gitlab.com/ethz_hvl/hvl_ccb/
-Author: ('Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, David Taylor',)
-Author-email: mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch
-License: GNU General Public License v3
-Description: ====================
-        HVL Common Code Base
-        ====================
-        
-        .. image:: https://img.shields.io/pypi/v/hvl_ccb?logo=PyPi
-           :target: https://pypi.org/project/hvl_ccb/
-           :alt: PyPI version
-        
-        .. image:: https://img.shields.io/pypi/pyversions/hvl_ccb?logo=Python
-           :target: https://pypi.org/project/hvl_ccb/
-           :alt: Supported Python versions
-        
-        .. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/master?logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/master
-            :alt: Pipeline status
-        
-        .. image:: https://img.shields.io/gitlab/coverage/ethz_hvl/hvl_ccb/master?logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/commits/master
-            :alt: Coverage report
-        
-        .. image:: https://img.shields.io/readthedocs/hvl_ccb?logo=read-the-docs
-            :target: https://hvl-ccb.readthedocs.io/en/stable/
-            :alt: Documentation Status
-        
-        .. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/devel?label=devel&logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/devel
-            :alt: Development pipeline status
-        
-        Python common code base to control devices high voltage research devices, in
-        particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH.
-        
-        
-        * Free software: GNU General Public License v3
-        * Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-        
-        
-        Features
-        --------
-        
-        For managing multi-device experiments instantiate the :code:`ExperimentManager`
-        utility class.
-        
-        Devices
-        ~~~~~~~
-        
-        The devices wrappers in :code:`hvl_ccb` provide a standardised API with configuration
-        dataclasses, various settings and options enumerations, as well as start/stop methods.
-        Currently, wrappers to control the following devices are available:
-        
-        +-------------------------+------------------------------------------------------------+
-        | Function/Type           | Devices                                                    |
-        +=========================+============================================================+
-        | Data acquisition        | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
-        |                         | | Pico Technology PT-104 Platinum Resistance Data Logger   |
-        |                         |   (requires `PicoSDK`_/`libusbpt104`_)                     |
-        +-------------------------+------------------------------------------------------------+
-        | Digital IO              | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
-        +-------------------------+------------------------------------------------------------+
-        | Experiment control      | | HVL Supercube with and without Frequency Converter       |
-        +-------------------------+------------------------------------------------------------+
-        | Gas Analyser            | | MBW 973-SF6 gas dew point mirror analyzer                |
-        |                         | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for    |
-        |                         |   compact pressure gauges                                  |
-        |                         | | SST Luminox oxygen sensor                                |
-        +-------------------------+------------------------------------------------------------+
-        | I2C host                | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
-        +-------------------------+------------------------------------------------------------+
-        | Laser                   | | CryLaS pulsed laser                                      |
-        |                         | | CryLaS laser attenuator                                  |
-        +-------------------------+------------------------------------------------------------+
-        | Oscilloscope            | | Rhode & Schwarz RTO 1024                                 |
-        |                         | | TiePie (HS5, HS6, WS5; requries `LibTiePie SDK`_)        |
-        +-------------------------+------------------------------------------------------------+
-        | Power supply            | | Elektro-Automatik PSI9000                                |
-        |                         | | FuG Elektronik                                           |
-        |                         | | Heinzinger PNC                                           |
-        |                         | | Technix capacitor charger                                |
-        +-------------------------+------------------------------------------------------------+
-        | Stepper motor drive     | | Newport SMC100PP                                         |
-        |                         | | Schneider Electric ILS2T                                 |
-        +-------------------------+------------------------------------------------------------+
-        | Temperature control     | | Lauda PRO RP 245 E circulation thermostat                |
-        +-------------------------+------------------------------------------------------------+
-        | Waveform generator      | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
-        +-------------------------+------------------------------------------------------------+
-        
-        Each device uses at least one standardised communication protocol wrapper.
-        
-        Communication protocols
-        ~~~~~~~~~~~~~~~~~~~~~~~
-        
-        In :code:`hvl_ccb` by "communication protocol" we mean different levels of
-        communication standards, from the low level actual communication protocols like
-        serial communication to application level interfaces like VISA TCP standard. There
-        are also devices in :code:`hvl_ccb` that use dummy communication protocol concept;
-        this is because these devices build on propriety vendor libraries that communicate
-        with vendor devices, like in case of the TiePie devices.
-        
-        The communication protocol wrappers in :code:`hvl_ccb` provide a standardised API with
-        configuration dataclasses, as well as open/close, and read/write/query methods.
-        Currently, wrappers to use the following communication protocols are available:
-        
-        +------------------------+-------------------------------------------------------------+
-        | Communication protocol | Devices using                                               |
-        +========================+=============================================================+
-        | Modbus TCP             | | Schneider Electric ILS2T stepper motor drive              |
-        +------------------------+-------------------------------------------------------------+
-        | OPC UA                 | | HVL Supercube with and without Frequency Converter        |
-        +------------------------+-------------------------------------------------------------+
-        | Serial                 | | CryLaS pulsed laser and laser attenuator                  |
-        |                        | | FuG Elektronik power supply (e.g. capacitor charger HCK)  |
-        |                        |   using the Probus V protocol                               |
-        |                        | | Heinzinger PNC power supply                               |
-        |                        |   using Heinzinger Digital Interface I/II                   |
-        |                        | | SST Luminox oxygen sensor                                 |
-        |                        | | MBW 973-SF6 gas dew point mirror analyzer                 |
-        |                        | | Newport SMC100PP single axis driver for 2-phase stepper   |
-        |                        |   motors                                                    |
-        |                        | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for     |
-        |                        |   compact pressure gauges                                   |
-        |                        | | Technix capacitor charger                                 |
-        +------------------------+-------------------------------------------------------------+
-        | TCP                    | | Lauda PRO RP 245 E circulation thermostat                 |
-        +------------------------+-------------------------------------------------------------+
-        | Telnet                 | | Technix capacitor charger                                 |
-        +------------------------+-------------------------------------------------------------+
-        | VISA TCP               | | Elektro-Automatik PSI9000 DC power supply                 |
-        |                        | | Rhode & Schwarz RTO 1024 oscilloscope                     |
-        +------------------------+-------------------------------------------------------------+
-        | *propriety*            | | LabJack (T4, T7, T7-PRO) devices, which communicate via   |
-        |                        |   `LJM Library`_                                            |
-        |                        | | Pico Technology PT-104 Platinum Resistance Data Logger,   |
-        |                        |   which communicate via `PicoSDK`_/`libusbpt104`_           |
-        |                        | | TiePie (HS5, HS6, WS5) oscilloscopes, generators and I2C  |
-        |                        |   hosts, which communicate via `LibTiePie SDK`_             |
-        +------------------------+-------------------------------------------------------------+
-        
-        .. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
-        .. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
-        .. _`LJM Library`: https://labjack.com/ljm
-        .. _`PicoSDK`: https://www.picotech.com/downloads
-        
-        Documentation
-        -------------
-        
-        Note: if you're planning to contribute to the :code:`hvl_ccb` project do read
-        beforehand the **Contributing** section in the HVL CCB documentation.
-        
-        Do either:
-        
-        * read `HVL CCB documentation at RTD`_,
-        
-        or
-        
-        * build and read HVL CCB documentation locally; install first `Graphviz`_ (make sure
-          to have the :code:`dot` command in the executable search path) and the Python
-          build requirements for documentation::
-        
-            $ pip install docs/requirements.txt
-        
-          and then either on Windows in Git BASH run::
-        
-            $ ./make.sh docs
-        
-          or from any other shell with GNU Make installed run::
-        
-            $ make docs
-        
-          The target index HTML (:code:`"docs/_build/html/index.html"`) should open
-          automatically in your Web browser.
-        
-        .. _`Graphviz`: https://graphviz.org/
-        .. _`HVL CCB documentation at RTD`: https://readthedocs.org/projects/hvl-ccb/
-        
-        Credits
-        -------
-        
-        This package was created with Cookiecutter_ and the
-        `audreyr/cookiecutter-pypackage`_ project template.
-        
-        .. _Cookiecutter: https://github.com/audreyr/cookiecutter
-        .. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage
-        
-        
-        ============
-        Installation
-        ============
-        
-        
-        Stable release
-        --------------
-        
-        To install HVL Common Code Base, run this command in your terminal:
-        
-        .. code-block:: console
-        
-            $ pip install hvl_ccb
-        
-        To install HVL Common Code Base with optional Python libraries that require manual
-        installations of additional system libraries, you need to specify on installation
-        extra requirements corresponding to these controllers. For instance, to install
-        Python requirements for LabJack and TiePie devices, run:
-        
-        .. code-block:: console
-        
-            $ pip install "hvl_ccb[tiepie,labjack]"
-        
-        See below for the info about additional system libraries and the corresponding extra
-        requirements.
-        
-        To install all extra requirements run:
-        
-        .. code-block:: console
-        
-            $ pip install "hvl_ccb[all]"
-        
-        This is the preferred method to install HVL Common Code Base, as it will always install
-        the most recent stable release.
-        
-        If you don't have `pip`_ installed, this `Python installation guide`_ can guide
-        you through the process.
-        
-        .. _pip: https://pip.pypa.io
-        .. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
-        
-        
-        From sources
-        ------------
-        
-        The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
-        
-        You can either clone the repository:
-        
-        .. code-block:: console
-        
-            $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
-        
-        Or download the `tarball`_:
-        
-        .. code-block:: console
-        
-            $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-        
-        Once you have a copy of the source, you can install it with:
-        
-        .. code-block:: console
-        
-            $ pip install .
-        
-        
-        .. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
-        .. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-        
-        
-        Additional system libraries
-        ---------------------------
-        
-        If you have installed `hvl_ccb` with any of the extra features corresponding to
-        device controllers, you must additionally install respective system library; these are:
-        
-        +-------------------------+------------------------------------------------------------+
-        | Extra feature           | Additional system library                                  |
-        +=========================+============================================================+
-        | :code:`labjack`         | `LJM Library`_                                             |
-        +-------------------------+------------------------------------------------------------+
-        | :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
-        +-------------------------+------------------------------------------------------------+
-        | :code:`tiepie`          | `LibTiePie SDK`_                                           |
-        +-------------------------+------------------------------------------------------------+
-        
-        For more details on installation of the libraries see docstrings of the corresponding
-        :code:`hvl_ccb` modules.
-        
-        .. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
-        .. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
-        .. _`LJM Library`: https://labjack.com/ljm
-        .. _`PicoSDK`: https://www.picotech.com/downloads
-        
-        
-        =======
-        History
-        =======
-        
-        0.8.5 (2021-11-05)
-        ------------------
-        
-        * Added arbitrary waveform for TiePie signal generation, configurable via
-          :code:`dev.tiepie.generator.TiePieGeneratorConfig.waveform` property.
-        * In :code:`utils.conversion_sensor`: improvements for class constants; removed SciPy
-          dependency.
-        * Added Python 3.10 support.
-        
-        0.8.4 (2021-10-22)
-        ------------------
-        
-        * :code:`utils.validation.validate_number` extension to handle NumPy arrays and
-          array-like objects.
-        * :code:`utils.conversion_unit` utility classes handle correctly :code:`NamedTuple`
-          instances.
-        * :code:`utils.conversion_sensor` and :code:`utils.conversion_unit` code
-          simplification (no :code:`transfer_function_order` attribute) and cleanups.
-        * Fixed incorrect error logging in :code:`configuration.configdataclass`.
-        * :code:`comm.telnet.TelnetCommunication` tests fixes for local run errors.
-        
-        0.8.3 (2021-09-27)
-        ------------------
-        
-        * New data conversion functions in :code:`utils.conversion_sensor` and
-          :code:`utils.conversion_unit` modules. Note: to use these functions you must install
-          :code:`hvl_ccb` with extra requirement, either :code:`hvl_ccb[conversion]` or
-          :code:`hvl_ccb[all]`.
-        * Improved documentation with respect to installation of external libraries.
-        
-        0.8.2 (2021-08-27)
-        ------------------
-        
-        * New functionality in :code:`dev.labjack.LabJack`:
-            * configure clock and send timed pulse sequences
-            * set DAC/analog output voltage
-        * Bugfix: ignore random bits sent by to :code:`dev.newport.NewportSMC100PP`
-          controller during start-up/powering-up.
-        
-        0.8.1 (2021-08-13)
-        ------------------
-        
-        * Add Python version check (min version error; max version warning).
-        * Daily checks for upstream dependencies compatibility and devel environment
-          improvements.
-        
-        0.8.0 (2021-07-02)
-        ------------------
-        
-        * TCP communication protocol.
-        * Lauda PRO RP 245 E circulation thermostat device over TCP.
-        * Pico Technology PT-104 Platinum Resistance Data Logger device as a wrapper of the
-          Python bindings for the PicoSDK.
-        * In :code:`com.visa.VisaCommunication`: periodic status polling when VISA/TCP keep
-          alive connection is not supported by a host.
-        
-        0.7.1 (2021-06-04)
-        ------------------
-        
-        * New :code:`utils.validation` submodule with :code:`validate_bool` and
-          :code:`validate_number` utilities extracted from internal use within a
-          :code:`dev.tiepie` subpackage.
-        * In :code:`comm.serial.SerialCommunication`:
-             * strict encoding errors handling strategy for subclasses,
-             * user warning for a low communication timeout value.
-        
-        0.7.0 (2021-05-25)
-        ------------------
-        
-        * The :code:`dev.tiepie` module was splitted into a subpackage with, in particular,
-          submodules for each of the device types -- :code:`oscilloscope`, :code:`generator`,
-          and :code:`i2c` -- and with backward-incompatible direct imports from the submodules.
-        * In :code:`dev.technix`:
-              * fixed communication crash on nested status byte query;
-              * added enums for GET and SET register commands.
-        * Further minor logging improvements: added missing module level logger and removed some
-          error logs in :code:`except` blocks used for a flow control.
-        * In :code:`examples/` folder renamed consistently all the examples.
-        * In API documentation: fix incorrect links mapping on inheritance diagrams.
-        
-        0.6.1 (2021-05-08)
-        ------------------
-        
-        * In :code:`dev.tiepie`:
-              * dynamically set oscilloscope's channel limits in
-                :code:`OscilloscopeChannelParameterLimits`: :code:`input_range` and
-                :code:`trigger_level_abs`, incl. update of latter on each change of
-                :code:`input_range` value of a :code:`TiePieOscilloscopeChannelConfig`
-                instances;
-              * quick fix for opening of combined instruments by disabling
-                :code:`OscilloscopeParameterLimits.trigger_delay` (an advanced feature);
-              * enable automatic devices detection to be able to find network devices with
-                :code:`TiePieOscilloscope.list_devices()`.
-        * Fix :code:`examples/example_labjack.py`.
-        * Improved logging: consistently use module level loggers, and always log exception
-          tracebacks.
-        * Improve API documentation: separate pages per modules, each with an inheritance
-          diagram as an overview.
-        
-        0.6.0 (2021-04-23)
-        ------------------
-        
-        * Technix capacitor charger using either serial connection or Telnet protocol.
-        * Extensions, improvements and fixes in existing devices:
-           * In :code:`dev.tiepie.TiePieOscilloscope`:
-               * redesigned measurement start and data collection API, incl. time out
-                 argument, with no/infinite time out option;
-               * trigger allows now a no/infinite time out;
-               * record length and trigger level were fixed to accept, respectively, floating
-                 point and integer numbers;
-               * fixed resolution validation bug;
-           * :code:`dev.heinzinger.HeinzingerDI` and `dev.rs_rto1024.RTO1024` instances are now
-             resilient to multiple :code:`stop()` calls.
-           * In :code:`dev.crylas.CryLasLaser`: default configuration timeout and
-             polling period were adjusted;
-           * Fixed PSI9080 example script.
-        * Package and source code improvements:
-           * Update to backward-incompatible :code:`pyvisa-py>=0.5.2`. Developers, do update
-             your local development environments!
-           * External libraries, like LibTiePie SDK or LJM Library, are now not installed by
-             default; they are now extra installation options.
-           * Added Python 3.9 support.
-           * Improved number formatting in logs.
-           * Typing improvements and fixes for :code:`mypy>=0.800`.
-        
-        0.5.0 (2020-11-11)
-        ------------------
-        
-        * TiePie USB oscilloscope, generator and I2C host devices, as a wrapper of the Python
-          bindings for the LibTiePie SDK.
-        * a FuG Elektronik Power Supply (e.g. Capacitor Charger HCK) using the built-in ADDAT
-          controller with the Probus V protocol over a serial connection
-        * All devices poling status or measurements use now a :code:`dev.utils.Poller` utility
-          class.
-        * Extensions and improvements in existing devices:
-            * In :code:`dev.rs_rto1024.RTO1024`: added Channel state, scale, range,
-              position and offset accessors, and measurements activation and read methods.
-            * In :code:`dev.sst_luminox.Luminox`: added querying for all measurements
-              in polling mode, and made output mode activation more robust.
-            * In :code:`dev.newport.NewportSMC100PP`: an error-prone
-              :code:`wait_until_move_finished` method of replaced by a fixed waiting time,
-              device operations are now robust to a power supply cut, and device restart is not
-              required to apply a start configuration.
-        * Other minor improvements:
-            * Single failure-safe starting and stopping of devices sequenced via
-              :code:`dev.base.DeviceSequenceMixin`.
-            * Moved :code:`read_text_nonempty` up to :code:`comm.serial.SerialCommunication`.
-            * Added development Dockerfile.
-            * Updated package and development dependencies: :code:`pymodbus`,
-              :code:`pytest-mock`.
-        
-        0.4.0 (2020-07-16)
-        ------------------
-        
-        * Significantly improved new Supercube device controller:
-            - more robust error-handling,
-            - status polling with generic :code:`Poller` helper,
-            - messages and status boards.
-            - tested with a physical device,
-        * Improved OPC UA client wrapper, with better error handling, incl. re-tries on
-          :code:`concurrent.futures.TimeoutError`.
-        * SST Luminox Oxygen sensor device controller.
-        * Backward-incompatible changes:
-            - :code:`CommunicationProtocol.access_lock` has changed type from
-              :code:`threading.Lock` to :code:`threading.RLock`.
-            - :code:`ILS2T.relative_step` and :code:`ILS2T.absolute_position` are now called,
-              respectively, :code:`ILS2T.write_relative_step` and
-              :code:`ILS2T.write_absolute_position`.
-        * Minor bugfixes and improvements:
-            - fix use of max resolution in :code:`Labjack.set_ain_resolution()`,
-            - resolve ILS2T devices relative and absolute position setters race condition,
-            - added acoustic horn function in the 2015 Supercube.
-        * Toolchain changes:
-            - add Python 3.8 support,
-            - drop pytest-runner support,
-            - ensure compatibility with :code:`labjack_ljm` 2019 version library.
-        
-        0.3.5 (2020-02-18)
-        ------------------
-        
-        * Fix issue with reading integers from LabJack LJM Library (device's product ID, serial
-          number etc.)
-        * Fix development requirements specification (tox version).
-        
-        0.3.4 (2019-12-20)
-        ------------------
-        
-        * New devices using serial connection:
-            * Heinzinger Digital Interface I/II and a Heinzinger PNC power supply
-            * Q-switched Pulsed Laser and a laser attenuator from CryLas
-            * Newport SMC100PP single axis motion controller for 2-phase stepper motors
-            * Pfeiffer TPG controller (TPG 25x, TPG 26x and TPG 36x) for Compact pressure Gauges
-        * PEP 561 compatibility and related corrections for static type checking (now in CI)
-        * Refactorings:
-            * Protected non-thread safe read and write in communication protocols
-            * Device sequence mixin: start/stop, add/rm and lookup
-            * `.format()` to f-strings
-            * more enumerations and a quite some improvements of existing code
-        * Improved error docstrings (:code:`:raises:` annotations) and extended tests for
-          errors.
-        
-        0.3.3 (2019-05-08)
-        ------------------
-        
-        * Use PyPI labjack-ljm (no external dependencies)
-        
-        
-        0.3.2 (2019-05-08)
-        ------------------
-        
-        * INSTALLATION.rst with LJMPython prerequisite info
-        
-        
-        0.3.1 (2019-05-02)
-        ------------------
-        
-        * readthedocs.org support
-        
-        0.3 (2019-05-02)
-        ----------------
-        
-        * Prevent an automatic close of VISA connection when not used.
-        * Rhode & Schwarz RTO 1024 oscilloscope using VISA interface over TCP::INSTR.
-        * Extended tests incl. messages sent to devices.
-        * Added Supercube device using an OPC UA client
-        * Added Supercube 2015 device using an OPC UA client (for interfacing with old system
-          version)
-        
-        0.2.1 (2019-04-01)
-        ------------------
-        
-        * Fix issue with LJMPython not being installed automatically with setuptools.
-        
-        0.2.0 (2019-03-31)
-        ------------------
-        
-        * LabJack LJM Library communication wrapper and LabJack device.
-        * Modbus TCP communication protocol.
-        * Schneider Electric ILS2T stepper motor drive device.
-        * Elektro-Automatik PSI9000 current source device and VISA communication wrapper.
-        * Separate configuration classes for communication protocols and devices.
-        * Simple experiment manager class.
-        
-        0.1.0 (2019-02-06)
-        ------------------
-        
-        * Communication protocol base and serial communication implementation.
-        * Device base and MBW973 implementation.
-        
-Keywords: hvl_ccb
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Education
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
-Classifier: Natural Language :: English
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Requires-Python: >=3.7
-Description-Content-Type: text/x-rst
-Provides-Extra: all
-Provides-Extra: tiepie
-Provides-Extra: labjack
-Provides-Extra: picotech
+Metadata-Version: 2.1
+Name: hvl_ccb
+Version: 0.9.0
+Summary: Python common code base to control devices high voltage research devices, in particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
+Home-page: https://gitlab.com/ethz_hvl/hvl_ccb/
+Author: ('Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, David Taylor',)
+Author-email: mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch
+License: GNU General Public License v3
+Keywords: hvl_ccb
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Education
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+Classifier: Natural Language :: English
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Requires-Python: >=3.7
+Description-Content-Type: text/x-rst
+Provides-Extra: all
+Provides-Extra: tiepie
+Provides-Extra: labjack
+Provides-Extra: picotech
+License-File: LICENSE
+License-File: AUTHORS.rst
+
+====================
+HVL Common Code Base
+====================
+
+.. image:: https://img.shields.io/pypi/v/hvl_ccb?logo=PyPi
+   :target: https://pypi.org/project/hvl_ccb/
+   :alt: PyPI version
+
+.. image:: https://img.shields.io/pypi/pyversions/hvl_ccb?logo=Python
+   :target: https://pypi.org/project/hvl_ccb/
+   :alt: Supported Python versions
+
+.. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/master?logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/master
+    :alt: Pipeline status
+
+.. image:: https://img.shields.io/gitlab/coverage/ethz_hvl/hvl_ccb/master?logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/commits/master
+    :alt: Coverage report
+
+.. image:: https://img.shields.io/readthedocs/hvl_ccb?logo=read-the-docs
+    :target: https://hvl-ccb.readthedocs.io/en/stable/
+    :alt: Documentation Status
+
+.. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/devel?label=devel&logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/devel
+    :alt: Development pipeline status
+
+Python common code base (CCB) to control devices, which are used in high-voltage
+research. All implemented devices are used and tested in the High Voltage Laboratory
+(`HVL`_) of the Federal Institute of Technology Zurich (ETH Zurich).
+
+* Free software: GNU General Public License v3
+* Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+
+.. _`HVL`: https://hvl.ee.ethz.ch/
+
+Features
+--------
+
+For managing multi-device experiments instantiate the :code:`ExperimentManager`
+utility class.
+
+Devices
+~~~~~~~
+
+The device wrappers in :code:`hvl_ccb` provide a standardised API with configuration
+dataclasses, various settings and options, as well as start/stop methods.
+Currently wrappers are available to control the following devices:
+
++-------------------------+------------------------------------------------------------+
+| Function/Type           | Devices                                                    |
++=========================+============================================================+
+| Data acquisition        | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
+|                         | | Pico Technology PT-104 Platinum Resistance Data Logger   |
+|                         |   (requires `PicoSDK`_/`libusbpt104`_)                     |
++-------------------------+------------------------------------------------------------+
+| Digital Delay Generator | | Highland T560                                            |
++-------------------------+------------------------------------------------------------+
+| Digital IO              | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
++-------------------------+------------------------------------------------------------+
+| Experiment control      | | HVL Supercube with and without Frequency Converter       |
++-------------------------+------------------------------------------------------------+
+| Gas Analyser            | | MBW 973-SF6 gas dew point mirror analyzer                |
+|                         | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for    |
+|                         |   compact pressure gauges                                  |
+|                         | | SST Luminox oxygen sensor                                |
++-------------------------+------------------------------------------------------------+
+| I2C host                | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
++-------------------------+------------------------------------------------------------+
+| Laser                   | | CryLaS pulsed laser                                      |
+|                         | | CryLaS laser attenuator                                  |
++-------------------------+------------------------------------------------------------+
+| Oscilloscope            | | Rhode & Schwarz RTO 1024                                 |
+|                         | | TiePie (HS5, HS6, WS5; requires `LibTiePie SDK`_)        |
++-------------------------+------------------------------------------------------------+
+| Power supply            | | Elektro-Automatik PSI9000                                |
+|                         | | FuG Elektronik                                           |
+|                         | | Heinzinger PNC                                           |
+|                         | | Technix capacitor charger                                |
++-------------------------+------------------------------------------------------------+
+| Stepper motor drive     | | Newport SMC100PP                                         |
+|                         | | Schneider Electric ILS2T                                 |
++-------------------------+------------------------------------------------------------+
+| Temperature control     | | Lauda PRO RP 245 E circulation thermostat                |
++-------------------------+------------------------------------------------------------+
+| Waveform generator      | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
++-------------------------+------------------------------------------------------------+
+
+Each device uses at least one standardised communication protocol wrapper.
+
+Communication protocols
+~~~~~~~~~~~~~~~~~~~~~~~
+
+In :code:`hvl_ccb` by "communication protocol" we mean different levels of
+communication standards, from the low level actual communication protocols like
+serial communication to application level interfaces like VISA TCP standard. There
+are also devices in :code:`hvl_ccb` that use a dummy communication protocol;
+this is because these devices are build on proprietary manufacturer libraries that
+communicate with the corresponding devices, as in the case of TiePie or LabJack devices.
+
+The communication protocol wrappers in :code:`hvl_ccb` provide a standardised API with
+configuration dataclasses, as well as open/close and read/write/query methods.
+Currently, wrappers for the following communication protocols are available:
+
++------------------------+-------------------------------------------------------------+
+| Communication protocol | Devices using                                               |
++========================+=============================================================+
+| Modbus TCP             | | Schneider Electric ILS2T stepper motor drive              |
++------------------------+-------------------------------------------------------------+
+| OPC UA                 | | HVL Supercube with and without Frequency Converter        |
++------------------------+-------------------------------------------------------------+
+| Serial                 | | CryLaS pulsed laser and laser attenuator                  |
+|                        | | FuG Elektronik power supply (e.g. capacitor charger HCK)  |
+|                        |   using the Probus V protocol                               |
+|                        | | Heinzinger PNC power supply                               |
+|                        |   using Heinzinger Digital Interface I/II                   |
+|                        | | SST Luminox oxygen sensor                                 |
+|                        | | MBW 973-SF6 gas dew point mirror analyzer                 |
+|                        | | Newport SMC100PP single axis driver for 2-phase stepper   |
+|                        |   motors                                                    |
+|                        | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for     |
+|                        |   compact pressure gauges                                   |
+|                        | | Technix capacitor charger                                 |
++------------------------+-------------------------------------------------------------+
+| TCP                    | | Lauda PRO RP 245 E circulation thermostat                 |
++------------------------+-------------------------------------------------------------+
+| Telnet                 | | Technix capacitor charger                                 |
++------------------------+-------------------------------------------------------------+
+| VISA TCP               | | Elektro-Automatik PSI9000 DC power supply                 |
+|                        | | Rhode & Schwarz RTO 1024 oscilloscope                     |
++------------------------+-------------------------------------------------------------+
+| *propriety*            | | LabJack (T4, T7, T7-PRO) devices, which communicate via   |
+|                        |   `LJM Library`_                                            |
+|                        | | Pico Technology PT-104 Platinum Resistance Data Logger,   |
+|                        |   which communicate via `PicoSDK`_/`libusbpt104`_           |
+|                        | | TiePie (HS5, HS6, WS5) oscilloscopes, generators and I2C  |
+|                        |   hosts, which communicate via `LibTiePie SDK`_             |
++------------------------+-------------------------------------------------------------+
+
+.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
+.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
+.. _`LJM Library`: https://labjack.com/ljm
+.. _`PicoSDK`: https://www.picotech.com/downloads
+
+Sensor and Unit Conversion Utility
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The Sensor and Unit Conversion Utility is a submodule that allows on the one hand a
+unified implementation of hardware-sensors and on the other hand provides a unified
+way to convert units. The utility can be used with single numbers (:code:`int`,
+:code:`float`) as well as array-like structures containing single numbers
+(:code:`np.array()`, :code:`list`, :code:`dict`, :code:`tuple`).
+
+Currently the following sensors are implemented:
+
+- LEM LT 4000S
+- LMT 70A
+
+The following unit conversion classes are implemented:
+
+- Temperature (Kelvin, Celsius, Fahrenheit)
+- Pressure (Pascal, Bar, Atmosphere, Psi, Torr, Millimeter Mercury)
+
+
+Documentation
+-------------
+
+Note: if you're planning to contribute to the :code:`hvl_ccb` project read
+the **Contributing** section in the HVL CCB documentation.
+
+Do either:
+
+* read `HVL CCB documentation at RTD`_,
+
+or
+
+* build and read HVL CCB documentation locally; install first `Graphviz`_ (make sure
+  to have the :code:`dot` command in the executable search path) and the Python
+  build requirements for documentation::
+
+    $ pip install docs/requirements.txt
+
+  and then either on Windows in Git BASH run::
+
+    $ ./make.sh docs
+
+  or from any other shell with GNU Make installed run::
+
+    $ make docs
+
+  The target index HTML (:code:`"docs/_build/html/index.html"`) should open
+  automatically in your Web browser.
+
+.. _`Graphviz`: https://graphviz.org/
+.. _`HVL CCB documentation at RTD`: https://readthedocs.org/projects/hvl-ccb/
+
+Credits
+-------
+
+This package was created with Cookiecutter_ and the
+`audreyr/cookiecutter-pypackage`_ project template.
+
+.. _Cookiecutter: https://github.com/audreyr/cookiecutter
+.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage
+
+
+============
+Installation
+============
+
+
+Stable release
+--------------
+
+To install HVL Common Code Base, run this command in your terminal:
+
+.. code-block:: console
+
+    $ pip install hvl_ccb
+
+To install HVL Common Code Base with optional Python libraries that require manual
+installations of additional system libraries, you need to specify on installation
+extra requirements corresponding to these controllers. For instance, to install
+Python requirements for LabJack and TiePie devices, run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[tiepie,labjack]"
+
+See below for the info about additional system libraries and the corresponding extra
+requirements.
+
+To install all extra requirements run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[all]"
+
+This is the preferred method to install HVL Common Code Base, as it will always install
+the most recent stable release.
+
+If you don't have `pip`_ installed, this `Python installation guide`_ can guide
+you through the process.
+
+.. _pip: https://pip.pypa.io
+.. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
+
+
+From sources
+------------
+
+The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
+
+You can either clone the repository:
+
+.. code-block:: console
+
+    $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
+
+Or download the `tarball`_:
+
+.. code-block:: console
+
+    $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+Once you have a copy of the source, you can install it with:
+
+.. code-block:: console
+
+    $ pip install .
+
+
+.. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
+.. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+
+Additional system libraries
+---------------------------
+
+If you have installed `hvl_ccb` with any of the extra features corresponding to
+device controllers, you must additionally install respective system library; these are:
+
++-------------------------+------------------------------------------------------------+
+| Extra feature           | Additional system library                                  |
++=========================+============================================================+
+| :code:`labjack`         | `LJM Library`_                                             |
++-------------------------+------------------------------------------------------------+
+| :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
++-------------------------+------------------------------------------------------------+
+| :code:`tiepie`          | `LibTiePie SDK`_                                           |
++-------------------------+------------------------------------------------------------+
+
+For more details on installation of the libraries see docstrings of the corresponding
+:code:`hvl_ccb` modules.
+
+.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
+.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
+.. _`LJM Library`: https://labjack.com/ljm
+.. _`PicoSDK`: https://www.picotech.com/downloads
+
+
+=======
+History
+=======
+
+0.9.0 (2022-01-07)
+------------------
+
+* New device: Highland T560 digital delay and pulse generator over Telnet.
+* Rework of the Technix Capacitor Charger.
+    * Moved into a separate sub-package
+    * NEW import over :code:`import hvl_ccb.dev.technix as XXX`
+    * Slightly adapted behaviour
+* Add :code:`validate_tcp_port` to validate port number.
+* Add :code:`validate_and_resolve_host` to validate and resolve host names and IPs.
+    * Remove requirement :code:`IPy`
+* Add a unified CCB Exception schema for all devices and communication protocols.
+* Add data conversion functions to README.
+* Update CI and devel images from Debian 10 buster to Debian 11 bullseye.
+* Fix typing due to numpy update.
+* Fix incorrect overloading of :code:`clean_values()` in classes of
+  type :code:`XCommunicationConfig`.
+
+0.8.5 (2021-11-05)
+------------------
+
+* Added arbitrary waveform for TiePie signal generation, configurable via
+  :code:`dev.tiepie.generator.TiePieGeneratorConfig.waveform` property.
+* In :code:`utils.conversion_sensor`: improvements for class constants; removed SciPy
+  dependency.
+* Added Python 3.10 support.
+
+0.8.4 (2021-10-22)
+------------------
+
+* :code:`utils.validation.validate_number` extension to handle NumPy arrays and
+  array-like objects.
+* :code:`utils.conversion_unit` utility classes handle correctly :code:`NamedTuple`
+  instances.
+* :code:`utils.conversion_sensor` and :code:`utils.conversion_unit` code
+  simplification (no :code:`transfer_function_order` attribute) and cleanups.
+* Fixed incorrect error logging in :code:`configuration.configdataclass`.
+* :code:`comm.telnet.TelnetCommunication` tests fixes for local run errors.
+
+0.8.3 (2021-09-27)
+------------------
+
+* New data conversion functions in :code:`utils.conversion_sensor` and
+  :code:`utils.conversion_unit` modules. Note: to use these functions you must install
+  :code:`hvl_ccb` with extra requirement, either :code:`hvl_ccb[conversion]` or
+  :code:`hvl_ccb[all]`.
+* Improved documentation with respect to installation of external libraries.
+
+0.8.2 (2021-08-27)
+------------------
+
+* New functionality in :code:`dev.labjack.LabJack`:
+    * configure clock and send timed pulse sequences
+    * set DAC/analog output voltage
+* Bugfix: ignore random bits sent by to :code:`dev.newport.NewportSMC100PP`
+  controller during start-up/powering-up.
+
+0.8.1 (2021-08-13)
+------------------
+
+* Add Python version check (min version error; max version warning).
+* Daily checks for upstream dependencies compatibility and devel environment
+  improvements.
+
+0.8.0 (2021-07-02)
+------------------
+
+* TCP communication protocol.
+* Lauda PRO RP 245 E circulation thermostat device over TCP.
+* Pico Technology PT-104 Platinum Resistance Data Logger device as a wrapper of the
+  Python bindings for the PicoSDK.
+* In :code:`com.visa.VisaCommunication`: periodic status polling when VISA/TCP keep
+  alive connection is not supported by a host.
+
+0.7.1 (2021-06-04)
+------------------
+
+* New :code:`utils.validation` submodule with :code:`validate_bool` and
+  :code:`validate_number` utilities extracted from internal use within a
+  :code:`dev.tiepie` subpackage.
+* In :code:`comm.serial.SerialCommunication`:
+     * strict encoding errors handling strategy for subclasses,
+     * user warning for a low communication timeout value.
+
+0.7.0 (2021-05-25)
+------------------
+
+* The :code:`dev.tiepie` module was splitted into a subpackage with, in particular,
+  submodules for each of the device types -- :code:`oscilloscope`, :code:`generator`,
+  and :code:`i2c` -- and with backward-incompatible direct imports from the submodules.
+* In :code:`dev.technix`:
+      * fixed communication crash on nested status byte query;
+      * added enums for GET and SET register commands.
+* Further minor logging improvements: added missing module level logger and removed some
+  error logs in :code:`except` blocks used for a flow control.
+* In :code:`examples/` folder renamed consistently all the examples.
+* In API documentation: fix incorrect links mapping on inheritance diagrams.
+
+0.6.1 (2021-05-08)
+------------------
+
+* In :code:`dev.tiepie`:
+      * dynamically set oscilloscope's channel limits in
+        :code:`OscilloscopeChannelParameterLimits`: :code:`input_range` and
+        :code:`trigger_level_abs`, incl. update of latter on each change of
+        :code:`input_range` value of a :code:`TiePieOscilloscopeChannelConfig`
+        instances;
+      * quick fix for opening of combined instruments by disabling
+        :code:`OscilloscopeParameterLimits.trigger_delay` (an advanced feature);
+      * enable automatic devices detection to be able to find network devices with
+        :code:`TiePieOscilloscope.list_devices()`.
+* Fix :code:`examples/example_labjack.py`.
+* Improved logging: consistently use module level loggers, and always log exception
+  tracebacks.
+* Improve API documentation: separate pages per modules, each with an inheritance
+  diagram as an overview.
+
+0.6.0 (2021-04-23)
+------------------
+
+* Technix capacitor charger using either serial connection or Telnet protocol.
+* Extensions, improvements and fixes in existing devices:
+   * In :code:`dev.tiepie.TiePieOscilloscope`:
+       * redesigned measurement start and data collection API, incl. time out
+         argument, with no/infinite time out option;
+       * trigger allows now a no/infinite time out;
+       * record length and trigger level were fixed to accept, respectively, floating
+         point and integer numbers;
+       * fixed resolution validation bug;
+   * :code:`dev.heinzinger.HeinzingerDI` and `dev.rs_rto1024.RTO1024` instances are now
+     resilient to multiple :code:`stop()` calls.
+   * In :code:`dev.crylas.CryLasLaser`: default configuration timeout and
+     polling period were adjusted;
+   * Fixed PSI9080 example script.
+* Package and source code improvements:
+   * Update to backward-incompatible :code:`pyvisa-py>=0.5.2`. Developers, do update
+     your local development environments!
+   * External libraries, like LibTiePie SDK or LJM Library, are now not installed by
+     default; they are now extra installation options.
+   * Added Python 3.9 support.
+   * Improved number formatting in logs.
+   * Typing improvements and fixes for :code:`mypy>=0.800`.
+
+0.5.0 (2020-11-11)
+------------------
+
+* TiePie USB oscilloscope, generator and I2C host devices, as a wrapper of the Python
+  bindings for the LibTiePie SDK.
+* a FuG Elektronik Power Supply (e.g. Capacitor Charger HCK) using the built-in ADDAT
+  controller with the Probus V protocol over a serial connection
+* All devices poling status or measurements use now a :code:`dev.utils.Poller` utility
+  class.
+* Extensions and improvements in existing devices:
+    * In :code:`dev.rs_rto1024.RTO1024`: added Channel state, scale, range,
+      position and offset accessors, and measurements activation and read methods.
+    * In :code:`dev.sst_luminox.Luminox`: added querying for all measurements
+      in polling mode, and made output mode activation more robust.
+    * In :code:`dev.newport.NewportSMC100PP`: an error-prone
+      :code:`wait_until_move_finished` method of replaced by a fixed waiting time,
+      device operations are now robust to a power supply cut, and device restart is not
+      required to apply a start configuration.
+* Other minor improvements:
+    * Single failure-safe starting and stopping of devices sequenced via
+      :code:`dev.base.DeviceSequenceMixin`.
+    * Moved :code:`read_text_nonempty` up to :code:`comm.serial.SerialCommunication`.
+    * Added development Dockerfile.
+    * Updated package and development dependencies: :code:`pymodbus`,
+      :code:`pytest-mock`.
+
+0.4.0 (2020-07-16)
+------------------
+
+* Significantly improved new Supercube device controller:
+    - more robust error-handling,
+    - status polling with generic :code:`Poller` helper,
+    - messages and status boards.
+    - tested with a physical device,
+* Improved OPC UA client wrapper, with better error handling, incl. re-tries on
+  :code:`concurrent.futures.TimeoutError`.
+* SST Luminox Oxygen sensor device controller.
+* Backward-incompatible changes:
+    - :code:`CommunicationProtocol.access_lock` has changed type from
+      :code:`threading.Lock` to :code:`threading.RLock`.
+    - :code:`ILS2T.relative_step` and :code:`ILS2T.absolute_position` are now called,
+      respectively, :code:`ILS2T.write_relative_step` and
+      :code:`ILS2T.write_absolute_position`.
+* Minor bugfixes and improvements:
+    - fix use of max resolution in :code:`Labjack.set_ain_resolution()`,
+    - resolve ILS2T devices relative and absolute position setters race condition,
+    - added acoustic horn function in the 2015 Supercube.
+* Toolchain changes:
+    - add Python 3.8 support,
+    - drop pytest-runner support,
+    - ensure compatibility with :code:`labjack_ljm` 2019 version library.
+
+0.3.5 (2020-02-18)
+------------------
+
+* Fix issue with reading integers from LabJack LJM Library (device's product ID, serial
+  number etc.)
+* Fix development requirements specification (tox version).
+
+0.3.4 (2019-12-20)
+------------------
+
+* New devices using serial connection:
+    * Heinzinger Digital Interface I/II and a Heinzinger PNC power supply
+    * Q-switched Pulsed Laser and a laser attenuator from CryLas
+    * Newport SMC100PP single axis motion controller for 2-phase stepper motors
+    * Pfeiffer TPG controller (TPG 25x, TPG 26x and TPG 36x) for Compact pressure Gauges
+* PEP 561 compatibility and related corrections for static type checking (now in CI)
+* Refactorings:
+    * Protected non-thread safe read and write in communication protocols
+    * Device sequence mixin: start/stop, add/rm and lookup
+    * `.format()` to f-strings
+    * more enumerations and a quite some improvements of existing code
+* Improved error docstrings (:code:`:raises:` annotations) and extended tests for
+  errors.
+
+0.3.3 (2019-05-08)
+------------------
+
+* Use PyPI labjack-ljm (no external dependencies)
+
+
+0.3.2 (2019-05-08)
+------------------
+
+* INSTALLATION.rst with LJMPython prerequisite info
+
+
+0.3.1 (2019-05-02)
+------------------
+
+* readthedocs.org support
+
+0.3 (2019-05-02)
+----------------
+
+* Prevent an automatic close of VISA connection when not used.
+* Rhode & Schwarz RTO 1024 oscilloscope using VISA interface over TCP::INSTR.
+* Extended tests incl. messages sent to devices.
+* Added Supercube device using an OPC UA client
+* Added Supercube 2015 device using an OPC UA client (for interfacing with old system
+  version)
+
+0.2.1 (2019-04-01)
+------------------
+
+* Fix issue with LJMPython not being installed automatically with setuptools.
+
+0.2.0 (2019-03-31)
+------------------
+
+* LabJack LJM Library communication wrapper and LabJack device.
+* Modbus TCP communication protocol.
+* Schneider Electric ILS2T stepper motor drive device.
+* Elektro-Automatik PSI9000 current source device and VISA communication wrapper.
+* Separate configuration classes for communication protocols and devices.
+* Simple experiment manager class.
+
+0.1.0 (2019-02-06)
+------------------
+
+* Communication protocol base and serial communication implementation.
+* Device base and MBW973 implementation.
+
+
```

### Comparing `hvl_ccb-0.8.5/README.rst` & `hvl_ccb-0.9.0/README.rst`

 * *Files 10% similar despite different names*

```diff
@@ -22,87 +22,90 @@
     :target: https://hvl-ccb.readthedocs.io/en/stable/
     :alt: Documentation Status
 
 .. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/devel?label=devel&logo=gitlab
     :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/devel
     :alt: Development pipeline status
 
-Python common code base to control devices high voltage research devices, in
-particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH.
-
+Python common code base (CCB) to control devices, which are used in high-voltage
+research. All implemented devices are used and tested in the High Voltage Laboratory
+(`HVL`_) of the Federal Institute of Technology Zurich (ETH Zurich).
 
 * Free software: GNU General Public License v3
-* Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
+* Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
 
+.. _`HVL`: https://hvl.ee.ethz.ch/
 
 Features
 --------
 
 For managing multi-device experiments instantiate the :code:`ExperimentManager`
 utility class.
 
 Devices
 ~~~~~~~
 
-The devices wrappers in :code:`hvl_ccb` provide a standardised API with configuration
-dataclasses, various settings and options enumerations, as well as start/stop methods.
-Currently, wrappers to control the following devices are available:
+The device wrappers in :code:`hvl_ccb` provide a standardised API with configuration
+dataclasses, various settings and options, as well as start/stop methods.
+Currently wrappers are available to control the following devices:
 
 +-------------------------+------------------------------------------------------------+
 | Function/Type           | Devices                                                    |
 +=========================+============================================================+
 | Data acquisition        | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
 |                         | | Pico Technology PT-104 Platinum Resistance Data Logger   |
 |                         |   (requires `PicoSDK`_/`libusbpt104`_)                     |
 +-------------------------+------------------------------------------------------------+
+| Digital Delay Generator | | Highland T560                                            |
++-------------------------+------------------------------------------------------------+
 | Digital IO              | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
 +-------------------------+------------------------------------------------------------+
 | Experiment control      | | HVL Supercube with and without Frequency Converter       |
 +-------------------------+------------------------------------------------------------+
 | Gas Analyser            | | MBW 973-SF6 gas dew point mirror analyzer                |
 |                         | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for    |
 |                         |   compact pressure gauges                                  |
 |                         | | SST Luminox oxygen sensor                                |
 +-------------------------+------------------------------------------------------------+
-| I2C host                | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
+| I2C host                | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
 +-------------------------+------------------------------------------------------------+
 | Laser                   | | CryLaS pulsed laser                                      |
 |                         | | CryLaS laser attenuator                                  |
 +-------------------------+------------------------------------------------------------+
 | Oscilloscope            | | Rhode & Schwarz RTO 1024                                 |
-|                         | | TiePie (HS5, HS6, WS5; requries `LibTiePie SDK`_)        |
+|                         | | TiePie (HS5, HS6, WS5; requires `LibTiePie SDK`_)        |
 +-------------------------+------------------------------------------------------------+
 | Power supply            | | Elektro-Automatik PSI9000                                |
 |                         | | FuG Elektronik                                           |
 |                         | | Heinzinger PNC                                           |
 |                         | | Technix capacitor charger                                |
 +-------------------------+------------------------------------------------------------+
 | Stepper motor drive     | | Newport SMC100PP                                         |
 |                         | | Schneider Electric ILS2T                                 |
 +-------------------------+------------------------------------------------------------+
 | Temperature control     | | Lauda PRO RP 245 E circulation thermostat                |
 +-------------------------+------------------------------------------------------------+
-| Waveform generator      | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
+| Waveform generator      | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
 +-------------------------+------------------------------------------------------------+
 
 Each device uses at least one standardised communication protocol wrapper.
 
 Communication protocols
 ~~~~~~~~~~~~~~~~~~~~~~~
 
 In :code:`hvl_ccb` by "communication protocol" we mean different levels of
 communication standards, from the low level actual communication protocols like
 serial communication to application level interfaces like VISA TCP standard. There
-are also devices in :code:`hvl_ccb` that use dummy communication protocol concept;
-this is because these devices build on propriety vendor libraries that communicate
-with vendor devices, like in case of the TiePie devices.
+are also devices in :code:`hvl_ccb` that use a dummy communication protocol;
+this is because these devices are build on proprietary manufacturer libraries that
+communicate with the corresponding devices, as in the case of TiePie or LabJack devices.
 
 The communication protocol wrappers in :code:`hvl_ccb` provide a standardised API with
-configuration dataclasses, as well as open/close, and read/write/query methods.
-Currently, wrappers to use the following communication protocols are available:
+configuration dataclasses, as well as open/close and read/write/query methods.
+Currently, wrappers for the following communication protocols are available:
 
 +------------------------+-------------------------------------------------------------+
 | Communication protocol | Devices using                                               |
 +========================+=============================================================+
 | Modbus TCP             | | Schneider Electric ILS2T stepper motor drive              |
 +------------------------+-------------------------------------------------------------+
 | OPC UA                 | | HVL Supercube with and without Frequency Converter        |
@@ -136,19 +139,39 @@
 +------------------------+-------------------------------------------------------------+
 
 .. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
 .. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
 .. _`LJM Library`: https://labjack.com/ljm
 .. _`PicoSDK`: https://www.picotech.com/downloads
 
+Sensor and Unit Conversion Utility
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The Sensor and Unit Conversion Utility is a submodule that allows on the one hand a
+unified implementation of hardware-sensors and on the other hand provides a unified
+way to convert units. The utility can be used with single numbers (:code:`int`,
+:code:`float`) as well as array-like structures containing single numbers
+(:code:`np.array()`, :code:`list`, :code:`dict`, :code:`tuple`).
+
+Currently the following sensors are implemented:
+
+- LEM LT 4000S
+- LMT 70A
+
+The following unit conversion classes are implemented:
+
+- Temperature (Kelvin, Celsius, Fahrenheit)
+- Pressure (Pascal, Bar, Atmosphere, Psi, Torr, Millimeter Mercury)
+
+
 Documentation
 -------------
 
-Note: if you're planning to contribute to the :code:`hvl_ccb` project do read
-beforehand the **Contributing** section in the HVL CCB documentation.
+Note: if you're planning to contribute to the :code:`hvl_ccb` project read
+the **Contributing** section in the HVL CCB documentation.
 
 Do either:
 
 * read `HVL CCB documentation at RTD`_,
 
 or
```

### Comparing `hvl_ccb-0.8.5/docs/Makefile` & `hvl_ccb-0.9.0/docs/Makefile`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,20 +1,20 @@
-# Minimal makefile for Sphinx documentation
-#
-
-# You can set these variables from the command line.
-SPHINXOPTS    =
-SPHINXBUILD   = python -msphinx
-SPHINXPROJ    = hvl_ccb
-SOURCEDIR     = .
-BUILDDIR      = _build
-
-# Put it first so that "make" without argument is like "make help".
-help:
-	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
-
-.PHONY: help Makefile
-
-# Catch-all target: route all unknown targets to Sphinx using the new
-# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
-%: Makefile
-	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
+# Minimal makefile for Sphinx documentation
+#
+
+# You can set these variables from the command line.
+SPHINXOPTS    =
+SPHINXBUILD   = python -msphinx
+SPHINXPROJ    = hvl_ccb
+SOURCEDIR     = .
+BUILDDIR      = _build
+
+# Put it first so that "make" without argument is like "make help".
+help:
+	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
+
+.PHONY: help Makefile
+
+# Catch-all target: route all unknown targets to Sphinx using the new
+# "make mode" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).
+%: Makefile
+	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
```

### Comparing `hvl_ccb-0.8.5/docs/conf.py` & `hvl_ccb-0.9.0/docs/conf.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,189 +1,189 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-#
-# hvl_ccb documentation build configuration file, created by
-# sphinx-quickstart on Fri Jun  9 13:47:02 2017.
-#
-# This file is execfile()d with the current directory set to its
-# containing dir.
-#
-# Note that not all possible configuration values are present in this
-# autogenerated file.
-#
-# All configuration values have a default; values that are commented out
-# serve to show the default.
-
-# If extensions (or modules to document with autodoc) are in another
-# directory, add these directories to sys.path here. If the directory is
-# relative to the documentation root, use os.path.abspath to make it
-# absolute, like shown here.
-#
-import os
-import sys
-sys.path.insert(0, os.path.abspath('..'))
-
-with open(os.path.join('..', 'VERSION')) as version_file:
-    hvl_ccb_version = version_file.read().strip()
-
-# -- General configuration ---------------------------------------------
-
-# If your documentation needs a minimal Sphinx version, state it here.
-#
-# needs_sphinx = '1.0'
-
-# Add any Sphinx extension module names here, as strings. They can be
-# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
-extensions = [
-    'sphinx.ext.autodoc',
-    'sphinx.ext.viewcode',
-    'sphinx.ext.graphviz',
-    'sphinx.ext.inheritance_diagram',
-]
-
-# Add any paths that contain templates here, relative to this directory.
-templates_path = ['_templates']
-
-# The suffix(es) of source filenames.
-# You can specify multiple suffix as a list of string:
-#
-# source_suffix = ['.rst', '.md']
-source_suffix = '.rst'
-
-# The master toctree document.
-master_doc = 'index'
-
-# General information about the project.
-project = u'HVL Common Code Base'
-copyright = u"2019-2021 ETH Zurich, SIS ID and HVL D-ITET"
-author = (
-    u"Mikolaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, "
-    u"Henning Janssen, David Taylor"
-)
-
-# The version info for the project you're documenting, acts as replacement
-# for |version| and |release|, also used in various other places throughout
-# the built documents.
-#
-# The short X.Y version.
-version = hvl_ccb_version
-# The full version, including alpha/beta/rc tags.
-release = hvl_ccb_version
-
-# The language for content autogenerated by Sphinx. Refer to documentation
-# for a list of supported languages.
-#
-# This is also used if you do content translation via gettext catalogs.
-# Usually you set "language" from the command line for these cases.
-language = None
-
-# List of patterns, relative to source directory, that match files and
-# directories to ignore when looking for source files.
-# This patterns also effect to html_static_path and html_extra_path
-exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
-
-# The name of the Pygments (syntax highlighting) style to use.
-pygments_style = 'sphinx'
-
-# If true, `todo` and `todoList` produce output, else they produce nothing.
-todo_include_todos = False
-
-# If true, the current module name will be prepended to all description
-# unit titles (such as .. function::).
-add_module_names = False
-
-# The output format for Graphviz when building HTML files. This must be either 'png'
-# or 'svg'; the default is 'png'. If 'svg' is used, in order to make the URL links
-# work properly, an appropriate target attribute must be set, such as "_top" and
-# "_blank".
-graphviz_output_format = "svg"
-
-# A dictionary of graphviz graph attributes for inheritance diagrams.
-inheritance_graph_attrs = dict(
-    rankdir="TB",  # top to bottom
-    size='""',
-)
-
-# -- Options for HTML output -------------------------------------------
-
-# The theme to use for HTML and HTML Help pages.  See the documentation for
-# a list of builtin themes.
-#
-html_theme = 'sphinx_rtd_theme'
-
-# Theme options are theme-specific and customize the look and feel of a
-# theme further.  For a list of options available for each theme, see the
-# documentation.
-#
-html_theme_options = {
-    'navigation_depth': 8,
-}
-
-# Add any paths that contain custom static files (such as style sheets) here,
-# relative to this directory. They are copied after the builtin static files,
-# so a file named "default.css" will overwrite the builtin "default.css".
-html_static_path = ['_static']
-
-
-# -- Options for HTMLHelp output ---------------------------------------
-
-# Output file base name for HTML help builder.
-htmlhelp_basename = 'hvl_ccbdoc'
-
-
-# -- Options for LaTeX output ------------------------------------------
-
-latex_elements = {
-    # The paper size ('letterpaper' or 'a4paper').
-    #
-    # 'papersize': 'letterpaper',
-
-    # The font size ('10pt', '11pt' or '12pt').
-    #
-    # 'pointsize': '10pt',
-
-    # Additional stuff for the LaTeX preamble.
-    #
-    # 'preamble': '',
-
-    # Latex figure (float) alignment
-    #
-    # 'figure_align': 'htbp',
-}
-
-# Grouping the document tree into LaTeX files. List of tuples
-# (source start file, target name, title, author, documentclass
-# [howto, manual, or own class]).
-latex_documents = [
-    (master_doc, 'hvl_ccb.tex',
-     u'HVL Common Code Base Documentation',
-     author, 'manual'),
-]
-
-
-# -- Options for manual page output ------------------------------------
-
-# One entry per manual page. List of tuples
-# (source start file, name, description, authors, manual section).
-man_pages = [
-    (master_doc, 'hvl_ccb',
-     u'HVL Common Code Base Documentation',
-     [author], 1)
-]
-
-
-# -- Options for Texinfo output ----------------------------------------
-
-# Grouping the document tree into Texinfo files. List of tuples
-# (source start file, target name, title, author,
-#  dir menu entry, description, category)
-texinfo_documents = [
-    (master_doc, 'hvl_ccb',
-     u'HVL Common Code Base Documentation',
-     author,
-     'hvl_ccb',
-     'One line description of project.',
-     'Miscellaneous'),
-]
-
-
-
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# hvl_ccb documentation build configuration file, created by
+# sphinx-quickstart on Fri Jun  9 13:47:02 2017.
+#
+# This file is execfile()d with the current directory set to its
+# containing dir.
+#
+# Note that not all possible configuration values are present in this
+# autogenerated file.
+#
+# All configuration values have a default; values that are commented out
+# serve to show the default.
+
+# If extensions (or modules to document with autodoc) are in another
+# directory, add these directories to sys.path here. If the directory is
+# relative to the documentation root, use os.path.abspath to make it
+# absolute, like shown here.
+#
+import os
+import sys
+sys.path.insert(0, os.path.abspath('..'))
+
+with open(os.path.join('..', 'VERSION')) as version_file:
+    hvl_ccb_version = version_file.read().strip()
+
+# -- General configuration ---------------------------------------------
+
+# If your documentation needs a minimal Sphinx version, state it here.
+#
+# needs_sphinx = '1.0'
+
+# Add any Sphinx extension module names here, as strings. They can be
+# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
+extensions = [
+    'sphinx.ext.autodoc',
+    'sphinx.ext.viewcode',
+    'sphinx.ext.graphviz',
+    'sphinx.ext.inheritance_diagram',
+]
+
+# Add any paths that contain templates here, relative to this directory.
+templates_path = ['_templates']
+
+# The suffix(es) of source filenames.
+# You can specify multiple suffix as a list of string:
+#
+# source_suffix = ['.rst', '.md']
+source_suffix = '.rst'
+
+# The master toctree document.
+master_doc = 'index'
+
+# General information about the project.
+project = u'HVL Common Code Base'
+copyright = u"2019-2021 ETH Zurich, SIS ID and HVL D-ITET"
+author = (
+    u"Mikolaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, "
+    u"Henning Janssen, David Taylor"
+)
+
+# The version info for the project you're documenting, acts as replacement
+# for |version| and |release|, also used in various other places throughout
+# the built documents.
+#
+# The short X.Y version.
+version = hvl_ccb_version
+# The full version, including alpha/beta/rc tags.
+release = hvl_ccb_version
+
+# The language for content autogenerated by Sphinx. Refer to documentation
+# for a list of supported languages.
+#
+# This is also used if you do content translation via gettext catalogs.
+# Usually you set "language" from the command line for these cases.
+language = None
+
+# List of patterns, relative to source directory, that match files and
+# directories to ignore when looking for source files.
+# This patterns also effect to html_static_path and html_extra_path
+exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+
+# The name of the Pygments (syntax highlighting) style to use.
+pygments_style = 'sphinx'
+
+# If true, `todo` and `todoList` produce output, else they produce nothing.
+todo_include_todos = False
+
+# If true, the current module name will be prepended to all description
+# unit titles (such as .. function::).
+add_module_names = False
+
+# The output format for Graphviz when building HTML files. This must be either 'png'
+# or 'svg'; the default is 'png'. If 'svg' is used, in order to make the URL links
+# work properly, an appropriate target attribute must be set, such as "_top" and
+# "_blank".
+graphviz_output_format = "svg"
+
+# A dictionary of graphviz graph attributes for inheritance diagrams.
+inheritance_graph_attrs = dict(
+    rankdir="TB",  # top to bottom
+    size='""',
+)
+
+# -- Options for HTML output -------------------------------------------
+
+# The theme to use for HTML and HTML Help pages.  See the documentation for
+# a list of builtin themes.
+#
+html_theme = 'sphinx_rtd_theme'
+
+# Theme options are theme-specific and customize the look and feel of a
+# theme further.  For a list of options available for each theme, see the
+# documentation.
+#
+html_theme_options = {
+    'navigation_depth': 8,
+}
+
+# Add any paths that contain custom static files (such as style sheets) here,
+# relative to this directory. They are copied after the builtin static files,
+# so a file named "default.css" will overwrite the builtin "default.css".
+html_static_path = ['_static']
+
+
+# -- Options for HTMLHelp output ---------------------------------------
+
+# Output file base name for HTML help builder.
+htmlhelp_basename = 'hvl_ccbdoc'
+
+
+# -- Options for LaTeX output ------------------------------------------
+
+latex_elements = {
+    # The paper size ('letterpaper' or 'a4paper').
+    #
+    # 'papersize': 'letterpaper',
+
+    # The font size ('10pt', '11pt' or '12pt').
+    #
+    # 'pointsize': '10pt',
+
+    # Additional stuff for the LaTeX preamble.
+    #
+    # 'preamble': '',
+
+    # Latex figure (float) alignment
+    #
+    # 'figure_align': 'htbp',
+}
+
+# Grouping the document tree into LaTeX files. List of tuples
+# (source start file, target name, title, author, documentclass
+# [howto, manual, or own class]).
+latex_documents = [
+    (master_doc, 'hvl_ccb.tex',
+     u'HVL Common Code Base Documentation',
+     author, 'manual'),
+]
+
+
+# -- Options for manual page output ------------------------------------
+
+# One entry per manual page. List of tuples
+# (source start file, name, description, authors, manual section).
+man_pages = [
+    (master_doc, 'hvl_ccb',
+     u'HVL Common Code Base Documentation',
+     [author], 1)
+]
+
+
+# -- Options for Texinfo output ----------------------------------------
+
+# Grouping the document tree into Texinfo files. List of tuples
+# (source start file, target name, title, author,
+#  dir menu entry, description, category)
+texinfo_documents = [
+    (master_doc, 'hvl_ccb',
+     u'HVL Common Code Base Documentation',
+     author,
+     'hvl_ccb',
+     'One line description of project.',
+     'Miscellaneous'),
+]
+
+
+
```

### Comparing `hvl_ccb-0.8.5/docs/hvl_ccb.dev.picotech_pt104.rst` & `hvl_ccb-0.9.0/docs/hvl_ccb.dev.picotech_pt104.rst`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-hvl\_ccb.dev.picotech\_pt104
-============================
-
-**NOTE**: `PicoSDK Python wrappers`_ already on import attempt to load the
-`PicoSDK library`_; thus, the API docs can only be generated in a system with the
-latter installed and are by default disabled.
-
-.. _`PicoSDK Python wrappers`: https://pypi.org/project/picosdk/
-.. _`PicoSDK library`: https://www.picotech.com/downloads
-
-To build the API docs for this submodule locally edit the
-:code:`docs/hvl_ccb.dev.picotech_pt104.rst` file to remove the :code:`.. code-block::`
-directive preceding the following directives:
-
-.. code-block::
-
-    .. inheritance-diagram:: hvl_ccb.dev.picotech_pt104
-       :parts: 1
-
-
-    .. automodule:: hvl_ccb.dev.picotech_pt104
-       :members:
-       :undoc-members:
-       :show-inheritance:
+hvl\_ccb.dev.picotech\_pt104
+============================
+
+**NOTE**: `PicoSDK Python wrappers`_ already on import attempt to load the
+`PicoSDK library`_; thus, the API docs can only be generated in a system with the
+latter installed and are by default disabled.
+
+.. _`PicoSDK Python wrappers`: https://pypi.org/project/picosdk/
+.. _`PicoSDK library`: https://www.picotech.com/downloads
+
+To build the API docs for this submodule locally edit the
+:code:`docs/hvl_ccb.dev.picotech_pt104.rst` file to remove the :code:`.. code-block::`
+directive preceding the following directives:
+
+.. code-block::
+
+    .. inheritance-diagram:: hvl_ccb.dev.picotech_pt104
+       :parts: 1
+
+
+    .. automodule:: hvl_ccb.dev.picotech_pt104
+       :members:
+       :undoc-members:
+       :show-inheritance:
```

### Comparing `hvl_ccb-0.8.5/docs/hvl_ccb.dev.rst` & `hvl_ccb-0.9.0/docs/hvl_ccb.dev.rst`

 * *Files 24% similar despite different names*

```diff
@@ -1,45 +1,46 @@
-hvl\_ccb.dev
-============
-
-
-Subpackages
------------
-
-.. toctree::
-   :maxdepth: 4
-
-   hvl_ccb.dev.supercube
-   hvl_ccb.dev.supercube2015
-   hvl_ccb.dev.tiepie
-
-Submodules
-----------
-
-.. toctree::
-   :maxdepth: 4
-
-   hvl_ccb.dev.base
-   hvl_ccb.dev.crylas
-   hvl_ccb.dev.ea_psi9000
-   hvl_ccb.dev.fug
-   hvl_ccb.dev.heinzinger
-   hvl_ccb.dev.labjack
-   hvl_ccb.dev.lauda
-   hvl_ccb.dev.mbw973
-   hvl_ccb.dev.newport
-   hvl_ccb.dev.pfeiffer_tpg
-   hvl_ccb.dev.picotech_pt104
-   hvl_ccb.dev.rs_rto1024
-   hvl_ccb.dev.se_ils2t
-   hvl_ccb.dev.sst_luminox
-   hvl_ccb.dev.technix
-   hvl_ccb.dev.utils
-   hvl_ccb.dev.visa
-
-Module contents
----------------
-
-.. automodule:: hvl_ccb.dev
-   :members:
-   :undoc-members:
-   :show-inheritance:
+hvl\_ccb.dev
+============
+
+
+Subpackages
+-----------
+
+.. toctree::
+   :maxdepth: 4
+
+   hvl_ccb.dev.highland_t560
+   hvl_ccb.dev.supercube
+   hvl_ccb.dev.supercube2015
+   hvl_ccb.dev.technix
+   hvl_ccb.dev.tiepie
+
+Submodules
+----------
+
+.. toctree::
+   :maxdepth: 4
+
+   hvl_ccb.dev.base
+   hvl_ccb.dev.crylas
+   hvl_ccb.dev.ea_psi9000
+   hvl_ccb.dev.fug
+   hvl_ccb.dev.heinzinger
+   hvl_ccb.dev.labjack
+   hvl_ccb.dev.lauda
+   hvl_ccb.dev.mbw973
+   hvl_ccb.dev.newport
+   hvl_ccb.dev.pfeiffer_tpg
+   hvl_ccb.dev.picotech_pt104
+   hvl_ccb.dev.rs_rto1024
+   hvl_ccb.dev.se_ils2t
+   hvl_ccb.dev.sst_luminox
+   hvl_ccb.dev.utils
+   hvl_ccb.dev.visa
+
+Module contents
+---------------
+
+.. automodule:: hvl_ccb.dev
+   :members:
+   :undoc-members:
+   :show-inheritance:
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/__init__.py` & `hvl_ccb-0.9.0/hvl_ccb/__init__.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""Top-level package for HVL Common Code Base."""
-
-__author__ = (
-    "Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, "
-    "David Taylor"
-)
-__email__ = (
-    "mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, "
-    "chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch"
-)
-__version__ = '0.8.5'
-
-from . import comm  # noqa: F401
-from . import dev  # noqa: F401
-from .configuration import ConfigurationMixin, configdataclass  # noqa: F401
-from .experiment_manager import (  # noqa: F401
-    ExperimentManager,
-    ExperimentStatus,
-    ExperimentError
-)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""Top-level package for HVL Common Code Base."""
+
+__author__ = (
+    "Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, "
+    "David Taylor"
+)
+__email__ = (
+    "mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, "
+    "chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch"
+)
+__version__ = '0.9.0'
+
+from . import comm  # noqa: F401
+from . import dev  # noqa: F401
+from .configuration import ConfigurationMixin, configdataclass  # noqa: F401
+from .experiment_manager import (  # noqa: F401
+    ExperimentManager,
+    ExperimentStatus,
+    ExperimentError
+)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/__init__.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/__init__.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""Communication protocols subpackage."""
-
-from .base import (  # noqa: F401
-    CommunicationProtocol,
-    NullCommunicationProtocol,
-)
-
-try:
-    from .labjack_ljm import (  # noqa: F401
-        LJMCommunication,
-        LJMCommunicationConfig,
-        LJMCommunicationError,
-    )
-except (ImportError, ModuleNotFoundError):
-    import warnings
-
-    warnings.warn(
-        "\n\n  "
-        "To use LabJack device controller or related utilities install the LJM Library"
-        "\n  "
-        "and install hvl_ccb library with a 'labjack' extra feature:"
-        "\n\n  "
-        "    pip install hvl_ccb[labjack]"
-        "\n\n"
-    )
-
-from .modbus_tcp import (  # noqa: F401
-    ModbusTcpCommunication,
-    ModbusTcpConnectionFailedException,
-    ModbusTcpCommunicationConfig,
-)
-from .opc import (  # noqa: F401
-    OpcUaCommunication,
-    OpcUaCommunicationConfig,
-    OpcUaCommunicationIOError,
-    OpcUaCommunicationTimeoutError,
-    OpcUaSubHandler,
-)
-from .telnet import (  # noqa: F401
-    TelnetCommunication,
-    TelnetCommunicationConfig,
-    TelnetError,
-)
-from .serial import (  # noqa: F401
-    SerialCommunication,
-    SerialCommunicationConfig,
-    SerialCommunicationIOError,
-)
-from .tcp import (  # noqa: F401
-    TcpCommunicationConfig,
-    Tcp,
-)
-from .visa import (  # noqa: F401
-    VisaCommunication,
-    VisaCommunicationError,
-    VisaCommunicationConfig,
-)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""Communication protocols subpackage."""
+
+from .base import (  # noqa: F401
+    CommunicationProtocol,
+    NullCommunicationProtocol,
+)
+
+try:
+    from .labjack_ljm import (  # noqa: F401
+        LJMCommunication,
+        LJMCommunicationConfig,
+        LJMCommunicationError,
+    )
+except (ImportError, ModuleNotFoundError):
+    import warnings
+
+    warnings.warn(
+        "\n\n  "
+        "To use LabJack device controller or related utilities install the LJM Library"
+        "\n  "
+        "and install hvl_ccb library with a 'labjack' extra feature:"
+        "\n\n  "
+        "    pip install hvl_ccb[labjack]"
+        "\n\n"
+    )
+
+from .modbus_tcp import (  # noqa: F401
+    ModbusTcpCommunication,
+    ModbusTcpConnectionFailedException,
+    ModbusTcpCommunicationConfig,
+)
+from .opc import (  # noqa: F401
+    OpcUaCommunication,
+    OpcUaCommunicationConfig,
+    OpcUaCommunicationIOError,
+    OpcUaCommunicationTimeoutError,
+    OpcUaSubHandler,
+)
+from .telnet import (  # noqa: F401
+    TelnetCommunication,
+    TelnetCommunicationConfig,
+    TelnetError,
+)
+from .serial import (  # noqa: F401
+    SerialCommunication,
+    SerialCommunicationConfig,
+    SerialCommunicationIOError,
+)
+from .tcp import (  # noqa: F401
+    TcpCommunicationConfig,
+    Tcp,
+)
+from .visa import (  # noqa: F401
+    VisaCommunication,
+    VisaCommunicationError,
+    VisaCommunicationConfig,
+)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/labjack_ljm.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/labjack_ljm.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,292 +1,292 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol for LabJack using the LJM Library.
-Originally developed and tested for LabJack T7-PRO.
-
-Makes use of the LabJack LJM Library Python wrapper.
-This wrapper needs an installation of the LJM Library for Windows, Mac OS X or Linux.
-Go to:
-https://labjack.com/support/software/installers/ljm
-and
-https://labjack.com/support/software/examples/ljm/python
-"""
-
-import logging
-from numbers import Real, Integral
-from typing import Union, Dict, Sequence, Type
-
-from labjack import ljm
-
-from .base import CommunicationProtocol
-from .._dev import labjack
-from ..configuration import configdataclass
-from ..utils.enum import AutoNumberNameEnum
-
-logger = logging.getLogger(__name__)
-
-
-class LJMCommunicationError(Exception):
-    """
-    Errors coming from LJMCommunication.
-    """
-
-    pass
-
-
-@configdataclass
-class LJMCommunicationConfig:
-    """
-    Configuration dataclass for :class:`LJMCommunication`.
-    """
-
-    DeviceType = labjack.DeviceType
-
-    #: Can be either string 'ANY', 'T7_PRO', 'T7', 'T4', or of enum :class:`DeviceType`.
-    device_type: Union[str, labjack.DeviceType] = "ANY"
-
-    class ConnectionType(AutoNumberNameEnum):
-        """
-        LabJack connection type.
-        """
-
-        ANY = ()
-        USB = ()
-        TCP = ()
-        ETHERNET = ()
-        WIFI = ()
-
-    #: Can be either string or of enum :class:`ConnectionType`.
-    connection_type: Union[str, ConnectionType] = "ANY"
-
-    identifier: str = "ANY"
-    """
-    The identifier specifies information for the connection to be used. This can
-    be an IP address, serial number, or device name. See the LabJack docs (
-    https://labjack.com/support/software/api/ljm/function-reference/ljmopens/\
-identifier-parameter) for more information.
-    """
-
-    def clean_values(self) -> None:
-        """
-        Performs value checks on device_type and connection_type.
-        """
-        if not isinstance(self.device_type, self.DeviceType):
-            self.force_value(  # type: ignore
-                "device_type", self.DeviceType(self.device_type)
-            )
-
-        if not isinstance(self.connection_type, self.ConnectionType):
-            self.force_value(  # type: ignore
-                "connection_type", self.ConnectionType(self.connection_type)
-            )
-
-
-class LJMCommunication(CommunicationProtocol):
-    """
-    Communication protocol implementing the LabJack LJM Library Python wrapper.
-    """
-
-    def __init__(self, configuration) -> None:
-        """
-        Constructor for LJMCommunication.
-        """
-        super().__init__(configuration)
-
-        # reference to the ctypes handle
-        self._handle = None
-
-    @staticmethod
-    def config_cls():
-        return LJMCommunicationConfig
-
-    def open(self) -> None:
-        """
-        Open the communication port.
-        """
-
-        logger.info("Open connection")
-
-        # open connection and store handle
-        # may throw 1227 LJME_DEVICE_NOT_FOUND if device is not found
-        try:
-            with self.access_lock:
-                self._handle = ljm.openS(
-                    self.config.device_type.type_str,
-                    str(self.config.connection_type),
-                    str(self.config.identifier),
-                )
-        except ljm.LJMError as e:
-            logger.error(str(e), exc_info=e)
-            # only catch "1229 LJME_DEVICE_ALREADY_OPEN", never observed
-            if e.errorCode != 1229:
-                raise LJMCommunicationError from e
-
-    def close(self) -> None:
-        """
-        Close the communication port.
-        """
-
-        logger.info("Closing connection")
-
-        try:
-            with self.access_lock:
-                ljm.close(self._handle)
-        except ljm.LJMError as e:
-            logger.error(str(e), exc_info=e)
-            # only catch "1224 LJME_DEVICE_NOT_OPEN", thrown on invalid handle
-            if e.errorCode != 1224:
-                raise LJMCommunicationError from e
-        self._handle = None
-
-    @property
-    def is_open(self) -> bool:
-        """
-        Flag indicating if the communication port is open.
-
-        :return: `True` if the port is open, otherwise `False`
-        """
-        # getHandleInfo does not work with LJM DEMO_MODE - consider it always opened
-        # if only set
-        if str(self._handle) == labjack.constants.DEMO_MODE:
-            return True
-
-        try:
-            ljm.getHandleInfo(self._handle)
-        except ljm.LJMError as e:
-            logger.error(str(e), exc_info=e)
-            if e.errorCode == 1224:  # "1224 LJME_DEVICE_NOT_OPEN"
-                return False
-            raise LJMCommunicationError from e
-        return True
-
-    def __del__(self) -> None:
-        """
-        Finalizer, closes port
-        """
-
-        self.close()
-
-    @staticmethod
-    def _cast_read_value(
-        name: str,
-        val: Real,
-        return_num_type: Type[Real] = float,  # type: ignore
-        # see: https://github.com/python/mypy/issues/3186
-    ) -> Real:
-        """
-        Cast a read value to a numeric type, performing some extra cast validity checks.
-
-        :param name: name of the read value, only for error reporting
-        :param val: value to cast
-        :param return_num_type: optional numeric type specification for return values;
-            by default `float`
-        :return: input value `val` casted to `return_num_type`
-        :raises TypeError: if read value of type not compatible with `return_num_type`
-        """
-        # Note: the underlying library returns already `float` (or
-        # `ctypes.c_double`?); but defensively cast again via `str`:
-        # 1) in case the underlying lib behaviour changes, and
-        # 2) to raise `TypeError` when got non integer `float` value and expecting
-        #    `int` value
-        invalid_value_type = False
-        try:
-            fval = float(str(val))
-            if issubclass(return_num_type, Integral) and not fval.is_integer():
-                invalid_value_type = True
-            else:
-                ret = return_num_type(fval)  # type: ignore
-        except ValueError as e:
-            logger.error(str(e), exc_info=e)
-            invalid_value_type = True
-        if invalid_value_type:
-            raise TypeError(
-                f"Expected {return_num_type} value for '{name}' "
-                f"name, got {type(val)} value of {val}"
-            )
-        return ret
-
-    def read_name(
-        self,
-        *names: str,
-        return_num_type: Type[Real] = float,  # type: ignore
-        # see: https://github.com/python/mypy/issues/3186
-    ) -> Union[Real, Sequence[Real]]:
-        """
-        Read one or more input numeric values by name.
-
-        :param names: one or more names to read out from the LabJack
-        :param return_num_type: optional numeric type specification for return values;
-            by default `float`.
-        :return: answer of the LabJack, either single number or multiple numbers in a
-            sequence, respectively, when one or multiple names to read were given
-        :raises TypeError: if read value of type not compatible with `return_num_type`
-        """
-
-        # Errors that can be returned here:
-        # 1224 LJME_DEVICE_NOT_OPEN if the device is not open
-        # 1239 LJME_DEVICE_RECONNECT_FAILED if the device was opened, but connection
-        #   lost
-
-        with self.access_lock:
-            try:
-                if len(names) == 1:
-                    ret = ljm.eReadName(self._handle, names[0])
-                    ret = self._cast_read_value(
-                        names[0], ret, return_num_type=return_num_type
-                    )
-                else:
-                    ret = ljm.eReadNames(self._handle, len(names), names)
-                    for (i, (iname, iret)) in enumerate(zip(names, ret)):
-                        ret[i] = self._cast_read_value(
-                            iname, iret, return_num_type=return_num_type
-                        )
-            except ljm.LJMError as e:
-                logger.error(str(e), exc_info=e)
-                raise LJMCommunicationError from e
-
-        return ret
-
-    def write_name(self, name: str, value: Real) -> None:
-        """
-        Write one value to a named output.
-
-        :param name: String or with name of LabJack IO
-        :param value: is the value to write to the named IO port
-        """
-
-        with self.access_lock:
-            try:
-                ljm.eWriteName(self._handle, name, value)
-            except ljm.LJMError as e:
-                logger.error(str(e), exc_info=e)
-                raise LJMCommunicationError from e
-
-    def write_names(self, name_value_dict: Dict[str, Real]) -> None:
-        """
-        Write more than one value at once to named outputs.
-
-        :param name_value_dict: is a dictionary with string names of LabJack IO as keys
-            and corresponding numeric values
-        """
-        names = list(name_value_dict.keys())
-        values = list(name_value_dict.values())
-        with self.access_lock:
-            try:
-                ljm.eWriteNames(self._handle, len(names), names, values)
-            except ljm.LJMError as e:
-                logger.error(str(e), exc_info=e)
-                raise LJMCommunicationError from e
-
-    # def write_address(self, address: int, value: Real) -> None:
-    #     """
-    #     **NOT IMPLEMENTED.**
-    #     Write one or more values to Modbus addresses.
-    #
-    #     :param address: One or more Modbus address on the LabJack.
-    #     :param value: One or more values to be written to the addresses.
-    #     """
-    #
-    #     raise NotImplementedError
-    #     # TODO: Implement function to write on addresses. Problem so far: I also need
-    #     #  to bring in the data types (INT32, FLOAT32...)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol for LabJack using the LJM Library.
+Originally developed and tested for LabJack T7-PRO.
+
+Makes use of the LabJack LJM Library Python wrapper.
+This wrapper needs an installation of the LJM Library for Windows, Mac OS X or Linux.
+Go to:
+https://labjack.com/support/software/installers/ljm
+and
+https://labjack.com/support/software/examples/ljm/python
+"""
+
+import logging
+from numbers import Real, Integral
+from typing import Union, Dict, Sequence, Type
+
+from labjack import ljm
+
+from .base import CommunicationProtocol, CommunicationException
+from .._dev import labjack
+from ..configuration import configdataclass
+from ..utils.enum import AutoNumberNameEnum
+
+logger = logging.getLogger(__name__)
+
+
+class LJMCommunicationError(CommunicationException):
+    """
+    Errors coming from LJMCommunication.
+    """
+
+    pass
+
+
+@configdataclass
+class LJMCommunicationConfig:
+    """
+    Configuration dataclass for :class:`LJMCommunication`.
+    """
+
+    DeviceType = labjack.DeviceType
+
+    #: Can be either string 'ANY', 'T7_PRO', 'T7', 'T4', or of enum :class:`DeviceType`.
+    device_type: Union[str, labjack.DeviceType] = "ANY"
+
+    class ConnectionType(AutoNumberNameEnum):
+        """
+        LabJack connection type.
+        """
+
+        ANY = ()
+        USB = ()
+        TCP = ()
+        ETHERNET = ()
+        WIFI = ()
+
+    #: Can be either string or of enum :class:`ConnectionType`.
+    connection_type: Union[str, ConnectionType] = "ANY"
+
+    identifier: str = "ANY"
+    """
+    The identifier specifies information for the connection to be used. This can
+    be an IP address, serial number, or device name. See the LabJack docs (
+    https://labjack.com/support/software/api/ljm/function-reference/ljmopens/\
+identifier-parameter) for more information.
+    """
+
+    def clean_values(self) -> None:
+        """
+        Performs value checks on device_type and connection_type.
+        """
+        if not isinstance(self.device_type, self.DeviceType):
+            self.force_value(  # type: ignore
+                "device_type", self.DeviceType(self.device_type)
+            )
+
+        if not isinstance(self.connection_type, self.ConnectionType):
+            self.force_value(  # type: ignore
+                "connection_type", self.ConnectionType(self.connection_type)
+            )
+
+
+class LJMCommunication(CommunicationProtocol):
+    """
+    Communication protocol implementing the LabJack LJM Library Python wrapper.
+    """
+
+    def __init__(self, configuration) -> None:
+        """
+        Constructor for LJMCommunication.
+        """
+        super().__init__(configuration)
+
+        # reference to the ctypes handle
+        self._handle = None
+
+    @staticmethod
+    def config_cls():
+        return LJMCommunicationConfig
+
+    def open(self) -> None:
+        """
+        Open the communication port.
+        """
+
+        logger.info("Open connection")
+
+        # open connection and store handle
+        # may throw 1227 LJME_DEVICE_NOT_FOUND if device is not found
+        try:
+            with self.access_lock:
+                self._handle = ljm.openS(
+                    self.config.device_type.type_str,
+                    str(self.config.connection_type),
+                    str(self.config.identifier),
+                )
+        except ljm.LJMError as e:
+            logger.error(str(e), exc_info=e)
+            # only catch "1229 LJME_DEVICE_ALREADY_OPEN", never observed
+            if e.errorCode != 1229:
+                raise LJMCommunicationError from e
+
+    def close(self) -> None:
+        """
+        Close the communication port.
+        """
+
+        logger.info("Closing connection")
+
+        try:
+            with self.access_lock:
+                ljm.close(self._handle)
+        except ljm.LJMError as e:
+            logger.error(str(e), exc_info=e)
+            # only catch "1224 LJME_DEVICE_NOT_OPEN", thrown on invalid handle
+            if e.errorCode != 1224:
+                raise LJMCommunicationError from e
+        self._handle = None
+
+    @property
+    def is_open(self) -> bool:
+        """
+        Flag indicating if the communication port is open.
+
+        :return: `True` if the port is open, otherwise `False`
+        """
+        # getHandleInfo does not work with LJM DEMO_MODE - consider it always opened
+        # if only set
+        if str(self._handle) == labjack.constants.DEMO_MODE:
+            return True
+
+        try:
+            ljm.getHandleInfo(self._handle)
+        except ljm.LJMError as e:
+            logger.error(str(e), exc_info=e)
+            if e.errorCode == 1224:  # "1224 LJME_DEVICE_NOT_OPEN"
+                return False
+            raise LJMCommunicationError from e
+        return True
+
+    def __del__(self) -> None:
+        """
+        Finalizer, closes port
+        """
+
+        self.close()
+
+    @staticmethod
+    def _cast_read_value(
+        name: str,
+        val: Real,
+        return_num_type: Type[Real] = float,  # type: ignore
+        # see: https://github.com/python/mypy/issues/3186
+    ) -> Real:
+        """
+        Cast a read value to a numeric type, performing some extra cast validity checks.
+
+        :param name: name of the read value, only for error reporting
+        :param val: value to cast
+        :param return_num_type: optional numeric type specification for return values;
+            by default `float`
+        :return: input value `val` casted to `return_num_type`
+        :raises TypeError: if read value of type not compatible with `return_num_type`
+        """
+        # Note: the underlying library returns already `float` (or
+        # `ctypes.c_double`?); but defensively cast again via `str`:
+        # 1) in case the underlying lib behaviour changes, and
+        # 2) to raise `TypeError` when got non integer `float` value and expecting
+        #    `int` value
+        invalid_value_type = False
+        try:
+            fval = float(str(val))
+            if issubclass(return_num_type, Integral) and not fval.is_integer():
+                invalid_value_type = True
+            else:
+                ret = return_num_type(fval)  # type: ignore
+        except ValueError as e:
+            logger.error(str(e), exc_info=e)
+            invalid_value_type = True
+        if invalid_value_type:
+            raise TypeError(
+                f"Expected {return_num_type} value for '{name}' "
+                f"name, got {type(val)} value of {val}"
+            )
+        return ret
+
+    def read_name(
+        self,
+        *names: str,
+        return_num_type: Type[Real] = float,  # type: ignore
+        # see: https://github.com/python/mypy/issues/3186
+    ) -> Union[Real, Sequence[Real]]:
+        """
+        Read one or more input numeric values by name.
+
+        :param names: one or more names to read out from the LabJack
+        :param return_num_type: optional numeric type specification for return values;
+            by default `float`.
+        :return: answer of the LabJack, either single number or multiple numbers in a
+            sequence, respectively, when one or multiple names to read were given
+        :raises TypeError: if read value of type not compatible with `return_num_type`
+        """
+
+        # Errors that can be returned here:
+        # 1224 LJME_DEVICE_NOT_OPEN if the device is not open
+        # 1239 LJME_DEVICE_RECONNECT_FAILED if the device was opened, but connection
+        #   lost
+
+        with self.access_lock:
+            try:
+                if len(names) == 1:
+                    ret = ljm.eReadName(self._handle, names[0])
+                    ret = self._cast_read_value(
+                        names[0], ret, return_num_type=return_num_type
+                    )
+                else:
+                    ret = ljm.eReadNames(self._handle, len(names), names)
+                    for (i, (iname, iret)) in enumerate(zip(names, ret)):
+                        ret[i] = self._cast_read_value(
+                            iname, iret, return_num_type=return_num_type
+                        )
+            except ljm.LJMError as e:
+                logger.error(str(e), exc_info=e)
+                raise LJMCommunicationError from e
+
+        return ret
+
+    def write_name(self, name: str, value: Real) -> None:
+        """
+        Write one value to a named output.
+
+        :param name: String or with name of LabJack IO
+        :param value: is the value to write to the named IO port
+        """
+
+        with self.access_lock:
+            try:
+                ljm.eWriteName(self._handle, name, value)
+            except ljm.LJMError as e:
+                logger.error(str(e), exc_info=e)
+                raise LJMCommunicationError from e
+
+    def write_names(self, name_value_dict: Dict[str, Real]) -> None:
+        """
+        Write more than one value at once to named outputs.
+
+        :param name_value_dict: is a dictionary with string names of LabJack IO as keys
+            and corresponding numeric values
+        """
+        names = list(name_value_dict.keys())
+        values = list(name_value_dict.values())
+        with self.access_lock:
+            try:
+                ljm.eWriteNames(self._handle, len(names), names, values)
+            except ljm.LJMError as e:
+                logger.error(str(e), exc_info=e)
+                raise LJMCommunicationError from e
+
+    # def write_address(self, address: int, value: Real) -> None:
+    #     """
+    #     **NOT IMPLEMENTED.**
+    #     Write one or more values to Modbus addresses.
+    #
+    #     :param address: One or more Modbus address on the LabJack.
+    #     :param value: One or more values to be written to the addresses.
+    #     """
+    #
+    #     raise NotImplementedError
+    #     # TODO: Implement function to write on addresses. Problem so far: I also need
+    #     #  to bring in the data types (INT32, FLOAT32...)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/modbus_tcp.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/modbus_tcp.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,165 +1,165 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol for modbus TCP ports. Makes use of the
-`pymodbus <https://pymodbus.readthedocs.io/en/latest/>`_ library.
-"""
-
-import logging
-from typing import List, Union
-
-from IPy import IP
-from pymodbus.client.sync import ModbusTcpClient
-from pymodbus.constants import Defaults as ModbusDefaults
-from pymodbus.exceptions import ConnectionException
-
-from .base import CommunicationProtocol
-from ..configuration import configdataclass
-
-logger = logging.getLogger(__name__)
-
-
-class ModbusTcpConnectionFailedException(ConnectionException):
-    """
-    Exception raised when the connection failed.
-    """
-
-    pass
-
-
-@configdataclass
-class ModbusTcpCommunicationConfig:
-    """
-    Configuration dataclass for :class:`ModbusTcpCommunication`.
-    """
-
-    #: Host is the IP address of the connected device.
-    host: str
-
-    #: Unit number to be used when connecting with Modbus/TCP. Typically this is used
-    #: when connecting to a relay having Modbus/RTU-connected devices.
-    unit: int
-
-    #: TCP port
-    port: int = ModbusDefaults.Port
-
-    def clean_values(self):
-        # host, raises ValueError on its own if not suitable
-        IP(self.host)
-
-
-class ModbusTcpCommunication(CommunicationProtocol):
-    """
-    Implements the Communication Protocol for modbus TCP.
-    """
-
-    def __init__(self, configuration):
-        """Constructor for modbus"""
-        super().__init__(configuration)
-
-        # create the modbus port specified in the configuration
-        logger.debug(
-            f"Create ModbusTcpClient with host: {self.config.host}, "
-            f"Port: {self.config.port}, Unit: {self.config.unit}"
-        )
-        self.client = ModbusTcpClient(
-            self.config.host, port=self.config.port, unit=self.config.unit
-        )
-
-    @staticmethod
-    def config_cls():
-        return ModbusTcpCommunicationConfig
-
-    def open(self) -> None:
-        """
-        Open the Modbus TCP connection.
-
-        :raises ModbusTcpConnectionFailedException: if the connection fails.
-        """
-
-        # open the port
-        logger.debug("Open Modbus TCP Port.")
-
-        with self.access_lock:
-            if not self.client.connect():
-                raise ModbusTcpConnectionFailedException
-
-    def close(self):
-        """
-        Close the Modbus TCP connection.
-        """
-
-        # close the port
-        logger.debug("Close Modbus TCP Port.")
-
-        with self.access_lock:
-            self.client.close()
-
-    def write_registers(self, address: int, values: Union[List[int], int]):
-        """
-        Write values from the specified address forward.
-
-        :param address: address of the first register
-        :param values: list with all values
-        """
-
-        logger.debug(f"Write registers {address} with values {values}")
-
-        with self.access_lock:
-            try:
-                self.client.write_registers(
-                    address=address, values=values, unit=self.config.unit
-                )
-            except ConnectionException as e:
-                logger.error(str(e), exc_info=e)
-                raise ModbusTcpConnectionFailedException from e
-
-    def read_holding_registers(self, address: int, count: int) -> List[int]:
-        """
-        Read specified number of register starting with given address and return
-        the values from each register.
-
-        :param address: address of the first register
-        :param count: count of registers to read
-        :return: list of `int` values
-        """
-
-        logger.debug(f"Read holding registers {address} with count {count}.")
-
-        with self.access_lock:
-            try:
-                registers = self.client.read_holding_registers(
-                    address=address, count=count
-                ).registers
-            except ConnectionException as e:
-                logger.error(str(e), exc_info=e)
-                raise ModbusTcpConnectionFailedException from e
-
-        logger.debug(f"Returned holding registers {address}: {registers}")
-
-        return registers
-
-    def read_input_registers(self, address: int, count: int) -> List[int]:
-        """
-        Read specified number of register starting with given address and return
-        the values from each register in a list.
-
-        :param address: address of the first register
-        :param count: count of registers to read
-        :return: list of `int` values
-        """
-
-        logger.debug(f"Read input registers {address} with count {count}.")
-
-        with self.access_lock:
-            try:
-                registers = self.client.read_input_registers(
-                    address=address, count=count
-                ).registers
-            except ConnectionException as e:
-                logger.error(str(e), exc_info=e)
-                raise ModbusTcpConnectionFailedException from e
-
-        logger.debug(f"Returned input registers {address}: {registers}")
-
-        return registers
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol for modbus TCP ports. Makes use of the
+`pymodbus <https://pymodbus.readthedocs.io/en/latest/>`_ library.
+"""
+
+import logging
+from ipaddress import IPv4Address, IPv6Address
+from typing import List, Union
+
+from pymodbus.client.sync import ModbusTcpClient
+from pymodbus.constants import Defaults as ModbusDefaults
+from pymodbus.exceptions import ConnectionException
+
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+from .base import CommunicationProtocol, CommunicationException
+from ..configuration import configdataclass
+
+logger = logging.getLogger(__name__)
+
+
+class ModbusTcpConnectionFailedException(ConnectionException, CommunicationException):
+    """
+    Exception raised when the connection failed.
+    """
+
+    pass
+
+
+@configdataclass
+class ModbusTcpCommunicationConfig:
+    """
+    Configuration dataclass for :class:`ModbusTcpCommunication`.
+    """
+    # Host is the IP address or hostname of the connected device.
+    host: Union[str, IPv4Address, IPv6Address]
+
+    # Unit number to be used when connecting with Modbus/TCP. Typically this is used
+    # when connecting to a relay having Modbus/RTU-connected devices.
+    unit: int
+
+    # TCP port
+    port: int = ModbusDefaults.Port
+
+    def clean_values(self):
+        self.force_value("host", validate_and_resolve_host(self.host, logger))
+        validate_tcp_port(self.port, logger)
+
+
+class ModbusTcpCommunication(CommunicationProtocol):
+    """
+    Implements the Communication Protocol for modbus TCP.
+    """
+
+    def __init__(self, configuration):
+        """Constructor for modbus"""
+        super().__init__(configuration)
+
+        # create the modbus port specified in the configuration
+        logger.debug(
+            f"Create ModbusTcpClient with host: {self.config.host}, "
+            f"Port: {self.config.port}, Unit: {self.config.unit}"
+        )
+        self.client = ModbusTcpClient(
+            self.config.host, port=self.config.port, unit=self.config.unit
+        )
+
+    @staticmethod
+    def config_cls():
+        return ModbusTcpCommunicationConfig
+
+    def open(self) -> None:
+        """
+        Open the Modbus TCP connection.
+
+        :raises ModbusTcpConnectionFailedException: if the connection fails.
+        """
+
+        # open the port
+        logger.debug("Open Modbus TCP Port.")
+
+        with self.access_lock:
+            if not self.client.connect():
+                raise ModbusTcpConnectionFailedException
+
+    def close(self):
+        """
+        Close the Modbus TCP connection.
+        """
+
+        # close the port
+        logger.debug("Close Modbus TCP Port.")
+
+        with self.access_lock:
+            self.client.close()
+
+    def write_registers(self, address: int, values: Union[List[int], int]):
+        """
+        Write values from the specified address forward.
+
+        :param address: address of the first register
+        :param values: list with all values
+        """
+
+        logger.debug(f"Write registers {address} with values {values}")
+
+        with self.access_lock:
+            try:
+                self.client.write_registers(
+                    address=address, values=values, unit=self.config.unit
+                )
+            except ConnectionException as e:
+                logger.error(str(e), exc_info=e)
+                raise ModbusTcpConnectionFailedException from e
+
+    def read_holding_registers(self, address: int, count: int) -> List[int]:
+        """
+        Read specified number of register starting with given address and return
+        the values from each register.
+
+        :param address: address of the first register
+        :param count: count of registers to read
+        :return: list of `int` values
+        """
+
+        logger.debug(f"Read holding registers {address} with count {count}.")
+
+        with self.access_lock:
+            try:
+                registers = self.client.read_holding_registers(
+                    address=address, count=count
+                ).registers
+            except ConnectionException as e:
+                logger.error(str(e), exc_info=e)
+                raise ModbusTcpConnectionFailedException from e
+
+        logger.debug(f"Returned holding registers {address}: {registers}")
+
+        return registers
+
+    def read_input_registers(self, address: int, count: int) -> List[int]:
+        """
+        Read specified number of register starting with given address and return
+        the values from each register in a list.
+
+        :param address: address of the first register
+        :param count: count of registers to read
+        :return: list of `int` values
+        """
+
+        logger.debug(f"Read input registers {address} with count {count}.")
+
+        with self.access_lock:
+            try:
+                registers = self.client.read_input_registers(
+                    address=address, count=count
+                ).registers
+            except ConnectionException as e:
+                logger.error(str(e), exc_info=e)
+                raise ModbusTcpConnectionFailedException from e
+
+        logger.debug(f"Returned input registers {address}: {registers}")
+
+        return registers
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/opc.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/opc.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,360 +1,364 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol implementing an OPC UA connection.
-This protocol is used to interface with the "Supercube" PLC from Siemens.
-"""
-
-import errno
-import logging
-from collections.abc import Iterable as IterableBase
-from concurrent.futures import CancelledError, TimeoutError
-from functools import wraps
-from socket import gaierror
-from time import sleep
-from typing import Iterable, Union, Optional
-
-from opcua import Client, Node, Subscription
-from opcua.ua import NodeId, DataValue, UaError
-from opcua.ua.uaerrors import BadSubscriptionIdInvalid
-
-from .base import CommunicationProtocol
-from ..configuration import configdataclass
-
-logger = logging.getLogger(__name__)
-
-
-class OpcUaSubHandler:
-    """
-    Base class for subscription handling of OPC events and data change events.
-    Override methods from this class to add own handling capabilities.
-
-    To receive events from server for a subscription
-    data_change and event methods are called directly from receiving thread.
-    Do not do expensive, slow or network operation there. Create another
-    thread if you need to do such a thing.
-    """
-
-    def datachange_notification(self, node, val, data):
-        logger.debug(f"OPCUA Datachange event: {node} to value {val}")
-
-    def event_notification(self, event):
-        logger.debug(f"OPCUA Event: {event}")
-
-
-@configdataclass
-class OpcUaCommunicationConfig:
-    """
-    Configuration dataclass for OPC UA Communciation.
-    """
-
-    #: Hostname or IP-Address of the OPC UA server.
-    host: str
-
-    #: Endpoint of the OPC server, this is a path like 'OPCUA/SimulationServer'
-    endpoint_name: str
-
-    #: Port of the OPC UA server to connect to.
-    port: int = 4840
-
-    #: object to use for handling subscriptions.
-    sub_handler: OpcUaSubHandler = OpcUaSubHandler()
-
-    #: Update period for generating datachange events in OPC UA [milli seconds]
-    update_period: int = 500
-
-    #: Wait time between re-trying calls on underlying OPC UA client timeout error
-    wait_timeout_retry_sec: Union[int, float] = 1
-
-    #: Maximal number of call re-tries on underlying OPC UA client timeout error
-    max_timeout_retry_nr: int = 5
-
-    def clean_values(self):
-        if self.update_period <= 0:
-            raise ValueError(
-                "Update period for generating datachange events (msec) needs to be "
-                "a positive integer."
-            )
-        if self.wait_timeout_retry_sec <= 0:
-            raise ValueError(
-                "Re-try wait time (sec) on timeout needs to be a positive number."
-            )
-        if self.max_timeout_retry_nr < 0:
-            raise ValueError(
-                "Maximal re-tries count on timeout needs to be non-negative integer."
-            )
-
-
-class OpcUaCommunicationIOError(IOError):
-    """OPC-UA communication I/O error."""
-
-
-class OpcUaCommunicationTimeoutError(OpcUaCommunicationIOError):
-    """OPC-UA communication timeout error."""
-
-
-#: current number of reopen tries on OPC UA connection error
-_n_timeout_retry = 0
-
-
-def _wrap_ua_error(method):
-    """
-    Wrap any `UaError` raised from a `OpcUaCommunication` method into
-    `OpcUaCommunicationIOError`; additionally, log source error.
-
-    :param method: `OpcUaCommunication` instance method to wrap
-    :return: Whatever `method` returns
-    """
-
-    @wraps(method)
-    def wrapper(self, *args, **kwargs):
-
-        try:
-
-            result = method(self, *args, **kwargs)
-
-        except UaError as e:
-            err_msg = "OPC UA client runtime error"
-            logger.error(err_msg, exc_info=e)
-            raise OpcUaCommunicationIOError(err_msg) from e
-
-        except gaierror as e:
-            err_msg = "Socket address error"
-            logger.error(err_msg, exc_info=e)
-            raise OpcUaCommunicationIOError(err_msg) from e
-
-        except OSError as e:
-
-            if e.errno == errno.EBADF:
-                err_msg = "OPC UA client socket error"
-            else:
-                err_msg = "OPC UA client OS error"
-            logger.error(err_msg, exc_info=e)
-            raise OpcUaCommunicationIOError(err_msg) from e
-
-        except CancelledError as e:
-            err_msg = "OPC UA client thread cancelled error"
-            logger.error(err_msg, exc_info=e)
-            raise OpcUaCommunicationIOError(err_msg) from e
-
-        except TimeoutError as e:
-            err_msg = "OPC UA client thread timeout error"
-            logger.error(err_msg, exc_info=e)
-            # try close, re-open and re-call
-            global _n_timeout_retry
-            _max_try_reopen = self.config.max_timeout_retry_nr
-            if _n_timeout_retry < _max_try_reopen:
-                sleep(self.config.wait_timeout_retry_sec)
-                _n_timeout_retry += 1
-
-                logger.info(
-                    f"OPC UA client retry #{_n_timeout_retry}/#{_max_try_reopen}:"
-                    f" {method}"
-                )
-
-                # note: nested re-tries use the global counter to stop on max limit
-                result = wrapper(self, *args, **kwargs)
-                # success => reset global counter
-                _n_timeout_retry = 0
-
-            else:
-                # failure => reset global counter
-                _n_timeout_retry = 0
-                # raise from original timeout error
-                raise OpcUaCommunicationTimeoutError from e
-
-        return result
-
-    return wrapper
-
-
-def _require_ua_opened(method):
-    """
-    Check if `opcua.client.ua_client.UaClient` socket is opened and raise an
-    `OpcUaCommunicationIOError` if not.
-
-    NOTE: this checks should be implemented downstream in
-    `opcua.client.ua_client.UaClient`; currently you get `AttributeError: 'NoneType'
-    object has no attribute ...`.
-
-    :param method: `OpcUaCommunication` instance method to wrap
-    :return: Whatever `method` returns
-    """
-
-    @wraps(method)
-    def wrapper(self, *args, **kwargs):
-        # BLAH: this checks should be implemented downstream in
-        # `opcua.client.ua_client.UaClient`
-        if self._client.uaclient._uasocket is None:
-            err_msg = f"Client's socket is not set in {str(self)}. Was it opened?"
-            logger.error(err_msg)
-            raise OpcUaCommunicationIOError(err_msg)
-        return method(self, *args, **kwargs)
-
-    return wrapper
-
-
-class OpcUaCommunication(CommunicationProtocol):
-    """
-    Communication protocol implementing an OPC UA connection.
-    Makes use of the package python-opcua.
-    """
-
-    def __init__(self, config) -> None:
-        """
-        Constructor for OpcUaCommunication.
-
-        :param config: is the configuration dictionary.
-        """
-
-        super().__init__(config)
-
-        conf = self.config
-        url = f"opc.tcp://{conf.host}:{conf.port}/{conf.endpoint_name}"
-
-        logger.info(f"Create OPC UA client to URL: {url}")
-
-        self._client = Client(url)
-
-        # the objects node exists on every OPC UA server and are root for all objects.
-        self._objects_node: Optional[Node] = None
-
-        # subscription handler
-        self._sub_handler = self.config.sub_handler
-
-        # subscription object
-        self._subscription: Optional[Subscription] = None
-
-    @staticmethod
-    def config_cls():
-        return OpcUaCommunicationConfig
-
-    @_wrap_ua_error
-    def open(self) -> None:
-        """
-        Open the communication to the OPC UA server.
-
-        :raises OpcUaCommunicationIOError: when communication port cannot be opened.
-        """
-
-        logger.info("Open connection to OPC server.")
-        with self.access_lock:
-            self._client.connect()
-            # in example from opcua, load_type_definitions() is called after connect(
-            # ). However, this raises ValueError when connecting to Siemens S7,
-            # and no problems are detected omitting this call.
-            # self._client.load_type_definitions()
-            self._objects_node = self._client.get_objects_node()
-            self._subscription = self._client.create_subscription(
-                self.config.update_period, self._sub_handler
-            )
-
-    @property
-    def is_open(self) -> bool:
-        """
-        Flag indicating if the communication port is open.
-
-        :return: `True` if the port is open, otherwise `False`
-        """
-        open_called = self._objects_node or self._subscription
-        if open_called:
-            try:
-                self._client.send_hello()
-                return True
-            except UaError as e:
-                logger.info(f"Sending hello returned UA error: {str(e)}")
-                # try cleanup in case connection was opened before but now is lost
-                if open_called:
-                    self.close()
-        return False
-
-    @_wrap_ua_error
-    def close(self) -> None:
-        """
-        Close the connection to the OPC UA server.
-        """
-
-        logger.info("Close connection to OPC server.")
-        with self.access_lock:
-            if self._subscription:
-                try:
-                    self._subscription.delete()
-                except BadSubscriptionIdInvalid as e:
-                    logger.error(str(e), exc_info=e)
-                self._subscription = None
-            if self._objects_node:
-                self._objects_node = None
-            self._client.disconnect()
-
-    @_require_ua_opened
-    @_wrap_ua_error
-    def read(self, node_id, ns_index):
-        """
-        Read a value from a node with id and namespace index.
-
-        :param node_id: the ID of the node to read the value from
-        :param ns_index: the namespace index of the node
-        :return: the value of the node object.
-        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
-            communicate with a OPC UA server
-        """
-
-        with self.access_lock:
-            return self._client.get_node(
-                NodeId(identifier=node_id, namespaceidx=ns_index)
-            ).get_value()
-
-    @_require_ua_opened
-    @_wrap_ua_error
-    def write(self, node_id, ns_index, value) -> None:
-        """
-        Write a value to a node with name ``name``.
-
-        :param node_id: the id of the node to write the value to.
-        :param ns_index: the namespace index of the node.
-        :param value: the value to write.
-        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
-            communicate with a OPC UA server
-        """
-
-        with self.access_lock:
-            self._client.get_node(
-                NodeId(identifier=node_id, namespaceidx=ns_index)
-            ).set_value(DataValue(value))
-
-    @_require_ua_opened
-    @_wrap_ua_error
-    def init_monitored_nodes(
-        self, node_id: Union[object, Iterable], ns_index: int
-    ) -> None:
-        """
-        Initialize monitored nodes.
-
-        :param node_id: one or more strings of node IDs; node IDs are always casted
-            via `str()` method here, hence do not have to be strictly string objects.
-        :param ns_index: the namespace index the nodes belong to.
-        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
-            communicate with a OPC UA server
-        """
-
-        if not self._subscription:
-            err_msg = f"Missing subscription in {str(self)}. Was it opened?"
-            logger.error(err_msg)
-            raise OpcUaCommunicationIOError(err_msg)
-
-        ids: Iterable[object] = (
-            node_id
-            if not isinstance(node_id, str) and isinstance(node_id, IterableBase)
-            else (node_id,)
-        )
-
-        nodes = []
-        for id_ in ids:
-            nodes.append(
-                self._client.get_node(
-                    NodeId(identifier=str(id_), namespaceidx=ns_index)
-                )
-            )
-
-        with self.access_lock:
-            self._subscription.subscribe_data_change(nodes)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol implementing an OPC UA connection.
+This protocol is used to interface with the "Supercube" PLC from Siemens.
+"""
+
+import errno
+import logging
+from collections.abc import Iterable as IterableBase
+from concurrent.futures import CancelledError, TimeoutError
+from functools import wraps
+from ipaddress import IPv4Address, IPv6Address
+from socket import gaierror
+from time import sleep
+from typing import Iterable, Union, Optional
+
+from opcua import Client, Node, Subscription
+from opcua.ua import NodeId, DataValue, UaError
+from opcua.ua.uaerrors import BadSubscriptionIdInvalid
+
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+from .base import CommunicationProtocol, CommunicationException
+from ..configuration import configdataclass
+
+logger = logging.getLogger(__name__)
+
+
+class OpcUaSubHandler:
+    """
+    Base class for subscription handling of OPC events and data change events.
+    Override methods from this class to add own handling capabilities.
+
+    To receive events from server for a subscription
+    data_change and event methods are called directly from receiving thread.
+    Do not do expensive, slow or network operation there. Create another
+    thread if you need to do such a thing.
+    """
+
+    def datachange_notification(self, node, val, data):
+        logger.debug(f"OPCUA Datachange event: {node} to value {val}")
+
+    def event_notification(self, event):
+        logger.debug(f"OPCUA Event: {event}")
+
+
+@configdataclass
+class OpcUaCommunicationConfig:
+    """
+    Configuration dataclass for OPC UA Communciation.
+    """
+
+    #: Hostname or IP-Address of the OPC UA server.
+    host: Union[str, IPv4Address, IPv6Address]
+
+    #: Endpoint of the OPC server, this is a path like 'OPCUA/SimulationServer'
+    endpoint_name: str
+
+    #: Port of the OPC UA server to connect to.
+    port: int = 4840
+
+    #: object to use for handling subscriptions.
+    sub_handler: OpcUaSubHandler = OpcUaSubHandler()
+
+    #: Update period for generating datachange events in OPC UA [milli seconds]
+    update_period: int = 500
+
+    #: Wait time between re-trying calls on underlying OPC UA client timeout error
+    wait_timeout_retry_sec: Union[int, float] = 1
+
+    #: Maximal number of call re-tries on underlying OPC UA client timeout error
+    max_timeout_retry_nr: int = 5
+
+    def clean_values(self):
+        if self.update_period <= 0:
+            raise ValueError(
+                "Update period for generating datachange events (msec) needs to be "
+                "a positive integer."
+            )
+        if self.wait_timeout_retry_sec <= 0:
+            raise ValueError(
+                "Re-try wait time (sec) on timeout needs to be a positive number."
+            )
+        if self.max_timeout_retry_nr < 0:
+            raise ValueError(
+                "Maximal re-tries count on timeout needs to be non-negative integer."
+            )
+        self.force_value("host", validate_and_resolve_host(self.host, logger))
+        validate_tcp_port(self.port, logger)
+
+
+class OpcUaCommunicationIOError(IOError, CommunicationException):
+    """OPC-UA communication I/O error."""
+
+
+class OpcUaCommunicationTimeoutError(OpcUaCommunicationIOError):
+    """OPC-UA communication timeout error."""
+
+
+#: current number of reopen tries on OPC UA connection error
+_n_timeout_retry = 0
+
+
+def _wrap_ua_error(method):
+    """
+    Wrap any `UaError` raised from a `OpcUaCommunication` method into
+    `OpcUaCommunicationIOError`; additionally, log source error.
+
+    :param method: `OpcUaCommunication` instance method to wrap
+    :return: Whatever `method` returns
+    """
+
+    @wraps(method)
+    def wrapper(self, *args, **kwargs):
+
+        try:
+
+            result = method(self, *args, **kwargs)
+
+        except UaError as e:
+            err_msg = "OPC UA client runtime error"
+            logger.error(err_msg, exc_info=e)
+            raise OpcUaCommunicationIOError(err_msg) from e
+
+        except gaierror as e:
+            err_msg = "Socket address error"
+            logger.error(err_msg, exc_info=e)
+            raise OpcUaCommunicationIOError(err_msg) from e
+
+        except OSError as e:
+
+            if e.errno == errno.EBADF:
+                err_msg = "OPC UA client socket error"
+            else:
+                err_msg = "OPC UA client OS error"
+            logger.error(err_msg, exc_info=e)
+            raise OpcUaCommunicationIOError(err_msg) from e
+
+        except CancelledError as e:
+            err_msg = "OPC UA client thread cancelled error"
+            logger.error(err_msg, exc_info=e)
+            raise OpcUaCommunicationIOError(err_msg) from e
+
+        except TimeoutError as e:
+            err_msg = "OPC UA client thread timeout error"
+            logger.error(err_msg, exc_info=e)
+            # try close, re-open and re-call
+            global _n_timeout_retry
+            _max_try_reopen = self.config.max_timeout_retry_nr
+            if _n_timeout_retry < _max_try_reopen:
+                sleep(self.config.wait_timeout_retry_sec)
+                _n_timeout_retry += 1
+
+                logger.info(
+                    f"OPC UA client retry #{_n_timeout_retry}/#{_max_try_reopen}:"
+                    f" {method}"
+                )
+
+                # note: nested re-tries use the global counter to stop on max limit
+                result = wrapper(self, *args, **kwargs)
+                # success => reset global counter
+                _n_timeout_retry = 0
+
+            else:
+                # failure => reset global counter
+                _n_timeout_retry = 0
+                # raise from original timeout error
+                raise OpcUaCommunicationTimeoutError from e
+
+        return result
+
+    return wrapper
+
+
+def _require_ua_opened(method):
+    """
+    Check if `opcua.client.ua_client.UaClient` socket is opened and raise an
+    `OpcUaCommunicationIOError` if not.
+
+    NOTE: this checks should be implemented downstream in
+    `opcua.client.ua_client.UaClient`; currently you get `AttributeError: 'NoneType'
+    object has no attribute ...`.
+
+    :param method: `OpcUaCommunication` instance method to wrap
+    :return: Whatever `method` returns
+    """
+
+    @wraps(method)
+    def wrapper(self, *args, **kwargs):
+        # BLAH: this checks should be implemented downstream in
+        # `opcua.client.ua_client.UaClient`
+        if self._client.uaclient._uasocket is None:
+            err_msg = f"Client's socket is not set in {str(self)}. Was it opened?"
+            logger.error(err_msg)
+            raise OpcUaCommunicationIOError(err_msg)
+        return method(self, *args, **kwargs)
+
+    return wrapper
+
+
+class OpcUaCommunication(CommunicationProtocol):
+    """
+    Communication protocol implementing an OPC UA connection.
+    Makes use of the package python-opcua.
+    """
+
+    def __init__(self, config) -> None:
+        """
+        Constructor for OpcUaCommunication.
+
+        :param config: is the configuration dictionary.
+        """
+
+        super().__init__(config)
+
+        conf = self.config
+        url = f"opc.tcp://{conf.host}:{conf.port}/{conf.endpoint_name}"
+
+        logger.info(f"Create OPC UA client to URL: {url}")
+
+        self._client = Client(url)
+
+        # the objects node exists on every OPC UA server and are root for all objects.
+        self._objects_node: Optional[Node] = None
+
+        # subscription handler
+        self._sub_handler = self.config.sub_handler
+
+        # subscription object
+        self._subscription: Optional[Subscription] = None
+
+    @staticmethod
+    def config_cls():
+        return OpcUaCommunicationConfig
+
+    @_wrap_ua_error
+    def open(self) -> None:
+        """
+        Open the communication to the OPC UA server.
+
+        :raises OpcUaCommunicationIOError: when communication port cannot be opened.
+        """
+
+        logger.info("Open connection to OPC server.")
+        with self.access_lock:
+            self._client.connect()
+            # in example from opcua, load_type_definitions() is called after connect(
+            # ). However, this raises ValueError when connecting to Siemens S7,
+            # and no problems are detected omitting this call.
+            # self._client.load_type_definitions()
+            self._objects_node = self._client.get_objects_node()
+            self._subscription = self._client.create_subscription(
+                self.config.update_period, self._sub_handler
+            )
+
+    @property
+    def is_open(self) -> bool:
+        """
+        Flag indicating if the communication port is open.
+
+        :return: `True` if the port is open, otherwise `False`
+        """
+        open_called = self._objects_node or self._subscription
+        if open_called:
+            try:
+                self._client.send_hello()
+                return True
+            except UaError as e:
+                logger.info(f"Sending hello returned UA error: {str(e)}")
+                # try cleanup in case connection was opened before but now is lost
+                if open_called:
+                    self.close()
+        return False
+
+    @_wrap_ua_error
+    def close(self) -> None:
+        """
+        Close the connection to the OPC UA server.
+        """
+
+        logger.info("Close connection to OPC server.")
+        with self.access_lock:
+            if self._subscription:
+                try:
+                    self._subscription.delete()
+                except BadSubscriptionIdInvalid as e:
+                    logger.error(str(e), exc_info=e)
+                self._subscription = None
+            if self._objects_node:
+                self._objects_node = None
+            self._client.disconnect()
+
+    @_require_ua_opened
+    @_wrap_ua_error
+    def read(self, node_id, ns_index):
+        """
+        Read a value from a node with id and namespace index.
+
+        :param node_id: the ID of the node to read the value from
+        :param ns_index: the namespace index of the node
+        :return: the value of the node object.
+        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
+            communicate with a OPC UA server
+        """
+
+        with self.access_lock:
+            return self._client.get_node(
+                NodeId(identifier=node_id, namespaceidx=ns_index)
+            ).get_value()
+
+    @_require_ua_opened
+    @_wrap_ua_error
+    def write(self, node_id, ns_index, value) -> None:
+        """
+        Write a value to a node with name ``name``.
+
+        :param node_id: the id of the node to write the value to.
+        :param ns_index: the namespace index of the node.
+        :param value: the value to write.
+        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
+            communicate with a OPC UA server
+        """
+
+        with self.access_lock:
+            self._client.get_node(
+                NodeId(identifier=node_id, namespaceidx=ns_index)
+            ).set_value(DataValue(value))
+
+    @_require_ua_opened
+    @_wrap_ua_error
+    def init_monitored_nodes(
+        self, node_id: Union[object, Iterable], ns_index: int
+    ) -> None:
+        """
+        Initialize monitored nodes.
+
+        :param node_id: one or more strings of node IDs; node IDs are always casted
+            via `str()` method here, hence do not have to be strictly string objects.
+        :param ns_index: the namespace index the nodes belong to.
+        :raises OpcUaCommunicationIOError: when protocol was not opened or can't
+            communicate with a OPC UA server
+        """
+
+        if not self._subscription:
+            err_msg = f"Missing subscription in {str(self)}. Was it opened?"
+            logger.error(err_msg)
+            raise OpcUaCommunicationIOError(err_msg)
+
+        ids: Iterable[object] = (
+            node_id
+            if not isinstance(node_id, str) and isinstance(node_id, IterableBase)
+            else (node_id,)
+        )
+
+        nodes = []
+        for id_ in ids:
+            nodes.append(
+                self._client.get_node(
+                    NodeId(identifier=str(id_), namespaceidx=ns_index)
+                )
+            )
+
+        with self.access_lock:
+            self._subscription.subscribe_data_change(nodes)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/serial.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/serial.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,243 +1,244 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol for serial ports. Makes use of the `pySerial
-<https://pythonhosted.org/pyserial/index.html>`_ library.
-"""
-
-import logging
-import warnings
-from typing import Optional, Union, cast
-
-# Note: PyCharm does not recognize the dependency correctly, it is added as pyserial.
-import serial
-
-from .base import (
-    AsyncCommunicationProtocolConfig,
-    AsyncCommunicationProtocol,
-)
-from ..configuration import configdataclass, ConfigurationValueWarning
-from ..utils.enum import ValueEnum, unique
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class SerialCommunicationIOError(IOError):
-    """Serial communication related I/O errors."""
-
-
-@unique
-class SerialCommunicationParity(ValueEnum):
-    """
-    Serial communication parity.
-    """
-
-    EVEN = serial.PARITY_EVEN
-    MARK = serial.PARITY_MARK
-    NAMES = serial.PARITY_NAMES
-    NONE = serial.PARITY_NONE
-    ODD = serial.PARITY_ODD
-    SPACE = serial.PARITY_SPACE
-
-
-@unique
-class SerialCommunicationStopbits(ValueEnum):
-    """
-    Serial communication stopbits.
-    """
-
-    ONE = serial.STOPBITS_ONE
-    ONE_POINT_FIVE = serial.STOPBITS_ONE_POINT_FIVE
-    TWO = serial.STOPBITS_TWO
-
-
-@unique
-class SerialCommunicationBytesize(ValueEnum):
-    """
-    Serial communication bytesize.
-    """
-
-    FIVEBITS = serial.FIVEBITS
-    SIXBITS = serial.SIXBITS
-    SEVENBITS = serial.SEVENBITS
-    EIGHTBITS = serial.EIGHTBITS
-
-
-@configdataclass
-class SerialCommunicationConfig(AsyncCommunicationProtocolConfig):
-    """
-    Configuration dataclass for :class:`SerialCommunication`.
-    """
-
-    Parity = SerialCommunicationParity
-    Stopbits = SerialCommunicationStopbits
-    Bytesize = SerialCommunicationBytesize
-
-    #: Port is a string referring to a COM-port (e.g. ``'COM3'``) or a URL.
-    #: The full list of capabilities is found `on the pyserial documentation
-    #: <https://pythonhosted.org/pyserial/url_handlers.html>`_.
-    port: Optional[str] = None
-
-    #: Baudrate of the serial port
-    baudrate: int = 9600
-
-    #: Parity to be used for the connection.
-    parity: Union[str, SerialCommunicationParity] = Parity.NONE
-
-    #: Stopbits setting, can be 1, 1.5 or 2.
-    stopbits: Union[Number, SerialCommunicationStopbits] = Stopbits.ONE
-
-    #: Size of a byte, 5 to 8
-    bytesize: Union[int, SerialCommunicationBytesize] = Bytesize.EIGHTBITS
-
-    #: Timeout in seconds for the serial port
-    timeout: Number = 2
-
-    def clean_values(self):
-
-        super().clean_values()
-
-        if not isinstance(self.parity, SerialCommunicationParity):
-            self.force_value("parity", SerialCommunicationParity(self.parity))
-
-        if not isinstance(self.stopbits, SerialCommunicationStopbits):
-            self.force_value("stopbits", SerialCommunicationStopbits(self.stopbits))
-
-        if not isinstance(self.bytesize, SerialCommunicationBytesize):
-            self.force_value("bytesize", SerialCommunicationBytesize(self.bytesize))
-
-        if self.timeout < 0:
-            raise ValueError("Timeout has to be >= 0.")
-        if self.timeout < 1:  # min. viable threshold as tested w/ Arduino Nano board
-            warnings.warn(
-                "Setting a too low timeout for a serial connection communication may "
-                "lead to random errors during a communication with a device.",
-                category=ConfigurationValueWarning,
-            )
-
-    def create_serial_port(self) -> serial.Serial:
-        """
-        Create a serial port instance according to specification in this configuration
-
-        :return: Closed serial port instance
-        """
-
-        ser = serial.serial_for_url(self.port, do_not_open=True)
-        assert not ser.is_open
-
-        ser.baudrate = self.baudrate
-        ser.parity = cast(SerialCommunicationParity, self.parity).value
-        ser.stopbits = cast(SerialCommunicationStopbits, self.stopbits).value
-        ser.bytesize = cast(SerialCommunicationBytesize, self.bytesize).value
-        ser.timeout = self.timeout
-
-        return ser
-
-    def terminator_str(self) -> str:
-        return self.terminator.decode()
-
-
-class SerialCommunication(AsyncCommunicationProtocol):
-    """
-    Implements the Communication Protocol for serial ports.
-    """
-
-    def __init__(self, configuration):
-        """
-        Constructor for SerialCommunication.
-        """
-
-        super().__init__(configuration)
-
-        self._serial_port = self.config.create_serial_port()
-
-    @staticmethod
-    def config_cls():
-        return SerialCommunicationConfig
-
-    def open(self):
-        """
-        Open the serial connection.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened.
-        """
-
-        # open the port
-        with self.access_lock:
-            try:
-                self._serial_port.open()
-            except serial.SerialException as exc:
-                # ignore when port is already open
-                logger.error(str(exc), exc_info=exc)
-                if str(exc) != "Port is already open.":
-                    raise SerialCommunicationIOError from exc
-
-    def close(self):
-        """
-        Close the serial connection.
-        """
-
-        # close the port
-        with self.access_lock:
-            self._serial_port.close()
-
-    @property
-    def is_open(self) -> bool:
-        """
-        Flag indicating if the serial port is open.
-
-        :return: `True` if the serial port is open, otherwise `False`
-        """
-        return self._serial_port.is_open
-
-    def read_bytes(self) -> bytes:
-        """
-        Read the bytes from the serial port till the terminator is found.
-        The input buffer may hold additional lines afterwards.
-
-        This method uses `self.access_lock` to ensure thread-safety.
-
-        :return: Bytes read from the serial port; `b''` if there was nothing to read.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        with self.access_lock:
-            try:
-                return self._serial_port.read_until(self.config.terminator)
-            except serial.SerialException as exc:
-                logger.error(str(exc), exc_info=exc)
-                raise SerialCommunicationIOError from exc
-
-    def write_bytes(self, data: bytes) -> int:
-        """
-        Write bytes to the serial port.
-
-        This method uses `self.access_lock` to ensure thread-safety.
-
-        :param data: data to write to the serial port
-        :return: number of bytes written
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        with self.access_lock:
-            try:
-                return self._serial_port.write(data)
-            except serial.SerialException as exc:
-                logger.error(str(exc), exc_info=exc)
-                raise SerialCommunicationIOError from exc
-
-    def read_single_bytes(self, size: int = 1) -> bytes:
-        """
-        Read the specified number of bytes from the serial port.
-        The input buffer may hold additional data afterwards.
-
-        :return: Bytes read from the serial port; `b''` if there was nothing to read.
-        """
-
-        with self.access_lock:
-            try:
-                return self._serial_port.read(size)
-            except serial.SerialException as exc:
-                logger.error(str(exc), exc_info=exc)
-                raise SerialCommunicationIOError from exc
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol for serial ports. Makes use of the `pySerial
+<https://pythonhosted.org/pyserial/index.html>`_ library.
+"""
+
+import logging
+import warnings
+from typing import Optional, Union, cast
+
+# Note: PyCharm does not recognize the dependency correctly, it is added as pyserial.
+import serial
+
+from .base import (
+    AsyncCommunicationProtocolConfig,
+    AsyncCommunicationProtocol,
+    CommunicationException,
+)
+from ..configuration import configdataclass, ConfigurationValueWarning
+from ..utils.enum import ValueEnum, unique
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class SerialCommunicationIOError(IOError, CommunicationException):
+    """Serial communication related I/O errors."""
+
+
+@unique
+class SerialCommunicationParity(ValueEnum):
+    """
+    Serial communication parity.
+    """
+
+    EVEN = serial.PARITY_EVEN
+    MARK = serial.PARITY_MARK
+    NAMES = serial.PARITY_NAMES
+    NONE = serial.PARITY_NONE
+    ODD = serial.PARITY_ODD
+    SPACE = serial.PARITY_SPACE
+
+
+@unique
+class SerialCommunicationStopbits(ValueEnum):
+    """
+    Serial communication stopbits.
+    """
+
+    ONE = serial.STOPBITS_ONE
+    ONE_POINT_FIVE = serial.STOPBITS_ONE_POINT_FIVE
+    TWO = serial.STOPBITS_TWO
+
+
+@unique
+class SerialCommunicationBytesize(ValueEnum):
+    """
+    Serial communication bytesize.
+    """
+
+    FIVEBITS = serial.FIVEBITS
+    SIXBITS = serial.SIXBITS
+    SEVENBITS = serial.SEVENBITS
+    EIGHTBITS = serial.EIGHTBITS
+
+
+@configdataclass
+class SerialCommunicationConfig(AsyncCommunicationProtocolConfig):
+    """
+    Configuration dataclass for :class:`SerialCommunication`.
+    """
+
+    Parity = SerialCommunicationParity
+    Stopbits = SerialCommunicationStopbits
+    Bytesize = SerialCommunicationBytesize
+
+    #: Port is a string referring to a COM-port (e.g. ``'COM3'``) or a URL.
+    #: The full list of capabilities is found `on the pyserial documentation
+    #: <https://pythonhosted.org/pyserial/url_handlers.html>`_.
+    port: Optional[str] = None
+
+    #: Baudrate of the serial port
+    baudrate: int = 9600
+
+    #: Parity to be used for the connection.
+    parity: Union[str, SerialCommunicationParity] = Parity.NONE
+
+    #: Stopbits setting, can be 1, 1.5 or 2.
+    stopbits: Union[Number, SerialCommunicationStopbits] = Stopbits.ONE
+
+    #: Size of a byte, 5 to 8
+    bytesize: Union[int, SerialCommunicationBytesize] = Bytesize.EIGHTBITS
+
+    #: Timeout in seconds for the serial port
+    timeout: Number = 2
+
+    def clean_values(self):
+
+        super().clean_values()
+
+        if not isinstance(self.parity, SerialCommunicationParity):
+            self.force_value("parity", SerialCommunicationParity(self.parity))
+
+        if not isinstance(self.stopbits, SerialCommunicationStopbits):
+            self.force_value("stopbits", SerialCommunicationStopbits(self.stopbits))
+
+        if not isinstance(self.bytesize, SerialCommunicationBytesize):
+            self.force_value("bytesize", SerialCommunicationBytesize(self.bytesize))
+
+        if self.timeout < 0:
+            raise ValueError("Timeout has to be >= 0.")
+        if self.timeout < 1:  # min. viable threshold as tested w/ Arduino Nano board
+            warnings.warn(
+                "Setting a too low timeout for a serial connection communication may "
+                "lead to random errors during a communication with a device.",
+                category=ConfigurationValueWarning,
+            )
+
+    def create_serial_port(self) -> serial.Serial:
+        """
+        Create a serial port instance according to specification in this configuration
+
+        :return: Closed serial port instance
+        """
+
+        ser = serial.serial_for_url(self.port, do_not_open=True)
+        assert not ser.is_open
+
+        ser.baudrate = self.baudrate
+        ser.parity = cast(SerialCommunicationParity, self.parity).value
+        ser.stopbits = cast(SerialCommunicationStopbits, self.stopbits).value
+        ser.bytesize = cast(SerialCommunicationBytesize, self.bytesize).value
+        ser.timeout = self.timeout
+
+        return ser
+
+    def terminator_str(self) -> str:
+        return self.terminator.decode()
+
+
+class SerialCommunication(AsyncCommunicationProtocol):
+    """
+    Implements the Communication Protocol for serial ports.
+    """
+
+    def __init__(self, configuration):
+        """
+        Constructor for SerialCommunication.
+        """
+
+        super().__init__(configuration)
+
+        self._serial_port = self.config.create_serial_port()
+
+    @staticmethod
+    def config_cls():
+        return SerialCommunicationConfig
+
+    def open(self):
+        """
+        Open the serial connection.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened.
+        """
+
+        # open the port
+        with self.access_lock:
+            try:
+                self._serial_port.open()
+            except serial.SerialException as exc:
+                # ignore when port is already open
+                logger.error(str(exc), exc_info=exc)
+                if str(exc) != "Port is already open.":
+                    raise SerialCommunicationIOError from exc
+
+    def close(self):
+        """
+        Close the serial connection.
+        """
+
+        # close the port
+        with self.access_lock:
+            self._serial_port.close()
+
+    @property
+    def is_open(self) -> bool:
+        """
+        Flag indicating if the serial port is open.
+
+        :return: `True` if the serial port is open, otherwise `False`
+        """
+        return self._serial_port.is_open
+
+    def read_bytes(self) -> bytes:
+        """
+        Read the bytes from the serial port till the terminator is found.
+        The input buffer may hold additional lines afterwards.
+
+        This method uses `self.access_lock` to ensure thread-safety.
+
+        :return: Bytes read from the serial port; `b''` if there was nothing to read.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        with self.access_lock:
+            try:
+                return self._serial_port.read_until(self.config.terminator)
+            except serial.SerialException as exc:
+                logger.error(str(exc), exc_info=exc)
+                raise SerialCommunicationIOError from exc
+
+    def write_bytes(self, data: bytes) -> int:
+        """
+        Write bytes to the serial port.
+
+        This method uses `self.access_lock` to ensure thread-safety.
+
+        :param data: data to write to the serial port
+        :return: number of bytes written
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        with self.access_lock:
+            try:
+                return self._serial_port.write(data)
+            except serial.SerialException as exc:
+                logger.error(str(exc), exc_info=exc)
+                raise SerialCommunicationIOError from exc
+
+    def read_single_bytes(self, size: int = 1) -> bytes:
+        """
+        Read the specified number of bytes from the serial port.
+        The input buffer may hold additional data afterwards.
+
+        :return: Bytes read from the serial port; `b''` if there was nothing to read.
+        """
+
+        with self.access_lock:
+            try:
+                return self._serial_port.read(size)
+            except serial.SerialException as exc:
+                logger.error(str(exc), exc_info=exc)
+                raise SerialCommunicationIOError from exc
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/tcp.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/tcp.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,108 +1,107 @@
-#  Copyright (c) 2019-2020 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-TCP communication protocol. Makes use of the socket library.
-"""
-
-import logging
-import socket
-from typing import Type
-
-from IPy import IP
-
-from .base import CommunicationProtocol
-from ..configuration import configdataclass
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class TcpCommunicationConfig:
-    """
-    Configuration dataclass for :class:`TcpCommunication`.
-    """
-
-    # Host is the IP address of the connected device.
-    host: str
-    # TCP port
-    port: int = 54321
-    # TCP receiving buffersize
-    bufsize: int = 1024
-
-    def clean_values(self) -> None:
-        # if necessary, converts host to a valid IP address
-        IP(self.host)
-        if self.port < 1:
-            raise ValueError("Port number has to be >= 1")
-        if self.bufsize < 1:
-            raise ValueError("Buffer size has to be >= 1")
-
-
-class Tcp(CommunicationProtocol):
-    """
-    Tcp Communication Protocol.
-    """
-
-    def __init__(self, configuration):
-        """Constructor socket"""
-        super().__init__(configuration)
-
-        # create the communication port specified in the configuration
-        logger.debug(
-            'Create socket TcpClient with host: "{}", Port: "{}"'.format(
-                self.config.host,
-                self.config.port,
-            )
-        )
-        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-
-    @staticmethod
-    def config_cls() -> Type[TcpCommunicationConfig]:
-        return TcpCommunicationConfig
-
-    def write(self, command: str = "") -> None:
-        """
-        TCP write function
-        :param command: command string to be sent
-        :return: none
-        """
-        self.sock.send(bytes(command, "ascii"))
-        logger.debug(
-            "Sent {command}".format(
-                command=command,
-            )
-        )
-
-    def read(self) -> str:
-        """
-        TCP read function
-        :return: information read from TCP buffer formatted as string
-        """
-        reply = self.sock.recv(self.config.bufsize)
-        reply = reply.decode("ascii")
-        logger.debug(
-            "Received via TCP: {reply}".format(
-                reply=reply,
-            )
-        )
-        return reply
-
-    def open(self) -> None:
-        """
-        Open TCP connection.
-        """
-
-        # open the port
-        logger.debug("Open TCP Port.")
-
-        self.sock.connect((self.config.host, self.config.port))
-
-    def close(self) -> None:
-        """
-        Close TCP connection.
-        """
-
-        # close the port
-        logger.debug("Close TCP Port.")
-
-        self.sock.close()
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+TCP communication protocol. Makes use of the socket library.
+"""
+
+import logging
+import socket
+from ipaddress import IPv4Address, IPv6Address
+from typing import Type, Union
+
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+from .base import CommunicationProtocol
+from ..configuration import configdataclass
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class TcpCommunicationConfig:
+    """
+    Configuration dataclass for :class:`TcpCommunication`.
+    """
+
+    # Host is the IP address of the connected device.
+    host: Union[str, IPv4Address, IPv6Address]
+    # TCP port
+    port: int = 54321
+    # TCP receiving buffersize
+    bufsize: int = 1024
+
+    def clean_values(self):
+        # if necessary, converts host to a valid IP address
+        self.force_value("host", validate_and_resolve_host(self.host, logger))
+        validate_tcp_port(self.port, logger)
+        if self.bufsize < 1:
+            raise ValueError("Buffer size has to be >= 1")
+
+
+class Tcp(CommunicationProtocol):
+    """
+    Tcp Communication Protocol.
+    """
+
+    def __init__(self, configuration):
+        """Constructor socket"""
+        super().__init__(configuration)
+
+        # create the communication port specified in the configuration
+        logger.debug(
+            'Create socket TcpClient with host: "{}", Port: "{}"'.format(
+                self.config.host,
+                self.config.port,
+            )
+        )
+        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+
+    @staticmethod
+    def config_cls() -> Type[TcpCommunicationConfig]:
+        return TcpCommunicationConfig
+
+    def write(self, command: str = "") -> None:
+        """
+        TCP write function
+        :param command: command string to be sent
+        :return: none
+        """
+        self.sock.send(bytes(command, "ascii"))
+        logger.debug(
+            "Sent {command}".format(
+                command=command,
+            )
+        )
+
+    def read(self) -> str:
+        """
+        TCP read function
+        :return: information read from TCP buffer formatted as string
+        """
+        reply = self.sock.recv(self.config.bufsize)
+        reply = reply.decode("ascii")
+        logger.debug(
+            "Received via TCP: {reply}".format(
+                reply=reply,
+            )
+        )
+        return reply
+
+    def open(self) -> None:
+        """
+        Open TCP connection.
+        """
+
+        # open the port
+        logger.debug("Open TCP Port.")
+
+        self.sock.connect((self.config.host, self.config.port))
+
+    def close(self) -> None:
+        """
+        Close TCP connection.
+        """
+
+        # close the port
+        logger.debug("Close TCP Port.")
+
+        self.sock.close()
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/telnet.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/telnet.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,143 +1,155 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol for telnet. Makes use of the `telnetlib
-<https://docs.python.org/3/library/telnetlib.html>`_ library.
-"""
-
-import telnetlib
-from typing import Optional
-
-from .base import AsyncCommunicationProtocolConfig, AsyncCommunicationProtocol
-from ..configuration import configdataclass
-from ..utils.typing import Number
-
-
-class TelnetError(Exception):
-    """Telnet communication related errors."""
-
-
-@configdataclass
-class TelnetCommunicationConfig(AsyncCommunicationProtocolConfig):
-    """
-    Configuration dataclass for :class:`TelnetCommunication`.
-    """
-
-    #: Host to connect to
-    #: can be ``localhost`` or
-    host: Optional[str] = None
-
-    #: Port at which the host is listening
-    port: int = 0
-
-    #: Timeout for reading a line
-    timeout: Number = 0.2
-
-    def clean_values(self):
-        if self.timeout < 0:
-            raise ValueError("Timeout has to be >= 0.")
-
-    def create_telnet(self) -> Optional[telnetlib.Telnet]:
-        """
-        Create a telnet client
-        :return: Opened Telnet object or None if connection is not possible
-        """
-        if self.host is None:
-            return None
-
-        try:
-            tn = telnetlib.Telnet(host=self.host, port=self.port)
-        except (ConnectionRefusedError, TimeoutError, OSError) as exc:
-            raise TelnetError from exc
-        else:
-            return tn
-
-
-class TelnetCommunication(AsyncCommunicationProtocol):
-    """
-    Implements the Communication Protocol for telnet.
-    """
-
-    def __init__(self, configuration):
-        """
-        Constructor for TelnetCommunication.
-        """
-
-        super().__init__(configuration)
-
-        self._tn: Optional[telnetlib.Telnet] = self.config.create_telnet()
-
-    @property
-    def is_open(self) -> bool:
-        """
-        Is the connection open?
-
-        :return: True for an open connection
-        """
-        return (
-            self._tn is not None
-            and self._tn.sock is not None  # type: ignore
-        )
-
-    def open(self):
-        """
-        Open the telnet connection unless it is not yet opened.
-        """
-        if self.is_open:
-            return
-
-        with self.access_lock:
-            try:
-                self._tn.open(self._tn.host, self._tn.port)
-            except (ConnectionRefusedError, TimeoutError, OSError) as exc:
-                raise TelnetError from exc
-
-    def close(self):
-        """
-        Close the telnet connection unless it is not closed.
-        """
-        if not self.is_open:
-            return
-
-        with self.access_lock:
-            self._tn.close()
-
-    @staticmethod
-    def config_cls():
-        return TelnetCommunicationConfig
-
-    def write_bytes(self, data: bytes):
-        """
-        Write the data as `bytes` to the telnet connection.
-
-        :param data: Data to be sent.
-        :raises TelnetError: when connection is not open, raises an Error during the
-            communication
-        """
-
-        if not self.is_open:
-            raise TelnetError("The Telnet connection is not open.")
-
-        assert self._tn is not None  # makes mypy happy
-        with self.access_lock:
-            self._tn.write(data)
-
-    def read_bytes(self) -> bytes:
-        """
-        Read data as `bytes` from the telnet connection.
-
-        :return: data from telnet connection
-        :raises TelnetError: when connection is not open, raises an Error during the
-            communication
-        """
-
-        if not self.is_open:
-            raise TelnetError("The Telnet connection is not open.")
-
-        assert self._tn is not None  # makes mypy happy
-        try:
-            return self._tn.read_until(
-                match=self.config.terminator, timeout=self.config.timeout
-            ).strip()
-        except EOFError:
-            return b""
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol for telnet. Makes use of the `telnetlib
+<https://docs.python.org/3/library/telnetlib.html>`_ library.
+"""
+
+import logging
+import telnetlib
+from ipaddress import IPv4Address, IPv6Address
+from typing import Optional, Union, cast
+
+from hvl_ccb.utils.typing import Number
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+from .base import (
+    AsyncCommunicationProtocolConfig,
+    AsyncCommunicationProtocol,
+    CommunicationException,
+)
+from ..configuration import configdataclass
+
+logger = logging.getLogger(__name__)
+
+
+class TelnetError(IOError, CommunicationException):
+    """Telnet communication related errors."""
+
+
+@configdataclass
+class TelnetCommunicationConfig(AsyncCommunicationProtocolConfig):
+    """
+    Configuration dataclass for :class:`TelnetCommunication`.
+    """
+
+    #: Host to connect to
+    #: can be ``localhost`` or
+    host: Optional[Union[str, IPv4Address, IPv6Address]] = None
+
+    #: Port at which the host is listening
+    port: int = 0
+
+    #: Timeout for reading a line
+    timeout: Number = 0.2
+
+    def clean_values(self):
+        super().clean_values()
+        if self.timeout < 0:
+            raise ValueError("Timeout has to be >= 0.")
+        self.force_value("host", validate_and_resolve_host(self.host, logger))
+        validate_tcp_port(self.port, logger)
+
+    def create_telnet(self) -> Optional[telnetlib.Telnet]:
+        """
+        Create a telnet client
+        :return: Opened Telnet object or None if connection is not possible
+        """
+        if self.host is None:
+            return None
+
+        try:
+            tn = telnetlib.Telnet(host=cast(str, self.host), port=self.port)
+        except (ConnectionRefusedError, TimeoutError, OSError) as exc:
+            raise TelnetError from exc
+        else:
+            return tn
+
+
+class TelnetCommunication(AsyncCommunicationProtocol):
+    """
+    Implements the Communication Protocol for telnet.
+    """
+
+    def __init__(self, configuration):
+        """
+        Constructor for TelnetCommunication.
+        """
+
+        super().__init__(configuration)
+
+        self._tn: Optional[telnetlib.Telnet] = self.config.create_telnet()
+
+    @property
+    def is_open(self) -> bool:
+        """
+        Is the connection open?
+
+        :return: True for an open connection
+        """
+        return (
+            self._tn is not None
+            and self._tn.sock is not None  # type: ignore
+        )
+
+    def open(self):
+        """
+        Open the telnet connection unless it is not yet opened.
+        """
+        if self.is_open:
+            return
+
+        with self.access_lock:
+            try:
+                self._tn.open(self._tn.host, self._tn.port)
+            except (ConnectionRefusedError, TimeoutError, OSError) as exc:
+                raise TelnetError from exc
+
+    def close(self):
+        """
+        Close the telnet connection unless it is not closed.
+        """
+        if not self.is_open:
+            return
+
+        with self.access_lock:
+            self._tn.close()
+
+    @staticmethod
+    def config_cls():
+        return TelnetCommunicationConfig
+
+    def write_bytes(self, data: bytes):
+        """
+        Write the data as `bytes` to the telnet connection.
+
+        :param data: Data to be sent.
+        :raises TelnetError: when connection is not open, raises an Error during the
+            communication
+        """
+
+        if not self.is_open:
+            raise TelnetError("The Telnet connection is not open.")
+
+        assert self._tn is not None  # makes mypy happy
+        with self.access_lock:
+            self._tn.write(data)
+
+    def read_bytes(self) -> bytes:
+        """
+        Read data as `bytes` from the telnet connection.
+
+        :return: data from telnet connection
+        :raises TelnetError: when connection is not open, raises an Error during the
+            communication
+        """
+
+        if not self.is_open:
+            raise TelnetError("The Telnet connection is not open.")
+
+        assert self._tn is not None  # makes mypy happy
+        try:
+            return self._tn.read_until(
+                match=self.config.terminator, timeout=self.config.timeout
+            ).strip()
+        except EOFError:
+            return b""
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/comm/visa.py` & `hvl_ccb-0.9.0/hvl_ccb/comm/visa.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,342 +1,342 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Communication protocol for VISA. Makes use of the pyvisa library.
-The backend can be NI-Visa or pyvisa-py.
-
-Information on how to install a VISA backend can be found here:
-https://pyvisa.readthedocs.io/en/master/getting_nivisa.html
-
-So far only TCPIP SOCKET and TCPIP INSTR interfaces are supported.
-"""
-
-import logging
-from time import sleep
-from typing import Tuple, Union, Type, Optional, cast
-
-import pyvisa as visa
-from IPy import IP
-from pyvisa.resources import MessageBasedResource
-from pyvisa_py.protocols.rpc import RPCError  # type: ignore
-
-from .base import CommunicationProtocol
-from ..configuration import configdataclass
-from ..utils.enum import AutoNumberNameEnum
-
-logger = logging.getLogger(__name__)
-
-
-class VisaCommunicationError(Exception):
-    """
-    Base class for VisaCommunication errors.
-    """
-
-    pass
-
-
-@configdataclass
-class VisaCommunicationConfig:
-    """
-    `VisaCommunication` configuration dataclass.
-    """
-
-    class InterfaceType(AutoNumberNameEnum):
-        """
-        Supported VISA Interface types.
-        """
-
-        _init_ = "value"
-
-        #: VISA-RAW protocol
-        TCPIP_SOCKET = ((),)
-
-        #: VXI-11 protocol
-        TCPIP_INSTR = ((),)
-
-        def address(self, host: str, port: int = None, board: int = None) -> str:
-            """
-            Address string specific to the VISA interface type.
-
-            :param host: host IP address
-            :param port: optional TCP port
-            :param board: optional board number
-            :return: address string
-            """
-
-            if self.name == VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET:
-                return f"TCPIP{board}::{host}::{port}::SOCKET"
-            elif self.name == VisaCommunicationConfig.InterfaceType.TCPIP_INSTR:
-                return f"TCPIP::{host}::INSTR"
-            else:
-                assert False, self.name + " is unkonow InterfaceType."
-
-    #: IP address of the VISA device. DNS names are currently unsupported.
-    host: str
-
-    #: Interface type of the VISA connection, being one of :class:`InterfaceType`.
-    interface_type: Union[str, InterfaceType]
-
-    #: Board number is typically 0 and comes from old bus systems.
-    board: int = 0
-
-    #: TCP port, standard is 5025.
-    port: int = 5025
-
-    #: Timeout for commands in milli seconds.
-    timeout: int = 5000
-
-    #: Chunk size is the allocated memory for read operations. The standard is 20kB,
-    #: and is increased per default here to 200kB. It is specified in bytes.
-    chunk_size: int = 204800
-
-    #: Timeout for opening the connection, in milli seconds.
-    open_timeout: int = 1000
-
-    #: Write termination character.
-    write_termination: str = "\n"
-
-    #: Read termination character.
-    read_termination: str = "\n"
-
-    visa_backend: str = ""
-    """
-    Specifies the path to the library to be used with PyVISA as a backend. Defaults
-    to None, which is NI-VISA (if installed), or pyvisa-py (if NI-VISA is not found).
-    To force the use of pyvisa-py, specify '@py' here.
-    """
-
-    def clean_values(self):
-        # in principle, host is allowed to be IP or FQDN. However, we only allow IP:
-        IP(self.host)
-
-        if not isinstance(self.interface_type, self.InterfaceType):
-            self.force_value("interface_type", self.InterfaceType(self.interface_type))
-
-        if self.board < 0:
-            raise ValueError("Board number has to be >= 0.")
-
-        if self.timeout < 0:
-            raise ValueError("Timeout has to be >= 0.")
-
-        if self.open_timeout < 0:
-            raise ValueError("Open Timeout has to be >= 0.")
-
-        allowed_terminators = ("\n", "\r", "\r\n")
-        if self.read_termination not in allowed_terminators:
-            raise ValueError("Read terminator has to be \\n, \\r or \\r\\n.")
-
-        if self.write_termination not in allowed_terminators:
-            raise ValueError("Write terminator has to be \\n, \\r or \\r\\n.")
-
-    @property
-    def address(self) -> str:
-        """
-        Address string depending on the VISA protocol's configuration.
-
-        :return: address string corresponding to current configuration
-        """
-
-        return self.interface_type.address(  # type: ignore
-            self.host,
-            port=self.port,
-            board=self.board,
-        )
-
-
-class VisaCommunication(CommunicationProtocol):
-    """
-    Implements the Communication Protocol for VISA / SCPI.
-    """
-
-    #: The maximum of commands that can be sent in one round is 5 according to the
-    #: VISA standard.
-    MULTI_COMMANDS_MAX = 5
-
-    #: The character to separate two commands is ; according to the VISA standard.
-    MULTI_COMMANDS_SEPARATOR = ";"
-
-    #: Small pause in seconds to wait after write operations, allowing devices to
-    #: really do what we tell them before continuing with further tasks.
-    WAIT_AFTER_WRITE = 0.08  # seconds to wait after a write is sent
-
-    def __init__(self, configuration):
-        """
-        Constructor for VisaCommunication.
-        """
-
-        super().__init__(configuration)
-
-        # create a new resource manager
-        if self.config.visa_backend == "":
-            self._resource_manager = visa.ResourceManager()
-        else:
-            self._resource_manager = visa.ResourceManager(self.config.visa_backend)
-
-        self._instrument: Optional[MessageBasedResource] = None
-
-    @staticmethod
-    def config_cls() -> Type[VisaCommunicationConfig]:
-        return VisaCommunicationConfig
-
-    def open(self) -> None:
-        """
-        Open the VISA connection and create the resource.
-        """
-
-        logger.info("Open the VISA connection.")
-
-        with self.access_lock:
-            try:
-                self._instrument = cast(
-                    MessageBasedResource,
-                    self._resource_manager.open_resource(
-                        self.config.address,
-                        open_timeout=self.config.open_timeout,
-                    ),
-                )
-                self._instrument.chunk_size = self.config.chunk_size
-                self._instrument.timeout = self.config.timeout
-                self._instrument.write_termination = self.config.write_termination
-                self._instrument.read_termination = self.config.read_termination
-
-            except visa.VisaIOError as e:
-                logger.error(str(e), exc_info=e)
-                if e.error_code != 0:
-                    raise VisaCommunicationError from e
-
-            except (
-                RPCError,
-                ConnectionRefusedError,
-                BrokenPipeError,
-            ) as e:
-                # if pyvisa-py is used as backend, this RPCError can come. As it is
-                # difficult to import (hyphen in package name), we "convert" it here to
-                # a VisaCommunicationError. Apparently on the Linux runners,
-                # a ConnectionRefusedError is raised on fail, rather than an RPCError.
-                # On macOS the BrokenPipeError error is raised (from
-                # pyvisa-py/protocols/rpc.py:320), with puzzling log message from
-                # visa.py: "187 WARNING  Could not close VISA connection, was not
-                # started."
-                logger.error(str(e), exc_info=e)
-                raise VisaCommunicationError from e
-
-            if self._instrument is not None:
-                try:
-                    # enable keep-alive of the connection. Seems not to work always, but
-                    # using the status poller a keepalive of the connection is also
-                    # satisfied. Unsupported on RTO 1022 devices.
-                    self._instrument.set_visa_attribute(
-                        visa.constants.ResourceAttribute.tcpip_keepalive,
-                        visa.constants.VI_TRUE,
-                    )
-
-                except visa.VisaIOError as e:
-                    if e.abbreviation == 'VI_ERROR_NSUP_ATTR':
-                        logger.warning(str(e), exc_info=e)
-                    else:
-                        logger.error(str(e), exc_info=e)
-                        if e.error_code != 0:
-                            raise VisaCommunicationError from e
-
-    def close(self) -> None:
-        """
-        Close the VISA connection and invalidates the handle.
-        """
-
-        if self._instrument is None:
-            logger.warning("Could not close VISA connection, was not started.")
-            return
-
-        try:
-            with self.access_lock:
-                self._instrument.close()
-        except visa.InvalidSession as e:
-            logger.warning(
-                "Could not close VISA connection, session invalid.", exc_info=e
-            )
-
-    def write(self, *commands: str) -> None:
-        """
-        Write commands. No answer is read or expected.
-
-        :param commands: one or more commands to send
-        :raises VisaCommunicationError: when connection was not started
-        """
-
-        if self._instrument is None:
-            msg = "Could not write to VISA connection, was not started."
-            logger.error(msg)
-            raise VisaCommunicationError(msg)
-
-        with self.access_lock:
-            self._instrument.write(self._generate_cmd_string(commands))
-
-        # sleep small amount of time to not overload device
-        sleep(self.WAIT_AFTER_WRITE)
-
-    def query(self, *commands: str) -> Union[str, Tuple[str, ...]]:
-        """
-        A combination of write(message) and read.
-
-        :param commands: list of commands
-        :return: list of values
-        :raises VisaCommunicationError: when connection was not started, or when trying
-            to issue too many commands at once.
-        """
-
-        if self._instrument is None:
-            msg = "Could not query VISA connection, was not started."
-            logger.error(msg)
-            raise VisaCommunicationError(msg)
-
-        cmd_string = self._generate_cmd_string(commands)
-        with self.access_lock:
-            return_string = self._instrument.query(cmd_string)
-
-        if len(commands) == 1:
-            return return_string
-
-        return tuple(return_string.split(self.MULTI_COMMANDS_SEPARATOR))
-
-    @classmethod
-    def _generate_cmd_string(cls, command_list: Tuple[str, ...]) -> str:
-        """
-        Generate the command string out of a tuple of strings.
-
-        :param command_list: is the tuple containing multiple commands
-        :return: the command string that can be sent via the protocol
-        """
-
-        if len(command_list) <= cls.MULTI_COMMANDS_MAX:
-            return cls.MULTI_COMMANDS_SEPARATOR.join(command_list)
-
-        raise VisaCommunicationError(
-            f"Too many commands at once ({len(command_list)}). Max allowed: "
-            f"{cls.MULTI_COMMANDS_MAX}."
-        )
-
-    def spoll(self) -> int:
-        """
-        Execute serial poll on the device. Reads the status byte register STB. This
-        is a fast function that can be executed periodically in a polling fashion.
-
-        :return: integer representation of the status byte
-        :raises VisaCommunicationError: when connection was not started
-        """
-
-        if self._instrument is None:
-            msg = "Could not query VISA connection, was not started."
-            logger.error(msg)
-            raise VisaCommunicationError(msg)
-
-        interface_type = self.config.interface_type
-
-        if interface_type == VisaCommunicationConfig.InterfaceType.TCPIP_INSTR:
-            with self.access_lock:
-                stb = self._instrument.read_stb()
-            return stb
-
-        if interface_type == VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET:
-            return int(self.query("*STB?"))  # type: ignore
-
-        assert False, "Forgot to cover interface_type case?"
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Communication protocol for VISA. Makes use of the pyvisa library.
+The backend can be NI-Visa or pyvisa-py.
+
+Information on how to install a VISA backend can be found here:
+https://pyvisa.readthedocs.io/en/master/getting_nivisa.html
+
+So far only TCPIP SOCKET and TCPIP INSTR interfaces are supported.
+"""
+
+import logging
+from ipaddress import IPv4Address, IPv6Address
+from time import sleep
+from typing import Tuple, Union, Type, Optional, cast
+
+import pyvisa as visa
+from pyvisa.resources import MessageBasedResource
+from pyvisa_py.protocols.rpc import RPCError  # type: ignore
+
+from hvl_ccb.utils.enum import AutoNumberNameEnum
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+from .base import CommunicationProtocol, CommunicationException
+from ..configuration import configdataclass
+
+logger = logging.getLogger(__name__)
+
+
+class VisaCommunicationError(IOError, CommunicationException):
+    """
+    Base class for VisaCommunication errors.
+    """
+
+    pass
+
+
+@configdataclass
+class VisaCommunicationConfig:
+    """
+    `VisaCommunication` configuration dataclass.
+    """
+
+    class InterfaceType(AutoNumberNameEnum, init="value"):  # type:ignore
+        """
+        Supported VISA Interface types.
+        """
+
+        #: VISA-RAW protocol
+        TCPIP_SOCKET = ((),)
+
+        #: VXI-11 protocol
+        TCPIP_INSTR = ((),)
+
+        def address(self, host: str, port: int = None, board: int = None) -> str:
+            """
+            Address string specific to the VISA interface type.
+
+            :param host: host IP address
+            :param port: optional TCP port
+            :param board: optional board number
+            :return: address string
+            """
+
+            if self.name == VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET:
+                return f"TCPIP{board}::{host}::{port}::SOCKET"
+            elif self.name == VisaCommunicationConfig.InterfaceType.TCPIP_INSTR:
+                return f"TCPIP::{host}::INSTR"
+            else:
+                assert False, self.name + " is unkonow InterfaceType."
+
+    # IP address of the VISA device.
+    host: Union[str, IPv4Address, IPv6Address]
+
+    #: Interface type of the VISA connection, being one of :class:`InterfaceType`.
+    interface_type: Union[str, InterfaceType]
+
+    #: Board number is typically 0 and comes from old bus systems.
+    board: int = 0
+
+    #: TCP port, standard is 5025.
+    port: int = 5025
+
+    #: Timeout for commands in milli seconds.
+    timeout: int = 5000
+
+    #: Chunk size is the allocated memory for read operations. The standard is 20kB,
+    #: and is increased per default here to 200kB. It is specified in bytes.
+    chunk_size: int = 204800
+
+    #: Timeout for opening the connection, in milli seconds.
+    open_timeout: int = 1000
+
+    #: Write termination character.
+    write_termination: str = "\n"
+
+    #: Read termination character.
+    read_termination: str = "\n"
+
+    visa_backend: str = ""
+    """
+    Specifies the path to the library to be used with PyVISA as a backend. Defaults
+    to None, which is NI-VISA (if installed), or pyvisa-py (if NI-VISA is not found).
+    To force the use of pyvisa-py, specify '@py' here.
+    """
+
+    def clean_values(self):
+        # in principle, host is allowed to be IP or FQDN. However, we only allow IP:
+        self.force_value("host", validate_and_resolve_host(self.host, logger))
+        validate_tcp_port(self.port, logger)
+
+        if not isinstance(self.interface_type, self.InterfaceType):
+            self.force_value("interface_type", self.InterfaceType(self.interface_type))
+
+        if self.board < 0:
+            raise ValueError("Board number has to be >= 0.")
+
+        if self.timeout < 0:
+            raise ValueError("Timeout has to be >= 0.")
+
+        if self.open_timeout < 0:
+            raise ValueError("Open Timeout has to be >= 0.")
+
+        allowed_terminators = ("\n", "\r", "\r\n")
+        if self.read_termination not in allowed_terminators:
+            raise ValueError("Read terminator has to be \\n, \\r or \\r\\n.")
+
+        if self.write_termination not in allowed_terminators:
+            raise ValueError("Write terminator has to be \\n, \\r or \\r\\n.")
+
+    @property
+    def address(self) -> str:
+        """
+        Address string depending on the VISA protocol's configuration.
+
+        :return: address string corresponding to current configuration
+        """
+
+        return self.interface_type.address(  # type: ignore
+            cast(str, self.host),
+            port=self.port,
+            board=self.board,
+        )
+
+
+class VisaCommunication(CommunicationProtocol):
+    """
+    Implements the Communication Protocol for VISA / SCPI.
+    """
+
+    #: The maximum of commands that can be sent in one round is 5 according to the
+    #: VISA standard.
+    MULTI_COMMANDS_MAX = 5
+
+    #: The character to separate two commands is ; according to the VISA standard.
+    MULTI_COMMANDS_SEPARATOR = ";"
+
+    #: Small pause in seconds to wait after write operations, allowing devices to
+    #: really do what we tell them before continuing with further tasks.
+    WAIT_AFTER_WRITE = 0.08  # seconds to wait after a write is sent
+
+    def __init__(self, configuration):
+        """
+        Constructor for VisaCommunication.
+        """
+
+        super().__init__(configuration)
+
+        # create a new resource manager
+        if self.config.visa_backend == "":
+            self._resource_manager = visa.ResourceManager()
+        else:
+            self._resource_manager = visa.ResourceManager(self.config.visa_backend)
+
+        self._instrument: Optional[MessageBasedResource] = None
+
+    @staticmethod
+    def config_cls() -> Type[VisaCommunicationConfig]:
+        return VisaCommunicationConfig
+
+    def open(self) -> None:
+        """
+        Open the VISA connection and create the resource.
+        """
+
+        logger.info("Open the VISA connection.")
+
+        with self.access_lock:
+            try:
+                self._instrument = cast(
+                    MessageBasedResource,
+                    self._resource_manager.open_resource(
+                        self.config.address,
+                        open_timeout=self.config.open_timeout,
+                    ),
+                )
+                self._instrument.chunk_size = self.config.chunk_size
+                self._instrument.timeout = self.config.timeout
+                self._instrument.write_termination = self.config.write_termination
+                self._instrument.read_termination = self.config.read_termination
+
+            except visa.VisaIOError as e:
+                logger.error(str(e), exc_info=e)
+                if e.error_code != 0:
+                    raise VisaCommunicationError from e
+
+            except (
+                RPCError,
+                ConnectionRefusedError,
+                BrokenPipeError,
+            ) as e:
+                # if pyvisa-py is used as backend, this RPCError can come. As it is
+                # difficult to import (hyphen in package name), we "convert" it here to
+                # a VisaCommunicationError. Apparently on the Linux runners,
+                # a ConnectionRefusedError is raised on fail, rather than an RPCError.
+                # On macOS the BrokenPipeError error is raised (from
+                # pyvisa-py/protocols/rpc.py:320), with puzzling log message from
+                # visa.py: "187 WARNING  Could not close VISA connection, was not
+                # started."
+                logger.error(str(e), exc_info=e)
+                raise VisaCommunicationError from e
+
+            if self._instrument is not None:
+                try:
+                    # enable keep-alive of the connection. Seems not to work always, but
+                    # using the status poller a keepalive of the connection is also
+                    # satisfied. Unsupported on RTO 1022 devices.
+                    self._instrument.set_visa_attribute(
+                        visa.constants.ResourceAttribute.tcpip_keepalive,
+                        visa.constants.VI_TRUE,
+                    )
+
+                except visa.VisaIOError as e:
+                    if e.abbreviation == 'VI_ERROR_NSUP_ATTR':
+                        logger.warning(str(e), exc_info=e)
+                    else:
+                        logger.error(str(e), exc_info=e)
+                        if e.error_code != 0:
+                            raise VisaCommunicationError from e
+
+    def close(self) -> None:
+        """
+        Close the VISA connection and invalidates the handle.
+        """
+
+        if self._instrument is None:
+            logger.warning("Could not close VISA connection, was not started.")
+            return
+
+        try:
+            with self.access_lock:
+                self._instrument.close()
+        except visa.InvalidSession as e:
+            logger.warning(
+                "Could not close VISA connection, session invalid.", exc_info=e
+            )
+
+    def write(self, *commands: str) -> None:
+        """
+        Write commands. No answer is read or expected.
+
+        :param commands: one or more commands to send
+        :raises VisaCommunicationError: when connection was not started
+        """
+
+        if self._instrument is None:
+            msg = "Could not write to VISA connection, was not started."
+            logger.error(msg)
+            raise VisaCommunicationError(msg)
+
+        with self.access_lock:
+            self._instrument.write(self._generate_cmd_string(commands))
+
+        # sleep small amount of time to not overload device
+        sleep(self.WAIT_AFTER_WRITE)
+
+    def query(self, *commands: str) -> Union[str, Tuple[str, ...]]:
+        """
+        A combination of write(message) and read.
+
+        :param commands: list of commands
+        :return: list of values
+        :raises VisaCommunicationError: when connection was not started, or when trying
+            to issue too many commands at once.
+        """
+
+        if self._instrument is None:
+            msg = "Could not query VISA connection, was not started."
+            logger.error(msg)
+            raise VisaCommunicationError(msg)
+
+        cmd_string = self._generate_cmd_string(commands)
+        with self.access_lock:
+            return_string = self._instrument.query(cmd_string)
+
+        if len(commands) == 1:
+            return return_string
+
+        return tuple(return_string.split(self.MULTI_COMMANDS_SEPARATOR))
+
+    @classmethod
+    def _generate_cmd_string(cls, command_list: Tuple[str, ...]) -> str:
+        """
+        Generate the command string out of a tuple of strings.
+
+        :param command_list: is the tuple containing multiple commands
+        :return: the command string that can be sent via the protocol
+        """
+
+        if len(command_list) <= cls.MULTI_COMMANDS_MAX:
+            return cls.MULTI_COMMANDS_SEPARATOR.join(command_list)
+
+        raise VisaCommunicationError(
+            f"Too many commands at once ({len(command_list)}). Max allowed: "
+            f"{cls.MULTI_COMMANDS_MAX}."
+        )
+
+    def spoll(self) -> int:
+        """
+        Execute serial poll on the device. Reads the status byte register STB. This
+        is a fast function that can be executed periodically in a polling fashion.
+
+        :return: integer representation of the status byte
+        :raises VisaCommunicationError: when connection was not started
+        """
+
+        if self._instrument is None:
+            msg = "Could not query VISA connection, was not started."
+            logger.error(msg)
+            raise VisaCommunicationError(msg)
+
+        interface_type = self.config.interface_type
+
+        if interface_type == VisaCommunicationConfig.InterfaceType.TCPIP_INSTR:
+            with self.access_lock:
+                stb = self._instrument.read_stb()
+            return stb
+
+        if interface_type == VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET:
+            return int(self.query("*STB?"))  # type: ignore
+
+        assert False, "Forgot to cover interface_type case?"
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/configuration.py` & `hvl_ccb-0.9.0/hvl_ccb/configuration.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,273 +1,273 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Facilities providing classes for handling configuration for communication protocols
-and devices.
-"""
-
-import dataclasses
-import json
-import logging
-from abc import ABC, abstractmethod
-from importlib import import_module
-from typing import Dict, Sequence
-
-from .utils.typing import is_generic_type_hint, check_generic_type
-
-logger = logging.getLogger(__name__)
-
-
-def _has_default_value(f: dataclasses.Field):
-    return not isinstance(f.default, dataclasses._MISSING_TYPE)
-
-
-# Hooks of configdataclass
-def _clean_values(self):
-    """
-    Cleans and enforces configuration values. Does nothing by default, but may be
-    overridden to add custom configuration value checks.
-    """
-
-
-_configclass_hooks = {
-    "clean_values": _clean_values,
-}
-
-
-# Methods of configdataclass
-def ___post_init__(self):
-    self._check_types()
-    self.clean_values()
-
-
-def _force_value(self, fieldname, value):
-    """
-    Forces a value to a dataclass field despite the class being frozen.
-
-    NOTE: you can define `post_force_value` method with same signature as this method
-    to do extra processing after `value` has been forced on `fieldname`.
-
-    :param fieldname: name of the field
-    :param value: value to assign
-    """
-    object.__setattr__(self, fieldname, value)
-    if hasattr(self, "post_force_value"):
-        self.post_force_value(fieldname, value)
-
-
-@classmethod  # type: ignore
-def _keys(cls) -> Sequence[str]:
-    """
-    Returns a list of all configdataclass fields key-names.
-
-    :return: a list of strings containing all keys.
-    """
-    return [f.name for f in dataclasses.fields(cls)]
-
-
-@classmethod  # type: ignore
-def _required_keys(cls) -> Sequence[str]:
-    """
-    Returns a list of all configdataclass fields, that have no default value assigned
-    and need to be specified on instantiation.
-
-    :return: a list of strings containing all required keys.
-    """
-    return [f.name for f in dataclasses.fields(cls) if not _has_default_value(f)]
-
-
-@classmethod  # type: ignore
-def _optional_defaults(cls) -> Dict[str, object]:
-    """
-    Returns a list of all configdataclass fields, that have a default value assigned
-    and may be optionally specified on instantiation.
-
-    :return: a list of strings containing all optional keys.
-    """
-    return {f.name: f.default for f in dataclasses.fields(cls) if _has_default_value(f)}
-
-
-def __check_types(self):
-    mod = import_module(self.__module__)
-    for field in dataclasses.fields(self):
-        name = field.name
-        value = getattr(self, name)
-        type_ = field.type
-        if isinstance(type_, str):  # `from __future__ import annotations` in use
-            try:
-                # built-in types
-                type_ = eval(type_)
-            except NameError:
-                # no logging at this point, try-except controls program behaviour
-                # module-level defined type
-                type_ = getattr(mod, type_)
-        if is_generic_type_hint(type_):
-            check_generic_type(value, type_, name=name)
-        elif not isinstance(value, type_):
-            raise TypeError(
-                f"Type of field '{name}' is '{type(value)}' "
-                f"and does not match '{type_}.'"
-            )
-
-
-_configclass_methods = {
-    "__post_init__": ___post_init__,
-    "force_value": _force_value,
-    "keys": _keys,
-    "required_keys": _required_keys,
-    "optional_defaults": _optional_defaults,
-    "_check_types": __check_types,
-}
-
-
-def configdataclass(direct_decoration=None, frozen=True):
-    """
-    Decorator to make a class a configdataclass. Types in these dataclasses are
-    enforced. Implement a function clean_values(self) to do additional checking on
-    value ranges etc.
-
-    It is possible to inherit from a configdataclass and re-decorate it with
-    @configdataclass. In a subclass, default values can be added to existing fields.
-    Note: adding additional non-default fields is prone to errors, since the order
-    has to be respected through the whole chain (first non-default fields, only then
-    default-fields).
-
-    :param frozen: defaults to True. False allows to later change configuration values.
-        Attention: if configdataclass is not frozen and a value is changed, typing is
-        not enforced anymore!
-    """
-
-    def decorator(cls):
-        for name, method in _configclass_methods.items():
-            if name in cls.__dict__:
-                raise AttributeError(
-                    f"configdataclass {cls.__name__} cannot define {name} method"
-                )
-            setattr(cls, name, method)
-        for name, hook in _configclass_hooks.items():
-            if not hasattr(cls, name):
-                setattr(cls, name, hook)
-        if not hasattr(cls, "is_configdataclass"):
-            setattr(cls, "is_configdataclass", True)
-
-        return dataclasses.dataclass(cls, frozen=frozen)
-
-    if direct_decoration:
-        return decorator(direct_decoration)
-
-    return decorator
-
-
-class ConfigurationMixin(ABC):
-    """
-    Mixin providing configuration to a class.
-    """
-
-    # omitting type hint of `configuration` on purpose, because type hinting
-    # configdataclass is not possible. Union[Dict[str, object], object] resolves to
-    # object.
-    def __init__(self, configuration) -> None:
-        """
-        Constructor for the configuration mixin.
-
-        :param configuration: is the configuration provided either as:
-        *   a dict with string keys and values, then the default config dataclass
-            will be used
-        *   a configdataclass object
-        *   None, then the config_cls() with no parameters is instantiated
-        """
-
-        if not configuration:
-            configuration = {}
-
-        if hasattr(configuration, "is_configdataclass"):
-            self._configuration = configuration
-        elif isinstance(configuration, Dict):
-            default_configdataclass = self.config_cls()
-            if not hasattr(default_configdataclass, "is_configdataclass"):
-                raise TypeError(
-                    "Default configdataclass is not a configdataclass. Is"
-                    "the decorator `@configdataclass` applied?"
-                )
-            self._configuration = default_configdataclass(**configuration)
-        else:
-            raise TypeError("configuration is not a dictionary or configdataclass.")
-
-    @staticmethod
-    @abstractmethod
-    def config_cls():
-        """
-        Return the default configdataclass class.
-
-        :return: a reference to the default configdataclass class
-        """
-
-    @property
-    def config(self):
-        """
-        ConfigDataclass property.
-
-        :return: the configuration
-        """
-
-        return self._configuration
-
-    @classmethod
-    def from_json(cls, filename: str):
-        """
-        Instantiate communication protocol using configuration from a JSON file.
-
-        :param filename: Path and filename to the JSON configuration
-        """
-
-        configuration = cls._configuration_load_json(filename)
-        return cls(configuration)
-
-    def configuration_save_json(self, path: str) -> None:
-        """
-        Save current configuration as JSON file.
-
-        :param path: path to the JSON file.
-        """
-
-        self._configuration_save_json(dataclasses.asdict(self._configuration), path)
-
-    @staticmethod
-    def _configuration_load_json(path: str) -> Dict[str, object]:
-        """
-        Load configuration from JSON file and return Dict. This method is only used
-        during construction, if not directly a configuration is given but rather a
-        path to a JSON config file.
-
-        :param path: Path to the JSON configuration file.
-        :return: Dictionary containing the parameters read from the JSON file.
-        """
-
-        with open(path, "r") as fp:
-            return json.load(fp)
-
-    @staticmethod
-    def _configuration_save_json(configuration: Dict[str, object], path: str) -> None:
-        """
-        Store a configuration dict to a JSON file.
-
-        :param configuration: configuration dictionary
-        :param path: path to the JSON file.
-        """
-
-        with open(path, "w") as fp:
-            json.dump(configuration, fp, indent=4)
-
-
-@configdataclass
-class EmptyConfig:
-    """
-    Empty configuration dataclass.
-    """
-
-
-class ConfigurationValueWarning(UserWarning):
-    """
-    User warnings category for values of `@configdataclass` fields.
-    """
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Facilities providing classes for handling configuration for communication protocols
+and devices.
+"""
+
+import dataclasses
+import json
+import logging
+from abc import ABC, abstractmethod
+from importlib import import_module
+from typing import Dict, Sequence
+
+from .utils.typing import is_generic_type_hint, check_generic_type
+
+logger = logging.getLogger(__name__)
+
+
+def _has_default_value(f: dataclasses.Field):
+    return not isinstance(f.default, dataclasses._MISSING_TYPE)
+
+
+# Hooks of configdataclass
+def _clean_values(self):
+    """
+    Cleans and enforces configuration values. Does nothing by default, but may be
+    overridden to add custom configuration value checks.
+    """
+
+
+_configclass_hooks = {
+    "clean_values": _clean_values,
+}
+
+
+# Methods of configdataclass
+def ___post_init__(self):
+    self._check_types()
+    self.clean_values()
+
+
+def _force_value(self, fieldname, value):
+    """
+    Forces a value to a dataclass field despite the class being frozen.
+
+    NOTE: you can define `post_force_value` method with same signature as this method
+    to do extra processing after `value` has been forced on `fieldname`.
+
+    :param fieldname: name of the field
+    :param value: value to assign
+    """
+    object.__setattr__(self, fieldname, value)
+    if hasattr(self, "post_force_value"):
+        self.post_force_value(fieldname, value)
+
+
+@classmethod  # type: ignore
+def _keys(cls) -> Sequence[str]:
+    """
+    Returns a list of all configdataclass fields key-names.
+
+    :return: a list of strings containing all keys.
+    """
+    return [f.name for f in dataclasses.fields(cls)]
+
+
+@classmethod  # type: ignore
+def _required_keys(cls) -> Sequence[str]:
+    """
+    Returns a list of all configdataclass fields, that have no default value assigned
+    and need to be specified on instantiation.
+
+    :return: a list of strings containing all required keys.
+    """
+    return [f.name for f in dataclasses.fields(cls) if not _has_default_value(f)]
+
+
+@classmethod  # type: ignore
+def _optional_defaults(cls) -> Dict[str, object]:
+    """
+    Returns a list of all configdataclass fields, that have a default value assigned
+    and may be optionally specified on instantiation.
+
+    :return: a list of strings containing all optional keys.
+    """
+    return {f.name: f.default for f in dataclasses.fields(cls) if _has_default_value(f)}
+
+
+def __check_types(self):
+    mod = import_module(self.__module__)
+    for field in dataclasses.fields(self):
+        name = field.name
+        value = getattr(self, name)
+        type_ = field.type
+        if isinstance(type_, str):  # `from __future__ import annotations` in use
+            try:
+                # built-in types
+                type_ = eval(type_)
+            except NameError:
+                # no logging at this point, try-except controls program behaviour
+                # module-level defined type
+                type_ = getattr(mod, type_)
+        if is_generic_type_hint(type_):
+            check_generic_type(value, type_, name=name)
+        elif not isinstance(value, type_):
+            raise TypeError(
+                f"Type of field '{name}' is '{type(value)}' "
+                f"and does not match '{type_}.'"
+            )
+
+
+_configclass_methods = {
+    "__post_init__": ___post_init__,
+    "force_value": _force_value,
+    "keys": _keys,
+    "required_keys": _required_keys,
+    "optional_defaults": _optional_defaults,
+    "_check_types": __check_types,
+}
+
+
+def configdataclass(direct_decoration=None, frozen=True):
+    """
+    Decorator to make a class a configdataclass. Types in these dataclasses are
+    enforced. Implement a function clean_values(self) to do additional checking on
+    value ranges etc.
+
+    It is possible to inherit from a configdataclass and re-decorate it with
+    @configdataclass. In a subclass, default values can be added to existing fields.
+    Note: adding additional non-default fields is prone to errors, since the order
+    has to be respected through the whole chain (first non-default fields, only then
+    default-fields).
+
+    :param frozen: defaults to True. False allows to later change configuration values.
+        Attention: if configdataclass is not frozen and a value is changed, typing is
+        not enforced anymore!
+    """
+
+    def decorator(cls):
+        for name, method in _configclass_methods.items():
+            if name in cls.__dict__:
+                raise AttributeError(
+                    f"configdataclass {cls.__name__} cannot define {name} method"
+                )
+            setattr(cls, name, method)
+        for name, hook in _configclass_hooks.items():
+            if not hasattr(cls, name):
+                setattr(cls, name, hook)
+        if not hasattr(cls, "is_configdataclass"):
+            setattr(cls, "is_configdataclass", True)
+
+        return dataclasses.dataclass(cls, frozen=frozen)
+
+    if direct_decoration:
+        return decorator(direct_decoration)
+
+    return decorator
+
+
+class ConfigurationMixin(ABC):
+    """
+    Mixin providing configuration to a class.
+    """
+
+    # omitting type hint of `configuration` on purpose, because type hinting
+    # configdataclass is not possible. Union[Dict[str, object], object] resolves to
+    # object.
+    def __init__(self, configuration) -> None:
+        """
+        Constructor for the configuration mixin.
+
+        :param configuration: is the configuration provided either as:
+        *   a dict with string keys and values, then the default config dataclass
+            will be used
+        *   a configdataclass object
+        *   None, then the config_cls() with no parameters is instantiated
+        """
+
+        if not configuration:
+            configuration = {}
+
+        if hasattr(configuration, "is_configdataclass"):
+            self._configuration = configuration
+        elif isinstance(configuration, Dict):
+            default_configdataclass = self.config_cls()
+            if not hasattr(default_configdataclass, "is_configdataclass"):
+                raise TypeError(
+                    "Default configdataclass is not a configdataclass. Is"
+                    "the decorator `@configdataclass` applied?"
+                )
+            self._configuration = default_configdataclass(**configuration)
+        else:
+            raise TypeError("configuration is not a dictionary or configdataclass.")
+
+    @staticmethod
+    @abstractmethod
+    def config_cls():
+        """
+        Return the default configdataclass class.
+
+        :return: a reference to the default configdataclass class
+        """
+
+    @property
+    def config(self):
+        """
+        ConfigDataclass property.
+
+        :return: the configuration
+        """
+
+        return self._configuration
+
+    @classmethod
+    def from_json(cls, filename: str):
+        """
+        Instantiate communication protocol using configuration from a JSON file.
+
+        :param filename: Path and filename to the JSON configuration
+        """
+
+        configuration = cls._configuration_load_json(filename)
+        return cls(configuration)
+
+    def configuration_save_json(self, path: str) -> None:
+        """
+        Save current configuration as JSON file.
+
+        :param path: path to the JSON file.
+        """
+
+        self._configuration_save_json(dataclasses.asdict(self._configuration), path)
+
+    @staticmethod
+    def _configuration_load_json(path: str) -> Dict[str, object]:
+        """
+        Load configuration from JSON file and return Dict. This method is only used
+        during construction, if not directly a configuration is given but rather a
+        path to a JSON config file.
+
+        :param path: Path to the JSON configuration file.
+        :return: Dictionary containing the parameters read from the JSON file.
+        """
+
+        with open(path, "r") as fp:
+            return json.load(fp)
+
+    @staticmethod
+    def _configuration_save_json(configuration: Dict[str, object], path: str) -> None:
+        """
+        Store a configuration dict to a JSON file.
+
+        :param configuration: configuration dictionary
+        :param path: path to the JSON file.
+        """
+
+        with open(path, "w") as fp:
+            json.dump(configuration, fp, indent=4)
+
+
+@configdataclass
+class EmptyConfig:
+    """
+    Empty configuration dataclass.
+    """
+
+
+class ConfigurationValueWarning(UserWarning):
+    """
+    User warnings category for values of `@configdataclass` fields.
+    """
+    pass
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/__init__.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/__init__.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,227 +1,221 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""Devices subpackage."""
-
-import sys
-
-from .base import (  # noqa: F401
-    Device,
-    DeviceExistingException,
-    DeviceSequenceMixin,
-    DeviceFailuresException,
-    SingleCommDevice,
-)
-from .crylas import (  # noqa: F401
-    CryLasLaser,
-    CryLasLaserConfig,
-    CryLasLaserSerialCommunication,
-    CryLasLaserSerialCommunicationConfig,
-    CryLasLaserError,
-    CryLasLaserNotReadyError,
-    CryLasAttenuator,
-    CryLasAttenuatorConfig,
-    CryLasAttenuatorSerialCommunication,
-    CryLasAttenuatorSerialCommunicationConfig,
-    CryLasAttenuatorError,
-)
-from .ea_psi9000 import (  # noqa: F401
-    PSI9000,
-    PSI9000Config,
-    PSI9000VisaCommunication,
-    PSI9000VisaCommunicationConfig,
-    PSI9000Error,
-)
-from .fug import (  # noqa: F401
-    FuG,
-    FuGConfig,
-    FuGSerialCommunication,
-    FuGSerialCommunicationConfig,
-    FuGError,
-    FuGErrorcodes,
-    FuGDigitalVal,
-    FuGTerminators,
-    FuGPolarities,
-    FuGReadbackChannels,
-    FuGMonitorModes,
-    FuGRampModes,
-)
-from .heinzinger import (  # noqa: F401
-    HeinzingerDI,
-    HeinzingerPNC,
-    HeinzingerConfig,
-    HeinzingerPNCError,
-    HeinzingerPNCMaxVoltageExceededException,
-    HeinzingerPNCMaxCurrentExceededException,
-    HeinzingerPNCDeviceNotRecognizedException,
-    HeinzingerSerialCommunication,
-    HeinzingerSerialCommunicationConfig,
-)
-
-try:
-    from .labjack import (  # noqa: F401
-        LabJack,
-        LabJackError,
-        LabJackIdentifierDIOError,
-    )
-except (ImportError, ModuleNotFoundError):
-    import warnings
-
-    warnings.warn(
-        "\n\n  "
-        "To use LabJack device controller or related utilities install LJM Library and"
-        "\n  "
-        "install the hvl_ccb library with a 'labjack' extra feature:"
-        "\n\n  "
-        "    pip install hvl_ccb[labjack]"
-        "\n\n"
-    )
-
-from .lauda import (  # noqa: F401
-    LaudaProRp245eTcpCommunicationConfig,
-    LaudaProRp245eTcpCommunication,
-    LaudaProRp245eConfig,
-    LaudaProRp245e,
-)
-from .mbw973 import (  # noqa: F401
-    MBW973,
-    MBW973Config,
-    MBW973ControlRunningException,
-    MBW973PumpRunningException,
-    MBW973Error,
-    MBW973SerialCommunication,
-    MBW973SerialCommunicationConfig,
-)
-from .newport import (  # noqa: F401
-    NewportSMC100PP,
-    NewportSMC100PPConfig,
-    NewportStates,
-    NewportSMC100PPSerialCommunication,
-    NewportSMC100PPSerialCommunicationConfig,
-    NewportConfigCommands,
-    NewportMotorError,
-    NewportControllerError,
-    NewportSerialCommunicationError,
-    NewportUncertainPositionError,
-    NewportMotorPowerSupplyWasCutError,
-)
-from .pfeiffer_tpg import (  # noqa: F401
-    PfeifferTPG,
-    PfeifferTPGConfig,
-    PfeifferTPGSerialCommunication,
-    PfeifferTPGSerialCommunicationConfig,
-    PfeifferTPGError,
-)
-if sys.platform == 'darwin':
-    import warnings
-
-    warnings.warn("\n\n  PicoSDK is not available for Darwin OSs\n")
-else:
-    try:
-        from .picotech_pt104 import (  # noqa: F401
-            Pt104,
-            Pt104ChannelConfig,
-            Pt104CommunicationType,
-            Pt104DeviceConfig,
-        )
-    except (ImportError, ModuleNotFoundError):
-        import warnings
-
-        warnings.warn(
-            "\n\n  "
-            "To use PicoTech PT-104 device controller or related utilities install"
-            "\n  "
-            "PicoSDK and install the hvl_ccb library with a 'picotech' extra feature:"
-            "\n\n  "
-            "    $ pip install hvl_ccb[picotech]"
-            "\n\n"
-        )
-
-from .rs_rto1024 import (  # noqa: F401
-    RTO1024,
-    RTO1024Error,
-    RTO1024Config,
-    RTO1024VisaCommunication,
-    RTO1024VisaCommunicationConfig,
-)
-from .se_ils2t import (  # noqa: F401
-    ILS2T,
-    ILS2TConfig,
-    ILS2TException,
-    ILS2TModbusTcpCommunication,
-    ILS2TModbusTcpCommunicationConfig,
-    IoScanningModeValueError,
-    ScalingFactorValueError,
-)
-from .sst_luminox import (  # noqa: F401
-    Luminox,
-    LuminoxConfig,
-    LuminoxSerialCommunication,
-    LuminoxSerialCommunicationConfig,
-    LuminoxMeasurementType,
-    LuminoxMeasurementTypeError,
-    LuminoxOutputMode,
-    LuminoxOutputModeError,
-)
-from .technix import (  # noqa: F401
-    Technix,
-    TechnixError,
-    TechnixTelnetCommunication,
-    TechnixSerialCommunication,
-)
-from .visa import (  # noqa: F401
-    VisaDevice,
-    VisaDeviceConfig,
-)
-
-if sys.platform == 'darwin':
-    import warnings
-
-    warnings.warn("\n\n  LibTiePie SDK is not available for Darwin OSs\n")
-else:
-    try:
-        from .tiepie.generator import (  # noqa: F401
-            TiePieGeneratorConfig,
-            TiePieGeneratorSignalType,
-            TiePieGeneratorMixin,
-        )
-        from .tiepie.i2c import (  # noqa: F401
-            TiePieI2CHostConfig,
-            TiePieI2CHostMixin,
-        )
-        from .tiepie.oscilloscope import (  # noqa: F401
-            TiePieOscilloscope,
-            TiePieOscilloscopeConfig,
-            TiePieOscilloscopeResolution,
-            TiePieOscilloscopeAutoResolutionModes,
-        )
-        from .tiepie.base import (  # noqa: F401
-            TiePieDeviceConfig,
-            TiePieDeviceType,
-            TiePieError,
-            get_device_by_serial_number,
-            _verify_via_libtiepie,
-        )
-        from .tiepie.channel import (  # noqa: F401
-            TiePieOscilloscopeChannelCoupling,
-            TiePieOscilloscopeChannelConfig,
-            TiePieOscilloscopeRange,
-            TiePieOscilloscopeTriggerKind,
-            TiePieOscilloscopeTriggerLevelMode,
-        )
-        from .tiepie.device import (  # noqa: F401
-            TiePieHS5,
-            TiePieHS6,
-            TiePieWS5,
-        )
-    except (ImportError, ModuleNotFoundError):
-        import warnings
-
-        warnings.warn(
-            "\n\n  "
-            "To use TiePie devices controllers or related utilities install LibTiePie"
-            "\n  "
-            "and install the hvl_ccb library with a 'tiepie' extra feature:"
-            "\n\n  "
-            "    $ pip install hvl_ccb[tiepie]"
-            "\n\n"
-        )
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""Devices subpackage."""
+
+import sys
+
+from .base import (  # noqa: F401
+    Device,
+    DeviceExistingException,
+    DeviceSequenceMixin,
+    DeviceFailuresException,
+    SingleCommDevice,
+)
+from .crylas import (  # noqa: F401
+    CryLasLaser,
+    CryLasLaserConfig,
+    CryLasLaserSerialCommunication,
+    CryLasLaserSerialCommunicationConfig,
+    CryLasLaserError,
+    CryLasLaserNotReadyError,
+    CryLasAttenuator,
+    CryLasAttenuatorConfig,
+    CryLasAttenuatorSerialCommunication,
+    CryLasAttenuatorSerialCommunicationConfig,
+    CryLasAttenuatorError,
+)
+from .ea_psi9000 import (  # noqa: F401
+    PSI9000,
+    PSI9000Config,
+    PSI9000VisaCommunication,
+    PSI9000VisaCommunicationConfig,
+    PSI9000Error,
+)
+from .fug import (  # noqa: F401
+    FuG,
+    FuGConfig,
+    FuGSerialCommunication,
+    FuGSerialCommunicationConfig,
+    FuGError,
+    FuGErrorcodes,
+    FuGDigitalVal,
+    FuGTerminators,
+    FuGPolarities,
+    FuGReadbackChannels,
+    FuGMonitorModes,
+    FuGRampModes,
+)
+from .heinzinger import (  # noqa: F401
+    HeinzingerDI,
+    HeinzingerPNC,
+    HeinzingerConfig,
+    HeinzingerPNCError,
+    HeinzingerPNCMaxVoltageExceededException,
+    HeinzingerPNCMaxCurrentExceededException,
+    HeinzingerPNCDeviceNotRecognizedException,
+    HeinzingerSerialCommunication,
+    HeinzingerSerialCommunicationConfig,
+)
+
+try:
+    from .labjack import (  # noqa: F401
+        LabJack,
+        LabJackError,
+        LabJackIdentifierDIOError,
+    )
+except (ImportError, ModuleNotFoundError):
+    import warnings
+
+    warnings.warn(
+        "\n\n  "
+        "To use LabJack device controller or related utilities install LJM Library and"
+        "\n  "
+        "install the hvl_ccb library with a 'labjack' extra feature:"
+        "\n\n  "
+        "    pip install hvl_ccb[labjack]"
+        "\n\n"
+    )
+
+from .lauda import (  # noqa: F401
+    LaudaProRp245eTcpCommunicationConfig,
+    LaudaProRp245eTcpCommunication,
+    LaudaProRp245eConfig,
+    LaudaProRp245e,
+)
+from .mbw973 import (  # noqa: F401
+    MBW973,
+    MBW973Config,
+    MBW973ControlRunningException,
+    MBW973PumpRunningException,
+    MBW973Error,
+    MBW973SerialCommunication,
+    MBW973SerialCommunicationConfig,
+)
+from .newport import (  # noqa: F401
+    NewportSMC100PP,
+    NewportSMC100PPConfig,
+    NewportStates,
+    NewportSMC100PPSerialCommunication,
+    NewportSMC100PPSerialCommunicationConfig,
+    NewportConfigCommands,
+    NewportMotorError,
+    NewportControllerError,
+    NewportSerialCommunicationError,
+    NewportUncertainPositionError,
+    NewportMotorPowerSupplyWasCutError,
+)
+from .pfeiffer_tpg import (  # noqa: F401
+    PfeifferTPG,
+    PfeifferTPGConfig,
+    PfeifferTPGSerialCommunication,
+    PfeifferTPGSerialCommunicationConfig,
+    PfeifferTPGError,
+)
+if sys.platform == 'darwin':
+    import warnings
+
+    warnings.warn("\n\n  PicoSDK is not available for Darwin OSs\n")
+else:
+    try:
+        from .picotech_pt104 import (  # noqa: F401
+            Pt104,
+            Pt104ChannelConfig,
+            Pt104CommunicationType,
+            Pt104DeviceConfig,
+        )
+    except (ImportError, ModuleNotFoundError):
+        import warnings
+
+        warnings.warn(
+            "\n\n  "
+            "To use PicoTech PT-104 device controller or related utilities install"
+            "\n  "
+            "PicoSDK and install the hvl_ccb library with a 'picotech' extra feature:"
+            "\n\n  "
+            "    $ pip install hvl_ccb[picotech]"
+            "\n\n"
+        )
+
+from .rs_rto1024 import (  # noqa: F401
+    RTO1024,
+    RTO1024Error,
+    RTO1024Config,
+    RTO1024VisaCommunication,
+    RTO1024VisaCommunicationConfig,
+)
+from .se_ils2t import (  # noqa: F401
+    ILS2T,
+    ILS2TConfig,
+    ILS2TException,
+    ILS2TModbusTcpCommunication,
+    ILS2TModbusTcpCommunicationConfig,
+    IoScanningModeValueError,
+    ScalingFactorValueError,
+)
+from .sst_luminox import (  # noqa: F401
+    Luminox,
+    LuminoxConfig,
+    LuminoxSerialCommunication,
+    LuminoxSerialCommunicationConfig,
+    LuminoxMeasurementType,
+    LuminoxMeasurementTypeError,
+    LuminoxOutputMode,
+    LuminoxOutputModeError,
+)
+from .visa import (  # noqa: F401
+    VisaDevice,
+    VisaDeviceConfig,
+)
+
+if sys.platform == 'darwin':
+    import warnings
+
+    warnings.warn("\n\n  LibTiePie SDK is not available for Darwin OSs\n")
+else:
+    try:
+        from .tiepie.generator import (  # noqa: F401
+            TiePieGeneratorConfig,
+            TiePieGeneratorSignalType,
+            TiePieGeneratorMixin,
+        )
+        from .tiepie.i2c import (  # noqa: F401
+            TiePieI2CHostConfig,
+            TiePieI2CHostMixin,
+        )
+        from .tiepie.oscilloscope import (  # noqa: F401
+            TiePieOscilloscope,
+            TiePieOscilloscopeConfig,
+            TiePieOscilloscopeResolution,
+            TiePieOscilloscopeAutoResolutionModes,
+        )
+        from .tiepie.base import (  # noqa: F401
+            TiePieDeviceConfig,
+            TiePieDeviceType,
+            TiePieError,
+            get_device_by_serial_number,
+            _verify_via_libtiepie,
+        )
+        from .tiepie.channel import (  # noqa: F401
+            TiePieOscilloscopeChannelCoupling,
+            TiePieOscilloscopeChannelConfig,
+            TiePieOscilloscopeRange,
+            TiePieOscilloscopeTriggerKind,
+            TiePieOscilloscopeTriggerLevelMode,
+        )
+        from .tiepie.device import (  # noqa: F401
+            TiePieHS5,
+            TiePieHS6,
+            TiePieWS5,
+        )
+    except (ImportError, ModuleNotFoundError):
+        import warnings
+
+        warnings.warn(
+            "\n\n  "
+            "To use TiePie devices controllers or related utilities install LibTiePie"
+            "\n  "
+            "and install the hvl_ccb library with a 'tiepie' extra feature:"
+            "\n\n  "
+            "    $ pip install hvl_ccb[tiepie]"
+            "\n\n"
+        )
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/base.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/base.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,295 +1,300 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Module with base classes for devices.
-"""
-
-import logging
-from abc import ABC, abstractmethod
-from typing import Dict, Type, List, Tuple, Union
-
-from ..comm import CommunicationProtocol
-from ..configuration import ConfigurationMixin, configdataclass
-
-logger = logging.getLogger(__name__)
-
-
-class DeviceExistingException(Exception):
-    """
-    Exception to indicate that a device with that name already exists.
-    """
-
-    pass
-
-
-class DeviceFailuresException(Exception):
-    """
-    Exception to indicate that one or several devices failed.
-    """
-
-    def __init__(self, failures: Dict[str, Exception], *args):
-        super().__init__(failures)
-        self.failures: Dict[str, Exception] = failures
-        """A dictionary of named devices failures (exceptions).
-        """
-
-
-@configdataclass
-class EmptyConfig:
-    """
-    Empty configuration dataclass that is the default configuration for a Device.
-    """
-
-    pass
-
-
-class Device(ConfigurationMixin, ABC):
-    """
-    Base class for devices. Implement this class for a concrete device,
-    such as measurement equipment or voltage sources.
-
-    Specifies the methods to implement for a device.
-    """
-
-    def __init__(self, dev_config=None):
-        """
-        Constructor for Device.
-        """
-
-        super().__init__(dev_config)
-
-    @abstractmethod
-    def start(self) -> None:
-        """
-        Start or restart this Device. To be implemented in the subclass.
-        """
-
-    @abstractmethod
-    def stop(self) -> None:
-        """
-        Stop this Device. To be implemented in the subclass.
-        """
-
-    def __enter__(self):
-        self.start()
-        return self
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        self.stop()
-
-    @staticmethod
-    def config_cls():
-        return EmptyConfig
-
-
-class DeviceSequenceMixin(ABC):
-    """
-    Mixin that can be used on a device or other classes to provide facilities for
-    handling multiple devices in a sequence.
-    """
-
-    def __init__(self, devices: Dict[str, Device]):
-        """
-        Constructor for the DeviceSequenceMixin.
-
-        :param devices: is a dictionary of devices to be added to this sequence.
-        """
-
-        super().__init__()
-
-        self._devices: Dict[str, Device] = {}
-        for (name, device) in devices.items():
-            self.add_device(name, device)
-
-        self.devices_failed_start: Dict[str, Device] = dict()
-        """Dictionary of named device instances from the sequence for which the most
-        recent `start()` attempt failed.
-
-        Empty if `stop()` was called last; cf. `devices_failed_stop`."""
-        self.devices_failed_stop: Dict[str, Device] = dict()
-        """Dictionary of named device instances from the sequence for which the most
-        recent `stop()` attempt failed.
-
-        Empty if `start()` was called last; cf. `devices_failed_start`."""
-
-    def __getattribute__(self, item: str) -> Union[Device, object]:
-        """
-        Gets Device from the sequence or object's attribute.
-
-        :param item: Item name to get
-        :return: Device or object's attribute.
-        """
-        if item != "_devices" and item in self._devices:
-            return self.get_device(item)
-        return super().__getattribute__(item)
-
-    def __eq__(self, other):
-        return (
-            isinstance(other, DeviceSequenceMixin) and self._devices == other._devices
-        )
-
-    def get_devices(self) -> List[Tuple[str, Device]]:
-        """
-        Get list of name, device pairs according to current sequence.
-
-        :return: A list of tuples with name and device each.
-        """
-        return list(self._devices.items())
-
-    def get_device(self, name: str) -> Device:
-        """
-        Get a device by name.
-
-        :param name: is the name of the device.
-        :return: the device object from this sequence.
-        """
-
-        return self._devices.get(name)  # type: ignore
-
-    def add_device(self, name: str, device: Device) -> None:
-        """
-        Add a new device to the device sequence.
-
-        :param name: is the name of the device.
-        :param device: is the instantiated Device object.
-        :raise DeviceExistingException:
-        """
-
-        if name in self._devices:
-            raise DeviceExistingException
-
-        # disallow over-shadowing via ".DEVICE_NAME" lookup
-        if hasattr(self, name):
-            raise ValueError(
-                f"This sequence already has an attribute called"
-                f" {name}. Use different name for this device."
-            )
-
-        self._devices[name] = device
-
-    def remove_device(self, name: str) -> Device:
-        """
-        Remove a device from this sequence and return the device object.
-
-        :param name: is the name of the device.
-        :return: device object or `None` if such device was not in the sequence.
-        :raises ValueError: when device with given name was not found
-        """
-
-        if name not in self._devices:
-            raise ValueError(f'No device named "{name}" in this sequence.')
-
-        if name in self.devices_failed_start:
-            self.devices_failed_start.pop(name)
-        elif name in self.devices_failed_stop:
-            self.devices_failed_stop.pop(name)
-
-        return self._devices.pop(name)
-
-    def start(self) -> None:
-        """
-        Start all devices in this sequence in their added order.
-
-        :raises DeviceFailuresException: if one or several devices failed to start
-        """
-
-        # reset the failure dicts
-        failures = dict()
-        self.devices_failed_start = dict()
-        self.devices_failed_stop = dict()
-
-        for name, device in self._devices.items():
-            try:
-                device.start()
-            except Exception as e:
-                logger.error(f"Could not start {name}: ", exc_info=e)
-                failures[name] = e
-                self.devices_failed_start[name] = device
-        if failures:
-            raise DeviceFailuresException(failures)
-
-    def stop(self) -> None:
-        """
-        Stop all devices in this sequence in their reverse order.
-
-        :raises DeviceFailuresException: if one or several devices failed to stop
-        """
-
-        # reset the failure dicts
-        failures: Dict[str, Exception] = dict()
-        self.devices_failed_start = dict()
-        self.devices_failed_stop = dict()
-
-        for name, device in self._devices.items():
-            try:
-                device.stop()
-            except Exception as e:
-                logger.error(f"Could not start {name}: ", exc_info=e)
-                failures[name] = e
-                self.devices_failed_stop[name] = device
-        if failures:
-            raise DeviceFailuresException(failures)
-
-
-class SingleCommDevice(Device, ABC):
-    """
-    Base class for devices with a single communication protocol.
-    """
-
-    # Omitting typing hint `com: CommunicationProtocol` on purpose
-    # to enable PyCharm autocompletion for subtypes.
-    def __init__(self, com, dev_config=None) -> None:
-        """
-        Constructor for Device. Links the communication protocol and provides a
-        configuration for the device.
-
-        :param com: Communication protocol to be used with
-            this device. Can be of type: - CommunicationProtocol instance, - dictionary
-            with keys and values to be used as configuration together with the
-            default communication protocol, or - @configdataclass to be used together
-            with the default communication protocol.
-
-        :param dev_config: configuration of the device. Can be:
-            - None: empty configuration is used, or the specified config_cls()
-            - @configdataclass decorated class
-            - Dictionary, which is then used to instantiate the specified config_cls()
-        """
-
-        super().__init__(dev_config)
-
-        if isinstance(com, CommunicationProtocol):
-            self._com = com
-        else:
-            self._com = self.default_com_cls()(com)
-
-    @staticmethod
-    @abstractmethod
-    def default_com_cls() -> Type[CommunicationProtocol]:
-        """
-        Get the class for the default communication protocol used with this device.
-
-        :return: the type of the standard communication protocol for this device
-        """
-
-    @property
-    def com(self):
-        """
-        Get the communication protocol of this device.
-
-        :return: an instance of CommunicationProtocol subtype
-        """
-        return self._com
-
-    def start(self) -> None:
-        """
-        Open the associated communication protocol.
-        """
-
-        self.com.open()
-
-    def stop(self) -> None:
-        """
-        Close the associated communication protocol.
-        """
-
-        self.com.close()
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Module with base classes for devices.
+"""
+
+import logging
+from abc import ABC, abstractmethod
+from typing import Dict, Type, List, Tuple, Union
+
+from ..comm import CommunicationProtocol
+from ..configuration import ConfigurationMixin, configdataclass
+from hvl_ccb.exception import CCBException
+
+logger = logging.getLogger(__name__)
+
+
+class DeviceException(CCBException):
+    pass
+
+
+class DeviceExistingException(DeviceException):
+    """
+    Exception to indicate that a device with that name already exists.
+    """
+
+    pass
+
+
+class DeviceFailuresException(DeviceException):
+    """
+    Exception to indicate that one or several devices failed.
+    """
+
+    def __init__(self, failures: Dict[str, Exception], *args):
+        super().__init__(failures)
+        self.failures: Dict[str, Exception] = failures
+        """A dictionary of named devices failures (exceptions).
+        """
+
+
+@configdataclass
+class EmptyConfig:
+    """
+    Empty configuration dataclass that is the default configuration for a Device.
+    """
+
+    pass
+
+
+class Device(ConfigurationMixin, ABC):
+    """
+    Base class for devices. Implement this class for a concrete device,
+    such as measurement equipment or voltage sources.
+
+    Specifies the methods to implement for a device.
+    """
+
+    def __init__(self, dev_config=None):
+        """
+        Constructor for Device.
+        """
+
+        super().__init__(dev_config)
+
+    @abstractmethod
+    def start(self) -> None:
+        """
+        Start or restart this Device. To be implemented in the subclass.
+        """
+
+    @abstractmethod
+    def stop(self) -> None:
+        """
+        Stop this Device. To be implemented in the subclass.
+        """
+
+    def __enter__(self):
+        self.start()
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.stop()
+
+    @staticmethod
+    def config_cls():
+        return EmptyConfig
+
+
+class DeviceSequenceMixin(ABC):
+    """
+    Mixin that can be used on a device or other classes to provide facilities for
+    handling multiple devices in a sequence.
+    """
+
+    def __init__(self, devices: Dict[str, Device]):
+        """
+        Constructor for the DeviceSequenceMixin.
+
+        :param devices: is a dictionary of devices to be added to this sequence.
+        """
+
+        super().__init__()
+
+        self._devices: Dict[str, Device] = {}
+        for (name, device) in devices.items():
+            self.add_device(name, device)
+
+        self.devices_failed_start: Dict[str, Device] = dict()
+        """Dictionary of named device instances from the sequence for which the most
+        recent `start()` attempt failed.
+
+        Empty if `stop()` was called last; cf. `devices_failed_stop`."""
+        self.devices_failed_stop: Dict[str, Device] = dict()
+        """Dictionary of named device instances from the sequence for which the most
+        recent `stop()` attempt failed.
+
+        Empty if `start()` was called last; cf. `devices_failed_start`."""
+
+    def __getattribute__(self, item: str) -> Union[Device, object]:
+        """
+        Gets Device from the sequence or object's attribute.
+
+        :param item: Item name to get
+        :return: Device or object's attribute.
+        """
+        if item != "_devices" and item in self._devices:
+            return self.get_device(item)
+        return super().__getattribute__(item)
+
+    def __eq__(self, other):
+        return (
+            isinstance(other, DeviceSequenceMixin) and self._devices == other._devices
+        )
+
+    def get_devices(self) -> List[Tuple[str, Device]]:
+        """
+        Get list of name, device pairs according to current sequence.
+
+        :return: A list of tuples with name and device each.
+        """
+        return list(self._devices.items())
+
+    def get_device(self, name: str) -> Device:
+        """
+        Get a device by name.
+
+        :param name: is the name of the device.
+        :return: the device object from this sequence.
+        """
+
+        return self._devices.get(name)  # type: ignore
+
+    def add_device(self, name: str, device: Device) -> None:
+        """
+        Add a new device to the device sequence.
+
+        :param name: is the name of the device.
+        :param device: is the instantiated Device object.
+        :raise DeviceExistingException:
+        """
+
+        if name in self._devices:
+            raise DeviceExistingException
+
+        # disallow over-shadowing via ".DEVICE_NAME" lookup
+        if hasattr(self, name):
+            raise ValueError(
+                f"This sequence already has an attribute called"
+                f" {name}. Use different name for this device."
+            )
+
+        self._devices[name] = device
+
+    def remove_device(self, name: str) -> Device:
+        """
+        Remove a device from this sequence and return the device object.
+
+        :param name: is the name of the device.
+        :return: device object or `None` if such device was not in the sequence.
+        :raises ValueError: when device with given name was not found
+        """
+
+        if name not in self._devices:
+            raise ValueError(f'No device named "{name}" in this sequence.')
+
+        if name in self.devices_failed_start:
+            self.devices_failed_start.pop(name)
+        elif name in self.devices_failed_stop:
+            self.devices_failed_stop.pop(name)
+
+        return self._devices.pop(name)
+
+    def start(self) -> None:
+        """
+        Start all devices in this sequence in their added order.
+
+        :raises DeviceFailuresException: if one or several devices failed to start
+        """
+
+        # reset the failure dicts
+        failures = dict()
+        self.devices_failed_start = dict()
+        self.devices_failed_stop = dict()
+
+        for name, device in self._devices.items():
+            try:
+                device.start()
+            except Exception as e:
+                logger.error(f"Could not start {name}: ", exc_info=e)
+                failures[name] = e
+                self.devices_failed_start[name] = device
+        if failures:
+            raise DeviceFailuresException(failures)
+
+    def stop(self) -> None:
+        """
+        Stop all devices in this sequence in their reverse order.
+
+        :raises DeviceFailuresException: if one or several devices failed to stop
+        """
+
+        # reset the failure dicts
+        failures: Dict[str, Exception] = dict()
+        self.devices_failed_start = dict()
+        self.devices_failed_stop = dict()
+
+        for name, device in self._devices.items():
+            try:
+                device.stop()
+            except Exception as e:
+                logger.error(f"Could not start {name}: ", exc_info=e)
+                failures[name] = e
+                self.devices_failed_stop[name] = device
+        if failures:
+            raise DeviceFailuresException(failures)
+
+
+class SingleCommDevice(Device, ABC):
+    """
+    Base class for devices with a single communication protocol.
+    """
+
+    # Omitting typing hint `com: CommunicationProtocol` on purpose
+    # to enable PyCharm autocompletion for subtypes.
+    def __init__(self, com, dev_config=None) -> None:
+        """
+        Constructor for Device. Links the communication protocol and provides a
+        configuration for the device.
+
+        :param com: Communication protocol to be used with
+            this device. Can be of type: - CommunicationProtocol instance, - dictionary
+            with keys and values to be used as configuration together with the
+            default communication protocol, or - @configdataclass to be used together
+            with the default communication protocol.
+
+        :param dev_config: configuration of the device. Can be:
+            - None: empty configuration is used, or the specified config_cls()
+            - @configdataclass decorated class
+            - Dictionary, which is then used to instantiate the specified config_cls()
+        """
+
+        super().__init__(dev_config)
+
+        if isinstance(com, CommunicationProtocol):
+            self._com = com
+        else:
+            self._com = self.default_com_cls()(com)
+
+    @staticmethod
+    @abstractmethod
+    def default_com_cls() -> Type[CommunicationProtocol]:
+        """
+        Get the class for the default communication protocol used with this device.
+
+        :return: the type of the standard communication protocol for this device
+        """
+
+    @property
+    def com(self):
+        """
+        Get the communication protocol of this device.
+
+        :return: an instance of CommunicationProtocol subtype
+        """
+        return self._com
+
+    def start(self) -> None:
+        """
+        Open the associated communication protocol.
+        """
+
+        self.com.open()
+
+    def stop(self) -> None:
+        """
+        Close the associated communication protocol.
+        """
+
+        self.com.close()
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/crylas.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/crylas.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,1003 +1,1002 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device classes for a CryLas pulsed laser controller and a CryLas laser attenuator,
-using serial communication.
-
-There are three modes of operation for the laser
-1. Laser-internal hardware trigger (default): fixed to 20 Hz and max energy per pulse.
-2. Laser-internal software trigger (for diagnosis only).
-3. External trigger: required for arbitrary pulse energy or repetition rate. Switch to
-"external" on the front panel of laser controller for using option 3.
-
-After switching on the laser with laser_on(), the system must stabilize
-for some minutes. Do not apply abrupt changes of pulse energy or repetition rate.
-
-Manufacturer homepage:
-https://www.crylas.de/products/pulsed_laser.html
-"""
-
-import logging
-import math
-import re
-import time
-from datetime import datetime
-from threading import Event
-from typing import Union, Tuple, Optional, Callable
-
-from aenum import Enum, IntEnum
-
-from .base import SingleCommDevice
-from .utils import Poller
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class CryLasLaserSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for CryLas laser is 19200 baud
-    baudrate: int = 19200
-
-    #: CryLas laser does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: CryLas laser uses one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is LF
-    terminator: bytes = b"\n"
-
-    #: use 10 seconds timeout as default (a long timeout is needed!)
-    timeout: Number = 10
-
-
-class CryLasLaserSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for the CryLas laser controller.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    @staticmethod
-    def config_cls():
-        return CryLasLaserSerialCommunicationConfig
-
-    READ_TEXT_SKIP_PREFIXES = (">", "MODE:")
-    """Prefixes of lines that are skipped when read from the serial port."""
-
-    def read(
-        self,
-    ) -> str:
-        """
-        Read first line of text from the serial port that does not start with any of
-        `self.READ_TEXT_SKIP_PREFIXES`.
-
-        :return: String read from the serial port; `''` if there was nothing to read.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        with self.access_lock:
-            line = super().read()
-            while line.startswith(self.READ_TEXT_SKIP_PREFIXES):
-                logger.debug(f'Laser com: "{line.rstrip()}" SKIPPED')
-                line = super().read_text()
-            logger.debug(f'Laser com: "{line.rstrip()}"')
-            return line
-
-    def query(self, cmd: str, prefix: str, post_cmd: str = None) -> str:
-        """
-        Send a command, then read the com until a line starting with prefix,
-        or an empty line, is found. Returns the line in question.
-
-        :param cmd: query message to send to the device
-        :param prefix: start of the line to look for in the device answer
-        :param post_cmd: optional additional command to send after the query
-        :return: line in question as a string
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        # TODO: Make use of SyncCommunicationProtocol
-
-        with self.access_lock:
-            # send the command
-            self.write(cmd)
-            # read the com until the prefix or an empty line is found
-            line = self.read().strip()
-            while line and not line.startswith(prefix):
-                line = self.read().strip()
-            if post_cmd is not None:
-                # send an optional post-command message to send to the device
-                self.write(post_cmd)
-            return line
-
-    def query_all(self, cmd: str, prefix: str):
-        """
-        Send a command, then read the com until a line starting with prefix,
-        or an empty line, is found. Returns a list of successive lines starting with
-        prefix.
-
-        :param cmd: query message to send to the device
-        :param prefix: start of the line to look for in the device answer
-        :return: line in question as a string
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        # TODO: Make use of SyncCommunicationProtocol
-
-        with self.access_lock:
-            # send the command
-            self.write(cmd)
-            # read the com until the prefix or an empty line is found
-            line = self.read().strip()
-            while line and not line.startswith(prefix):
-                line = self.read().strip()
-            answer = []
-            while line.startswith(prefix):
-                answer.append(line)
-                line = self.read().strip()
-            return answer
-
-
-class CryLasLaserShutterStatus(Enum):
-    """
-    Status of the CryLas laser shutter
-    """
-
-    CLOSED = 0
-    OPENED = 1
-
-
-@configdataclass
-class CryLasLaserConfig:
-    """
-    Device configuration dataclass for the CryLas laser controller.
-    """
-
-    # status of the shutter
-    ShutterStatus = CryLasLaserShutterStatus
-
-    # calibration factor for the pulse energy
-    calibration_factor: Number = 4.35
-
-    # polling period (s) to check back on the laser status if not ready
-    # it should be longer than the communication timeout
-    polling_period: Union[int, float] = 12
-
-    # timeout (s) when polling the laser status, CryLasLaserError is raised on timeout
-    polling_timeout: Number = 300
-
-    # automatically turn on the laser when ready
-    auto_laser_on: bool = True
-
-    # status of the shutter to be set on start
-    init_shutter_status: Union[
-        int, CryLasLaserShutterStatus
-    ] = CryLasLaserShutterStatus.CLOSED
-
-    def clean_values(self):
-        if self.calibration_factor <= 0:
-            raise ValueError("The calibration factor should be positive.")
-        if self.polling_period <= 0:
-            raise ValueError("The polling period should be positive.")
-        if self.polling_timeout <= 0:
-            raise ValueError("The polling timeout should be positive.")
-        self.force_value(
-            "init_shutter_status", self.ShutterStatus(self.init_shutter_status)
-        )
-
-
-class CryLasLaserPoller(Poller):
-    """
-    Poller class for polling the laser status until the laser is ready.
-
-    :raises CryLasLaserError: if the timeout is reached before the laser is ready
-    :raises SerialCommunicationIOError: when communication port is closed.
-    """
-
-    def __init__(
-        self,
-        spoll_handler: Callable,
-        check_handler: Callable,
-        check_laser_status_handler: Callable,
-        polling_delay_sec: Number = 0,
-        polling_interval_sec: Number = 1,
-        polling_timeout_sec: Optional[Number] = None,
-    ):
-        """
-        Initialize the polling helper.
-
-        :param spoll_handler: Polling function.
-        :param check_handler: Check polling results.
-        :param check_laser_status_handler: Check laser status.
-        :param polling_delay_sec: Delay before starting the polling, in seconds.
-        :param polling_interval_sec: Polling interval, in seconds.
-        """
-        super().__init__(
-            spoll_handler, polling_delay_sec, polling_interval_sec, polling_timeout_sec
-        )
-
-        self._check_handler = check_handler
-        self._check_laser_status_handler = check_laser_status_handler
-
-    def _if_poll_again(
-        self, stop_event: Event, delay_sec: Number, stop_time: Optional[Number]
-    ) -> bool:
-        """
-        Check if to poll again.
-
-        :param stop_event: Polling stop event.
-        :param delay_sec: Delay time (in seconds).
-        :param stop_time: Absolute stop time.
-        :return: `True` if another polling handler call is due, `False` otherwise.
-        """
-        if_poll_again = super()._if_poll_again(stop_event, delay_sec, stop_time)
-        is_laser_ready = self._check_laser_status_handler()
-
-        return if_poll_again and not is_laser_ready
-
-    def _poll_until_stop_or_timeout(self, stop_event: Event) -> Optional[object]:
-        """
-        Thread for polling until stopped, timed-out or the laser is ready.
-
-        :param stop_event: Event used to stop the polling
-        :return: Last result of the polling function call
-        """
-        last_result = super()._poll_until_stop_or_timeout(stop_event)
-
-        if stop_event.wait(0):
-            logger.info(f"[{datetime.now()}] Polling status: ... STOPPED")
-            return last_result
-        else:
-            self._check_handler()
-
-        return last_result
-
-
-class CryLasLaser(SingleCommDevice):
-    """
-    CryLas laser controller device class.
-    """
-
-    class LaserStatus(Enum):
-        """
-        Status of the CryLas laser
-        """
-
-        UNREADY_INACTIVE = 0
-        READY_INACTIVE = 1
-        READY_ACTIVE = 2
-
-        @property
-        def is_ready(self):
-            return self is not CryLasLaser.LaserStatus.UNREADY_INACTIVE
-
-        @property
-        def is_inactive(self):
-            return self is not CryLasLaser.LaserStatus.READY_ACTIVE
-
-    # status of the shutter
-    ShutterStatus = CryLasLaserShutterStatus
-
-    class AnswersShutter(Enum):
-        """
-        Standard answers of the CryLas laser controller to `'Shutter'` command passed
-        via `com`.
-        """
-
-        OPENED = "Shutter aktiv"
-        CLOSED = "Shutter inaktiv"
-
-    class AnswersStatus(Enum):
-        """
-        Standard answers of the CryLas laser controller to `'STATUS'` command passed
-        via `com`.
-        """
-
-        TEC1 = "STATUS: TEC1 Regulation ok"
-        TEC2 = "STATUS: TEC2 Regulation ok"
-        HEAD = "STATUS: Head ok"
-        READY = "STATUS: System ready"
-        ACTIVE = "STATUS: Laser active"
-        INACTIVE = "STATUS: Laser inactive"
-
-    class RepetitionRates(IntEnum):
-        """
-        Repetition rates for the internal software trigger in Hz
-        """
-
-        _init_ = "value send_value"
-        HARDWARE = 0, 0  # software trigger is disabled, hardware trigger is used
-        # instead (hardware trigger may be internal or external).
-        SOFTWARE_INTERNAL_TEN = 10, 1
-        SOFTWARE_INTERNAL_TWENTY = 20, 2
-        SOFTWARE_INTERNAL_SIXTY = 60, 3
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # laser status
-        self.laser_status = self.LaserStatus.UNREADY_INACTIVE
-
-        # shutter status
-        self.shutter_status = None
-
-        # command repetition rate
-        self.repetition_rate = None
-
-        # command pulse energy (micro joule)
-        self._target_pulse_energy = None
-
-        # thread that polls the laser status until it is ready
-        self._status_poller = None
-
-    @property
-    def target_pulse_energy(self):
-        return self._target_pulse_energy
-
-    @staticmethod
-    def default_com_cls():
-        return CryLasLaserSerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return CryLasLaserConfig
-
-    def start(self) -> None:
-        """
-        Opens the communication protocol and configures the device.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened
-        """
-
-        logger.info("Starting device " + str(self))
-
-        # open the com
-        super().start()
-
-        # set the init shutter status
-        self.set_init_shutter_status()
-        # check if the laser is ready to be turned on
-        self.update_laser_status()
-        if not self.laser_status.is_ready:
-            logger.info("Laser not ready yet.")
-            # optionally, block execution until laser is ready
-            if self.config.auto_laser_on and not self._is_polling():
-                self._start_polling()
-        elif self.config.auto_laser_on:
-            # turn on the laser
-            self.laser_on()
-
-    def _start_polling(self):
-        """
-        Start polling laser status.
-        """
-        logger.info("Start polling laser status.")
-        self._status_poller = CryLasLaserPoller(
-            spoll_handler=self.update_laser_status,
-            check_handler=self._after_polling_check_status,
-            check_laser_status_handler=self._check_laser_status_handler,
-            polling_delay_sec=self.config.polling_period,
-            polling_interval_sec=self.config.polling_period,
-            polling_timeout_sec=self.config.polling_timeout,
-        )
-        self._status_poller.start_polling()
-
-    def _check_laser_status_handler(self) -> bool:
-        """
-        Checks whether the laser status is ready.
-        """
-        return self.laser_status.is_ready
-
-    def _after_polling_check_status(self) -> None:
-        """
-        Thread for polling the laser status until the laser is ready.
-
-        :raises CryLasLaserError: if the timeout is reached before the laser is ready
-        :raises SerialCommunicationIOError: when communication port is closed.
-        """
-
-        if not self.laser_status.is_ready:
-            err_msg = "Laser is not yet ready but status polling timed out."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-
-        logger.info(f"[{datetime.now()}] Polling status: ... DONE")
-        if self.config.auto_laser_on:
-            self.laser_on()
-
-    def _wait_for_polling_result(self):
-        """
-        Wait for until polling function returns a result as well as any exception that
-        might have been raised within a thread.
-
-        :return: polling function result
-        :raises: polling function errors
-        """
-        return self._status_poller.wait_for_polling_result()
-
-    def _stop_polling(self):
-        """
-        Stop polling laser status.
-
-        :return: polling function result
-        :raises: polling function errors
-        """
-        # use the event to stop the thread
-        logger.info("Stop polling laser status.")
-        self._status_poller.stop_polling()
-        return self._wait_for_polling_result()
-
-    def _is_polling(self) -> bool:
-        """
-        Check if device status is being polled.
-
-        :return: `True` when polling thread is set and alive
-        """
-        return self._status_poller is not None and self._status_poller.is_polling()
-
-    def wait_until_ready(self) -> None:
-        """
-        Block execution until the laser is ready
-
-        :raises CryLasLaserError: if the polling thread stops before the laser is ready
-        """
-
-        if not self.laser_status.is_ready:
-            if not self._is_polling():
-                self._start_polling()
-            logger.info("Waiting until the laser is ready...")
-            self._wait_for_polling_result()
-        else:
-            logger.info("No need waiting, the laser is already ready.")
-
-    def stop(self) -> None:
-        """
-        Stops the device and closes the communication protocol.
-
-        :raises SerialCommunicationIOError: if com port is closed unexpectedly
-        :raises CryLasLaserError: if laser_off() or close_shutter() fail
-        """
-
-        if self.com.is_open:
-            # turn off the laser
-            self.laser_off()
-            # close the laser shutter
-            self.close_shutter()
-            # cancel the polling thread in case still running
-            if self._is_polling():
-                self._stop_polling()
-                logger.info("The laser polling thread was stopped.")
-            # close the com
-            super().stop()
-        else:
-            logger.warning("Could not turn off the laser, com was already closed.")
-
-    def update_laser_status(self) -> None:
-        """
-        Update the laser status to `LaserStatus.NOT_READY` or `LaserStatus.INACTIVE` or
-        `LaserStatus.ACTIVE`.
-
-        Note: laser never explicitly says that it is not ready  (
-        `LaserStatus.NOT_READY`) in response to `'STATUS'` command. It only says
-        that it is ready (heated-up and implicitly inactive/off) or active (on). If
-        it's not either of these then the answer is `Answers.HEAD`. Moreover,
-        the only time the laser explicitly says that its status is inactive (
-        `Answers.INACTIVE`) is after issuing a 'LASER OFF' command.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        # query the status
-        answer_list = self.com.query_all("STATUS", "STATUS:")
-        # analyze the answer
-        if not answer_list:
-            err_msg = "Command to query the laser status did not return an answer."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            # at least one line in answer_list
-            for line in answer_list:
-                answer = self.AnswersStatus(line)
-                if answer in (
-                    self.AnswersStatus.TEC1,
-                    self.AnswersStatus.TEC2,
-                    self.AnswersStatus.HEAD,
-                ):
-                    new_status = self.LaserStatus.UNREADY_INACTIVE
-                    info_msg = "The laser is not ready."
-                elif answer is self.AnswersStatus.READY:
-                    new_status = self.LaserStatus.READY_INACTIVE
-                    info_msg = "The laser is ready."
-                elif answer is self.AnswersStatus.ACTIVE:
-                    new_status = self.LaserStatus.READY_ACTIVE
-                    info_msg = "The laser is on."
-                else:
-                    err_msg = f'Unexpected "STATUS" query response {answer.value}.'
-                    logger.error(err_msg)
-                    raise CryLasLaserError(err_msg)
-            self.laser_status = new_status
-            logger.info(info_msg)
-
-    def update_shutter_status(self) -> None:
-        """
-        Update the shutter status (OPENED or CLOSED)
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # query the status
-        answer = self.com.query("Shutter", "Shutter")
-        # analyse the answer
-        if not answer:
-            err_msg = "Command to query the shutter status did not return an answer."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            answer = self.AnswersShutter(answer)
-            if answer is self.AnswersShutter.CLOSED:
-                logger.info("The laser shutter is currently CLOSED.")
-                self.shutter_status = self.ShutterStatus.CLOSED
-            elif answer is self.AnswersShutter.OPENED:
-                logger.info("The laser shutter is currently OPENED.")
-                self.shutter_status = self.ShutterStatus.OPENED
-
-    def update_repetition_rate(self) -> None:
-        """
-        Query the laser repetition rate.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # query the repetition rate
-        answer = self.com.query("BOO IP", "Impuls=")
-        # analyse the answer
-        if not answer:
-            err_msg = "Querying the repetition rate did not return an answer."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        elif answer == "Impuls=disabled, extern Trigger":
-            logger.info(
-                "The laser is using a hardware trigger "
-                "(may be internal or external)."
-            )
-            self.repetition_rate = self.RepetitionRates.HARDWARE
-        elif answer.startswith("Impuls=enabled"):
-            match = re.search(r"\d+", answer)
-            if match is None:
-                err_msg = (
-                    f"Expected rate integer to follow 'Impuls=enabled' answer "
-                    f"in {answer} while querying the repetition."
-                )
-                logger.error(err_msg)
-                raise CryLasLaserError(err_msg)
-            rate = int(match.group(0))
-            self.repetition_rate = self.RepetitionRates(rate)
-            logger.info(
-                "The laser is using the internal " f"software trigger at {rate} Hz."
-            )
-
-    def update_target_pulse_energy(self) -> None:
-        """
-        Query the laser pulse energy.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # query the repetition rate
-        answer = self.com.query("BOO SE", "PD-Sollwert=")
-        # analyse the answer
-        if not answer:
-            err_msg = (
-                "Command to query the target pulse energy did not return an answer."
-            )
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            current_value = int(answer.split("=")[1])
-            current_energy = int(current_value * self.config.calibration_factor / 1000)
-            # update the pulse energy attribute
-            self._target_pulse_energy = current_energy
-            logger.info(f"The target pulse energy is {current_energy} uJ.")
-
-    def laser_on(self) -> None:
-        """
-        Turn the laser on.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserNotReadyError: if the laser is not ready to be turned on
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        if not self.laser_status.is_ready:
-            raise CryLasLaserNotReadyError("Laser not ready, cannot be turned on yet.")
-        else:
-            # send the command
-            answer = self.com.query("LASER ON", "STATUS: Laser")
-            # analyse the answer
-            if not answer or self.AnswersStatus(answer) != self.AnswersStatus.ACTIVE:
-                if not self.laser_status.is_inactive:
-                    logger.info("Laser is already on.")
-                else:
-                    err_msg = (
-                        f"Command to turn on the laser "
-                        f"{'failed' if answer else 'did not return an answer'}."
-                    )
-                    logger.error(err_msg)
-                    raise CryLasLaserError(err_msg)
-            else:
-                self.laser_status = self.LaserStatus.READY_ACTIVE
-                logger.info("Laser is turned on.")
-
-    def laser_off(self) -> None:
-        """
-        Turn the laser off.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # send the command
-        answer = self.com.query("LASER OFF", "STATUS: Laser")
-        # analyse the answer
-        if not answer or self.AnswersStatus(answer) != self.AnswersStatus.INACTIVE:
-            if self.laser_status.is_inactive:
-                logger.info("Laser is already off.")
-            else:
-                err_msg = (
-                    f"Command to turn off the laser "
-                    f"{'failed' if answer else 'did not return an answer'}."
-                )
-                logger.error(err_msg)
-                raise CryLasLaserError(err_msg)
-        else:
-            self.laser_status = self.LaserStatus.READY_INACTIVE
-            logger.info("Laser is turned off.")
-
-    def open_shutter(self) -> None:
-        """
-        Open the laser shutter.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # send the command
-        answer = self.com.query(
-            f"Shutter {self.config.ShutterStatus.OPENED.value}", "Shutter"
-        )
-        # analyse the answer
-        if not answer or self.AnswersShutter(answer) != self.AnswersShutter.OPENED:
-            err_msg = (
-                f"Opening laser shutter "
-                f"{'failed' if answer else 'did not return an answer'}."
-            )
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            logger.info("Opening laser shutter succeeded.")
-            self.shutter_status = self.ShutterStatus.OPENED
-
-    def close_shutter(self) -> None:
-        """
-        Close the laser shutter.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # send the command
-        answer = self.com.query(
-            f"Shutter {self.config.ShutterStatus.CLOSED.value}", "Shutter"
-        )
-        # analyse the answer
-        if not answer or self.AnswersShutter(answer) != self.AnswersShutter.CLOSED:
-            err_msg = (
-                f"Closing laser shutter "
-                f"{'failed' if answer else 'did not return an answer'}."
-            )
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            logger.info("Closing laser shutter succeeded.")
-            self.shutter_status = self.ShutterStatus.CLOSED
-
-    def set_init_shutter_status(self) -> None:
-        """
-        Open or close the shutter, to match the configured shutter_status.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        self.update_shutter_status()
-        if self.config.init_shutter_status != self.shutter_status:
-            if self.config.init_shutter_status == self.ShutterStatus.CLOSED:
-                self.close_shutter()
-            elif self.config.init_shutter_status == self.ShutterStatus.OPENED:
-                self.open_shutter()
-
-    def get_pulse_energy_and_rate(self) -> Tuple[int, int]:
-        """
-        Use the debug mode, return the measured pulse energy and rate.
-
-        :return: (energy in micro joule, rate in Hz)
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if the device does not answer the query
-        """
-
-        # send the command (enter the debug mode)
-        answer = self.com.query("DB1", "IST:", "DB0")
-        if not answer:
-            err_msg = "Command to find laser energy and rate did not return an answer."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            # the answer should look like 'IST: LDTemp=x, NLOTemp=x, CaseTemp=x,
-            # PD=x, D_I= x, freq=x, LDE=x, RegOFF=x' where x are integers
-            # find the values of interest
-            values = re.findall(r"\d+", answer)
-            energy = int(int(values[3]) * self.config.calibration_factor / 1000)
-            rate = int(values[5])
-            logger.info(f"Laser energy: {energy} uJ, repetition rate: {rate} Hz.")
-            return energy, rate
-
-    def set_repetition_rate(self, rate: Union[int, RepetitionRates]) -> None:
-        """
-        Sets the repetition rate of the internal software trigger.
-
-        :param rate: frequency (Hz) as an integer
-        :raises ValueError: if rate is not an accepted value in RepetitionRates Enum
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if success is not confirmed by the device
-        """
-
-        # check if the value is ok
-        if not isinstance(rate, self.RepetitionRates):
-            try:
-                rate = self.RepetitionRates(rate)
-            except ValueError as e:
-                logger.error(str(e), exc_info=e)
-                raise e
-        # send the corresponding value to the controller
-        answer = self.com.query(f"BOO IP{rate.send_value}", "Impuls=")
-        # check the success of the command
-        if rate != self.RepetitionRates.HARDWARE:
-            # check whether the expected answer is obtained
-            if answer != f"Impuls=enabled {rate}Hz":
-                err_msg = (
-                    f"Setting the repetition rate failed. Controller answered:"
-                    f" {answer}."
-                )
-                logger.error(err_msg)
-                raise CryLasLaserError(err_msg)
-            else:
-                logger.info(f"Laser internal software trigger set to {rate.value} Hz")
-        else:
-            # For the internal hardware trigger rate, there is no way to check success
-            logger.info("Using laser internal hardware trigger.")
-        # update the repetition rate attribute
-        self.repetition_rate = rate
-
-    def set_pulse_energy(self, energy: int) -> None:
-        """
-        Sets the energy of pulses (works only with external hardware trigger).
-        Proceed with small energy steps, or the regulation may fail.
-
-        :param energy: energy in micro joule
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasLaserError: if the device does not confirm success
-        """
-
-        # convert the input value into the required command value
-        command_value = int(energy * 1000 / self.config.calibration_factor)
-        # send the command
-        answer = self.com.query(f"BOO SE {command_value}", "PD-Sollwert=")
-        # analyse the answer
-        if not answer:
-            err_msg = "Command to set the pulse energy did not return an answer."
-            logger.error(err_msg)
-            raise CryLasLaserError(err_msg)
-        else:
-            current_value = int(answer.split("=")[1])
-            current_energy = int(current_value * self.config.calibration_factor / 1000)
-            # update the pulse energy attribute
-            self._target_pulse_energy = current_energy
-            if current_value != command_value:
-                message = (
-                    f"Command to set the pulse energy failed. "
-                    f"The pulse energy is currently set to {current_energy} "
-                    f"micro joule. Setting a different value is only possible "
-                    f"when using an external hardware trigger."
-                )
-                logger.error(message)
-                raise CryLasLaserError(message)
-            else:
-                logger.info(f"Successfully set pulse energy to {energy}")
-
-
-class CryLasLaserError(Exception):
-    """
-    General error with the CryLas Laser.
-    """
-
-    pass
-
-
-class CryLasLaserNotReadyError(CryLasLaserError):
-    """
-    Error when trying to turn on the CryLas Laser before it is ready.
-    """
-
-    pass
-
-
-@configdataclass
-class CryLasAttenuatorSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for CryLas attenuator is 9600 baud
-    baudrate: int = 9600
-
-    #: CryLas attenuator does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: CryLas attenuator uses one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: No terminator
-    terminator: bytes = b""
-
-    #: use 3 seconds timeout as default
-    timeout: Number = 3
-
-
-class CryLasAttenuatorSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for
-    the CryLas attenuator.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    @staticmethod
-    def config_cls():
-        return CryLasAttenuatorSerialCommunicationConfig
-
-
-@configdataclass
-class CryLasAttenuatorConfig:
-    """
-    Device configuration dataclass for CryLas attenuator.
-    """
-
-    # initial/default attenuation value which is set on start()
-    init_attenuation: Number = 0
-    response_sleep_time: Number = 1
-
-    def clean_values(self):
-        if not 0 <= self.init_attenuation <= 100:
-            raise ValueError("Attenuation should be " "between 0 and 100 included.")
-        if self.response_sleep_time <= 0:
-            raise ValueError("Response sleep time should be positive.")
-
-
-class CryLasAttenuator(SingleCommDevice):
-    """
-    Device class for the CryLas laser attenuator.
-    """
-
-    def __init__(self, com, dev_config=None):
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # attenuation of the laser light in percent (not determined yet)
-        self._attenuation = None
-
-    @staticmethod
-    def default_com_cls():
-        return CryLasAttenuatorSerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return CryLasAttenuatorConfig
-
-    @property
-    def attenuation(self) -> Number:
-        return self._attenuation
-
-    @property
-    def transmission(self) -> Number:
-        return 100 - self._attenuation
-
-    def start(self) -> None:
-        """
-        Open the com, apply the config value 'init_attenuation'
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened
-        """
-
-        super().start()
-        self.set_init_attenuation()
-
-    def set_init_attenuation(self):
-        """
-        Sets the attenuation to its configured initial/default value
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.set_attenuation(self.config.init_attenuation)
-
-    def set_attenuation(self, percent: Number) -> None:
-        """
-        Set the percentage of attenuated light (inverse of set_transmission).
-        :param percent: percentage of attenuation, number between 0 and 100
-        :raises ValueError: if param percent not between 0 and 100
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasAttenuatorError: if the device does not confirm success
-        """
-
-        if not 0 <= percent <= 100:
-            raise ValueError("Attenuation should be between 0 and 100 included.")
-        else:
-            pulse = int(math.asin((50 - percent) * 0.02) * 536.5 + 6000)
-            prepulse = pulse - 400
-            # prepare the values to send with the motor protocol
-            lsb = prepulse % 128
-            msb = math.floor(prepulse / 128)
-            # send the values
-            self.com.write_bytes(bytes([132, 0, lsb, msb]))
-            time.sleep(self.config.response_sleep_time)
-            lsb = pulse % 128
-            msb = math.floor(pulse / 128)
-            self.com.write_bytes(bytes([132, 0, lsb, msb]))
-            time.sleep(self.config.response_sleep_time / 10)
-            self.com.write_bytes(bytes([161]))
-            time.sleep(self.config.response_sleep_time / 10)
-            b1 = self.com.read_single_bytes()
-            b2 = self.com.read_single_bytes()
-            logger.debug(f"b1 = {b1}, b2 = {b2}")
-            if b1 != b"\x00" or b2 != b"\x00":
-                err_msg = f"Setting laser attenuation to {percent} percents failed."
-                logger.error(err_msg)
-                raise CryLasAttenuatorError(err_msg)
-            else:
-                logger.info(
-                    f"Successfully set laser attenuation to {percent} Cpercents."
-                )
-                self._attenuation = percent
-
-    def set_transmission(self, percent: Number) -> None:
-        """
-        Set the percentage of transmitted light (inverse of set_attenuation).
-        :param percent: percentage of transmitted light
-        :raises ValueError: if param percent not between 0 and 100
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises CryLasAttenuatorError: if the device does not confirm success
-        """
-
-        self.set_attenuation(100 - percent)
-
-
-class CryLasAttenuatorError(Exception):
-    """
-    General error with the CryLas Attenuator.
-    """
-
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device classes for a CryLas pulsed laser controller and a CryLas laser attenuator,
+using serial communication.
+
+There are three modes of operation for the laser
+1. Laser-internal hardware trigger (default): fixed to 20 Hz and max energy per pulse.
+2. Laser-internal software trigger (for diagnosis only).
+3. External trigger: required for arbitrary pulse energy or repetition rate. Switch to
+"external" on the front panel of laser controller for using option 3.
+
+After switching on the laser with laser_on(), the system must stabilize
+for some minutes. Do not apply abrupt changes of pulse energy or repetition rate.
+
+Manufacturer homepage:
+https://www.crylas.de/products/pulsed_laser.html
+"""
+
+import logging
+import math
+import re
+import time
+from datetime import datetime
+from threading import Event
+from typing import Union, Tuple, Optional, Callable
+
+from aenum import Enum, IntEnum
+
+from .base import SingleCommDevice, DeviceException
+from .utils import Poller
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class CryLasLaserSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for CryLas laser is 19200 baud
+    baudrate: int = 19200
+
+    #: CryLas laser does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: CryLas laser uses one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is LF
+    terminator: bytes = b"\n"
+
+    #: use 10 seconds timeout as default (a long timeout is needed!)
+    timeout: Number = 10
+
+
+class CryLasLaserSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for the CryLas laser controller.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    @staticmethod
+    def config_cls():
+        return CryLasLaserSerialCommunicationConfig
+
+    READ_TEXT_SKIP_PREFIXES = (">", "MODE:")
+    """Prefixes of lines that are skipped when read from the serial port."""
+
+    def read(
+        self,
+    ) -> str:
+        """
+        Read first line of text from the serial port that does not start with any of
+        `self.READ_TEXT_SKIP_PREFIXES`.
+
+        :return: String read from the serial port; `''` if there was nothing to read.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        with self.access_lock:
+            line = super().read()
+            while line.startswith(self.READ_TEXT_SKIP_PREFIXES):
+                logger.debug(f'Laser com: "{line.rstrip()}" SKIPPED')
+                line = super().read_text()
+            logger.debug(f'Laser com: "{line.rstrip()}"')
+            return line
+
+    def query(self, cmd: str, prefix: str, post_cmd: str = None) -> str:
+        """
+        Send a command, then read the com until a line starting with prefix,
+        or an empty line, is found. Returns the line in question.
+
+        :param cmd: query message to send to the device
+        :param prefix: start of the line to look for in the device answer
+        :param post_cmd: optional additional command to send after the query
+        :return: line in question as a string
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        # TODO: Make use of SyncCommunicationProtocol
+
+        with self.access_lock:
+            # send the command
+            self.write(cmd)
+            # read the com until the prefix or an empty line is found
+            line = self.read().strip()
+            while line and not line.startswith(prefix):
+                line = self.read().strip()
+            if post_cmd is not None:
+                # send an optional post-command message to send to the device
+                self.write(post_cmd)
+            return line
+
+    def query_all(self, cmd: str, prefix: str):
+        """
+        Send a command, then read the com until a line starting with prefix,
+        or an empty line, is found. Returns a list of successive lines starting with
+        prefix.
+
+        :param cmd: query message to send to the device
+        :param prefix: start of the line to look for in the device answer
+        :return: line in question as a string
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        # TODO: Make use of SyncCommunicationProtocol
+
+        with self.access_lock:
+            # send the command
+            self.write(cmd)
+            # read the com until the prefix or an empty line is found
+            line = self.read().strip()
+            while line and not line.startswith(prefix):
+                line = self.read().strip()
+            answer = []
+            while line.startswith(prefix):
+                answer.append(line)
+                line = self.read().strip()
+            return answer
+
+
+class CryLasLaserShutterStatus(Enum):
+    """
+    Status of the CryLas laser shutter
+    """
+
+    CLOSED = 0
+    OPENED = 1
+
+
+@configdataclass
+class CryLasLaserConfig:
+    """
+    Device configuration dataclass for the CryLas laser controller.
+    """
+
+    # status of the shutter
+    ShutterStatus = CryLasLaserShutterStatus
+
+    # calibration factor for the pulse energy
+    calibration_factor: Number = 4.35
+
+    # polling period (s) to check back on the laser status if not ready
+    # it should be longer than the communication timeout
+    polling_period: Union[int, float] = 12
+
+    # timeout (s) when polling the laser status, CryLasLaserError is raised on timeout
+    polling_timeout: Number = 300
+
+    # automatically turn on the laser when ready
+    auto_laser_on: bool = True
+
+    # status of the shutter to be set on start
+    init_shutter_status: Union[
+        int, CryLasLaserShutterStatus
+    ] = CryLasLaserShutterStatus.CLOSED
+
+    def clean_values(self):
+        if self.calibration_factor <= 0:
+            raise ValueError("The calibration factor should be positive.")
+        if self.polling_period <= 0:
+            raise ValueError("The polling period should be positive.")
+        if self.polling_timeout <= 0:
+            raise ValueError("The polling timeout should be positive.")
+        self.force_value(
+            "init_shutter_status", self.ShutterStatus(self.init_shutter_status)
+        )
+
+
+class CryLasLaserPoller(Poller):
+    """
+    Poller class for polling the laser status until the laser is ready.
+
+    :raises CryLasLaserError: if the timeout is reached before the laser is ready
+    :raises SerialCommunicationIOError: when communication port is closed.
+    """
+
+    def __init__(
+        self,
+        spoll_handler: Callable,
+        check_handler: Callable,
+        check_laser_status_handler: Callable,
+        polling_delay_sec: Number = 0,
+        polling_interval_sec: Number = 1,
+        polling_timeout_sec: Optional[Number] = None,
+    ):
+        """
+        Initialize the polling helper.
+
+        :param spoll_handler: Polling function.
+        :param check_handler: Check polling results.
+        :param check_laser_status_handler: Check laser status.
+        :param polling_delay_sec: Delay before starting the polling, in seconds.
+        :param polling_interval_sec: Polling interval, in seconds.
+        """
+        super().__init__(
+            spoll_handler, polling_delay_sec, polling_interval_sec, polling_timeout_sec
+        )
+
+        self._check_handler = check_handler
+        self._check_laser_status_handler = check_laser_status_handler
+
+    def _if_poll_again(
+        self, stop_event: Event, delay_sec: Number, stop_time: Optional[Number]
+    ) -> bool:
+        """
+        Check if to poll again.
+
+        :param stop_event: Polling stop event.
+        :param delay_sec: Delay time (in seconds).
+        :param stop_time: Absolute stop time.
+        :return: `True` if another polling handler call is due, `False` otherwise.
+        """
+        if_poll_again = super()._if_poll_again(stop_event, delay_sec, stop_time)
+        is_laser_ready = self._check_laser_status_handler()
+
+        return if_poll_again and not is_laser_ready
+
+    def _poll_until_stop_or_timeout(self, stop_event: Event) -> Optional[object]:
+        """
+        Thread for polling until stopped, timed-out or the laser is ready.
+
+        :param stop_event: Event used to stop the polling
+        :return: Last result of the polling function call
+        """
+        last_result = super()._poll_until_stop_or_timeout(stop_event)
+
+        if stop_event.wait(0):
+            logger.info(f"[{datetime.now()}] Polling status: ... STOPPED")
+            return last_result
+        else:
+            self._check_handler()
+
+        return last_result
+
+
+class CryLasLaser(SingleCommDevice):
+    """
+    CryLas laser controller device class.
+    """
+
+    class LaserStatus(Enum):
+        """
+        Status of the CryLas laser
+        """
+
+        UNREADY_INACTIVE = 0
+        READY_INACTIVE = 1
+        READY_ACTIVE = 2
+
+        @property
+        def is_ready(self):
+            return self is not CryLasLaser.LaserStatus.UNREADY_INACTIVE
+
+        @property
+        def is_inactive(self):
+            return self is not CryLasLaser.LaserStatus.READY_ACTIVE
+
+    # status of the shutter
+    ShutterStatus = CryLasLaserShutterStatus
+
+    class AnswersShutter(Enum):
+        """
+        Standard answers of the CryLas laser controller to `'Shutter'` command passed
+        via `com`.
+        """
+
+        OPENED = "Shutter aktiv"
+        CLOSED = "Shutter inaktiv"
+
+    class AnswersStatus(Enum):
+        """
+        Standard answers of the CryLas laser controller to `'STATUS'` command passed
+        via `com`.
+        """
+
+        TEC1 = "STATUS: TEC1 Regulation ok"
+        TEC2 = "STATUS: TEC2 Regulation ok"
+        HEAD = "STATUS: Head ok"
+        READY = "STATUS: System ready"
+        ACTIVE = "STATUS: Laser active"
+        INACTIVE = "STATUS: Laser inactive"
+
+    class RepetitionRates(IntEnum, init="value send_value"):  # type: ignore
+        """
+        Repetition rates for the internal software trigger in Hz
+        """
+
+        HARDWARE = 0, 0  # software trigger is disabled, hardware trigger is used
+        # instead (hardware trigger may be internal or external).
+        SOFTWARE_INTERNAL_TEN = 10, 1
+        SOFTWARE_INTERNAL_TWENTY = 20, 2
+        SOFTWARE_INTERNAL_SIXTY = 60, 3
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # laser status
+        self.laser_status = self.LaserStatus.UNREADY_INACTIVE
+
+        # shutter status
+        self.shutter_status = None
+
+        # command repetition rate
+        self.repetition_rate = None
+
+        # command pulse energy (micro joule)
+        self._target_pulse_energy = None
+
+        # thread that polls the laser status until it is ready
+        self._status_poller = None
+
+    @property
+    def target_pulse_energy(self):
+        return self._target_pulse_energy
+
+    @staticmethod
+    def default_com_cls():
+        return CryLasLaserSerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return CryLasLaserConfig
+
+    def start(self) -> None:
+        """
+        Opens the communication protocol and configures the device.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened
+        """
+
+        logger.info("Starting device " + str(self))
+
+        # open the com
+        super().start()
+
+        # set the init shutter status
+        self.set_init_shutter_status()
+        # check if the laser is ready to be turned on
+        self.update_laser_status()
+        if not self.laser_status.is_ready:
+            logger.info("Laser not ready yet.")
+            # optionally, block execution until laser is ready
+            if self.config.auto_laser_on and not self._is_polling():
+                self._start_polling()
+        elif self.config.auto_laser_on:
+            # turn on the laser
+            self.laser_on()
+
+    def _start_polling(self):
+        """
+        Start polling laser status.
+        """
+        logger.info("Start polling laser status.")
+        self._status_poller = CryLasLaserPoller(
+            spoll_handler=self.update_laser_status,
+            check_handler=self._after_polling_check_status,
+            check_laser_status_handler=self._check_laser_status_handler,
+            polling_delay_sec=self.config.polling_period,
+            polling_interval_sec=self.config.polling_period,
+            polling_timeout_sec=self.config.polling_timeout,
+        )
+        self._status_poller.start_polling()
+
+    def _check_laser_status_handler(self) -> bool:
+        """
+        Checks whether the laser status is ready.
+        """
+        return self.laser_status.is_ready
+
+    def _after_polling_check_status(self) -> None:
+        """
+        Thread for polling the laser status until the laser is ready.
+
+        :raises CryLasLaserError: if the timeout is reached before the laser is ready
+        :raises SerialCommunicationIOError: when communication port is closed.
+        """
+
+        if not self.laser_status.is_ready:
+            err_msg = "Laser is not yet ready but status polling timed out."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+
+        logger.info(f"[{datetime.now()}] Polling status: ... DONE")
+        if self.config.auto_laser_on:
+            self.laser_on()
+
+    def _wait_for_polling_result(self):
+        """
+        Wait for until polling function returns a result as well as any exception that
+        might have been raised within a thread.
+
+        :return: polling function result
+        :raises: polling function errors
+        """
+        return self._status_poller.wait_for_polling_result()
+
+    def _stop_polling(self):
+        """
+        Stop polling laser status.
+
+        :return: polling function result
+        :raises: polling function errors
+        """
+        # use the event to stop the thread
+        logger.info("Stop polling laser status.")
+        self._status_poller.stop_polling()
+        return self._wait_for_polling_result()
+
+    def _is_polling(self) -> bool:
+        """
+        Check if device status is being polled.
+
+        :return: `True` when polling thread is set and alive
+        """
+        return self._status_poller is not None and self._status_poller.is_polling()
+
+    def wait_until_ready(self) -> None:
+        """
+        Block execution until the laser is ready
+
+        :raises CryLasLaserError: if the polling thread stops before the laser is ready
+        """
+
+        if not self.laser_status.is_ready:
+            if not self._is_polling():
+                self._start_polling()
+            logger.info("Waiting until the laser is ready...")
+            self._wait_for_polling_result()
+        else:
+            logger.info("No need waiting, the laser is already ready.")
+
+    def stop(self) -> None:
+        """
+        Stops the device and closes the communication protocol.
+
+        :raises SerialCommunicationIOError: if com port is closed unexpectedly
+        :raises CryLasLaserError: if laser_off() or close_shutter() fail
+        """
+
+        if self.com.is_open:
+            # turn off the laser
+            self.laser_off()
+            # close the laser shutter
+            self.close_shutter()
+            # cancel the polling thread in case still running
+            if self._is_polling():
+                self._stop_polling()
+                logger.info("The laser polling thread was stopped.")
+            # close the com
+            super().stop()
+        else:
+            logger.warning("Could not turn off the laser, com was already closed.")
+
+    def update_laser_status(self) -> None:
+        """
+        Update the laser status to `LaserStatus.NOT_READY` or `LaserStatus.INACTIVE` or
+        `LaserStatus.ACTIVE`.
+
+        Note: laser never explicitly says that it is not ready  (
+        `LaserStatus.NOT_READY`) in response to `'STATUS'` command. It only says
+        that it is ready (heated-up and implicitly inactive/off) or active (on). If
+        it's not either of these then the answer is `Answers.HEAD`. Moreover,
+        the only time the laser explicitly says that its status is inactive (
+        `Answers.INACTIVE`) is after issuing a 'LASER OFF' command.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        # query the status
+        answer_list = self.com.query_all("STATUS", "STATUS:")
+        # analyze the answer
+        if not answer_list:
+            err_msg = "Command to query the laser status did not return an answer."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            # at least one line in answer_list
+            for line in answer_list:
+                answer = self.AnswersStatus(line)
+                if answer in (
+                    self.AnswersStatus.TEC1,
+                    self.AnswersStatus.TEC2,
+                    self.AnswersStatus.HEAD,
+                ):
+                    new_status = self.LaserStatus.UNREADY_INACTIVE
+                    info_msg = "The laser is not ready."
+                elif answer is self.AnswersStatus.READY:
+                    new_status = self.LaserStatus.READY_INACTIVE
+                    info_msg = "The laser is ready."
+                elif answer is self.AnswersStatus.ACTIVE:
+                    new_status = self.LaserStatus.READY_ACTIVE
+                    info_msg = "The laser is on."
+                else:
+                    err_msg = f'Unexpected "STATUS" query response {answer.value}.'
+                    logger.error(err_msg)
+                    raise CryLasLaserError(err_msg)
+            self.laser_status = new_status
+            logger.info(info_msg)
+
+    def update_shutter_status(self) -> None:
+        """
+        Update the shutter status (OPENED or CLOSED)
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # query the status
+        answer = self.com.query("Shutter", "Shutter")
+        # analyse the answer
+        if not answer:
+            err_msg = "Command to query the shutter status did not return an answer."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            answer = self.AnswersShutter(answer)
+            if answer is self.AnswersShutter.CLOSED:
+                logger.info("The laser shutter is currently CLOSED.")
+                self.shutter_status = self.ShutterStatus.CLOSED
+            elif answer is self.AnswersShutter.OPENED:
+                logger.info("The laser shutter is currently OPENED.")
+                self.shutter_status = self.ShutterStatus.OPENED
+
+    def update_repetition_rate(self) -> None:
+        """
+        Query the laser repetition rate.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # query the repetition rate
+        answer = self.com.query("BOO IP", "Impuls=")
+        # analyse the answer
+        if not answer:
+            err_msg = "Querying the repetition rate did not return an answer."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        elif answer == "Impuls=disabled, extern Trigger":
+            logger.info(
+                "The laser is using a hardware trigger "
+                "(may be internal or external)."
+            )
+            self.repetition_rate = self.RepetitionRates.HARDWARE
+        elif answer.startswith("Impuls=enabled"):
+            match = re.search(r"\d+", answer)
+            if match is None:
+                err_msg = (
+                    f"Expected rate integer to follow 'Impuls=enabled' answer "
+                    f"in {answer} while querying the repetition."
+                )
+                logger.error(err_msg)
+                raise CryLasLaserError(err_msg)
+            rate = int(match.group(0))
+            self.repetition_rate = self.RepetitionRates(rate)
+            logger.info(
+                "The laser is using the internal " f"software trigger at {rate} Hz."
+            )
+
+    def update_target_pulse_energy(self) -> None:
+        """
+        Query the laser pulse energy.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # query the repetition rate
+        answer = self.com.query("BOO SE", "PD-Sollwert=")
+        # analyse the answer
+        if not answer:
+            err_msg = (
+                "Command to query the target pulse energy did not return an answer."
+            )
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            current_value = int(answer.split("=")[1])
+            current_energy = int(current_value * self.config.calibration_factor / 1000)
+            # update the pulse energy attribute
+            self._target_pulse_energy = current_energy
+            logger.info(f"The target pulse energy is {current_energy} uJ.")
+
+    def laser_on(self) -> None:
+        """
+        Turn the laser on.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserNotReadyError: if the laser is not ready to be turned on
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        if not self.laser_status.is_ready:
+            raise CryLasLaserNotReadyError("Laser not ready, cannot be turned on yet.")
+        else:
+            # send the command
+            answer = self.com.query("LASER ON", "STATUS: Laser")
+            # analyse the answer
+            if not answer or self.AnswersStatus(answer) != self.AnswersStatus.ACTIVE:
+                if not self.laser_status.is_inactive:
+                    logger.info("Laser is already on.")
+                else:
+                    err_msg = (
+                        f"Command to turn on the laser "
+                        f"{'failed' if answer else 'did not return an answer'}."
+                    )
+                    logger.error(err_msg)
+                    raise CryLasLaserError(err_msg)
+            else:
+                self.laser_status = self.LaserStatus.READY_ACTIVE
+                logger.info("Laser is turned on.")
+
+    def laser_off(self) -> None:
+        """
+        Turn the laser off.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # send the command
+        answer = self.com.query("LASER OFF", "STATUS: Laser")
+        # analyse the answer
+        if not answer or self.AnswersStatus(answer) != self.AnswersStatus.INACTIVE:
+            if self.laser_status.is_inactive:
+                logger.info("Laser is already off.")
+            else:
+                err_msg = (
+                    f"Command to turn off the laser "
+                    f"{'failed' if answer else 'did not return an answer'}."
+                )
+                logger.error(err_msg)
+                raise CryLasLaserError(err_msg)
+        else:
+            self.laser_status = self.LaserStatus.READY_INACTIVE
+            logger.info("Laser is turned off.")
+
+    def open_shutter(self) -> None:
+        """
+        Open the laser shutter.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # send the command
+        answer = self.com.query(
+            f"Shutter {self.config.ShutterStatus.OPENED.value}", "Shutter"
+        )
+        # analyse the answer
+        if not answer or self.AnswersShutter(answer) != self.AnswersShutter.OPENED:
+            err_msg = (
+                f"Opening laser shutter "
+                f"{'failed' if answer else 'did not return an answer'}."
+            )
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            logger.info("Opening laser shutter succeeded.")
+            self.shutter_status = self.ShutterStatus.OPENED
+
+    def close_shutter(self) -> None:
+        """
+        Close the laser shutter.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # send the command
+        answer = self.com.query(
+            f"Shutter {self.config.ShutterStatus.CLOSED.value}", "Shutter"
+        )
+        # analyse the answer
+        if not answer or self.AnswersShutter(answer) != self.AnswersShutter.CLOSED:
+            err_msg = (
+                f"Closing laser shutter "
+                f"{'failed' if answer else 'did not return an answer'}."
+            )
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            logger.info("Closing laser shutter succeeded.")
+            self.shutter_status = self.ShutterStatus.CLOSED
+
+    def set_init_shutter_status(self) -> None:
+        """
+        Open or close the shutter, to match the configured shutter_status.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        self.update_shutter_status()
+        if self.config.init_shutter_status != self.shutter_status:
+            if self.config.init_shutter_status == self.ShutterStatus.CLOSED:
+                self.close_shutter()
+            elif self.config.init_shutter_status == self.ShutterStatus.OPENED:
+                self.open_shutter()
+
+    def get_pulse_energy_and_rate(self) -> Tuple[int, int]:
+        """
+        Use the debug mode, return the measured pulse energy and rate.
+
+        :return: (energy in micro joule, rate in Hz)
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if the device does not answer the query
+        """
+
+        # send the command (enter the debug mode)
+        answer = self.com.query("DB1", "IST:", "DB0")
+        if not answer:
+            err_msg = "Command to find laser energy and rate did not return an answer."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            # the answer should look like 'IST: LDTemp=x, NLOTemp=x, CaseTemp=x,
+            # PD=x, D_I= x, freq=x, LDE=x, RegOFF=x' where x are integers
+            # find the values of interest
+            values = re.findall(r"\d+", answer)
+            energy = int(int(values[3]) * self.config.calibration_factor / 1000)
+            rate = int(values[5])
+            logger.info(f"Laser energy: {energy} uJ, repetition rate: {rate} Hz.")
+            return energy, rate
+
+    def set_repetition_rate(self, rate: Union[int, RepetitionRates]) -> None:
+        """
+        Sets the repetition rate of the internal software trigger.
+
+        :param rate: frequency (Hz) as an integer
+        :raises ValueError: if rate is not an accepted value in RepetitionRates Enum
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if success is not confirmed by the device
+        """
+
+        # check if the value is ok
+        if not isinstance(rate, self.RepetitionRates):
+            try:
+                rate = self.RepetitionRates(rate)
+            except ValueError as e:
+                logger.error(str(e), exc_info=e)
+                raise e
+        # send the corresponding value to the controller
+        answer = self.com.query(f"BOO IP{rate.send_value}", "Impuls=")
+        # check the success of the command
+        if rate != self.RepetitionRates.HARDWARE:
+            # check whether the expected answer is obtained
+            if answer != f"Impuls=enabled {rate}Hz":
+                err_msg = (
+                    f"Setting the repetition rate failed. Controller answered:"
+                    f" {answer}."
+                )
+                logger.error(err_msg)
+                raise CryLasLaserError(err_msg)
+            else:
+                logger.info(f"Laser internal software trigger set to {rate.value} Hz")
+        else:
+            # For the internal hardware trigger rate, there is no way to check success
+            logger.info("Using laser internal hardware trigger.")
+        # update the repetition rate attribute
+        self.repetition_rate = rate
+
+    def set_pulse_energy(self, energy: int) -> None:
+        """
+        Sets the energy of pulses (works only with external hardware trigger).
+        Proceed with small energy steps, or the regulation may fail.
+
+        :param energy: energy in micro joule
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasLaserError: if the device does not confirm success
+        """
+
+        # convert the input value into the required command value
+        command_value = int(energy * 1000 / self.config.calibration_factor)
+        # send the command
+        answer = self.com.query(f"BOO SE {command_value}", "PD-Sollwert=")
+        # analyse the answer
+        if not answer:
+            err_msg = "Command to set the pulse energy did not return an answer."
+            logger.error(err_msg)
+            raise CryLasLaserError(err_msg)
+        else:
+            current_value = int(answer.split("=")[1])
+            current_energy = int(current_value * self.config.calibration_factor / 1000)
+            # update the pulse energy attribute
+            self._target_pulse_energy = current_energy
+            if current_value != command_value:
+                message = (
+                    f"Command to set the pulse energy failed. "
+                    f"The pulse energy is currently set to {current_energy} "
+                    f"micro joule. Setting a different value is only possible "
+                    f"when using an external hardware trigger."
+                )
+                logger.error(message)
+                raise CryLasLaserError(message)
+            else:
+                logger.info(f"Successfully set pulse energy to {energy}")
+
+
+class CryLasLaserError(DeviceException):
+    """
+    General error with the CryLas Laser.
+    """
+
+    pass
+
+
+class CryLasLaserNotReadyError(CryLasLaserError):
+    """
+    Error when trying to turn on the CryLas Laser before it is ready.
+    """
+
+    pass
+
+
+@configdataclass
+class CryLasAttenuatorSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for CryLas attenuator is 9600 baud
+    baudrate: int = 9600
+
+    #: CryLas attenuator does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: CryLas attenuator uses one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: No terminator
+    terminator: bytes = b""
+
+    #: use 3 seconds timeout as default
+    timeout: Number = 3
+
+
+class CryLasAttenuatorSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for
+    the CryLas attenuator.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    @staticmethod
+    def config_cls():
+        return CryLasAttenuatorSerialCommunicationConfig
+
+
+@configdataclass
+class CryLasAttenuatorConfig:
+    """
+    Device configuration dataclass for CryLas attenuator.
+    """
+
+    # initial/default attenuation value which is set on start()
+    init_attenuation: Number = 0
+    response_sleep_time: Number = 1
+
+    def clean_values(self):
+        if not 0 <= self.init_attenuation <= 100:
+            raise ValueError("Attenuation should be " "between 0 and 100 included.")
+        if self.response_sleep_time <= 0:
+            raise ValueError("Response sleep time should be positive.")
+
+
+class CryLasAttenuator(SingleCommDevice):
+    """
+    Device class for the CryLas laser attenuator.
+    """
+
+    def __init__(self, com, dev_config=None):
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # attenuation of the laser light in percent (not determined yet)
+        self._attenuation = None
+
+    @staticmethod
+    def default_com_cls():
+        return CryLasAttenuatorSerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return CryLasAttenuatorConfig
+
+    @property
+    def attenuation(self) -> Number:
+        return self._attenuation
+
+    @property
+    def transmission(self) -> Number:
+        return 100 - self._attenuation
+
+    def start(self) -> None:
+        """
+        Open the com, apply the config value 'init_attenuation'
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened
+        """
+
+        super().start()
+        self.set_init_attenuation()
+
+    def set_init_attenuation(self):
+        """
+        Sets the attenuation to its configured initial/default value
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.set_attenuation(self.config.init_attenuation)
+
+    def set_attenuation(self, percent: Number) -> None:
+        """
+        Set the percentage of attenuated light (inverse of set_transmission).
+        :param percent: percentage of attenuation, number between 0 and 100
+        :raises ValueError: if param percent not between 0 and 100
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasAttenuatorError: if the device does not confirm success
+        """
+
+        if not 0 <= percent <= 100:
+            raise ValueError("Attenuation should be between 0 and 100 included.")
+        else:
+            pulse = int(math.asin((50 - percent) * 0.02) * 536.5 + 6000)
+            prepulse = pulse - 400
+            # prepare the values to send with the motor protocol
+            lsb = prepulse % 128
+            msb = math.floor(prepulse / 128)
+            # send the values
+            self.com.write_bytes(bytes([132, 0, lsb, msb]))
+            time.sleep(self.config.response_sleep_time)
+            lsb = pulse % 128
+            msb = math.floor(pulse / 128)
+            self.com.write_bytes(bytes([132, 0, lsb, msb]))
+            time.sleep(self.config.response_sleep_time / 10)
+            self.com.write_bytes(bytes([161]))
+            time.sleep(self.config.response_sleep_time / 10)
+            b1 = self.com.read_single_bytes()
+            b2 = self.com.read_single_bytes()
+            logger.debug(f"b1 = {b1}, b2 = {b2}")
+            if b1 != b"\x00" or b2 != b"\x00":
+                err_msg = f"Setting laser attenuation to {percent} percents failed."
+                logger.error(err_msg)
+                raise CryLasAttenuatorError(err_msg)
+            else:
+                logger.info(
+                    f"Successfully set laser attenuation to {percent} Cpercents."
+                )
+                self._attenuation = percent
+
+    def set_transmission(self, percent: Number) -> None:
+        """
+        Set the percentage of transmitted light (inverse of set_attenuation).
+        :param percent: percentage of transmitted light
+        :raises ValueError: if param percent not between 0 and 100
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises CryLasAttenuatorError: if the device does not confirm success
+        """
+
+        self.set_attenuation(100 - percent)
+
+
+class CryLasAttenuatorError(DeviceException):
+    """
+    General error with the CryLas Attenuator.
+    """
+
+    pass
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/heinzinger.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/heinzinger.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,532 +1,532 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device classes for Heinzinger Digital Interface I/II and Heinzinger PNC power supply.
-
-The Heinzinger Digital Interface I/II is used for many Heinzinger power units.
-Manufacturer homepage:
-https://www.heinzinger.com/products/accessories-and-more/digital-interfaces/
-
-The Heinzinger PNC series is a series of high voltage direct current power supplies.
-The class HeinzingerPNC is tested with two PNChp 60000-1neg and a PNChp 1500-1neg.
-Check the code carefully before using it with other PNC devices, especially PNC3p
-or PNCcap.
-Manufacturer homepage:
-https://www.heinzinger.com/products/high-voltage/universal-high-voltage-power-supplies/
-"""
-
-import logging
-import re
-from abc import ABC, abstractmethod
-from enum import IntEnum
-from time import sleep
-from typing import Union
-
-from .base import SingleCommDevice
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.enum import AutoNumberNameEnum
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class HeinzingerSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for Heinzinger power supplies is 9600 baud
-    baudrate: int = 9600
-
-    #: Heinzinger does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: Heinzinger uses one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is LF
-    terminator: bytes = b"\n"
-
-    #: use 3 seconds timeout as default
-    timeout: Number = 3
-
-    #: default time to wait between attempts of reading a non-empty text
-    wait_sec_read_text_nonempty: Number = 0.5
-
-    #: increased to 40 default number of attempts to read a non-empty text
-    default_n_attempts_read_text_nonempty: int = 40
-
-
-class HeinzingerSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for
-    Heinzinger power supplies.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    @staticmethod
-    def config_cls():
-        return HeinzingerSerialCommunicationConfig
-
-
-@configdataclass
-class HeinzingerConfig:
-    """
-    Device configuration dataclass for Heinzinger power supplies.
-    """
-
-    class RecordingsEnum(IntEnum):
-        ONE = 1
-        TWO = 2
-        FOUR = 4
-        EIGHT = 8
-        SIXTEEN = 16
-
-    #: default number of recordings used in averaging the current
-    #  or the voltage [1, 2, 4, 8, 16]
-    default_number_of_recordings: Union[int, RecordingsEnum] = 1
-
-    #: number of decimals sent for setting the current limit or the voltage, between 1
-    #  and 10
-    number_of_decimals: int = 6
-
-    #: Time to wait after subsequent commands during stop (in seconds)
-    wait_sec_stop_commands: Number = 0.5
-
-    def clean_values(self):
-        if not isinstance(self.default_number_of_recordings, self.RecordingsEnum):
-            self.force_value(
-                "default_number_of_recordings",
-                self.RecordingsEnum(self.default_number_of_recordings),
-            )
-
-        if self.number_of_decimals not in range(1, 11):
-            raise ValueError(
-                "The number of decimals should be " "an integer between 1 and 10."
-            )
-
-        if self.wait_sec_stop_commands <= 0:
-            raise ValueError(
-                "Wait time after subsequent commands during stop must be be a "
-                "positive value (in seconds)."
-            )
-
-
-class HeinzingerDI(SingleCommDevice, ABC):
-    """
-    Heinzinger Digital Interface I/II device class
-
-    Sends basic SCPI commands and reads the answer.
-    Only the standard instruction set from the manual is implemented.
-    """
-
-    class OutputStatus(IntEnum):
-        """
-        Status of the voltage output
-        """
-
-        UNKNOWN = -1
-        OFF = 0
-        ON = 1
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # Version of the interface (will be retrieved after com is opened)
-        self._interface_version = ""
-
-        # Status of the voltage output (it has to be updated via the output_on and
-        # output_off methods because querying it is not supported)
-        self._output_status = self.OutputStatus.UNKNOWN
-
-    def __repr__(self):
-        return f"HeinzingerDI({self._interface_version})"
-
-    @property
-    def output_status(self) -> OutputStatus:
-        return self._output_status
-
-    @staticmethod
-    def default_com_cls():
-        return HeinzingerSerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return HeinzingerConfig
-
-    @abstractmethod
-    def start(self):
-        """
-        Opens the communication protocol.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened.
-        """
-
-        logger.info("Starting device " + str(self))
-        super().start()
-
-        self._interface_version = self.get_interface_version()
-
-    def stop(self) -> None:
-        """
-        Stop the device. Closes also the communication protocol.
-        """
-
-        logger.info(f"Stopping device {self}")
-        if not self.com.is_open:
-            logger.warning(f"Device {self} already stopped")
-        else:
-            # set the voltage to zero
-            self.set_voltage(0)
-            sleep(self.config.wait_sec_stop_commands)
-            # switch off the voltage output
-            self.output_off()
-            sleep(self.config.wait_sec_stop_commands)
-        super().stop()
-
-    def reset_interface(self) -> None:
-        """
-        Reset of the digital interface; only Digital Interface I:
-        Power supply is switched to the Local-Mode (Manual operation)
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("*RST")
-
-    def get_interface_version(self) -> str:
-        """
-        Queries the version number of the digital interface.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("VERS?")
-        return self.com.read_text_nonempty()
-
-    def get_serial_number(self) -> str:
-        """
-        Ask the device for its serial number and returns the answer as a string.
-
-        :return: string containing the device serial number
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("*IDN?")
-        return self.com.read_text_nonempty()
-
-    def output_on(self) -> None:
-        """
-        Switch DC voltage output on and updates the output status.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("OUTP ON")
-        self._output_status = self.output_status.ON
-
-    def output_off(self) -> None:
-        """
-        Switch DC voltage output off and updates the output status.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("OUTP OFF")
-        self._output_status = self.output_status.OFF
-
-    def get_number_of_recordings(self) -> int:
-        """
-        Queries the number of recordings the device is using for average value
-        calculation.
-
-        :return: int number of recordings
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("AVER?")
-        answer = self.com.read_text_nonempty()
-        return int(answer)
-
-    def set_number_of_recordings(
-        self,
-        value: Union[int, HeinzingerConfig.RecordingsEnum],
-    ) -> None:
-        """
-        Sets the number of recordings the device is using for average value
-        calculation. The possible values are 1, 2, 4, 8 and 16.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        value = self.config.RecordingsEnum(value).value
-        self.com.write_text(f"AVER {value}")
-
-    def measure_voltage(self) -> float:
-        """
-        Ask the Device to measure its output voltage and return the measurement result.
-
-        :return: measured voltage as float
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("MEAS:VOLT?")
-        answer = self.com.read_text_nonempty()
-        return float(answer)
-
-    def set_voltage(self, value: Union[int, float]) -> None:
-        """
-        Sets the output voltage of the Heinzinger PNC to the given value.
-
-        :param value: voltage expressed in `self.unit_voltage`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.com.write_text(f"VOLT {value:.{self.config.number_of_decimals}f}")
-
-    def get_voltage(self) -> float:
-        """
-        Queries the set voltage of the Heinzinger PNC (not the measured voltage!).
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("VOLT?")
-        answer = self.com.read_text_nonempty()
-        return float(answer)
-
-    def measure_current(self) -> float:
-        """
-        Ask the Device to measure its output current and return the measurement result.
-
-        :return: measured current as float
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("MEAS:CURR?")
-        answer = self.com.read_text_nonempty()
-        return float(answer)
-
-    def set_current(self, value: Union[int, float]) -> None:
-        """
-        Sets the output current of the Heinzinger PNC to the given value.
-
-        :param value: current expressed in `self.unit_current`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.com.write_text(f"CURR {value:.{self.config.number_of_decimals}f}")
-
-    def get_current(self) -> float:
-        """
-        Queries the set current of the Heinzinger PNC (not the measured current!).
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text("CURR?")
-        answer = self.com.read_text_nonempty()
-        return float(answer)
-
-
-class HeinzingerPNC(HeinzingerDI):
-    """
-    Heinzinger PNC power supply device class.
-
-    The power supply is controlled over a Heinzinger Digital Interface I/II
-    """
-
-    class UnitCurrent(AutoNumberNameEnum):
-        UNKNOWN = ()
-        mA = ()
-        A = ()
-
-    class UnitVoltage(AutoNumberNameEnum):
-        UNKNOWN = ()
-        V = ()
-        kV = ()
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # Serial number of the device (will be retrieved after com is opened)
-        self._serial_number = ""
-        # model of the device (derived from serial number)
-        self._model = ""
-        # maximum output current of the hardware (unit mA or A, depending on model)
-        self._max_current_hardware = 0
-        # maximum output voltage of the hardware (unit V or kV, depending on model)
-        self._max_voltage_hardware = 0
-        # maximum output current set by user (unit mA or A, depending on model)
-        self._max_current = 0
-        # maximum output voltage set by user (unit V or kV, depending on model)
-        self._max_voltage = 0
-        # current unit: 'mA' or 'A', depending on model
-        self._unit_current = self.UnitCurrent.UNKNOWN
-        # voltage unit: 'V' or 'kV', depending on model
-        self._unit_voltage = self.UnitVoltage.UNKNOWN
-
-    def __repr__(self):
-        return (
-            f"HeinzingerPNC({self._serial_number}), with "
-            f"HeinzingerDI({self._interface_version})"
-        )
-
-    @property
-    def max_current_hardware(self) -> Union[int, float]:
-        return self._max_current_hardware
-
-    @property
-    def max_voltage_hardware(self) -> Union[int, float]:
-        return self._max_voltage_hardware
-
-    @property
-    def unit_voltage(self) -> UnitVoltage:  # noqa: F821
-        return self._unit_voltage
-
-    @property
-    def unit_current(self) -> UnitCurrent:  # noqa: F821
-        return self._unit_current
-
-    @property
-    def max_current(self) -> Union[int, float]:
-        return self._max_current
-
-    @max_current.setter
-    def max_current(self, value: Union[int, float]):
-        if not 0 <= value <= self._max_current_hardware:
-            raise ValueError(
-                "max_current must positive " "and below max_current_hardware."
-            )
-        self._max_current = value
-
-    @property
-    def max_voltage(self) -> Union[int, float]:
-        return self._max_voltage
-
-    @max_voltage.setter
-    def max_voltage(self, value: Union[int, float]):
-        if not 0 <= value <= self._max_voltage_hardware:
-            raise ValueError(
-                "max_voltage must be positive " "and below max_voltage_hardware."
-            )
-        self._max_voltage = value
-
-    def start(self) -> None:
-        """
-        Opens the communication protocol and configures the device.
-        """
-
-        # starting Heinzinger Digital Interface
-        super().start()
-
-        logger.info("Starting device " + str(self))
-
-        # find out which type of source this is:
-        self.identify_device()
-        self.set_number_of_recordings(self.config.default_number_of_recordings)
-
-    def identify_device(self) -> None:
-        """
-        Identify the device nominal voltage and current based on its serial number.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        serial_number = self.get_serial_number()
-        # regex to find the model of the device
-        regex_vc = r"(\d+)-(\d+)"  # voltage-current info
-        regex_model = r"PNC.*?" + regex_vc + r"\s?[a-z]{3}"
-        result = re.search(regex_model, serial_number)
-        if result:
-            self._serial_number = serial_number
-            model = result.group()
-            self._model = model
-            # regex to find the nominal voltage and nominal current
-            match = re.search(regex_vc, model)
-            assert match  # already matched in regex_model expression
-            voltage = int(match.group(1))
-            current = int(match.group(2))
-            # identifying the units to use for voltage and current
-            if voltage < 100000:
-                self._unit_voltage = self.UnitVoltage.V
-                self._max_voltage_hardware = voltage
-                self._max_voltage = voltage
-            else:
-                self._unit_voltage = self.UnitVoltage.kV
-                self._max_voltage_hardware = int(voltage / 1000)
-                self._max_voltage = int(voltage / 1000)
-            if current < 1000:
-                self._unit_current = self.UnitCurrent.mA
-                self._max_current_hardware = current
-                self._max_current = current
-            else:
-                self._unit_current = self.UnitCurrent.A
-                self._max_current_hardware = int(current / 1000)
-                self._max_current = int(current / 1000)
-            logger.info(f"Device {model} successfully identified")
-        else:
-            raise HeinzingerPNCDeviceNotRecognizedException(serial_number)
-
-    def set_voltage(self, value: Union[int, float]) -> None:
-        """
-        Sets the output voltage of the Heinzinger PNC to the given value.
-
-        :param value: voltage expressed in `self.unit_voltage`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        if value > self.max_voltage:
-            raise HeinzingerPNCMaxVoltageExceededException
-        elif value < 0:
-            raise ValueError("voltage must be positive")
-
-        super().set_voltage(value)
-
-    def set_current(self, value: Union[int, float]) -> None:
-        """
-        Sets the output current of the Heinzinger PNC to the given value.
-
-        :param value: current expressed in `self.unit_current`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        if value > self.max_current:
-            raise HeinzingerPNCMaxCurrentExceededException
-        elif value < 0:
-            raise ValueError("current must be positive")
-
-        super().set_current(value)
-
-
-class HeinzingerPNCError(Exception):
-    """
-    General error with the Heinzinger PNC voltage source.
-    """
-
-    pass
-
-
-class HeinzingerPNCMaxVoltageExceededException(HeinzingerPNCError):
-    """
-    Error indicating that program attempted to set the voltage
-    to a value exceeding 'max_voltage'.
-    """
-
-    pass
-
-
-class HeinzingerPNCMaxCurrentExceededException(HeinzingerPNCError):
-    """
-    Error indicating that program attempted to set the current
-    to a value exceeding 'max_current'.
-    """
-
-    pass
-
-
-class HeinzingerPNCDeviceNotRecognizedException(HeinzingerPNCError):
-    """
-    Error indicating that the serial number of the device
-    is not recognized.
-    """
-
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device classes for Heinzinger Digital Interface I/II and Heinzinger PNC power supply.
+
+The Heinzinger Digital Interface I/II is used for many Heinzinger power units.
+Manufacturer homepage:
+https://www.heinzinger.com/products/accessories-and-more/digital-interfaces/
+
+The Heinzinger PNC series is a series of high voltage direct current power supplies.
+The class HeinzingerPNC is tested with two PNChp 60000-1neg and a PNChp 1500-1neg.
+Check the code carefully before using it with other PNC devices, especially PNC3p
+or PNCcap.
+Manufacturer homepage:
+https://www.heinzinger.com/products/high-voltage/universal-high-voltage-power-supplies/
+"""
+
+import logging
+import re
+from abc import ABC, abstractmethod
+from enum import IntEnum
+from time import sleep
+from typing import Union
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.enum import AutoNumberNameEnum
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class HeinzingerSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for Heinzinger power supplies is 9600 baud
+    baudrate: int = 9600
+
+    #: Heinzinger does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: Heinzinger uses one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is LF
+    terminator: bytes = b"\n"
+
+    #: use 3 seconds timeout as default
+    timeout: Number = 3
+
+    #: default time to wait between attempts of reading a non-empty text
+    wait_sec_read_text_nonempty: Number = 0.5
+
+    #: increased to 40 default number of attempts to read a non-empty text
+    default_n_attempts_read_text_nonempty: int = 40
+
+
+class HeinzingerSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for
+    Heinzinger power supplies.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    @staticmethod
+    def config_cls():
+        return HeinzingerSerialCommunicationConfig
+
+
+@configdataclass
+class HeinzingerConfig:
+    """
+    Device configuration dataclass for Heinzinger power supplies.
+    """
+
+    class RecordingsEnum(IntEnum):
+        ONE = 1
+        TWO = 2
+        FOUR = 4
+        EIGHT = 8
+        SIXTEEN = 16
+
+    #: default number of recordings used in averaging the current
+    #  or the voltage [1, 2, 4, 8, 16]
+    default_number_of_recordings: Union[int, RecordingsEnum] = 1
+
+    #: number of decimals sent for setting the current limit or the voltage, between 1
+    #  and 10
+    number_of_decimals: int = 6
+
+    #: Time to wait after subsequent commands during stop (in seconds)
+    wait_sec_stop_commands: Number = 0.5
+
+    def clean_values(self):
+        if not isinstance(self.default_number_of_recordings, self.RecordingsEnum):
+            self.force_value(
+                "default_number_of_recordings",
+                self.RecordingsEnum(self.default_number_of_recordings),
+            )
+
+        if self.number_of_decimals not in range(1, 11):
+            raise ValueError(
+                "The number of decimals should be " "an integer between 1 and 10."
+            )
+
+        if self.wait_sec_stop_commands <= 0:
+            raise ValueError(
+                "Wait time after subsequent commands during stop must be be a "
+                "positive value (in seconds)."
+            )
+
+
+class HeinzingerDI(SingleCommDevice, ABC):
+    """
+    Heinzinger Digital Interface I/II device class
+
+    Sends basic SCPI commands and reads the answer.
+    Only the standard instruction set from the manual is implemented.
+    """
+
+    class OutputStatus(IntEnum):
+        """
+        Status of the voltage output
+        """
+
+        UNKNOWN = -1
+        OFF = 0
+        ON = 1
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # Version of the interface (will be retrieved after com is opened)
+        self._interface_version = ""
+
+        # Status of the voltage output (it has to be updated via the output_on and
+        # output_off methods because querying it is not supported)
+        self._output_status = self.OutputStatus.UNKNOWN
+
+    def __repr__(self):
+        return f"HeinzingerDI({self._interface_version})"
+
+    @property
+    def output_status(self) -> OutputStatus:
+        return self._output_status
+
+    @staticmethod
+    def default_com_cls():
+        return HeinzingerSerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return HeinzingerConfig
+
+    @abstractmethod
+    def start(self):
+        """
+        Opens the communication protocol.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened.
+        """
+
+        logger.info("Starting device " + str(self))
+        super().start()
+
+        self._interface_version = self.get_interface_version()
+
+    def stop(self) -> None:
+        """
+        Stop the device. Closes also the communication protocol.
+        """
+
+        logger.info(f"Stopping device {self}")
+        if not self.com.is_open:
+            logger.warning(f"Device {self} already stopped")
+        else:
+            # set the voltage to zero
+            self.set_voltage(0)
+            sleep(self.config.wait_sec_stop_commands)
+            # switch off the voltage output
+            self.output_off()
+            sleep(self.config.wait_sec_stop_commands)
+        super().stop()
+
+    def reset_interface(self) -> None:
+        """
+        Reset of the digital interface; only Digital Interface I:
+        Power supply is switched to the Local-Mode (Manual operation)
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("*RST")
+
+    def get_interface_version(self) -> str:
+        """
+        Queries the version number of the digital interface.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("VERS?")
+        return self.com.read_text_nonempty()
+
+    def get_serial_number(self) -> str:
+        """
+        Ask the device for its serial number and returns the answer as a string.
+
+        :return: string containing the device serial number
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("*IDN?")
+        return self.com.read_text_nonempty()
+
+    def output_on(self) -> None:
+        """
+        Switch DC voltage output on and updates the output status.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("OUTP ON")
+        self._output_status = self.output_status.ON
+
+    def output_off(self) -> None:
+        """
+        Switch DC voltage output off and updates the output status.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("OUTP OFF")
+        self._output_status = self.output_status.OFF
+
+    def get_number_of_recordings(self) -> int:
+        """
+        Queries the number of recordings the device is using for average value
+        calculation.
+
+        :return: int number of recordings
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("AVER?")
+        answer = self.com.read_text_nonempty()
+        return int(answer)
+
+    def set_number_of_recordings(
+        self,
+        value: Union[int, HeinzingerConfig.RecordingsEnum],
+    ) -> None:
+        """
+        Sets the number of recordings the device is using for average value
+        calculation. The possible values are 1, 2, 4, 8 and 16.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        value = self.config.RecordingsEnum(value).value
+        self.com.write_text(f"AVER {value}")
+
+    def measure_voltage(self) -> float:
+        """
+        Ask the Device to measure its output voltage and return the measurement result.
+
+        :return: measured voltage as float
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("MEAS:VOLT?")
+        answer = self.com.read_text_nonempty()
+        return float(answer)
+
+    def set_voltage(self, value: Union[int, float]) -> None:
+        """
+        Sets the output voltage of the Heinzinger PNC to the given value.
+
+        :param value: voltage expressed in `self.unit_voltage`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.com.write_text(f"VOLT {value:.{self.config.number_of_decimals}f}")
+
+    def get_voltage(self) -> float:
+        """
+        Queries the set voltage of the Heinzinger PNC (not the measured voltage!).
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("VOLT?")
+        answer = self.com.read_text_nonempty()
+        return float(answer)
+
+    def measure_current(self) -> float:
+        """
+        Ask the Device to measure its output current and return the measurement result.
+
+        :return: measured current as float
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("MEAS:CURR?")
+        answer = self.com.read_text_nonempty()
+        return float(answer)
+
+    def set_current(self, value: Union[int, float]) -> None:
+        """
+        Sets the output current of the Heinzinger PNC to the given value.
+
+        :param value: current expressed in `self.unit_current`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.com.write_text(f"CURR {value:.{self.config.number_of_decimals}f}")
+
+    def get_current(self) -> float:
+        """
+        Queries the set current of the Heinzinger PNC (not the measured current!).
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text("CURR?")
+        answer = self.com.read_text_nonempty()
+        return float(answer)
+
+
+class HeinzingerPNC(HeinzingerDI):
+    """
+    Heinzinger PNC power supply device class.
+
+    The power supply is controlled over a Heinzinger Digital Interface I/II
+    """
+
+    class UnitCurrent(AutoNumberNameEnum):
+        UNKNOWN = ()
+        mA = ()
+        A = ()
+
+    class UnitVoltage(AutoNumberNameEnum):
+        UNKNOWN = ()
+        V = ()
+        kV = ()
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # Serial number of the device (will be retrieved after com is opened)
+        self._serial_number = ""
+        # model of the device (derived from serial number)
+        self._model = ""
+        # maximum output current of the hardware (unit mA or A, depending on model)
+        self._max_current_hardware = 0
+        # maximum output voltage of the hardware (unit V or kV, depending on model)
+        self._max_voltage_hardware = 0
+        # maximum output current set by user (unit mA or A, depending on model)
+        self._max_current = 0
+        # maximum output voltage set by user (unit V or kV, depending on model)
+        self._max_voltage = 0
+        # current unit: 'mA' or 'A', depending on model
+        self._unit_current = self.UnitCurrent.UNKNOWN
+        # voltage unit: 'V' or 'kV', depending on model
+        self._unit_voltage = self.UnitVoltage.UNKNOWN
+
+    def __repr__(self):
+        return (
+            f"HeinzingerPNC({self._serial_number}), with "
+            f"HeinzingerDI({self._interface_version})"
+        )
+
+    @property
+    def max_current_hardware(self) -> Union[int, float]:
+        return self._max_current_hardware
+
+    @property
+    def max_voltage_hardware(self) -> Union[int, float]:
+        return self._max_voltage_hardware
+
+    @property
+    def unit_voltage(self) -> UnitVoltage:  # noqa: F821
+        return self._unit_voltage
+
+    @property
+    def unit_current(self) -> UnitCurrent:  # noqa: F821
+        return self._unit_current
+
+    @property
+    def max_current(self) -> Union[int, float]:
+        return self._max_current
+
+    @max_current.setter
+    def max_current(self, value: Union[int, float]):
+        if not 0 <= value <= self._max_current_hardware:
+            raise ValueError(
+                "max_current must positive " "and below max_current_hardware."
+            )
+        self._max_current = value
+
+    @property
+    def max_voltage(self) -> Union[int, float]:
+        return self._max_voltage
+
+    @max_voltage.setter
+    def max_voltage(self, value: Union[int, float]):
+        if not 0 <= value <= self._max_voltage_hardware:
+            raise ValueError(
+                "max_voltage must be positive " "and below max_voltage_hardware."
+            )
+        self._max_voltage = value
+
+    def start(self) -> None:
+        """
+        Opens the communication protocol and configures the device.
+        """
+
+        # starting Heinzinger Digital Interface
+        super().start()
+
+        logger.info("Starting device " + str(self))
+
+        # find out which type of source this is:
+        self.identify_device()
+        self.set_number_of_recordings(self.config.default_number_of_recordings)
+
+    def identify_device(self) -> None:
+        """
+        Identify the device nominal voltage and current based on its serial number.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        serial_number = self.get_serial_number()
+        # regex to find the model of the device
+        regex_vc = r"(\d+)-(\d+)"  # voltage-current info
+        regex_model = r"PNC.*?" + regex_vc + r"\s?[a-z]{3}"
+        result = re.search(regex_model, serial_number)
+        if result:
+            self._serial_number = serial_number
+            model = result.group()
+            self._model = model
+            # regex to find the nominal voltage and nominal current
+            match = re.search(regex_vc, model)
+            assert match  # already matched in regex_model expression
+            voltage = int(match.group(1))
+            current = int(match.group(2))
+            # identifying the units to use for voltage and current
+            if voltage < 100000:
+                self._unit_voltage = self.UnitVoltage.V
+                self._max_voltage_hardware = voltage
+                self._max_voltage = voltage
+            else:
+                self._unit_voltage = self.UnitVoltage.kV
+                self._max_voltage_hardware = int(voltage / 1000)
+                self._max_voltage = int(voltage / 1000)
+            if current < 1000:
+                self._unit_current = self.UnitCurrent.mA
+                self._max_current_hardware = current
+                self._max_current = current
+            else:
+                self._unit_current = self.UnitCurrent.A
+                self._max_current_hardware = int(current / 1000)
+                self._max_current = int(current / 1000)
+            logger.info(f"Device {model} successfully identified")
+        else:
+            raise HeinzingerPNCDeviceNotRecognizedException(serial_number)
+
+    def set_voltage(self, value: Union[int, float]) -> None:
+        """
+        Sets the output voltage of the Heinzinger PNC to the given value.
+
+        :param value: voltage expressed in `self.unit_voltage`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        if value > self.max_voltage:
+            raise HeinzingerPNCMaxVoltageExceededException
+        elif value < 0:
+            raise ValueError("voltage must be positive")
+
+        super().set_voltage(value)
+
+    def set_current(self, value: Union[int, float]) -> None:
+        """
+        Sets the output current of the Heinzinger PNC to the given value.
+
+        :param value: current expressed in `self.unit_current`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        if value > self.max_current:
+            raise HeinzingerPNCMaxCurrentExceededException
+        elif value < 0:
+            raise ValueError("current must be positive")
+
+        super().set_current(value)
+
+
+class HeinzingerPNCError(DeviceException):
+    """
+    General error with the Heinzinger PNC voltage source.
+    """
+
+    pass
+
+
+class HeinzingerPNCMaxVoltageExceededException(HeinzingerPNCError):
+    """
+    Error indicating that program attempted to set the voltage
+    to a value exceeding 'max_voltage'.
+    """
+
+    pass
+
+
+class HeinzingerPNCMaxCurrentExceededException(HeinzingerPNCError):
+    """
+    Error indicating that program attempted to set the current
+    to a value exceeding 'max_current'.
+    """
+
+    pass
+
+
+class HeinzingerPNCDeviceNotRecognizedException(HeinzingerPNCError):
+    """
+    Error indicating that the serial number of the device
+    is not recognized.
+    """
+
+    pass
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/labjack.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/labjack.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,709 +1,705 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-A LabJack T-series devices wrapper around the LabJack's LJM Library; see
-https://labjack.com/ljm .
-The wrapper was originally developed and tested for a LabJack T7-PRO device.
-
-Extra installation
-~~~~~~~~~~~~~~~~~~
-
-To use this LabJack T-series devices wrapper:
-
-1. install the :code:`hvl_ccb` package with a :code:`labjack` extra feature::
-
-        $ pip install "hvl_ccb[labjack]"
-
-   this will install the Python bindings for the library.
-
-2. install the library - follow instruction in
-   https://labjack.com/support/software/installers/ljm .
-
-"""
-from __future__ import annotations
-
-import logging
-from collections.abc import Sequence
-from numbers import Real
-from typing import Union, Optional, List, cast, Dict
-
-from aenum import Enum, IntEnum
-
-from .._dev import labjack
-from ..comm import LJMCommunication
-from ..dev import SingleCommDevice
-from ..utils.enum import NameEnum, StrEnumBase
-from ..utils.typing import Number
-from ..utils.validation import validate_bool, validate_number
-
-logger = logging.getLogger(__name__)
-
-
-class LabJackError(Exception):
-    """
-    Errors of the LabJack device.
-    """
-
-    pass
-
-
-class LabJackIdentifierDIOError(Exception):
-    """
-    Error indicating a wrong DIO identifier
-    """
-
-    pass
-
-
-class LabJack(SingleCommDevice):
-    """
-    LabJack Device.
-
-    This class is tested with a LabJack T7-Pro and should also work with T4 and T7
-    devices communicating through the LJM Library. Other or older hardware versions and
-    variants of LabJack devices are not supported.
-    """
-
-    DeviceType = labjack.DeviceType
-    """
-    LabJack device types.
-    """
-
-    def __init__(self, com, dev_config=None) -> None:
-        """
-        Constructor for a LabJack Device.
-
-        :param com: Communication protocol object of type
-            LJMCommunication. If a configuration (dict or configdataclass) is given,
-            a new communication protocol object will be instantiated.
-        :param dev_config: There is no device configuration for LabJack yet.
-        """
-        super().__init__(com, dev_config)
-
-        # cached device type
-        self._device_type: Optional[labjack.DeviceType] = None
-
-        # clock configuration for pulse out feature
-        self.configured_pulse_addresses: List[
-            Union[str, labjack.TSeriesDIOChannel]] = []
-
-    @staticmethod
-    def default_com_cls():
-        return LJMCommunication
-
-    def start(self) -> None:
-        """
-        Start the Device.
-        """
-
-        logger.info(f"Starting device {str(self)}")
-        super().start()
-
-    def stop(self) -> None:
-        """
-        Stop the Device.
-        """
-
-        logger.info(f"Stopping device {str(self)}")
-        super().stop()
-
-    def _read_float(self, *names: str) -> Union[float, Sequence[float]]:
-        """
-        Read a numeric value.
-
-        :param name: name to read via communication protocol
-        :return: read numeric value
-        """
-        return self.com.read_name(*names, return_num_type=float)
-
-    def _read_int(self, *names: str) -> Union[int, Sequence[int]]:
-        """
-        Read an integer value.
-
-        :param name: name to read via communication protocol
-        :return: read integer value
-        """
-        return self.com.read_name(*names, return_num_type=int)
-
-    def get_serial_number(self) -> int:
-        """
-        Returns the serial number of the connected LabJack.
-
-        :return: Serial number.
-        """
-
-        return cast(int, self._read_int("SERIAL_NUMBER"))
-
-    def get_sbus_temp(self, number: int) -> float:
-        """
-        Read the temperature value from a serial SBUS sensor.
-
-        :param number: port number (0..22)
-        :return: temperature in Kelvin
-        """
-
-        return cast(float, self._read_float(f"SBUS{number}_TEMP"))
-
-    def get_sbus_rh(self, number: int) -> float:
-        """
-        Read the relative humidity value from a serial SBUS sensor.
-
-        :param number: port number (0..22)
-        :return: relative humidity in %RH
-        """
-
-        return cast(float, self._read_float(f"SBUS{number}_RH"))
-
-    class AInRange(StrEnumBase):
-        _init_ = "value_str"
-        TEN = "10"
-        ONE = "1"
-        ONE_TENTH = "0.1"
-        ONE_HUNDREDTH = "0.01"
-
-        def __str__(self) -> str:
-            return self.value_str
-
-        @property
-        def value(self) -> float:
-            return float(self.value_str)
-
-    def get_ain(self, *channels: int) -> Union[float, Sequence[float]]:
-        """
-        Read currently measured value (voltage, resistance, ...) from one or more
-        of analog inputs.
-
-        :param channels: AIN number or numbers (0..254)
-        :return: the read value (voltage, resistance, ...) as `float`or `tuple` of
-            them in case multiple channels given
-        """
-        ch_str = [f"AIN{ch}" for ch in channels]
-        return self._read_float(*ch_str)
-
-    def set_analog_output(self, channel: int, value: Number) -> None:
-        """
-        Set the voltage of a analog output port
-
-        :param channel: DAC channel number 1/0
-        :param value: The output voltage value 0-5 Volts int/float
-        """
-        validate_number("DAC channel number", channel, (0, 1), int, logger)
-        validate_number("DAC output voltage", value, (0.0, 5.0), logger=logger)
-        self.com.write_name(f"DAC{channel}", value)
-
-    def set_ain_range(self, channel: int, vrange: Union[Real, AInRange]) -> None:
-        """
-        Set the range of an analog input port.
-
-        :param channel: is the AIN number (0..254)
-        :param vrange: is the voltage range to be set
-        """
-        vrange = self.AInRange(str(vrange))
-        self.com.write_name(f"AIN{channel}_RANGE", vrange.value)
-
-    def set_ain_resolution(self, channel: int, resolution: int) -> None:
-        """
-        Set the resolution index of an analog input port.
-
-        :param channel: is the AIN number (0..254)
-        :param resolution: is the resolution index within
-            0...`get_product_type().ain_max_resolution` range; 0 will set the
-            resolution index to default value.
-        """
-
-        ain_max_resolution = self.get_product_type().ain_max_resolution  # type: ignore
-        if resolution not in range(ain_max_resolution + 1):
-            raise LabJackError(f"Not supported resolution index: {resolution}")
-
-        self.com.write_name(f"AIN{channel}_RESOLUTION_INDEX", resolution)
-
-    def set_ain_differential(self, pos_channel: int, differential: bool) -> None:
-        """
-        Sets an analog input to differential mode or not.
-        T7-specific: For base differential channels, positive must be even channel
-        from 0-12 and negative must be positive+1. For extended channels 16-127,
-        see Mux80 datasheet.
-
-        :param pos_channel: is the AIN number (0..12)
-        :param differential: True or False
-        :raises LabJackError: if parameters are unsupported
-        """
-
-        if pos_channel not in range(13):
-            raise LabJackError(f"Not supported pos_channel: {pos_channel}")
-
-        if pos_channel % 2 != 0:
-            raise LabJackError(
-                f"AIN pos_channel for positive part of differential pair"
-                f" must be even: {pos_channel}"
-            )
-
-        neg_channel = pos_channel + 1
-
-        self.com.write_name(
-            f"AIN{pos_channel}_NEGATIVE_CH", neg_channel if differential else 199
-        )
-
-    class ThermocoupleType(NameEnum):
-        """
-        Thermocouple type; NONE means disable thermocouple mode.
-        """
-
-        _init_ = "ef_index"
-        NONE = 0
-        E = 20
-        J = 21
-        K = 22
-        R = 23
-        T = 24
-        S = 25
-        C = 30
-        PT100 = 40
-        PT500 = 41
-        PT1000 = 42
-
-    class CjcType(NameEnum):
-        """
-        CJC slope and offset
-        """
-
-        _init_ = "slope offset"
-        internal = 1, 0
-        lm34 = 55.56, 255.37
-
-    class TemperatureUnit(NameEnum):
-        """
-        Temperature unit (to be returned)
-        """
-
-        _init_ = "ef_config_a"
-        K = 0
-        C = 1
-        F = 2
-
-    def set_ain_thermocouple(
-        self,
-        pos_channel: int,
-        thermocouple: Union[None, str, ThermocoupleType],
-        cjc_address: int = 60050,
-        cjc_type: Union[str, CjcType] = (
-            CjcType.internal  # type: ignore
-        ),
-        vrange: Union[Real, AInRange] = (
-            AInRange.ONE_HUNDREDTH  # type: ignore
-        ),
-        resolution: int = 10,
-        unit: Union[str, TemperatureUnit] = (
-            TemperatureUnit.K  # type: ignore
-        ),
-    ) -> None:
-        """
-        Set the analog input channel to thermocouple mode.
-
-        :param pos_channel: is the analog input channel of the positive part of the
-            differential pair
-        :param thermocouple: None to disable thermocouple mode, or string specifying
-            the thermocouple type
-        :param cjc_address: modbus register address to read the CJC temperature
-        :param cjc_type: determines cjc slope and offset, 'internal' or 'lm34'
-        :param vrange: measurement voltage range
-        :param resolution: resolution index (T7-Pro: 0-12)
-        :param unit: is the temperature unit to be returned ('K', 'C' or 'F')
-        :raises LabJackError: if parameters are unsupported
-        """
-
-        if thermocouple is None:
-            thermocouple = self.ThermocoupleType.NONE  # type: ignore
-
-        thermocouple = self.ThermocoupleType(thermocouple)
-
-        # validate separately from `set_ain_range` to fail before any write happens
-        # (in `set_ain_differential` first)
-        vrange = self.AInRange(str(vrange))
-
-        unit = self.TemperatureUnit(unit)
-
-        cjc_type = self.CjcType(cjc_type)
-
-        self.set_ain_differential(pos_channel=pos_channel, differential=True)
-        self.set_ain_range(pos_channel, vrange)
-        self.set_ain_resolution(pos_channel, resolution)
-        self.set_ain_range(pos_channel + 1, vrange)
-        self.set_ain_resolution(pos_channel + 1, resolution)
-
-        # specify thermocouple mode
-        self.com.write_name(f"AIN{pos_channel}_EF_INDEX", thermocouple.ef_index)
-
-        # specify the units for AIN#_EF_READ_A and AIN#_EF_READ_C (0 = K, 1 = C, 2 = F)
-        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_A", unit.ef_config_a)
-
-        # specify modbus address for cold junction reading CJC
-        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_B", cjc_address)
-
-        # set slope for the CJC reading, typically 1
-        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_D", cjc_type.slope)
-
-        # set the offset for the CJC reading, typically 0
-        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_E", cjc_type.offset)
-
-    def read_thermocouple(self, pos_channel: int) -> float:
-        """
-        Read the temperature of a connected thermocouple.
-
-        :param pos_channel: is the AIN number of the positive pin
-        :return: temperature in specified unit
-        """
-
-        return round(cast(float, self._read_float(f"AIN{pos_channel}_EF_READ_A")), 2)
-
-    class DIOStatus(IntEnum):
-        """
-        State of a digital I/O channel.
-        """
-
-        LOW = 0
-        HIGH = 1
-
-    def set_digital_output(self, address: str, state: Union[int, DIOStatus]) -> None:
-        """
-        Set the value of a digital output.
-
-        :param address: name of the output -> `'FIO0'`
-        :param state: state of the output -> `DIOStatus` instance or corresponding `int`
-            value
-        """
-        dt = self.get_product_type()
-        if address not in (
-            dt.dio  # type: ignore
-        ):
-            raise LabJackIdentifierDIOError
-        state = self.DIOStatus(state)
-        self.com.write_name(address, state)
-
-    DIOChannel = labjack.TSeriesDIOChannel
-
-    def get_digital_input(
-        self, address: Union[str, labjack.TSeriesDIOChannel]
-    ) -> LabJack.DIOStatus:
-        """
-        Get the value of a digital input.
-
-        allowed names for T7 (Pro): FIO0 - FIO7, EIO0 - EIO 7, CIO0- CIO3, MIO0 - MIO2
-        :param address: name of the output -> 'FIO0'
-        :return: HIGH when `address` DIO is high, and LOW when `address` DIO is low
-        """
-        if not isinstance(address, self.DIOChannel):
-            address = self.DIOChannel(address)
-        dt = self.get_product_type()
-        if address not in (
-            dt.dio  # type: ignore
-        ):
-            dt_name = dt.name  # type: ignore
-            raise LabJackIdentifierDIOError(
-                f"DIO {address.name} is not available for this device type: {dt_name}."
-            )
-        try:
-            ret = self._read_int(address.name)
-            return self.DIOStatus(ret)
-        except ValueError as e:
-            logger.error(str(e), exc_info=e)
-            raise LabJackIdentifierDIOError(f"Expected 0 or 1 return value, got {ret}.")
-
-    class CalMicroAmpere(Enum):
-        """
-        Pre-defined microampere (uA) values for calibration current source query.
-        """
-
-        _init_ = "value current_source_query"
-        TEN = "10uA", "CURRENT_SOURCE_10UA_CAL_VALUE"
-        TWO_HUNDRED = "200uA", "CURRENT_SOURCE_200UA_CAL_VALUE"
-
-    def get_cal_current_source(self, name: Union[str, CalMicroAmpere]) -> float:
-        """
-        This function will return the calibration of the chosen current source,
-        this ist not a measurement!
-
-        The value was stored during fabrication.
-
-        :param name: '200uA' or '10uA' current source
-        :return: calibration of the chosen current source in ampere
-        """
-        if not isinstance(name, self.CalMicroAmpere):
-            name = self.CalMicroAmpere(name)
-        return cast(float, self._read_float(name.current_source_query))
-
-    def get_product_id(self) -> int:
-        """
-        This function returns the product ID reported by the connected device.
-
-        Attention: returns `7` for both T7 and T7-Pro devices!
-
-        :return: integer product ID of the device
-        """
-        return cast(int, self._read_int("PRODUCT_ID"))
-
-    def get_product_type(self, force_query_id: bool = False) -> labjack.DeviceType:
-        """
-        This function will return the device type based on reported device type and
-        in case of unambiguity based on configuration of device's communication
-        protocol (e.g. for "T7" and  "T7_PRO" devices), or, if not available first
-        matching.
-
-
-        :param force_query_id: boolean flag to force `get_product_id` query to device
-            instead of using cached device type from previous queries.
-        :return: `DeviceType` instance
-        :raises LabJackIdentifierDIOError: when read Product ID is unknown
-        """
-        if force_query_id or not self._device_type:
-            try:
-                device_type_or_list = self.DeviceType.get_by_p_id(self.get_product_id())
-            except ValueError as e:
-                logger.error(str(e), exc_info=e)
-                raise LabJackIdentifierDIOError from e
-            if isinstance(device_type_or_list, self.DeviceType):
-                device_type = device_type_or_list
-            else:  # isinstance(device_type_or_list, list):
-                device_type_list: List[labjack.DeviceType] = device_type_or_list
-                # can be None in case a non-default com or its config was used
-                conf_device_type = getattr(self.com.config, "device_type", None)
-                if conf_device_type:
-                    if conf_device_type not in device_type_list:
-                        raise LabJackIdentifierDIOError(
-                            f"Configured devices type {conf_device_type!s} does not "
-                            f"match any of the unambiguously reported device types: "
-                            f"{','.join(str(dt) for dt in device_type_list)}."
-                        )
-                    device_type = conf_device_type
-                else:
-                    device_type = device_type_list[0]
-            self._device_type = device_type
-        return self._device_type
-
-    def get_product_name(self, force_query_id=False) -> str:
-        """
-        This function will return the product name based on product ID reported by
-        the device.
-
-        Attention: returns "T7" for both T7 and T7-Pro devices!
-
-        :param force_query_id: boolean flag to force `get_product_id` query to device
-            instead of using cached device type from previous queries.
-        :return: device name string, compatible with `LabJack.DeviceType`
-        """
-        return self.get_product_type(force_query_id=force_query_id).name
-
-    def set_ain_resistance(
-        self, channel: int, vrange: Union[Real, AInRange], resolution: int
-    ) -> None:
-        """
-        Set the specified channel to resistance mode. It utilized the 200uA current
-        source of the LabJack.
-
-        :param channel: channel that should measure the resistance
-        :param vrange: voltage range of the channel
-        :param resolution: resolution index of the channel T4: 0-5, T7: 0-8, T7-Pro 0-12
-        """
-        self.set_ain_range(channel, vrange)
-        self.set_ain_resolution(channel, resolution)
-
-        # resistance mode
-        self.com.write_name(f"AIN{channel}_EF_INDEX", 4)
-        # excitation with 200uA current source
-        self.com.write_name(f"AIN{channel}_EF_CONFIG_B", 0)
-
-    def read_resistance(self, channel: int) -> float:
-        """
-        Read resistance from specified channel.
-
-        :param channel: channel with resistor
-        :return: resistance value with 2 decimal places
-        """
-        return round(cast(float, self._read_float(f"AIN{channel}_EF_READ_A")), 2)
-
-    class ClockFrequency(IntEnum):
-        """
-        Available clock frequencies, in Hz
-        """
-        MAXIMUM = 80_000_000
-        FORTY_MHZ = 40_000_000
-        TWENTY_MHZ = 20_000_000
-        TEN_MHZ = 10_000_000
-        FIVE_MHZ = 5_000_000
-        TWENTY_FIVE_HUNDRED_KHZ = 2_500_000
-        TWELVE_HUNDRED_FIFTY_KHZ = 1_250_000
-        MINIMUM = 312_500
-
-    class BitLimit(IntEnum):
-        """
-        Maximum integer values for clock settings
-        """
-        THIRTY_TWO_BIT = 2 ** 32 - 1
-
-    @property
-    def _clock_config(self) -> Dict[str, int]:
-        clock_config = {"divisor": self.com.read_name("DIO_EF_CLOCK0_DIVISOR"),
-                        "roll_value": self.com.read_name("DIO_EF_CLOCK0_ROLL_VALUE")}
-        # adjust zeroes to corresponding real values for frequency/period conversion:
-        if clock_config["divisor"] == 0:
-            clock_config["divisor"] = 1
-        if clock_config["roll_value"] == 0:
-            clock_config["roll_value"] = self.BitLimit.THIRTY_TWO_BIT
-
-        return clock_config
-
-    @_clock_config.setter
-    def _clock_config(self, clock_config: Dict[str, int]):
-        self.com.write_name("DIO_EF_CLOCK0_DIVISOR", clock_config["divisor"])
-        self.com.write_name("DIO_EF_CLOCK0_ROLL_VALUE", clock_config["roll_value"])
-
-    def enable_clock(self, clock_enabled: bool) -> None:
-        """
-        Enable/disable LabJack clock to configure or send pulses.
-        :param clock_enabled: True -> enable, False -> disable.
-        :raises TypeError: if clock_enabled is not of type bool
-        """
-        validate_bool("clock enabled", clock_enabled, logger=logger)
-        self.com.write_name("DIO_EF_CLOCK0_ENABLE", int(clock_enabled))
-
-    def get_clock(self) -> Dict[str, Number]:
-        """
-        Return clock settings read from LabJack.
-        """
-        divisor, roll_value = self._clock_config.values()
-        clock_frequency = self.ClockFrequency.MAXIMUM / divisor
-        clock_period = clock_frequency * roll_value
-        clock_settings = {"clock_frequency": clock_frequency,
-                          "clock_period": clock_period}
-        return clock_settings
-
-    def set_clock(self,
-                  clock_frequency: Union[Number, ClockFrequency] = 10_000_000,
-                  clock_period: Number = 1) -> None:
-        """
-        Configure LabJack clock for pulse out feature.
-        :param clock_frequency: clock frequency in Hz; default 10 MHz for base 10.
-        :raises ValueError: if clock_frequency is not allowed (see ClockFrequency).
-        :param clock_period: clock roll time in seconds; default 1s, 0 for max.
-        :raises ValueError: if clock_period exceeds the 32bit tick limit.
-        Clock period determines pulse spacing when using multi-pulse settings.
-        Ensure period exceeds maximum intended pulse end time.
-        """
-        validate_number("clock frequency", clock_frequency,
-                        limits=(self.ClockFrequency.MINIMUM,
-                                self.ClockFrequency.MAXIMUM),
-                        logger=logger)
-        clock_frequency = self.ClockFrequency(clock_frequency)
-        divisor = int(self.ClockFrequency.MAXIMUM / clock_frequency)
-        validate_number("clock period", clock_period,
-                        limits=(0, self.BitLimit.THIRTY_TWO_BIT/clock_frequency),
-                        logger=logger)
-        clock_period_ticks = int(clock_period * clock_frequency)
-
-        self.enable_clock(False)
-        self._clock_config = {"divisor": divisor, "roll_value": clock_period_ticks}
-        # adjust zero input to real period for logging.
-        if clock_period == 0:
-            clock_period = self.BitLimit.THIRTY_TWO_BIT/clock_frequency
-        logger.info(f"Clock frequency is set to {clock_frequency:_} Hz")
-        logger.info(f"Clock period is set to {clock_period} s")
-
-    def config_high_pulse(self, address: Union[str, labjack.TSeriesDIOChannel],
-                          t_start: Number, t_width: Number, n_pulses: int = 1) -> None:
-        """
-        Configures one FIO channel to send a timed HIGH pulse.
-        Configure multiple channels to send pulses with relative timing accuracy.
-        Times have a maximum resolution of 1e-7 seconds @ 10 MHz.
-        :param address: FIO channel: [T7] FIO0;2;3;4;5. [T4] FIO6;7.
-        :raises LabJackError if address is not supported.
-        :param t_start: pulse start time in seconds.
-        :raises ValueError: if t_start is negative or would exceed the clock period.
-        :param t_width: duration of high pulse, in seconds.
-        :raises ValueError: if t_width is negative or would exceed the clock period.
-        :param n_pulses: number of pulses to be sent; single pulse default.
-        :raises TypeError if n_pulses is not of type int.
-        :raises Value Error if n_pulses is negative or exceeds the 32bit limit.
-        """
-        if not isinstance(address, self.DIOChannel):
-            address = self.DIOChannel(address)
-
-        device_type = self.get_product_type()
-        if address not in device_type.pulse_out_addr:
-            msg = f"{address} does not support pulse feature"
-            logging.error(msg)
-            raise LabJackError(msg)
-
-        divisor, roll_value = self._clock_config.values()
-
-        clock_frequency = int(self.ClockFrequency.MAXIMUM/divisor)
-        clock_period = clock_frequency * roll_value
-
-        validate_number("pulse start", t_start,
-                        limits=(0, clock_period), logger=logger)
-        validate_number("pulse width", t_width,
-                        limits=(0, clock_period - t_start), logger=logger)
-        validate_number("n pulses", n_pulses,
-                        limits=(0, self.BitLimit.THIRTY_TWO_BIT),
-                        number_type=int, logger=logger)
-
-        start_tick = int(t_start * clock_frequency)
-        end_tick = int((t_start + t_width) * clock_frequency)
-        addr = address.address
-
-        self.enable_clock(False)
-        self.com.write_names({f"DIO{addr}": 0,
-                              f"DIO{addr}_EF_ENABLE": 0,
-                              f"DIO{addr}_EF_OPTIONS": 0,
-                              f"DIO{addr}_EF_INDEX": 2,
-                              f"DIO{addr}_EF_CONFIG_B": start_tick,
-                              f"DIO{addr}_EF_CONFIG_A": end_tick,
-                              f"DIO{addr}_EF_CONFIG_C": n_pulses})
-
-        if address not in self.configured_pulse_addresses:
-            self.configured_pulse_addresses.append(address)
-        logger.info(f"Pulse configured for {address}")
-
-    def send_pulses(self, *addresses: Union[str, labjack.TSeriesDIOChannel]) -> None:
-        """
-        Sends pre-configured pulses for specified addresses.
-        :param addresses: tuple of FIO addresses
-        :raises LabJackError if an address has not been configured.
-        """
-        address_list = []
-        for address in addresses:
-            if not isinstance(address, self.DIOChannel):
-                address = self.DIOChannel(address)
-            if address not in self.configured_pulse_addresses:
-                msg = f"No pulse configured for {address}"
-                logging.error(msg)
-                raise LabJackError(msg)
-            address_list.append(address.address)
-
-        self.enable_clock(False)
-        for addr in address_list:
-            self.com.write_name(f"DIO{addr}_EF_ENABLE", 1)
-
-        self.enable_clock(True)
-        logger.info(f"Pulses sent on {addresses}")
-
-    def disable_pulses(self,
-                       *addresses: Optional[Union[str, labjack.TSeriesDIOChannel]]
-                       ) -> None:
-        """
-        Disable previously configured pulse channels.
-        :param addresses: tuple of FIO addresses.
-        All channels disabled if no argument is passed.
-        """
-        self.enable_clock(False)
-        if len(addresses) == 0:
-            addresses = tuple(self.configured_pulse_addresses)
-
-        for address in addresses:
-            if not isinstance(address, self.DIOChannel):
-                address = self.DIOChannel(address)
-            if address not in self.configured_pulse_addresses:
-                logging.warning(f"No pulse configured for {address}")
-                continue
-            self.com.write_name(f"DIO{address.address}_EF_ENABLE", 0)
-            self.configured_pulse_addresses.remove(address.name)
-            logger.info(f"Pulse disabled for {address}")
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+A LabJack T-series devices wrapper around the LabJack's LJM Library; see
+https://labjack.com/ljm .
+The wrapper was originally developed and tested for a LabJack T7-PRO device.
+
+Extra installation
+~~~~~~~~~~~~~~~~~~
+
+To use this LabJack T-series devices wrapper:
+
+1. install the :code:`hvl_ccb` package with a :code:`labjack` extra feature::
+
+        $ pip install "hvl_ccb[labjack]"
+
+   this will install the Python bindings for the library.
+
+2. install the library - follow instruction in
+   https://labjack.com/support/software/installers/ljm .
+
+"""
+from __future__ import annotations
+
+import logging
+from collections.abc import Sequence
+from numbers import Real
+from typing import Union, Optional, List, cast, Dict
+
+from aenum import Enum, IntEnum
+
+from hvl_ccb.dev.base import DeviceException
+from .._dev import labjack
+from ..comm import LJMCommunication
+from ..dev import SingleCommDevice
+from ..utils.enum import NameEnum, StrEnumBase
+from ..utils.typing import Number
+from ..utils.validation import validate_bool, validate_number
+
+logger = logging.getLogger(__name__)
+
+
+class LabJackError(DeviceException):
+    """
+    General Exception for the LabJack device.
+    """
+
+    pass
+
+
+class LabJackIdentifierDIOError(LabJackError):
+    """
+    Error indicating a wrong DIO identifier
+    """
+
+    pass
+
+
+class LabJack(SingleCommDevice):
+    """
+    LabJack Device.
+
+    This class is tested with a LabJack T7-Pro and should also work with T4 and T7
+    devices communicating through the LJM Library. Other or older hardware versions and
+    variants of LabJack devices are not supported.
+    """
+
+    DeviceType = labjack.DeviceType
+    """
+    LabJack device types.
+    """
+
+    def __init__(self, com, dev_config=None) -> None:
+        """
+        Constructor for a LabJack Device.
+
+        :param com: Communication protocol object of type
+            LJMCommunication. If a configuration (dict or configdataclass) is given,
+            a new communication protocol object will be instantiated.
+        :param dev_config: There is no device configuration for LabJack yet.
+        """
+        super().__init__(com, dev_config)
+
+        # cached device type
+        self._device_type: Optional[labjack.DeviceType] = None
+
+        # clock configuration for pulse out feature
+        self.configured_pulse_addresses: List[
+            Union[str, labjack.TSeriesDIOChannel]] = []
+
+    @staticmethod
+    def default_com_cls():
+        return LJMCommunication
+
+    def start(self) -> None:
+        """
+        Start the Device.
+        """
+
+        logger.info(f"Starting device {str(self)}")
+        super().start()
+
+    def stop(self) -> None:
+        """
+        Stop the Device.
+        """
+
+        logger.info(f"Stopping device {str(self)}")
+        super().stop()
+
+    def _read_float(self, *names: str) -> Union[float, Sequence[float]]:
+        """
+        Read a numeric value.
+
+        :param name: name to read via communication protocol
+        :return: read numeric value
+        """
+        return self.com.read_name(*names, return_num_type=float)
+
+    def _read_int(self, *names: str) -> Union[int, Sequence[int]]:
+        """
+        Read an integer value.
+
+        :param name: name to read via communication protocol
+        :return: read integer value
+        """
+        return self.com.read_name(*names, return_num_type=int)
+
+    def get_serial_number(self) -> int:
+        """
+        Returns the serial number of the connected LabJack.
+
+        :return: Serial number.
+        """
+
+        return cast(int, self._read_int("SERIAL_NUMBER"))
+
+    def get_sbus_temp(self, number: int) -> float:
+        """
+        Read the temperature value from a serial SBUS sensor.
+
+        :param number: port number (0..22)
+        :return: temperature in Kelvin
+        """
+
+        return cast(float, self._read_float(f"SBUS{number}_TEMP"))
+
+    def get_sbus_rh(self, number: int) -> float:
+        """
+        Read the relative humidity value from a serial SBUS sensor.
+
+        :param number: port number (0..22)
+        :return: relative humidity in %RH
+        """
+
+        return cast(float, self._read_float(f"SBUS{number}_RH"))
+
+    class AInRange(StrEnumBase, init="value_str"):  # type:ignore
+        TEN = "10"
+        ONE = "1"
+        ONE_TENTH = "0.1"
+        ONE_HUNDREDTH = "0.01"
+
+        def __str__(self) -> str:
+            return self.value_str
+
+        @property
+        def value(self) -> float:
+            return float(self.value_str)
+
+    def get_ain(self, *channels: int) -> Union[float, Sequence[float]]:
+        """
+        Read currently measured value (voltage, resistance, ...) from one or more
+        of analog inputs.
+
+        :param channels: AIN number or numbers (0..254)
+        :return: the read value (voltage, resistance, ...) as `float`or `tuple` of
+            them in case multiple channels given
+        """
+        ch_str = [f"AIN{ch}" for ch in channels]
+        return self._read_float(*ch_str)
+
+    def set_analog_output(self, channel: int, value: Number) -> None:
+        """
+        Set the voltage of a analog output port
+
+        :param channel: DAC channel number 1/0
+        :param value: The output voltage value 0-5 Volts int/float
+        """
+        validate_number("DAC channel number", channel, (0, 1), int, logger)
+        validate_number("DAC output voltage", value, (0.0, 5.0), logger=logger)
+        self.com.write_name(f"DAC{channel}", value)
+
+    def set_ain_range(self, channel: int, vrange: Union[Real, AInRange]) -> None:
+        """
+        Set the range of an analog input port.
+
+        :param channel: is the AIN number (0..254)
+        :param vrange: is the voltage range to be set
+        """
+        vrange = self.AInRange(str(vrange))
+        self.com.write_name(f"AIN{channel}_RANGE", vrange.value)
+
+    def set_ain_resolution(self, channel: int, resolution: int) -> None:
+        """
+        Set the resolution index of an analog input port.
+
+        :param channel: is the AIN number (0..254)
+        :param resolution: is the resolution index within
+            0...`get_product_type().ain_max_resolution` range; 0 will set the
+            resolution index to default value.
+        """
+
+        ain_max_resolution = self.get_product_type().ain_max_resolution  # type: ignore
+        if resolution not in range(ain_max_resolution + 1):
+            raise LabJackError(f"Not supported resolution index: {resolution}")
+
+        self.com.write_name(f"AIN{channel}_RESOLUTION_INDEX", resolution)
+
+    def set_ain_differential(self, pos_channel: int, differential: bool) -> None:
+        """
+        Sets an analog input to differential mode or not.
+        T7-specific: For base differential channels, positive must be even channel
+        from 0-12 and negative must be positive+1. For extended channels 16-127,
+        see Mux80 datasheet.
+
+        :param pos_channel: is the AIN number (0..12)
+        :param differential: True or False
+        :raises LabJackError: if parameters are unsupported
+        """
+
+        if pos_channel not in range(13):
+            raise LabJackError(f"Not supported pos_channel: {pos_channel}")
+
+        if pos_channel % 2 != 0:
+            raise LabJackError(
+                f"AIN pos_channel for positive part of differential pair"
+                f" must be even: {pos_channel}"
+            )
+
+        neg_channel = pos_channel + 1
+
+        self.com.write_name(
+            f"AIN{pos_channel}_NEGATIVE_CH", neg_channel if differential else 199
+        )
+
+    class ThermocoupleType(NameEnum, init="ef_index"):  # type:ignore
+        """
+        Thermocouple type; NONE means disable thermocouple mode.
+        """
+
+        NONE = 0
+        E = 20
+        J = 21
+        K = 22
+        R = 23
+        T = 24
+        S = 25
+        C = 30
+        PT100 = 40
+        PT500 = 41
+        PT1000 = 42
+
+    class CjcType(NameEnum, init="slope offset"):  # type:ignore
+        """
+        CJC slope and offset
+        """
+
+        internal = 1, 0
+        lm34 = 55.56, 255.37
+
+    class TemperatureUnit(NameEnum, init="ef_config_a"):  # type:ignore
+        """
+        Temperature unit (to be returned)
+        """
+
+        K = 0
+        C = 1
+        F = 2
+
+    def set_ain_thermocouple(
+        self,
+        pos_channel: int,
+        thermocouple: Union[None, str, ThermocoupleType],
+        cjc_address: int = 60050,
+        cjc_type: Union[str, CjcType] = (
+            CjcType.internal  # type: ignore
+        ),
+        vrange: Union[Real, AInRange] = (
+            AInRange.ONE_HUNDREDTH  # type: ignore
+        ),
+        resolution: int = 10,
+        unit: Union[str, TemperatureUnit] = (
+            TemperatureUnit.K  # type: ignore
+        ),
+    ) -> None:
+        """
+        Set the analog input channel to thermocouple mode.
+
+        :param pos_channel: is the analog input channel of the positive part of the
+            differential pair
+        :param thermocouple: None to disable thermocouple mode, or string specifying
+            the thermocouple type
+        :param cjc_address: modbus register address to read the CJC temperature
+        :param cjc_type: determines cjc slope and offset, 'internal' or 'lm34'
+        :param vrange: measurement voltage range
+        :param resolution: resolution index (T7-Pro: 0-12)
+        :param unit: is the temperature unit to be returned ('K', 'C' or 'F')
+        :raises LabJackError: if parameters are unsupported
+        """
+
+        if thermocouple is None:
+            thermocouple = self.ThermocoupleType.NONE  # type: ignore
+
+        thermocouple = self.ThermocoupleType(thermocouple)
+
+        # validate separately from `set_ain_range` to fail before any write happens
+        # (in `set_ain_differential` first)
+        vrange = self.AInRange(str(vrange))
+
+        unit = self.TemperatureUnit(unit)
+
+        cjc_type = self.CjcType(cjc_type)
+
+        self.set_ain_differential(pos_channel=pos_channel, differential=True)
+        self.set_ain_range(pos_channel, vrange)
+        self.set_ain_resolution(pos_channel, resolution)
+        self.set_ain_range(pos_channel + 1, vrange)
+        self.set_ain_resolution(pos_channel + 1, resolution)
+
+        # specify thermocouple mode
+        self.com.write_name(f"AIN{pos_channel}_EF_INDEX", thermocouple.ef_index)
+
+        # specify the units for AIN#_EF_READ_A and AIN#_EF_READ_C (0 = K, 1 = C, 2 = F)
+        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_A", unit.ef_config_a)
+
+        # specify modbus address for cold junction reading CJC
+        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_B", cjc_address)
+
+        # set slope for the CJC reading, typically 1
+        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_D", cjc_type.slope)
+
+        # set the offset for the CJC reading, typically 0
+        self.com.write_name(f"AIN{pos_channel}_EF_CONFIG_E", cjc_type.offset)
+
+    def read_thermocouple(self, pos_channel: int) -> float:
+        """
+        Read the temperature of a connected thermocouple.
+
+        :param pos_channel: is the AIN number of the positive pin
+        :return: temperature in specified unit
+        """
+
+        return round(cast(float, self._read_float(f"AIN{pos_channel}_EF_READ_A")), 2)
+
+    class DIOStatus(IntEnum):
+        """
+        State of a digital I/O channel.
+        """
+
+        LOW = 0
+        HIGH = 1
+
+    def set_digital_output(self, address: str, state: Union[int, DIOStatus]) -> None:
+        """
+        Set the value of a digital output.
+
+        :param address: name of the output -> `'FIO0'`
+        :param state: state of the output -> `DIOStatus` instance or corresponding `int`
+            value
+        """
+        dt = self.get_product_type()
+        if address not in (
+            dt.dio  # type: ignore
+        ):
+            raise LabJackIdentifierDIOError
+        state = self.DIOStatus(state)
+        self.com.write_name(address, state)
+
+    DIOChannel = labjack.TSeriesDIOChannel
+
+    def get_digital_input(
+        self, address: Union[str, labjack.TSeriesDIOChannel]
+    ) -> LabJack.DIOStatus:
+        """
+        Get the value of a digital input.
+
+        allowed names for T7 (Pro): FIO0 - FIO7, EIO0 - EIO 7, CIO0- CIO3, MIO0 - MIO2
+        :param address: name of the output -> 'FIO0'
+        :return: HIGH when `address` DIO is high, and LOW when `address` DIO is low
+        """
+        if not isinstance(address, self.DIOChannel):
+            address = self.DIOChannel(address)
+        dt = self.get_product_type()
+        if address not in (
+            dt.dio  # type: ignore
+        ):
+            dt_name = dt.name  # type: ignore
+            raise LabJackIdentifierDIOError(
+                f"DIO {address.name} is not available for this device type: {dt_name}."
+            )
+        try:
+            ret = self._read_int(address.name)
+            return self.DIOStatus(ret)
+        except ValueError as e:
+            logger.error(str(e), exc_info=e)
+            raise LabJackIdentifierDIOError(f"Expected 0 or 1 return value, got {ret}.")
+
+    class CalMicroAmpere(Enum, init="value current_source_query"):  # type: ignore
+        """
+        Pre-defined microampere (uA) values for calibration current source query.
+        """
+
+        TEN = "10uA", "CURRENT_SOURCE_10UA_CAL_VALUE"
+        TWO_HUNDRED = "200uA", "CURRENT_SOURCE_200UA_CAL_VALUE"
+
+    def get_cal_current_source(self, name: Union[str, CalMicroAmpere]) -> float:
+        """
+        This function will return the calibration of the chosen current source,
+        this ist not a measurement!
+
+        The value was stored during fabrication.
+
+        :param name: '200uA' or '10uA' current source
+        :return: calibration of the chosen current source in ampere
+        """
+        if not isinstance(name, self.CalMicroAmpere):
+            name = self.CalMicroAmpere(name)
+        return cast(float, self._read_float(name.current_source_query))
+
+    def get_product_id(self) -> int:
+        """
+        This function returns the product ID reported by the connected device.
+
+        Attention: returns `7` for both T7 and T7-Pro devices!
+
+        :return: integer product ID of the device
+        """
+        return cast(int, self._read_int("PRODUCT_ID"))
+
+    def get_product_type(self, force_query_id: bool = False) -> labjack.DeviceType:
+        """
+        This function will return the device type based on reported device type and
+        in case of unambiguity based on configuration of device's communication
+        protocol (e.g. for "T7" and  "T7_PRO" devices), or, if not available first
+        matching.
+
+
+        :param force_query_id: boolean flag to force `get_product_id` query to device
+            instead of using cached device type from previous queries.
+        :return: `DeviceType` instance
+        :raises LabJackIdentifierDIOError: when read Product ID is unknown
+        """
+        if force_query_id or not self._device_type:
+            try:
+                device_type_or_list = self.DeviceType.get_by_p_id(self.get_product_id())
+            except ValueError as e:
+                logger.error(str(e), exc_info=e)
+                raise LabJackIdentifierDIOError from e
+            if isinstance(device_type_or_list, self.DeviceType):
+                device_type = device_type_or_list
+            else:  # isinstance(device_type_or_list, list):
+                device_type_list: List[labjack.DeviceType] = device_type_or_list
+                # can be None in case a non-default com or its config was used
+                conf_device_type = getattr(self.com.config, "device_type", None)
+                if conf_device_type:
+                    if conf_device_type not in device_type_list:
+                        raise LabJackIdentifierDIOError(
+                            f"Configured devices type {conf_device_type!s} does not "
+                            f"match any of the unambiguously reported device types: "
+                            f"{','.join(str(dt) for dt in device_type_list)}."
+                        )
+                    device_type = conf_device_type
+                else:
+                    device_type = device_type_list[0]
+            self._device_type = device_type
+        return self._device_type
+
+    def get_product_name(self, force_query_id=False) -> str:
+        """
+        This function will return the product name based on product ID reported by
+        the device.
+
+        Attention: returns "T7" for both T7 and T7-Pro devices!
+
+        :param force_query_id: boolean flag to force `get_product_id` query to device
+            instead of using cached device type from previous queries.
+        :return: device name string, compatible with `LabJack.DeviceType`
+        """
+        return self.get_product_type(force_query_id=force_query_id).name
+
+    def set_ain_resistance(
+        self, channel: int, vrange: Union[Real, AInRange], resolution: int
+    ) -> None:
+        """
+        Set the specified channel to resistance mode. It utilized the 200uA current
+        source of the LabJack.
+
+        :param channel: channel that should measure the resistance
+        :param vrange: voltage range of the channel
+        :param resolution: resolution index of the channel T4: 0-5, T7: 0-8, T7-Pro 0-12
+        """
+        self.set_ain_range(channel, vrange)
+        self.set_ain_resolution(channel, resolution)
+
+        # resistance mode
+        self.com.write_name(f"AIN{channel}_EF_INDEX", 4)
+        # excitation with 200uA current source
+        self.com.write_name(f"AIN{channel}_EF_CONFIG_B", 0)
+
+    def read_resistance(self, channel: int) -> float:
+        """
+        Read resistance from specified channel.
+
+        :param channel: channel with resistor
+        :return: resistance value with 2 decimal places
+        """
+        return round(cast(float, self._read_float(f"AIN{channel}_EF_READ_A")), 2)
+
+    class ClockFrequency(IntEnum):
+        """
+        Available clock frequencies, in Hz
+        """
+        MAXIMUM = 80_000_000
+        FORTY_MHZ = 40_000_000
+        TWENTY_MHZ = 20_000_000
+        TEN_MHZ = 10_000_000
+        FIVE_MHZ = 5_000_000
+        TWENTY_FIVE_HUNDRED_KHZ = 2_500_000
+        TWELVE_HUNDRED_FIFTY_KHZ = 1_250_000
+        MINIMUM = 312_500
+
+    class BitLimit(IntEnum):
+        """
+        Maximum integer values for clock settings
+        """
+        THIRTY_TWO_BIT = 2 ** 32 - 1
+
+    @property
+    def _clock_config(self) -> Dict[str, int]:
+        clock_config = {"divisor": self.com.read_name("DIO_EF_CLOCK0_DIVISOR"),
+                        "roll_value": self.com.read_name("DIO_EF_CLOCK0_ROLL_VALUE")}
+        # adjust zeroes to corresponding real values for frequency/period conversion:
+        if clock_config["divisor"] == 0:
+            clock_config["divisor"] = 1
+        if clock_config["roll_value"] == 0:
+            clock_config["roll_value"] = self.BitLimit.THIRTY_TWO_BIT
+
+        return clock_config
+
+    @_clock_config.setter
+    def _clock_config(self, clock_config: Dict[str, int]):
+        self.com.write_name("DIO_EF_CLOCK0_DIVISOR", clock_config["divisor"])
+        self.com.write_name("DIO_EF_CLOCK0_ROLL_VALUE", clock_config["roll_value"])
+
+    def enable_clock(self, clock_enabled: bool) -> None:
+        """
+        Enable/disable LabJack clock to configure or send pulses.
+        :param clock_enabled: True -> enable, False -> disable.
+        :raises TypeError: if clock_enabled is not of type bool
+        """
+        validate_bool("clock enabled", clock_enabled, logger=logger)
+        self.com.write_name("DIO_EF_CLOCK0_ENABLE", int(clock_enabled))
+
+    def get_clock(self) -> Dict[str, Number]:
+        """
+        Return clock settings read from LabJack.
+        """
+        divisor, roll_value = self._clock_config.values()
+        clock_frequency = self.ClockFrequency.MAXIMUM / divisor
+        clock_period = clock_frequency * roll_value
+        clock_settings = {"clock_frequency": clock_frequency,
+                          "clock_period": clock_period}
+        return clock_settings
+
+    def set_clock(self,
+                  clock_frequency: Union[Number, ClockFrequency] = 10_000_000,
+                  clock_period: Number = 1) -> None:
+        """
+        Configure LabJack clock for pulse out feature.
+        :param clock_frequency: clock frequency in Hz; default 10 MHz for base 10.
+        :raises ValueError: if clock_frequency is not allowed (see ClockFrequency).
+        :param clock_period: clock roll time in seconds; default 1s, 0 for max.
+        :raises ValueError: if clock_period exceeds the 32bit tick limit.
+        Clock period determines pulse spacing when using multi-pulse settings.
+        Ensure period exceeds maximum intended pulse end time.
+        """
+        validate_number("clock frequency", clock_frequency,
+                        limits=(self.ClockFrequency.MINIMUM,
+                                self.ClockFrequency.MAXIMUM),
+                        logger=logger)
+        clock_frequency = self.ClockFrequency(clock_frequency)
+        divisor = int(self.ClockFrequency.MAXIMUM / clock_frequency)
+        validate_number("clock period", clock_period,
+                        limits=(0, self.BitLimit.THIRTY_TWO_BIT/clock_frequency),
+                        logger=logger)
+        clock_period_ticks = int(clock_period * clock_frequency)
+
+        self.enable_clock(False)
+        self._clock_config = {"divisor": divisor, "roll_value": clock_period_ticks}
+        # adjust zero input to real period for logging.
+        if clock_period == 0:
+            clock_period = self.BitLimit.THIRTY_TWO_BIT/clock_frequency
+        logger.info(f"Clock frequency is set to {clock_frequency:_} Hz")
+        logger.info(f"Clock period is set to {clock_period} s")
+
+    def config_high_pulse(self, address: Union[str, labjack.TSeriesDIOChannel],
+                          t_start: Number, t_width: Number, n_pulses: int = 1) -> None:
+        """
+        Configures one FIO channel to send a timed HIGH pulse.
+        Configure multiple channels to send pulses with relative timing accuracy.
+        Times have a maximum resolution of 1e-7 seconds @ 10 MHz.
+        :param address: FIO channel: [T7] FIO0;2;3;4;5. [T4] FIO6;7.
+        :raises LabJackError if address is not supported.
+        :param t_start: pulse start time in seconds.
+        :raises ValueError: if t_start is negative or would exceed the clock period.
+        :param t_width: duration of high pulse, in seconds.
+        :raises ValueError: if t_width is negative or would exceed the clock period.
+        :param n_pulses: number of pulses to be sent; single pulse default.
+        :raises TypeError if n_pulses is not of type int.
+        :raises Value Error if n_pulses is negative or exceeds the 32bit limit.
+        """
+        if not isinstance(address, self.DIOChannel):
+            address = self.DIOChannel(address)
+
+        device_type = self.get_product_type()
+        if address not in device_type.pulse_out_addr:
+            msg = f"{address} does not support pulse feature"
+            logging.error(msg)
+            raise LabJackError(msg)
+
+        divisor, roll_value = self._clock_config.values()
+
+        clock_frequency = int(self.ClockFrequency.MAXIMUM/divisor)
+        clock_period = clock_frequency * roll_value
+
+        validate_number("pulse start", t_start,
+                        limits=(0, clock_period), logger=logger)
+        validate_number("pulse width", t_width,
+                        limits=(0, clock_period - t_start), logger=logger)
+        validate_number("n pulses", n_pulses,
+                        limits=(0, self.BitLimit.THIRTY_TWO_BIT),
+                        number_type=int, logger=logger)
+
+        start_tick = int(t_start * clock_frequency)
+        end_tick = int((t_start + t_width) * clock_frequency)
+        addr = address.address
+
+        self.enable_clock(False)
+        self.com.write_names({f"DIO{addr}": 0,
+                              f"DIO{addr}_EF_ENABLE": 0,
+                              f"DIO{addr}_EF_OPTIONS": 0,
+                              f"DIO{addr}_EF_INDEX": 2,
+                              f"DIO{addr}_EF_CONFIG_B": start_tick,
+                              f"DIO{addr}_EF_CONFIG_A": end_tick,
+                              f"DIO{addr}_EF_CONFIG_C": n_pulses})
+
+        if address not in self.configured_pulse_addresses:
+            self.configured_pulse_addresses.append(address)
+        logger.info(f"Pulse configured for {address}")
+
+    def send_pulses(self, *addresses: Union[str, labjack.TSeriesDIOChannel]) -> None:
+        """
+        Sends pre-configured pulses for specified addresses.
+        :param addresses: tuple of FIO addresses
+        :raises LabJackError if an address has not been configured.
+        """
+        address_list = []
+        for address in addresses:
+            if not isinstance(address, self.DIOChannel):
+                address = self.DIOChannel(address)
+            if address not in self.configured_pulse_addresses:
+                msg = f"No pulse configured for {address}"
+                logging.error(msg)
+                raise LabJackError(msg)
+            address_list.append(address.address)
+
+        self.enable_clock(False)
+        for addr in address_list:
+            self.com.write_name(f"DIO{addr}_EF_ENABLE", 1)
+
+        self.enable_clock(True)
+        logger.info(f"Pulses sent on {addresses}")
+
+    def disable_pulses(self,
+                       *addresses: Optional[Union[str, labjack.TSeriesDIOChannel]]
+                       ) -> None:
+        """
+        Disable previously configured pulse channels.
+        :param addresses: tuple of FIO addresses.
+        All channels disabled if no argument is passed.
+        """
+        self.enable_clock(False)
+        if len(addresses) == 0:
+            addresses = tuple(self.configured_pulse_addresses)
+
+        for address in addresses:
+            if not isinstance(address, self.DIOChannel):
+                address = self.DIOChannel(address)
+            if address not in self.configured_pulse_addresses:
+                logging.warning(f"No pulse configured for {address}")
+                continue
+            self.com.write_name(f"DIO{address.address}_EF_ENABLE", 0)
+            self.configured_pulse_addresses.remove(address.name)
+            logger.info(f"Pulse disabled for {address}")
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/mbw973.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/mbw973.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,312 +1,312 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device class for controlling a MBW 973 SF6 Analyzer over a serial connection.
-
-The MBW 973 is a gas analyzer designed for gas insulated switchgear and measures
-humidity, SF6 purity and SO2 contamination in one go.
-Manufacturer homepage: https://www.mbw.ch/products/sf6-gas-analysis/973-sf6-analyzer/
-"""
-
-import logging
-from typing import Dict, Type, Union
-
-from .base import SingleCommDevice
-from .utils import Poller
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class MBW973Error(Exception):
-    """
-    General error with the MBW973 dew point mirror device.
-    """
-
-    pass
-
-
-class MBW973ControlRunningException(MBW973Error):
-    """
-    Error indicating there is still a measurement running, and a new one cannot be
-    started.
-    """
-
-    pass
-
-
-class MBW973PumpRunningException(MBW973Error):
-    """
-    Error indicating the pump of the dew point mirror is still recovering gas,
-    unable to start a new measurement.
-    """
-
-    pass
-
-
-@configdataclass
-class MBW973SerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for MBW973 is 9600 baud
-    baudrate: int = 9600
-
-    #: MBW973 does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: MBW973 does use one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is only CR
-    terminator: bytes = b"\r"
-
-    #: use 3 seconds timeout as default
-    timeout: Number = 3
-
-
-class MBW973SerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for the MBW973 dew point mirror.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    @staticmethod
-    def config_cls():
-        return MBW973SerialCommunicationConfig
-
-
-@configdataclass
-class MBW973Config:
-    """
-    Device configuration dataclass for MBW973.
-    """
-
-    #: Polling period for `is_done` status queries [in seconds].
-    polling_interval: Number = 2
-
-    def clean_values(self):
-        if self.polling_interval <= 0:
-            raise ValueError("Polling interval needs to be positive.")
-
-
-class MBW973(SingleCommDevice):
-    """
-    MBW 973 dew point mirror device class.
-    """
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # polling status
-        self.status_poller = Poller(
-            self.is_done,
-            polling_delay_sec=self.config.polling_interval,
-            polling_interval_sec=self.config.polling_interval,
-        )
-
-        # is done with dew point = True, new measurement sample required and
-        # not ready yet = False
-        self.is_done_with_measurements = True
-
-        # dict telling what measurement options are selected
-        self.measurement_options = {
-            "dewpoint": True,
-            "SF6_Vol": False,
-        }
-
-        self.last_measurement_values = {}
-
-    @staticmethod
-    def default_com_cls():
-        return MBW973SerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return MBW973Config
-
-    def start(self) -> None:
-        """
-        Start this device. Opens the communication protocol and retrieves the
-        set measurement options from the device.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened.
-        """
-
-        logger.info("Starting device " + str(self))
-        super().start()
-
-        # check test options
-        self.write("HumidityTest?")
-        self.measurement_options["dewpoint"] = bool(self.read_int())
-
-        self.write("SF6PurityTest?")
-        self.measurement_options["SF6_Vol"] = bool(self.read_int())
-
-    def stop(self) -> None:
-        """
-        Stop the device. Closes also the communication protocol.
-        """
-
-        logger.info("Stopping device " + str(self))
-        super().stop()
-
-    def write(self, value) -> None:
-        """
-        Send `value` to `self.com`.
-
-        :param value: Value to send, converted to `str`.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        self.com.write_text(str(value))
-
-    def read(self, cast_type: Type = str):
-        """
-        Read value from `self.com` and cast to `cast_type`.
-        Raises `ValueError` if read text (`str`) is not convertible to `cast_type`,
-        e.g. to `float` or to `int`.
-
-        :return: Read value of `cast_type` type.
-        """
-        return cast_type(self.com.read_text())
-
-    def read_float(self) -> float:
-        """
-        Convenience wrapper for `self.read()`, with typing hint for return value.
-
-        :return: Read `float` value.
-        """
-        return self.read(float)
-
-    def read_int(self) -> int:
-        """
-        Convenience wrapper for `self.read()`, with typing hint for return value.
-
-        :return: Read `int` value.
-        """
-        return self.read(int)
-
-    def is_done(self) -> bool:
-        """
-        Poll status of the dew point mirror and return True, if all
-        measurements are done.
-
-        :return: True, if all measurements are done; False otherwise.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        # assume everything is done
-        done = True
-
-        if self.measurement_options["dewpoint"]:
-            # ask if done with DP
-            self.write("DoneWithDP?")
-            done = done and bool(self.read_int())
-
-        if self.measurement_options["SF6_Vol"]:
-            # ask if done with SF6 volume measurement
-            self.write("SF6VolHold?")
-            done = done and bool(self.read_int())
-
-        self.is_done_with_measurements = done
-
-        if self.is_done_with_measurements:
-            self.status_poller.stop_polling()
-            self.read_measurements()
-
-        return self.is_done_with_measurements
-
-    def start_control(self) -> None:
-        """
-        Start dew point control to acquire a new value set.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        # send control?
-        self.write("control?")
-
-        if self.read_float():
-            raise MBW973ControlRunningException
-
-        # send Pump.on? to check, whether gas is still being pumped back
-        self.write("Pump.on?")
-
-        if self.read_float():
-            raise MBW973PumpRunningException
-
-        # start control of device
-        self.write("control=1")
-        logger.info("Starting dew point control")
-        self.is_done_with_measurements = False
-        self.status_poller.start_polling()
-
-    def read_measurements(self) -> Dict[str, float]:
-        """
-        Read out measurement values and return them as a dictionary.
-
-        :return: Dictionary with values.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.write("Fp?")
-        frostpoint = self.read_float()
-
-        self.write("Fp1?")
-        frostpoint_ambient = self.read_float()
-
-        self.write("Px?")
-        pressure = self.read_float()
-
-        self.write("PPMv?")
-        ppmv = self.read_float()
-
-        self.write("PPMw?")
-        ppmw = self.read_float()
-
-        self.write("SF6Vol?")
-        sf6_vol = self.read_float()
-
-        values = {
-            "frostpoint": frostpoint,
-            "frostpoint_ambient": frostpoint_ambient,
-            "pressure": pressure,
-            "ppmv": ppmv,
-            "ppmw": ppmw,
-            "sf6_vol": sf6_vol,
-        }
-
-        logger.info("Read out values")
-        logger.info(values)
-
-        self.last_measurement_values = values
-
-        return values
-
-    def set_measuring_options(
-        self, humidity: bool = True, sf6_purity: bool = False
-    ) -> None:
-        """
-        Send measuring options to the dew point mirror.
-
-        :param humidity: Perform humidity test or not?
-        :param sf6_purity: Perform SF6 purity test or not?
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.write(f"HumidityTest={1 if humidity else 0}")
-        self.write(f"SF6PurityTest={1 if sf6_purity else 0}")
-
-        self.measurement_options["dewpoint"] = humidity
-        self.measurement_options["SF6_Vol"] = sf6_purity
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device class for controlling a MBW 973 SF6 Analyzer over a serial connection.
+
+The MBW 973 is a gas analyzer designed for gas insulated switchgear and measures
+humidity, SF6 purity and SO2 contamination in one go.
+Manufacturer homepage: https://www.mbw.ch/products/sf6-gas-analysis/973-sf6-analyzer/
+"""
+
+import logging
+from typing import Dict, Type, Union
+
+from .base import SingleCommDevice, DeviceException
+from .utils import Poller
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class MBW973Error(DeviceException):
+    """
+    General error with the MBW973 dew point mirror device.
+    """
+
+    pass
+
+
+class MBW973ControlRunningException(MBW973Error):
+    """
+    Error indicating there is still a measurement running, and a new one cannot be
+    started.
+    """
+
+    pass
+
+
+class MBW973PumpRunningException(MBW973Error):
+    """
+    Error indicating the pump of the dew point mirror is still recovering gas,
+    unable to start a new measurement.
+    """
+
+    pass
+
+
+@configdataclass
+class MBW973SerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for MBW973 is 9600 baud
+    baudrate: int = 9600
+
+    #: MBW973 does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: MBW973 does use one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is only CR
+    terminator: bytes = b"\r"
+
+    #: use 3 seconds timeout as default
+    timeout: Number = 3
+
+
+class MBW973SerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for the MBW973 dew point mirror.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    @staticmethod
+    def config_cls():
+        return MBW973SerialCommunicationConfig
+
+
+@configdataclass
+class MBW973Config:
+    """
+    Device configuration dataclass for MBW973.
+    """
+
+    #: Polling period for `is_done` status queries [in seconds].
+    polling_interval: Number = 2
+
+    def clean_values(self):
+        if self.polling_interval <= 0:
+            raise ValueError("Polling interval needs to be positive.")
+
+
+class MBW973(SingleCommDevice):
+    """
+    MBW 973 dew point mirror device class.
+    """
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # polling status
+        self.status_poller = Poller(
+            self.is_done,
+            polling_delay_sec=self.config.polling_interval,
+            polling_interval_sec=self.config.polling_interval,
+        )
+
+        # is done with dew point = True, new measurement sample required and
+        # not ready yet = False
+        self.is_done_with_measurements = True
+
+        # dict telling what measurement options are selected
+        self.measurement_options = {
+            "dewpoint": True,
+            "SF6_Vol": False,
+        }
+
+        self.last_measurement_values = {}
+
+    @staticmethod
+    def default_com_cls():
+        return MBW973SerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return MBW973Config
+
+    def start(self) -> None:
+        """
+        Start this device. Opens the communication protocol and retrieves the
+        set measurement options from the device.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened.
+        """
+
+        logger.info("Starting device " + str(self))
+        super().start()
+
+        # check test options
+        self.write("HumidityTest?")
+        self.measurement_options["dewpoint"] = bool(self.read_int())
+
+        self.write("SF6PurityTest?")
+        self.measurement_options["SF6_Vol"] = bool(self.read_int())
+
+    def stop(self) -> None:
+        """
+        Stop the device. Closes also the communication protocol.
+        """
+
+        logger.info("Stopping device " + str(self))
+        super().stop()
+
+    def write(self, value) -> None:
+        """
+        Send `value` to `self.com`.
+
+        :param value: Value to send, converted to `str`.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        self.com.write_text(str(value))
+
+    def read(self, cast_type: Type = str):
+        """
+        Read value from `self.com` and cast to `cast_type`.
+        Raises `ValueError` if read text (`str`) is not convertible to `cast_type`,
+        e.g. to `float` or to `int`.
+
+        :return: Read value of `cast_type` type.
+        """
+        return cast_type(self.com.read_text())
+
+    def read_float(self) -> float:
+        """
+        Convenience wrapper for `self.read()`, with typing hint for return value.
+
+        :return: Read `float` value.
+        """
+        return self.read(float)
+
+    def read_int(self) -> int:
+        """
+        Convenience wrapper for `self.read()`, with typing hint for return value.
+
+        :return: Read `int` value.
+        """
+        return self.read(int)
+
+    def is_done(self) -> bool:
+        """
+        Poll status of the dew point mirror and return True, if all
+        measurements are done.
+
+        :return: True, if all measurements are done; False otherwise.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        # assume everything is done
+        done = True
+
+        if self.measurement_options["dewpoint"]:
+            # ask if done with DP
+            self.write("DoneWithDP?")
+            done = done and bool(self.read_int())
+
+        if self.measurement_options["SF6_Vol"]:
+            # ask if done with SF6 volume measurement
+            self.write("SF6VolHold?")
+            done = done and bool(self.read_int())
+
+        self.is_done_with_measurements = done
+
+        if self.is_done_with_measurements:
+            self.status_poller.stop_polling()
+            self.read_measurements()
+
+        return self.is_done_with_measurements
+
+    def start_control(self) -> None:
+        """
+        Start dew point control to acquire a new value set.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        # send control?
+        self.write("control?")
+
+        if self.read_float():
+            raise MBW973ControlRunningException
+
+        # send Pump.on? to check, whether gas is still being pumped back
+        self.write("Pump.on?")
+
+        if self.read_float():
+            raise MBW973PumpRunningException
+
+        # start control of device
+        self.write("control=1")
+        logger.info("Starting dew point control")
+        self.is_done_with_measurements = False
+        self.status_poller.start_polling()
+
+    def read_measurements(self) -> Dict[str, float]:
+        """
+        Read out measurement values and return them as a dictionary.
+
+        :return: Dictionary with values.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.write("Fp?")
+        frostpoint = self.read_float()
+
+        self.write("Fp1?")
+        frostpoint_ambient = self.read_float()
+
+        self.write("Px?")
+        pressure = self.read_float()
+
+        self.write("PPMv?")
+        ppmv = self.read_float()
+
+        self.write("PPMw?")
+        ppmw = self.read_float()
+
+        self.write("SF6Vol?")
+        sf6_vol = self.read_float()
+
+        values = {
+            "frostpoint": frostpoint,
+            "frostpoint_ambient": frostpoint_ambient,
+            "pressure": pressure,
+            "ppmv": ppmv,
+            "ppmw": ppmw,
+            "sf6_vol": sf6_vol,
+        }
+
+        logger.info("Read out values")
+        logger.info(values)
+
+        self.last_measurement_values = values
+
+        return values
+
+    def set_measuring_options(
+        self, humidity: bool = True, sf6_purity: bool = False
+    ) -> None:
+        """
+        Send measuring options to the dew point mirror.
+
+        :param humidity: Perform humidity test or not?
+        :param sf6_purity: Perform SF6 purity test or not?
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.write(f"HumidityTest={1 if humidity else 0}")
+        self.write(f"SF6PurityTest={1 if sf6_purity else 0}")
+
+        self.measurement_options["dewpoint"] = humidity
+        self.measurement_options["SF6_Vol"] = sf6_purity
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/newport.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/newport.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,1214 +1,1215 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device class for Newport SMC100PP stepper motor controller with serial communication.
-
-The SMC100PP is a single axis motion controller/driver for stepper motors up to 48 VDC
-at 1.5 A rms. Up to 31 controllers can be networked through the internal RS-485
-communication link.
-
-Manufacturer homepage:
-https://www.newport.com/f/smc100-single-axis-dc-or-stepper-motion-controller
-"""
-
-import logging
-from time import sleep, time
-from typing import Union, Dict, List
-
-# Note: PyCharm does not recognize the dependency correctly, it is added as pyserial.
-from aenum import Enum, IntEnum
-
-from .base import SingleCommDevice
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.enum import NameEnum, AutoNumberNameEnum
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-Param = Union[Number, str, None]
-
-
-@configdataclass
-class NewportSMC100PPSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for NewportSMC100 controller is 57600 baud
-    baudrate: int = 57600
-
-    #: NewportSMC100 controller does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: NewportSMC100 controller uses one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: NewportSMC100 controller uses 8 bits for one data byte
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is CR/LF
-    terminator: bytes = b"\r\n"
-
-    #: use 10 seconds timeout as default
-    timeout: Number = 10
-    #: use ASCII as de-/encoding, cf. the manual
-    encoding: str = "ascii"
-
-    #: replace bytes with � instead of raising utf-8 exception when decoding fails
-    encoding_error_handling: str = "replace"
-
-
-class NewportSMC100PPSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for NewportSMC100 controller.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    class ControllerErrors(Enum):
-        """
-        Possible controller errors with values as returned by the device in response
-        to sent commands.
-        """
-
-        _init_ = "value message"
-
-        NO_ERROR = "@", "No error."
-        CODE_OR_ADDR_INVALID = (
-            "A",
-            "Unknown message code or floating point controller address.",
-        )
-        ADDR_INCORRECT = "B", "Controller address not correct."
-        PARAM_MISSING_OR_INVALID = "C", "Parameter missing or out of range."
-        CMD_NOT_ALLOWED = "D", "Command not allowed."
-        HOME_STARTED = "E", "Home sequence already started."
-        ESP_STAGE_NAME_INVALID = (
-            "F",
-            "ESP stage name unknown.",
-        )
-        DISPLACEMENT_OUT_OF_LIMIT = (
-            "G",
-            "Displacement out of limits.",
-        )
-        CMD_NOT_ALLOWED_NOT_REFERENCED = (
-            "H",
-            "Command not allowed in NOT REFERENCED state.",
-        )
-        CMD_NOT_ALLOWED_CONFIGURATION = (
-            "I",
-            "Command not allowed in CONFIGURATION state.",
-        )
-        CMD_NOT_ALLOWED_DISABLE = "J", "Command not allowed in DISABLE state."
-        CMD_NOT_ALLOWED_READY = "K", "Command not allowed in READY state."
-        CMD_NOT_ALLOWED_HOMING = "L", "Command not allowed in HOMING state."
-        CMD_NOT_ALLOWED_MOVING = "M", "Command not allowed in MOVING state."
-        POSITION_OUT_OF_LIMIT = "N", "Current position out of software limit."
-        COM_TIMEOUT = (
-            "S",
-            "Communication Time Out.",
-        )
-        EEPROM_ACCESS_ERROR = "U", "Error during EEPROM access."
-        CMD_EXEC_ERROR = "V", "Error during command execution."
-        CMD_NOT_ALLOWED_PP = "W", "Command not allowed for PP version."
-        CMD_NOT_ALLOWED_CC = "X", "Command not allowed for CC version."
-
-    def __init__(self, configuration):
-        """
-        Constructor for NewportSMC100PPSerialCommunication.
-        """
-
-        super().__init__(configuration)
-
-    @staticmethod
-    def config_cls():
-        return NewportSMC100PPSerialCommunicationConfig
-
-    def read_text(self) -> str:
-        """
-        Read one line of text from the serial port, and check for presence of a null
-        char which indicates that the motor power supply was cut and then restored. The
-        input buffer may hold additional data afterwards, since only one line is read.
-
-        This method uses `self.access_lock` to ensure thread-safety.
-
-        :return: String read from the serial port; `''` if there was nothing to read.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises NewportMotorPowerSupplyWasCutError: if a null char is read
-        """
-
-        with self.access_lock:
-            line = super().read_text()
-            if "\x00" in line:
-                raise NewportMotorPowerSupplyWasCutError(
-                    'Unexpected message from motor:', line
-                )
-            return line
-
-    def _send_command_without_checking_error(
-        self, add: int, cmd: str, param: Param = None
-    ) -> None:
-        """
-        Send a command to the controller.
-
-        :param add: the controller address (1 to 31)
-        :param cmd: the command to be sent
-        :param param: optional parameter (int/float/str) appended to the command
-        """
-
-        if param is None:
-            param = ""
-
-        with self.access_lock:
-            self.write_text(f"{add}{cmd}{param}")
-            logger.debug(f"sent: {add}{cmd}{param}")
-
-    def _query_without_checking_errors(
-        self, add: int, cmd: str, param: Param = None
-    ) -> str:
-        """
-        Send a command to the controller and read the answer. The prefix add+cmd is
-        removed from the answer.
-
-        :param add: the controller address (1 to 31)
-        :param cmd: the command to be sent
-        :param param: optional parameter (int/float/str) appended to the command
-        :return: the answer from the device without the prefix
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if param is None:
-            param = ""
-
-        prefix = f"{add}{cmd}"
-        query = f"{add}{cmd}{param}"
-
-        with self.access_lock:
-            self._send_command_without_checking_error(add, cmd, param)
-            sleep(0.01)
-            answer = self.read_text().strip()
-            if len(answer) == 0:
-                message = f"Newport controller {add} did not answer to query {query}."
-                logger.error(message)
-                raise NewportSerialCommunicationError(message)
-            elif not answer.startswith(prefix):
-                message = (
-                    f"Newport controller {add} answer {answer} to query {query} "
-                    f"does not start with expected prefix {prefix}."
-                )
-                logger.error(message)
-                raise NewportSerialCommunicationError(message)
-            else:
-                logger.debug(f"Newport com: {answer}")
-                return answer[len(prefix):].strip()
-
-    def check_for_error(self, add: int) -> None:
-        """
-        Ask the Newport controller for the last error it recorded.
-
-        This method is called after every command or query.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        with self.access_lock:
-            error = self.ControllerErrors(
-                self._query_without_checking_errors(add, "TE")
-            )
-            if error is not self.ControllerErrors.NO_ERROR:
-                logger.error(f"NewportControllerError: {error.message}")
-                raise NewportControllerError(error.message)
-
-    def send_command(self, add: int, cmd: str, param: Param = None) -> None:
-        """
-        Send a command to the controller, and check for errors.
-
-        :param add: the controller address (1 to 31)
-        :param cmd: the command to be sent
-        :param param: optional parameter (int/float/str) appended to the command
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if param is None:
-            param = ""
-
-        with self.access_lock:
-            self._send_command_without_checking_error(add, cmd, param)
-            self.check_for_error(add)
-
-    def send_stop(self, add: int) -> None:
-        """
-        Send the general stop ST command to the controller, and check for errors.
-
-        :param add: the controller address (1 to 31)
-        :return: ControllerErrors reported by Newport Controller
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        """
-
-        with self.access_lock:
-            self.write_text("ST")
-            self.check_for_error(add)
-
-    def query(self, add: int, cmd: str, param: Param = None) -> str:
-        """
-        Send a query to the controller, read the answer, and check for errors. The
-        prefix add+cmd is removed from the answer.
-
-        :param add: the controller address (1 to 31)
-        :param cmd: the command to be sent
-        :param param: optional parameter (int/float/str) appended to the command
-        :return: the answer from the device without the prefix
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        with self.access_lock:
-
-            try:
-                answer = self._query_without_checking_errors(add, cmd, param)
-            finally:
-                self.check_for_error(add)
-
-        return answer
-
-    def query_multiple(self, add: int, cmd: str, prefixes: List[str]) -> List[str]:
-        """
-        Send a query to the controller, read the answers, and check for errors. The
-        prefixes are removed from the answers.
-
-        :param add: the controller address (1 to 31)
-        :param cmd: the command to be sent
-        :param prefixes: prefixes of each line expected in the answer
-        :return: list of answers from the device without prefix
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        with self.access_lock:
-
-            try:
-                self._send_command_without_checking_error(add, cmd)
-                answer = []
-                for prefix in prefixes:
-                    line = self.read_text().strip()
-                    if not line.startswith(prefix):
-                        message = (
-                            f"Newport controller {add} answer {line} to command "
-                            f"{cmd} does not start with expected prefix {prefix}."
-                        )
-                        logger.error(message)
-                        raise NewportSerialCommunicationError(message)
-                    else:
-                        answer.append(line[len(prefix) :])
-            finally:
-                self.check_for_error(add)
-
-        return answer
-
-
-class NewportConfigCommands(NameEnum):
-    """
-    Commands predefined by the communication protocol of the SMC100PP
-    """
-
-    AC = "acceleration"
-    BA = "backlash_compensation"
-    BH = "hysteresis_compensation"
-    FRM = "micro_step_per_full_step_factor"
-    FRS = "motion_distance_per_full_step"
-    HT = "home_search_type"
-    JR = "jerk_time"
-    OH = "home_search_velocity"
-    OT = "home_search_timeout"
-    QIL = "peak_output_current_limit"
-    SA = "rs485_address"
-    SL = "negative_software_limit"
-    SR = "positive_software_limit"
-    VA = "velocity"
-    VB = "base_velocity"
-    ZX = "stage_configuration"
-
-
-@configdataclass
-class NewportSMC100PPConfig:
-    """
-    Configuration dataclass for the Newport motor controller SMC100PP.
-    """
-
-    class HomeSearch(IntEnum):
-        """
-        Different methods for the motor to search its home position during
-        initialization.
-        """
-
-        HomeSwitch_and_Index = 0
-        CurrentPosition = 1
-        HomeSwitch = 2
-        EndOfRunSwitch_and_Index = 3
-        EndOfRunSwitch = 4
-
-    class EspStageConfig(IntEnum):
-        """
-        Different configurations to check or not the motor configuration upon power-up.
-        """
-
-        DisableEspStageCheck = 1
-        UpdateEspStageInfo = 2
-        EnableEspStageCheck = 3
-
-    # The following parameters are added for convenience, they do not correspond to any
-    # actual hardware configuration:
-
-    # controller address (1 to 31)
-    address: int = 1
-
-    # user position offset (mm). For convenience of the user, the motor
-    # position is given relative to this point:
-    user_position_offset: Number = 23.987
-
-    # correction for the scaling between screw turns and distance (should be close to 1)
-    screw_scaling: Number = 1
-
-    # nr of seconds to wait after exit configuration command has been issued
-    exit_configuration_wait_sec: Number = 5
-
-    # waiting time for a move
-    move_wait_sec: Number = 1
-
-    # The following parameters are actual hardware configuration parameters:
-
-    # acceleration (preset units/s^2)
-    acceleration: Number = 10
-
-    # backlash compensation (preset units)
-    # either backlash compensation or hysteresis compensation can be used, not both.
-    backlash_compensation: Number = 0
-
-    # hysteresis compensation (preset units)
-    # either backlash compensation or hysteresis compensation can be used, not both.
-    hysteresis_compensation: Number = 0.015
-
-    # micro step per full step factor, integer between 1 and 2000
-    micro_step_per_full_step_factor: int = 100
-
-    # motion distance per full step (preset units)
-    motion_distance_per_full_step: Number = 0.01
-
-    # home search type
-    home_search_type: Union[int, HomeSearch] = HomeSearch.HomeSwitch
-
-    # jerk time (s) -> time to reach the needed acceleration
-    jerk_time: Number = 0.04
-
-    # home search velocity (preset units/s)
-    home_search_velocity: Number = 4
-
-    # home search time-out (s)
-    home_search_timeout: Number = 27.5
-
-    # home search polling interval (s)
-    home_search_polling_interval: Number = 1
-
-    # peak output current delivered to the motor (A)
-    peak_output_current_limit: Number = 0.4
-
-    # RS485 address, integer between 2 and 31
-    rs485_address: int = 2
-
-    # lower limit for the motor position (mm)
-    negative_software_limit: Number = -23.5
-
-    # upper limit for the motor position (mm)
-    positive_software_limit: Number = 25
-
-    # maximum velocity (preset units/s), this is also the default velocity unless a
-    # lower value is set
-    velocity: Number = 4
-
-    # profile generator base velocity (preset units/s)
-    base_velocity: Number = 0
-
-    # ESP stage configuration
-    stage_configuration: Union[int, EspStageConfig] = EspStageConfig.EnableEspStageCheck
-
-    def clean_values(self):
-        if self.address not in range(1, 32):
-            raise ValueError("Address should be an integer between 1 and 31.")
-        if abs(self.screw_scaling - 1) > 0.1:
-            raise ValueError("The screw scaling should be close to 1.")
-        if not 0 < self.exit_configuration_wait_sec:
-            raise ValueError(
-                "The exit configuration wait time must be a positive "
-                "value (in seconds)."
-            )
-        if not 0 < self.move_wait_sec:
-            raise ValueError(
-                "The wait time for a move to finish must be a "
-                "positive value (in seconds)."
-            )
-        if not 1e-6 < self.acceleration < 1e12:
-            raise ValueError("The acceleration should be between 1e-6 and 1e12.")
-        if not 0 <= self.backlash_compensation < 1e12:
-            raise ValueError("The backlash compensation should be between 0 and 1e12.")
-        if not 0 <= self.hysteresis_compensation < 1e12:
-            raise ValueError(
-                "The hysteresis compensation should be between " "0 and 1e12."
-            )
-        if (
-            not isinstance(self.micro_step_per_full_step_factor, int)
-            or not 1 <= self.micro_step_per_full_step_factor <= 2000
-        ):
-            raise ValueError(
-                "The micro step per full step factor should be between 1 " "and 2000."
-            )
-        if not 1e-6 < self.motion_distance_per_full_step < 1e12:
-            raise ValueError(
-                "The motion distance per full step should be between 1e-6" " and 1e12."
-            )
-        if not isinstance(self.home_search_type, self.HomeSearch):
-            self.force_value("home_search_type", self.HomeSearch(self.home_search_type))
-        if not 1e-3 < self.jerk_time < 1e12:
-            raise ValueError("The jerk time should be between 1e-3 and 1e12.")
-        if not 1e-6 < self.home_search_velocity < 1e12:
-            raise ValueError(
-                "The home search velocity should be between 1e-6 " "and 1e12."
-            )
-        if not 1 < self.home_search_timeout < 1e3:
-            raise ValueError("The home search timeout should be between 1 and 1e3.")
-        if not 0 < self.home_search_polling_interval:
-            raise ValueError(
-                "The home search polling interval (sec) needs to have "
-                "a positive value."
-            )
-        if not 0.05 <= self.peak_output_current_limit <= 3:
-            raise ValueError(
-                "The peak output current limit should be between 0.05 A" "and 3 A."
-            )
-        if self.rs485_address not in range(2, 32):
-            raise ValueError("The RS485 address should be between 2 and 31.")
-        if not -1e12 < self.negative_software_limit <= 0:
-            raise ValueError(
-                "The negative software limit should be between -1e12 " "and 0."
-            )
-        if not 0 <= self.positive_software_limit < 1e12:
-            raise ValueError(
-                "The positive software limit should be between 0 " "and 1e12."
-            )
-        if not 1e-6 < self.velocity < 1e12:
-            raise ValueError("The velocity should be between 1e-6 and 1e12.")
-        if not 0 <= self.base_velocity <= self.velocity:
-            raise ValueError(
-                "The base velocity should be between 0 and the maximum " "velocity."
-            )
-        if not isinstance(self.stage_configuration, self.EspStageConfig):
-            self.force_value(
-                "stage_configuration", self.EspStageConfig(self.stage_configuration)
-            )
-
-    def _build_motor_config(self) -> Dict[str, float]:
-        return {
-            param.value: float(getattr(self, param.value))
-            for param in NewportConfigCommands  # type: ignore
-        }
-
-    @property
-    def motor_config(self) -> Dict[str, float]:
-        """
-        Gather the configuration parameters of the motor into a dictionary.
-
-        :return: dict containing the configuration parameters of the motor
-        """
-
-        if not hasattr(self, "_motor_config"):
-            self.force_value(  # type: ignore
-                "_motor_config",
-                self._build_motor_config(),
-            )
-        return self._motor_config  # type: ignore
-
-    def post_force_value(self, fieldname, value):
-        # if motor config is already cached and field is one of config commands fields..
-        if hasattr(self, "_motor_config") and fieldname in self._motor_config:
-            # ..update directly config dict value
-            self._motor_config[fieldname] = value
-
-
-class NewportStates(AutoNumberNameEnum):
-    """
-    States of the Newport controller. Certain commands are allowed only in certain
-    states.
-    """
-
-    NO_REF = ()
-    HOMING = ()
-    CONFIG = ()
-    READY = ()
-    MOVING = ()
-    DISABLE = ()
-    JOGGING = ()
-
-
-class NewportSMC100PP(SingleCommDevice):
-    """
-    Device class of the Newport motor controller SMC100PP
-    """
-
-    States = NewportStates
-
-    class MotorErrors(Enum):
-        """
-        Possible motor errors reported by the motor during get_state().
-        """
-
-        _init_ = "value message"
-
-        OUTPUT_POWER_EXCEEDED = 2, "80W output power exceeded"
-        DC_VOLTAGE_TOO_LOW = 3, "DC voltage too low"
-        WRONG_ESP_STAGE = 4, "Wrong ESP stage"
-        HOMING_TIMEOUT = 5, "Homing timeout"
-        FOLLOWING_ERROR = 6, "Following error"
-        SHORT_CIRCUIT = 7, "Short circuit detection"
-        RMS_CURRENT_LIMIT = 8, "RMS current limit"
-        PEAK_CURRENT_LIMIT = 9, "Peak current limit"
-        POS_END_OF_TURN = 10, "Positive end of turn"
-        NED_END_OF_TURN = 11, "Negative end of turn"
-
-    class StateMessages(Enum):
-        """
-        Possible messages returned by the controller on get_state() query.
-        """
-
-        _init_ = "value message state"
-
-        NO_REF_FROM_RESET = "0A", "NOT REFERENCED from reset.", NewportStates.NO_REF
-        NO_REF_FROM_HOMING = "0B", "NOT REFERENCED from HOMING.", NewportStates.NO_REF
-        NO_REF_FROM_CONFIG = (
-            "0C",
-            "NOT REFERENCED from CONFIGURATION.",
-            NewportStates.NO_REF,
-        )
-        NO_REF_FROM_DISABLED = (
-            "0D",
-            "NOT REFERENCED from DISABLE.",
-            NewportStates.NO_REF,
-        )
-        NO_REF_FROM_READY = "0E", "NOT REFERENCED from READY.", NewportStates.NO_REF
-        NO_REF_FROM_MOVING = "0F", "NOT REFERENCED from MOVING.", NewportStates.NO_REF
-        NO_REF_ESP_STAGE_ERROR = (
-            "10",
-            "NOT REFERENCED ESP stage error.",
-            NewportStates.NO_REF,
-        )
-        NO_REF_FROM_JOGGING = "11", "NOT REFERENCED from JOGGING.", NewportStates.NO_REF
-        CONFIG = "14", "CONFIGURATION.", NewportStates.CONFIG
-        HOMING_FROM_RS232 = (
-            "1E",
-            "HOMING commanded from RS-232-C.",
-            NewportStates.HOMING,
-        )
-        HOMING_FROM_SMC = "1F", "HOMING commanded by SMC-RC.", NewportStates.HOMING
-        MOVING = "28", "MOVING.", NewportStates.MOVING
-        READY_FROM_HOMING = "32", "READY from HOMING.", NewportStates.READY
-        READY_FROM_MOVING = "33", "READY from MOVING.", NewportStates.READY
-        READY_FROM_DISABLE = "34", "READY from DISABLE.", NewportStates.READY
-        READY_FROM_JOGGING = "35", "READY from JOGGING.", NewportStates.READY
-        DISABLE_FROM_READY = "3C", "DISABLE from READY.", NewportStates.DISABLE
-        DISABLE_FROM_MOVING = "3D", "DISABLE from MOVING.", NewportStates.DISABLE
-        DISABLE_FROM_JOGGING = "3E", "DISABLE from JOGGING.", NewportStates.DISABLE
-        JOGGING_FROM_READY = "46", "JOGGING from READY.", NewportStates.JOGGING
-        JOGGING_FROM_DISABLE = "47", "JOGGING from DISABLE.", NewportStates.JOGGING
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # address of the controller
-        self.address = self.config.address
-
-        # State of the controller (see state diagram in manual)
-        self.state = self.States.NO_REF
-
-        # position of the motor
-        self.position = None
-
-    def __repr__(self):
-        return f"Newport motor controller SMC100PP {self.address}"
-
-    @staticmethod
-    def default_com_cls():
-        return NewportSMC100PPSerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return NewportSMC100PPConfig
-
-    def start(self):
-        """
-        Opens the communication protocol and applies the config.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened
-        """
-
-        logger.info(f"Starting {self}")
-        super().start()
-
-        self.get_state()
-
-        if self.config.motor_config != self.get_motor_configuration():
-            logger.info(f"Updating {self} configuration")
-            if self.state != self.States.NO_REF:
-                self.reset()
-            self.go_to_configuration()
-            self.set_motor_configuration()
-            self.exit_configuration()
-
-        if self.state == self.States.NO_REF:
-            self.initialize()
-            self.wait_until_motor_initialized()
-
-    def stop(self) -> None:
-        """
-        Stop the device. Close the communication protocol.
-        """
-
-        try:
-            if self.com.is_open:
-                self.stop_motion()
-        finally:
-            logger.info(f"Stopping {self}")
-            # close the com
-            super().stop()
-
-    def get_state(self, add: int = None) -> "StateMessages":
-        """
-        Check on the motor errors and the controller state
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        :raises NewportMotorError: if the motor reports an error
-        :return: state message from the device (member of StateMessages)
-        """
-
-        if add is None:
-            add = self.address
-
-        # sometimes when restarting the Newport controller
-        # random bytes can be sent. In this scenario
-        # an error is raised and the query is repeated.
-        # So far on the second try the query is successful.
-        # cf. Issue #93 https://gitlab.com/ethz_hvl/hvl_ccb/-/issues/93
-        # and Issue #184 https://gitlab.com/ethz_hvl/hvl_ccb/-/issues/184
-        try:
-            ans = self.com.query(add, "TS")
-        except NewportMotorPowerSupplyWasCutError as e:
-            logger.error(str(e), exc_info=e)
-            # simply try again once
-            ans = self.com.query(add, "TS")
-
-        # the first symbol is not used, the next 3 symbols
-        # are hexadecimal. Once converted to binary, they
-        # indicate motor errors (see manual).
-        errors = []
-        for i in range(3):
-            bin_errors = bin(int(ans[i + 1], 16))[2:].zfill(4)
-            for j, b in enumerate(bin_errors):
-                if b == "1":
-                    errors.append(self.MotorErrors(i * 4 + j).message)
-        if len(errors) > 0:
-            message = f"Motor {add} error(s): {', '.join(errors)}"
-            logger.error(message)
-            raise NewportMotorError(message)
-        # the next two symbols indicate the controller state
-        s = self.StateMessages(ans[4:6])
-        logger.info(f"The newport controller {add} is in state {s.name}")
-        self.state = s.state
-        return s
-
-    def get_motor_configuration(self, add: int = None) -> Dict[str, float]:
-        """
-        Query the motor configuration and returns it in a dictionary.
-
-        :param add: controller address (1 to 31)
-        :return: dictionary containing the motor's configuration
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        # The controller answer should be lines starting with the following prefixes
-        prefixes = (
-            [f"{add}PW1", f"{add}ID"]
-            + [f"{add}{p.name}" for p in NewportConfigCommands]  # type: ignore
-            + [f"{add}PW0"]
-        )
-        answers = self.com.query_multiple(add, "ZT", prefixes)
-        # first and last line are expected to be only the prefixes
-        assert not (answers[0] + answers[-1])
-        # additionally, second line ID is not relevant
-        answers = answers[2:-1]
-
-        motor_config = {}
-        # for each config param, read the answer given by the controller
-        for prefix, answer in zip(NewportConfigCommands, answers):  # type: ignore
-            # cast the config param as a float and add the result to the config dict
-            motor_config[prefix.value] = float(answer)
-        return motor_config
-
-    def go_to_configuration(self, add: int = None) -> None:
-        """
-        This method is executed during start(). It can also be executed after a reset().
-        The controller is put in CONFIG state, where configuration parameters
-        can be changed.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(f"Newport controller {add} entering CONFIG state.")
-        self.com.send_command(add, "PW", 1)
-        self.state = self.States.CONFIG
-
-    def set_motor_configuration(self, add: int = None, config: dict = None) -> None:
-        """
-        Set the motor configuration. The motor must be in CONFIG state.
-
-        :param add: controller address (1 to 31)
-        :param config: dictionary containing the motor's configuration
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-        if config is None:
-            config = self.config.motor_config
-
-        logger.info(f"Setting motor {add} configuration.")
-        for param in config:
-            if "compensation" in param and config[param] == 0:
-                logger.debug(
-                    f"Skipping command to set {param} to 0, which would cause"
-                    f"ControllerErrors.PARAM_MISSING_OR_INVALID error. "
-                    f"{param} will be set to 0 automatically anyway."
-                )
-            else:
-                cmd = NewportConfigCommands(param).name
-                self.com.send_command(add, cmd, config[param])
-
-    def exit_configuration(self, add: int = None) -> None:
-        """
-        Exit the CONFIGURATION state and go back to the NOT REFERENCED state. All
-        configuration parameters are saved to the device"s memory.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(f"Newport controller {add} leaving CONFIG state.")
-        with self.com.access_lock:
-            self.com._send_command_without_checking_error(add, "PW", 0)
-            sleep(self.config.exit_configuration_wait_sec)
-            self.com.check_for_error(add)
-        self.state = self.States.NO_REF
-
-    def initialize(self, add: int = None) -> None:
-        """
-        Puts the controller from the NOT_REF state to the READY state.
-        Sends the motor to its "home" position.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(f"Newport controller {add} is HOMING.")
-        self.com.send_command(add, "OR")
-        self.state = self.States.READY
-
-    def wait_until_motor_initialized(self, add: int = None) -> None:
-        """
-        Wait until the motor leaves the HOMING state (at which point it should
-        have arrived to the home position).
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        poll = True
-        elapsed_time = 0.0
-        start_time = time()
-        while poll:
-            state_message = self.get_state(add)
-            elapsed_time += time() - start_time
-            poll = (state_message.state == self.States.HOMING) and (
-                elapsed_time < self.config.home_search_timeout
-            )
-            if poll:
-                sleep(self.config.home_search_polling_interval)
-
-        if state_message != self.StateMessages.READY_FROM_HOMING:
-            raise NewportControllerError(
-                f"Newport motor {add} should be READY from"
-                f" HOMING but is {state_message}."
-            )
-
-    def reset(self, add: int = None) -> None:
-        """
-        Resets the controller, equivalent to a power-up. This puts the controller
-        back to NOT REFERENCED state, which is necessary for configuring the controller.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(f"Newport controller {add} is being reset to NO_REF.")
-        self.com.send_command(add, "RS")
-        # an additional read_text is needed to clean the buffer after reset()
-        strange_char = self.com.read_text()
-        logger.debug(f"{self} sent this: '{strange_char}' after reset()")
-        self.state = self.States.NO_REF
-
-    def get_position(self, add: int = None) -> float:
-        """
-        Returns the value of the current position.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        :raises NewportUncertainPositionError: if the position is ambiguous
-        """
-
-        if add is None:
-            add = self.address
-
-        ans = float(self.com.query(add, "TP"))
-
-        # if zero, check motor state (answer 0 is not reliable in NO_REF state)
-        if ans == 0 and self.get_state().state == NewportStates.NO_REF:
-            message = (
-                "Motor claiming to be at home position in NO_REF state"
-                "is not reliable. Initialization needed."
-            )
-            logger.error(message)
-            raise NewportUncertainPositionError(message)
-
-        self.position = (
-            ans * self.config.screw_scaling + self.config.user_position_offset
-        )
-        logger.info(f"Newport motor {add} position is {self.position}.")
-        return self.position
-
-    def move_to_absolute_position(self, pos: Number, add: int = None) -> None:
-        """
-        Move the motor to the specified position.
-
-        :param pos: target absolute position (affected by the configured offset)
-        :param add: controller address (1 to 31), defaults to self.address
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(
-            f"Newport motor {add} moving from absolute position "
-            f"{self.get_position()} to absolute position {pos}."
-        )
-
-        # translate user-position into hardware-position
-        hard_pos = pos - self.config.user_position_offset
-        self.com.send_command(add, "PA", hard_pos)
-        sleep(self.config.move_wait_sec)
-
-    def go_home(self, add: int = None) -> None:
-        """
-        Move the motor to its home position.
-
-        :param add: controller address (1 to 31), defaults to self.address
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(
-            f"Newport motor {add} moving from absolute position {self.get_position()} "
-            f"to home position {self.config.user_position_offset}."
-        )
-
-        self.com.send_command(add, "PA", 0)
-        sleep(self.config.move_wait_sec)
-
-    def move_to_relative_position(self, pos: Number, add: int = None) -> None:
-        """
-        Move the motor of the specified distance.
-
-        :param pos: distance to travel (the sign gives the direction)
-        :param add: controller address (1 to 31), defaults to self.address
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        logger.info(f"Newport motor {add} moving of {pos} units.")
-        self.com.send_command(add, "PR", pos)
-        sleep(self.config.move_wait_sec)
-
-    def get_move_duration(self, dist: Number, add: int = None) -> float:
-        """
-        Estimate the time necessary to move the motor of the specified distance.
-
-        :param dist: distance to travel
-        :param add: controller address (1 to 31), defaults to self.address
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        dist = round(dist, 2)
-        duration = float(self.com.query(add, "PT", abs(dist)))
-        logger.info(f"Newport motor {add} will need {duration}s to move {dist} units.")
-        return duration
-
-    def stop_motion(self, add: int = None) -> None:
-        """
-        Stop a move in progress by decelerating the positioner immediately with the
-        configured acceleration until it stops. If a controller address is provided,
-        stops a move in progress on this controller, else stops the moves on all
-        controllers.
-
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-            logger.info("Stopping motion of all Newport motors.")
-            self.com.send_stop(add)
-        else:
-            logger.info(f"Stopping motion of Newport motor {add}.")
-            self.com.send_command(add, "ST")
-
-    def get_acceleration(self, add: int = None) -> Number:
-        """
-        Leave the configuration state. The configuration parameters are saved to
-        the device"s memory.
-
-        :param add: controller address (1 to 31)
-        :return: acceleration (preset units/s^2), value between 1e-6 and 1e12
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        acc = float(self.com.query(add, "AC", "?"))
-        logger.info(f"Newport motor {add} acceleration is {acc}.")
-        return acc
-
-    def set_acceleration(self, acc: Number, add: int = None) -> None:
-        """
-        Leave the configuration state. The configuration parameters are saved to
-        the device"s memory.
-
-        :param acc: acceleration (preset units/s^2), value between 1e-6 and 1e12
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        self.com.send_command(add, "AC", acc)
-        logger.info(f"Newport motor {add} acceleration set to {acc}.")
-
-    def get_controller_information(self, add: int = None) -> str:
-        """
-        Get information on the controller name and driver version
-
-        :param add: controller address (1 to 31)
-        :return: controller information
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        return self.com.query(add, "VE", "?")
-
-    def get_positive_software_limit(self, add: int = None) -> Number:
-        """
-        Get the positive software limit (the maximum position that the motor is allowed
-        to travel to towards the right).
-
-        :param add: controller address (1 to 31)
-        :return: positive software limit (preset units), value between 0 and 1e12
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        lim = float(self.com.query(add, "SR", "?"))
-        logger.info(f"Newport motor {add} positive software limit is {lim}.")
-        return lim
-
-    def set_positive_software_limit(self, lim: Number, add: int = None) -> None:
-        """
-        Set the positive software limit (the maximum position that the motor is allowed
-        to travel to towards the right).
-
-        :param lim: positive software limit (preset units), value between 0 and 1e12
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        self.com.send_command(add, "SR", lim)
-        logger.info(f"Newport {add} positive software limit set to {lim}.")
-
-    def get_negative_software_limit(self, add: int = None) -> Number:
-        """
-        Get the negative software limit (the maximum position that the motor is allowed
-        to travel to towards the left).
-
-        :param add: controller address (1 to 31)
-        :return: negative software limit (preset units), value between -1e12 and 0
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        lim = float(self.com.query(add, "SL", "?"))
-        logger.info(f"Newport motor {add} negative software limit is {lim}.")
-        return lim
-
-    def set_negative_software_limit(self, lim: Number, add: int = None) -> None:
-        """
-        Set the negative software limit (the maximum position that the motor is allowed
-        to travel to towards the left).
-
-        :param lim: negative software limit (preset units), value between -1e12 and 0
-        :param add: controller address (1 to 31)
-        :raises SerialCommunicationIOError: if the com is closed
-        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
-        :raises NewportControllerError: if the controller reports an error
-        """
-
-        if add is None:
-            add = self.address
-
-        self.com.send_command(add, "SL", lim)
-        logger.info(f"Newport {add} negative software limit set to {lim}.")
-
-
-class NewportMotorError(Exception):
-    """
-    Error with the Newport motor.
-    """
-
-    pass
-
-
-class NewportUncertainPositionError(Exception):
-    """
-    Error with the position of the Newport motor.
-    """
-
-    pass
-
-
-class NewportMotorPowerSupplyWasCutError(Exception):
-    """
-    Error with the Newport motor after the power supply was cut and then restored,
-    without interrupting the communication with the controller.
-    """
-
-    pass
-
-
-class NewportControllerError(Exception):
-    """
-    Error with the Newport controller.
-    """
-
-    pass
-
-
-class NewportSerialCommunicationError(Exception):
-    """
-    Communication error with the Newport controller.
-    """
-
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device class for Newport SMC100PP stepper motor controller with serial communication.
+
+The SMC100PP is a single axis motion controller/driver for stepper motors up to 48 VDC
+at 1.5 A rms. Up to 31 controllers can be networked through the internal RS-485
+communication link.
+
+Manufacturer homepage:
+https://www.newport.com/f/smc100-single-axis-dc-or-stepper-motion-controller
+"""
+
+import logging
+from time import sleep, time
+from typing import Union, Dict, List
+
+# Note: PyCharm does not recognize the dependency correctly, it is added as pyserial.
+from aenum import Enum, IntEnum
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.enum import NameEnum, AutoNumberNameEnum
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+Param = Union[Number, str, None]
+
+
+@configdataclass
+class NewportSMC100PPSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for NewportSMC100 controller is 57600 baud
+    baudrate: int = 57600
+
+    #: NewportSMC100 controller does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: NewportSMC100 controller uses one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: NewportSMC100 controller uses 8 bits for one data byte
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is CR/LF
+    terminator: bytes = b"\r\n"
+
+    #: use 10 seconds timeout as default
+    timeout: Number = 10
+    #: use ASCII as de-/encoding, cf. the manual
+    encoding: str = "ascii"
+
+    #: replace bytes with � instead of raising utf-8 exception when decoding fails
+    encoding_error_handling: str = "replace"
+
+
+class NewportSMC100PPSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for NewportSMC100 controller.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    class ControllerErrors(Enum, init="value message"):  # type: ignore
+        """
+        Possible controller errors with values as returned by the device in response
+        to sent commands.
+        """
+
+        NO_ERROR = "@", "No error."
+        CODE_OR_ADDR_INVALID = (
+            "A",
+            "Unknown message code or floating point controller address.",
+        )
+        ADDR_INCORRECT = "B", "Controller address not correct."
+        PARAM_MISSING_OR_INVALID = "C", "Parameter missing or out of range."
+        CMD_NOT_ALLOWED = "D", "Command not allowed."
+        HOME_STARTED = "E", "Home sequence already started."
+        ESP_STAGE_NAME_INVALID = (
+            "F",
+            "ESP stage name unknown.",
+        )
+        DISPLACEMENT_OUT_OF_LIMIT = (
+            "G",
+            "Displacement out of limits.",
+        )
+        CMD_NOT_ALLOWED_NOT_REFERENCED = (
+            "H",
+            "Command not allowed in NOT REFERENCED state.",
+        )
+        CMD_NOT_ALLOWED_CONFIGURATION = (
+            "I",
+            "Command not allowed in CONFIGURATION state.",
+        )
+        CMD_NOT_ALLOWED_DISABLE = "J", "Command not allowed in DISABLE state."
+        CMD_NOT_ALLOWED_READY = "K", "Command not allowed in READY state."
+        CMD_NOT_ALLOWED_HOMING = "L", "Command not allowed in HOMING state."
+        CMD_NOT_ALLOWED_MOVING = "M", "Command not allowed in MOVING state."
+        POSITION_OUT_OF_LIMIT = "N", "Current position out of software limit."
+        COM_TIMEOUT = (
+            "S",
+            "Communication Time Out.",
+        )
+        EEPROM_ACCESS_ERROR = "U", "Error during EEPROM access."
+        CMD_EXEC_ERROR = "V", "Error during command execution."
+        CMD_NOT_ALLOWED_PP = "W", "Command not allowed for PP version."
+        CMD_NOT_ALLOWED_CC = "X", "Command not allowed for CC version."
+
+    def __init__(self, configuration):
+        """
+        Constructor for NewportSMC100PPSerialCommunication.
+        """
+
+        super().__init__(configuration)
+
+    @staticmethod
+    def config_cls():
+        return NewportSMC100PPSerialCommunicationConfig
+
+    def read_text(self) -> str:
+        """
+        Read one line of text from the serial port, and check for presence of a null
+        char which indicates that the motor power supply was cut and then restored. The
+        input buffer may hold additional data afterwards, since only one line is read.
+
+        This method uses `self.access_lock` to ensure thread-safety.
+
+        :return: String read from the serial port; `''` if there was nothing to read.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises NewportMotorPowerSupplyWasCutError: if a null char is read
+        """
+
+        with self.access_lock:
+            line = super().read_text()
+            if "\x00" in line:
+                raise NewportMotorPowerSupplyWasCutError(
+                    'Unexpected message from motor:', line
+                )
+            return line
+
+    def _send_command_without_checking_error(
+        self, add: int, cmd: str, param: Param = None
+    ) -> None:
+        """
+        Send a command to the controller.
+
+        :param add: the controller address (1 to 31)
+        :param cmd: the command to be sent
+        :param param: optional parameter (int/float/str) appended to the command
+        """
+
+        if param is None:
+            param = ""
+
+        with self.access_lock:
+            self.write_text(f"{add}{cmd}{param}")
+            logger.debug(f"sent: {add}{cmd}{param}")
+
+    def _query_without_checking_errors(
+        self, add: int, cmd: str, param: Param = None
+    ) -> str:
+        """
+        Send a command to the controller and read the answer. The prefix add+cmd is
+        removed from the answer.
+
+        :param add: the controller address (1 to 31)
+        :param cmd: the command to be sent
+        :param param: optional parameter (int/float/str) appended to the command
+        :return: the answer from the device without the prefix
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if param is None:
+            param = ""
+
+        prefix = f"{add}{cmd}"
+        query = f"{add}{cmd}{param}"
+
+        with self.access_lock:
+            self._send_command_without_checking_error(add, cmd, param)
+            sleep(0.01)
+            answer = self.read_text().strip()
+            if len(answer) == 0:
+                message = f"Newport controller {add} did not answer to query {query}."
+                logger.error(message)
+                raise NewportSerialCommunicationError(message)
+            elif not answer.startswith(prefix):
+                message = (
+                    f"Newport controller {add} answer {answer} to query {query} "
+                    f"does not start with expected prefix {prefix}."
+                )
+                logger.error(message)
+                raise NewportSerialCommunicationError(message)
+            else:
+                logger.debug(f"Newport com: {answer}")
+                return answer[len(prefix):].strip()
+
+    def check_for_error(self, add: int) -> None:
+        """
+        Ask the Newport controller for the last error it recorded.
+
+        This method is called after every command or query.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        with self.access_lock:
+            error = self.ControllerErrors(
+                self._query_without_checking_errors(add, "TE")
+            )
+            if error is not self.ControllerErrors.NO_ERROR:
+                logger.error(f"NewportControllerError: {error.message}")
+                raise NewportControllerError(error.message)
+
+    def send_command(self, add: int, cmd: str, param: Param = None) -> None:
+        """
+        Send a command to the controller, and check for errors.
+
+        :param add: the controller address (1 to 31)
+        :param cmd: the command to be sent
+        :param param: optional parameter (int/float/str) appended to the command
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if param is None:
+            param = ""
+
+        with self.access_lock:
+            self._send_command_without_checking_error(add, cmd, param)
+            self.check_for_error(add)
+
+    def send_stop(self, add: int) -> None:
+        """
+        Send the general stop ST command to the controller, and check for errors.
+
+        :param add: the controller address (1 to 31)
+        :return: ControllerErrors reported by Newport Controller
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        """
+
+        with self.access_lock:
+            self.write_text("ST")
+            self.check_for_error(add)
+
+    def query(self, add: int, cmd: str, param: Param = None) -> str:
+        """
+        Send a query to the controller, read the answer, and check for errors. The
+        prefix add+cmd is removed from the answer.
+
+        :param add: the controller address (1 to 31)
+        :param cmd: the command to be sent
+        :param param: optional parameter (int/float/str) appended to the command
+        :return: the answer from the device without the prefix
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        with self.access_lock:
+
+            try:
+                answer = self._query_without_checking_errors(add, cmd, param)
+            finally:
+                self.check_for_error(add)
+
+        return answer
+
+    def query_multiple(self, add: int, cmd: str, prefixes: List[str]) -> List[str]:
+        """
+        Send a query to the controller, read the answers, and check for errors. The
+        prefixes are removed from the answers.
+
+        :param add: the controller address (1 to 31)
+        :param cmd: the command to be sent
+        :param prefixes: prefixes of each line expected in the answer
+        :return: list of answers from the device without prefix
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        with self.access_lock:
+
+            try:
+                self._send_command_without_checking_error(add, cmd)
+                answer = []
+                for prefix in prefixes:
+                    line = self.read_text().strip()
+                    if not line.startswith(prefix):
+                        message = (
+                            f"Newport controller {add} answer {line} to command "
+                            f"{cmd} does not start with expected prefix {prefix}."
+                        )
+                        logger.error(message)
+                        raise NewportSerialCommunicationError(message)
+                    else:
+                        answer.append(line[len(prefix) :])
+            finally:
+                self.check_for_error(add)
+
+        return answer
+
+
+class NewportConfigCommands(NameEnum):
+    """
+    Commands predefined by the communication protocol of the SMC100PP
+    """
+
+    AC = "acceleration"
+    BA = "backlash_compensation"
+    BH = "hysteresis_compensation"
+    FRM = "micro_step_per_full_step_factor"
+    FRS = "motion_distance_per_full_step"
+    HT = "home_search_type"
+    JR = "jerk_time"
+    OH = "home_search_velocity"
+    OT = "home_search_timeout"
+    QIL = "peak_output_current_limit"
+    SA = "rs485_address"
+    SL = "negative_software_limit"
+    SR = "positive_software_limit"
+    VA = "velocity"
+    VB = "base_velocity"
+    ZX = "stage_configuration"
+
+
+@configdataclass
+class NewportSMC100PPConfig:
+    """
+    Configuration dataclass for the Newport motor controller SMC100PP.
+    """
+
+    class HomeSearch(IntEnum):
+        """
+        Different methods for the motor to search its home position during
+        initialization.
+        """
+
+        HomeSwitch_and_Index = 0
+        CurrentPosition = 1
+        HomeSwitch = 2
+        EndOfRunSwitch_and_Index = 3
+        EndOfRunSwitch = 4
+
+    class EspStageConfig(IntEnum):
+        """
+        Different configurations to check or not the motor configuration upon power-up.
+        """
+
+        DisableEspStageCheck = 1
+        UpdateEspStageInfo = 2
+        EnableEspStageCheck = 3
+
+    # The following parameters are added for convenience, they do not correspond to any
+    # actual hardware configuration:
+
+    # controller address (1 to 31)
+    address: int = 1
+
+    # user position offset (mm). For convenience of the user, the motor
+    # position is given relative to this point:
+    user_position_offset: Number = 23.987
+
+    # correction for the scaling between screw turns and distance (should be close to 1)
+    screw_scaling: Number = 1
+
+    # nr of seconds to wait after exit configuration command has been issued
+    exit_configuration_wait_sec: Number = 5
+
+    # waiting time for a move
+    move_wait_sec: Number = 1
+
+    # The following parameters are actual hardware configuration parameters:
+
+    # acceleration (preset units/s^2)
+    acceleration: Number = 10
+
+    # backlash compensation (preset units)
+    # either backlash compensation or hysteresis compensation can be used, not both.
+    backlash_compensation: Number = 0
+
+    # hysteresis compensation (preset units)
+    # either backlash compensation or hysteresis compensation can be used, not both.
+    hysteresis_compensation: Number = 0.015
+
+    # micro step per full step factor, integer between 1 and 2000
+    micro_step_per_full_step_factor: int = 100
+
+    # motion distance per full step (preset units)
+    motion_distance_per_full_step: Number = 0.01
+
+    # home search type
+    home_search_type: Union[int, HomeSearch] = HomeSearch.HomeSwitch
+
+    # jerk time (s) -> time to reach the needed acceleration
+    jerk_time: Number = 0.04
+
+    # home search velocity (preset units/s)
+    home_search_velocity: Number = 4
+
+    # home search time-out (s)
+    home_search_timeout: Number = 27.5
+
+    # home search polling interval (s)
+    home_search_polling_interval: Number = 1
+
+    # peak output current delivered to the motor (A)
+    peak_output_current_limit: Number = 0.4
+
+    # RS485 address, integer between 2 and 31
+    rs485_address: int = 2
+
+    # lower limit for the motor position (mm)
+    negative_software_limit: Number = -23.5
+
+    # upper limit for the motor position (mm)
+    positive_software_limit: Number = 25
+
+    # maximum velocity (preset units/s), this is also the default velocity unless a
+    # lower value is set
+    velocity: Number = 4
+
+    # profile generator base velocity (preset units/s)
+    base_velocity: Number = 0
+
+    # ESP stage configuration
+    stage_configuration: Union[int, EspStageConfig] = EspStageConfig.EnableEspStageCheck
+
+    def clean_values(self):
+        if self.address not in range(1, 32):
+            raise ValueError("Address should be an integer between 1 and 31.")
+        if abs(self.screw_scaling - 1) > 0.1:
+            raise ValueError("The screw scaling should be close to 1.")
+        if not 0 < self.exit_configuration_wait_sec:
+            raise ValueError(
+                "The exit configuration wait time must be a positive "
+                "value (in seconds)."
+            )
+        if not 0 < self.move_wait_sec:
+            raise ValueError(
+                "The wait time for a move to finish must be a "
+                "positive value (in seconds)."
+            )
+        if not 1e-6 < self.acceleration < 1e12:
+            raise ValueError("The acceleration should be between 1e-6 and 1e12.")
+        if not 0 <= self.backlash_compensation < 1e12:
+            raise ValueError("The backlash compensation should be between 0 and 1e12.")
+        if not 0 <= self.hysteresis_compensation < 1e12:
+            raise ValueError(
+                "The hysteresis compensation should be between " "0 and 1e12."
+            )
+        if (
+            not isinstance(self.micro_step_per_full_step_factor, int)
+            or not 1 <= self.micro_step_per_full_step_factor <= 2000
+        ):
+            raise ValueError(
+                "The micro step per full step factor should be between 1 " "and 2000."
+            )
+        if not 1e-6 < self.motion_distance_per_full_step < 1e12:
+            raise ValueError(
+                "The motion distance per full step should be between 1e-6" " and 1e12."
+            )
+        if not isinstance(self.home_search_type, self.HomeSearch):
+            self.force_value("home_search_type", self.HomeSearch(self.home_search_type))
+        if not 1e-3 < self.jerk_time < 1e12:
+            raise ValueError("The jerk time should be between 1e-3 and 1e12.")
+        if not 1e-6 < self.home_search_velocity < 1e12:
+            raise ValueError(
+                "The home search velocity should be between 1e-6 " "and 1e12."
+            )
+        if not 1 < self.home_search_timeout < 1e3:
+            raise ValueError("The home search timeout should be between 1 and 1e3.")
+        if not 0 < self.home_search_polling_interval:
+            raise ValueError(
+                "The home search polling interval (sec) needs to have "
+                "a positive value."
+            )
+        if not 0.05 <= self.peak_output_current_limit <= 3:
+            raise ValueError(
+                "The peak output current limit should be between 0.05 A" "and 3 A."
+            )
+        if self.rs485_address not in range(2, 32):
+            raise ValueError("The RS485 address should be between 2 and 31.")
+        if not -1e12 < self.negative_software_limit <= 0:
+            raise ValueError(
+                "The negative software limit should be between -1e12 " "and 0."
+            )
+        if not 0 <= self.positive_software_limit < 1e12:
+            raise ValueError(
+                "The positive software limit should be between 0 " "and 1e12."
+            )
+        if not 1e-6 < self.velocity < 1e12:
+            raise ValueError("The velocity should be between 1e-6 and 1e12.")
+        if not 0 <= self.base_velocity <= self.velocity:
+            raise ValueError(
+                "The base velocity should be between 0 and the maximum " "velocity."
+            )
+        if not isinstance(self.stage_configuration, self.EspStageConfig):
+            self.force_value(
+                "stage_configuration", self.EspStageConfig(self.stage_configuration)
+            )
+
+    def _build_motor_config(self) -> Dict[str, float]:
+        return {
+            param.value: float(getattr(self, param.value))
+            for param in NewportConfigCommands  # type: ignore
+        }
+
+    @property
+    def motor_config(self) -> Dict[str, float]:
+        """
+        Gather the configuration parameters of the motor into a dictionary.
+
+        :return: dict containing the configuration parameters of the motor
+        """
+
+        if not hasattr(self, "_motor_config"):
+            self.force_value(  # type: ignore
+                "_motor_config",
+                self._build_motor_config(),
+            )
+        return self._motor_config  # type: ignore
+
+    def post_force_value(self, fieldname, value):
+        # if motor config is already cached and field is one of config commands fields..
+        if hasattr(self, "_motor_config") and fieldname in self._motor_config:
+            # ..update directly config dict value
+            self._motor_config[fieldname] = value
+
+
+class NewportStates(AutoNumberNameEnum):
+    """
+    States of the Newport controller. Certain commands are allowed only in certain
+    states.
+    """
+
+    NO_REF = ()
+    HOMING = ()
+    CONFIG = ()
+    READY = ()
+    MOVING = ()
+    DISABLE = ()
+    JOGGING = ()
+
+
+class NewportSMC100PP(SingleCommDevice):
+    """
+    Device class of the Newport motor controller SMC100PP
+    """
+
+    States = NewportStates
+
+    class MotorErrors(Enum, init="value message"):  # type: ignore
+        """
+        Possible motor errors reported by the motor during get_state().
+        """
+
+        OUTPUT_POWER_EXCEEDED = 2, "80W output power exceeded"
+        DC_VOLTAGE_TOO_LOW = 3, "DC voltage too low"
+        WRONG_ESP_STAGE = 4, "Wrong ESP stage"
+        HOMING_TIMEOUT = 5, "Homing timeout"
+        FOLLOWING_ERROR = 6, "Following error"
+        SHORT_CIRCUIT = 7, "Short circuit detection"
+        RMS_CURRENT_LIMIT = 8, "RMS current limit"
+        PEAK_CURRENT_LIMIT = 9, "Peak current limit"
+        POS_END_OF_TURN = 10, "Positive end of turn"
+        NED_END_OF_TURN = 11, "Negative end of turn"
+
+    class StateMessages(Enum, init="value message state"):  # type: ignore
+        """
+        Possible messages returned by the controller on get_state() query.
+        """
+
+        NO_REF_FROM_RESET = "0A", "NOT REFERENCED from reset.", NewportStates.NO_REF
+        NO_REF_FROM_HOMING = "0B", "NOT REFERENCED from HOMING.", NewportStates.NO_REF
+        NO_REF_FROM_CONFIG = (
+            "0C",
+            "NOT REFERENCED from CONFIGURATION.",
+            NewportStates.NO_REF,
+        )
+        NO_REF_FROM_DISABLED = (
+            "0D",
+            "NOT REFERENCED from DISABLE.",
+            NewportStates.NO_REF,
+        )
+        NO_REF_FROM_READY = "0E", "NOT REFERENCED from READY.", NewportStates.NO_REF
+        NO_REF_FROM_MOVING = "0F", "NOT REFERENCED from MOVING.", NewportStates.NO_REF
+        NO_REF_ESP_STAGE_ERROR = (
+            "10",
+            "NOT REFERENCED ESP stage error.",
+            NewportStates.NO_REF,
+        )
+        NO_REF_FROM_JOGGING = "11", "NOT REFERENCED from JOGGING.", NewportStates.NO_REF
+        CONFIG = "14", "CONFIGURATION.", NewportStates.CONFIG
+        HOMING_FROM_RS232 = (
+            "1E",
+            "HOMING commanded from RS-232-C.",
+            NewportStates.HOMING,
+        )
+        HOMING_FROM_SMC = "1F", "HOMING commanded by SMC-RC.", NewportStates.HOMING
+        MOVING = "28", "MOVING.", NewportStates.MOVING
+        READY_FROM_HOMING = "32", "READY from HOMING.", NewportStates.READY
+        READY_FROM_MOVING = "33", "READY from MOVING.", NewportStates.READY
+        READY_FROM_DISABLE = "34", "READY from DISABLE.", NewportStates.READY
+        READY_FROM_JOGGING = "35", "READY from JOGGING.", NewportStates.READY
+        DISABLE_FROM_READY = "3C", "DISABLE from READY.", NewportStates.DISABLE
+        DISABLE_FROM_MOVING = "3D", "DISABLE from MOVING.", NewportStates.DISABLE
+        DISABLE_FROM_JOGGING = "3E", "DISABLE from JOGGING.", NewportStates.DISABLE
+        JOGGING_FROM_READY = "46", "JOGGING from READY.", NewportStates.JOGGING
+        JOGGING_FROM_DISABLE = "47", "JOGGING from DISABLE.", NewportStates.JOGGING
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # address of the controller
+        self.address = self.config.address
+
+        # State of the controller (see state diagram in manual)
+        self.state = self.States.NO_REF
+
+        # position of the motor
+        self.position = None
+
+    def __repr__(self):
+        return f"Newport motor controller SMC100PP {self.address}"
+
+    @staticmethod
+    def default_com_cls():
+        return NewportSMC100PPSerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return NewportSMC100PPConfig
+
+    def start(self):
+        """
+        Opens the communication protocol and applies the config.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened
+        """
+
+        logger.info(f"Starting {self}")
+        super().start()
+
+        self.get_state()
+
+        if self.config.motor_config != self.get_motor_configuration():
+            logger.info(f"Updating {self} configuration")
+            if self.state != self.States.NO_REF:
+                self.reset()
+            self.go_to_configuration()
+            self.set_motor_configuration()
+            self.exit_configuration()
+
+        if self.state == self.States.NO_REF:
+            self.initialize()
+            self.wait_until_motor_initialized()
+
+    def stop(self) -> None:
+        """
+        Stop the device. Close the communication protocol.
+        """
+
+        try:
+            if self.com.is_open:
+                self.stop_motion()
+        finally:
+            logger.info(f"Stopping {self}")
+            # close the com
+            super().stop()
+
+    def get_state(self, add: int = None) -> "StateMessages":
+        """
+        Check on the motor errors and the controller state
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        :raises NewportMotorError: if the motor reports an error
+        :return: state message from the device (member of StateMessages)
+        """
+
+        if add is None:
+            add = self.address
+
+        # sometimes when restarting the Newport controller
+        # random bytes can be sent. In this scenario
+        # an error is raised and the query is repeated.
+        # So far on the second try the query is successful.
+        # cf. Issue #93 https://gitlab.com/ethz_hvl/hvl_ccb/-/issues/93
+        # and Issue #184 https://gitlab.com/ethz_hvl/hvl_ccb/-/issues/184
+        try:
+            ans = self.com.query(add, "TS")
+        except NewportMotorPowerSupplyWasCutError as e:
+            logger.error(str(e), exc_info=e)
+            # simply try again once
+            ans = self.com.query(add, "TS")
+
+        # the first symbol is not used, the next 3 symbols
+        # are hexadecimal. Once converted to binary, they
+        # indicate motor errors (see manual).
+        errors = []
+        for i in range(3):
+            bin_errors = bin(int(ans[i + 1], 16))[2:].zfill(4)
+            for j, b in enumerate(bin_errors):
+                if b == "1":
+                    errors.append(self.MotorErrors(i * 4 + j).message)
+        if len(errors) > 0:
+            message = f"Motor {add} error(s): {', '.join(errors)}"
+            logger.error(message)
+            raise NewportMotorError(message)
+        # the next two symbols indicate the controller state
+        s = self.StateMessages(ans[4:6])
+        logger.info(f"The newport controller {add} is in state {s.name}")
+        self.state = s.state
+        return s
+
+    def get_motor_configuration(self, add: int = None) -> Dict[str, float]:
+        """
+        Query the motor configuration and returns it in a dictionary.
+
+        :param add: controller address (1 to 31)
+        :return: dictionary containing the motor's configuration
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        # The controller answer should be lines starting with the following prefixes
+        prefixes = (
+            [f"{add}PW1", f"{add}ID"]
+            + [f"{add}{p.name}" for p in NewportConfigCommands]  # type: ignore
+            + [f"{add}PW0"]
+        )
+        answers = self.com.query_multiple(add, "ZT", prefixes)
+        # first and last line are expected to be only the prefixes
+        assert not (answers[0] + answers[-1])
+        # additionally, second line ID is not relevant
+        answers = answers[2:-1]
+
+        motor_config = {}
+        # for each config param, read the answer given by the controller
+        for prefix, answer in zip(NewportConfigCommands, answers):  # type: ignore
+            # cast the config param as a float and add the result to the config dict
+            motor_config[prefix.value] = float(answer)
+        return motor_config
+
+    def go_to_configuration(self, add: int = None) -> None:
+        """
+        This method is executed during start(). It can also be executed after a reset().
+        The controller is put in CONFIG state, where configuration parameters
+        can be changed.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(f"Newport controller {add} entering CONFIG state.")
+        self.com.send_command(add, "PW", 1)
+        self.state = self.States.CONFIG
+
+    def set_motor_configuration(self, add: int = None, config: dict = None) -> None:
+        """
+        Set the motor configuration. The motor must be in CONFIG state.
+
+        :param add: controller address (1 to 31)
+        :param config: dictionary containing the motor's configuration
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+        if config is None:
+            config = self.config.motor_config
+
+        logger.info(f"Setting motor {add} configuration.")
+        for param in config:
+            if "compensation" in param and config[param] == 0:
+                logger.debug(
+                    f"Skipping command to set {param} to 0, which would cause"
+                    f"ControllerErrors.PARAM_MISSING_OR_INVALID error. "
+                    f"{param} will be set to 0 automatically anyway."
+                )
+            else:
+                cmd = NewportConfigCommands(param).name
+                self.com.send_command(add, cmd, config[param])
+
+    def exit_configuration(self, add: int = None) -> None:
+        """
+        Exit the CONFIGURATION state and go back to the NOT REFERENCED state. All
+        configuration parameters are saved to the device"s memory.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(f"Newport controller {add} leaving CONFIG state.")
+        with self.com.access_lock:
+            self.com._send_command_without_checking_error(add, "PW", 0)
+            sleep(self.config.exit_configuration_wait_sec)
+            self.com.check_for_error(add)
+        self.state = self.States.NO_REF
+
+    def initialize(self, add: int = None) -> None:
+        """
+        Puts the controller from the NOT_REF state to the READY state.
+        Sends the motor to its "home" position.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(f"Newport controller {add} is HOMING.")
+        self.com.send_command(add, "OR")
+        self.state = self.States.READY
+
+    def wait_until_motor_initialized(self, add: int = None) -> None:
+        """
+        Wait until the motor leaves the HOMING state (at which point it should
+        have arrived to the home position).
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        poll = True
+        elapsed_time = 0.0
+        start_time = time()
+        while poll:
+            state_message = self.get_state(add)
+            elapsed_time += time() - start_time
+            poll = (state_message.state == self.States.HOMING) and (
+                elapsed_time < self.config.home_search_timeout
+            )
+            if poll:
+                sleep(self.config.home_search_polling_interval)
+
+        if state_message != self.StateMessages.READY_FROM_HOMING:
+            raise NewportControllerError(
+                f"Newport motor {add} should be READY from"
+                f" HOMING but is {state_message}."
+            )
+
+    def reset(self, add: int = None) -> None:
+        """
+        Resets the controller, equivalent to a power-up. This puts the controller
+        back to NOT REFERENCED state, which is necessary for configuring the controller.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(f"Newport controller {add} is being reset to NO_REF.")
+        self.com.send_command(add, "RS")
+        # an additional read_text is needed to clean the buffer after reset()
+        strange_char = self.com.read_text()
+        logger.debug(f"{self} sent this: '{strange_char}' after reset()")
+        self.state = self.States.NO_REF
+
+    def get_position(self, add: int = None) -> float:
+        """
+        Returns the value of the current position.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        :raises NewportUncertainPositionError: if the position is ambiguous
+        """
+
+        if add is None:
+            add = self.address
+
+        ans = float(self.com.query(add, "TP"))
+
+        # if zero, check motor state (answer 0 is not reliable in NO_REF state)
+        if ans == 0 and self.get_state().state == NewportStates.NO_REF:
+            message = (
+                "Motor claiming to be at home position in NO_REF state"
+                "is not reliable. Initialization needed."
+            )
+            logger.error(message)
+            raise NewportUncertainPositionError(message)
+
+        self.position = (
+            ans * self.config.screw_scaling + self.config.user_position_offset
+        )
+        logger.info(f"Newport motor {add} position is {self.position}.")
+        return self.position
+
+    def move_to_absolute_position(self, pos: Number, add: int = None) -> None:
+        """
+        Move the motor to the specified position.
+
+        :param pos: target absolute position (affected by the configured offset)
+        :param add: controller address (1 to 31), defaults to self.address
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(
+            f"Newport motor {add} moving from absolute position "
+            f"{self.get_position()} to absolute position {pos}."
+        )
+
+        # translate user-position into hardware-position
+        hard_pos = pos - self.config.user_position_offset
+        self.com.send_command(add, "PA", hard_pos)
+        sleep(self.config.move_wait_sec)
+
+    def go_home(self, add: int = None) -> None:
+        """
+        Move the motor to its home position.
+
+        :param add: controller address (1 to 31), defaults to self.address
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(
+            f"Newport motor {add} moving from absolute position {self.get_position()} "
+            f"to home position {self.config.user_position_offset}."
+        )
+
+        self.com.send_command(add, "PA", 0)
+        sleep(self.config.move_wait_sec)
+
+    def move_to_relative_position(self, pos: Number, add: int = None) -> None:
+        """
+        Move the motor of the specified distance.
+
+        :param pos: distance to travel (the sign gives the direction)
+        :param add: controller address (1 to 31), defaults to self.address
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        logger.info(f"Newport motor {add} moving of {pos} units.")
+        self.com.send_command(add, "PR", pos)
+        sleep(self.config.move_wait_sec)
+
+    def get_move_duration(self, dist: Number, add: int = None) -> float:
+        """
+        Estimate the time necessary to move the motor of the specified distance.
+
+        :param dist: distance to travel
+        :param add: controller address (1 to 31), defaults to self.address
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        dist = round(dist, 2)
+        duration = float(self.com.query(add, "PT", abs(dist)))
+        logger.info(f"Newport motor {add} will need {duration}s to move {dist} units.")
+        return duration
+
+    def stop_motion(self, add: int = None) -> None:
+        """
+        Stop a move in progress by decelerating the positioner immediately with the
+        configured acceleration until it stops. If a controller address is provided,
+        stops a move in progress on this controller, else stops the moves on all
+        controllers.
+
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+            logger.info("Stopping motion of all Newport motors.")
+            self.com.send_stop(add)
+        else:
+            logger.info(f"Stopping motion of Newport motor {add}.")
+            self.com.send_command(add, "ST")
+
+    def get_acceleration(self, add: int = None) -> Number:
+        """
+        Leave the configuration state. The configuration parameters are saved to
+        the device"s memory.
+
+        :param add: controller address (1 to 31)
+        :return: acceleration (preset units/s^2), value between 1e-6 and 1e12
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        acc = float(self.com.query(add, "AC", "?"))
+        logger.info(f"Newport motor {add} acceleration is {acc}.")
+        return acc
+
+    def set_acceleration(self, acc: Number, add: int = None) -> None:
+        """
+        Leave the configuration state. The configuration parameters are saved to
+        the device"s memory.
+
+        :param acc: acceleration (preset units/s^2), value between 1e-6 and 1e12
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        self.com.send_command(add, "AC", acc)
+        logger.info(f"Newport motor {add} acceleration set to {acc}.")
+
+    def get_controller_information(self, add: int = None) -> str:
+        """
+        Get information on the controller name and driver version
+
+        :param add: controller address (1 to 31)
+        :return: controller information
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        return self.com.query(add, "VE", "?")
+
+    def get_positive_software_limit(self, add: int = None) -> Number:
+        """
+        Get the positive software limit (the maximum position that the motor is allowed
+        to travel to towards the right).
+
+        :param add: controller address (1 to 31)
+        :return: positive software limit (preset units), value between 0 and 1e12
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        lim = float(self.com.query(add, "SR", "?"))
+        logger.info(f"Newport motor {add} positive software limit is {lim}.")
+        return lim
+
+    def set_positive_software_limit(self, lim: Number, add: int = None) -> None:
+        """
+        Set the positive software limit (the maximum position that the motor is allowed
+        to travel to towards the right).
+
+        :param lim: positive software limit (preset units), value between 0 and 1e12
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        self.com.send_command(add, "SR", lim)
+        logger.info(f"Newport {add} positive software limit set to {lim}.")
+
+    def get_negative_software_limit(self, add: int = None) -> Number:
+        """
+        Get the negative software limit (the maximum position that the motor is allowed
+        to travel to towards the left).
+
+        :param add: controller address (1 to 31)
+        :return: negative software limit (preset units), value between -1e12 and 0
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        lim = float(self.com.query(add, "SL", "?"))
+        logger.info(f"Newport motor {add} negative software limit is {lim}.")
+        return lim
+
+    def set_negative_software_limit(self, lim: Number, add: int = None) -> None:
+        """
+        Set the negative software limit (the maximum position that the motor is allowed
+        to travel to towards the left).
+
+        :param lim: negative software limit (preset units), value between -1e12 and 0
+        :param add: controller address (1 to 31)
+        :raises SerialCommunicationIOError: if the com is closed
+        :raises NewportSerialCommunicationError: if an unexpected answer is obtained
+        :raises NewportControllerError: if the controller reports an error
+        """
+
+        if add is None:
+            add = self.address
+
+        self.com.send_command(add, "SL", lim)
+        logger.info(f"Newport {add} negative software limit set to {lim}.")
+
+
+class NewportError(DeviceException):
+    """
+    General Exception for Newport Device
+    """
+    pass
+
+
+class NewportMotorError(NewportError):
+    """
+    Error with the Newport motor.
+    """
+
+    pass
+
+
+class NewportUncertainPositionError(NewportError):
+    """
+    Error with the position of the Newport motor.
+    """
+
+    pass
+
+
+class NewportMotorPowerSupplyWasCutError(NewportError):
+    """
+    Error with the Newport motor after the power supply was cut and then restored,
+    without interrupting the communication with the controller.
+    """
+
+    pass
+
+
+class NewportControllerError(NewportError):
+    """
+    Error with the Newport controller.
+    """
+
+    pass
+
+
+class NewportSerialCommunicationError(NewportError):
+    """
+    Communication error with the Newport controller.
+    """
+
+    pass
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/pfeiffer_tpg.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/pfeiffer_tpg.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,544 +1,543 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device class for Pfeiffer TPG controllers.
-
-The Pfeiffer TPG control units are used to control Pfeiffer Compact Gauges.
-Models: TPG 251 A, TPG 252 A, TPG 256A, TPG 261, TPG 262, TPG 361, TPG 362 and TPG 366.
-
-Manufacturer homepage:
-https://www.pfeiffer-vacuum.com/en/products/measurement-analysis/
-measurement/activeline/controllers/
-"""
-
-import logging
-from enum import Enum, IntEnum
-from typing import Dict, List, Tuple, Union, cast
-
-from .base import SingleCommDevice
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.enum import NameEnum
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class PfeifferTPGError(Exception):
-    """
-    Error with the Pfeiffer TPG Controller.
-    """
-
-    pass
-
-
-@configdataclass
-class PfeifferTPGSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for Pfeiffer TPG controllers is 9600 baud
-    baudrate: int = 9600
-
-    #: Pfeiffer TPG controllers do not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: Pfeiffer TPG controllers use one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is <CR><LF>
-    terminator: bytes = b"\r\n"
-
-    #: use 3 seconds timeout as default
-    timeout: Number = 3
-
-
-class PfeifferTPGSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for Pfeiffer TPG controllers.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    def __init__(self, configuration):
-        super().__init__(configuration)
-
-    @staticmethod
-    def config_cls():
-        return PfeifferTPGSerialCommunicationConfig
-
-    def send_command(self, cmd: str) -> None:
-        """
-        Send a command to the device and check for acknowledgement.
-
-        :param cmd: command to send to the device
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if the answer from the device differs from the
-            expected acknowledgement character 'chr(6)'.
-        """
-
-        with self.access_lock:
-            # send the command
-            self.write_text(cmd)
-            # check for acknowledgment char (ASCII 6)
-            answer = self.read_text()
-            if len(answer) == 0 or ord(answer[0]) != 6:
-                message = f"Pfeiffer TPG not acknowledging command {cmd}"
-                logger.error(message)
-                if len(answer) > 0:
-                    logger.debug(f"Pfeiffer TPG: {answer}")
-                raise PfeifferTPGError(message)
-
-    def query(self, cmd: str) -> str:
-        """
-        Send a query, then read and returns the first line from the com port.
-
-        :param cmd: query message to send to the device
-        :return: first line read on the com
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if the device does not acknowledge the command or if
-            the answer from the device is empty
-        """
-
-        with self.access_lock:
-            # send the command
-            self.write_text(cmd)
-            # check for acknowledgment char (ASCII 6)
-            answer = self.read_text()
-            if len(answer) == 0 or ord(answer[0]) != 6:
-                message = f"Pfeiffer TPG not acknowledging command {cmd}"
-                logger.error(message)
-                if len(answer) > 0:
-                    logger.debug(f"Pfeiffer TPG: {answer}")
-                raise PfeifferTPGError(message)
-            # send enquiry
-            self.write_text(chr(5))
-            # read answer
-            answer = self.read_text().strip()
-            if len(answer) == 0:
-                message = f"Pfeiffer TPG not answering to command {cmd}"
-                logger.error(message)
-                raise PfeifferTPGError(message)
-            return answer
-
-
-@configdataclass
-class PfeifferTPGConfig:
-    """
-    Device configuration dataclass for Pfeiffer TPG controllers.
-    """
-
-    class Model(NameEnum):
-        _init_ = "full_scale_ranges"
-        TPG25xA = {
-            1: 0,
-            10: 1,
-            100: 2,
-            1000: 3,
-            2000: 4,
-            5000: 5,
-            10000: 6,
-            50000: 7,
-            0.1: 8,
-        }
-        TPGx6x = {
-            0.01: 0,
-            0.1: 1,
-            1: 2,
-            10: 3,
-            100: 4,
-            1000: 5,
-            2000: 6,
-            5000: 7,
-            10000: 8,
-            50000: 9,
-        }
-
-        def __init__(self, *args, **kwargs):
-            super().__init__(*args, **kwargs)
-            self.full_scale_ranges_reversed: Dict[int, int] = {
-                v: k for k, v in self.full_scale_ranges.items()
-            }
-
-        def is_valid_scale_range_reversed_str(self, v: str) -> bool:
-            """
-            Check if given string represents a valid reversed scale range of a model.
-
-            :param v: Reversed scale range string.
-            :return: `True` if valid, `False` otherwise.
-            """
-            # Explicit check because otherwise we get `True` for instance for `float`
-            if not isinstance(v, str):
-                raise TypeError(f"Expected `str`, got `{type(v)}` instead.")
-            try:
-                return int(v) in self.full_scale_ranges_reversed
-            except ValueError as e:
-                logger.error(str(e), exc_info=e)
-                return False
-
-    # model of the TPG (determines which lookup table to use for the
-    # full scale range)
-    model: Union[str, Model] = Model.TPG25xA  # type: ignore
-
-    def clean_values(self):
-        if not isinstance(self.model, self.Model):
-            self.force_value("model", self.Model(self.model))
-
-
-class PfeifferTPG(SingleCommDevice):
-    """
-    Pfeiffer TPG control unit device class
-    """
-
-    class PressureUnits(NameEnum):
-        """
-        Enum of available pressure units for the digital display. "0" corresponds either
-        to bar or to mbar depending on the TPG model. In case of doubt, the unit is
-        visible on the digital display.
-        """
-
-        mbar = 0
-        bar = 0
-        Torr = 1
-        Pascal = 2
-        Micron = 3
-        hPascal = 4
-        Volt = 5
-
-    SensorTypes = Enum(  # type: ignore
-        value="SensorTypes",
-        names=[
-            ("TPR/PCR Pirani Gauge", 1),
-            ("TPR", 1),
-            ("TPR/PCR", 1),
-            ("IKR Cold Cathode Gauge", 2),
-            ("IKR", 2),
-            ("IKR9", 2),
-            ("IKR11", 2),
-            ("PKR Full range CC", 3),
-            ("PKR", 3),
-            ("APR/CMR Linear Gauge", 4),
-            ("CMR", 4),
-            ("APR/CMR", 4),
-            ("CMR/APR", 4),
-            ("Pirani / High Pressure Gauge", 5),
-            ("IMR", 5),
-            ("Fullrange BA Gauge", 6),
-            ("PBR", 6),
-            ("None", 7),
-            ("no Sensor", 7),
-            ("noSen", 7),
-            ("noSENSOR", 7),
-        ],
-    )
-
-    class SensorStatus(IntEnum):
-        Ok = 0
-        Underrange = 1
-        Overrange = 2
-        Sensor_error = 3
-        Sensor_off = 4
-        No_sensor = 5
-        Identification_error = 6
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # list of sensors connected to the TPG
-        self.sensors: List[str] = []
-
-    def __repr__(self):
-        return f"Pfeiffer TPG with {self.number_of_sensors} sensors: {self.sensors}"
-
-    @property
-    def number_of_sensors(self):
-        return len(self.sensors)
-
-    @property
-    def unit(self):
-        """
-        The pressure unit of readings is always mbar, regardless of the display unit.
-        """
-        return "mbar"
-
-    @staticmethod
-    def default_com_cls():
-        return PfeifferTPGSerialCommunication
-
-    @staticmethod
-    def config_cls():
-        return PfeifferTPGConfig
-
-    def start(self) -> None:
-        """
-        Start this device. Opens the communication protocol,
-        and identify the sensors.
-
-        :raises SerialCommunicationIOError: when communication port cannot be opened
-        """
-
-        logger.info("Starting Pfeiffer TPG")
-        super().start()
-
-        # identify the sensors connected to the TPG
-        # and also find out the number of channels
-        self.identify_sensors()
-
-    def stop(self) -> None:
-        """
-        Stop the device. Closes also the communication protocol.
-        """
-
-        logger.info(f"Stopping device {self}")
-        super().stop()
-
-    def identify_sensors(self) -> None:
-        """
-        Send identification request TID to sensors on all channels.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        try:
-            answer = self.com.query("TID")
-        except PfeifferTPGError as e:
-            logger.error("Pressure sensor identification failed.", exc_info=e)
-            raise
-
-        # try matching the sensors:
-        sensors = []
-        for s in answer.split(","):
-            try:
-                sensors.append(self.SensorTypes[s].name)
-            except KeyError as e:
-                logger.error(str(e), exc_info=e)
-                sensors.append("Unknown")
-        self.sensors = sensors
-        # identification successful:
-        logger.info(f"Identified {self}")
-
-    def set_display_unit(self, unit: Union[str, PressureUnits]) -> None:
-        """
-        Set the unit in which the measurements are shown on the display.
-
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        if not isinstance(unit, self.PressureUnits):
-            unit = self.PressureUnits(unit)
-
-        try:
-            self.com.send_command(f"UNI,{unit.value}")
-            logger.info(f"Setting display unit to {unit.name}")
-        except PfeifferTPGError as e:
-            logger.error(
-                f"Setting display unit to {unit.name} failed. "
-                f"Not all units are available on all TGP models",
-                exc_info=e,
-            )
-            raise
-
-    def measure(self, channel: int) -> Tuple[str, float]:
-        """
-        Get the status and measurement of one sensor
-
-        :param channel: int channel on which the sensor is connected, with
-            1 <= channel <= number_of_sensors
-        :return: measured value as float if measurement successful,
-            sensor status as string if not
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        if not 1 <= channel <= self.number_of_sensors:
-            message = (
-                f"{channel} is not a valid channel number, it should be between "
-                f"1 and {self.number_of_sensors}"
-            )
-            logger.error(message)
-            raise ValueError(message)
-
-        try:
-            answer = self.com.query(f"PR{channel}")
-        except PfeifferTPGError as e:
-            logger.error(f"Reading sensor {channel} failed.", exc_info=e)
-            raise
-
-        status, measurement = answer.split(",")
-        s = self.SensorStatus(int(status))
-        if s == self.SensorStatus.Ok:
-            logger.info(
-                f"Channel {channel} successful reading of "
-                f"pressure: {measurement} mbar."
-            )
-        else:
-            logger.info(
-                f"Channel {channel} no reading of pressure, sensor status is "
-                f"{self.SensorStatus(s).name}."
-            )
-        return s.name, float(measurement)
-
-    def measure_all(self) -> List[Tuple[str, float]]:
-        """
-        Get the status and measurement of all sensors (this command is
-        not available on all models)
-
-        :return: list of measured values as float if measurements successful,
-            and or sensor status as strings if not
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        try:
-            answer = self.com.query("PRX")
-        except PfeifferTPGError as e:
-            logger.error(
-                "Getting pressure reading from all sensors failed "
-                "(this command is not available on all TGP models).",
-                exc_info=e,
-            )
-            raise
-
-        ans = answer.split(",")
-        ret = [
-            (self.SensorStatus(int(ans[2 * i])).name, float(ans[2 * i + 1]))
-            for i in range(self.number_of_sensors)
-        ]
-        logger.info(f"Reading all sensors with result: {ret}.")
-        return ret
-
-    def _set_full_scale(self, fsr: List[Number], unitless: bool) -> None:
-        """
-        Set the full scale range of the attached sensors. See lookup table between
-        command and corresponding pressure in the device user manual.
-
-        :param fsr: list of full scale range values, like `[0, 1, 3, 3, 2, 0]` for
-            `unitless = True` scale or `[0.01, 1000]` otherwise (mbar units scale)
-        :param unitless: flag to indicate scale of range values; if `False` then mbar
-            units scale
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-        if len(fsr) != self.number_of_sensors:
-            raise ValueError(
-                f"Argument fsr should be of length {self.number_of_sensors}. "
-                f"Received length {len(fsr)}."
-            )
-
-        possible_values_map = (
-            self.config.model.full_scale_ranges_reversed
-            if unitless
-            else self.config.model.full_scale_ranges
-        )
-        wrong_values = [v for v in fsr if v not in possible_values_map]
-        if wrong_values:
-            raise ValueError(
-                f"Argument fsr contains invalid values: {wrong_values}. Accepted "
-                f"values are {list(possible_values_map.items())}"
-                f"{'' if unitless else ' mbar'}."
-            )
-
-        str_fsr = ",".join(
-            [str(f if unitless else possible_values_map[f]) for f in fsr]
-        )
-        try:
-            self.com.send_command(f"FSR,{str_fsr}")
-            logger.info(f"Set sensors full scale to {fsr} " f"(unitless) respectively.")
-        except PfeifferTPGError as e:
-            logger.error("Setting sensors full scale failed.", exc_info=e)
-            raise e
-
-    def _get_full_scale(self, unitless: bool) -> List[Number]:
-        """
-        Get the full scale range of the attached sensors. See lookup table between
-        command and corresponding pressure in the device user manual.
-
-        :param unitless: flag to indicate scale of range values; if `False` then mbar
-            units scale
-        :return: list of full scale range values, like `[0, 1, 3, 3, 2, 0]` for
-            `unitless = True` scale or `[0.01, 1000]` otherwise (mbar units scale)
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        try:
-            answer = self.com.query("FSR")
-        except PfeifferTPGError as e:
-            logger.error("Query full scale range of all sensors failed.", exc_info=e)
-            raise
-
-        answer_values = answer.split(",")
-        wrong_values = [
-            v
-            for v in answer_values
-            if not self.config.model.is_valid_scale_range_reversed_str(v)
-        ]
-        if wrong_values:
-            raise PfeifferTPGError(
-                f"The controller returned the full unitless scale range values: "
-                f"{answer}. The values {wrong_values} are invalid. Accepted values are "
-                f"{list(self.config.model.full_scale_ranges_reversed.keys())}."
-            )
-
-        fsr = [
-            int(v) if unitless else self.config.model.full_scale_ranges_reversed[int(v)]
-            for v in answer_values
-        ]
-        logger.info(
-            f"Obtained full scale range of all sensors as {fsr}"
-            f"{'' if unitless else ' mbar'}."
-        )
-        return fsr
-
-    def set_full_scale_unitless(self, fsr: List[int]) -> None:
-        """
-        Set the full scale range of the attached sensors. See lookup table between
-        command and corresponding pressure in the device user manual.
-
-        :param fsr: list of full scale range values, like `[0, 1, 3, 3, 2, 0]`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-        self._set_full_scale(cast(List[Number], fsr), True)
-
-    def get_full_scale_unitless(self) -> List[int]:
-        """
-        Get the full scale range of the attached sensors. See lookup table between
-        command and corresponding pressure in the device user manual.
-
-        :return: list of full scale range values, like `[0, 1, 3, 3, 2, 0]`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-        return cast(List[int], self._get_full_scale(True))
-
-    def set_full_scale_mbar(self, fsr: List[Number]) -> None:
-        """
-        Set the full scale range of the attached sensors (in unit mbar)
-
-        :param fsr: full scale range values in mbar, for example `[0.01, 1000]`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-        self._set_full_scale(fsr, False)
-
-    def get_full_scale_mbar(self) -> List[Number]:
-        """
-        Get the full scale range of the attached sensors
-
-        :return: full scale range values in mbar, like `[0.01, 1, 0.1, 1000, 50000, 10]`
-        :raises SerialCommunicationIOError: when communication port is not opened
-        :raises PfeifferTPGError: if command fails
-        """
-
-        return self._get_full_scale(False)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device class for Pfeiffer TPG controllers.
+
+The Pfeiffer TPG control units are used to control Pfeiffer Compact Gauges.
+Models: TPG 251 A, TPG 252 A, TPG 256A, TPG 261, TPG 262, TPG 361, TPG 362 and TPG 366.
+
+Manufacturer homepage:
+https://www.pfeiffer-vacuum.com/en/products/measurement-analysis/
+measurement/activeline/controllers/
+"""
+
+import logging
+from enum import Enum, IntEnum
+from typing import Dict, List, Tuple, Union, cast
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.enum import NameEnum
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class PfeifferTPGError(DeviceException):
+    """
+    Error with the Pfeiffer TPG Controller.
+    """
+
+    pass
+
+
+@configdataclass
+class PfeifferTPGSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for Pfeiffer TPG controllers is 9600 baud
+    baudrate: int = 9600
+
+    #: Pfeiffer TPG controllers do not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: Pfeiffer TPG controllers use one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is <CR><LF>
+    terminator: bytes = b"\r\n"
+
+    #: use 3 seconds timeout as default
+    timeout: Number = 3
+
+
+class PfeifferTPGSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for Pfeiffer TPG controllers.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    def __init__(self, configuration):
+        super().__init__(configuration)
+
+    @staticmethod
+    def config_cls():
+        return PfeifferTPGSerialCommunicationConfig
+
+    def send_command(self, cmd: str) -> None:
+        """
+        Send a command to the device and check for acknowledgement.
+
+        :param cmd: command to send to the device
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if the answer from the device differs from the
+            expected acknowledgement character 'chr(6)'.
+        """
+
+        with self.access_lock:
+            # send the command
+            self.write_text(cmd)
+            # check for acknowledgment char (ASCII 6)
+            answer = self.read_text()
+            if len(answer) == 0 or ord(answer[0]) != 6:
+                message = f"Pfeiffer TPG not acknowledging command {cmd}"
+                logger.error(message)
+                if len(answer) > 0:
+                    logger.debug(f"Pfeiffer TPG: {answer}")
+                raise PfeifferTPGError(message)
+
+    def query(self, cmd: str) -> str:
+        """
+        Send a query, then read and returns the first line from the com port.
+
+        :param cmd: query message to send to the device
+        :return: first line read on the com
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if the device does not acknowledge the command or if
+            the answer from the device is empty
+        """
+
+        with self.access_lock:
+            # send the command
+            self.write_text(cmd)
+            # check for acknowledgment char (ASCII 6)
+            answer = self.read_text()
+            if len(answer) == 0 or ord(answer[0]) != 6:
+                message = f"Pfeiffer TPG not acknowledging command {cmd}"
+                logger.error(message)
+                if len(answer) > 0:
+                    logger.debug(f"Pfeiffer TPG: {answer}")
+                raise PfeifferTPGError(message)
+            # send enquiry
+            self.write_text(chr(5))
+            # read answer
+            answer = self.read_text().strip()
+            if len(answer) == 0:
+                message = f"Pfeiffer TPG not answering to command {cmd}"
+                logger.error(message)
+                raise PfeifferTPGError(message)
+            return answer
+
+
+@configdataclass
+class PfeifferTPGConfig:
+    """
+    Device configuration dataclass for Pfeiffer TPG controllers.
+    """
+
+    class Model(NameEnum, init="full_scale_ranges"):  # type:ignore
+        TPG25xA = {
+            1: 0,
+            10: 1,
+            100: 2,
+            1000: 3,
+            2000: 4,
+            5000: 5,
+            10000: 6,
+            50000: 7,
+            0.1: 8,
+        }
+        TPGx6x = {
+            0.01: 0,
+            0.1: 1,
+            1: 2,
+            10: 3,
+            100: 4,
+            1000: 5,
+            2000: 6,
+            5000: 7,
+            10000: 8,
+            50000: 9,
+        }
+
+        def __init__(self, *args, **kwargs):
+            super().__init__(*args, **kwargs)
+            self.full_scale_ranges_reversed: Dict[int, int] = {
+                v: k for k, v in self.full_scale_ranges.items()
+            }
+
+        def is_valid_scale_range_reversed_str(self, v: str) -> bool:
+            """
+            Check if given string represents a valid reversed scale range of a model.
+
+            :param v: Reversed scale range string.
+            :return: `True` if valid, `False` otherwise.
+            """
+            # Explicit check because otherwise we get `True` for instance for `float`
+            if not isinstance(v, str):
+                raise TypeError(f"Expected `str`, got `{type(v)}` instead.")
+            try:
+                return int(v) in self.full_scale_ranges_reversed
+            except ValueError as e:
+                logger.error(str(e), exc_info=e)
+                return False
+
+    # model of the TPG (determines which lookup table to use for the
+    # full scale range)
+    model: Union[str, Model] = Model.TPG25xA  # type: ignore
+
+    def clean_values(self):
+        if not isinstance(self.model, self.Model):
+            self.force_value("model", self.Model(self.model))
+
+
+class PfeifferTPG(SingleCommDevice):
+    """
+    Pfeiffer TPG control unit device class
+    """
+
+    class PressureUnits(NameEnum):
+        """
+        Enum of available pressure units for the digital display. "0" corresponds either
+        to bar or to mbar depending on the TPG model. In case of doubt, the unit is
+        visible on the digital display.
+        """
+
+        mbar = 0
+        bar = 0
+        Torr = 1
+        Pascal = 2
+        Micron = 3
+        hPascal = 4
+        Volt = 5
+
+    SensorTypes = Enum(  # type: ignore
+        value="SensorTypes",
+        names=[
+            ("TPR/PCR Pirani Gauge", 1),
+            ("TPR", 1),
+            ("TPR/PCR", 1),
+            ("IKR Cold Cathode Gauge", 2),
+            ("IKR", 2),
+            ("IKR9", 2),
+            ("IKR11", 2),
+            ("PKR Full range CC", 3),
+            ("PKR", 3),
+            ("APR/CMR Linear Gauge", 4),
+            ("CMR", 4),
+            ("APR/CMR", 4),
+            ("CMR/APR", 4),
+            ("Pirani / High Pressure Gauge", 5),
+            ("IMR", 5),
+            ("Fullrange BA Gauge", 6),
+            ("PBR", 6),
+            ("None", 7),
+            ("no Sensor", 7),
+            ("noSen", 7),
+            ("noSENSOR", 7),
+        ],
+    )
+
+    class SensorStatus(IntEnum):
+        Ok = 0
+        Underrange = 1
+        Overrange = 2
+        Sensor_error = 3
+        Sensor_off = 4
+        No_sensor = 5
+        Identification_error = 6
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # list of sensors connected to the TPG
+        self.sensors: List[str] = []
+
+    def __repr__(self):
+        return f"Pfeiffer TPG with {self.number_of_sensors} sensors: {self.sensors}"
+
+    @property
+    def number_of_sensors(self):
+        return len(self.sensors)
+
+    @property
+    def unit(self):
+        """
+        The pressure unit of readings is always mbar, regardless of the display unit.
+        """
+        return "mbar"
+
+    @staticmethod
+    def default_com_cls():
+        return PfeifferTPGSerialCommunication
+
+    @staticmethod
+    def config_cls():
+        return PfeifferTPGConfig
+
+    def start(self) -> None:
+        """
+        Start this device. Opens the communication protocol,
+        and identify the sensors.
+
+        :raises SerialCommunicationIOError: when communication port cannot be opened
+        """
+
+        logger.info("Starting Pfeiffer TPG")
+        super().start()
+
+        # identify the sensors connected to the TPG
+        # and also find out the number of channels
+        self.identify_sensors()
+
+    def stop(self) -> None:
+        """
+        Stop the device. Closes also the communication protocol.
+        """
+
+        logger.info(f"Stopping device {self}")
+        super().stop()
+
+    def identify_sensors(self) -> None:
+        """
+        Send identification request TID to sensors on all channels.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        try:
+            answer = self.com.query("TID")
+        except PfeifferTPGError as e:
+            logger.error("Pressure sensor identification failed.", exc_info=e)
+            raise
+
+        # try matching the sensors:
+        sensors = []
+        for s in answer.split(","):
+            try:
+                sensors.append(self.SensorTypes[s].name)
+            except KeyError as e:
+                logger.error(str(e), exc_info=e)
+                sensors.append("Unknown")
+        self.sensors = sensors
+        # identification successful:
+        logger.info(f"Identified {self}")
+
+    def set_display_unit(self, unit: Union[str, PressureUnits]) -> None:
+        """
+        Set the unit in which the measurements are shown on the display.
+
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        if not isinstance(unit, self.PressureUnits):
+            unit = self.PressureUnits(unit)
+
+        try:
+            self.com.send_command(f"UNI,{unit.value}")
+            logger.info(f"Setting display unit to {unit.name}")
+        except PfeifferTPGError as e:
+            logger.error(
+                f"Setting display unit to {unit.name} failed. "
+                f"Not all units are available on all TGP models",
+                exc_info=e,
+            )
+            raise
+
+    def measure(self, channel: int) -> Tuple[str, float]:
+        """
+        Get the status and measurement of one sensor
+
+        :param channel: int channel on which the sensor is connected, with
+            1 <= channel <= number_of_sensors
+        :return: measured value as float if measurement successful,
+            sensor status as string if not
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        if not 1 <= channel <= self.number_of_sensors:
+            message = (
+                f"{channel} is not a valid channel number, it should be between "
+                f"1 and {self.number_of_sensors}"
+            )
+            logger.error(message)
+            raise ValueError(message)
+
+        try:
+            answer = self.com.query(f"PR{channel}")
+        except PfeifferTPGError as e:
+            logger.error(f"Reading sensor {channel} failed.", exc_info=e)
+            raise
+
+        status, measurement = answer.split(",")
+        s = self.SensorStatus(int(status))
+        if s == self.SensorStatus.Ok:
+            logger.info(
+                f"Channel {channel} successful reading of "
+                f"pressure: {measurement} mbar."
+            )
+        else:
+            logger.info(
+                f"Channel {channel} no reading of pressure, sensor status is "
+                f"{self.SensorStatus(s).name}."
+            )
+        return s.name, float(measurement)
+
+    def measure_all(self) -> List[Tuple[str, float]]:
+        """
+        Get the status and measurement of all sensors (this command is
+        not available on all models)
+
+        :return: list of measured values as float if measurements successful,
+            and or sensor status as strings if not
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        try:
+            answer = self.com.query("PRX")
+        except PfeifferTPGError as e:
+            logger.error(
+                "Getting pressure reading from all sensors failed "
+                "(this command is not available on all TGP models).",
+                exc_info=e,
+            )
+            raise
+
+        ans = answer.split(",")
+        ret = [
+            (self.SensorStatus(int(ans[2 * i])).name, float(ans[2 * i + 1]))
+            for i in range(self.number_of_sensors)
+        ]
+        logger.info(f"Reading all sensors with result: {ret}.")
+        return ret
+
+    def _set_full_scale(self, fsr: List[Number], unitless: bool) -> None:
+        """
+        Set the full scale range of the attached sensors. See lookup table between
+        command and corresponding pressure in the device user manual.
+
+        :param fsr: list of full scale range values, like `[0, 1, 3, 3, 2, 0]` for
+            `unitless = True` scale or `[0.01, 1000]` otherwise (mbar units scale)
+        :param unitless: flag to indicate scale of range values; if `False` then mbar
+            units scale
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+        if len(fsr) != self.number_of_sensors:
+            raise ValueError(
+                f"Argument fsr should be of length {self.number_of_sensors}. "
+                f"Received length {len(fsr)}."
+            )
+
+        possible_values_map = (
+            self.config.model.full_scale_ranges_reversed
+            if unitless
+            else self.config.model.full_scale_ranges
+        )
+        wrong_values = [v for v in fsr if v not in possible_values_map]
+        if wrong_values:
+            raise ValueError(
+                f"Argument fsr contains invalid values: {wrong_values}. Accepted "
+                f"values are {list(possible_values_map.items())}"
+                f"{'' if unitless else ' mbar'}."
+            )
+
+        str_fsr = ",".join(
+            [str(f if unitless else possible_values_map[f]) for f in fsr]
+        )
+        try:
+            self.com.send_command(f"FSR,{str_fsr}")
+            logger.info(f"Set sensors full scale to {fsr} " f"(unitless) respectively.")
+        except PfeifferTPGError as e:
+            logger.error("Setting sensors full scale failed.", exc_info=e)
+            raise e
+
+    def _get_full_scale(self, unitless: bool) -> List[Number]:
+        """
+        Get the full scale range of the attached sensors. See lookup table between
+        command and corresponding pressure in the device user manual.
+
+        :param unitless: flag to indicate scale of range values; if `False` then mbar
+            units scale
+        :return: list of full scale range values, like `[0, 1, 3, 3, 2, 0]` for
+            `unitless = True` scale or `[0.01, 1000]` otherwise (mbar units scale)
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        try:
+            answer = self.com.query("FSR")
+        except PfeifferTPGError as e:
+            logger.error("Query full scale range of all sensors failed.", exc_info=e)
+            raise
+
+        answer_values = answer.split(",")
+        wrong_values = [
+            v
+            for v in answer_values
+            if not self.config.model.is_valid_scale_range_reversed_str(v)
+        ]
+        if wrong_values:
+            raise PfeifferTPGError(
+                f"The controller returned the full unitless scale range values: "
+                f"{answer}. The values {wrong_values} are invalid. Accepted values are "
+                f"{list(self.config.model.full_scale_ranges_reversed.keys())}."
+            )
+
+        fsr = [
+            int(v) if unitless else self.config.model.full_scale_ranges_reversed[int(v)]
+            for v in answer_values
+        ]
+        logger.info(
+            f"Obtained full scale range of all sensors as {fsr}"
+            f"{'' if unitless else ' mbar'}."
+        )
+        return fsr
+
+    def set_full_scale_unitless(self, fsr: List[int]) -> None:
+        """
+        Set the full scale range of the attached sensors. See lookup table between
+        command and corresponding pressure in the device user manual.
+
+        :param fsr: list of full scale range values, like `[0, 1, 3, 3, 2, 0]`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+        self._set_full_scale(cast(List[Number], fsr), True)
+
+    def get_full_scale_unitless(self) -> List[int]:
+        """
+        Get the full scale range of the attached sensors. See lookup table between
+        command and corresponding pressure in the device user manual.
+
+        :return: list of full scale range values, like `[0, 1, 3, 3, 2, 0]`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+        return cast(List[int], self._get_full_scale(True))
+
+    def set_full_scale_mbar(self, fsr: List[Number]) -> None:
+        """
+        Set the full scale range of the attached sensors (in unit mbar)
+
+        :param fsr: full scale range values in mbar, for example `[0.01, 1000]`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+        self._set_full_scale(fsr, False)
+
+    def get_full_scale_mbar(self) -> List[Number]:
+        """
+        Get the full scale range of the attached sensors
+
+        :return: full scale range values in mbar, like `[0.01, 1, 0.1, 1000, 50000, 10]`
+        :raises SerialCommunicationIOError: when communication port is not opened
+        :raises PfeifferTPGError: if command fails
+        """
+
+        return self._get_full_scale(False)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/picotech_pt104.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/picotech_pt104.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,439 +1,438 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Controller for the Pico Technology PT-104 temperature logger device.
-The controller is written as a wrapper around Pico Technology driver for the PT-104
-device.
-
-This code is directly based on: https://github.com/trombastic/Pico_PT104/ .
-
-Extra installation
-~~~~~~~~~~~~~~~~~~
-
-Pico Technology driver for the PT-104 device is available only on Windows and on Linux.
-
-To use this PT-104 device wrapper:
-
-1. install the :code:`hvl_ccb` package with a :code:`picotech` extra feature::
-
-        $ pip install "hvl_ccb[picotech]"
-
-   this will install the Python bindings for the library.
-
-2. install the library
-
-    * on Windows: download and install PicoSDK from https://www.picotech.com/downloads
-      (choose "PicoLog Data Loggers" > "PT-104" > "Software");
-    * on Linux:
-        - for Ubuntu/Debian, install :code:`libusbpt104` from :code:`.deb` file found in
-          https://labs.picotech.com/debian/pool/main/libu/libusbpt104/ (note: at the
-          moment the PT-104 driver is not a part of the official :code:`picoscope`
-          package; cf.
-          https://www.picotech.com/support/topic40626.html );
-        - for any other supported Linux distribution, follow instructions to install
-          the "USB PT-104 devices" drivers in https://www.picotech.com/downloads/linux ;
-
-"""
-
-import logging
-from abc import ABC
-from ctypes import byref, c_long, c_short, c_ushort
-from dataclasses import dataclass, field
-from enum import IntEnum
-from functools import wraps
-from time import time
-from typing import Type, Dict, Optional
-
-import aenum
-from IPy import IP
-from picosdk.errors import CannotFindPicoSDKError  # type: ignore
-
-try:
-    from picosdk.usbPT104 import usbPt104 as pt104  # type: ignore
-except CannotFindPicoSDKError:
-    # PicoSDK Python wrapper tries to import PicoSDK system library already on import
-    raise ImportError
-
-from .base import SingleCommDevice
-from ..comm import NullCommunicationProtocol
-from ..configuration import configdataclass
-
-logger = logging.getLogger(__name__)
-
-
-class Pt104Exception(Exception):
-    """
-    Exception to indicate communication issues with the pt104.
-    """
-    pass
-
-
-def require_started(method):
-    """
-    Check if device `is_started` and raise an `Pt104Exception` if not.
-
-    :param method: `Pt104` instance method to wrap
-    :return: Whatever `method` returns
-    """
-    @wraps(method)
-    def wrapper(self, *args, **kwargs):
-        if not self.is_started:
-            err_msg = f"{self} is not started. Run `start()` method first."
-            logger.error(err_msg)
-            raise Pt104Exception(err_msg)
-        return method(self, *args, **kwargs)
-
-    return wrapper
-
-
-class Pt104Channels(IntEnum):
-    CHANNEL_1 = 1
-    CHANNEL_2 = 2
-    CHANNEL_3 = 3
-    CHANNEL_4 = 4
-    CHANNEL_5 = 5
-    CHANNEL_6 = 6
-    CHANNEL_7 = 7
-    CHANNEL_8 = 8
-    MAX_CHANNELS = CHANNEL_8
-
-
-class Pt104Wires(IntEnum):
-    WIRES_2 = 2
-    WIRES_3 = 3
-    WIRES_4 = 4
-    MIN_WIRES = WIRES_2
-    MAX_WIRES = WIRES_4
-
-
-class Pt104DataTypes(IntEnum):
-    OFF = 0
-    PT100 = 1
-    PT1000 = 2
-    RESISTANCE_TO_375R = 3
-    RESISTANCE_TO_10K = 4
-    DIFFERENTIAL_TO_115MV = 5
-    DIFFERENTIAL_TO_2500MV = 6
-    SINGLE_ENDED_TO_115MV = 7
-    SINGLE_ENDED_TO_2500MV = 8
-
-    @property
-    def is_active(self):
-        return self is not Pt104DataTypes.OFF
-
-
-_pt104_ct_dict = pt104.COMMUNICATION_TYPE()
-
-
-class Pt104CommunicationType(aenum.IntEnum):
-    _init_ = "value open_unit"
-    USB = (
-        _pt104_ct_dict["CT_USB"],
-        pt104._OpenUnit,  # UsbPt104OpenUnit
-    )
-    ETHERNET = (
-        _pt104_ct_dict["CT_ETHERNET"],
-        pt104._OpenUnitViaIp,  # UsbPt104OpenUnitViaIP
-    )
-
-    @property
-    def requires_host(self) -> bool:
-        return self == self.__class__.ETHERNET
-
-
-@configdataclass
-class Pt104DeviceConfig:
-    """
-    Configuration dataclass for PT104
-    """
-
-    #: Serial number
-    serial_number: str
-    #: Interface to communicate on
-    interface: Pt104CommunicationType
-    #: Host TCP/IP address, if applicable
-    host: Optional[str] = None
-    #: TCP port number, if applicable
-    port: Optional[int] = None
-
-    def clean_values(self):
-        if self.interface.requires_host:
-            if not self.host:
-                raise ValueError(f"Host IP is required for interface: {self.interface}")
-            IP(self.host)
-
-    @property
-    def host_address(self) -> Optional[str]:
-        if self.host:
-            port_sufix = f":{self.port}" if self.port else ""
-            return f"{self.host}{port_sufix}"
-        return None
-
-
-@dataclass
-class Pt104ChannelConfig:
-    data_type: Pt104DataTypes = Pt104DataTypes.OFF
-    nb_wires: Pt104Wires = Pt104Wires.WIRES_4
-    low_pass_filter: bool = True
-    value: c_long = c_long(0)
-    last_query: float = field(init=False)
-
-    def __post_init__(self):
-        self.last_query = time()
-
-
-class Pt104(SingleCommDevice, ABC):
-    """
-    PicoTech pt104 data logger class.
-    """
-
-    def __init__(self, com, dev_config=None) -> None:
-        """
-        Constructor for pt104.
-
-        :param com: object to use as communication protocol.
-        """
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        self.channels: Dict[Pt104Channels, Pt104ChannelConfig] = {
-            ch: Pt104ChannelConfig()
-            for ch in (
-                Pt104Channels.CHANNEL_1,
-                Pt104Channels.CHANNEL_2,
-                Pt104Channels.CHANNEL_3,
-                Pt104Channels.CHANNEL_4,
-            )
-        }
-        self._handle: Optional[c_short] = None
-
-    @staticmethod
-    def default_com_cls() -> Type[NullCommunicationProtocol]:
-        return NullCommunicationProtocol
-
-    @staticmethod
-    def config_cls():
-        return Pt104DeviceConfig
-
-    @staticmethod
-    def _validate_channel(self, channel: int):
-        if channel not in self.channels:
-            raise ValueError(f"Invalid channel {channel}; available channels are: "
-                             f"", ".join(self.channels.keys())}.")
-
-    @property
-    def is_connected(self) -> bool:
-        """Check the connection status.
-
-        :return: `True` if connection with device is initiated, `False` otherwise.
-        """
-        return self._handle is not None
-
-    @property
-    def is_started(self) -> bool:
-        """Check if device is started.
-
-        :return: `True` if device is started, `False` otherwise.
-        """
-        return self.is_connected
-
-    def start(self) -> None:
-        """Connect to a Pt-104A data acquisition module via USB or Ethernet
-        """
-        logger.info("Starting device " + str(self))
-        super().start()
-
-        if self.is_connected:
-            self.stop()
-
-        self._handle = c_short()
-
-        open_unit_extra_args = []
-        if self.config.interface.requires_host:
-            open_unit_extra_args.append(self.config.host_address.encode())
-        status_unit = self.config.interface.open_unit(
-            byref(self._handle),
-            self.config.serial_number.encode(),
-            *open_unit_extra_args
-        )
-
-        if status_unit != 0:
-            self._handle = None
-            msg = (
-                f"Communication with pt104 could not be established, "
-                f"error code: {status_unit}"
-            )
-            logger.error(msg)
-            raise Pt104Exception(msg)
-
-        self.set_channels()
-
-    @property
-    def active_channel_count(self) -> int:
-        """return the number of active channels
-        :return: number of active channels
-        """
-        n = 0
-        for channel, conf in self.channels.items():
-            if conf.data_type.is_active:
-                n += 1
-        return n
-
-    def stop(self) -> None:
-        """disconnect from the unit
-        :return: bool
-        """
-        logger.info("Stopping device " + str(self))
-        pt104.UsbPt104CloseUnit(self._handle)
-        self._handle = None
-        super().stop()
-
-    @require_started
-    def set_channel(
-        self,
-        channel: Pt104Channels,
-        data_type: Pt104DataTypes,
-        nb_wires: Pt104Wires,
-        low_pass_filter: bool = True,
-    ) -> None:
-        """writes the channel configuration to self.channels and the device.
-        :param channel: channel number (Pt104Channels)
-        :param data_type: data type of the connected probe (DataType)
-        :param nb_wires: number of wires (Pt104Wires)
-        :param low_pass_filter: use the low pass filter [True, False]
-        :return: status
-        """
-        logger.info(f"Configuring channel: {channel}")
-        self._validate_channel(self, channel)
-        self.channels[channel].data_type = data_type
-        self.channels[channel].nb_wires = nb_wires
-        self.channels[channel].low_pass_filter = low_pass_filter
-
-        cs = pt104.UsbPt104SetChannel(self._handle, channel, data_type, nb_wires)
-        if cs != 0:
-            msg = f"Setting channel {channel} failed with error {cs}"
-            logger.error(msg)
-            raise Pt104Exception(msg)
-
-    def set_channels(self) -> None:
-        """sets the channel configuration from self.channels
-        """
-        for channel in self.channels:
-            self.set_channel(channel, self.channels[channel].data_type,
-                             self.channels[channel].nb_wires)
-
-    @require_started
-    def get_value(self, channel: Pt104Channels, raw_value: bool = False) -> float:
-        """queries the measurement value from the unit
-        :param channel: channel number (Pt104Channels)
-        :param raw_value: skip conversion
-        :return: measured value
-        """
-        self._validate_channel(self, channel)
-        result = None
-        count = 0
-        while result is None:
-            count += 1
-            self._wait_for_conversion(channel)
-            status_channel = pt104.UsbPt104GetValue(
-                self._handle,
-                channel,
-                byref(self.channels[channel].value),
-                self.channels[channel].low_pass_filter,
-            )
-            self.channels[channel].last_query = time()
-            if status_channel == 0:
-                if raw_value:
-                    result = float(self.channels[channel].value.value)
-                    return result
-                result = self.scale_value(
-                    float(self.channels[channel].value.value), channel
-                )
-                return result
-            else:
-                msg = f"Error while reading {channel}, error code {status_channel}"
-                logger.error(msg)
-            if count == 10:
-                msg = f"Could not retrieve value from pt104 {channel} after 10 trials"
-                logger.error(msg)
-                raise Pt104Exception(msg)
-
-    @property
-    def get_value_channel_1(self) -> float:
-        """queries the measurement value from channel 1
-        :return: scaled measured value
-        """
-        return self.get_value(Pt104Channels.CHANNEL_1)
-
-    @property
-    def get_value_channel_2(self) -> float:
-        """queries the measurement value from channel 2
-        :return: scaled measured value
-        """
-        return self.get_value(Pt104Channels.CHANNEL_2)
-
-    @property
-    def get_value_channel_3(self) -> float:
-        """queries the measurement value from channel 3
-        :return: scaled measured value
-        """
-        return self.get_value(Pt104Channels.CHANNEL_3)
-
-    @property
-    def get_value_channel_4(self) -> float:
-        """queries the measurement value from channel 4
-        :return: scaled measured value
-        """
-        return self.get_value(Pt104Channels.CHANNEL_4)
-
-    def set_mains(self, sixty_hertz: bool = False) -> None:
-        """This function is used to inform the driver of the
-        local mains (line) frequency.
-        This helps the driver to filter out electrical noise.
-        :param sixty_hertz: mains frequency is sixty
-        :return: success
-        """
-        if sixty_hertz:
-            sixty = c_ushort(1)
-            logger.info("set mains freq to 60 Hz")
-        else:
-            sixty = c_ushort(0)
-            logger.info("set mains freq to 50 Hz")
-        pt104.UsbPt104SetMains(self._handle, sixty)
-
-    def _wait_for_conversion(self, channel: Pt104Channels) -> None:
-        """wait until the adc conversion is finished
-        :param channel: channel number (Pt104Channels)
-        :return:
-        """
-        conversion_time = self.active_channel_count * 0.75
-        last_query = self.channels[channel].last_query
-        while last_query + conversion_time > time():
-            pass
-
-    def scale_value(self, value: float, channel: Pt104Channels) -> float:
-        """scales the value from the device.
-        :param value: value to convert as float
-        :param channel: channel number (Pt104Channels)
-        :return: Temperature in °C, Resistance in mOhm, Voltage in mV
-        """
-        if self.channels[channel].data_type in [Pt104DataTypes.PT100,
-                                                Pt104DataTypes.PT1000]:
-            return value / 10.0 ** 3  # °C
-        if self.channels[channel].data_type == Pt104DataTypes.RESISTANCE_TO_375R:
-            return value / 10.0 ** 3  # mOhm
-        if self.channels[channel].data_type == Pt104DataTypes.RESISTANCE_TO_10K:
-            return value  # mOhm
-        if self.channels[channel].data_type in [
-            Pt104DataTypes.DIFFERENTIAL_TO_115MV,
-            Pt104DataTypes.SINGLE_ENDED_TO_115MV,
-        ]:
-            return value / 10.0 ** 9  # mV
-        if self.channels[channel].data_type in [
-            Pt104DataTypes.DIFFERENTIAL_TO_2500MV,
-            Pt104DataTypes.SINGLE_ENDED_TO_2500MV,
-        ]:
-            return value / 10.0 ** 8  # mV
-        else:
-            raise Pt104Exception('selected datatype not recognized')
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Controller for the Pico Technology PT-104 temperature logger device.
+The controller is written as a wrapper around Pico Technology driver for the PT-104
+device.
+
+This code is directly based on: https://github.com/trombastic/Pico_PT104/ .
+
+Extra installation
+~~~~~~~~~~~~~~~~~~
+
+Pico Technology driver for the PT-104 device is available only on Windows and on Linux.
+
+To use this PT-104 device wrapper:
+
+1. install the :code:`hvl_ccb` package with a :code:`picotech` extra feature::
+
+        $ pip install "hvl_ccb[picotech]"
+
+   this will install the Python bindings for the library.
+
+2. install the library
+
+    * on Windows: download and install PicoSDK from https://www.picotech.com/downloads
+      (choose "PicoLog Data Loggers" > "PT-104" > "Software");
+    * on Linux:
+        - for Ubuntu/Debian, install :code:`libusbpt104` from :code:`.deb` file found in
+          https://labs.picotech.com/debian/pool/main/libu/libusbpt104/ (note: at the
+          moment the PT-104 driver is not a part of the official :code:`picoscope`
+          package; cf.
+          https://www.picotech.com/support/topic40626.html );
+        - for any other supported Linux distribution, follow instructions to install
+          the "USB PT-104 devices" drivers in https://www.picotech.com/downloads/linux ;
+
+"""
+
+import logging
+from abc import ABC
+from ctypes import byref, c_long, c_short, c_ushort
+from dataclasses import dataclass, field
+from enum import IntEnum
+from functools import wraps
+from ipaddress import IPv4Address, IPv6Address
+from time import time
+from typing import Type, Dict, Optional, Union
+
+import aenum
+from picosdk.errors import CannotFindPicoSDKError  # type: ignore
+
+try:
+    from picosdk.usbPT104 import usbPt104 as pt104  # type: ignore
+except CannotFindPicoSDKError:
+    # PicoSDK Python wrapper tries to import PicoSDK system library already on import
+    raise ImportError
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import NullCommunicationProtocol
+from ..configuration import configdataclass
+from hvl_ccb.utils.validation import validate_and_resolve_host, validate_tcp_port
+
+logger = logging.getLogger(__name__)
+
+
+class Pt104Exception(DeviceException):
+    """
+    Exception to indicate communication issues with the pt104.
+    """
+    pass
+
+
+def require_started(method):
+    """
+    Check if device `is_started` and raise an `Pt104Exception` if not.
+
+    :param method: `Pt104` instance method to wrap
+    :return: Whatever `method` returns
+    """
+    @wraps(method)
+    def wrapper(self, *args, **kwargs):
+        if not self.is_started:
+            err_msg = f"{self} is not started. Run `start()` method first."
+            logger.error(err_msg)
+            raise Pt104Exception(err_msg)
+        return method(self, *args, **kwargs)
+
+    return wrapper
+
+
+class Pt104Channels(IntEnum):
+    CHANNEL_1 = 1
+    CHANNEL_2 = 2
+    CHANNEL_3 = 3
+    CHANNEL_4 = 4
+    CHANNEL_5 = 5
+    CHANNEL_6 = 6
+    CHANNEL_7 = 7
+    CHANNEL_8 = 8
+    MAX_CHANNELS = CHANNEL_8
+
+
+class Pt104Wires(IntEnum):
+    WIRES_2 = 2
+    WIRES_3 = 3
+    WIRES_4 = 4
+    MIN_WIRES = WIRES_2
+    MAX_WIRES = WIRES_4
+
+
+class Pt104DataTypes(IntEnum):
+    OFF = 0
+    PT100 = 1
+    PT1000 = 2
+    RESISTANCE_TO_375R = 3
+    RESISTANCE_TO_10K = 4
+    DIFFERENTIAL_TO_115MV = 5
+    DIFFERENTIAL_TO_2500MV = 6
+    SINGLE_ENDED_TO_115MV = 7
+    SINGLE_ENDED_TO_2500MV = 8
+
+    @property
+    def is_active(self):
+        return self is not Pt104DataTypes.OFF
+
+
+_pt104_ct_dict = pt104.COMMUNICATION_TYPE()
+
+
+class Pt104CommunicationType(aenum.IntEnum, init="value open_unit"):  # type: ignore
+    USB = (
+        _pt104_ct_dict["CT_USB"],
+        pt104._OpenUnit,  # UsbPt104OpenUnit
+    )
+    ETHERNET = (
+        _pt104_ct_dict["CT_ETHERNET"],
+        pt104._OpenUnitViaIp,  # UsbPt104OpenUnitViaIP
+    )
+
+    @property
+    def requires_host(self) -> bool:
+        return self == self.__class__.ETHERNET
+
+
+@configdataclass
+class Pt104DeviceConfig:
+    """
+    Configuration dataclass for PT104
+    """
+
+    #: Serial number
+    serial_number: str
+    #: Interface to communicate on
+    interface: Pt104CommunicationType
+    #: Host TCP/IP address, if applicable
+    host: Optional[Union[str, IPv4Address, IPv6Address]] = None
+    #: TCP port number, if applicable
+    port: Optional[int] = None
+
+    def clean_values(self):
+        if self.interface.requires_host:
+            self.force_value("host", validate_and_resolve_host(self.host, logger))
+            validate_tcp_port(self.port, logger)
+
+    @property
+    def host_address(self) -> Optional[str]:
+        if self.host:
+            port_sufix = f":{self.port}" if self.port else ""
+            return f"{self.host}{port_sufix}"
+        return None
+
+
+@dataclass
+class Pt104ChannelConfig:
+    data_type: Pt104DataTypes = Pt104DataTypes.OFF
+    nb_wires: Pt104Wires = Pt104Wires.WIRES_4
+    low_pass_filter: bool = True
+    value: c_long = c_long(0)
+    last_query: float = field(init=False)
+
+    def __post_init__(self):
+        self.last_query = time()
+
+
+class Pt104(SingleCommDevice, ABC):
+    """
+    PicoTech pt104 data logger class.
+    """
+
+    def __init__(self, com, dev_config=None) -> None:
+        """
+        Constructor for pt104.
+
+        :param com: object to use as communication protocol.
+        """
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        self.channels: Dict[Pt104Channels, Pt104ChannelConfig] = {
+            ch: Pt104ChannelConfig()
+            for ch in (
+                Pt104Channels.CHANNEL_1,
+                Pt104Channels.CHANNEL_2,
+                Pt104Channels.CHANNEL_3,
+                Pt104Channels.CHANNEL_4,
+            )
+        }
+        self._handle: Optional[c_short] = None
+
+    @staticmethod
+    def default_com_cls() -> Type[NullCommunicationProtocol]:
+        return NullCommunicationProtocol
+
+    @staticmethod
+    def config_cls():
+        return Pt104DeviceConfig
+
+    @staticmethod
+    def _validate_channel(self, channel: int):
+        if channel not in self.channels:
+            raise ValueError(f"Invalid channel {channel}; available channels are: "
+                             f"", ".join(self.channels.keys())}.")
+
+    @property
+    def is_connected(self) -> bool:
+        """Check the connection status.
+
+        :return: `True` if connection with device is initiated, `False` otherwise.
+        """
+        return self._handle is not None
+
+    @property
+    def is_started(self) -> bool:
+        """Check if device is started.
+
+        :return: `True` if device is started, `False` otherwise.
+        """
+        return self.is_connected
+
+    def start(self) -> None:
+        """Connect to a Pt-104A data acquisition module via USB or Ethernet
+        """
+        logger.info("Starting device " + str(self))
+        super().start()
+
+        if self.is_connected:
+            self.stop()
+
+        self._handle = c_short()
+
+        open_unit_extra_args = []
+        if self.config.interface.requires_host:
+            open_unit_extra_args.append(self.config.host_address.encode())
+        status_unit = self.config.interface.open_unit(
+            byref(self._handle),
+            self.config.serial_number.encode(),
+            *open_unit_extra_args
+        )
+
+        if status_unit != 0:
+            self._handle = None
+            msg = (
+                f"Communication with pt104 could not be established, "
+                f"error code: {status_unit}"
+            )
+            logger.error(msg)
+            raise Pt104Exception(msg)
+
+        self.set_channels()
+
+    @property
+    def active_channel_count(self) -> int:
+        """return the number of active channels
+        :return: number of active channels
+        """
+        n = 0
+        for channel, conf in self.channels.items():
+            if conf.data_type.is_active:
+                n += 1
+        return n
+
+    def stop(self) -> None:
+        """disconnect from the unit
+        :return: bool
+        """
+        logger.info("Stopping device " + str(self))
+        pt104.UsbPt104CloseUnit(self._handle)
+        self._handle = None
+        super().stop()
+
+    @require_started
+    def set_channel(
+        self,
+        channel: Pt104Channels,
+        data_type: Pt104DataTypes,
+        nb_wires: Pt104Wires,
+        low_pass_filter: bool = True,
+    ) -> None:
+        """writes the channel configuration to self.channels and the device.
+        :param channel: channel number (Pt104Channels)
+        :param data_type: data type of the connected probe (DataType)
+        :param nb_wires: number of wires (Pt104Wires)
+        :param low_pass_filter: use the low pass filter [True, False]
+        :return: status
+        """
+        logger.info(f"Configuring channel: {channel}")
+        self._validate_channel(self, channel)
+        self.channels[channel].data_type = data_type
+        self.channels[channel].nb_wires = nb_wires
+        self.channels[channel].low_pass_filter = low_pass_filter
+
+        cs = pt104.UsbPt104SetChannel(self._handle, channel, data_type, nb_wires)
+        if cs != 0:
+            msg = f"Setting channel {channel} failed with error {cs}"
+            logger.error(msg)
+            raise Pt104Exception(msg)
+
+    def set_channels(self) -> None:
+        """sets the channel configuration from self.channels
+        """
+        for channel in self.channels:
+            self.set_channel(channel, self.channels[channel].data_type,
+                             self.channels[channel].nb_wires)
+
+    @require_started
+    def get_value(self, channel: Pt104Channels, raw_value: bool = False) -> float:
+        """queries the measurement value from the unit
+        :param channel: channel number (Pt104Channels)
+        :param raw_value: skip conversion
+        :return: measured value
+        """
+        self._validate_channel(self, channel)
+        result = None
+        count = 0
+        while result is None:
+            count += 1
+            self._wait_for_conversion(channel)
+            status_channel = pt104.UsbPt104GetValue(
+                self._handle,
+                channel,
+                byref(self.channels[channel].value),
+                self.channels[channel].low_pass_filter,
+            )
+            self.channels[channel].last_query = time()
+            if status_channel == 0:
+                if raw_value:
+                    result = float(self.channels[channel].value.value)
+                    return result
+                result = self.scale_value(
+                    float(self.channels[channel].value.value), channel
+                )
+                return result
+            else:
+                msg = f"Error while reading {channel}, error code {status_channel}"
+                logger.error(msg)
+            if count == 10:
+                msg = f"Could not retrieve value from pt104 {channel} after 10 trials"
+                logger.error(msg)
+                raise Pt104Exception(msg)
+
+    @property
+    def get_value_channel_1(self) -> float:
+        """queries the measurement value from channel 1
+        :return: scaled measured value
+        """
+        return self.get_value(Pt104Channels.CHANNEL_1)
+
+    @property
+    def get_value_channel_2(self) -> float:
+        """queries the measurement value from channel 2
+        :return: scaled measured value
+        """
+        return self.get_value(Pt104Channels.CHANNEL_2)
+
+    @property
+    def get_value_channel_3(self) -> float:
+        """queries the measurement value from channel 3
+        :return: scaled measured value
+        """
+        return self.get_value(Pt104Channels.CHANNEL_3)
+
+    @property
+    def get_value_channel_4(self) -> float:
+        """queries the measurement value from channel 4
+        :return: scaled measured value
+        """
+        return self.get_value(Pt104Channels.CHANNEL_4)
+
+    def set_mains(self, sixty_hertz: bool = False) -> None:
+        """This function is used to inform the driver of the
+        local mains (line) frequency.
+        This helps the driver to filter out electrical noise.
+        :param sixty_hertz: mains frequency is sixty
+        :return: success
+        """
+        if sixty_hertz:
+            sixty = c_ushort(1)
+            logger.info("set mains freq to 60 Hz")
+        else:
+            sixty = c_ushort(0)
+            logger.info("set mains freq to 50 Hz")
+        pt104.UsbPt104SetMains(self._handle, sixty)
+
+    def _wait_for_conversion(self, channel: Pt104Channels) -> None:
+        """wait until the adc conversion is finished
+        :param channel: channel number (Pt104Channels)
+        :return:
+        """
+        conversion_time = self.active_channel_count * 0.75
+        last_query = self.channels[channel].last_query
+        while last_query + conversion_time > time():
+            pass
+
+    def scale_value(self, value: float, channel: Pt104Channels) -> float:
+        """scales the value from the device.
+        :param value: value to convert as float
+        :param channel: channel number (Pt104Channels)
+        :return: Temperature in °C, Resistance in mOhm, Voltage in mV
+        """
+        if self.channels[channel].data_type in [Pt104DataTypes.PT100,
+                                                Pt104DataTypes.PT1000]:
+            return value / 10.0 ** 3  # °C
+        if self.channels[channel].data_type == Pt104DataTypes.RESISTANCE_TO_375R:
+            return value / 10.0 ** 3  # mOhm
+        if self.channels[channel].data_type == Pt104DataTypes.RESISTANCE_TO_10K:
+            return value  # mOhm
+        if self.channels[channel].data_type in [
+            Pt104DataTypes.DIFFERENTIAL_TO_115MV,
+            Pt104DataTypes.SINGLE_ENDED_TO_115MV,
+        ]:
+            return value / 10.0 ** 9  # mV
+        if self.channels[channel].data_type in [
+            Pt104DataTypes.DIFFERENTIAL_TO_2500MV,
+            Pt104DataTypes.SINGLE_ENDED_TO_2500MV,
+        ]:
+            return value / 10.0 ** 8  # mV
+        else:
+            raise Pt104Exception('selected datatype not recognized')
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/rs_rto1024.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/rs_rto1024.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,804 +1,805 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Python module for the Rhode & Schwarz RTO 1024 oscilloscope.
-The communication to the device is through VISA, type TCPIP / INSTR.
-"""
-
-import logging
-import re
-from pathlib import PureWindowsPath
-from time import sleep
-from typing import List, Tuple, Union
-
-from .visa import (
-    VisaDevice,
-    VisaDeviceConfig,
-    _VisaDeviceConfigBase,
-    _VisaDeviceConfigDefaultsBase,
-)
-from ..comm.visa import VisaCommunication, VisaCommunicationConfig
-from ..configuration import configdataclass
-from ..utils.enum import AutoNumberNameEnum
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class RTO1024Error(Exception):
-    pass
-
-
-@configdataclass
-class _RTO1024ConfigBase(_VisaDeviceConfigBase):
-
-    waveforms_path: str
-    """
-    Windows directory on the oscilloscope filesystem for storing waveforms.
-    Mind escaping the backslashes of the path.
-    """
-
-    settings_path: str
-    """
-    Windows directory on the oscilloscope filesystem for storing settings .dfl files.
-    Mind escaping the backslashes of the path.
-    """
-
-    backup_path: str
-    """
-    Windows directory on the oscilloscope filesystem for use as backup directory for
-    waveforms. Mind escaping the backslashes of the path.
-    """
-
-
-@configdataclass
-class _RTO1024ConfigDefaultsBase(_VisaDeviceConfigDefaultsBase):
-
-    command_timeout_seconds: Number = 60
-    """
-    Timeout to wait for asynchronous commands to complete, in seconds. This timeout
-    is respected for long operations such as storing waveforms.
-    """
-    wait_sec_short_pause: Number = 0.1
-    """Time for short wait periods, in seconds (depends on both device and
-    network/connection)."""
-    wait_sec_enable_history: Number = 1
-    """Time to wait after enabling history, in seconds."""
-    wait_sec_post_acquisition_start: Number = 2
-    """Time to wait after start of continuous acquisition, in seconds."""
-
-    def clean_values(self):
-        super().clean_values()
-
-        if self.command_timeout_seconds <= 0:
-            raise ValueError(
-                "Timeout to wait for asynchronous commands to complete must be a "
-                "positive value (in seconds)."
-            )
-        if self.wait_sec_short_pause <= 0:
-            raise ValueError(
-                "Wait time for a short pause must be a positive value (in seconds)."
-            )
-        if self.wait_sec_enable_history <= 0:
-            raise ValueError(
-                "Wait time for enabling history must be a positive value (in seconds)."
-            )
-        if self.wait_sec_post_acquisition_start <= 0:
-            raise ValueError(
-                "Wait time after acquisition start must be a positive value (in "
-                "seconds)."
-            )
-
-
-@configdataclass
-class RTO1024Config(VisaDeviceConfig, _RTO1024ConfigDefaultsBase, _RTO1024ConfigBase):
-    """
-    Configdataclass for the RTO1024 device.
-    """
-
-    pass
-
-
-@configdataclass
-class RTO1024VisaCommunicationConfig(VisaCommunicationConfig):
-    """
-    Configuration dataclass for VisaCommunication with specifications for the RTO1024
-    device class.
-    """
-
-    interface_type: Union[
-        str, VisaCommunicationConfig.InterfaceType
-    ] = VisaCommunicationConfig.InterfaceType.TCPIP_INSTR  # type: ignore
-
-
-class RTO1024VisaCommunication(VisaCommunication):
-    """
-    Specialization of VisaCommunication for the RTO1024 oscilloscope
-    """
-
-    @staticmethod
-    def config_cls():
-        return RTO1024VisaCommunicationConfig
-
-
-class RTO1024(VisaDevice):
-    """
-    Device class for the Rhode & Schwarz RTO 1024 oscilloscope.
-    """
-
-    class TriggerModes(AutoNumberNameEnum):
-        """
-        Enumeration for the three available trigger modes.
-        """
-
-        AUTO = ()
-        NORMAL = ()
-        FREERUN = ()
-
-        @classmethod
-        def names(cls):
-            """
-            Returns a list of the available trigger modes.
-            :return: list of strings
-            """
-
-            return list(map(lambda x: x.name, cls))
-
-    @staticmethod
-    def config_cls():
-        return RTO1024Config
-
-    @staticmethod
-    def default_com_cls():
-        return RTO1024VisaCommunication
-
-    def __init__(
-        self,
-        com: Union[RTO1024VisaCommunication, RTO1024VisaCommunicationConfig, dict],
-        dev_config: Union[RTO1024Config, dict],
-    ):
-        super().__init__(com, dev_config)
-
-    def start(self) -> None:
-        """
-        Start the RTO1024 oscilloscope and bring it into a defined state and remote
-        mode.
-        """
-
-        super().start()
-
-        # go to remote mode
-        self.com.write("&GTR")
-
-        # reset device (RST) and clear status registers (CLS)
-        self.com.write("*RST", "*CLS")
-
-        # enable local display
-        self.local_display(True)
-
-        # enable status register
-        self.com.write("*ESE 127")
-
-    def stop(self) -> None:
-        """
-        Stop the RTO1024 oscilloscope, reset events and close communication. Brings
-        back the device to a state where local operation is possible.
-        """
-
-        if self._spoll_thread is not None and self._spoll_thread.is_polling():
-            # disable any events, EventStatusEnable ESE = 0
-            self.com.write("*ESE 0")
-
-            # disable any service requests SRE = 0
-            self.com.write("*SRE 0")
-
-            # device clear: abort processing of any commands
-            self.com.write("&DCL")
-
-            # go to local mode
-            self.com.write("&GTL")
-        else:
-            logger.warning("RTO1024 was already stopped")
-
-        super().stop()
-
-    def local_display(self, state: bool) -> None:
-        """
-        Enable or disable local display of the scope.
-
-        :param state: is the desired local display state
-        """
-        state_str = "ON" if state else "OFF"
-        self.com.write(f"SYST:DISP:UPD {state_str}")
-
-    def set_acquire_length(self, timerange: float) -> None:
-        r"""
-        Defines the time of one acquisition, that is the time across the 10 divisions
-        of the diagram.
-
-        *  Range: 250E-12 ... 500 [s]
-        *  Increment: 1E-12 [s]
-        *  \*RST = 0.5 [s]
-
-        :param timerange: is the time for one acquisition. Range: 250e-12 ... 500 [s]
-        """
-
-        self.com.write(f"TIMebase:RANGe {timerange:G}")
-
-    def get_acquire_length(self) -> float:
-        r"""
-        Gets the time of one acquisition, that is the time across the 10 divisions
-        of the diagram.
-
-        *  Range: 250E-12 ... 500 [s]
-        *  Increment: 1E-12 [s]
-
-        :return: the time for one acquisition. Range: 250e-12 ... 500 [s]
-        """
-
-        return float(self.com.query("TIMebase:RANGe?"))
-
-    def set_reference_point(self, percentage: int) -> None:
-        r"""
-        Sets the reference point of the time scale in % of the display.
-        If the "Trigger offset" is zero, the trigger point matches the reference point.
-        ReferencePoint = zero pint of the time scale
-
-        *  Range: 0 ... 100 [%]
-        *  Increment: 1 [%]
-        *  \*RST = 50 [%]
-
-        :param percentage: is the reference in %
-        """
-
-        self.com.write(f"TIMebase:REFerence {percentage:d}")
-
-    def get_reference_point(self) -> int:
-        r"""
-        Gets the reference point of the time scale in % of the display.
-        If the "Trigger offset" is zero, the trigger point matches the reference point.
-        ReferencePoint = zero pint of the time scale
-
-        *  Range: 0 ... 100 [%]
-        *  Increment: 1 [%]
-
-        :return: the reference in %
-        """
-
-        return int(self.com.query("TIMebase:REFerence?"))
-
-    def set_repetitions(self, number: int) -> None:
-        r"""
-        Set the number of acquired waveforms with RUN Nx SINGLE. Also defines the
-        number of waveforms used to calculate the average waveform.
-
-        *  Range: 1 ... 16777215
-        *  Increment: 10
-        *  \*RST = 1
-
-        :param number: is the number of waveforms to acquire
-        """
-
-        self.com.write(f"ACQuire:COUNt {number:d}")
-
-    def get_repetitions(self) -> int:
-        r"""
-        Get the number of acquired waveforms with RUN Nx SINGLE. Also defines the
-        number of waveforms used to calculate the average waveform.
-
-        *  Range: 1 ... 16777215
-        *  Increment: 10
-        *  \*RST = 1
-
-        :return: the number of waveforms to acquire
-        """
-
-        return int(self.com.query("ACQuire:COUNt?"))
-
-    def set_channel_state(self, channel: int, state: bool) -> None:
-        """
-        Switches the channel signal on or off.
-
-        :param channel: is the input channel (1..4)
-        :param state: is True for on, False for off
-        """
-
-        self.com.write(f"CHANnel{channel}:STATe {'ON' if state else 'OFF'}")
-
-    def get_channel_state(self, channel: int) -> bool:
-        """
-        Queries if the channel is active or not.
-
-        :param channel: is the input channel (1..4)
-        :return: True if active, else False
-        """
-
-        return self.com.query(f"CHANnel{channel}:STATe?") == "1"
-
-    def set_channel_scale(self, channel: int, scale: float) -> None:
-        r"""
-        Sets the vertical scale for the indicated channel.
-        The scale value is given in volts per division.
-
-        *   Range for scale: depends on attenuation factor and coupling. With
-            1:1 probe and external attenuations and 50 Ω input
-            coupling, the vertical scale (input sensitivity) is 1
-            mV/div to 1 V/div. For 1 MΩ input coupling, it is 1
-            mV/div to 10 V/div. If the probe and/or external
-            attenuation is changed, multiply the values by the
-            attenuation factors to get the actual scale range.
-
-        *  Increment: 1e-3
-        *  \*RST = 0.05
-
-        See also:
-        set_channel_range
-
-        :param channel: is the channel number (1..4)
-        :param scale: is the vertical scaling [V/div]
-        """
-
-        self.com.write(f"CHANnel{channel}:SCALe {scale:4.3f}")
-
-    def get_channel_scale(self, channel: int) -> float:
-        """
-        Queries the channel scale in V/div.
-
-        :param channel: is the input channel (1..4)
-        :return: channel scale in V/div
-        """
-
-        return float(self.com.query(f"CHANnel{channel}:SCALe?"))
-
-    def set_channel_range(self, channel: int, v_range: float) -> None:
-        r"""
-        Sets the voltage range across the 10 vertical divisions of the diagram. Use
-        the command alternatively instead of set_channel_scale.
-
-        *   Range for range: Depends on attenuation factors and coupling. With
-            1:1 probe and external attenuations and 50 Ω input
-            coupling, the range is 10 mV to 10 V. For 1 MΩ
-            input coupling, it is 10 mV to 100 V. If the probe
-            and/or external attenuation is changed, multiply the
-            range values by the attenuation factors.
-
-        *  Increment: 0.01
-        *  \*RST = 0.5
-
-        :param channel: is the channel number (1..4)
-        :param v_range: is the vertical range [V]
-        """
-
-        self.com.write(f"CHANnel{channel}:RANGe {v_range:4.3f}")
-
-    def get_channel_range(self, channel: int) -> float:
-        """
-        Queries the channel range in V.
-
-        :param channel: is the input channel (1..4)
-        :return: channel range in V
-        """
-
-        return float(self.com.query(f"CHANnel{channel}:RANGe?"))
-
-    def set_channel_position(self, channel: int, position: float) -> None:
-        r"""
-        Sets the vertical position of the indicated channel as a graphical value.
-
-        *  Range: -5.0 ... 5.0 [div]
-        *  Increment: 0.02
-        *  \*RST = 0
-
-        :param channel: is the channel number (1..4)
-        :param position: is the position. Positive values move the waveform up,
-            negative values move it down.
-        """
-
-        self.com.write(f"CHANnel{channel}:POSition {position:3.2f}")
-
-    def get_channel_position(self, channel: int) -> float:
-        r"""
-        Gets the vertical position of the indicated channel.
-
-        :param channel: is the channel number (1..4)
-        :return: channel position in div (value between -5 and 5)
-        """
-
-        return float(self.com.query(f"CHANnel{channel}:POSition?"))
-
-    def set_channel_offset(self, channel: int, offset: float) -> None:
-        r"""
-        Sets the voltage offset of the indicated channel.
-
-        *  Range: Dependent on the channel scale and coupling [V]
-        *  Increment: Minimum 0.001 [V], may be higher depending on the channel scale
-           and coupling
-        *  \*RST = 0
-
-        :param channel: is the channel number (1..4)
-        :param offset: Offset voltage. Positive values move the waveform down,
-            negative values move it up.
-        """
-
-        self.com.write(f"CHANnel{channel}:OFFSet {offset:3.3f}")
-
-    def get_channel_offset(self, channel: int) -> float:
-        r"""
-        Gets the voltage offset of the indicated channel.
-
-        :param channel: is the channel number (1..4)
-        :return: channel offset voltage in V (value between -1 and 1)
-        """
-
-        return float(self.com.query(f"CHANnel{channel}:OFFSet?"))
-
-    def set_trigger_source(self, channel: int, event_type: int = 1) -> None:
-        """
-        Set the trigger (Event A) source channel.
-
-        :param channel: is the channel number (1..4)
-        :param event_type: is the event type. 1: A-Event, 2: B-Event, 3: R-Event
-        """
-
-        self.com.write(f"TRIGger{event_type}:SOURce CHAN{channel}")
-
-    def set_trigger_level(
-        self, channel: int, level: float, event_type: int = 1
-    ) -> None:
-        r"""
-        Sets the trigger level for the specified event and source.
-
-        *  Range: -10 to 10 V
-        *  Increment: 1e-3 V
-        *  \*RST = 0 V
-
-        :param channel: indicates the trigger source.
-
-            *  1..4    = channel 1 to 4, available for all event types 1..3
-            *  5       = external trigger input on the rear panel for analog signals,
-               available for A-event type = 1
-            *  6..9    = not available
-
-        :param level: is the voltage for the trigger level in [V].
-        :param event_type: is the event type. 1: A-Event, 2: B-Event, 3: R-Event
-        """
-
-        self.com.write(f"TRIGger{event_type}:LEVel{channel} {level}")
-
-    def set_trigger_mode(self, mode: Union[str, TriggerModes]) -> None:
-        """
-        Sets the trigger mode which determines the behavior of the instrument if no
-        trigger occurs.
-
-        :param mode: is either auto, normal, or freerun.
-        :raises RTO1024Error: if an invalid triggermode is selected
-        """
-
-        if isinstance(mode, str):
-            try:
-                mode = self.TriggerModes[mode.upper()]  # type: ignore
-            except KeyError as e:
-                err_msg = (
-                    f'"{mode}" is not an allowed trigger mode out of '
-                    f"{self.TriggerModes.names()}."
-                )
-                logger.error(err_msg, exc_info=e)
-                raise RTO1024Error(err_msg)
-        assert isinstance(mode, self.TriggerModes)
-
-        self.com.write(f"TRIGger1:MODE {mode.name}")
-
-    def file_copy(self, source: str, destination: str) -> None:
-        """
-        Copy a file from one destination to another on the oscilloscope drive. If the
-        destination file already exists, it is overwritten without notice.
-
-        :param source: absolute path to the source file on the DSO filesystem
-        :param destination: absolute path to the destination file on the DSO filesystem
-        :raises RTO1024Error: if the operation did not complete
-        """
-
-        # clear status
-        self.com.write("*CLS")
-
-        # initiate file copy
-        self.com.write(f"MMEMory:COPY '{source}', '{destination}'", "*OPC")
-
-        # wait for OPC
-        done = self.wait_operation_complete(self.config.command_timeout_seconds)
-
-        if not done:
-            err_msg = "File copy not complete, timeout exceeded."
-            logger.error(err_msg)
-            raise RTO1024Error(err_msg)
-
-        logger.info(f'File copied: "{source}" to "{destination}"')
-
-    def backup_waveform(self, filename: str) -> None:
-        """
-        Backup a waveform file from the standard directory specified in the device
-        configuration to the standard backup destination specified in the device
-        configuration. The filename has to be specified without .bin or path.
-
-        :param filename: The waveform filename without extension and path
-        """
-        waveforms_file_path = str(PureWindowsPath(self.config.waveforms_path, filename))
-        backup_file_path = str(PureWindowsPath(self.config.backup_path, filename))
-
-        logger.info(f"Backing up {filename}.Wfm.bin")
-        self.file_copy(waveforms_file_path + ".Wfm.bin", backup_file_path + ".Wfm.bin")
-
-        logger.info(f"Backing up {filename}.bin")
-        self.file_copy(waveforms_file_path + ".bin", backup_file_path + ".bin")
-
-    def list_directory(self, path: str) -> List[Tuple[str, str, int]]:
-        """
-        List the contents of a given directory on the oscilloscope filesystem.
-
-        :param path: is the path to a folder
-        :return: a list of filenames in the given folder
-        """
-
-        file_string = self.com.query(f"MMEMory:CATalog? '{path}'")
-
-        # generate list of strings
-        file_list = re.findall('[^,^"]+,[A-Z]+,[0-9]+', file_string)
-
-        # delete . and .. entries
-        assert len(file_list) > 0 and file_list[0][:1] == ".", 'Expected "." folder'
-        assert len(file_list) > 1 and file_list[1][:2] == "..", 'Expected ".." folder'
-        file_list[0:2] = []
-
-        # split lines into lists [name, extension, size]
-        file_list = [line.split(",") for line in file_list]
-
-        return file_list
-
-    def save_waveform_history(
-        self, filename: str, channel: int, waveform: int = 1
-    ) -> None:
-        """
-        Save the history of one channel and one waveform to a .bin file. This
-        function is used after an acquisition using sequence trigger mode (with or
-        without ultra segmentation) was performed.
-
-        :param filename: is the name (without extension) of the file
-        :param channel: is the channel number
-        :param waveform: is the waveform number (typically 1)
-        :raises RTO1024Error: if storing waveform times out
-        """
-
-        # turn on fast export
-        self.com.write("EXPort:WAVeform:FASTexport ON")
-
-        # enable history
-        self.com.write("CHAN:HIST ON")
-        sleep(self.config.wait_sec_enable_history)
-
-        # turn off display
-        self.local_display(False)
-
-        # disable multichannel export
-        self.com.write("EXPort:WAVeform:MULTichannel OFF")
-
-        # select source channel and waveform
-        self.com.write(f"EXPort:WAVeform:SOURce C{channel}W{waveform}")
-
-        # set filename
-        abs_win_path = PureWindowsPath(self.config.waveforms_path, filename)
-        self.com.write(f"EXPort:WAVeform:NAME '{abs_win_path}.bin'")
-
-        # enable waveform logging
-        self.com.write("EXPort:WAVeform:DLOGging ON")
-
-        # clear status, to get *OPC working
-        self.com.write("*CLS")
-        sleep(self.config.wait_sec_short_pause)
-
-        # play waveform to start exporting
-        self.com.write("CHANnel:HISTory:PLAY", "*OPC")
-        is_done = self.wait_operation_complete(self.config.command_timeout_seconds)
-
-        # disable fast export
-        self.com.write("EXPort:WAVeform:FASTexport OFF")
-
-        # enable local display
-        self.local_display(True)
-
-        if not is_done:
-            logger.error("Storing waveform timed out.")
-            raise RTO1024Error("Storing waveform timed out.")
-
-        # check filelist
-        filenames: List[str] = [
-            file_info[0]
-            for file_info in self.list_directory(self.config.waveforms_path)
-        ]
-        if (filename + ".Wfm.bin") not in filenames or (
-            filename + ".bin"
-        ) not in filenames:
-            err_msg = f"Waveform {filename} could not be stored."
-            logger.error(err_msg)
-            raise RTO1024Error(err_msg)
-
-        logger.info(f"Waveform {filename} stored successfully.")
-
-    def run_continuous_acquisition(self) -> None:
-        """
-        Start acquiring continuously.
-        """
-
-        self.com.write("RUN")
-
-    def run_single_acquisition(self) -> None:
-        """
-        Start a single or Nx acquisition.
-        """
-
-        self.com.write("SINGle")
-
-    def stop_acquisition(self) -> None:
-        """
-        Stop any acquisition.
-        """
-
-        self.com.write("STOP")
-
-    def prepare_ultra_segmentation(self) -> None:
-        """
-        Make ready for a new acquisition in ultra segmentation mode. This function
-        does one acquisition without ultra segmentation to clear the history and
-        prepare for a new measurement.
-        """
-
-        # disable ultra segmentation
-        self.com.write("ACQuire:SEGMented:STATe OFF")
-
-        # go to AUTO trigger mode to let the scope running freely
-        self.set_trigger_mode("AUTO")
-
-        # pause a little bit
-        sleep(self.config.wait_sec_short_pause)
-
-        # start acquisition and wait for two seconds
-        self.run_continuous_acquisition()
-        sleep(self.config.wait_sec_post_acquisition_start)
-
-        # stop acquisition
-        self.stop_acquisition()
-
-        # set normal trigger mode
-        self.set_trigger_mode("NORMAL")
-
-        # enable ultra segmentation
-        self.com.write("ACQuire:SEGMented:STATe ON")
-
-        # set to maximum amount of acquisitions
-        self.com.write("ACQuire:SEGMented:MAX ON")
-
-        # final pause to secure the state
-        sleep(self.config.wait_sec_short_pause)
-
-    def save_configuration(self, filename: str) -> None:
-        r"""
-        Save the current oscilloscope settings to a file.
-        The filename has to be specified without path and '.dfl' extension, the file
-        will be saved to the configured settings directory.
-
-        **Information from the manual**
-        `SAVe` stores the current instrument settings under the
-        specified number in an intermediate memory. The settings can
-        be recalled using the command `\*RCL` with the associated
-        number. To transfer the stored instrument settings to a file,
-        use `MMEMory:STORe:STATe` .
-
-        :param filename: is the name of the settings file without path and extension
-        """
-
-        abs_win_path = PureWindowsPath(self.config.settings_path, filename)
-        self.com.write(f"MMEMory:SAV '{abs_win_path}.dfl'")
-
-    def load_configuration(self, filename: str) -> None:
-        r"""
-        Load current settings from a configuration file. The filename has to be
-        specified without base directory and '.dfl' extension.
-
-        **Information from the manual**
-        `ReCaLl` calls up the instrument settings from an intermediate
-        memory identified by the specified number. The instrument
-        settings can be stored to this memory using the command
-        `\*SAV` with the associated number. It also activates the
-        instrument settings which are stored in a file and loaded
-        using `MMEMory:LOAD:STATe` .
-
-        :param filename: is the name of the settings file without path and extension
-        """
-
-        abs_win_path = PureWindowsPath(self.config.settings_path, filename)
-        self.com.write(f"MMEMory:RCL '{abs_win_path}.dfl'")
-
-    def get_timestamps(self) -> List[float]:
-        """
-        Gets the timestamps of all recorded frames in the history and returns them as
-        a list of floats.
-
-        :return: list of timestamps in [s]
-        :raises RTO1024Error: if the timestamps are invalid
-        """
-
-        # disable local display (it is faster)
-        self.local_display(False)
-
-        # enable the history
-        self.com.write("CHANnel:WAVeform:HISTory:STATe 1")
-
-        # get the number of acquisitions
-        number_acquisitions = int(self.com.query("ACQuire:AVAilable?"))
-
-        # get the relative timestamp for each acquisition
-        timestamps_relative = []
-
-        # loop over all acquisitions. Note: Negative index up to 0!
-        for index in range(-number_acquisitions + 1, 1):
-            # switch to acquisition frame in history
-            self.com.write(f"CHANnel:WAVeform:HISTory:CURRent {index}")
-
-            # wait until frame is loaded
-            sleep(self.config.wait_sec_short_pause)
-
-            # store relative timestamp
-            timestamps_relative.append(
-                float(self.com.query("CHANnel:WAVeform:HISTory:TSRelative?"))
-            )
-
-            # wait until timestamp is stored
-            sleep(self.config.wait_sec_short_pause)
-
-        # re-enable local display
-        self.local_display(True)
-
-        # check validity of acquired timestamps. If they are read out too fast,
-        # there may be the same value two times in the list.
-        if len(set(timestamps_relative)) != len(timestamps_relative):
-            logger.error("Timestamps are not valid, there are doubled values.")
-            raise RTO1024Error("Timestamps are not valid, there are doubled values.")
-
-        logger.info("Timestamps successfully transferred.")
-        return timestamps_relative
-
-    def activate_measurements(
-        self,
-        meas_n: int,
-        source: str,
-        measurements: List[str],
-        category: str = "AMPTime",
-    ):
-        """
-        Activate the list of 'measurements' of the waveform 'source' in the
-        measurement box number 'meas_n'. The list 'measurements' starts with the main
-        measurement and continues with additional measurements of the same 'category'.
-
-        :param meas_n: measurement number 1..8
-        :param source: measurement source, for example C1W1
-        :param measurements: list of measurements, the first one will be the main
-            measurement.
-        :param category: the category of measurements, by default AMPTime
-        """
-
-        self.com.write(f"MEAS{meas_n}:ENAB ON")
-        self.com.write(f"MEAS{meas_n}:SOUR {source}")
-        self.com.write(f"MEAS{meas_n}:CAT {category}")
-        if measurements:
-            self.com.write(f"MEAS{meas_n}:MAIN {measurements.pop(0)}")
-        while measurements:
-            self.com.write(f"MEAS{meas_n}:ADD {measurements.pop(0)}, ON")
-
-    def read_measurement(self, meas_n: int, name: str) -> float:
-        """
-
-        :param meas_n: measurement number 1..8
-        :param name: measurement name, for example "MAX"
-        :return: measured value
-        """
-
-        return float(self.com.query(f"MEAS{meas_n}:RES? {name}"))
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Python module for the Rhode & Schwarz RTO 1024 oscilloscope.
+The communication to the device is through VISA, type TCPIP / INSTR.
+"""
+
+import logging
+import re
+from pathlib import PureWindowsPath
+from time import sleep
+from typing import List, Tuple, Union
+
+from hvl_ccb.dev.base import DeviceException
+from .visa import (
+    VisaDevice,
+    VisaDeviceConfig,
+    _VisaDeviceConfigBase,
+    _VisaDeviceConfigDefaultsBase,
+)
+from ..comm.visa import VisaCommunication, VisaCommunicationConfig
+from ..configuration import configdataclass
+from ..utils.enum import AutoNumberNameEnum
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class RTO1024Error(DeviceException):
+    pass
+
+
+@configdataclass
+class _RTO1024ConfigBase(_VisaDeviceConfigBase):
+
+    waveforms_path: str
+    """
+    Windows directory on the oscilloscope filesystem for storing waveforms.
+    Mind escaping the backslashes of the path.
+    """
+
+    settings_path: str
+    """
+    Windows directory on the oscilloscope filesystem for storing settings .dfl files.
+    Mind escaping the backslashes of the path.
+    """
+
+    backup_path: str
+    """
+    Windows directory on the oscilloscope filesystem for use as backup directory for
+    waveforms. Mind escaping the backslashes of the path.
+    """
+
+
+@configdataclass
+class _RTO1024ConfigDefaultsBase(_VisaDeviceConfigDefaultsBase):
+
+    command_timeout_seconds: Number = 60
+    """
+    Timeout to wait for asynchronous commands to complete, in seconds. This timeout
+    is respected for long operations such as storing waveforms.
+    """
+    wait_sec_short_pause: Number = 0.1
+    """Time for short wait periods, in seconds (depends on both device and
+    network/connection)."""
+    wait_sec_enable_history: Number = 1
+    """Time to wait after enabling history, in seconds."""
+    wait_sec_post_acquisition_start: Number = 2
+    """Time to wait after start of continuous acquisition, in seconds."""
+
+    def clean_values(self):
+        super().clean_values()
+
+        if self.command_timeout_seconds <= 0:
+            raise ValueError(
+                "Timeout to wait for asynchronous commands to complete must be a "
+                "positive value (in seconds)."
+            )
+        if self.wait_sec_short_pause <= 0:
+            raise ValueError(
+                "Wait time for a short pause must be a positive value (in seconds)."
+            )
+        if self.wait_sec_enable_history <= 0:
+            raise ValueError(
+                "Wait time for enabling history must be a positive value (in seconds)."
+            )
+        if self.wait_sec_post_acquisition_start <= 0:
+            raise ValueError(
+                "Wait time after acquisition start must be a positive value (in "
+                "seconds)."
+            )
+
+
+@configdataclass
+class RTO1024Config(VisaDeviceConfig, _RTO1024ConfigDefaultsBase, _RTO1024ConfigBase):
+    """
+    Configdataclass for the RTO1024 device.
+    """
+
+    pass
+
+
+@configdataclass
+class RTO1024VisaCommunicationConfig(VisaCommunicationConfig):
+    """
+    Configuration dataclass for VisaCommunication with specifications for the RTO1024
+    device class.
+    """
+
+    interface_type: Union[
+        str, VisaCommunicationConfig.InterfaceType
+    ] = VisaCommunicationConfig.InterfaceType.TCPIP_INSTR  # type: ignore
+
+
+class RTO1024VisaCommunication(VisaCommunication):
+    """
+    Specialization of VisaCommunication for the RTO1024 oscilloscope
+    """
+
+    @staticmethod
+    def config_cls():
+        return RTO1024VisaCommunicationConfig
+
+
+class RTO1024(VisaDevice):
+    """
+    Device class for the Rhode & Schwarz RTO 1024 oscilloscope.
+    """
+
+    class TriggerModes(AutoNumberNameEnum):
+        """
+        Enumeration for the three available trigger modes.
+        """
+
+        AUTO = ()
+        NORMAL = ()
+        FREERUN = ()
+
+        @classmethod
+        def names(cls):
+            """
+            Returns a list of the available trigger modes.
+            :return: list of strings
+            """
+
+            return list(map(lambda x: x.name, cls))
+
+    @staticmethod
+    def config_cls():
+        return RTO1024Config
+
+    @staticmethod
+    def default_com_cls():
+        return RTO1024VisaCommunication
+
+    def __init__(
+        self,
+        com: Union[RTO1024VisaCommunication, RTO1024VisaCommunicationConfig, dict],
+        dev_config: Union[RTO1024Config, dict],
+    ):
+        super().__init__(com, dev_config)
+
+    def start(self) -> None:
+        """
+        Start the RTO1024 oscilloscope and bring it into a defined state and remote
+        mode.
+        """
+
+        super().start()
+
+        # go to remote mode
+        self.com.write("&GTR")
+
+        # reset device (RST) and clear status registers (CLS)
+        self.com.write("*RST", "*CLS")
+
+        # enable local display
+        self.local_display(True)
+
+        # enable status register
+        self.com.write("*ESE 127")
+
+    def stop(self) -> None:
+        """
+        Stop the RTO1024 oscilloscope, reset events and close communication. Brings
+        back the device to a state where local operation is possible.
+        """
+
+        if self._spoll_thread is not None and self._spoll_thread.is_polling():
+            # disable any events, EventStatusEnable ESE = 0
+            self.com.write("*ESE 0")
+
+            # disable any service requests SRE = 0
+            self.com.write("*SRE 0")
+
+            # device clear: abort processing of any commands
+            self.com.write("&DCL")
+
+            # go to local mode
+            self.com.write("&GTL")
+        else:
+            logger.warning("RTO1024 was already stopped")
+
+        super().stop()
+
+    def local_display(self, state: bool) -> None:
+        """
+        Enable or disable local display of the scope.
+
+        :param state: is the desired local display state
+        """
+        state_str = "ON" if state else "OFF"
+        self.com.write(f"SYST:DISP:UPD {state_str}")
+
+    def set_acquire_length(self, timerange: float) -> None:
+        r"""
+        Defines the time of one acquisition, that is the time across the 10 divisions
+        of the diagram.
+
+        *  Range: 250E-12 ... 500 [s]
+        *  Increment: 1E-12 [s]
+        *  \*RST = 0.5 [s]
+
+        :param timerange: is the time for one acquisition. Range: 250e-12 ... 500 [s]
+        """
+
+        self.com.write(f"TIMebase:RANGe {timerange:G}")
+
+    def get_acquire_length(self) -> float:
+        r"""
+        Gets the time of one acquisition, that is the time across the 10 divisions
+        of the diagram.
+
+        *  Range: 250E-12 ... 500 [s]
+        *  Increment: 1E-12 [s]
+
+        :return: the time for one acquisition. Range: 250e-12 ... 500 [s]
+        """
+
+        return float(self.com.query("TIMebase:RANGe?"))
+
+    def set_reference_point(self, percentage: int) -> None:
+        r"""
+        Sets the reference point of the time scale in % of the display.
+        If the "Trigger offset" is zero, the trigger point matches the reference point.
+        ReferencePoint = zero pint of the time scale
+
+        *  Range: 0 ... 100 [%]
+        *  Increment: 1 [%]
+        *  \*RST = 50 [%]
+
+        :param percentage: is the reference in %
+        """
+
+        self.com.write(f"TIMebase:REFerence {percentage:d}")
+
+    def get_reference_point(self) -> int:
+        r"""
+        Gets the reference point of the time scale in % of the display.
+        If the "Trigger offset" is zero, the trigger point matches the reference point.
+        ReferencePoint = zero pint of the time scale
+
+        *  Range: 0 ... 100 [%]
+        *  Increment: 1 [%]
+
+        :return: the reference in %
+        """
+
+        return int(self.com.query("TIMebase:REFerence?"))
+
+    def set_repetitions(self, number: int) -> None:
+        r"""
+        Set the number of acquired waveforms with RUN Nx SINGLE. Also defines the
+        number of waveforms used to calculate the average waveform.
+
+        *  Range: 1 ... 16777215
+        *  Increment: 10
+        *  \*RST = 1
+
+        :param number: is the number of waveforms to acquire
+        """
+
+        self.com.write(f"ACQuire:COUNt {number:d}")
+
+    def get_repetitions(self) -> int:
+        r"""
+        Get the number of acquired waveforms with RUN Nx SINGLE. Also defines the
+        number of waveforms used to calculate the average waveform.
+
+        *  Range: 1 ... 16777215
+        *  Increment: 10
+        *  \*RST = 1
+
+        :return: the number of waveforms to acquire
+        """
+
+        return int(self.com.query("ACQuire:COUNt?"))
+
+    def set_channel_state(self, channel: int, state: bool) -> None:
+        """
+        Switches the channel signal on or off.
+
+        :param channel: is the input channel (1..4)
+        :param state: is True for on, False for off
+        """
+
+        self.com.write(f"CHANnel{channel}:STATe {'ON' if state else 'OFF'}")
+
+    def get_channel_state(self, channel: int) -> bool:
+        """
+        Queries if the channel is active or not.
+
+        :param channel: is the input channel (1..4)
+        :return: True if active, else False
+        """
+
+        return self.com.query(f"CHANnel{channel}:STATe?") == "1"
+
+    def set_channel_scale(self, channel: int, scale: float) -> None:
+        r"""
+        Sets the vertical scale for the indicated channel.
+        The scale value is given in volts per division.
+
+        *   Range for scale: depends on attenuation factor and coupling. With
+            1:1 probe and external attenuations and 50 Ω input
+            coupling, the vertical scale (input sensitivity) is 1
+            mV/div to 1 V/div. For 1 MΩ input coupling, it is 1
+            mV/div to 10 V/div. If the probe and/or external
+            attenuation is changed, multiply the values by the
+            attenuation factors to get the actual scale range.
+
+        *  Increment: 1e-3
+        *  \*RST = 0.05
+
+        See also:
+        set_channel_range
+
+        :param channel: is the channel number (1..4)
+        :param scale: is the vertical scaling [V/div]
+        """
+
+        self.com.write(f"CHANnel{channel}:SCALe {scale:4.3f}")
+
+    def get_channel_scale(self, channel: int) -> float:
+        """
+        Queries the channel scale in V/div.
+
+        :param channel: is the input channel (1..4)
+        :return: channel scale in V/div
+        """
+
+        return float(self.com.query(f"CHANnel{channel}:SCALe?"))
+
+    def set_channel_range(self, channel: int, v_range: float) -> None:
+        r"""
+        Sets the voltage range across the 10 vertical divisions of the diagram. Use
+        the command alternatively instead of set_channel_scale.
+
+        *   Range for range: Depends on attenuation factors and coupling. With
+            1:1 probe and external attenuations and 50 Ω input
+            coupling, the range is 10 mV to 10 V. For 1 MΩ
+            input coupling, it is 10 mV to 100 V. If the probe
+            and/or external attenuation is changed, multiply the
+            range values by the attenuation factors.
+
+        *  Increment: 0.01
+        *  \*RST = 0.5
+
+        :param channel: is the channel number (1..4)
+        :param v_range: is the vertical range [V]
+        """
+
+        self.com.write(f"CHANnel{channel}:RANGe {v_range:4.3f}")
+
+    def get_channel_range(self, channel: int) -> float:
+        """
+        Queries the channel range in V.
+
+        :param channel: is the input channel (1..4)
+        :return: channel range in V
+        """
+
+        return float(self.com.query(f"CHANnel{channel}:RANGe?"))
+
+    def set_channel_position(self, channel: int, position: float) -> None:
+        r"""
+        Sets the vertical position of the indicated channel as a graphical value.
+
+        *  Range: -5.0 ... 5.0 [div]
+        *  Increment: 0.02
+        *  \*RST = 0
+
+        :param channel: is the channel number (1..4)
+        :param position: is the position. Positive values move the waveform up,
+            negative values move it down.
+        """
+
+        self.com.write(f"CHANnel{channel}:POSition {position:3.2f}")
+
+    def get_channel_position(self, channel: int) -> float:
+        r"""
+        Gets the vertical position of the indicated channel.
+
+        :param channel: is the channel number (1..4)
+        :return: channel position in div (value between -5 and 5)
+        """
+
+        return float(self.com.query(f"CHANnel{channel}:POSition?"))
+
+    def set_channel_offset(self, channel: int, offset: float) -> None:
+        r"""
+        Sets the voltage offset of the indicated channel.
+
+        *  Range: Dependent on the channel scale and coupling [V]
+        *  Increment: Minimum 0.001 [V], may be higher depending on the channel scale
+           and coupling
+        *  \*RST = 0
+
+        :param channel: is the channel number (1..4)
+        :param offset: Offset voltage. Positive values move the waveform down,
+            negative values move it up.
+        """
+
+        self.com.write(f"CHANnel{channel}:OFFSet {offset:3.3f}")
+
+    def get_channel_offset(self, channel: int) -> float:
+        r"""
+        Gets the voltage offset of the indicated channel.
+
+        :param channel: is the channel number (1..4)
+        :return: channel offset voltage in V (value between -1 and 1)
+        """
+
+        return float(self.com.query(f"CHANnel{channel}:OFFSet?"))
+
+    def set_trigger_source(self, channel: int, event_type: int = 1) -> None:
+        """
+        Set the trigger (Event A) source channel.
+
+        :param channel: is the channel number (1..4)
+        :param event_type: is the event type. 1: A-Event, 2: B-Event, 3: R-Event
+        """
+
+        self.com.write(f"TRIGger{event_type}:SOURce CHAN{channel}")
+
+    def set_trigger_level(
+        self, channel: int, level: float, event_type: int = 1
+    ) -> None:
+        r"""
+        Sets the trigger level for the specified event and source.
+
+        *  Range: -10 to 10 V
+        *  Increment: 1e-3 V
+        *  \*RST = 0 V
+
+        :param channel: indicates the trigger source.
+
+            *  1..4    = channel 1 to 4, available for all event types 1..3
+            *  5       = external trigger input on the rear panel for analog signals,
+               available for A-event type = 1
+            *  6..9    = not available
+
+        :param level: is the voltage for the trigger level in [V].
+        :param event_type: is the event type. 1: A-Event, 2: B-Event, 3: R-Event
+        """
+
+        self.com.write(f"TRIGger{event_type}:LEVel{channel} {level}")
+
+    def set_trigger_mode(self, mode: Union[str, TriggerModes]) -> None:
+        """
+        Sets the trigger mode which determines the behavior of the instrument if no
+        trigger occurs.
+
+        :param mode: is either auto, normal, or freerun.
+        :raises RTO1024Error: if an invalid triggermode is selected
+        """
+
+        if isinstance(mode, str):
+            try:
+                mode = self.TriggerModes[mode.upper()]  # type: ignore
+            except KeyError as e:
+                err_msg = (
+                    f'"{mode}" is not an allowed trigger mode out of '
+                    f"{self.TriggerModes.names()}."
+                )
+                logger.error(err_msg, exc_info=e)
+                raise RTO1024Error(err_msg)
+        assert isinstance(mode, self.TriggerModes)
+
+        self.com.write(f"TRIGger1:MODE {mode.name}")
+
+    def file_copy(self, source: str, destination: str) -> None:
+        """
+        Copy a file from one destination to another on the oscilloscope drive. If the
+        destination file already exists, it is overwritten without notice.
+
+        :param source: absolute path to the source file on the DSO filesystem
+        :param destination: absolute path to the destination file on the DSO filesystem
+        :raises RTO1024Error: if the operation did not complete
+        """
+
+        # clear status
+        self.com.write("*CLS")
+
+        # initiate file copy
+        self.com.write(f"MMEMory:COPY '{source}', '{destination}'", "*OPC")
+
+        # wait for OPC
+        done = self.wait_operation_complete(self.config.command_timeout_seconds)
+
+        if not done:
+            err_msg = "File copy not complete, timeout exceeded."
+            logger.error(err_msg)
+            raise RTO1024Error(err_msg)
+
+        logger.info(f'File copied: "{source}" to "{destination}"')
+
+    def backup_waveform(self, filename: str) -> None:
+        """
+        Backup a waveform file from the standard directory specified in the device
+        configuration to the standard backup destination specified in the device
+        configuration. The filename has to be specified without .bin or path.
+
+        :param filename: The waveform filename without extension and path
+        """
+        waveforms_file_path = str(PureWindowsPath(self.config.waveforms_path, filename))
+        backup_file_path = str(PureWindowsPath(self.config.backup_path, filename))
+
+        logger.info(f"Backing up {filename}.Wfm.bin")
+        self.file_copy(waveforms_file_path + ".Wfm.bin", backup_file_path + ".Wfm.bin")
+
+        logger.info(f"Backing up {filename}.bin")
+        self.file_copy(waveforms_file_path + ".bin", backup_file_path + ".bin")
+
+    def list_directory(self, path: str) -> List[Tuple[str, str, int]]:
+        """
+        List the contents of a given directory on the oscilloscope filesystem.
+
+        :param path: is the path to a folder
+        :return: a list of filenames in the given folder
+        """
+
+        file_string = self.com.query(f"MMEMory:CATalog? '{path}'")
+
+        # generate list of strings
+        file_list = re.findall('[^,^"]+,[A-Z]+,[0-9]+', file_string)
+
+        # delete . and .. entries
+        assert len(file_list) > 0 and file_list[0][:1] == ".", 'Expected "." folder'
+        assert len(file_list) > 1 and file_list[1][:2] == "..", 'Expected ".." folder'
+        file_list[0:2] = []
+
+        # split lines into lists [name, extension, size]
+        file_list = [line.split(",") for line in file_list]
+
+        return file_list
+
+    def save_waveform_history(
+        self, filename: str, channel: int, waveform: int = 1
+    ) -> None:
+        """
+        Save the history of one channel and one waveform to a .bin file. This
+        function is used after an acquisition using sequence trigger mode (with or
+        without ultra segmentation) was performed.
+
+        :param filename: is the name (without extension) of the file
+        :param channel: is the channel number
+        :param waveform: is the waveform number (typically 1)
+        :raises RTO1024Error: if storing waveform times out
+        """
+
+        # turn on fast export
+        self.com.write("EXPort:WAVeform:FASTexport ON")
+
+        # enable history
+        self.com.write("CHAN:HIST ON")
+        sleep(self.config.wait_sec_enable_history)
+
+        # turn off display
+        self.local_display(False)
+
+        # disable multichannel export
+        self.com.write("EXPort:WAVeform:MULTichannel OFF")
+
+        # select source channel and waveform
+        self.com.write(f"EXPort:WAVeform:SOURce C{channel}W{waveform}")
+
+        # set filename
+        abs_win_path = PureWindowsPath(self.config.waveforms_path, filename)
+        self.com.write(f"EXPort:WAVeform:NAME '{abs_win_path}.bin'")
+
+        # enable waveform logging
+        self.com.write("EXPort:WAVeform:DLOGging ON")
+
+        # clear status, to get *OPC working
+        self.com.write("*CLS")
+        sleep(self.config.wait_sec_short_pause)
+
+        # play waveform to start exporting
+        self.com.write("CHANnel:HISTory:PLAY", "*OPC")
+        is_done = self.wait_operation_complete(self.config.command_timeout_seconds)
+
+        # disable fast export
+        self.com.write("EXPort:WAVeform:FASTexport OFF")
+
+        # enable local display
+        self.local_display(True)
+
+        if not is_done:
+            logger.error("Storing waveform timed out.")
+            raise RTO1024Error("Storing waveform timed out.")
+
+        # check filelist
+        filenames: List[str] = [
+            file_info[0]
+            for file_info in self.list_directory(self.config.waveforms_path)
+        ]
+        if (filename + ".Wfm.bin") not in filenames or (
+            filename + ".bin"
+        ) not in filenames:
+            err_msg = f"Waveform {filename} could not be stored."
+            logger.error(err_msg)
+            raise RTO1024Error(err_msg)
+
+        logger.info(f"Waveform {filename} stored successfully.")
+
+    def run_continuous_acquisition(self) -> None:
+        """
+        Start acquiring continuously.
+        """
+
+        self.com.write("RUN")
+
+    def run_single_acquisition(self) -> None:
+        """
+        Start a single or Nx acquisition.
+        """
+
+        self.com.write("SINGle")
+
+    def stop_acquisition(self) -> None:
+        """
+        Stop any acquisition.
+        """
+
+        self.com.write("STOP")
+
+    def prepare_ultra_segmentation(self) -> None:
+        """
+        Make ready for a new acquisition in ultra segmentation mode. This function
+        does one acquisition without ultra segmentation to clear the history and
+        prepare for a new measurement.
+        """
+
+        # disable ultra segmentation
+        self.com.write("ACQuire:SEGMented:STATe OFF")
+
+        # go to AUTO trigger mode to let the scope running freely
+        self.set_trigger_mode("AUTO")
+
+        # pause a little bit
+        sleep(self.config.wait_sec_short_pause)
+
+        # start acquisition and wait for two seconds
+        self.run_continuous_acquisition()
+        sleep(self.config.wait_sec_post_acquisition_start)
+
+        # stop acquisition
+        self.stop_acquisition()
+
+        # set normal trigger mode
+        self.set_trigger_mode("NORMAL")
+
+        # enable ultra segmentation
+        self.com.write("ACQuire:SEGMented:STATe ON")
+
+        # set to maximum amount of acquisitions
+        self.com.write("ACQuire:SEGMented:MAX ON")
+
+        # final pause to secure the state
+        sleep(self.config.wait_sec_short_pause)
+
+    def save_configuration(self, filename: str) -> None:
+        r"""
+        Save the current oscilloscope settings to a file.
+        The filename has to be specified without path and '.dfl' extension, the file
+        will be saved to the configured settings directory.
+
+        **Information from the manual**
+        `SAVe` stores the current instrument settings under the
+        specified number in an intermediate memory. The settings can
+        be recalled using the command `\*RCL` with the associated
+        number. To transfer the stored instrument settings to a file,
+        use `MMEMory:STORe:STATe` .
+
+        :param filename: is the name of the settings file without path and extension
+        """
+
+        abs_win_path = PureWindowsPath(self.config.settings_path, filename)
+        self.com.write(f"MMEMory:SAV '{abs_win_path}.dfl'")
+
+    def load_configuration(self, filename: str) -> None:
+        r"""
+        Load current settings from a configuration file. The filename has to be
+        specified without base directory and '.dfl' extension.
+
+        **Information from the manual**
+        `ReCaLl` calls up the instrument settings from an intermediate
+        memory identified by the specified number. The instrument
+        settings can be stored to this memory using the command
+        `\*SAV` with the associated number. It also activates the
+        instrument settings which are stored in a file and loaded
+        using `MMEMory:LOAD:STATe` .
+
+        :param filename: is the name of the settings file without path and extension
+        """
+
+        abs_win_path = PureWindowsPath(self.config.settings_path, filename)
+        self.com.write(f"MMEMory:RCL '{abs_win_path}.dfl'")
+
+    def get_timestamps(self) -> List[float]:
+        """
+        Gets the timestamps of all recorded frames in the history and returns them as
+        a list of floats.
+
+        :return: list of timestamps in [s]
+        :raises RTO1024Error: if the timestamps are invalid
+        """
+
+        # disable local display (it is faster)
+        self.local_display(False)
+
+        # enable the history
+        self.com.write("CHANnel:WAVeform:HISTory:STATe 1")
+
+        # get the number of acquisitions
+        number_acquisitions = int(self.com.query("ACQuire:AVAilable?"))
+
+        # get the relative timestamp for each acquisition
+        timestamps_relative = []
+
+        # loop over all acquisitions. Note: Negative index up to 0!
+        for index in range(-number_acquisitions + 1, 1):
+            # switch to acquisition frame in history
+            self.com.write(f"CHANnel:WAVeform:HISTory:CURRent {index}")
+
+            # wait until frame is loaded
+            sleep(self.config.wait_sec_short_pause)
+
+            # store relative timestamp
+            timestamps_relative.append(
+                float(self.com.query("CHANnel:WAVeform:HISTory:TSRelative?"))
+            )
+
+            # wait until timestamp is stored
+            sleep(self.config.wait_sec_short_pause)
+
+        # re-enable local display
+        self.local_display(True)
+
+        # check validity of acquired timestamps. If they are read out too fast,
+        # there may be the same value two times in the list.
+        if len(set(timestamps_relative)) != len(timestamps_relative):
+            logger.error("Timestamps are not valid, there are doubled values.")
+            raise RTO1024Error("Timestamps are not valid, there are doubled values.")
+
+        logger.info("Timestamps successfully transferred.")
+        return timestamps_relative
+
+    def activate_measurements(
+        self,
+        meas_n: int,
+        source: str,
+        measurements: List[str],
+        category: str = "AMPTime",
+    ):
+        """
+        Activate the list of 'measurements' of the waveform 'source' in the
+        measurement box number 'meas_n'. The list 'measurements' starts with the main
+        measurement and continues with additional measurements of the same 'category'.
+
+        :param meas_n: measurement number 1..8
+        :param source: measurement source, for example C1W1
+        :param measurements: list of measurements, the first one will be the main
+            measurement.
+        :param category: the category of measurements, by default AMPTime
+        """
+
+        self.com.write(f"MEAS{meas_n}:ENAB ON")
+        self.com.write(f"MEAS{meas_n}:SOUR {source}")
+        self.com.write(f"MEAS{meas_n}:CAT {category}")
+        if measurements:
+            self.com.write(f"MEAS{meas_n}:MAIN {measurements.pop(0)}")
+        while measurements:
+            self.com.write(f"MEAS{meas_n}:ADD {measurements.pop(0)}, ON")
+
+    def read_measurement(self, meas_n: int, name: str) -> float:
+        """
+
+        :param meas_n: measurement number 1..8
+        :param name: measurement name, for example "MAX"
+        :return: measured value
+        """
+
+        return float(self.com.query(f"MEAS{meas_n}:RES? {name}"))
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/se_ils2t.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/se_ils2t.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,975 +1,974 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device class for controlling a Schneider Electric ILS2T stepper drive over modbus TCP.
-"""
-
-import logging
-from datetime import timedelta
-from enum import Flag, IntEnum
-from numbers import Integral
-from time import sleep, time
-from typing import Dict, List, Any, cast, Optional
-
-import aenum
-from bitstring import BitArray
-from pymodbus.constants import Endian
-from pymodbus.payload import BinaryPayloadDecoder, BinaryPayloadBuilder
-
-from .base import SingleCommDevice
-from ..comm import (
-    ModbusTcpCommunication,
-    ModbusTcpConnectionFailedException,
-    ModbusTcpCommunicationConfig,
-)
-from ..configuration import configdataclass
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class ILS2TException(Exception):
-    """
-    Exception to indicate problems with the SE ILS2T stepper motor.
-    """
-
-    pass
-
-
-class IoScanningModeValueError(ILS2TException):
-    """
-    Exception to indicate that the selected IO scanning mode is invalid.
-    """
-
-    pass
-
-
-class ScalingFactorValueError(ILS2TException):
-    """
-    Exception to indicate that a scaling factor value is invalid.
-    """
-
-    pass
-
-
-@configdataclass
-class ILS2TModbusTcpCommunicationConfig(ModbusTcpCommunicationConfig):
-    """
-    Configuration dataclass for Modbus/TCP communciation specific for the Schneider
-    Electric ILS2T stepper motor.
-    """
-
-    #: The unit has to be 255 such that IO scanning mode works.
-    unit: int = 255
-
-
-class ILS2TModbusTcpCommunication(ModbusTcpCommunication):
-    """
-    Specific implementation of Modbus/TCP for the Schneider Electric ILS2T stepper
-    motor.
-    """
-
-    @staticmethod
-    def config_cls():
-        return ILS2TModbusTcpCommunicationConfig
-
-
-@configdataclass
-class ILS2TConfig:
-    """
-    Configuration for the ILS2T stepper motor device.
-    """
-
-    #: initial maximum RPM for the motor, can be set up to 3000 RPM. The user is
-    #: allowed to set a new max RPM at runtime using :meth:`ILS2T.set_max_rpm`,
-    #: but the value must never exceed this configuration setting.
-    rpm_max_init: Integral = cast(Integral, 1500)
-    wait_sec_post_enable: Number = 1
-    wait_sec_max_disable: Number = 10
-    wait_sec_post_cannot_disable: Number = 1
-    wait_sec_post_relative_step: Number = 2
-    wait_sec_post_absolute_position: Number = 2
-
-    def clean_values(self):
-        if not 0 < self.rpm_max_init <= 3000:
-            raise ValueError(
-                "Maximum RPM for the motor must be integer number between 1 and 3000."
-            )
-        if self.wait_sec_post_enable <= 0:
-            raise ValueError(
-                "Wait time post motor enabling must be a positive value (in seconds)."
-            )
-        if self.wait_sec_max_disable < 0:
-            raise ValueError(
-                "Maximal wait time for attempting to disable motor must be a "
-                "non-negative value (in seconds)."
-            )
-        if self.wait_sec_post_cannot_disable <= 0:
-            raise ValueError(
-                "Wait time post failed motor disable attempt must be a positive value "
-                "(in seconds)."
-            )
-        if self.wait_sec_post_relative_step <= 0:
-            raise ValueError(
-                "Wait time post motor relative step must be a positive value "
-                "(in seconds)."
-            )
-        if self.wait_sec_post_absolute_position <= 0:
-            raise ValueError(
-                "Wait time post motor absolute position change must be a positive "
-                "value (in seconds)."
-            )
-
-
-class ILS2TRegDatatype(aenum.Enum):
-    """
-    Modbus Register Datatypes for Schneider Electric ILS2T stepper drive.
-
-    From the manual of the drive:
-
-    =========== =========== ============== =============
-    datatype    byte        min            max
-    =========== =========== ============== =============
-    INT8        1 Byte      -128           127
-    UINT8       1 Byte      0              255
-    INT16       2 Byte      -32_768        32_767
-    UINT16      2 Byte      0              65_535
-    INT32       4 Byte      -2_147_483_648 2_147_483_647
-    UINT32      4 Byte      0              4_294_967_295
-    BITS        just 32bits N/A            N/A
-    =========== =========== ============== =============
-
-    """
-
-    _init_ = "min max"
-    INT32 = -2_147_483_648, 2_147_483_647
-
-    def is_in_range(self, value: int) -> bool:
-        return self.min <= value <= self.max
-
-
-class ILS2TRegAddr(IntEnum):
-    """
-    Modbus Register Adresses for for Schneider Electric ILS2T stepper drive.
-    """
-
-    POSITION = 7706  # INT32 position of the motor in user defined units
-    IO_SCANNING = 6922  # BITS start register for IO scanning control
-    # and status
-    TEMP = 7200  # INT16 temperature of motor
-    VOLT = 7198  # UINT16 dc voltage of motor
-    SCALE = 1550  # INT32 user defined steps per revolution
-    ACCESS_ENABLE = 282  # BITS not documented register
-    # to enable access via IO scanning
-    JOGN_FAST = 10506  # UINT16 revolutions per minute for fast Jog (1 to 3000)
-    JOGN_SLOW = 10504  # UINT16 revolutions per minute
-    # for slow Jog (1 to 3000)
-
-    RAMP_TYPE = 1574  # INT16 ramp type, 0: linear / -1: motor optimized
-    RAMP_ACC = 1556  # UINT32 acceleration
-    RAMP_DECEL = 1558  # UINT32 deceleration
-    RAMP_N_MAX = 1554  # UINT16 max rpm
-    FLT_INFO = 15362  # 22 registers, code for error
-    FLT_MEM_RESET = 15114  # UINT16 reset fault memory
-    FLT_MEM_DEL = 15112  # UINT16 delete fault memory
-
-
-class ILS2T(SingleCommDevice):
-    """
-    Schneider Electric ILS2T stepper drive class.
-    """
-
-    RegDatatype = ILS2TRegDatatype
-    """Modbus Register Datatypes
-    """
-    RegAddr = ILS2TRegAddr
-    """Modbus Register Adresses
-    """
-
-    class Mode(IntEnum):
-        """
-        ILS2T device modes
-        """
-
-        PTP = 3  # point to point
-        JOG = 1
-
-    class ActionsPtp(IntEnum):
-        """
-        Allowed actions in the point to point mode (`ILS2T.Mode.PTP`).
-        """
-
-        ABSOLUTE_POSITION = 0
-        RELATIVE_POSITION_TARGET = 1
-        RELATIVE_POSITION_MOTOR = 2
-
-    ACTION_JOG_VALUE = 0
-    """
-    The single action value for `ILS2T.Mode.JOG`
-    """
-
-    # Note: don't use IntFlag here - it allows other then enumerated values
-    class Ref16Jog(Flag):
-        """
-        Allowed values for ILS2T ref_16 register (the shown values are the integer
-        representation of the bits), all in Jog mode = 1
-        """
-
-        NONE = 0
-        POS = 1
-        NEG = 2
-        FAST = 4
-        # allowed combinations
-        POS_FAST = POS | FAST
-        NEG_FAST = NEG | FAST
-
-    class State(IntEnum):
-        """
-        State machine status values
-        """
-
-        QUICKSTOP = 7
-        READY = 4
-        ON = 6
-
-    DEFAULT_IO_SCANNING_CONTROL_VALUES = {
-        "action": ActionsPtp.RELATIVE_POSITION_MOTOR.value,
-        "mode": Mode.PTP.value,
-        "disable_driver_di": 0,
-        "enable_driver_en": 0,
-        "quick_stop_qs": 0,
-        "fault_reset_fr": 0,
-        "execute_stop_sh": 0,
-        "reset_stop_ch": 0,
-        "continue_after_stop_cu": 0,
-        "ref_16": ILS2TConfig.rpm_max_init,
-        "ref_32": 0,
-    }
-    """
-    Default IO Scanning control mode values
-    """
-
-    def __init__(self, com, dev_config=None) -> None:
-        """
-        Constructor for ILS2T.
-
-        :param com: object to use as communication protocol.
-        """
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        # toggle reminder bit
-        self._mode_toggle_mt = 0
-
-        self.flt_list: List[Dict[int, Dict[str, Any]]] = []
-
-    @staticmethod
-    def default_com_cls():
-        return ILS2TModbusTcpCommunication
-
-    @staticmethod
-    def config_cls():
-        return ILS2TConfig
-
-    def start(self) -> None:
-        """
-        Start this device.
-        """
-
-        logger.info("Starting device " + str(self))
-        try:
-            # try opening the port
-            super().start()
-        except ModbusTcpConnectionFailedException as exc:
-            logger.error(str(exc), exc_info=exc)
-            raise
-
-        # writing 1 to register ACCESS_ENABLE allows to use the IO scanning mode.
-        #  This is not documented in the manual!
-        self.com.write_registers(self.RegAddr.ACCESS_ENABLE.value, [0, 1])
-
-        # set maximum RPM from init config
-        self.set_max_rpm(self.config.rpm_max_init)
-
-    def stop(self) -> None:
-        """
-        Stop this device. Disables the motor (applies brake), disables access and
-        closes the communication protocol.
-        """
-
-        logger.info("Stopping device " + str(self))
-        self.disable()
-        self.com.write_registers(self.RegAddr.ACCESS_ENABLE.value, [0, 0])
-        super().stop()
-
-    def get_status(self) -> Dict[str, int]:
-        """
-        Perform an IO Scanning read and return the status of the motor.
-
-        :return: dict with status information.
-        """
-
-        registers = self.com.read_holding_registers(self.RegAddr.IO_SCANNING.value, 8)
-        return self._decode_status_registers(registers)
-
-    def do_ioscanning_write(self, **kwargs: int) -> None:
-        """
-        Perform a write operation using IO Scanning mode.
-
-        :param kwargs:
-            Keyword-argument list with options to send, remaining are taken
-            from the defaults.
-        """
-
-        self._toggle()
-        values = self._generate_control_registers(**kwargs)
-        self.com.write_registers(self.RegAddr.IO_SCANNING.value, values)
-
-    def _generate_control_registers(self, **kwargs: int) -> List[int]:
-        """
-        Generates the control registers for the IO scanning mode.
-        It is necessary to write all 64 bit at the same time, so a list of 4 registers
-        is generated.
-
-        :param kwargs: Keyword-argument list with options different than the defaults.
-        :return: List of registers for the IO scanning mode.
-        """
-
-        cleaned_io_scanning_mode = self._clean_ioscanning_mode_values(kwargs)
-
-        action_bits = f"{cleaned_io_scanning_mode['action']:03b}"
-        mode_bits = f"{cleaned_io_scanning_mode['mode']:04b}"
-        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
-
-        # add the first byte: Drive control
-        builder.add_bits(
-            [
-                cleaned_io_scanning_mode["disable_driver_di"],
-                cleaned_io_scanning_mode["enable_driver_en"],
-                cleaned_io_scanning_mode["quick_stop_qs"],
-                cleaned_io_scanning_mode["fault_reset_fr"],
-                0,  # has to be 0 per default, no meaning
-                cleaned_io_scanning_mode["execute_stop_sh"],
-                cleaned_io_scanning_mode["reset_stop_ch"],
-                cleaned_io_scanning_mode["continue_after_stop_cu"],
-            ]
-        )
-
-        # add the second byte: Mode control
-        builder.add_bits(
-            [
-                int(mode_bits[3]),
-                int(mode_bits[2]),
-                int(mode_bits[1]),
-                int(mode_bits[0]),
-                int(action_bits[2]),
-                int(action_bits[1]),
-                int(action_bits[0]),
-                self._mode_toggle_mt,
-            ]
-        )
-
-        # add the third and fourth byte:
-        # Ref_16 (either JOG direction/speed, or RPM...)
-        builder.add_16bit_uint(cleaned_io_scanning_mode["ref_16"])
-
-        # add 4 bytes Ref_32, Target position
-        builder.add_32bit_int(cleaned_io_scanning_mode["ref_32"])
-
-        return builder.to_registers()
-
-    def _clean_ioscanning_mode_values(
-        self, io_scanning_values: Dict[str, int]
-    ) -> Dict[str, int]:
-        """
-        Checks if the constructed mode is valid.
-
-        :param io_scanning_values: Dictionary with register values to check
-        :return: Dictionary with cleaned register values
-        :raises ValueError: if `io_scanning_values` has unrecognized keys
-        :raises IoScanningModeValueError: if either `'mode'` or either of corresponding
-            `'action'`, `'ref_16'`, or `'ref_32'` keys of `io_scanning_values` has
-            an invalid value.
-        """
-
-        # check if there are too much keys that are not recognized
-        io_scanning_keys = set(io_scanning_values.keys())
-        all_keys = set(self.DEFAULT_IO_SCANNING_CONTROL_VALUES.keys())
-        superfluous_keys = io_scanning_keys.difference(all_keys)
-        if superfluous_keys:
-            raise ValueError(f"Unrecognized mode keys: {list(superfluous_keys)}")
-
-        # fill up io_scanning_values with defaults, if they are not set
-        for mode_key, default_value in self.DEFAULT_IO_SCANNING_CONTROL_VALUES.items():
-            if mode_key not in io_scanning_values:
-                io_scanning_values[mode_key] = cast(int, default_value)
-
-        # perform checks depending on mode
-        # JOG mode
-        if io_scanning_values["mode"] == self.Mode.JOG:
-
-            io_scanning_value = io_scanning_values["action"]
-            if not io_scanning_value == self.ACTION_JOG_VALUE:
-                raise IoScanningModeValueError(f"Wrong action: {io_scanning_value}")
-
-            io_scanning_value = io_scanning_values["ref_16"]
-            try:
-                self.Ref16Jog(io_scanning_value)
-            except ValueError as e:
-                logger.error(str(e), exc_info=e)
-                raise IoScanningModeValueError(
-                    f"Wrong value in ref_16 ({io_scanning_value})"
-                )
-
-            io_scanning_value = io_scanning_values["ref_32"]
-            if not io_scanning_value == 0:
-                raise IoScanningModeValueError(
-                    f"Wrong value in ref_32 ({io_scanning_value})"
-                )
-
-            return io_scanning_values
-
-        # PTP mode
-        if io_scanning_values["mode"] == self.Mode.PTP:
-
-            io_scanning_value = io_scanning_values["action"]
-            try:
-                self.ActionsPtp(io_scanning_value)
-            except ValueError as e:
-                logger.error(str(e), exc_info=e)
-                raise IoScanningModeValueError(f"Wrong action: {io_scanning_value}")
-
-            io_scanning_value = io_scanning_values["ref_16"]
-            if not self._is_valid_rpm(io_scanning_value):
-                raise IoScanningModeValueError(
-                    f"Wrong value in ref_16 ({io_scanning_value})"
-                )
-
-            io_scanning_value = io_scanning_values["ref_32"]
-            if not self._is_int32(io_scanning_value):
-                raise IoScanningModeValueError(
-                    f"Wrong value in ref_32 ({io_scanning_value})"
-                )
-
-            return io_scanning_values
-
-        # default
-        raise IoScanningModeValueError(f"Wrong mode: {io_scanning_values['mode']}")
-
-    def _is_valid_rpm(self, num: int) -> bool:
-        """
-        Checks whether `num` is a valid RPM value.
-
-        :param num: RPM value to check
-        :return: `True` if `num` is a valid RPM value, `False` otherwise
-        """
-
-        return isinstance(num, Integral) and 0 < num <= self.config.rpm_max_init
-
-    @classmethod
-    def _is_int32(cls, num: int) -> bool:
-        """
-        Checks whether a number fits in a signed 32-bit integer.
-
-        :param num: is the number to check.
-        :return: check result.
-        """
-        return isinstance(num, Integral) and cast(
-            ILS2TRegDatatype, ILS2TRegDatatype.INT32
-        ).is_in_range(num)
-
-    @staticmethod
-    def _decode_status_registers(registers: List[int]) -> Dict[str, int]:
-        """
-        Decodes the the status of the stepper drive, derived from IOscanning.
-
-        :param registers: List of 8 registers (6922-6930)
-        :return: dict
-        """
-
-        decoder = BinaryPayloadDecoder.fromRegisters(registers, byteorder=Endian.Big)
-        decoded = {
-            "drive_control": decoder.decode_bits(),
-            "mode_control": decoder.decode_bits(),
-            "ref_16": decoder.decode_16bit_int(),
-            "ref_32": decoder.decode_32bit_int(),
-            "drive_status_1": decoder.decode_bits(),
-            "drive_status_2": decoder.decode_bits(),
-            "mode_status": decoder.decode_bits(),
-            "drive_input": decoder.decode_bits(),
-            "action_word_1": decoder.decode_bits(),
-            "action_word_2": decoder.decode_bits(),
-            "special_function_1": decoder.decode_bits(),
-            "special_function_2": decoder.decode_bits(),
-        }
-
-        return {
-            "mode": BitArray(decoded["mode_status"][3::-1]).int,
-            "action": BitArray(decoded["mode_control"][6:3:-1]).int,
-            "ref_16": decoded["ref_16"],
-            "ref_32": decoded["ref_32"],
-            "state": BitArray(decoded["drive_status_2"][3::-1]).int,
-            "fault": decoded["drive_status_2"][6],
-            "warn": decoded["drive_status_2"][7],
-            "halt": decoded["drive_status_1"][0],
-            "motion_zero": decoded["action_word_2"][6],
-            "turning_positive": decoded["action_word_2"][7],
-            "turning_negative": decoded["action_word_1"][0],
-        }
-
-    def _toggle(self) -> None:
-        """
-        To activate a command it is necessary to toggle the MT bit first.
-        """
-
-        self._mode_toggle_mt = 0 if self._mode_toggle_mt else 1
-
-    def write_relative_step(self, steps: int) -> None:
-        """
-        Write instruction to turn the motor the relative amount of steps. This function
-        does not enable or disable the motor automatically.
-
-        :param steps: Number of steps to turn the motor.
-        """
-        max_step = self.RegDatatype.INT32.max  # type: ignore
-        # use _is_int32 instead?
-        if not abs(steps) < max_step:
-            logger.warning(f"number of steps is too big: {steps}")
-
-        logger.info(f"Perform number of steps: {steps}")
-
-        self.do_ioscanning_write(
-            enable_driver_en=1,
-            mode=self.Mode.PTP.value,
-            action=self.ActionsPtp.RELATIVE_POSITION_MOTOR.value,
-            ref_32=steps,
-        )
-
-    def write_absolute_position(self, position: int) -> None:
-        """
-        Write instruction to turn the motor until it reaches the absolute position.
-        This function does not enable or disable the motor automatically.
-
-        :param position: absolute position of motor in user defined steps.
-        """
-
-        max_position = self.RegDatatype.INT32.max  # type: ignore
-        # use _is_int32 instead?
-        if not abs(position) < max_position:
-            logger.warning(f"position is out of range: {position}")
-
-        logger.info(f"Absolute position: {position}")
-
-        self.do_ioscanning_write(
-            enable_driver_en=1,
-            mode=self.Mode.PTP.value,
-            action=self.ActionsPtp.ABSOLUTE_POSITION.value,
-            ref_32=position,
-        )
-
-    def _is_position_as_expected(
-        self, position_expected: int, position_actual: int, err_msg: str
-    ) -> bool:
-        """
-        Check if actual drive position is a expected. If expectation is not met,
-        check for possible drive error and log the given error message with appropriate
-        level of severity. Do not raise error; instead, return `bool` stating if
-        expectation was met.
-
-        :param position_expected: Expected drive position.
-        :param position_actual: Actual drive position.
-        :param err_msg: Error message to log if expectation is not met.
-        :return: `True` if actual position is as expected, `False` otherwise.
-        """
-        as_expected = position_expected == position_actual
-        if not as_expected:
-            flt_dict = self.get_error_code()
-            self.flt_list.append(flt_dict)
-            if "empty" in flt_dict[0].keys():
-                logger.warning(
-                    "no error in drive, something different must have gone wrong"
-                )
-                logger.warning(err_msg)
-            else:
-                logger.critical("error in drive, drive is know maybe locked")
-                logger.critical(err_msg)
-        return as_expected
-
-    def execute_relative_step(self, steps: int) -> bool:
-        """
-        Execute a relative step, i.e. enable motor, perform relative steps,
-        wait until done and disable motor afterwards.
-
-        Check position at the end if wrong do not raise error; instead just log and
-        return check result.
-
-        :param steps: Number of steps.
-        :return: `True` if actual position is as expected, `False` otherwise.
-        """
-        logger.info(f"Motor steps requested: {steps}")
-
-        with self.com.access_lock:
-            position_before = self.get_position()
-
-            self.enable()
-            sleep(self.config.wait_sec_post_enable)
-            self.write_relative_step(steps)
-            sleep(self.config.wait_sec_post_relative_step)
-            self.disable(log_warn=False)
-
-            # check if steps were made
-            position_after = self.get_position()
-            return self._is_position_as_expected(
-                position_before + steps,
-                position_after,
-                (
-                    "The position does not align with the requested step number. "
-                    f"Before: {position_before}, after: {position_after}, "
-                    f"requested: {steps}, "
-                    f"real difference: {position_after - position_before}."
-                ),
-            )
-
-    def execute_absolute_position(self, position: int) -> bool:
-        """
-        Execute a absolute position change, i.e. enable motor, perform absolute
-        position change, wait until done and disable motor afterwards.
-
-        Check position at the end if wrong do not raise error; instead just log and
-        return check result.
-
-        :param position: absolute position of motor in user defined steps.
-        :return: `True` if actual position is as expected, `False` otherwise.
-        """
-        logger.info(f"absolute position requested: {position}")
-
-        with self.com.access_lock:
-            position_before = self.get_position()
-
-            self.enable()
-            sleep(self.config.wait_sec_post_enable)
-            self.write_absolute_position(position)
-            sleep(self.config.wait_sec_post_absolute_position)
-            self.disable(log_warn=False)
-
-            # check if steps were made
-            position_after = self.get_position()
-            return self._is_position_as_expected(
-                position,
-                position_after,
-                (
-                    "The position does not align with the requested absolute position."
-                    f"Before: {position_before}, after: {position_after}, "
-                    f"requested: {position}."
-                ),
-            )
-
-    def disable(
-        self,
-        log_warn: bool = True,
-        wait_sec_max: Optional[int] = None,
-    ) -> bool:
-        """
-        Disable the driver of the stepper motor and enable the brake.
-
-        Note: the driver cannot be disabled if the motor is still running.
-
-        :param log_warn: if log a warning in case the motor cannot be disabled.
-        :param wait_sec_max: maximal wait time for the motor to stop running and to
-            disable it; by default, with `None`, use a config value
-        :return: `True` if disable request could and was sent, `False` otherwise.
-        """
-        if wait_sec_max is None:
-            wait_sec_max = self.config.wait_sec_max_disable
-
-        try_disable = True
-        elapsed_time = 0.0
-        start_time = time()
-        while try_disable:
-
-            can_disable = bool(self.get_status()["motion_zero"])
-            if can_disable:
-                logger.info("Disable motor, brake.")
-                self.do_ioscanning_write(enable_driver_en=0, disable_driver_di=1)
-            elif log_warn:
-                logger.warning("Cannot disable motor, still running!")
-            elapsed_time += time() - start_time
-
-            try_disable = not can_disable and elapsed_time < wait_sec_max
-            if try_disable:
-                sleep(self.config.wait_sec_post_cannot_disable)
-
-        return can_disable
-
-    def enable(self) -> None:
-        """
-        Enable the driver of the stepper motor and disable the brake.
-        """
-
-        self.do_ioscanning_write(enable_driver_en=1, disable_driver_di=0)
-        logger.info("Enable motor, disable brake.")
-
-    def get_position(self) -> int:
-        """
-        Read the position of the drive and store into status.
-
-        :return: Position step value
-        """
-
-        value = self.com.read_input_registers(self.RegAddr.POSITION.value, 2)
-        return self._decode_32bit(value, True)
-
-    def get_temperature(self) -> int:
-        """
-        Read the temperature of the motor.
-
-        :return: Temperature in degrees Celsius.
-        """
-
-        value = self.com.read_input_registers(self.RegAddr.TEMP.value, 2)
-        return self._decode_32bit(value, True)
-
-    def get_dc_volt(self) -> float:
-        """
-        Read the DC supply voltage of the motor.
-
-        :return: DC input voltage.
-        """
-
-        value = self.com.read_input_registers(self.RegAddr.VOLT.value, 2)
-        return self._decode_32bit(value, True) / 10
-
-    @staticmethod
-    def _decode_32bit(registers: List[int], signed: bool = True) -> int:
-        """
-        Decode two 16-bit ModBus registers to a 32-bit integer.
-
-        :param registers: list of two register values
-        :param signed: True, if register containes a signed value
-        :return: integer representation of the 32-bit register
-        """
-
-        decoder = BinaryPayloadDecoder.fromRegisters(registers, byteorder=Endian.Big)
-        if signed:
-            return decoder.decode_32bit_int()
-        else:
-            return decoder.decode_32bit_uint()
-
-    def user_steps(self, steps: int = 16384, revolutions: int = 1) -> None:
-        """
-        Define steps per revolution.
-        Default is 16384 steps per revolution.
-        Maximum precision is 32768 steps per revolution.
-
-        :param steps: number of steps in `revolutions`.
-        :param revolutions: number of revolutions corresponding to `steps`.
-        """
-
-        if not self._is_int32(revolutions):
-            err_msg = f"Wrong scaling factor: revolutions = {revolutions}"
-            logger.error(err_msg)
-            raise ScalingFactorValueError(err_msg)
-
-        if not self._is_int32(steps):
-            err_msg = f"Wrong scaling factor: steps = {steps}"
-            logger.error(err_msg)
-            raise ScalingFactorValueError(err_msg)
-
-        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
-        builder.add_32bit_int(steps)
-        builder.add_32bit_int(revolutions)
-        values = builder.to_registers()
-        self.com.write_registers(self.RegAddr.SCALE.value, values)
-
-    def quickstop(self) -> None:
-        """
-        Stops the motor with high deceleration rate and falls into error state. Reset
-        with `reset_error` to recover into normal state.
-        """
-
-        logger.warning("Motor QUICK STOP.")
-        self.do_ioscanning_write(quick_stop_qs=1)
-
-    def reset_error(self) -> None:
-        """
-        Resets the motor into normal state after quick stop or another error occured.
-        """
-
-        logger.info("Reset motor after fault or quick stop.")
-        self.do_ioscanning_write(fault_reset_fr=1)
-
-    def jog_run(self, direction: bool = True, fast: bool = False) -> None:
-        """
-        Slowly turn the motor in positive direction.
-        """
-
-        status = self.get_status()
-
-        if status["mode"] != self.Mode.JOG and not status["motion_zero"]:
-            logger.error("Motor is not in Jog mode or standstill, abort.")
-            return
-
-        if status["state"] != self.State.ON:
-            # need to enable first
-            logger.error("Motor is not enabled or in error state. Try .enable()")
-            return
-
-        ref_16 = self.Ref16Jog.NONE
-
-        if direction:
-            ref_16 = ref_16 | self.Ref16Jog.POS
-            logger.info("Jog mode in positive direction enabled.")
-        else:
-            ref_16 = ref_16 | self.Ref16Jog.NEG
-            logger.info("Jog mode in negative direction enabled.")
-
-        if fast:
-            ref_16 = ref_16 | self.Ref16Jog.FAST
-
-        self.do_ioscanning_write(
-            mode=self.Mode.JOG.value,
-            action=self.ACTION_JOG_VALUE,
-            enable_driver_en=1,
-            ref_16=ref_16.value,
-        )
-
-    def jog_stop(self) -> None:
-        """
-        Stop turning the motor in Jog mode.
-        """
-
-        logger.info("Stop in Jog mode.")
-
-        self.do_ioscanning_write(
-            mode=self.Mode.JOG.value,
-            action=self.ACTION_JOG_VALUE,
-            enable_driver_en=1,
-            ref_16=0,
-        )
-
-    def set_jog_speed(self, slow: int = 60, fast: int = 180) -> None:
-        """
-        Set the speed for jog mode. Default values correspond to startup values of
-        the motor.
-
-        :param slow: RPM for slow jog mode.
-        :param fast: RPM for fast jog mode.
-        """
-
-        logger.info(f"Setting Jog RPM. Slow = {slow} RPM, Fast = {fast} RPM.")
-        self.com.write_registers(self.RegAddr.JOGN_SLOW.value, [0, slow])
-        self.com.write_registers(self.RegAddr.JOGN_FAST.value, [0, fast])
-
-    def get_error_code(self) -> Dict[int, Dict[str, Any]]:
-        """
-        Read all messages in fault memory.
-        Will read the full error message and return the decoded values.
-        At the end the fault memory of the motor will be deleted.
-        In addition, reset_error is called to re-enable the motor for operation.
-
-        :return: Dictionary with all information
-        """
-
-        ret_dict = {}
-        self.com.write_registers(self.RegAddr.FLT_MEM_RESET.value, [0, 1])
-        for i in range(10):
-            registers = self.com.read_input_registers(self.RegAddr.FLT_INFO.value, 22)
-            decoder = BinaryPayloadDecoder.fromRegisters(
-                registers, byteorder=Endian.Big
-            )
-            decoded = {
-                "ignored0": decoder.skip_bytes(2),
-                "error_code": decoder.decode_16bit_uint(),
-                "ignored1": decoder.skip_bytes(2),
-                "error_class": decoder.decode_16bit_uint(),
-                "error_time": decoder.decode_32bit_uint(),
-                "ignored2": decoder.skip_bytes(2),
-                "error_addition": decoder.decode_16bit_uint(),
-                "ignored3": decoder.skip_bytes(2),
-                "error_no_cycle": decoder.decode_16bit_uint(),
-                "ignored4": decoder.skip_bytes(2),
-                "error_after_enable": decoder.decode_16bit_uint(),
-                "ignored5": decoder.skip_bytes(2),
-                "error_voltage_dc": decoder.decode_16bit_uint(),
-                "ignored6": decoder.skip_bytes(2),
-                "error_rpm": decoder.decode_16bit_int(),
-                "ignored7": decoder.skip_bytes(2),
-                "error_current": decoder.decode_16bit_uint(),
-                "ignored8": decoder.skip_bytes(2),
-                "error_amplifier_temperature": decoder.decode_16bit_int(),
-                "ignored9": decoder.skip_bytes(2),
-                "error_device_temperature": decoder.decode_16bit_int(),
-            }
-            flt_dict = {
-                "error_code": hex(decoded["error_code"])[2:],
-                "error_class": decoded["error_class"],
-                "error_time": timedelta(seconds=decoded["error_time"]),
-                "error_addition": decoded["error_addition"],
-                "error_no_cycle": decoded["error_no_cycle"],
-                "error_after_enable": timedelta(seconds=decoded["error_after_enable"]),
-                "error_voltage_dc": decoded["error_voltage_dc"] / 10,
-                "error_rpm": decoded["error_rpm"],
-                "error_current": decoded["error_current"] / 100,
-                "error_amplifier_temperature": decoded["error_amplifier_temperature"],
-                "error_device_temperature": decoded["error_device_temperature"],
-            }
-            ret_dict[i] = flt_dict
-            if flt_dict["error_code"] == "0":
-                flt_dict = {"empty": None}
-                ret_dict = {i: flt_dict}
-                break
-        self.com.write_registers(self.RegAddr.FLT_MEM_DEL.value, [0, 1])
-        self.reset_error()
-        return ret_dict
-
-    def set_max_rpm(self, rpm: int) -> None:
-        """
-        Set the maximum RPM.
-
-        :param rpm: revolution per minute ( 0 < rpm <= RPM_MAX)
-        :raises ILS2TException: if RPM is out of range
-        """
-
-        if self._is_valid_rpm(rpm):
-            self.DEFAULT_IO_SCANNING_CONTROL_VALUES["ref_16"] = rpm
-            self.com.write_registers(self.RegAddr.RAMP_N_MAX.value, [0, rpm])
-        else:
-            raise ILS2TException(
-                f"RPM out of range: {rpm} not in (0, {self.config.rpm_max_init}]"
-            )
-
-    def set_ramp_type(self, ramp_type: int = -1) -> None:
-        """
-        Set the ramp type. There are two options available:
-            0:  linear ramp
-            -1: motor optimized ramp
-
-        :param ramp_type: 0: linear ramp | -1: motor optimized ramp
-        """
-
-        self.com.write_registers(self.RegAddr.RAMP_TYPE.value, [0, ramp_type])
-
-    def set_max_acceleration(self, rpm_minute: int) -> None:
-        """
-        Set the maximum acceleration of the motor.
-
-        :param rpm_minute: revolution per minute per minute
-        """
-
-        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
-        builder.add_32bit_uint(rpm_minute)
-        values = builder.to_registers()
-        self.com.write_registers(self.RegAddr.RAMP_ACC.value, values)
-
-    def set_max_deceleration(self, rpm_minute: int) -> None:
-        """
-        Set the maximum deceleration of the motor.
-
-        :param rpm_minute: revolution per minute per minute
-        """
-
-        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
-        builder.add_32bit_uint(rpm_minute)
-        values = builder.to_registers()
-        self.com.write_registers(self.RegAddr.RAMP_DECEL.value, values)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device class for controlling a Schneider Electric ILS2T stepper drive over modbus TCP.
+"""
+
+import logging
+from datetime import timedelta
+from enum import Flag, IntEnum
+from numbers import Integral
+from time import sleep, time
+from typing import Dict, List, Any, cast, Optional
+
+import aenum
+from bitstring import BitArray
+from pymodbus.constants import Endian
+from pymodbus.payload import BinaryPayloadDecoder, BinaryPayloadBuilder
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import (
+    ModbusTcpCommunication,
+    ModbusTcpConnectionFailedException,
+    ModbusTcpCommunicationConfig,
+)
+from ..configuration import configdataclass
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class ILS2TException(DeviceException):
+    """
+    Exception to indicate problems with the SE ILS2T stepper motor.
+    """
+
+    pass
+
+
+class IoScanningModeValueError(ILS2TException):
+    """
+    Exception to indicate that the selected IO scanning mode is invalid.
+    """
+
+    pass
+
+
+class ScalingFactorValueError(ILS2TException):
+    """
+    Exception to indicate that a scaling factor value is invalid.
+    """
+
+    pass
+
+
+@configdataclass
+class ILS2TModbusTcpCommunicationConfig(ModbusTcpCommunicationConfig):
+    """
+    Configuration dataclass for Modbus/TCP communciation specific for the Schneider
+    Electric ILS2T stepper motor.
+    """
+
+    #: The unit has to be 255 such that IO scanning mode works.
+    unit: int = 255
+
+
+class ILS2TModbusTcpCommunication(ModbusTcpCommunication):
+    """
+    Specific implementation of Modbus/TCP for the Schneider Electric ILS2T stepper
+    motor.
+    """
+
+    @staticmethod
+    def config_cls():
+        return ILS2TModbusTcpCommunicationConfig
+
+
+@configdataclass
+class ILS2TConfig:
+    """
+    Configuration for the ILS2T stepper motor device.
+    """
+
+    #: initial maximum RPM for the motor, can be set up to 3000 RPM. The user is
+    #: allowed to set a new max RPM at runtime using :meth:`ILS2T.set_max_rpm`,
+    #: but the value must never exceed this configuration setting.
+    rpm_max_init: Integral = cast(Integral, 1500)
+    wait_sec_post_enable: Number = 1
+    wait_sec_max_disable: Number = 10
+    wait_sec_post_cannot_disable: Number = 1
+    wait_sec_post_relative_step: Number = 2
+    wait_sec_post_absolute_position: Number = 2
+
+    def clean_values(self):
+        if not 0 < self.rpm_max_init <= 3000:
+            raise ValueError(
+                "Maximum RPM for the motor must be integer number between 1 and 3000."
+            )
+        if self.wait_sec_post_enable <= 0:
+            raise ValueError(
+                "Wait time post motor enabling must be a positive value (in seconds)."
+            )
+        if self.wait_sec_max_disable < 0:
+            raise ValueError(
+                "Maximal wait time for attempting to disable motor must be a "
+                "non-negative value (in seconds)."
+            )
+        if self.wait_sec_post_cannot_disable <= 0:
+            raise ValueError(
+                "Wait time post failed motor disable attempt must be a positive value "
+                "(in seconds)."
+            )
+        if self.wait_sec_post_relative_step <= 0:
+            raise ValueError(
+                "Wait time post motor relative step must be a positive value "
+                "(in seconds)."
+            )
+        if self.wait_sec_post_absolute_position <= 0:
+            raise ValueError(
+                "Wait time post motor absolute position change must be a positive "
+                "value (in seconds)."
+            )
+
+
+class ILS2TRegDatatype(aenum.Enum, init="min max"):  # type: ignore
+    """
+    Modbus Register Datatypes for Schneider Electric ILS2T stepper drive.
+
+    From the manual of the drive:
+
+    =========== =========== ============== =============
+    datatype    byte        min            max
+    =========== =========== ============== =============
+    INT8        1 Byte      -128           127
+    UINT8       1 Byte      0              255
+    INT16       2 Byte      -32_768        32_767
+    UINT16      2 Byte      0              65_535
+    INT32       4 Byte      -2_147_483_648 2_147_483_647
+    UINT32      4 Byte      0              4_294_967_295
+    BITS        just 32bits N/A            N/A
+    =========== =========== ============== =============
+
+    """
+
+    INT32 = -2_147_483_648, 2_147_483_647
+
+    def is_in_range(self, value: int) -> bool:
+        return self.min <= value <= self.max
+
+
+class ILS2TRegAddr(IntEnum):
+    """
+    Modbus Register Adresses for for Schneider Electric ILS2T stepper drive.
+    """
+
+    POSITION = 7706  # INT32 position of the motor in user defined units
+    IO_SCANNING = 6922  # BITS start register for IO scanning control
+    # and status
+    TEMP = 7200  # INT16 temperature of motor
+    VOLT = 7198  # UINT16 dc voltage of motor
+    SCALE = 1550  # INT32 user defined steps per revolution
+    ACCESS_ENABLE = 282  # BITS not documented register
+    # to enable access via IO scanning
+    JOGN_FAST = 10506  # UINT16 revolutions per minute for fast Jog (1 to 3000)
+    JOGN_SLOW = 10504  # UINT16 revolutions per minute
+    # for slow Jog (1 to 3000)
+
+    RAMP_TYPE = 1574  # INT16 ramp type, 0: linear / -1: motor optimized
+    RAMP_ACC = 1556  # UINT32 acceleration
+    RAMP_DECEL = 1558  # UINT32 deceleration
+    RAMP_N_MAX = 1554  # UINT16 max rpm
+    FLT_INFO = 15362  # 22 registers, code for error
+    FLT_MEM_RESET = 15114  # UINT16 reset fault memory
+    FLT_MEM_DEL = 15112  # UINT16 delete fault memory
+
+
+class ILS2T(SingleCommDevice):
+    """
+    Schneider Electric ILS2T stepper drive class.
+    """
+
+    RegDatatype = ILS2TRegDatatype
+    """Modbus Register Datatypes
+    """
+    RegAddr = ILS2TRegAddr
+    """Modbus Register Adresses
+    """
+
+    class Mode(IntEnum):
+        """
+        ILS2T device modes
+        """
+
+        PTP = 3  # point to point
+        JOG = 1
+
+    class ActionsPtp(IntEnum):
+        """
+        Allowed actions in the point to point mode (`ILS2T.Mode.PTP`).
+        """
+
+        ABSOLUTE_POSITION = 0
+        RELATIVE_POSITION_TARGET = 1
+        RELATIVE_POSITION_MOTOR = 2
+
+    ACTION_JOG_VALUE = 0
+    """
+    The single action value for `ILS2T.Mode.JOG`
+    """
+
+    # Note: don't use IntFlag here - it allows other then enumerated values
+    class Ref16Jog(Flag):
+        """
+        Allowed values for ILS2T ref_16 register (the shown values are the integer
+        representation of the bits), all in Jog mode = 1
+        """
+
+        NONE = 0
+        POS = 1
+        NEG = 2
+        FAST = 4
+        # allowed combinations
+        POS_FAST = POS | FAST
+        NEG_FAST = NEG | FAST
+
+    class State(IntEnum):
+        """
+        State machine status values
+        """
+
+        QUICKSTOP = 7
+        READY = 4
+        ON = 6
+
+    DEFAULT_IO_SCANNING_CONTROL_VALUES = {
+        "action": ActionsPtp.RELATIVE_POSITION_MOTOR.value,
+        "mode": Mode.PTP.value,
+        "disable_driver_di": 0,
+        "enable_driver_en": 0,
+        "quick_stop_qs": 0,
+        "fault_reset_fr": 0,
+        "execute_stop_sh": 0,
+        "reset_stop_ch": 0,
+        "continue_after_stop_cu": 0,
+        "ref_16": ILS2TConfig.rpm_max_init,
+        "ref_32": 0,
+    }
+    """
+    Default IO Scanning control mode values
+    """
+
+    def __init__(self, com, dev_config=None) -> None:
+        """
+        Constructor for ILS2T.
+
+        :param com: object to use as communication protocol.
+        """
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        # toggle reminder bit
+        self._mode_toggle_mt = 0
+
+        self.flt_list: List[Dict[int, Dict[str, Any]]] = []
+
+    @staticmethod
+    def default_com_cls():
+        return ILS2TModbusTcpCommunication
+
+    @staticmethod
+    def config_cls():
+        return ILS2TConfig
+
+    def start(self) -> None:
+        """
+        Start this device.
+        """
+
+        logger.info("Starting device " + str(self))
+        try:
+            # try opening the port
+            super().start()
+        except ModbusTcpConnectionFailedException as exc:
+            logger.error(str(exc), exc_info=exc)
+            raise
+
+        # writing 1 to register ACCESS_ENABLE allows to use the IO scanning mode.
+        #  This is not documented in the manual!
+        self.com.write_registers(self.RegAddr.ACCESS_ENABLE.value, [0, 1])
+
+        # set maximum RPM from init config
+        self.set_max_rpm(self.config.rpm_max_init)
+
+    def stop(self) -> None:
+        """
+        Stop this device. Disables the motor (applies brake), disables access and
+        closes the communication protocol.
+        """
+
+        logger.info("Stopping device " + str(self))
+        self.disable()
+        self.com.write_registers(self.RegAddr.ACCESS_ENABLE.value, [0, 0])
+        super().stop()
+
+    def get_status(self) -> Dict[str, int]:
+        """
+        Perform an IO Scanning read and return the status of the motor.
+
+        :return: dict with status information.
+        """
+
+        registers = self.com.read_holding_registers(self.RegAddr.IO_SCANNING.value, 8)
+        return self._decode_status_registers(registers)
+
+    def do_ioscanning_write(self, **kwargs: int) -> None:
+        """
+        Perform a write operation using IO Scanning mode.
+
+        :param kwargs:
+            Keyword-argument list with options to send, remaining are taken
+            from the defaults.
+        """
+
+        self._toggle()
+        values = self._generate_control_registers(**kwargs)
+        self.com.write_registers(self.RegAddr.IO_SCANNING.value, values)
+
+    def _generate_control_registers(self, **kwargs: int) -> List[int]:
+        """
+        Generates the control registers for the IO scanning mode.
+        It is necessary to write all 64 bit at the same time, so a list of 4 registers
+        is generated.
+
+        :param kwargs: Keyword-argument list with options different than the defaults.
+        :return: List of registers for the IO scanning mode.
+        """
+
+        cleaned_io_scanning_mode = self._clean_ioscanning_mode_values(kwargs)
+
+        action_bits = f"{cleaned_io_scanning_mode['action']:03b}"
+        mode_bits = f"{cleaned_io_scanning_mode['mode']:04b}"
+        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
+
+        # add the first byte: Drive control
+        builder.add_bits(
+            [
+                cleaned_io_scanning_mode["disable_driver_di"],
+                cleaned_io_scanning_mode["enable_driver_en"],
+                cleaned_io_scanning_mode["quick_stop_qs"],
+                cleaned_io_scanning_mode["fault_reset_fr"],
+                0,  # has to be 0 per default, no meaning
+                cleaned_io_scanning_mode["execute_stop_sh"],
+                cleaned_io_scanning_mode["reset_stop_ch"],
+                cleaned_io_scanning_mode["continue_after_stop_cu"],
+            ]
+        )
+
+        # add the second byte: Mode control
+        builder.add_bits(
+            [
+                int(mode_bits[3]),
+                int(mode_bits[2]),
+                int(mode_bits[1]),
+                int(mode_bits[0]),
+                int(action_bits[2]),
+                int(action_bits[1]),
+                int(action_bits[0]),
+                self._mode_toggle_mt,
+            ]
+        )
+
+        # add the third and fourth byte:
+        # Ref_16 (either JOG direction/speed, or RPM...)
+        builder.add_16bit_uint(cleaned_io_scanning_mode["ref_16"])
+
+        # add 4 bytes Ref_32, Target position
+        builder.add_32bit_int(cleaned_io_scanning_mode["ref_32"])
+
+        return builder.to_registers()
+
+    def _clean_ioscanning_mode_values(
+        self, io_scanning_values: Dict[str, int]
+    ) -> Dict[str, int]:
+        """
+        Checks if the constructed mode is valid.
+
+        :param io_scanning_values: Dictionary with register values to check
+        :return: Dictionary with cleaned register values
+        :raises ValueError: if `io_scanning_values` has unrecognized keys
+        :raises IoScanningModeValueError: if either `'mode'` or either of corresponding
+            `'action'`, `'ref_16'`, or `'ref_32'` keys of `io_scanning_values` has
+            an invalid value.
+        """
+
+        # check if there are too much keys that are not recognized
+        io_scanning_keys = set(io_scanning_values.keys())
+        all_keys = set(self.DEFAULT_IO_SCANNING_CONTROL_VALUES.keys())
+        superfluous_keys = io_scanning_keys.difference(all_keys)
+        if superfluous_keys:
+            raise ValueError(f"Unrecognized mode keys: {list(superfluous_keys)}")
+
+        # fill up io_scanning_values with defaults, if they are not set
+        for mode_key, default_value in self.DEFAULT_IO_SCANNING_CONTROL_VALUES.items():
+            if mode_key not in io_scanning_values:
+                io_scanning_values[mode_key] = cast(int, default_value)
+
+        # perform checks depending on mode
+        # JOG mode
+        if io_scanning_values["mode"] == self.Mode.JOG:
+
+            io_scanning_value = io_scanning_values["action"]
+            if not io_scanning_value == self.ACTION_JOG_VALUE:
+                raise IoScanningModeValueError(f"Wrong action: {io_scanning_value}")
+
+            io_scanning_value = io_scanning_values["ref_16"]
+            try:
+                self.Ref16Jog(io_scanning_value)
+            except ValueError as e:
+                logger.error(str(e), exc_info=e)
+                raise IoScanningModeValueError(
+                    f"Wrong value in ref_16 ({io_scanning_value})"
+                )
+
+            io_scanning_value = io_scanning_values["ref_32"]
+            if not io_scanning_value == 0:
+                raise IoScanningModeValueError(
+                    f"Wrong value in ref_32 ({io_scanning_value})"
+                )
+
+            return io_scanning_values
+
+        # PTP mode
+        if io_scanning_values["mode"] == self.Mode.PTP:
+
+            io_scanning_value = io_scanning_values["action"]
+            try:
+                self.ActionsPtp(io_scanning_value)
+            except ValueError as e:
+                logger.error(str(e), exc_info=e)
+                raise IoScanningModeValueError(f"Wrong action: {io_scanning_value}")
+
+            io_scanning_value = io_scanning_values["ref_16"]
+            if not self._is_valid_rpm(io_scanning_value):
+                raise IoScanningModeValueError(
+                    f"Wrong value in ref_16 ({io_scanning_value})"
+                )
+
+            io_scanning_value = io_scanning_values["ref_32"]
+            if not self._is_int32(io_scanning_value):
+                raise IoScanningModeValueError(
+                    f"Wrong value in ref_32 ({io_scanning_value})"
+                )
+
+            return io_scanning_values
+
+        # default
+        raise IoScanningModeValueError(f"Wrong mode: {io_scanning_values['mode']}")
+
+    def _is_valid_rpm(self, num: int) -> bool:
+        """
+        Checks whether `num` is a valid RPM value.
+
+        :param num: RPM value to check
+        :return: `True` if `num` is a valid RPM value, `False` otherwise
+        """
+
+        return isinstance(num, Integral) and 0 < num <= self.config.rpm_max_init
+
+    @classmethod
+    def _is_int32(cls, num: int) -> bool:
+        """
+        Checks whether a number fits in a signed 32-bit integer.
+
+        :param num: is the number to check.
+        :return: check result.
+        """
+        return isinstance(num, Integral) and cast(
+            ILS2TRegDatatype, ILS2TRegDatatype.INT32
+        ).is_in_range(num)
+
+    @staticmethod
+    def _decode_status_registers(registers: List[int]) -> Dict[str, int]:
+        """
+        Decodes the the status of the stepper drive, derived from IOscanning.
+
+        :param registers: List of 8 registers (6922-6930)
+        :return: dict
+        """
+
+        decoder = BinaryPayloadDecoder.fromRegisters(registers, byteorder=Endian.Big)
+        decoded = {
+            "drive_control": decoder.decode_bits(),
+            "mode_control": decoder.decode_bits(),
+            "ref_16": decoder.decode_16bit_int(),
+            "ref_32": decoder.decode_32bit_int(),
+            "drive_status_1": decoder.decode_bits(),
+            "drive_status_2": decoder.decode_bits(),
+            "mode_status": decoder.decode_bits(),
+            "drive_input": decoder.decode_bits(),
+            "action_word_1": decoder.decode_bits(),
+            "action_word_2": decoder.decode_bits(),
+            "special_function_1": decoder.decode_bits(),
+            "special_function_2": decoder.decode_bits(),
+        }
+
+        return {
+            "mode": BitArray(decoded["mode_status"][3::-1]).int,
+            "action": BitArray(decoded["mode_control"][6:3:-1]).int,
+            "ref_16": decoded["ref_16"],
+            "ref_32": decoded["ref_32"],
+            "state": BitArray(decoded["drive_status_2"][3::-1]).int,
+            "fault": decoded["drive_status_2"][6],
+            "warn": decoded["drive_status_2"][7],
+            "halt": decoded["drive_status_1"][0],
+            "motion_zero": decoded["action_word_2"][6],
+            "turning_positive": decoded["action_word_2"][7],
+            "turning_negative": decoded["action_word_1"][0],
+        }
+
+    def _toggle(self) -> None:
+        """
+        To activate a command it is necessary to toggle the MT bit first.
+        """
+
+        self._mode_toggle_mt = 0 if self._mode_toggle_mt else 1
+
+    def write_relative_step(self, steps: int) -> None:
+        """
+        Write instruction to turn the motor the relative amount of steps. This function
+        does not enable or disable the motor automatically.
+
+        :param steps: Number of steps to turn the motor.
+        """
+        max_step = self.RegDatatype.INT32.max  # type: ignore
+        # use _is_int32 instead?
+        if not abs(steps) < max_step:
+            logger.warning(f"number of steps is too big: {steps}")
+
+        logger.info(f"Perform number of steps: {steps}")
+
+        self.do_ioscanning_write(
+            enable_driver_en=1,
+            mode=self.Mode.PTP.value,
+            action=self.ActionsPtp.RELATIVE_POSITION_MOTOR.value,
+            ref_32=steps,
+        )
+
+    def write_absolute_position(self, position: int) -> None:
+        """
+        Write instruction to turn the motor until it reaches the absolute position.
+        This function does not enable or disable the motor automatically.
+
+        :param position: absolute position of motor in user defined steps.
+        """
+
+        max_position = self.RegDatatype.INT32.max  # type: ignore
+        # use _is_int32 instead?
+        if not abs(position) < max_position:
+            logger.warning(f"position is out of range: {position}")
+
+        logger.info(f"Absolute position: {position}")
+
+        self.do_ioscanning_write(
+            enable_driver_en=1,
+            mode=self.Mode.PTP.value,
+            action=self.ActionsPtp.ABSOLUTE_POSITION.value,
+            ref_32=position,
+        )
+
+    def _is_position_as_expected(
+        self, position_expected: int, position_actual: int, err_msg: str
+    ) -> bool:
+        """
+        Check if actual drive position is a expected. If expectation is not met,
+        check for possible drive error and log the given error message with appropriate
+        level of severity. Do not raise error; instead, return `bool` stating if
+        expectation was met.
+
+        :param position_expected: Expected drive position.
+        :param position_actual: Actual drive position.
+        :param err_msg: Error message to log if expectation is not met.
+        :return: `True` if actual position is as expected, `False` otherwise.
+        """
+        as_expected = position_expected == position_actual
+        if not as_expected:
+            flt_dict = self.get_error_code()
+            self.flt_list.append(flt_dict)
+            if "empty" in flt_dict[0].keys():
+                logger.warning(
+                    "no error in drive, something different must have gone wrong"
+                )
+                logger.warning(err_msg)
+            else:
+                logger.critical("error in drive, drive is know maybe locked")
+                logger.critical(err_msg)
+        return as_expected
+
+    def execute_relative_step(self, steps: int) -> bool:
+        """
+        Execute a relative step, i.e. enable motor, perform relative steps,
+        wait until done and disable motor afterwards.
+
+        Check position at the end if wrong do not raise error; instead just log and
+        return check result.
+
+        :param steps: Number of steps.
+        :return: `True` if actual position is as expected, `False` otherwise.
+        """
+        logger.info(f"Motor steps requested: {steps}")
+
+        with self.com.access_lock:
+            position_before = self.get_position()
+
+            self.enable()
+            sleep(self.config.wait_sec_post_enable)
+            self.write_relative_step(steps)
+            sleep(self.config.wait_sec_post_relative_step)
+            self.disable(log_warn=False)
+
+            # check if steps were made
+            position_after = self.get_position()
+            return self._is_position_as_expected(
+                position_before + steps,
+                position_after,
+                (
+                    "The position does not align with the requested step number. "
+                    f"Before: {position_before}, after: {position_after}, "
+                    f"requested: {steps}, "
+                    f"real difference: {position_after - position_before}."
+                ),
+            )
+
+    def execute_absolute_position(self, position: int) -> bool:
+        """
+        Execute a absolute position change, i.e. enable motor, perform absolute
+        position change, wait until done and disable motor afterwards.
+
+        Check position at the end if wrong do not raise error; instead just log and
+        return check result.
+
+        :param position: absolute position of motor in user defined steps.
+        :return: `True` if actual position is as expected, `False` otherwise.
+        """
+        logger.info(f"absolute position requested: {position}")
+
+        with self.com.access_lock:
+            position_before = self.get_position()
+
+            self.enable()
+            sleep(self.config.wait_sec_post_enable)
+            self.write_absolute_position(position)
+            sleep(self.config.wait_sec_post_absolute_position)
+            self.disable(log_warn=False)
+
+            # check if steps were made
+            position_after = self.get_position()
+            return self._is_position_as_expected(
+                position,
+                position_after,
+                (
+                    "The position does not align with the requested absolute position."
+                    f"Before: {position_before}, after: {position_after}, "
+                    f"requested: {position}."
+                ),
+            )
+
+    def disable(
+        self,
+        log_warn: bool = True,
+        wait_sec_max: Optional[int] = None,
+    ) -> bool:
+        """
+        Disable the driver of the stepper motor and enable the brake.
+
+        Note: the driver cannot be disabled if the motor is still running.
+
+        :param log_warn: if log a warning in case the motor cannot be disabled.
+        :param wait_sec_max: maximal wait time for the motor to stop running and to
+            disable it; by default, with `None`, use a config value
+        :return: `True` if disable request could and was sent, `False` otherwise.
+        """
+        if wait_sec_max is None:
+            wait_sec_max = self.config.wait_sec_max_disable
+
+        try_disable = True
+        elapsed_time = 0.0
+        start_time = time()
+        while try_disable:
+
+            can_disable = bool(self.get_status()["motion_zero"])
+            if can_disable:
+                logger.info("Disable motor, brake.")
+                self.do_ioscanning_write(enable_driver_en=0, disable_driver_di=1)
+            elif log_warn:
+                logger.warning("Cannot disable motor, still running!")
+            elapsed_time += time() - start_time
+
+            try_disable = not can_disable and elapsed_time < wait_sec_max
+            if try_disable:
+                sleep(self.config.wait_sec_post_cannot_disable)
+
+        return can_disable
+
+    def enable(self) -> None:
+        """
+        Enable the driver of the stepper motor and disable the brake.
+        """
+
+        self.do_ioscanning_write(enable_driver_en=1, disable_driver_di=0)
+        logger.info("Enable motor, disable brake.")
+
+    def get_position(self) -> int:
+        """
+        Read the position of the drive and store into status.
+
+        :return: Position step value
+        """
+
+        value = self.com.read_input_registers(self.RegAddr.POSITION.value, 2)
+        return self._decode_32bit(value, True)
+
+    def get_temperature(self) -> int:
+        """
+        Read the temperature of the motor.
+
+        :return: Temperature in degrees Celsius.
+        """
+
+        value = self.com.read_input_registers(self.RegAddr.TEMP.value, 2)
+        return self._decode_32bit(value, True)
+
+    def get_dc_volt(self) -> float:
+        """
+        Read the DC supply voltage of the motor.
+
+        :return: DC input voltage.
+        """
+
+        value = self.com.read_input_registers(self.RegAddr.VOLT.value, 2)
+        return self._decode_32bit(value, True) / 10
+
+    @staticmethod
+    def _decode_32bit(registers: List[int], signed: bool = True) -> int:
+        """
+        Decode two 16-bit ModBus registers to a 32-bit integer.
+
+        :param registers: list of two register values
+        :param signed: True, if register containes a signed value
+        :return: integer representation of the 32-bit register
+        """
+
+        decoder = BinaryPayloadDecoder.fromRegisters(registers, byteorder=Endian.Big)
+        if signed:
+            return decoder.decode_32bit_int()
+        else:
+            return decoder.decode_32bit_uint()
+
+    def user_steps(self, steps: int = 16384, revolutions: int = 1) -> None:
+        """
+        Define steps per revolution.
+        Default is 16384 steps per revolution.
+        Maximum precision is 32768 steps per revolution.
+
+        :param steps: number of steps in `revolutions`.
+        :param revolutions: number of revolutions corresponding to `steps`.
+        """
+
+        if not self._is_int32(revolutions):
+            err_msg = f"Wrong scaling factor: revolutions = {revolutions}"
+            logger.error(err_msg)
+            raise ScalingFactorValueError(err_msg)
+
+        if not self._is_int32(steps):
+            err_msg = f"Wrong scaling factor: steps = {steps}"
+            logger.error(err_msg)
+            raise ScalingFactorValueError(err_msg)
+
+        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
+        builder.add_32bit_int(steps)
+        builder.add_32bit_int(revolutions)
+        values = builder.to_registers()
+        self.com.write_registers(self.RegAddr.SCALE.value, values)
+
+    def quickstop(self) -> None:
+        """
+        Stops the motor with high deceleration rate and falls into error state. Reset
+        with `reset_error` to recover into normal state.
+        """
+
+        logger.warning("Motor QUICK STOP.")
+        self.do_ioscanning_write(quick_stop_qs=1)
+
+    def reset_error(self) -> None:
+        """
+        Resets the motor into normal state after quick stop or another error occured.
+        """
+
+        logger.info("Reset motor after fault or quick stop.")
+        self.do_ioscanning_write(fault_reset_fr=1)
+
+    def jog_run(self, direction: bool = True, fast: bool = False) -> None:
+        """
+        Slowly turn the motor in positive direction.
+        """
+
+        status = self.get_status()
+
+        if status["mode"] != self.Mode.JOG and not status["motion_zero"]:
+            logger.error("Motor is not in Jog mode or standstill, abort.")
+            return
+
+        if status["state"] != self.State.ON:
+            # need to enable first
+            logger.error("Motor is not enabled or in error state. Try .enable()")
+            return
+
+        ref_16 = self.Ref16Jog.NONE
+
+        if direction:
+            ref_16 = ref_16 | self.Ref16Jog.POS
+            logger.info("Jog mode in positive direction enabled.")
+        else:
+            ref_16 = ref_16 | self.Ref16Jog.NEG
+            logger.info("Jog mode in negative direction enabled.")
+
+        if fast:
+            ref_16 = ref_16 | self.Ref16Jog.FAST
+
+        self.do_ioscanning_write(
+            mode=self.Mode.JOG.value,
+            action=self.ACTION_JOG_VALUE,
+            enable_driver_en=1,
+            ref_16=ref_16.value,
+        )
+
+    def jog_stop(self) -> None:
+        """
+        Stop turning the motor in Jog mode.
+        """
+
+        logger.info("Stop in Jog mode.")
+
+        self.do_ioscanning_write(
+            mode=self.Mode.JOG.value,
+            action=self.ACTION_JOG_VALUE,
+            enable_driver_en=1,
+            ref_16=0,
+        )
+
+    def set_jog_speed(self, slow: int = 60, fast: int = 180) -> None:
+        """
+        Set the speed for jog mode. Default values correspond to startup values of
+        the motor.
+
+        :param slow: RPM for slow jog mode.
+        :param fast: RPM for fast jog mode.
+        """
+
+        logger.info(f"Setting Jog RPM. Slow = {slow} RPM, Fast = {fast} RPM.")
+        self.com.write_registers(self.RegAddr.JOGN_SLOW.value, [0, slow])
+        self.com.write_registers(self.RegAddr.JOGN_FAST.value, [0, fast])
+
+    def get_error_code(self) -> Dict[int, Dict[str, Any]]:
+        """
+        Read all messages in fault memory.
+        Will read the full error message and return the decoded values.
+        At the end the fault memory of the motor will be deleted.
+        In addition, reset_error is called to re-enable the motor for operation.
+
+        :return: Dictionary with all information
+        """
+
+        ret_dict = {}
+        self.com.write_registers(self.RegAddr.FLT_MEM_RESET.value, [0, 1])
+        for i in range(10):
+            registers = self.com.read_input_registers(self.RegAddr.FLT_INFO.value, 22)
+            decoder = BinaryPayloadDecoder.fromRegisters(
+                registers, byteorder=Endian.Big
+            )
+            decoded = {
+                "ignored0": decoder.skip_bytes(2),
+                "error_code": decoder.decode_16bit_uint(),
+                "ignored1": decoder.skip_bytes(2),
+                "error_class": decoder.decode_16bit_uint(),
+                "error_time": decoder.decode_32bit_uint(),
+                "ignored2": decoder.skip_bytes(2),
+                "error_addition": decoder.decode_16bit_uint(),
+                "ignored3": decoder.skip_bytes(2),
+                "error_no_cycle": decoder.decode_16bit_uint(),
+                "ignored4": decoder.skip_bytes(2),
+                "error_after_enable": decoder.decode_16bit_uint(),
+                "ignored5": decoder.skip_bytes(2),
+                "error_voltage_dc": decoder.decode_16bit_uint(),
+                "ignored6": decoder.skip_bytes(2),
+                "error_rpm": decoder.decode_16bit_int(),
+                "ignored7": decoder.skip_bytes(2),
+                "error_current": decoder.decode_16bit_uint(),
+                "ignored8": decoder.skip_bytes(2),
+                "error_amplifier_temperature": decoder.decode_16bit_int(),
+                "ignored9": decoder.skip_bytes(2),
+                "error_device_temperature": decoder.decode_16bit_int(),
+            }
+            flt_dict = {
+                "error_code": hex(decoded["error_code"])[2:],
+                "error_class": decoded["error_class"],
+                "error_time": timedelta(seconds=decoded["error_time"]),
+                "error_addition": decoded["error_addition"],
+                "error_no_cycle": decoded["error_no_cycle"],
+                "error_after_enable": timedelta(seconds=decoded["error_after_enable"]),
+                "error_voltage_dc": decoded["error_voltage_dc"] / 10,
+                "error_rpm": decoded["error_rpm"],
+                "error_current": decoded["error_current"] / 100,
+                "error_amplifier_temperature": decoded["error_amplifier_temperature"],
+                "error_device_temperature": decoded["error_device_temperature"],
+            }
+            ret_dict[i] = flt_dict
+            if flt_dict["error_code"] == "0":
+                flt_dict = {"empty": None}
+                ret_dict = {i: flt_dict}
+                break
+        self.com.write_registers(self.RegAddr.FLT_MEM_DEL.value, [0, 1])
+        self.reset_error()
+        return ret_dict
+
+    def set_max_rpm(self, rpm: int) -> None:
+        """
+        Set the maximum RPM.
+
+        :param rpm: revolution per minute ( 0 < rpm <= RPM_MAX)
+        :raises ILS2TException: if RPM is out of range
+        """
+
+        if self._is_valid_rpm(rpm):
+            self.DEFAULT_IO_SCANNING_CONTROL_VALUES["ref_16"] = rpm
+            self.com.write_registers(self.RegAddr.RAMP_N_MAX.value, [0, rpm])
+        else:
+            raise ILS2TException(
+                f"RPM out of range: {rpm} not in (0, {self.config.rpm_max_init}]"
+            )
+
+    def set_ramp_type(self, ramp_type: int = -1) -> None:
+        """
+        Set the ramp type. There are two options available:
+            0:  linear ramp
+            -1: motor optimized ramp
+
+        :param ramp_type: 0: linear ramp | -1: motor optimized ramp
+        """
+
+        self.com.write_registers(self.RegAddr.RAMP_TYPE.value, [0, ramp_type])
+
+    def set_max_acceleration(self, rpm_minute: int) -> None:
+        """
+        Set the maximum acceleration of the motor.
+
+        :param rpm_minute: revolution per minute per minute
+        """
+
+        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
+        builder.add_32bit_uint(rpm_minute)
+        values = builder.to_registers()
+        self.com.write_registers(self.RegAddr.RAMP_ACC.value, values)
+
+    def set_max_deceleration(self, rpm_minute: int) -> None:
+        """
+        Set the maximum deceleration of the motor.
+
+        :param rpm_minute: revolution per minute per minute
+        """
+
+        builder = BinaryPayloadBuilder(byteorder=Endian.Big, wordorder=Endian.Big)
+        builder.add_32bit_uint(rpm_minute)
+        values = builder.to_registers()
+        self.com.write_registers(self.RegAddr.RAMP_DECEL.value, values)
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/sst_luminox.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/sst_luminox.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,369 +1,375 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Device class for a SST Luminox Oxygen sensor. This device can measure the oxygen
-concentration between 0 % and 25 %.
-
-Furthermore, it measures the barometric pressure and internal temperature.
-The device supports two operating modes: in streaming mode the device measures all
-parameters every second, in polling mode the device measures only after a query.
-
-Technical specification and documentation for the device can be found a the
-manufacturer's page:
-https://www.sstsensing.com/product/luminox-optical-oxygen-sensors-2/
-"""
-
-import logging
-import re
-from enum import Enum
-from time import sleep
-from typing import Union, Tuple, List, cast, Optional, Dict
-
-from .base import SingleCommDevice
-from ..comm import SerialCommunication, SerialCommunicationConfig
-from ..comm.serial import (
-    SerialCommunicationParity,
-    SerialCommunicationStopbits,
-    SerialCommunicationBytesize,
-)
-from ..configuration import configdataclass
-from ..utils.enum import ValueEnum
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class LuminoxOutputModeError(Exception):
-    """
-    Wrong output mode for requested data
-    """
-
-    pass
-
-
-class LuminoxOutputMode(Enum):
-    """
-    output mode.
-    """
-
-    streaming = 0
-    polling = 1
-
-
-class LuminoxMeasurementTypeError(Exception):
-    """
-    Wrong measurement type for requested data
-    """
-
-    pass
-
-
-LuminoxMeasurementTypeValue = Union[float, int, str]
-"""A typing hint for all possible LuminoxMeasurementType values as read in  either
-streaming mode or in a polling mode with `LuminoxMeasurementType.all_measurements`.
-
-Beware: has to be manually kept in sync with `LuminoxMeasurementType` instances
-`cast_type` attribute values.
-"""
-
-
-LuminoxMeasurementTypeDict = Dict[
-    Union[str, "LuminoxMeasurementType"], LuminoxMeasurementTypeValue
-]
-"""A typing hint for a dictionary holding LuminoxMeasurementType values. Keys are
-allowed as strings because `LuminoxMeasurementType` is of a `StrEnumBase` type.
-"""
-
-
-class LuminoxMeasurementType(ValueEnum):
-    """
-    Measurement types for `LuminoxOutputMode.polling`.
-
-    The `all_measurements` type will read values for the actual measurement types
-    as given in `LuminoxOutputMode.all_measurements_types()`; it parses multiple
-    single values using regexp's for other measurement types, therefore, no regexp is
-    defined for this measurement type.
-    """
-
-    _init_ = "value cast_type value_re"
-    partial_pressure_o2 = "O", float, r"[0-9]{4}.[0-9]"
-    percent_o2 = "%", float, r"[0-9]{3}.[0-9]{2}"
-    temperature_sensor = "T", float, r"[+-][0-9]{2}.[0-9]"
-    barometric_pressure = "P", int, r"[0-9]{4}"
-    sensor_status = "e", int, r"[0-9]{4}"
-    date_of_manufacture = "# 0", str, r"[0-9]{5} [0-9]{5}"
-    serial_number = "# 1", str, r"[0-9]{5} [0-9]{5}"
-    software_revision = "# 2", str, r"[0-9]{5}"
-    all_measurements = "A", str, None
-
-    @classmethod
-    def all_measurements_types(cls) -> Tuple["LuminoxMeasurementType", ...]:
-        """
-        A tuple of `LuminoxMeasurementType` enum instances which are actual
-        measurements, i.e. not date of manufacture or software revision.
-        """
-        return cast(
-            Tuple["LuminoxMeasurementType", ...],
-            (
-                cls.partial_pressure_o2,
-                cls.temperature_sensor,
-                cls.barometric_pressure,
-                cls.percent_o2,
-                cls.sensor_status,
-            ),
-        )
-
-    @property
-    def command(self) -> str:
-        return self.value.split(" ")[0]
-
-    def parse_read_measurement_value(
-        self, read_txt: str
-    ) -> Union[LuminoxMeasurementTypeDict, LuminoxMeasurementTypeValue]:
-        if self is LuminoxMeasurementType.all_measurements:
-            return {
-                measurement: measurement._parse_single_measurement_value(read_txt)
-                for measurement in LuminoxMeasurementType.all_measurements_types()
-            }
-        return self._parse_single_measurement_value(read_txt)
-
-    def _parse_single_measurement_value(
-        self, read_txt: str
-    ) -> LuminoxMeasurementTypeValue:
-
-        parsed_data: List[str] = re.findall(f"{self.command} {self.value_re}", read_txt)
-        if len(parsed_data) != 1:
-            self._parse_error(parsed_data)
-
-        parsed_measurement: str = parsed_data[0]
-        try:
-            parsed_value = self.cast_type(
-                # don't check for empty match - we know already that there is one
-                re.search(self.value_re, parsed_measurement).group()  # type: ignore
-            )
-        except ValueError as e:
-            logger.error(str(e), exc_info=e)
-            self._parse_error(parsed_data)
-
-        return parsed_value
-
-    def _parse_error(self, parsed_data: List[str]) -> None:
-        err_msg = (
-            f"Expected measurement value for {self.name.replace('_', ' ')} of type "
-            f'{self.cast_type}; instead tyring to parse: "{parsed_data}"'
-        )
-        logger.error(err_msg)
-        raise LuminoxMeasurementTypeError(err_msg)
-
-
-@configdataclass
-class LuminoxSerialCommunicationConfig(SerialCommunicationConfig):
-    #: Baudrate for SST Luminox is 9600 baud
-    baudrate: int = 9600
-
-    #: SST Luminox does not use parity
-    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
-
-    #: SST Luminox does use one stop bit
-    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
-
-    #: One byte is eight bits long
-    bytesize: Union[
-        int, SerialCommunicationBytesize
-    ] = SerialCommunicationBytesize.EIGHTBITS
-
-    #: The terminator is CR LF
-    terminator: bytes = b"\r\n"
-
-    #: use 3 seconds timeout as default
-    timeout: Number = 3
-
-
-class LuminoxSerialCommunication(SerialCommunication):
-    """
-    Specific communication protocol implementation for the SST Luminox oxygen sensor.
-    Already predefines device-specific protocol parameters in config.
-    """
-
-    @staticmethod
-    def config_cls():
-        return LuminoxSerialCommunicationConfig
-
-
-@configdataclass
-class LuminoxConfig:
-    """
-    Configuration for the SST Luminox oxygen sensor.
-    """
-
-    # wait between set and validation of output mode
-    wait_sec_post_activate: Number = 0.5
-    wait_sec_trials_activate: Number = 0.1
-    nr_trials_activate: int = 5
-
-    def clean_values(self):
-        if self.wait_sec_post_activate <= 0:
-            raise ValueError(
-                "Wait time (sec) post output mode activation must be a positive number."
-            )
-        if self.wait_sec_trials_activate <= 0:
-            raise ValueError(
-                "Re-try wait time (sec) for mode activation must be a positive number."
-            )
-        if self.nr_trials_activate <= 0:
-            raise ValueError(
-                "Trials for mode activation must be a positive integer >=1)."
-            )
-
-
-class Luminox(SingleCommDevice):
-    """
-    Luminox oxygen sensor device class.
-    """
-
-    def __init__(self, com, dev_config=None):
-
-        # Call superclass constructor
-        super().__init__(com, dev_config)
-
-        self.output: Optional[LuminoxOutputMode] = None
-
-    @staticmethod
-    def config_cls():
-        return LuminoxConfig
-
-    @staticmethod
-    def default_com_cls():
-        return LuminoxSerialCommunication
-
-    def start(self) -> None:
-        """
-        Start this device. Opens the communication protocol.
-        """
-
-        logger.info(f"Starting device {self}")
-        super().start()
-
-    def stop(self) -> None:
-        """
-        Stop the device. Closes also the communication protocol.
-        """
-
-        logger.info(f"Stopping device {self}")
-        super().stop()
-
-    def _write(self, value: str) -> None:
-        """
-        Write given `value` string to `self.com`.
-
-        :param value: String value to send.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-
-        self.com.write_text(value)
-
-    def _read(self) -> str:
-        """
-        Read a string value from `self.com`.
-
-        :return: Read text from the serial port, without the trailing terminator,
-            as defined in the communcation protocol configuration.
-        :raises SerialCommunicationIOError: when communication port is not opened
-        """
-        return self.com.read_text().rstrip(self.com.config.terminator_str())
-
-    def activate_output(self, mode: LuminoxOutputMode) -> None:
-        """
-        activate the selected output mode of the Luminox Sensor.
-        :param mode: polling or streaming
-        """
-        with self.com.access_lock:
-            self._write(f"M {mode.value}")
-            # needs a little bit of time ot activate
-            sleep(self.config.wait_sec_post_activate)
-
-            for trial in range(self.config.nr_trials_activate + 1):
-                msg = self._read()
-                if (
-                    not msg == f"M 0{mode.value}"
-                    and trial == self.config.nr_trials_activate
-                ):
-                    err_msg = (
-                        f"Stream mode activation was not possible "
-                        f"after {self.config.nr_trials_activate} trials {self}"
-                    )
-                    logger.error(err_msg)
-                    raise LuminoxOutputModeError(err_msg)
-                if msg == f"M 0{mode.value}":
-                    msg = (
-                        f"Stream mode activation possible "
-                        f"in trial {trial} out of {self.config.nr_trials_activate}"
-                    )
-                    logger.info(msg)
-                    break
-                sleep(self.config.wait_sec_trials_activate)
-
-        self.output = mode
-        logger.info(f"{mode.name} mode activated {self}")
-
-    def read_streaming(self) -> LuminoxMeasurementTypeDict:
-        """
-        Read values of Luminox in the streaming mode. Convert the single string
-        into separate values.
-
-        :return: dictionary with `LuminoxMeasurementType.all_measurements_types()` keys
-            and accordingly type-parsed values.
-        :raises LuminoxOutputModeError: when streaming mode is not activated
-        :raises LuminoxMeasurementTypeError: when any of expected measurement values is
-            not read
-        """
-        if not self.output == LuminoxOutputMode.streaming:
-            err_msg = f"Streaming mode not activated {self}"
-            logger.error(err_msg)
-            raise LuminoxOutputModeError(err_msg)
-
-        read_txt = self._read()
-        return cast(
-            LuminoxMeasurementTypeDict,
-            cast(
-                LuminoxMeasurementType, LuminoxMeasurementType.all_measurements
-            ).parse_read_measurement_value(read_txt),
-        )
-
-    def query_polling(
-        self,
-        measurement: Union[str, LuminoxMeasurementType],
-    ) -> Union[LuminoxMeasurementTypeDict, LuminoxMeasurementTypeValue]:
-        """
-        Query a value or values of Luminox measurements in the polling mode,
-        according to a given measurement type.
-
-        :param measurement: type of measurement
-        :return: value of requested measurement
-        :raises ValueError: when a wrong key for LuminoxMeasurementType is provided
-        :raises LuminoxOutputModeError: when polling mode is not activated
-        :raises LuminoxMeasurementTypeError: when expected measurement value is not read
-        """
-        if not isinstance(measurement, LuminoxMeasurementType):
-            try:
-                measurement = cast(
-                    LuminoxMeasurementType,
-                    LuminoxMeasurementType[measurement],  # type: ignore
-                )
-            except KeyError as e:
-                logger.error(str(e), exc_info=e)
-                measurement = cast(
-                    LuminoxMeasurementType,
-                    LuminoxMeasurementType(measurement),
-                )
-
-        if not self.output == LuminoxOutputMode.polling:
-            err_msg = f"Polling mode not activated {self}"
-            logger.error(err_msg)
-            raise LuminoxOutputModeError(err_msg)
-
-        with self.com.access_lock:
-            self._write(str(measurement))
-            read_txt = self._read()
-        read_value = measurement.parse_read_measurement_value(read_txt)
-        return read_value
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Device class for a SST Luminox Oxygen sensor. This device can measure the oxygen
+concentration between 0 % and 25 %.
+
+Furthermore, it measures the barometric pressure and internal temperature.
+The device supports two operating modes: in streaming mode the device measures all
+parameters every second, in polling mode the device measures only after a query.
+
+Technical specification and documentation for the device can be found a the
+manufacturer's page:
+https://www.sstsensing.com/product/luminox-optical-oxygen-sensors-2/
+"""
+
+import logging
+import re
+from enum import Enum
+from time import sleep
+from typing import Union, Tuple, List, cast, Optional, Dict
+
+from .base import SingleCommDevice, DeviceException
+from ..comm import SerialCommunication, SerialCommunicationConfig
+from ..comm.serial import (
+    SerialCommunicationParity,
+    SerialCommunicationStopbits,
+    SerialCommunicationBytesize,
+)
+from ..configuration import configdataclass
+from ..utils.enum import ValueEnum
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class LuminoxException(DeviceException):
+    """
+    General Exception for Luminox Device.
+    """
+    pass
+
+
+class LuminoxOutputModeError(LuminoxException):
+    """
+    Wrong output mode for requested data
+    """
+
+    pass
+
+
+class LuminoxOutputMode(Enum):
+    """
+    output mode.
+    """
+
+    streaming = 0
+    polling = 1
+
+
+class LuminoxMeasurementTypeError(LuminoxException):
+    """
+    Wrong measurement type for requested data
+    """
+
+    pass
+
+
+LuminoxMeasurementTypeValue = Union[float, int, str]
+"""A typing hint for all possible LuminoxMeasurementType values as read in  either
+streaming mode or in a polling mode with `LuminoxMeasurementType.all_measurements`.
+
+Beware: has to be manually kept in sync with `LuminoxMeasurementType` instances
+`cast_type` attribute values.
+"""
+
+
+LuminoxMeasurementTypeDict = Dict[
+    Union[str, "LuminoxMeasurementType"], LuminoxMeasurementTypeValue
+]
+"""A typing hint for a dictionary holding LuminoxMeasurementType values. Keys are
+allowed as strings because `LuminoxMeasurementType` is of a `StrEnumBase` type.
+"""
+
+
+class LuminoxMeasurementType(ValueEnum, init="value cast_type value_re"):  # type:ignore
+    """
+    Measurement types for `LuminoxOutputMode.polling`.
+
+    The `all_measurements` type will read values for the actual measurement types
+    as given in `LuminoxOutputMode.all_measurements_types()`; it parses multiple
+    single values using regexp's for other measurement types, therefore, no regexp is
+    defined for this measurement type.
+    """
+
+    partial_pressure_o2 = "O", float, r"[0-9]{4}.[0-9]"
+    percent_o2 = "%", float, r"[0-9]{3}.[0-9]{2}"
+    temperature_sensor = "T", float, r"[+-][0-9]{2}.[0-9]"
+    barometric_pressure = "P", int, r"[0-9]{4}"
+    sensor_status = "e", int, r"[0-9]{4}"
+    date_of_manufacture = "# 0", str, r"[0-9]{5} [0-9]{5}"
+    serial_number = "# 1", str, r"[0-9]{5} [0-9]{5}"
+    software_revision = "# 2", str, r"[0-9]{5}"
+    all_measurements = "A", str, None
+
+    @classmethod
+    def all_measurements_types(cls) -> Tuple["LuminoxMeasurementType", ...]:
+        """
+        A tuple of `LuminoxMeasurementType` enum instances which are actual
+        measurements, i.e. not date of manufacture or software revision.
+        """
+        return cast(
+            Tuple["LuminoxMeasurementType", ...],
+            (
+                cls.partial_pressure_o2,
+                cls.temperature_sensor,
+                cls.barometric_pressure,
+                cls.percent_o2,
+                cls.sensor_status,
+            ),
+        )
+
+    @property
+    def command(self) -> str:
+        return self.value.split(" ")[0]
+
+    def parse_read_measurement_value(
+        self, read_txt: str
+    ) -> Union[LuminoxMeasurementTypeDict, LuminoxMeasurementTypeValue]:
+        if self is LuminoxMeasurementType.all_measurements:
+            return {
+                measurement: measurement._parse_single_measurement_value(read_txt)
+                for measurement in LuminoxMeasurementType.all_measurements_types()
+            }
+        return self._parse_single_measurement_value(read_txt)
+
+    def _parse_single_measurement_value(
+        self, read_txt: str
+    ) -> LuminoxMeasurementTypeValue:
+
+        parsed_data: List[str] = re.findall(f"{self.command} {self.value_re}", read_txt)
+        if len(parsed_data) != 1:
+            self._parse_error(parsed_data)
+
+        parsed_measurement: str = parsed_data[0]
+        try:
+            parsed_value = self.cast_type(
+                # don't check for empty match - we know already that there is one
+                re.search(self.value_re, parsed_measurement).group()  # type: ignore
+            )
+        except ValueError as e:
+            logger.error(str(e), exc_info=e)
+            self._parse_error(parsed_data)
+
+        return parsed_value
+
+    def _parse_error(self, parsed_data: List[str]) -> None:
+        err_msg = (
+            f"Expected measurement value for {self.name.replace('_', ' ')} of type "
+            f'{self.cast_type}; instead tyring to parse: "{parsed_data}"'
+        )
+        logger.error(err_msg)
+        raise LuminoxMeasurementTypeError(err_msg)
+
+
+@configdataclass
+class LuminoxSerialCommunicationConfig(SerialCommunicationConfig):
+    #: Baudrate for SST Luminox is 9600 baud
+    baudrate: int = 9600
+
+    #: SST Luminox does not use parity
+    parity: Union[str, SerialCommunicationParity] = SerialCommunicationParity.NONE
+
+    #: SST Luminox does use one stop bit
+    stopbits: Union[int, SerialCommunicationStopbits] = SerialCommunicationStopbits.ONE
+
+    #: One byte is eight bits long
+    bytesize: Union[
+        int, SerialCommunicationBytesize
+    ] = SerialCommunicationBytesize.EIGHTBITS
+
+    #: The terminator is CR LF
+    terminator: bytes = b"\r\n"
+
+    #: use 3 seconds timeout as default
+    timeout: Number = 3
+
+
+class LuminoxSerialCommunication(SerialCommunication):
+    """
+    Specific communication protocol implementation for the SST Luminox oxygen sensor.
+    Already predefines device-specific protocol parameters in config.
+    """
+
+    @staticmethod
+    def config_cls():
+        return LuminoxSerialCommunicationConfig
+
+
+@configdataclass
+class LuminoxConfig:
+    """
+    Configuration for the SST Luminox oxygen sensor.
+    """
+
+    # wait between set and validation of output mode
+    wait_sec_post_activate: Number = 0.5
+    wait_sec_trials_activate: Number = 0.1
+    nr_trials_activate: int = 5
+
+    def clean_values(self):
+        if self.wait_sec_post_activate <= 0:
+            raise ValueError(
+                "Wait time (sec) post output mode activation must be a positive number."
+            )
+        if self.wait_sec_trials_activate <= 0:
+            raise ValueError(
+                "Re-try wait time (sec) for mode activation must be a positive number."
+            )
+        if self.nr_trials_activate <= 0:
+            raise ValueError(
+                "Trials for mode activation must be a positive integer >=1)."
+            )
+
+
+class Luminox(SingleCommDevice):
+    """
+    Luminox oxygen sensor device class.
+    """
+
+    def __init__(self, com, dev_config=None):
+
+        # Call superclass constructor
+        super().__init__(com, dev_config)
+
+        self.output: Optional[LuminoxOutputMode] = None
+
+    @staticmethod
+    def config_cls():
+        return LuminoxConfig
+
+    @staticmethod
+    def default_com_cls():
+        return LuminoxSerialCommunication
+
+    def start(self) -> None:
+        """
+        Start this device. Opens the communication protocol.
+        """
+
+        logger.info(f"Starting device {self}")
+        super().start()
+
+    def stop(self) -> None:
+        """
+        Stop the device. Closes also the communication protocol.
+        """
+
+        logger.info(f"Stopping device {self}")
+        super().stop()
+
+    def _write(self, value: str) -> None:
+        """
+        Write given `value` string to `self.com`.
+
+        :param value: String value to send.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+
+        self.com.write_text(value)
+
+    def _read(self) -> str:
+        """
+        Read a string value from `self.com`.
+
+        :return: Read text from the serial port, without the trailing terminator,
+            as defined in the communcation protocol configuration.
+        :raises SerialCommunicationIOError: when communication port is not opened
+        """
+        return self.com.read_text().rstrip(self.com.config.terminator_str())
+
+    def activate_output(self, mode: LuminoxOutputMode) -> None:
+        """
+        activate the selected output mode of the Luminox Sensor.
+        :param mode: polling or streaming
+        """
+        with self.com.access_lock:
+            self._write(f"M {mode.value}")
+            # needs a little bit of time ot activate
+            sleep(self.config.wait_sec_post_activate)
+
+            for trial in range(self.config.nr_trials_activate + 1):
+                msg = self._read()
+                if (
+                    not msg == f"M 0{mode.value}"
+                    and trial == self.config.nr_trials_activate
+                ):
+                    err_msg = (
+                        f"Stream mode activation was not possible "
+                        f"after {self.config.nr_trials_activate} trials {self}"
+                    )
+                    logger.error(err_msg)
+                    raise LuminoxOutputModeError(err_msg)
+                if msg == f"M 0{mode.value}":
+                    msg = (
+                        f"Stream mode activation possible "
+                        f"in trial {trial} out of {self.config.nr_trials_activate}"
+                    )
+                    logger.info(msg)
+                    break
+                sleep(self.config.wait_sec_trials_activate)
+
+        self.output = mode
+        logger.info(f"{mode.name} mode activated {self}")
+
+    def read_streaming(self) -> LuminoxMeasurementTypeDict:
+        """
+        Read values of Luminox in the streaming mode. Convert the single string
+        into separate values.
+
+        :return: dictionary with `LuminoxMeasurementType.all_measurements_types()` keys
+            and accordingly type-parsed values.
+        :raises LuminoxOutputModeError: when streaming mode is not activated
+        :raises LuminoxMeasurementTypeError: when any of expected measurement values is
+            not read
+        """
+        if not self.output == LuminoxOutputMode.streaming:
+            err_msg = f"Streaming mode not activated {self}"
+            logger.error(err_msg)
+            raise LuminoxOutputModeError(err_msg)
+
+        read_txt = self._read()
+        return cast(
+            LuminoxMeasurementTypeDict,
+            cast(
+                LuminoxMeasurementType, LuminoxMeasurementType.all_measurements
+            ).parse_read_measurement_value(read_txt),
+        )
+
+    def query_polling(
+        self,
+        measurement: Union[str, LuminoxMeasurementType],
+    ) -> Union[LuminoxMeasurementTypeDict, LuminoxMeasurementTypeValue]:
+        """
+        Query a value or values of Luminox measurements in the polling mode,
+        according to a given measurement type.
+
+        :param measurement: type of measurement
+        :return: value of requested measurement
+        :raises ValueError: when a wrong key for LuminoxMeasurementType is provided
+        :raises LuminoxOutputModeError: when polling mode is not activated
+        :raises LuminoxMeasurementTypeError: when expected measurement value is not read
+        """
+        if not isinstance(measurement, LuminoxMeasurementType):
+            try:
+                measurement = cast(
+                    LuminoxMeasurementType,
+                    LuminoxMeasurementType[measurement],  # type: ignore
+                )
+            except KeyError as e:
+                logger.error(str(e), exc_info=e)
+                measurement = cast(
+                    LuminoxMeasurementType,
+                    LuminoxMeasurementType(measurement),
+                )
+
+        if not self.output == LuminoxOutputMode.polling:
+            err_msg = f"Polling mode not activated {self}"
+            logger.error(err_msg)
+            raise LuminoxOutputModeError(err_msg)
+
+        with self.com.access_lock:
+            self._write(str(measurement))
+            read_txt = self._read()
+        read_value = measurement.parse_read_measurement_value(read_txt)
+        return read_value
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/supercube/constants.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/supercube/constants.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,839 +1,839 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Constants, variable names for the Supercube OPC-connected devices.
-"""
-
-import logging
-from typing import cast, Sequence, Sized, Tuple
-
-from aenum import IntEnum, EnumMeta
-
-from hvl_ccb.utils.enum import ValueEnum, unique
-
-logger = logging.getLogger(__name__)
-
-
-@unique
-class SupercubeOpcEndpoint(ValueEnum):
-    """
-    OPC Server Endpoint strings for the supercube variants.
-    """
-
-    A = "Supercube Typ A"
-    B = "Supercube Typ B"
-
-
-# NOTE: super metaclass has to match metaclass of `super(GeneralSupport)`!
-class GeneralSupportMeta(EnumMeta):
-    def __new__(metacls, clsname, bases, clsdict, **kwargs):
-        cls = EnumMeta.__new__(metacls, clsname, bases, clsdict, **kwargs)
-        # BEWARE: keep manually in sync with suffixes of enum instances; opt use dir()
-        cls._port_range = range(1, 7)
-        cls._contact_range = range(1, 3)
-        return cls
-
-
-@unique
-class GeneralSupport(ValueEnum, metaclass=GeneralSupportMeta):
-    """
-    NodeID strings for the support inputs and outputs.
-    """
-
-    in_1_1 = '"Ix_Allg_Support1_1"'
-    in_1_2 = '"Ix_Allg_Support1_2"'
-    in_2_1 = '"Ix_Allg_Support2_1"'
-    in_2_2 = '"Ix_Allg_Support2_2"'
-    in_3_1 = '"Ix_Allg_Support3_1"'
-    in_3_2 = '"Ix_Allg_Support3_2"'
-    in_4_1 = '"Ix_Allg_Support4_1"'
-    in_4_2 = '"Ix_Allg_Support4_2"'
-    in_5_1 = '"Ix_Allg_Support5_1"'
-    in_5_2 = '"Ix_Allg_Support5_2"'
-    in_6_1 = '"Ix_Allg_Support6_1"'
-    in_6_2 = '"Ix_Allg_Support6_2"'
-    out_1_1 = '"Qx_Allg_Support1_1"'
-    out_1_2 = '"Qx_Allg_Support1_2"'
-    out_2_1 = '"Qx_Allg_Support2_1"'
-    out_2_2 = '"Qx_Allg_Support2_2"'
-    out_3_1 = '"Qx_Allg_Support3_1"'
-    out_3_2 = '"Qx_Allg_Support3_2"'
-    out_4_1 = '"Qx_Allg_Support4_1"'
-    out_4_2 = '"Qx_Allg_Support4_2"'
-    out_5_1 = '"Qx_Allg_Support5_1"'
-    out_5_2 = '"Qx_Allg_Support5_2"'
-    out_6_1 = '"Qx_Allg_Support6_1"'
-    out_6_2 = '"Qx_Allg_Support6_2"'
-
-    @classmethod
-    def port_range(cls) -> Sequence[int]:
-        """
-        Integer range of all ports.
-
-        :return: sequence of port numbers
-        """
-        return cls._port_range
-
-    @classmethod
-    def contact_range(cls) -> Sequence[int]:
-        """
-        Integer range of all contacts.
-
-        :return: sequence of contact numbers
-        """
-        return cls._contact_range
-
-    @classmethod
-    def _validate_port_contact_numbers(cls, port: int, contact: int):
-        """
-        Validate earthing stick number.
-
-        :param port: the port number
-        :param contact: the contact number
-        :raises ValueError: when port or contact number is not valid
-        """
-        if port not in cls.port_range():
-            raise ValueError(f"Port number must be one of {list(cls.port_range())}")
-        if contact not in cls.contact_range():
-            raise ValueError(
-                f"Contact number must be one of {list(cls.contact_range())}"
-            )
-
-    @classmethod
-    def output(cls, port: int, contact: int):
-        """
-        Get the NodeID string for a support output.
-
-        :param port: the desired port (1..6)
-        :param contact: the desired contact at the port (1..2)
-        :return: the node id string
-        :raises ValueError: when port or contact number is not valid
-        """
-        cls._validate_port_contact_numbers(port, contact)
-        return getattr(cls, f"out_{port}_{contact}")
-
-    @classmethod
-    def input(cls, port: int, contact: int):
-        """
-        Get the NodeID string for a support input.
-
-        :param port: the desired port (1..6)
-        :param contact: the desired contact at the port (1..2)
-        :return: the node id string
-        :raises ValueError: when port or contact number is not valid
-        """
-        cls._validate_port_contact_numbers(port, contact)
-        return getattr(cls, f"in_{port}_{contact}")
-
-
-@unique
-class BreakdownDetection(ValueEnum):
-    """
-    Node ID strings for the breakdown detection.
-
-    TODO: these variable NodeIDs are not tested and/or correct yet.
-    """
-
-    #: Boolean read-only variable indicating whether breakdown detection and fast
-    #: switchoff is enabled in the system or not.
-    activated = '"Ix_Allg_Breakdown_activated"'
-
-    #: Boolean read-only variable telling whether the fast switch-off has triggered.
-    #: This can also be seen using the safety circuit state, therefore no method is
-    #: implemented to read this out directly.
-    triggered = '"Ix_Allg_Breakdown_triggered"'
-
-    #: Boolean writable variable to reset the fast switch-off. Toggle to re-enable.
-    reset = '"Qx_Allg_Breakdown_reset"'
-
-
-@unique
-class GeneralSockets(ValueEnum):
-    """
-    NodeID strings for the power sockets (3x T13 and 1xCEE16).
-    """
-
-    #: SEV T13 socket No. 1 (writable boolean).
-    t13_1 = '"Qx_Allg_Socket_T13_1"'
-
-    #: SEV T13 socket No. 2 (writable boolean).
-    t13_2 = '"Qx_Allg_Socket_T13_2"'
-
-    #: SEV T13 socket No. 3 (writable boolean).
-    t13_3 = '"Qx_Allg_Socket_T13_3"'
-
-    #: CEE16 socket (writeable boolean).
-    cee16 = '"Qx_Allg_Socket_CEE16"'
-
-
-T13_SOCKET_PORTS = (1, 2, 3)
-"""
-Port numbers of SEV T13 power socket
-"""
-
-
-@unique
-class Safety(ValueEnum):
-    """
-    NodeID strings for the basic safety circuit status and green/red switches "ready"
-    and "operate".
-    """
-
-    #: Status is a read-only integer containing the state number of the
-    #: supercube-internal state machine. The values correspond to numbers in
-    #: :class:`SafetyStatus`.
-    status = '"DB_Safety_Circuit"."si_safe_status"'
-
-    #: Writable boolean for switching to Red Ready (locked, HV off) state.
-    switch_to_ready = '"DB_Safety_Circuit"."sx_safe_switch_to_ready"'
-
-    #: Writable boolean for switching to Red Operate (locket, HV on) state.
-    switch_to_operate = '"DB_Safety_Circuit"."sx_safe_switch_to_operate"'
-
-
-class SafetyStatus(IntEnum):
-    """
-    Safety status values that are possible states returned from
-    :meth:`hvl_ccb.dev.supercube.base.Supercube.get_status`. These
-    values correspond to the states of the Supercube's safety circuit statemachine.
-    """
-
-    #: System is initializing or booting.
-    Initializing = 0
-
-    #: System is safe, lamps are green and some safety elements are not in place such
-    #: that it cannot be switched to red currently.
-    GreenNotReady = 1
-
-    #: System is safe and all safety elements are in place to be able to switch to
-    #: *ready*.
-    GreenReady = 2
-
-    #: System is locked in red state and *ready* to go to *operate* mode.
-    RedReady = 3
-
-    #: System is locked in red state and in *operate* mode, i.e. high voltage on.
-    RedOperate = 4
-
-    #: Fast turn off triggered and switched off the system. Reset FSO to go back to a
-    #: normal state.
-    QuickStop = 5
-
-    #: System is in error mode.
-    Error = 6
-
-
-@unique
-class Power(ValueEnum):
-    """
-    Variable NodeID strings concerning power data.
-
-    TODO: these variable NodeIDs are not tested and/or correct yet, they don't exist
-        yet on Supercube side.
-    """
-
-    #: Primary voltage in volts, measured by the frequency converter at its output.
-    #: (read-only)
-    voltage_primary = "Qr_Power_FU_actual_Voltage"
-
-    #: Primary current in ampere, measured by the frequency converter. (read-only)
-    current_primary = "Qr_Power_FU_actual_Current"
-
-    #: Power setup that is configured using the Supercube HMI. The value corresponds to
-    #: the ones in :class:`PowerSetup`. (read-only)
-    setup = "Qi_Power_Setup"
-
-    #: Voltage slope in V/s.
-    voltage_slope = "Ir_Power_dUdt"
-
-    #: Target voltage setpoint in V.
-    voltage_target = "Ir_Power_Target_Voltage"
-
-    #: Maximum voltage allowed by the current experimental setup. (read-only)
-    voltage_max = "Iw_Power_max_Voltage"
-
-    #: Frequency converter output frequency. (read-only)
-    frequency = "Ir_Power_FU_Frequency"
-
-
-class PowerSetup(IntEnum):
-    """
-    Possible power setups corresponding to the value of variable :attr:`Power.setup`.
-    """
-
-    #: No safety switches, use only safety components (doors, fence, earthing...)
-    #: without any power.
-    NoPower = 0
-
-    #: External power supply fed through blue CEE32 input using isolation transformer
-    #: and safety switches of the Supercube, or using an external safety switch
-    #: attached to the Supercube Type B.
-    External = 1
-
-    #: AC voltage with MWB transformer set to 50kV maximum voltage.
-    AC_SingleStage_50kV = 2
-
-    #: AC voltage with MWB transformer set to 100kV maximum voltage.
-    AC_SingleStage_100kV = 3
-
-    #: AC voltage with two MWB transformers, one at 100kV and the other at 50kV,
-    #: resulting in a total maximum voltage of 150kV.
-    AC_DoubleStage_150kV = 4
-
-    #: AC voltage with two MWB transformers both at 100kV, resulting in a total
-    #: maximum voltage of 200kV
-    AC_DoubleStage_200kV = 5
-
-    #: Internal usage of the frequency converter, controlling to the primary voltage
-    #: output of the supercube itself (no measurement transformer used)
-    Internal = 6
-
-    #: DC voltage with one AC transformer set to 100kV AC, resulting in 140kV DC
-    DC_SingleStage_140kV = 7
-
-    #: DC voltage with two AC transformers set to 100kV AC each, resulting in 280kV
-    #: DC in total (or a single stage transformer with Greinacher voltage doubling
-    #: rectifier)
-    DC_DoubleStage_280kV = 8
-
-
-class _PrefixedNumbersEnumBase(ValueEnum):
-    """
-    Base class for enums with "{prefix}{n}" instance names, where n=1..N.
-    """
-
-    @classmethod
-    def range(cls) -> Sequence[int]:
-        """
-        Integer range of all channels.
-
-        :return: sequence of channel numbers
-        """
-        return range(1, len(cast(Sized, cls)) + 1)
-
-    @classmethod
-    def _validate_number(cls, number: int):
-        """
-        Validate enum instance number.
-
-        :param number: the enum instance number (1..N)
-        :raises ValueError: when enum instance number is not in 1..N range
-        """
-        if number not in cls.range():
-            raise ValueError(
-                f"{cls._prefix()} number must be one of {list(cls.range())}"
-            )
-
-    @classmethod
-    def _prefix(cls) -> str:
-        """
-        Enum instances name prefix: "{prefix}{n}"
-
-        :return: enum instances prefix string
-        """
-        raise NotImplementedError("Implement in subclass")
-
-    @property
-    def number(self) -> int:
-        """
-        Get corresponding enum instance number.
-
-        :return: enum instance number (1..N)
-        """
-        # Py >=3.9: self.name.removeprefix()
-        return int(self.name[len(self._prefix()):])
-
-    # no type return as it would be a arguably too complex/obscure;
-    # cf. https://github.com/python/typing/issues/58#issuecomment-326240794
-    @classmethod
-    def get(cls, number: int):
-        """
-        Get the enum instance for a given number.
-
-        :param number: the instance number (1..N)
-        :return: the enum instance for the given number.
-        :raises ValueError: when instance number is not in the 1..N range
-        """
-        cls._validate_number(number)
-        return getattr(cls, f"{cls._prefix()}{number}")
-
-
-class _InputEnumBase(_PrefixedNumbersEnumBase):
-    """
-    Base class for enums with "input_{n}" instance names, where n=1..N.
-    """
-
-    @classmethod
-    def _prefix(cls) -> str:
-        return "input_"
-
-    @classmethod
-    def input(cls, channel: int):
-        """
-        Get the enum instance for a given channel number.
-
-        :param channel: the channel number (1..N)
-        :return: the enum instance for the given channel.
-        :raises ValueError: when channel number is not in the 1..N range
-        """
-        return cls.get(channel)
-
-
-MeasurementsScaledInput = unique(
-    _InputEnumBase(
-        "MeasurementsScaledInput",
-        {
-            f"{_InputEnumBase._prefix()}{n}":
-                f'"DB_Measurements"."si_scaled_Voltage_Input_{n}"'
-            for n in range(1, 5)
-        },
-    )
-)
-"""
-Variable NodeID strings for the four analog BNC inputs for measuring voltage.
-The voltage returned in these variables is already scaled with the set ratio,
-which can be read using the variables in :class:`MeasurementsDividerRatio`.
-"""
-
-
-MeasurementsDividerRatio = unique(
-    _InputEnumBase(
-        "MeasurementsDividerRatio",
-        {
-            f"{_InputEnumBase._prefix()}{n}":
-                f'"DB_Measurements"."si_Divider_Ratio_{n}"'
-            for n in range(1, 5)
-        },
-    )
-)
-"""
-Variable NodeID strings for the measurement input scaling ratios. These ratios
-are defined in the Supercube HMI setup and are provided in the python module here
-to be able to read them out, allowing further calculations.
-"""
-
-
-class EarthingStickStatus(IntEnum):
-    """
-    Status of an earthing stick. These are the possible values in the status integer
-    e.g. in :attr:`EarthingStick.status_1`.
-    """
-
-    #: Earthing stick is deselected and not enabled in safety circuit. To get out of
-    #: this state, the earthing has to be enabled in the Supercube HMI setup.
-    inactive = 0
-
-    #: Earthing is closed (safe).
-    closed = 1
-
-    #: Earthing is open (not safe).
-    open = 2
-
-    #: Earthing is in error, e.g. when the stick did not close correctly or could not
-    #: open.
-    error = 3
-
-
-class EarthingStickOperatingStatus(IntEnum):
-    """
-    Operating Status for an earthing stick. Stick can be used in auto or manual mode.
-    """
-
-    auto = 0
-    manual = 1
-
-
-class EarthingStickOperation(IntEnum):
-    """
-    Operation of the earthing stick in manual operating mode. Can be closed of opened.
-    """
-
-    open = 0
-    close = 1
-
-
-# NOTE: super metaclass has to match metaclass of `super(EarthingStick)`!
-class EarthingStickMeta(EnumMeta):
-    def __new__(metacls, clsname, bases, clsdict, **kwargs):
-        cls = EnumMeta.__new__(metacls, clsname, bases, clsdict, **kwargs)
-        # BEWARE: keep manually in sync with suffixes of enum instances; opt use dir()
-        cls._range = range(1, 7)
-        cls._statuses = tuple(getattr(cls, f"status_{number}") for number in cls._range)
-        cls._manuals = tuple(getattr(cls, f"manual_{number}") for number in cls._range)
-        cls._operating_statuses = tuple(
-            getattr(cls, f"operating_status_{number}") for number in cls._range
-        )
-        return cls
-
-
-@unique
-class EarthingStick(ValueEnum, metaclass=EarthingStickMeta):
-    """
-    Variable NodeID strings for all earthing stick statuses (read-only integer) and
-    writable booleans for setting the earthing in manual mode.
-    """
-
-    status_1 = '"DB_Safety_Circuit"."Earthstick_1"."si_HMI_Status"'
-    status_2 = '"DB_Safety_Circuit"."Earthstick_2"."si_HMI_Status"'
-    status_3 = '"DB_Safety_Circuit"."Earthstick_3"."si_HMI_Status"'
-    status_4 = '"DB_Safety_Circuit"."Earthstick_4"."si_HMI_Status"'
-    status_5 = '"DB_Safety_Circuit"."Earthstick_5"."si_HMI_Status"'
-    status_6 = '"DB_Safety_Circuit"."Earthstick_6"."si_HMI_Status"'
-
-    manual_1 = '"DB_Safety_Circuit"."Earthstick_1"."sx_earthing_manually"'
-    manual_2 = '"DB_Safety_Circuit"."Earthstick_2"."sx_earthing_manually"'
-    manual_3 = '"DB_Safety_Circuit"."Earthstick_3"."sx_earthing_manually"'
-    manual_4 = '"DB_Safety_Circuit"."Earthstick_4"."sx_earthing_manually"'
-    manual_5 = '"DB_Safety_Circuit"."Earthstick_5"."sx_earthing_manually"'
-    manual_6 = '"DB_Safety_Circuit"."Earthstick_6"."sx_earthing_manually"'
-
-    operating_status_1 = '"DB_Safety_Circuit"."Earthstick_1"."sx_manual_control_active"'
-    operating_status_2 = '"DB_Safety_Circuit"."Earthstick_2"."sx_manual_control_active"'
-    operating_status_3 = '"DB_Safety_Circuit"."Earthstick_3"."sx_manual_control_active"'
-    operating_status_4 = '"DB_Safety_Circuit"."Earthstick_4"."sx_manual_control_active"'
-    operating_status_5 = '"DB_Safety_Circuit"."Earthstick_5"."sx_manual_control_active"'
-    operating_status_6 = '"DB_Safety_Circuit"."Earthstick_6"."sx_manual_control_active"'
-
-    @property
-    def number(self) -> int:
-        """
-        Get corresponding earthing stick number.
-
-        :return: earthing stick number (1..6)
-        """
-        return int(self.name.rpartition("_")[-1])
-
-    @classmethod
-    def range(cls) -> Sequence[int]:
-        """
-        Integer range of all earthing sticks.
-
-        :return: sequence of earthing sticks numbers
-        """
-        return cls._range
-
-    @classmethod
-    def _validate_earthing_stick_number(cls, number: int):
-        """
-        Validate earthing stick number.
-
-        :param number: the earthing stick number
-        :raises ValueError: when earthing stick number is not valid
-        """
-        if number not in cls.range():
-            raise ValueError(
-                f"Earthing stick number must be one of {list(cls.range())}"
-            )
-
-    @classmethod
-    def statuses(cls) -> Tuple["EarthingStick", ...]:
-        """
-        Get all earthing stick status instances.
-
-        :return: tuple of status instances
-        """
-        return cls._statuses
-
-    @classmethod
-    def status(cls, number: int) -> "EarthingStick":
-        """
-        Get the status enum instance for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the status instance
-        :raises ValueError: when earthing stick number is not valid
-        """
-        cls._validate_earthing_stick_number(number)
-        return cls.statuses()[number - 1]
-
-    @classmethod
-    def manuals(cls) -> Tuple["EarthingStick", ...]:
-        """
-        Get all earthing stick manual instances.
-
-        :return: tuple of manual instances
-        """
-        return cls._manuals
-
-    @classmethod
-    def manual(cls, number: int):
-        """
-        Get the manual enum instance for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the manual instance
-        :raises ValueError: when earthing stick number is not valid
-        """
-        cls._validate_earthing_stick_number(number)
-        return cls.manuals()[number - 1]
-
-    @classmethod
-    def operating_statuses(cls) -> Tuple["EarthingStick", ...]:
-        """
-        Get all earthing stick operating status instances.
-
-        :return: tuple of operating status instances
-        """
-        return cls._operating_statuses
-
-    @classmethod
-    def operating_status(cls, number: int):
-        """
-        Get the operating status enum instance for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the operating status instance
-        :raises ValueError: when earthing stick number is not valid
-        """
-        cls._validate_earthing_stick_number(number)
-        return cls.operating_statuses()[number - 1]
-
-
-@unique
-class Errors(ValueEnum):
-    """
-    Variable NodeID strings for information regarding error, warning and message
-    handling.
-    """
-
-    #: Boolean read-only variable telling if a message is active.
-    message = '"DB_Message_Buffer"."Info_active"'
-
-    #: Boolean read-only variable telling if a warning is active.
-    warning = '"DB_Message_Buffer"."Warning_active"'
-
-    #: Boolean read-only variable telling if a stop is active.
-    stop = '"DB_Message_Buffer"."Stop_active"'
-
-    #: Writable boolean for the error quit button.
-    quit = '"DB_Message_Buffer"."Reset_button"'
-
-
-class _AlarmEnumBase(_PrefixedNumbersEnumBase):
-    """
-    Base class for enums with "Alarm{n}" instance names, where n=1..N.
-    """
-
-    @classmethod
-    def _prefix(cls) -> str:
-        return "Alarm"
-
-    @classmethod
-    def Alarm(cls, number: int):
-        """
-        Get the enum instance for a given alarm number.
-
-        :param number: the alarm number (1..N)
-        :return: the enum instance for the alarm number.
-        :raises ValueError: when alarm number is not in the 1..N range
-        """
-        return cls.get(number)
-
-
-Alarms = unique(
-    _AlarmEnumBase(
-        "Alarms",
-        {f"Alarm{n}": f'"DB_Alarm_HMI"."Alarm{n}"' for n in range(1, 152)},
-    )
-)
-"""
-Alarms enumeration containing all variable NodeID strings for the alarm array.
-"""
-
-
-class DoorStatus(IntEnum):
-    """
-    Possible status values for doors.
-    """
-
-    #: not enabled in Supercube HMI setup, this door is not supervised.
-    inactive = 0
-
-    #: Door is open.
-    open = 1
-
-    #: Door is closed, but not locked.
-    closed = 2
-
-    #: Door is closed and locked (safe state).
-    locked = 3
-
-    #: Door has an error or was opened in locked state (either with emergency stop or
-    #: from the inside).
-    error = 4
-
-
-class EarthingRodStatus(IntEnum):
-    """
-    Possible status values for earthing rods.
-    """
-
-    #: earthing rod is somewhere in the experiment
-    #: and blocks the start of the experiment
-    experiment_blocked = 0
-
-    #: earthing rod is hanging next to the door, experiment is ready to operate
-    experiment_ready = 1
-
-
-class _DoorEnumBase(_PrefixedNumbersEnumBase):
-    """
-    Base class for enums with "status_{n}" instance names, where n=1..N is the door
-    number.
-    """
-
-    @classmethod
-    def _prefix(cls) -> str:
-        return "status_"
-
-    @classmethod
-    def status(cls, door: int):
-        """
-        Get the enum instance for a given door number.
-
-        :param number: the door number (1..N)
-        :return: the enum instance for the given door number.
-        :raises ValueError: when door number is not in the 1..N range
-        """
-        return cls.get(door)
-
-
-Door = unique(
-    _DoorEnumBase(
-        "Door",
-        {
-            f"{_DoorEnumBase._prefix()}{n}":
-                f'"DB_Safety_Circuit"."Door_{n}"."si_HMI_status"'
-            for n in range(1, 4)
-        },
-    )
-)
-"""
-Variable NodeID strings for doors.
-"""
-
-EarthingRod = unique(
-    _DoorEnumBase(
-        "EarthingRod",
-        {
-            f"{_DoorEnumBase._prefix()}{n}":
-                f'"DB_Safety_Circuit"."Door_{n}"."Ix_earthingrod"'
-            for n in range(1, 4)
-        },
-    )
-)
-"""
-Variable NodeID strings for earthing rods.
-"""
-
-
-class AlarmText(ValueEnum):
-    """
-    This enumeration contains textual representations for all error classes (stop,
-    warning and message) of the Supercube system. Use the :meth:`AlarmText.get`
-    method to retrieve the enum of an alarm number.
-    """
-
-    # Safety elements
-    Alarm1 = "STOP Emergency Stop 1"
-    Alarm2 = "STOP Emergency Stop 2"
-    Alarm3 = "STOP Emergency Stop 3"
-    Alarm4 = "STOP Safety Switch 1 error"
-    Alarm5 = "STOP Safety Switch 2 error"
-    Alarm6 = "STOP Door 1 lock supervision"
-    Alarm7 = "STOP Door 2 lock supervision"
-    Alarm8 = "STOP Door 3 lock supervision"
-    Alarm9 = "STOP Earthing stick 1 error while opening"
-    Alarm10 = "STOP Earthing stick 2 error while opening"
-    Alarm11 = "STOP Earthing stick 3 error while opening"
-    Alarm12 = "STOP Earthing stick 4 error while opening"
-    Alarm13 = "STOP Earthing stick 5 error while opening"
-    Alarm14 = "STOP Earthing stick 6 error while opening"
-    Alarm15 = "STOP Earthing stick 1 error while closing"
-    Alarm16 = "STOP Earthing stick 2 error while closing"
-    Alarm17 = "STOP Earthing stick 3 error while closing"
-    Alarm18 = "STOP Earthing stick 4 error while closing"
-    Alarm19 = "STOP Earthing stick 5 error while closing"
-    Alarm20 = "STOP Earthing stick 6 error while closing"
-    Alarm21 = "STOP Safety fence 1"
-    Alarm22 = "STOP Safety fence 2"
-    Alarm23 = "STOP OPC connection error"
-    Alarm24 = "STOP Grid power failure"
-    Alarm25 = "STOP UPS failure"
-    Alarm26 = "STOP 24V PSU failure"
-
-    # Doors
-    Alarm41 = "WARNING Door 1: Use earthing rod!"
-    Alarm42 = "MESSAGE Door 1: Earthing rod is still in setup."
-    Alarm43 = "WARNING Door 2: Use earthing rod!"
-    Alarm44 = "MESSAGE Door 2: Earthing rod is still in setup."
-    Alarm45 = "WARNING Door 3: Use earthing rod!"
-    Alarm46 = "MESSAGE Door 3: Earthing rod is still in setup."
-
-    # General
-    Alarm47 = "MESSAGE UPS charge < 85%"
-    Alarm48 = "MESSAGE UPS running on battery"
-
-    # generic not defined alarm text
-    not_defined = "NO ALARM TEXT DEFINED"
-
-    @classmethod
-    def get(cls, alarm: int):
-        """
-        Get the attribute of this enum for an alarm number.
-
-        :param alarm: the alarm number
-        :return: the enum for the desired alarm number
-        """
-
-        try:
-            return getattr(cls, f"Alarm{alarm}")
-        except AttributeError:
-            return cls.not_defined
-
-
-class OpcControl(ValueEnum):
-    """
-    Variable NodeID strings for supervision of the OPC connection from the
-    controlling workstation to the Supercube.
-    """
-
-    #: writable boolean to enable OPC remote control and display a message window on
-    #: the Supercube HMI.
-    active = '"DB_OPC_Connection"."sx_OPC_active"'
-    live = '"DB_OPC_Connection"."sx_OPC_lifebit"'
-
-
-class _LineEnumBase(_PrefixedNumbersEnumBase):
-    """
-    Base class for enums with "input_{n}" instance names, where n=1..N.
-    """
-
-    @classmethod
-    def _prefix(cls) -> str:
-        return "line_"
-
-    @classmethod
-    def line(cls, number: int):
-        """
-        Get the enum instance for a given line number.
-
-        :param number: the line number (1..M)
-        :return: the enum instance for the given line number.
-        :raises ValueError: when line number is not in the 1..N range
-        """
-        return cls.get(number)
-
-
-MessageBoard = unique(
-    _LineEnumBase(
-        "MessageBoard",
-        {
-            f"{_LineEnumBase._prefix()}{n}": f'"DB_OPC_Connection"."Is_status_Line_{n}"'
-            for n in range(1, 16)
-        },
-    )
-)
-"""
-Variable NodeID strings for message board lines.
-"""
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Constants, variable names for the Supercube OPC-connected devices.
+"""
+
+import logging
+from typing import cast, Sequence, Sized, Tuple
+
+from aenum import IntEnum, EnumMeta
+
+from hvl_ccb.utils.enum import ValueEnum, unique
+
+logger = logging.getLogger(__name__)
+
+
+@unique
+class SupercubeOpcEndpoint(ValueEnum):
+    """
+    OPC Server Endpoint strings for the supercube variants.
+    """
+
+    A = "Supercube Typ A"
+    B = "Supercube Typ B"
+
+
+# NOTE: super metaclass has to match metaclass of `super(GeneralSupport)`!
+class GeneralSupportMeta(EnumMeta):
+    def __new__(metacls, clsname, bases, clsdict, **kwargs):
+        cls = EnumMeta.__new__(metacls, clsname, bases, clsdict, **kwargs)
+        # BEWARE: keep manually in sync with suffixes of enum instances; opt use dir()
+        cls._port_range = range(1, 7)
+        cls._contact_range = range(1, 3)
+        return cls
+
+
+@unique
+class GeneralSupport(ValueEnum, metaclass=GeneralSupportMeta):
+    """
+    NodeID strings for the support inputs and outputs.
+    """
+
+    in_1_1 = '"Ix_Allg_Support1_1"'
+    in_1_2 = '"Ix_Allg_Support1_2"'
+    in_2_1 = '"Ix_Allg_Support2_1"'
+    in_2_2 = '"Ix_Allg_Support2_2"'
+    in_3_1 = '"Ix_Allg_Support3_1"'
+    in_3_2 = '"Ix_Allg_Support3_2"'
+    in_4_1 = '"Ix_Allg_Support4_1"'
+    in_4_2 = '"Ix_Allg_Support4_2"'
+    in_5_1 = '"Ix_Allg_Support5_1"'
+    in_5_2 = '"Ix_Allg_Support5_2"'
+    in_6_1 = '"Ix_Allg_Support6_1"'
+    in_6_2 = '"Ix_Allg_Support6_2"'
+    out_1_1 = '"Qx_Allg_Support1_1"'
+    out_1_2 = '"Qx_Allg_Support1_2"'
+    out_2_1 = '"Qx_Allg_Support2_1"'
+    out_2_2 = '"Qx_Allg_Support2_2"'
+    out_3_1 = '"Qx_Allg_Support3_1"'
+    out_3_2 = '"Qx_Allg_Support3_2"'
+    out_4_1 = '"Qx_Allg_Support4_1"'
+    out_4_2 = '"Qx_Allg_Support4_2"'
+    out_5_1 = '"Qx_Allg_Support5_1"'
+    out_5_2 = '"Qx_Allg_Support5_2"'
+    out_6_1 = '"Qx_Allg_Support6_1"'
+    out_6_2 = '"Qx_Allg_Support6_2"'
+
+    @classmethod
+    def port_range(cls) -> Sequence[int]:
+        """
+        Integer range of all ports.
+
+        :return: sequence of port numbers
+        """
+        return cls._port_range
+
+    @classmethod
+    def contact_range(cls) -> Sequence[int]:
+        """
+        Integer range of all contacts.
+
+        :return: sequence of contact numbers
+        """
+        return cls._contact_range
+
+    @classmethod
+    def _validate_port_contact_numbers(cls, port: int, contact: int):
+        """
+        Validate earthing stick number.
+
+        :param port: the port number
+        :param contact: the contact number
+        :raises ValueError: when port or contact number is not valid
+        """
+        if port not in cls.port_range():
+            raise ValueError(f"Port number must be one of {list(cls.port_range())}")
+        if contact not in cls.contact_range():
+            raise ValueError(
+                f"Contact number must be one of {list(cls.contact_range())}"
+            )
+
+    @classmethod
+    def output(cls, port: int, contact: int):
+        """
+        Get the NodeID string for a support output.
+
+        :param port: the desired port (1..6)
+        :param contact: the desired contact at the port (1..2)
+        :return: the node id string
+        :raises ValueError: when port or contact number is not valid
+        """
+        cls._validate_port_contact_numbers(port, contact)
+        return getattr(cls, f"out_{port}_{contact}")
+
+    @classmethod
+    def input(cls, port: int, contact: int):
+        """
+        Get the NodeID string for a support input.
+
+        :param port: the desired port (1..6)
+        :param contact: the desired contact at the port (1..2)
+        :return: the node id string
+        :raises ValueError: when port or contact number is not valid
+        """
+        cls._validate_port_contact_numbers(port, contact)
+        return getattr(cls, f"in_{port}_{contact}")
+
+
+@unique
+class BreakdownDetection(ValueEnum):
+    """
+    Node ID strings for the breakdown detection.
+
+    TODO: these variable NodeIDs are not tested and/or correct yet.
+    """
+
+    #: Boolean read-only variable indicating whether breakdown detection and fast
+    #: switchoff is enabled in the system or not.
+    activated = '"Ix_Allg_Breakdown_activated"'
+
+    #: Boolean read-only variable telling whether the fast switch-off has triggered.
+    #: This can also be seen using the safety circuit state, therefore no method is
+    #: implemented to read this out directly.
+    triggered = '"Ix_Allg_Breakdown_triggered"'
+
+    #: Boolean writable variable to reset the fast switch-off. Toggle to re-enable.
+    reset = '"Qx_Allg_Breakdown_reset"'
+
+
+@unique
+class GeneralSockets(ValueEnum):
+    """
+    NodeID strings for the power sockets (3x T13 and 1xCEE16).
+    """
+
+    #: SEV T13 socket No. 1 (writable boolean).
+    t13_1 = '"Qx_Allg_Socket_T13_1"'
+
+    #: SEV T13 socket No. 2 (writable boolean).
+    t13_2 = '"Qx_Allg_Socket_T13_2"'
+
+    #: SEV T13 socket No. 3 (writable boolean).
+    t13_3 = '"Qx_Allg_Socket_T13_3"'
+
+    #: CEE16 socket (writeable boolean).
+    cee16 = '"Qx_Allg_Socket_CEE16"'
+
+
+T13_SOCKET_PORTS = (1, 2, 3)
+"""
+Port numbers of SEV T13 power socket
+"""
+
+
+@unique
+class Safety(ValueEnum):
+    """
+    NodeID strings for the basic safety circuit status and green/red switches "ready"
+    and "operate".
+    """
+
+    #: Status is a read-only integer containing the state number of the
+    #: supercube-internal state machine. The values correspond to numbers in
+    #: :class:`SafetyStatus`.
+    status = '"DB_Safety_Circuit"."si_safe_status"'
+
+    #: Writable boolean for switching to Red Ready (locked, HV off) state.
+    switch_to_ready = '"DB_Safety_Circuit"."sx_safe_switch_to_ready"'
+
+    #: Writable boolean for switching to Red Operate (locket, HV on) state.
+    switch_to_operate = '"DB_Safety_Circuit"."sx_safe_switch_to_operate"'
+
+
+class SafetyStatus(IntEnum):
+    """
+    Safety status values that are possible states returned from
+    :meth:`hvl_ccb.dev.supercube.base.Supercube.get_status`. These
+    values correspond to the states of the Supercube's safety circuit statemachine.
+    """
+
+    #: System is initializing or booting.
+    Initializing = 0
+
+    #: System is safe, lamps are green and some safety elements are not in place such
+    #: that it cannot be switched to red currently.
+    GreenNotReady = 1
+
+    #: System is safe and all safety elements are in place to be able to switch to
+    #: *ready*.
+    GreenReady = 2
+
+    #: System is locked in red state and *ready* to go to *operate* mode.
+    RedReady = 3
+
+    #: System is locked in red state and in *operate* mode, i.e. high voltage on.
+    RedOperate = 4
+
+    #: Fast turn off triggered and switched off the system. Reset FSO to go back to a
+    #: normal state.
+    QuickStop = 5
+
+    #: System is in error mode.
+    Error = 6
+
+
+@unique
+class Power(ValueEnum):
+    """
+    Variable NodeID strings concerning power data.
+
+    TODO: these variable NodeIDs are not tested and/or correct yet, they don't exist
+        yet on Supercube side.
+    """
+
+    #: Primary voltage in volts, measured by the frequency converter at its output.
+    #: (read-only)
+    voltage_primary = "Qr_Power_FU_actual_Voltage"
+
+    #: Primary current in ampere, measured by the frequency converter. (read-only)
+    current_primary = "Qr_Power_FU_actual_Current"
+
+    #: Power setup that is configured using the Supercube HMI. The value corresponds to
+    #: the ones in :class:`PowerSetup`. (read-only)
+    setup = "Qi_Power_Setup"
+
+    #: Voltage slope in V/s.
+    voltage_slope = "Ir_Power_dUdt"
+
+    #: Target voltage setpoint in V.
+    voltage_target = "Ir_Power_Target_Voltage"
+
+    #: Maximum voltage allowed by the current experimental setup. (read-only)
+    voltage_max = "Iw_Power_max_Voltage"
+
+    #: Frequency converter output frequency. (read-only)
+    frequency = "Ir_Power_FU_Frequency"
+
+
+class PowerSetup(IntEnum):
+    """
+    Possible power setups corresponding to the value of variable :attr:`Power.setup`.
+    """
+
+    #: No safety switches, use only safety components (doors, fence, earthing...)
+    #: without any power.
+    NoPower = 0
+
+    #: External power supply fed through blue CEE32 input using isolation transformer
+    #: and safety switches of the Supercube, or using an external safety switch
+    #: attached to the Supercube Type B.
+    External = 1
+
+    #: AC voltage with MWB transformer set to 50kV maximum voltage.
+    AC_SingleStage_50kV = 2
+
+    #: AC voltage with MWB transformer set to 100kV maximum voltage.
+    AC_SingleStage_100kV = 3
+
+    #: AC voltage with two MWB transformers, one at 100kV and the other at 50kV,
+    #: resulting in a total maximum voltage of 150kV.
+    AC_DoubleStage_150kV = 4
+
+    #: AC voltage with two MWB transformers both at 100kV, resulting in a total
+    #: maximum voltage of 200kV
+    AC_DoubleStage_200kV = 5
+
+    #: Internal usage of the frequency converter, controlling to the primary voltage
+    #: output of the supercube itself (no measurement transformer used)
+    Internal = 6
+
+    #: DC voltage with one AC transformer set to 100kV AC, resulting in 140kV DC
+    DC_SingleStage_140kV = 7
+
+    #: DC voltage with two AC transformers set to 100kV AC each, resulting in 280kV
+    #: DC in total (or a single stage transformer with Greinacher voltage doubling
+    #: rectifier)
+    DC_DoubleStage_280kV = 8
+
+
+class _PrefixedNumbersEnumBase(ValueEnum):
+    """
+    Base class for enums with "{prefix}{n}" instance names, where n=1..N.
+    """
+
+    @classmethod
+    def range(cls) -> Sequence[int]:
+        """
+        Integer range of all channels.
+
+        :return: sequence of channel numbers
+        """
+        return range(1, len(cast(Sized, cls)) + 1)
+
+    @classmethod
+    def _validate_number(cls, number: int):
+        """
+        Validate enum instance number.
+
+        :param number: the enum instance number (1..N)
+        :raises ValueError: when enum instance number is not in 1..N range
+        """
+        if number not in cls.range():
+            raise ValueError(
+                f"{cls._prefix()} number must be one of {list(cls.range())}"
+            )
+
+    @classmethod
+    def _prefix(cls) -> str:
+        """
+        Enum instances name prefix: "{prefix}{n}"
+
+        :return: enum instances prefix string
+        """
+        raise NotImplementedError("Implement in subclass")
+
+    @property
+    def number(self) -> int:
+        """
+        Get corresponding enum instance number.
+
+        :return: enum instance number (1..N)
+        """
+        # Py >=3.9: self.name.removeprefix()
+        return int(self.name[len(self._prefix()):])
+
+    # no type return as it would be a arguably too complex/obscure;
+    # cf. https://github.com/python/typing/issues/58#issuecomment-326240794
+    @classmethod
+    def get(cls, number: int):
+        """
+        Get the enum instance for a given number.
+
+        :param number: the instance number (1..N)
+        :return: the enum instance for the given number.
+        :raises ValueError: when instance number is not in the 1..N range
+        """
+        cls._validate_number(number)
+        return getattr(cls, f"{cls._prefix()}{number}")
+
+
+class _InputEnumBase(_PrefixedNumbersEnumBase):
+    """
+    Base class for enums with "input_{n}" instance names, where n=1..N.
+    """
+
+    @classmethod
+    def _prefix(cls) -> str:
+        return "input_"
+
+    @classmethod
+    def input(cls, channel: int):
+        """
+        Get the enum instance for a given channel number.
+
+        :param channel: the channel number (1..N)
+        :return: the enum instance for the given channel.
+        :raises ValueError: when channel number is not in the 1..N range
+        """
+        return cls.get(channel)
+
+
+MeasurementsScaledInput = unique(
+    _InputEnumBase(
+        "MeasurementsScaledInput",
+        {
+            f"{_InputEnumBase._prefix()}{n}":
+                f'"DB_Measurements"."si_scaled_Voltage_Input_{n}"'
+            for n in range(1, 5)
+        },
+    )
+)
+"""
+Variable NodeID strings for the four analog BNC inputs for measuring voltage.
+The voltage returned in these variables is already scaled with the set ratio,
+which can be read using the variables in :class:`MeasurementsDividerRatio`.
+"""
+
+
+MeasurementsDividerRatio = unique(
+    _InputEnumBase(
+        "MeasurementsDividerRatio",
+        {
+            f"{_InputEnumBase._prefix()}{n}":
+                f'"DB_Measurements"."si_Divider_Ratio_{n}"'
+            for n in range(1, 5)
+        },
+    )
+)
+"""
+Variable NodeID strings for the measurement input scaling ratios. These ratios
+are defined in the Supercube HMI setup and are provided in the python module here
+to be able to read them out, allowing further calculations.
+"""
+
+
+class EarthingStickStatus(IntEnum):
+    """
+    Status of an earthing stick. These are the possible values in the status integer
+    e.g. in :attr:`EarthingStick.status_1`.
+    """
+
+    #: Earthing stick is deselected and not enabled in safety circuit. To get out of
+    #: this state, the earthing has to be enabled in the Supercube HMI setup.
+    inactive = 0
+
+    #: Earthing is closed (safe).
+    closed = 1
+
+    #: Earthing is open (not safe).
+    open = 2
+
+    #: Earthing is in error, e.g. when the stick did not close correctly or could not
+    #: open.
+    error = 3
+
+
+class EarthingStickOperatingStatus(IntEnum):
+    """
+    Operating Status for an earthing stick. Stick can be used in auto or manual mode.
+    """
+
+    auto = 0
+    manual = 1
+
+
+class EarthingStickOperation(IntEnum):
+    """
+    Operation of the earthing stick in manual operating mode. Can be closed of opened.
+    """
+
+    open = 0
+    close = 1
+
+
+# NOTE: super metaclass has to match metaclass of `super(EarthingStick)`!
+class EarthingStickMeta(EnumMeta):
+    def __new__(metacls, clsname, bases, clsdict, **kwargs):
+        cls = EnumMeta.__new__(metacls, clsname, bases, clsdict, **kwargs)
+        # BEWARE: keep manually in sync with suffixes of enum instances; opt use dir()
+        cls._range = range(1, 7)
+        cls._statuses = tuple(getattr(cls, f"status_{number}") for number in cls._range)
+        cls._manuals = tuple(getattr(cls, f"manual_{number}") for number in cls._range)
+        cls._operating_statuses = tuple(
+            getattr(cls, f"operating_status_{number}") for number in cls._range
+        )
+        return cls
+
+
+@unique
+class EarthingStick(ValueEnum, metaclass=EarthingStickMeta):
+    """
+    Variable NodeID strings for all earthing stick statuses (read-only integer) and
+    writable booleans for setting the earthing in manual mode.
+    """
+
+    status_1 = '"DB_Safety_Circuit"."Earthstick_1"."si_HMI_Status"'
+    status_2 = '"DB_Safety_Circuit"."Earthstick_2"."si_HMI_Status"'
+    status_3 = '"DB_Safety_Circuit"."Earthstick_3"."si_HMI_Status"'
+    status_4 = '"DB_Safety_Circuit"."Earthstick_4"."si_HMI_Status"'
+    status_5 = '"DB_Safety_Circuit"."Earthstick_5"."si_HMI_Status"'
+    status_6 = '"DB_Safety_Circuit"."Earthstick_6"."si_HMI_Status"'
+
+    manual_1 = '"DB_Safety_Circuit"."Earthstick_1"."sx_earthing_manually"'
+    manual_2 = '"DB_Safety_Circuit"."Earthstick_2"."sx_earthing_manually"'
+    manual_3 = '"DB_Safety_Circuit"."Earthstick_3"."sx_earthing_manually"'
+    manual_4 = '"DB_Safety_Circuit"."Earthstick_4"."sx_earthing_manually"'
+    manual_5 = '"DB_Safety_Circuit"."Earthstick_5"."sx_earthing_manually"'
+    manual_6 = '"DB_Safety_Circuit"."Earthstick_6"."sx_earthing_manually"'
+
+    operating_status_1 = '"DB_Safety_Circuit"."Earthstick_1"."sx_manual_control_active"'
+    operating_status_2 = '"DB_Safety_Circuit"."Earthstick_2"."sx_manual_control_active"'
+    operating_status_3 = '"DB_Safety_Circuit"."Earthstick_3"."sx_manual_control_active"'
+    operating_status_4 = '"DB_Safety_Circuit"."Earthstick_4"."sx_manual_control_active"'
+    operating_status_5 = '"DB_Safety_Circuit"."Earthstick_5"."sx_manual_control_active"'
+    operating_status_6 = '"DB_Safety_Circuit"."Earthstick_6"."sx_manual_control_active"'
+
+    @property
+    def number(self) -> int:
+        """
+        Get corresponding earthing stick number.
+
+        :return: earthing stick number (1..6)
+        """
+        return int(self.name.rpartition("_")[-1])
+
+    @classmethod
+    def range(cls) -> Sequence[int]:
+        """
+        Integer range of all earthing sticks.
+
+        :return: sequence of earthing sticks numbers
+        """
+        return cls._range
+
+    @classmethod
+    def _validate_earthing_stick_number(cls, number: int):
+        """
+        Validate earthing stick number.
+
+        :param number: the earthing stick number
+        :raises ValueError: when earthing stick number is not valid
+        """
+        if number not in cls.range():
+            raise ValueError(
+                f"Earthing stick number must be one of {list(cls.range())}"
+            )
+
+    @classmethod
+    def statuses(cls) -> Tuple["EarthingStick", ...]:
+        """
+        Get all earthing stick status instances.
+
+        :return: tuple of status instances
+        """
+        return cls._statuses
+
+    @classmethod
+    def status(cls, number: int) -> "EarthingStick":
+        """
+        Get the status enum instance for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the status instance
+        :raises ValueError: when earthing stick number is not valid
+        """
+        cls._validate_earthing_stick_number(number)
+        return cls.statuses()[number - 1]
+
+    @classmethod
+    def manuals(cls) -> Tuple["EarthingStick", ...]:
+        """
+        Get all earthing stick manual instances.
+
+        :return: tuple of manual instances
+        """
+        return cls._manuals
+
+    @classmethod
+    def manual(cls, number: int):
+        """
+        Get the manual enum instance for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the manual instance
+        :raises ValueError: when earthing stick number is not valid
+        """
+        cls._validate_earthing_stick_number(number)
+        return cls.manuals()[number - 1]
+
+    @classmethod
+    def operating_statuses(cls) -> Tuple["EarthingStick", ...]:
+        """
+        Get all earthing stick operating status instances.
+
+        :return: tuple of operating status instances
+        """
+        return cls._operating_statuses
+
+    @classmethod
+    def operating_status(cls, number: int):
+        """
+        Get the operating status enum instance for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the operating status instance
+        :raises ValueError: when earthing stick number is not valid
+        """
+        cls._validate_earthing_stick_number(number)
+        return cls.operating_statuses()[number - 1]
+
+
+@unique
+class Errors(ValueEnum):
+    """
+    Variable NodeID strings for information regarding error, warning and message
+    handling.
+    """
+
+    #: Boolean read-only variable telling if a message is active.
+    message = '"DB_Message_Buffer"."Info_active"'
+
+    #: Boolean read-only variable telling if a warning is active.
+    warning = '"DB_Message_Buffer"."Warning_active"'
+
+    #: Boolean read-only variable telling if a stop is active.
+    stop = '"DB_Message_Buffer"."Stop_active"'
+
+    #: Writable boolean for the error quit button.
+    quit = '"DB_Message_Buffer"."Reset_button"'
+
+
+class _AlarmEnumBase(_PrefixedNumbersEnumBase):
+    """
+    Base class for enums with "Alarm{n}" instance names, where n=1..N.
+    """
+
+    @classmethod
+    def _prefix(cls) -> str:
+        return "Alarm"
+
+    @classmethod
+    def Alarm(cls, number: int):
+        """
+        Get the enum instance for a given alarm number.
+
+        :param number: the alarm number (1..N)
+        :return: the enum instance for the alarm number.
+        :raises ValueError: when alarm number is not in the 1..N range
+        """
+        return cls.get(number)
+
+
+Alarms = unique(
+    _AlarmEnumBase(
+        "Alarms",
+        {f"Alarm{n}": f'"DB_Alarm_HMI"."Alarm{n}"' for n in range(1, 152)},
+    )
+)
+"""
+Alarms enumeration containing all variable NodeID strings for the alarm array.
+"""
+
+
+class DoorStatus(IntEnum):
+    """
+    Possible status values for doors.
+    """
+
+    #: not enabled in Supercube HMI setup, this door is not supervised.
+    inactive = 0
+
+    #: Door is open.
+    open = 1
+
+    #: Door is closed, but not locked.
+    closed = 2
+
+    #: Door is closed and locked (safe state).
+    locked = 3
+
+    #: Door has an error or was opened in locked state (either with emergency stop or
+    #: from the inside).
+    error = 4
+
+
+class EarthingRodStatus(IntEnum):
+    """
+    Possible status values for earthing rods.
+    """
+
+    #: earthing rod is somewhere in the experiment
+    #: and blocks the start of the experiment
+    experiment_blocked = 0
+
+    #: earthing rod is hanging next to the door, experiment is ready to operate
+    experiment_ready = 1
+
+
+class _DoorEnumBase(_PrefixedNumbersEnumBase):
+    """
+    Base class for enums with "status_{n}" instance names, where n=1..N is the door
+    number.
+    """
+
+    @classmethod
+    def _prefix(cls) -> str:
+        return "status_"
+
+    @classmethod
+    def status(cls, door: int):
+        """
+        Get the enum instance for a given door number.
+
+        :param number: the door number (1..N)
+        :return: the enum instance for the given door number.
+        :raises ValueError: when door number is not in the 1..N range
+        """
+        return cls.get(door)
+
+
+Door = unique(
+    _DoorEnumBase(
+        "Door",
+        {
+            f"{_DoorEnumBase._prefix()}{n}":
+                f'"DB_Safety_Circuit"."Door_{n}"."si_HMI_status"'
+            for n in range(1, 4)
+        },
+    )
+)
+"""
+Variable NodeID strings for doors.
+"""
+
+EarthingRod = unique(
+    _DoorEnumBase(
+        "EarthingRod",
+        {
+            f"{_DoorEnumBase._prefix()}{n}":
+                f'"DB_Safety_Circuit"."Door_{n}"."Ix_earthingrod"'
+            for n in range(1, 4)
+        },
+    )
+)
+"""
+Variable NodeID strings for earthing rods.
+"""
+
+
+class AlarmText(ValueEnum):
+    """
+    This enumeration contains textual representations for all error classes (stop,
+    warning and message) of the Supercube system. Use the :meth:`AlarmText.get`
+    method to retrieve the enum of an alarm number.
+    """
+
+    # Safety elements
+    Alarm1 = "STOP Emergency Stop 1"
+    Alarm2 = "STOP Emergency Stop 2"
+    Alarm3 = "STOP Emergency Stop 3"
+    Alarm4 = "STOP Safety Switch 1 error"
+    Alarm5 = "STOP Safety Switch 2 error"
+    Alarm6 = "STOP Door 1 lock supervision"
+    Alarm7 = "STOP Door 2 lock supervision"
+    Alarm8 = "STOP Door 3 lock supervision"
+    Alarm9 = "STOP Earthing stick 1 error while opening"
+    Alarm10 = "STOP Earthing stick 2 error while opening"
+    Alarm11 = "STOP Earthing stick 3 error while opening"
+    Alarm12 = "STOP Earthing stick 4 error while opening"
+    Alarm13 = "STOP Earthing stick 5 error while opening"
+    Alarm14 = "STOP Earthing stick 6 error while opening"
+    Alarm15 = "STOP Earthing stick 1 error while closing"
+    Alarm16 = "STOP Earthing stick 2 error while closing"
+    Alarm17 = "STOP Earthing stick 3 error while closing"
+    Alarm18 = "STOP Earthing stick 4 error while closing"
+    Alarm19 = "STOP Earthing stick 5 error while closing"
+    Alarm20 = "STOP Earthing stick 6 error while closing"
+    Alarm21 = "STOP Safety fence 1"
+    Alarm22 = "STOP Safety fence 2"
+    Alarm23 = "STOP OPC connection error"
+    Alarm24 = "STOP Grid power failure"
+    Alarm25 = "STOP UPS failure"
+    Alarm26 = "STOP 24V PSU failure"
+
+    # Doors
+    Alarm41 = "WARNING Door 1: Use earthing rod!"
+    Alarm42 = "MESSAGE Door 1: Earthing rod is still in setup."
+    Alarm43 = "WARNING Door 2: Use earthing rod!"
+    Alarm44 = "MESSAGE Door 2: Earthing rod is still in setup."
+    Alarm45 = "WARNING Door 3: Use earthing rod!"
+    Alarm46 = "MESSAGE Door 3: Earthing rod is still in setup."
+
+    # General
+    Alarm47 = "MESSAGE UPS charge < 85%"
+    Alarm48 = "MESSAGE UPS running on battery"
+
+    # generic not defined alarm text
+    not_defined = "NO ALARM TEXT DEFINED"
+
+    @classmethod
+    def get(cls, alarm: int):
+        """
+        Get the attribute of this enum for an alarm number.
+
+        :param alarm: the alarm number
+        :return: the enum for the desired alarm number
+        """
+
+        try:
+            return getattr(cls, f"Alarm{alarm}")
+        except AttributeError:
+            return cls.not_defined
+
+
+class OpcControl(ValueEnum):
+    """
+    Variable NodeID strings for supervision of the OPC connection from the
+    controlling workstation to the Supercube.
+    """
+
+    #: writable boolean to enable OPC remote control and display a message window on
+    #: the Supercube HMI.
+    active = '"DB_OPC_Connection"."sx_OPC_active"'
+    live = '"DB_OPC_Connection"."sx_OPC_lifebit"'
+
+
+class _LineEnumBase(_PrefixedNumbersEnumBase):
+    """
+    Base class for enums with "input_{n}" instance names, where n=1..N.
+    """
+
+    @classmethod
+    def _prefix(cls) -> str:
+        return "line_"
+
+    @classmethod
+    def line(cls, number: int):
+        """
+        Get the enum instance for a given line number.
+
+        :param number: the line number (1..M)
+        :return: the enum instance for the given line number.
+        :raises ValueError: when line number is not in the 1..N range
+        """
+        return cls.get(number)
+
+
+MessageBoard = unique(
+    _LineEnumBase(
+        "MessageBoard",
+        {
+            f"{_LineEnumBase._prefix()}{n}": f'"DB_OPC_Connection"."Is_status_Line_{n}"'
+            for n in range(1, 16)
+        },
+    )
+)
+"""
+Variable NodeID strings for message board lines.
+"""
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/supercube/typ_b.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/supercube/typ_b.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Supercube Typ B module.
-"""
-
-import logging
-from hvl_ccb.configuration import configdataclass
-from . import constants
-from .base import (
-    SupercubeBase,
-    SupercubeOpcUaCommunication,
-    SupercubeOpcUaCommunicationConfig,
-)
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class SupercubeBOpcUaConfiguration(SupercubeOpcUaCommunicationConfig):
-    endpoint_name: str = constants.SupercubeOpcEndpoint.B.value  # type: ignore
-
-
-class SupercubeBOpcUaCommunication(SupercubeOpcUaCommunication):
-    @staticmethod
-    def config_cls():
-        return SupercubeBOpcUaConfiguration
-
-
-class SupercubeB(SupercubeBase):
-    """
-    Variant B of the Supercube without frequency converter but external safety switches.
-    """
-
-    @staticmethod
-    def default_com_cls():
-        return SupercubeBOpcUaCommunication
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Supercube Typ B module.
+"""
+
+import logging
+from hvl_ccb.configuration import configdataclass
+from . import constants
+from .base import (
+    SupercubeBase,
+    SupercubeOpcUaCommunication,
+    SupercubeOpcUaCommunicationConfig,
+)
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class SupercubeBOpcUaConfiguration(SupercubeOpcUaCommunicationConfig):
+    endpoint_name: str = constants.SupercubeOpcEndpoint.B.value  # type: ignore
+
+
+class SupercubeBOpcUaCommunication(SupercubeOpcUaCommunication):
+    @staticmethod
+    def config_cls():
+        return SupercubeBOpcUaConfiguration
+
+
+class SupercubeB(SupercubeBase):
+    """
+    Variant B of the Supercube without frequency converter but external safety switches.
+    """
+
+    @staticmethod
+    def default_com_cls():
+        return SupercubeBOpcUaCommunication
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/base.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/base.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,471 +1,471 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Base classes for the Supercube device.
-"""
-
-import logging
-from time import sleep
-
-from opcua import Node
-
-from hvl_ccb import configdataclass
-from hvl_ccb.comm import OpcUaSubHandler, OpcUaCommunicationConfig, OpcUaCommunication
-from . import constants
-from ..base import SingleCommDevice
-
-logger = logging.getLogger(__name__)
-
-
-class InvalidSupercubeStatusError(Exception):
-    """
-    Exception raised when supercube has invalid status.
-    """
-
-    pass
-
-
-class SupercubeSubscriptionHandler(OpcUaSubHandler):
-    """
-    OPC Subscription handler for datachange events and normal events specifically
-    implemented for the Supercube devices.
-    """
-
-    def datachange_notification(self, node: Node, val, data):
-        """
-        In addition to the standard operation (debug logging entry of the datachange),
-        alarms are logged at INFO level using the alarm text.
-
-        :param node: the node object that triggered the datachange event
-        :param val: the new value
-        :param data:
-        """
-
-        super().datachange_notification(node, val, data)
-
-        # assume an alarm datachange
-        if node.nodeid.Identifier == constants.Errors.stop_number:
-            alarm_text = constants.AlarmText.get(val)
-            logger.info(alarm_text)
-
-
-@configdataclass
-class SupercubeConfiguration:
-    """
-    Configuration dataclass for the Supercube devices.
-    """
-
-    #: Namespace of the OPC variables, typically this is 3 (coming from Siemens)
-    namespace_index: int = 7
-
-
-@configdataclass
-class SupercubeOpcUaCommunicationConfig(OpcUaCommunicationConfig):
-    """
-    Communication protocol configuration for OPC UA, specifications for the Supercube
-    devices.
-    """
-
-    #: Subscription handler for data change events
-    sub_handler: OpcUaSubHandler = SupercubeSubscriptionHandler()
-
-    port: int = 4845
-
-
-class SupercubeOpcUaCommunication(OpcUaCommunication):
-    """
-    Communication protocol specification for Supercube devices.
-    """
-
-    @staticmethod
-    def config_cls():
-        return SupercubeOpcUaCommunicationConfig
-
-
-class Supercube2015Base(SingleCommDevice):
-    """
-    Base class for Supercube variants.
-    """
-
-    def __init__(self, com, dev_config=None):
-        """
-        Constructor for Supercube base class.
-
-        :param com: the communication protocol or its configuration
-        :param dev_config: the device configuration
-        """
-
-        super().__init__(com, dev_config)
-
-    @staticmethod
-    def default_com_cls():
-        return SupercubeOpcUaCommunication
-
-    def start(self) -> None:
-        """
-        Starts the device. Sets the root node for all OPC read and write commands to
-        the Siemens PLC object node which holds all our relevant objects and variables.
-        """
-
-        logger.info("Starting Supercube Base device")
-        super().start()
-
-        logger.debug("Add monitoring nodes")
-        self.com.init_monitored_nodes(
-            map(  # type: ignore
-                str, constants.GeneralSockets
-            ),
-            self.config.namespace_index,
-        )
-        self.com.init_monitored_nodes(
-            map(  # type: ignore
-                str, constants.GeneralSupport
-            ),
-            self.config.namespace_index,
-        )
-        self.com.init_monitored_nodes(
-            map(  # type: ignore
-                str, constants.Safety
-            ),
-            self.config.namespace_index,
-        )
-
-        self.com.init_monitored_nodes(
-            str(constants.Errors.stop_number), self.config.namespace_index
-        )
-
-        self.com.init_monitored_nodes(
-            map(  # type: ignore
-                str, constants.EarthingStick
-            ),
-            self.config.namespace_index,
-        )
-
-        logger.debug("Finished starting")
-
-    def stop(self) -> None:
-        """
-        Stop the Supercube device. Deactivates the remote control and closes the
-        communication protocol.
-        """
-
-        super().stop()
-
-    @staticmethod
-    def config_cls():
-        return SupercubeConfiguration
-
-    def read(self, node_id: str):
-        """
-        Local wrapper for the OPC UA communication protocol read method.
-
-        :param node_id: the id of the node to read.
-        :return: the value of the variable
-        """
-
-        result = self.com.read(str(node_id), self.config.namespace_index)
-        logger.debug(f"Read from node ID {node_id}: {result}")
-        return result
-
-    def write(self, node_id, value) -> None:
-        """
-        Local wrapper for the OPC UA communication protocol write method.
-
-        :param node_id: the id of the node to read
-        :param value: the value to write to the variable
-        """
-
-        logger.debug(f"Write to node ID {node_id}: {value}")
-        self.com.write(str(node_id), self.config.namespace_index, value)
-
-    def set_remote_control(self, state: bool) -> None:
-        """
-        Enable or disable remote control for the Supercube. This will effectively
-        display a message on the touchscreen HMI.
-
-        :param state: desired remote control state
-        """
-
-        raise NotImplementedError("Function does not exist in Supercube 2015.")
-
-    def get_support_input(self, port: int, contact: int) -> bool:
-        """
-        Get the state of a support socket input.
-
-        :param port: is the socket number (1..6)
-        :param contact: is the contact on the socket (1..2)
-        :return: digital input read state
-        """
-
-        return bool(self.read(constants.GeneralSupport.input(port, contact)))
-
-    def get_support_output(self, port: int, contact: int) -> bool:
-        """
-        Get the state of a support socket output.
-
-        :param port: is the socket number (1..6)
-        :param contact: is the contact on the socket (1..2)
-        :return: digital output read state
-        """
-
-        return bool(self.read(constants.GeneralSupport.output(port, contact)))
-
-    def set_support_output(self, port: int, contact: int, state: bool) -> None:
-        """
-        Set the state of a support output socket.
-
-        :param port: is the socket number (1..6)
-        :param contact: is the contact on the socket (1..2)
-        :param state: is the desired state of the support output
-        """
-
-        self.write(constants.GeneralSupport.output(port, contact), bool(state))
-
-    def set_support_output_impulse(
-        self, port: int, contact: int, duration: float = 0.2, pos_pulse: bool = True
-    ) -> None:
-        """
-        Issue an impulse of a certain duration on a support output contact. The polarity
-        of the pulse (On-wait-Off or Off-wait-On) is specified by the pos_pulse
-        argument.
-
-        This function is blocking.
-
-        :param port: is the socket number (1..6)
-        :param contact: is the contact on the socket (1..2)
-        :param duration: is the length of the impulse in seconds
-        :param pos_pulse: is True, if the pulse shall be HIGH, False if it shall be LOW
-        """
-
-        self.set_support_output(port, contact, pos_pulse)
-        sleep(duration)
-        self.set_support_output(port, contact, not pos_pulse)
-
-    def get_t13_socket(self, port: int) -> bool:
-        """
-        Read the state of a SEV T13 power socket.
-
-        :param port: is the socket number, one of `constants.T13_SOCKET_PORTS`
-        :return: on-state of the power socket
-        """
-
-        if port not in constants.T13_SOCKET_PORTS:
-            raise ValueError(f"port not in {constants.T13_SOCKET_PORTS}: {port}")
-
-        return bool(self.read(getattr(constants.GeneralSockets, f"t13_{port}")))
-
-    def set_t13_socket(self, port: int, state: bool) -> None:
-        """
-        Set the state of a SEV T13 power socket.
-
-        :param port: is the socket number, one of `constants.T13_SOCKET_PORTS`
-        :param state: is the desired on-state of the socket
-        """
-
-        if not isinstance(state, bool):
-            raise ValueError(f"state is not <bool>: {state}")
-
-        if port not in constants.T13_SOCKET_PORTS:
-            raise ValueError(f"port not in {constants.T13_SOCKET_PORTS}: {port}")
-
-        self.write(getattr(constants.GeneralSockets, f"t13_{port}"), state)
-
-    def get_cee16_socket(self) -> bool:
-        """
-        Read the on-state of the IEC CEE16 three-phase power socket.
-
-        :return: the on-state of the CEE16 power socket
-        """
-
-        return bool(self.read(constants.GeneralSockets.cee16))
-
-    def set_cee16_socket(self, state: bool) -> None:
-        """
-        Switch the IEC CEE16 three-phase power socket on or off.
-
-        :param state: desired on-state of the power socket
-        :raises ValueError: if state is not of type bool
-        """
-
-        if not isinstance(state, bool):
-            raise ValueError(f"state is not <bool>: {state}")
-
-        self.write(constants.GeneralSockets.cee16, state)
-
-    def get_status(self) -> int:
-        """
-        Get the safety circuit status of the Supercube.
-
-        :return: the safety status of the supercube's state machine;
-            see `constants.SafetyStatus`.
-        """
-
-        ready_for_red = self.read(constants.Safety.status_ready_for_red)
-        red = self.read(constants.Safety.status_red)
-        green = self.read(constants.Safety.status_green)
-        operate = self.read(constants.Safety.switchto_operate)
-        error = self.read(constants.Safety.status_error)
-        triggered = self.read(constants.BreakdownDetection.triggered)
-        fso_active = self.read(constants.BreakdownDetection.activated)
-
-        if error:
-            return constants.SafetyStatus.Error
-
-        if triggered and fso_active:
-            return constants.SafetyStatus.QuickStop
-
-        if not ready_for_red and not red and green:
-            return constants.SafetyStatus.GreenNotReady
-
-        if ready_for_red and not red and not operate:
-            return constants.SafetyStatus.GreenReady
-
-        if red and not green and not operate:
-            return constants.SafetyStatus.RedReady
-
-        if red and not green and operate:
-            return constants.SafetyStatus.RedOperate
-
-        raise InvalidSupercubeStatusError(
-            f"ready_for_red: {ready_for_red}, red: {red}, green: {green}, "
-            f"operate: {operate}, triggered: {triggered}, fso_active: {fso_active}"
-        )
-
-    def ready(self, state: bool) -> None:
-        """
-        Set ready state. Ready means locket safety circuit, red lamps, but high voltage
-        still off.
-
-        :param state: set ready state
-        """
-
-        if state:
-            if self.get_status() is constants.SafetyStatus.GreenReady:
-                self.write(constants.Safety.switchto_ready, True)
-                sleep(0.02)
-                self.write(constants.Safety.switchto_ready, False)
-        else:
-            self.write(constants.Safety.switchto_green, True)
-            sleep(0.02)
-            self.write(constants.Safety.switchto_green, False)
-
-    def operate(self, state: bool) -> None:
-        """
-        Set operate state. If the state is RedReady, this will turn on the high
-        voltage and close the safety switches.
-
-        :param state: set operate state
-        """
-
-        if state:
-            if self.get_status() is constants.SafetyStatus.RedReady:
-                self.write(constants.Safety.switchto_operate, True)
-        else:
-            self.write(constants.Safety.switchto_operate, False)
-
-    def get_measurement_ratio(self, channel: int) -> float:
-        """
-        Get the set measurement ratio of an AC/DC analog input channel. Every input
-        channel has a divider ratio assigned during setup of the Supercube system.
-        This ratio can be read out.
-
-        **Attention:** Supercube 2015 does not have a separate ratio for every analog
-        input. Therefore there is only one ratio for ``channel = 1``.
-
-        :param channel: number of the input channel (1..4)
-        :return: the ratio
-        """
-
-        return float(self.read(constants.MeasurementsDividerRatio.get(channel)))
-
-    def get_measurement_voltage(self, channel: int) -> float:
-        """
-        Get the measured voltage of an analog input channel. The voltage read out
-        here is already scaled by the configured divider ratio.
-
-        **Attention:** In contrast to the *new* Supercube, the old one returns here
-        the input voltage read at the ADC. It is not scaled by a factor.
-
-        :param channel: number of the input channel (1..4)
-        :return: measured voltage
-        """
-
-        return float(self.read(constants.MeasurementsScaledInput.get(channel)))
-
-    def get_earthing_status(self, number: int) -> int:
-        """
-        Get the status of an earthing stick, whether it is closed, open or undefined
-        (moving).
-
-        :param number: number of the earthing stick (1..6)
-        :return: earthing stick status; see constants.EarthingStickStatus
-        """
-
-        connected = self.read(constants.EarthingStick.status_connected(number))
-        open_ = self.read(constants.EarthingStick.status_open(number))
-        closed = self.read(constants.EarthingStick.status_closed(number))
-
-        if not connected:
-            return constants.EarthingStickStatus.inactive
-
-        if open_ and not closed:
-            return constants.EarthingStickStatus.open
-
-        if not open_ and closed:
-            return constants.EarthingStickStatus.closed
-
-        return constants.EarthingStickStatus.error
-
-    def get_earthing_manual(self, number: int) -> bool:
-        """
-        Get the manual status of an earthing stick. If an earthing stick is set to
-        manual, it is closed even if the system is in states RedReady or RedOperate.
-
-        :param number: number of the earthing stick (1..6)
-        :return: earthing stick manual status
-        """
-
-        return bool(self.read(constants.EarthingStick.manual(number)))
-
-    def set_earthing_manual(self, number: int, manual: bool) -> None:
-        """
-        Set the manual status of an earthing stick. If an earthing stick is set to
-        manual, it is closed even if the system is in states RedReady or RedOperate.
-
-        :param number: number of the earthing stick (1..6)
-        :param manual: earthing stick manual status (True or False)
-        """
-
-        if self.get_status() is constants.SafetyStatus.RedOperate:
-            raise RuntimeError("Status is Red Operate, should not move earthing.")
-        self.write(constants.EarthingStick.manual(number), manual)
-
-    def quit_error(self) -> None:
-        """
-        Quits errors that are active on the Supercube.
-        """
-
-        self.write(constants.Errors.quit, True)
-        sleep(0.1)
-        self.write(constants.Errors.quit, False)
-
-    def horn(self, state: bool) -> None:
-        """
-        Turns acoustic horn on or off.
-
-        :param state: Turns horn on (True) or off (False)
-        """
-        self.write(constants.Safety.horn, state)
-
-    def get_door_status(self, door: int) -> constants.DoorStatus:
-        """
-        Get the status of a safety fence door. See :class:`constants.DoorStatus` for
-        possible returned door statuses.
-
-        :param door: the door number (1..3)
-        :return: the door status
-        """
-
-        raise NotImplementedError(
-            "Door status not supported in old Supercube 2015 version."
-        )
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Base classes for the Supercube device.
+"""
+
+import logging
+from time import sleep
+
+from opcua import Node
+
+from hvl_ccb import configdataclass
+from hvl_ccb.comm import OpcUaSubHandler, OpcUaCommunicationConfig, OpcUaCommunication
+from . import constants
+from ..base import SingleCommDevice
+
+logger = logging.getLogger(__name__)
+
+
+class InvalidSupercubeStatusError(Exception):
+    """
+    Exception raised when supercube has invalid status.
+    """
+
+    pass
+
+
+class SupercubeSubscriptionHandler(OpcUaSubHandler):
+    """
+    OPC Subscription handler for datachange events and normal events specifically
+    implemented for the Supercube devices.
+    """
+
+    def datachange_notification(self, node: Node, val, data):
+        """
+        In addition to the standard operation (debug logging entry of the datachange),
+        alarms are logged at INFO level using the alarm text.
+
+        :param node: the node object that triggered the datachange event
+        :param val: the new value
+        :param data:
+        """
+
+        super().datachange_notification(node, val, data)
+
+        # assume an alarm datachange
+        if node.nodeid.Identifier == constants.Errors.stop_number:
+            alarm_text = constants.AlarmText.get(val)
+            logger.info(alarm_text)
+
+
+@configdataclass
+class SupercubeConfiguration:
+    """
+    Configuration dataclass for the Supercube devices.
+    """
+
+    #: Namespace of the OPC variables, typically this is 3 (coming from Siemens)
+    namespace_index: int = 7
+
+
+@configdataclass
+class SupercubeOpcUaCommunicationConfig(OpcUaCommunicationConfig):
+    """
+    Communication protocol configuration for OPC UA, specifications for the Supercube
+    devices.
+    """
+
+    #: Subscription handler for data change events
+    sub_handler: OpcUaSubHandler = SupercubeSubscriptionHandler()
+
+    port: int = 4845
+
+
+class SupercubeOpcUaCommunication(OpcUaCommunication):
+    """
+    Communication protocol specification for Supercube devices.
+    """
+
+    @staticmethod
+    def config_cls():
+        return SupercubeOpcUaCommunicationConfig
+
+
+class Supercube2015Base(SingleCommDevice):
+    """
+    Base class for Supercube variants.
+    """
+
+    def __init__(self, com, dev_config=None):
+        """
+        Constructor for Supercube base class.
+
+        :param com: the communication protocol or its configuration
+        :param dev_config: the device configuration
+        """
+
+        super().__init__(com, dev_config)
+
+    @staticmethod
+    def default_com_cls():
+        return SupercubeOpcUaCommunication
+
+    def start(self) -> None:
+        """
+        Starts the device. Sets the root node for all OPC read and write commands to
+        the Siemens PLC object node which holds all our relevant objects and variables.
+        """
+
+        logger.info("Starting Supercube Base device")
+        super().start()
+
+        logger.debug("Add monitoring nodes")
+        self.com.init_monitored_nodes(
+            map(  # type: ignore
+                str, constants.GeneralSockets
+            ),
+            self.config.namespace_index,
+        )
+        self.com.init_monitored_nodes(
+            map(  # type: ignore
+                str, constants.GeneralSupport
+            ),
+            self.config.namespace_index,
+        )
+        self.com.init_monitored_nodes(
+            map(  # type: ignore
+                str, constants.Safety
+            ),
+            self.config.namespace_index,
+        )
+
+        self.com.init_monitored_nodes(
+            str(constants.Errors.stop_number), self.config.namespace_index
+        )
+
+        self.com.init_monitored_nodes(
+            map(  # type: ignore
+                str, constants.EarthingStick
+            ),
+            self.config.namespace_index,
+        )
+
+        logger.debug("Finished starting")
+
+    def stop(self) -> None:
+        """
+        Stop the Supercube device. Deactivates the remote control and closes the
+        communication protocol.
+        """
+
+        super().stop()
+
+    @staticmethod
+    def config_cls():
+        return SupercubeConfiguration
+
+    def read(self, node_id: str):
+        """
+        Local wrapper for the OPC UA communication protocol read method.
+
+        :param node_id: the id of the node to read.
+        :return: the value of the variable
+        """
+
+        result = self.com.read(str(node_id), self.config.namespace_index)
+        logger.debug(f"Read from node ID {node_id}: {result}")
+        return result
+
+    def write(self, node_id, value) -> None:
+        """
+        Local wrapper for the OPC UA communication protocol write method.
+
+        :param node_id: the id of the node to read
+        :param value: the value to write to the variable
+        """
+
+        logger.debug(f"Write to node ID {node_id}: {value}")
+        self.com.write(str(node_id), self.config.namespace_index, value)
+
+    def set_remote_control(self, state: bool) -> None:
+        """
+        Enable or disable remote control for the Supercube. This will effectively
+        display a message on the touchscreen HMI.
+
+        :param state: desired remote control state
+        """
+
+        raise NotImplementedError("Function does not exist in Supercube 2015.")
+
+    def get_support_input(self, port: int, contact: int) -> bool:
+        """
+        Get the state of a support socket input.
+
+        :param port: is the socket number (1..6)
+        :param contact: is the contact on the socket (1..2)
+        :return: digital input read state
+        """
+
+        return bool(self.read(constants.GeneralSupport.input(port, contact)))
+
+    def get_support_output(self, port: int, contact: int) -> bool:
+        """
+        Get the state of a support socket output.
+
+        :param port: is the socket number (1..6)
+        :param contact: is the contact on the socket (1..2)
+        :return: digital output read state
+        """
+
+        return bool(self.read(constants.GeneralSupport.output(port, contact)))
+
+    def set_support_output(self, port: int, contact: int, state: bool) -> None:
+        """
+        Set the state of a support output socket.
+
+        :param port: is the socket number (1..6)
+        :param contact: is the contact on the socket (1..2)
+        :param state: is the desired state of the support output
+        """
+
+        self.write(constants.GeneralSupport.output(port, contact), bool(state))
+
+    def set_support_output_impulse(
+        self, port: int, contact: int, duration: float = 0.2, pos_pulse: bool = True
+    ) -> None:
+        """
+        Issue an impulse of a certain duration on a support output contact. The polarity
+        of the pulse (On-wait-Off or Off-wait-On) is specified by the pos_pulse
+        argument.
+
+        This function is blocking.
+
+        :param port: is the socket number (1..6)
+        :param contact: is the contact on the socket (1..2)
+        :param duration: is the length of the impulse in seconds
+        :param pos_pulse: is True, if the pulse shall be HIGH, False if it shall be LOW
+        """
+
+        self.set_support_output(port, contact, pos_pulse)
+        sleep(duration)
+        self.set_support_output(port, contact, not pos_pulse)
+
+    def get_t13_socket(self, port: int) -> bool:
+        """
+        Read the state of a SEV T13 power socket.
+
+        :param port: is the socket number, one of `constants.T13_SOCKET_PORTS`
+        :return: on-state of the power socket
+        """
+
+        if port not in constants.T13_SOCKET_PORTS:
+            raise ValueError(f"port not in {constants.T13_SOCKET_PORTS}: {port}")
+
+        return bool(self.read(getattr(constants.GeneralSockets, f"t13_{port}")))
+
+    def set_t13_socket(self, port: int, state: bool) -> None:
+        """
+        Set the state of a SEV T13 power socket.
+
+        :param port: is the socket number, one of `constants.T13_SOCKET_PORTS`
+        :param state: is the desired on-state of the socket
+        """
+
+        if not isinstance(state, bool):
+            raise ValueError(f"state is not <bool>: {state}")
+
+        if port not in constants.T13_SOCKET_PORTS:
+            raise ValueError(f"port not in {constants.T13_SOCKET_PORTS}: {port}")
+
+        self.write(getattr(constants.GeneralSockets, f"t13_{port}"), state)
+
+    def get_cee16_socket(self) -> bool:
+        """
+        Read the on-state of the IEC CEE16 three-phase power socket.
+
+        :return: the on-state of the CEE16 power socket
+        """
+
+        return bool(self.read(constants.GeneralSockets.cee16))
+
+    def set_cee16_socket(self, state: bool) -> None:
+        """
+        Switch the IEC CEE16 three-phase power socket on or off.
+
+        :param state: desired on-state of the power socket
+        :raises ValueError: if state is not of type bool
+        """
+
+        if not isinstance(state, bool):
+            raise ValueError(f"state is not <bool>: {state}")
+
+        self.write(constants.GeneralSockets.cee16, state)
+
+    def get_status(self) -> int:
+        """
+        Get the safety circuit status of the Supercube.
+
+        :return: the safety status of the supercube's state machine;
+            see `constants.SafetyStatus`.
+        """
+
+        ready_for_red = self.read(constants.Safety.status_ready_for_red)
+        red = self.read(constants.Safety.status_red)
+        green = self.read(constants.Safety.status_green)
+        operate = self.read(constants.Safety.switchto_operate)
+        error = self.read(constants.Safety.status_error)
+        triggered = self.read(constants.BreakdownDetection.triggered)
+        fso_active = self.read(constants.BreakdownDetection.activated)
+
+        if error:
+            return constants.SafetyStatus.Error
+
+        if triggered and fso_active:
+            return constants.SafetyStatus.QuickStop
+
+        if not ready_for_red and not red and green:
+            return constants.SafetyStatus.GreenNotReady
+
+        if ready_for_red and not red and not operate:
+            return constants.SafetyStatus.GreenReady
+
+        if red and not green and not operate:
+            return constants.SafetyStatus.RedReady
+
+        if red and not green and operate:
+            return constants.SafetyStatus.RedOperate
+
+        raise InvalidSupercubeStatusError(
+            f"ready_for_red: {ready_for_red}, red: {red}, green: {green}, "
+            f"operate: {operate}, triggered: {triggered}, fso_active: {fso_active}"
+        )
+
+    def ready(self, state: bool) -> None:
+        """
+        Set ready state. Ready means locket safety circuit, red lamps, but high voltage
+        still off.
+
+        :param state: set ready state
+        """
+
+        if state:
+            if self.get_status() is constants.SafetyStatus.GreenReady:
+                self.write(constants.Safety.switchto_ready, True)
+                sleep(0.02)
+                self.write(constants.Safety.switchto_ready, False)
+        else:
+            self.write(constants.Safety.switchto_green, True)
+            sleep(0.02)
+            self.write(constants.Safety.switchto_green, False)
+
+    def operate(self, state: bool) -> None:
+        """
+        Set operate state. If the state is RedReady, this will turn on the high
+        voltage and close the safety switches.
+
+        :param state: set operate state
+        """
+
+        if state:
+            if self.get_status() is constants.SafetyStatus.RedReady:
+                self.write(constants.Safety.switchto_operate, True)
+        else:
+            self.write(constants.Safety.switchto_operate, False)
+
+    def get_measurement_ratio(self, channel: int) -> float:
+        """
+        Get the set measurement ratio of an AC/DC analog input channel. Every input
+        channel has a divider ratio assigned during setup of the Supercube system.
+        This ratio can be read out.
+
+        **Attention:** Supercube 2015 does not have a separate ratio for every analog
+        input. Therefore there is only one ratio for ``channel = 1``.
+
+        :param channel: number of the input channel (1..4)
+        :return: the ratio
+        """
+
+        return float(self.read(constants.MeasurementsDividerRatio.get(channel)))
+
+    def get_measurement_voltage(self, channel: int) -> float:
+        """
+        Get the measured voltage of an analog input channel. The voltage read out
+        here is already scaled by the configured divider ratio.
+
+        **Attention:** In contrast to the *new* Supercube, the old one returns here
+        the input voltage read at the ADC. It is not scaled by a factor.
+
+        :param channel: number of the input channel (1..4)
+        :return: measured voltage
+        """
+
+        return float(self.read(constants.MeasurementsScaledInput.get(channel)))
+
+    def get_earthing_status(self, number: int) -> int:
+        """
+        Get the status of an earthing stick, whether it is closed, open or undefined
+        (moving).
+
+        :param number: number of the earthing stick (1..6)
+        :return: earthing stick status; see constants.EarthingStickStatus
+        """
+
+        connected = self.read(constants.EarthingStick.status_connected(number))
+        open_ = self.read(constants.EarthingStick.status_open(number))
+        closed = self.read(constants.EarthingStick.status_closed(number))
+
+        if not connected:
+            return constants.EarthingStickStatus.inactive
+
+        if open_ and not closed:
+            return constants.EarthingStickStatus.open
+
+        if not open_ and closed:
+            return constants.EarthingStickStatus.closed
+
+        return constants.EarthingStickStatus.error
+
+    def get_earthing_manual(self, number: int) -> bool:
+        """
+        Get the manual status of an earthing stick. If an earthing stick is set to
+        manual, it is closed even if the system is in states RedReady or RedOperate.
+
+        :param number: number of the earthing stick (1..6)
+        :return: earthing stick manual status
+        """
+
+        return bool(self.read(constants.EarthingStick.manual(number)))
+
+    def set_earthing_manual(self, number: int, manual: bool) -> None:
+        """
+        Set the manual status of an earthing stick. If an earthing stick is set to
+        manual, it is closed even if the system is in states RedReady or RedOperate.
+
+        :param number: number of the earthing stick (1..6)
+        :param manual: earthing stick manual status (True or False)
+        """
+
+        if self.get_status() is constants.SafetyStatus.RedOperate:
+            raise RuntimeError("Status is Red Operate, should not move earthing.")
+        self.write(constants.EarthingStick.manual(number), manual)
+
+    def quit_error(self) -> None:
+        """
+        Quits errors that are active on the Supercube.
+        """
+
+        self.write(constants.Errors.quit, True)
+        sleep(0.1)
+        self.write(constants.Errors.quit, False)
+
+    def horn(self, state: bool) -> None:
+        """
+        Turns acoustic horn on or off.
+
+        :param state: Turns horn on (True) or off (False)
+        """
+        self.write(constants.Safety.horn, state)
+
+    def get_door_status(self, door: int) -> constants.DoorStatus:
+        """
+        Get the status of a safety fence door. See :class:`constants.DoorStatus` for
+        possible returned door statuses.
+
+        :param door: the door number (1..3)
+        :return: the door status
+        """
+
+        raise NotImplementedError(
+            "Door status not supported in old Supercube 2015 version."
+        )
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/supercube2015/constants.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/supercube2015/constants.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,483 +1,483 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Constants, variable names for the Supercube OPC-connected devices.
-"""
-
-import logging
-from aenum import IntEnum
-
-from hvl_ccb.utils.enum import ValueEnum, unique
-
-logger = logging.getLogger(__name__)
-
-
-class SupercubeOpcEndpoint(ValueEnum):
-    """
-    OPC Server Endpoint strings for the supercube variants.
-    """
-
-    A = "OPC.SimaticNET.S7"
-    B = "OPC.SimaticNET.S7"
-
-
-@unique
-class GeneralSupport(ValueEnum):
-    """
-    NodeID strings for the support inputs and outputs.
-    """
-
-    in_1_1 = "hvl-ipc.WINAC.Support1InA"
-    in_1_2 = "hvl-ipc.WINAC.Support1InB"
-    in_2_1 = "hvl-ipc.WINAC.Support2InA"
-    in_2_2 = "hvl-ipc.WINAC.Support2InB"
-    in_3_1 = "hvl-ipc.WINAC.Support3InA"
-    in_3_2 = "hvl-ipc.WINAC.Support3InB"
-    in_4_1 = "hvl-ipc.WINAC.Support4InA"
-    in_4_2 = "hvl-ipc.WINAC.Support4InB"
-    in_5_1 = "hvl-ipc.WINAC.Support5InA"
-    in_5_2 = "hvl-ipc.WINAC.Support5InB"
-    in_6_1 = "hvl-ipc.WINAC.Support6InA"
-    in_6_2 = "hvl-ipc.WINAC.Support6InB"
-    out_1_1 = "hvl-ipc.WINAC.Support1OutA"
-    out_1_2 = "hvl-ipc.WINAC.Support1OutB"
-    out_2_1 = "hvl-ipc.WINAC.Support2OutA"
-    out_2_2 = "hvl-ipc.WINAC.Support2OutB"
-    out_3_1 = "hvl-ipc.WINAC.Support3OutA"
-    out_3_2 = "hvl-ipc.WINAC.Support3OutB"
-    out_4_1 = "hvl-ipc.WINAC.Support4OutA"
-    out_4_2 = "hvl-ipc.WINAC.Support4OutB"
-    out_5_1 = "hvl-ipc.WINAC.Support5OutA"
-    out_5_2 = "hvl-ipc.WINAC.Support5OutB"
-    out_6_1 = "hvl-ipc.WINAC.Support6OutA"
-    out_6_2 = "hvl-ipc.WINAC.Support6OutB"
-
-    @classmethod
-    def output(cls, port, contact):
-        """
-        Get the NodeID string for a support output.
-
-        :param port: the desired port (1..6)
-        :param contact: the desired contact at the port (1..2)
-        :return: the node id string
-        """
-
-        return getattr(cls, f"out_{port}_{contact}")
-
-    @classmethod
-    def input(cls, port, contact):
-        """
-        Get the NodeID string for a support input.
-
-        :param port: the desired port (1..6)
-        :param contact: the desired contact at the port (1..2)
-        :return: the node id string
-        """
-
-        return getattr(cls, f"in_{port}_{contact}")
-
-
-@unique
-class BreakdownDetection(ValueEnum):
-    """
-    Node ID strings for the breakdown detection.
-    """
-
-    #: Boolean read-only variable indicating whether breakdown detection and fast
-    #: switchoff is enabled in the system or not.
-    activated = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.Breakdowndetection.connect"
-
-    #: Boolean read-only variable telling whether the fast switch-off has triggered.
-    #: This can also be seen using the safety circuit state, therefore no method is
-    #: implemented to read this out directly.
-    triggered = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.Breakdowndetection.triggered"
-
-    #: Boolean writable variable to reset the fast switch-off. Toggle to re-enable.
-    reset = "hvl-ipc.WINAC.Support6OutA"
-
-
-@unique
-class GeneralSockets(ValueEnum):
-    """
-    NodeID strings for the power sockets (3x T13 and 1xCEE16).
-    """
-
-    #: SEV T13 socket No. 1 (writable boolean).
-    t13_1 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_1"
-
-    #: SEV T13 socket No. 2 (writable boolean).
-    t13_2 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_2"
-
-    #: SEV T13 socket No. 3 (writable boolean).
-    t13_3 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_3"
-
-    #: CEE16 socket (writeable boolean).
-    cee16 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.CEE16"
-
-
-T13_SOCKET_PORTS = (1, 2, 3)
-"""
-Port numbers of SEV T13 power socket
-"""
-
-
-@unique
-class Safety(ValueEnum):
-    """
-    NodeID strings for the basic safety circuit status and green/red switches "ready"
-    and "operate".
-    """
-
-    #: Status is a read-only integer containing the state number of the
-    #: supercube-internal state machine. The values correspond to numbers in
-    #: :class:`SafetyStatus`.
-    status_ready_for_red = "hvl-ipc.WINAC.SYSTEMSTATE.ReadyForRed"
-    status_red = "hvl-ipc.WINAC.SYSTEMSTATE.RED"
-    status_green = "hvl-ipc.WINAC.SYSTEMSTATE.GREEN"
-    status_error = "hvl-ipc.WINAC.SYSTEMSTATE.ERROR"
-
-    #: Writable boolean for switching to Red Ready (locked, HV off) state.
-    switchto_ready = "hvl-ipc.WINAC.SYSTEMSTATE.RED_REQUEST"
-    switchto_green = "hvl-ipc.WINAC.SYSTEMSTATE.GREEN_REQUEST"
-
-    #: Writable boolean for switching to Red Operate (locket, HV on) state.
-    switchto_operate = "hvl-ipc.WINAC.SYSTEMSTATE.switchon"
-
-    #: Writeable boolean to manually turn on or off the horn
-    horn = "hvl-ipc.WINAC.SYSTEM_INTERN.hornen"
-
-
-class SafetyStatus(IntEnum):
-    """
-    Safety status values that are possible states returned from
-    :meth:`hvl_ccb.dev.supercube.base.Supercube.get_status`. These
-    values correspond to the states of the Supercube's safety circuit statemachine.
-    """
-
-    #: System is initializing or booting.
-    Initializing = 0
-
-    #: System is safe, lamps are green and some safety elements are not in place such
-    #: that it cannot be switched to red currently.
-    GreenNotReady = 1
-
-    #: System is safe and all safety elements are in place to be able to switch to
-    #: *ready*.
-    GreenReady = 2
-
-    #: System is locked in red state and *ready* to go to *operate* mode.
-    RedReady = 3
-
-    #: System is locked in red state and in *operate* mode, i.e. high voltage on.
-    RedOperate = 4
-
-    #: Fast turn off triggered and switched off the system. Reset FSO to go back to a
-    #: normal state.
-    QuickStop = 5
-
-    #: System is in error mode.
-    Error = 6
-
-
-@unique
-class Power(ValueEnum):
-    """
-    Variable NodeID strings concerning power data.
-    """
-
-    #: Primary voltage in volts, measured by the frequency converter at its output.
-    #: (read-only)
-    voltage_primary = "hvl-ipc.WINAC.SYSTEM_INTERN.FUVoltageprim"
-
-    #: Primary current in ampere, measured by the frequency converter. (read-only)
-    current_primary = "hvl-ipc.WINAC.SYSTEM_INTERN.FUCurrentprim"
-
-    #: Power setup that is configured using the Supercube HMI. The value corresponds to
-    #: the ones in :class:`PowerSetup`. (read-only)
-    setup = "hvl-ipc.WINAC.FU.TrafoSetup"
-
-    #: Voltage slope in V/s.
-    voltage_slope = "hvl-ipc.WINAC.FU.dUdt_-1"
-
-    #: Target voltage setpoint in V.
-    voltage_target = "hvl-ipc.WINAC.FU.SOLL"
-
-    #: Maximum voltage allowed by the current experimental setup. (read-only)
-    voltage_max = "hvl-ipc.WINAC.FU.maxVoltagekV"
-
-    #: Frequency converter output frequency. (read-only)
-    frequency = "hvl-ipc.WINAC.FU.Frequency"
-
-
-class PowerSetup(IntEnum):
-    """
-    Possible power setups corresponding to the value of variable :attr:`Power.setup`.
-    """
-
-    #: No safety switches, use only safety components (doors, fence, earthing...)
-    #: without any power.
-    # NoPower = 0
-
-    #: External power supply fed through blue CEE32 input using isolation transformer
-    #: and safety switches of the Supercube, or using an external safety switch
-    #: attached to the Supercube Type B.
-    External = 0
-
-    #: AC voltage with MWB transformer set to 50kV maximum voltage.
-    AC_SingleStage_50kV = 1
-
-    #: AC voltage with MWB transformer set to 100kV maximum voltage.
-    AC_SingleStage_100kV = 2
-
-    #: AC voltage with two MWB transformers, one at 100kV and the other at 50kV,
-    #: resulting in a total maximum voltage of 150kV.
-    AC_DoubleStage_150kV = 3
-
-    #: AC voltage with two MWB transformers both at 100kV, resulting in a total
-    #: maximum voltage of 200kV
-    AC_DoubleStage_200kV = 4
-
-    #: Internal usage of the frequency converter, controlling to the primary voltage
-    #: output of the supercube itself (no measurement transformer used)
-    Internal = 5
-
-    #: DC voltage with one AC transformer set to 100kV AC, resulting in 140kV DC
-    DC_SingleStage_140kV = 6
-
-    #: DC voltage with two AC transformers set to 100kV AC each, resulting in 280kV
-    #: DC in total (or a single stage transformer with Greinacher voltage doubling
-    #: rectifier)
-    DC_DoubleStage_280kV = 7
-
-
-@unique
-class MeasurementsScaledInput(ValueEnum):
-    """
-    Variable NodeID strings for the four analog BNC inputs for measuring voltage.
-    The voltage returned in these variables is already scaled with the set ratio,
-    which can be read using the variables in :class:`MeasurementsDividerRatio`.
-    """
-
-    input_1 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI1Volt"
-    input_2 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI2Volt"
-    input_3 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI3Volt"
-    input_4 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI4Volt"
-
-    @classmethod
-    def get(cls, channel: int):
-        """
-        Get the attribute for an input number.
-
-        :param channel: the channel number (1..4)
-        :return: the enum for the desired channel.
-        """
-
-        return getattr(cls, f"input_{channel}")
-
-
-@unique
-class MeasurementsDividerRatio(ValueEnum):
-    """
-    Variable NodeID strings for the measurement input scaling ratios. These ratios
-    are defined in the Supercube HMI setup and are provided in the python module here
-    to be able to read them out, allowing further calculations.
-    """
-
-    input_1 = "hvl-ipc.WINAC.SYSTEM_INTERN.DivididerRatio"
-
-    @classmethod
-    def get(cls, channel: int):
-        """
-        Get the attribute for an input number.
-
-        :param channel: the channel number (1..4)
-        :return: the enum for the desired channel.
-        """
-
-        return getattr(cls, f"input_{channel}")
-
-
-class EarthingStickStatus(IntEnum):
-    """
-    Status of an earthing stick. These are the possible values in the status integer
-    e.g. in :attr:`EarthingStick.status_1`.
-    """
-
-    #: Earthing stick is deselected and not enabled in safety circuit. To get out of
-    #: this state, the earthing has to be enabled in the Supercube HMI setup.
-    inactive = 0
-
-    #: Earthing is closed (safe).
-    closed = 1
-
-    #: Earthing is open (not safe).
-    open = 2
-
-    #: Earthing is in error, e.g. when the stick did not close correctly or could not
-    #: open.
-    error = 3
-
-
-@unique
-class EarthingStick(ValueEnum):
-    """
-    Variable NodeID strings for all earthing stick statuses (read-only integer) and
-    writable booleans for setting the earthing in manual mode.
-    """
-
-    status_1_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.CLOSE"
-    status_1_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.OPEN"
-    status_1_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.CONNECT"
-    status_2_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.CLOSE"
-    status_2_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.OPEN"
-    status_2_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.CONNECT"
-    status_3_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.CLOSE"
-    status_3_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.OPEN"
-    status_3_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.CONNECT"
-    status_4_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.CLOSE"
-    status_4_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.OPEN"
-    status_4_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.CONNECT"
-    status_5_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.CLOSE"
-    status_5_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.OPEN"
-    status_5_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.CONNECT"
-    status_6_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.CLOSE"
-    status_6_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.OPEN"
-    status_6_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.CONNECT"
-
-    manual_1 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.MANUAL"
-    manual_2 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.MANUAL"
-    manual_3 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.MANUAL"
-    manual_4 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.MANUAL"
-    manual_5 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.MANUAL"
-    manual_6 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.MANUAL"
-
-    @classmethod
-    def status_open(cls, number: int):
-        """
-        Get the status enum attribute for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the status enum
-        """
-
-        return getattr(cls, f"status_{number}_open")
-
-    @classmethod
-    def status_closed(cls, number: int):
-        """
-        Get the status enum attribute for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the status enum
-        """
-
-        return getattr(cls, f"status_{number}_closed")
-
-    @classmethod
-    def status_connected(cls, number: int):
-        """
-        Get the status enum attribute for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the status enum
-        """
-
-        return getattr(cls, f"status_{number}_connected")
-
-    @classmethod
-    def manual(cls, number: int):
-        """
-        Get the manual enum attribute for an earthing stick number.
-
-        :param number: the earthing stick (1..6)
-        :return: the manual enum
-        """
-
-        return getattr(cls, f"manual_{number}")
-
-
-@unique
-class Errors(ValueEnum):
-    """
-    Variable NodeID strings for information regarding error, warning and message
-    handling.
-    """
-
-    #: Boolean read-only variable telling if a stop is active.
-    stop = "hvl-ipc.WINAC.SYSTEMSTATE.ERROR"
-    stop_number = "hvl-ipc.WINAC.SYSTEMSTATE.Errornumber"
-
-    #: Writable boolean for the error quit button.
-    quit = "hvl-ipc.WINAC.SYSTEMSTATE.Faultconfirmation"
-
-
-class DoorStatus(IntEnum):
-    """
-    Possible status values for doors.
-    """
-
-    #: not enabled in Supercube HMI setup, this door is not supervised.
-    inactive = 0
-
-    #: Door is open.
-    open = 1
-
-    #: Door is closed, but not locked.
-    closed = 2
-
-    #: Door is closed and locked (safe state).
-    locked = 3
-
-    #: Door has an error or was opened in locked state (either with emergency stop or
-    #: from the inside).
-    error = 4
-
-
-class AlarmText(ValueEnum):
-    """
-    This enumeration contains textual representations for all error classes (stop,
-    warning and message) of the Supercube system. Use the :meth:`AlarmText.get`
-    method to retrieve the enum of an alarm number.
-    """
-
-    # No alarm
-    Alarm0 = "No Alarm."
-
-    # Safety elements
-    Alarm1 = "STOP Safety switch 1 error"
-    Alarm2 = "STOP Safety switch 2 error"
-    Alarm3 = "STOP Emergency Stop 1"
-    Alarm4 = "STOP Emergency Stop 2"
-    Alarm5 = "STOP Emergency Stop 3"
-    Alarm6 = "STOP Door 1 lock supervision"
-    Alarm7 = "STOP Door 2 lock supervision"
-    Alarm8 = "STOP Door 3 lock supervision"
-    Alarm9 = "STOP Earthing stick 1 error"
-    Alarm10 = "STOP Earthing stick 2 error"
-    Alarm11 = "STOP Earthing stick 3 error"
-    Alarm12 = "STOP Earthing stick 4 error"
-    Alarm13 = "STOP Earthing stick 5 error"
-    Alarm14 = "STOP Earthing stick 6 error"
-    Alarm17 = "STOP Source switch error"
-    Alarm19 = "STOP Fence 1 error"
-    Alarm20 = "STOP Fence 2 error"
-    Alarm21 = "STOP Control error"
-    Alarm22 = "STOP Power outage"
-
-    # generic not defined alarm text
-    not_defined = "NO ALARM TEXT DEFINED"
-
-    @classmethod
-    def get(cls, alarm: int):
-        """
-        Get the attribute of this enum for an alarm number.
-
-        :param alarm: the alarm number
-        :return: the enum for the desired alarm number
-        """
-
-        try:
-            return getattr(cls, f"Alarm{alarm}")
-        except AttributeError as e:
-            logger.error(str(e), exc_info=e)
-            return cls.not_defined
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Constants, variable names for the Supercube OPC-connected devices.
+"""
+
+import logging
+from aenum import IntEnum
+
+from hvl_ccb.utils.enum import ValueEnum, unique
+
+logger = logging.getLogger(__name__)
+
+
+class SupercubeOpcEndpoint(ValueEnum):
+    """
+    OPC Server Endpoint strings for the supercube variants.
+    """
+
+    A = "OPC.SimaticNET.S7"
+    B = "OPC.SimaticNET.S7"
+
+
+@unique
+class GeneralSupport(ValueEnum):
+    """
+    NodeID strings for the support inputs and outputs.
+    """
+
+    in_1_1 = "hvl-ipc.WINAC.Support1InA"
+    in_1_2 = "hvl-ipc.WINAC.Support1InB"
+    in_2_1 = "hvl-ipc.WINAC.Support2InA"
+    in_2_2 = "hvl-ipc.WINAC.Support2InB"
+    in_3_1 = "hvl-ipc.WINAC.Support3InA"
+    in_3_2 = "hvl-ipc.WINAC.Support3InB"
+    in_4_1 = "hvl-ipc.WINAC.Support4InA"
+    in_4_2 = "hvl-ipc.WINAC.Support4InB"
+    in_5_1 = "hvl-ipc.WINAC.Support5InA"
+    in_5_2 = "hvl-ipc.WINAC.Support5InB"
+    in_6_1 = "hvl-ipc.WINAC.Support6InA"
+    in_6_2 = "hvl-ipc.WINAC.Support6InB"
+    out_1_1 = "hvl-ipc.WINAC.Support1OutA"
+    out_1_2 = "hvl-ipc.WINAC.Support1OutB"
+    out_2_1 = "hvl-ipc.WINAC.Support2OutA"
+    out_2_2 = "hvl-ipc.WINAC.Support2OutB"
+    out_3_1 = "hvl-ipc.WINAC.Support3OutA"
+    out_3_2 = "hvl-ipc.WINAC.Support3OutB"
+    out_4_1 = "hvl-ipc.WINAC.Support4OutA"
+    out_4_2 = "hvl-ipc.WINAC.Support4OutB"
+    out_5_1 = "hvl-ipc.WINAC.Support5OutA"
+    out_5_2 = "hvl-ipc.WINAC.Support5OutB"
+    out_6_1 = "hvl-ipc.WINAC.Support6OutA"
+    out_6_2 = "hvl-ipc.WINAC.Support6OutB"
+
+    @classmethod
+    def output(cls, port, contact):
+        """
+        Get the NodeID string for a support output.
+
+        :param port: the desired port (1..6)
+        :param contact: the desired contact at the port (1..2)
+        :return: the node id string
+        """
+
+        return getattr(cls, f"out_{port}_{contact}")
+
+    @classmethod
+    def input(cls, port, contact):
+        """
+        Get the NodeID string for a support input.
+
+        :param port: the desired port (1..6)
+        :param contact: the desired contact at the port (1..2)
+        :return: the node id string
+        """
+
+        return getattr(cls, f"in_{port}_{contact}")
+
+
+@unique
+class BreakdownDetection(ValueEnum):
+    """
+    Node ID strings for the breakdown detection.
+    """
+
+    #: Boolean read-only variable indicating whether breakdown detection and fast
+    #: switchoff is enabled in the system or not.
+    activated = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.Breakdowndetection.connect"
+
+    #: Boolean read-only variable telling whether the fast switch-off has triggered.
+    #: This can also be seen using the safety circuit state, therefore no method is
+    #: implemented to read this out directly.
+    triggered = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.Breakdowndetection.triggered"
+
+    #: Boolean writable variable to reset the fast switch-off. Toggle to re-enable.
+    reset = "hvl-ipc.WINAC.Support6OutA"
+
+
+@unique
+class GeneralSockets(ValueEnum):
+    """
+    NodeID strings for the power sockets (3x T13 and 1xCEE16).
+    """
+
+    #: SEV T13 socket No. 1 (writable boolean).
+    t13_1 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_1"
+
+    #: SEV T13 socket No. 2 (writable boolean).
+    t13_2 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_2"
+
+    #: SEV T13 socket No. 3 (writable boolean).
+    t13_3 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.T13_3"
+
+    #: CEE16 socket (writeable boolean).
+    cee16 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.CEE16"
+
+
+T13_SOCKET_PORTS = (1, 2, 3)
+"""
+Port numbers of SEV T13 power socket
+"""
+
+
+@unique
+class Safety(ValueEnum):
+    """
+    NodeID strings for the basic safety circuit status and green/red switches "ready"
+    and "operate".
+    """
+
+    #: Status is a read-only integer containing the state number of the
+    #: supercube-internal state machine. The values correspond to numbers in
+    #: :class:`SafetyStatus`.
+    status_ready_for_red = "hvl-ipc.WINAC.SYSTEMSTATE.ReadyForRed"
+    status_red = "hvl-ipc.WINAC.SYSTEMSTATE.RED"
+    status_green = "hvl-ipc.WINAC.SYSTEMSTATE.GREEN"
+    status_error = "hvl-ipc.WINAC.SYSTEMSTATE.ERROR"
+
+    #: Writable boolean for switching to Red Ready (locked, HV off) state.
+    switchto_ready = "hvl-ipc.WINAC.SYSTEMSTATE.RED_REQUEST"
+    switchto_green = "hvl-ipc.WINAC.SYSTEMSTATE.GREEN_REQUEST"
+
+    #: Writable boolean for switching to Red Operate (locket, HV on) state.
+    switchto_operate = "hvl-ipc.WINAC.SYSTEMSTATE.switchon"
+
+    #: Writeable boolean to manually turn on or off the horn
+    horn = "hvl-ipc.WINAC.SYSTEM_INTERN.hornen"
+
+
+class SafetyStatus(IntEnum):
+    """
+    Safety status values that are possible states returned from
+    :meth:`hvl_ccb.dev.supercube.base.Supercube.get_status`. These
+    values correspond to the states of the Supercube's safety circuit statemachine.
+    """
+
+    #: System is initializing or booting.
+    Initializing = 0
+
+    #: System is safe, lamps are green and some safety elements are not in place such
+    #: that it cannot be switched to red currently.
+    GreenNotReady = 1
+
+    #: System is safe and all safety elements are in place to be able to switch to
+    #: *ready*.
+    GreenReady = 2
+
+    #: System is locked in red state and *ready* to go to *operate* mode.
+    RedReady = 3
+
+    #: System is locked in red state and in *operate* mode, i.e. high voltage on.
+    RedOperate = 4
+
+    #: Fast turn off triggered and switched off the system. Reset FSO to go back to a
+    #: normal state.
+    QuickStop = 5
+
+    #: System is in error mode.
+    Error = 6
+
+
+@unique
+class Power(ValueEnum):
+    """
+    Variable NodeID strings concerning power data.
+    """
+
+    #: Primary voltage in volts, measured by the frequency converter at its output.
+    #: (read-only)
+    voltage_primary = "hvl-ipc.WINAC.SYSTEM_INTERN.FUVoltageprim"
+
+    #: Primary current in ampere, measured by the frequency converter. (read-only)
+    current_primary = "hvl-ipc.WINAC.SYSTEM_INTERN.FUCurrentprim"
+
+    #: Power setup that is configured using the Supercube HMI. The value corresponds to
+    #: the ones in :class:`PowerSetup`. (read-only)
+    setup = "hvl-ipc.WINAC.FU.TrafoSetup"
+
+    #: Voltage slope in V/s.
+    voltage_slope = "hvl-ipc.WINAC.FU.dUdt_-1"
+
+    #: Target voltage setpoint in V.
+    voltage_target = "hvl-ipc.WINAC.FU.SOLL"
+
+    #: Maximum voltage allowed by the current experimental setup. (read-only)
+    voltage_max = "hvl-ipc.WINAC.FU.maxVoltagekV"
+
+    #: Frequency converter output frequency. (read-only)
+    frequency = "hvl-ipc.WINAC.FU.Frequency"
+
+
+class PowerSetup(IntEnum):
+    """
+    Possible power setups corresponding to the value of variable :attr:`Power.setup`.
+    """
+
+    #: No safety switches, use only safety components (doors, fence, earthing...)
+    #: without any power.
+    # NoPower = 0
+
+    #: External power supply fed through blue CEE32 input using isolation transformer
+    #: and safety switches of the Supercube, or using an external safety switch
+    #: attached to the Supercube Type B.
+    External = 0
+
+    #: AC voltage with MWB transformer set to 50kV maximum voltage.
+    AC_SingleStage_50kV = 1
+
+    #: AC voltage with MWB transformer set to 100kV maximum voltage.
+    AC_SingleStage_100kV = 2
+
+    #: AC voltage with two MWB transformers, one at 100kV and the other at 50kV,
+    #: resulting in a total maximum voltage of 150kV.
+    AC_DoubleStage_150kV = 3
+
+    #: AC voltage with two MWB transformers both at 100kV, resulting in a total
+    #: maximum voltage of 200kV
+    AC_DoubleStage_200kV = 4
+
+    #: Internal usage of the frequency converter, controlling to the primary voltage
+    #: output of the supercube itself (no measurement transformer used)
+    Internal = 5
+
+    #: DC voltage with one AC transformer set to 100kV AC, resulting in 140kV DC
+    DC_SingleStage_140kV = 6
+
+    #: DC voltage with two AC transformers set to 100kV AC each, resulting in 280kV
+    #: DC in total (or a single stage transformer with Greinacher voltage doubling
+    #: rectifier)
+    DC_DoubleStage_280kV = 7
+
+
+@unique
+class MeasurementsScaledInput(ValueEnum):
+    """
+    Variable NodeID strings for the four analog BNC inputs for measuring voltage.
+    The voltage returned in these variables is already scaled with the set ratio,
+    which can be read using the variables in :class:`MeasurementsDividerRatio`.
+    """
+
+    input_1 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI1Volt"
+    input_2 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI2Volt"
+    input_3 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI3Volt"
+    input_4 = "hvl-ipc.WINAC.SYSTEM_INTERN.AI4Volt"
+
+    @classmethod
+    def get(cls, channel: int):
+        """
+        Get the attribute for an input number.
+
+        :param channel: the channel number (1..4)
+        :return: the enum for the desired channel.
+        """
+
+        return getattr(cls, f"input_{channel}")
+
+
+@unique
+class MeasurementsDividerRatio(ValueEnum):
+    """
+    Variable NodeID strings for the measurement input scaling ratios. These ratios
+    are defined in the Supercube HMI setup and are provided in the python module here
+    to be able to read them out, allowing further calculations.
+    """
+
+    input_1 = "hvl-ipc.WINAC.SYSTEM_INTERN.DivididerRatio"
+
+    @classmethod
+    def get(cls, channel: int):
+        """
+        Get the attribute for an input number.
+
+        :param channel: the channel number (1..4)
+        :return: the enum for the desired channel.
+        """
+
+        return getattr(cls, f"input_{channel}")
+
+
+class EarthingStickStatus(IntEnum):
+    """
+    Status of an earthing stick. These are the possible values in the status integer
+    e.g. in :attr:`EarthingStick.status_1`.
+    """
+
+    #: Earthing stick is deselected and not enabled in safety circuit. To get out of
+    #: this state, the earthing has to be enabled in the Supercube HMI setup.
+    inactive = 0
+
+    #: Earthing is closed (safe).
+    closed = 1
+
+    #: Earthing is open (not safe).
+    open = 2
+
+    #: Earthing is in error, e.g. when the stick did not close correctly or could not
+    #: open.
+    error = 3
+
+
+@unique
+class EarthingStick(ValueEnum):
+    """
+    Variable NodeID strings for all earthing stick statuses (read-only integer) and
+    writable booleans for setting the earthing in manual mode.
+    """
+
+    status_1_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.CLOSE"
+    status_1_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.OPEN"
+    status_1_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.CONNECT"
+    status_2_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.CLOSE"
+    status_2_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.OPEN"
+    status_2_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.CONNECT"
+    status_3_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.CLOSE"
+    status_3_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.OPEN"
+    status_3_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.CONNECT"
+    status_4_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.CLOSE"
+    status_4_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.OPEN"
+    status_4_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.CONNECT"
+    status_5_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.CLOSE"
+    status_5_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.OPEN"
+    status_5_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.CONNECT"
+    status_6_closed = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.CLOSE"
+    status_6_open = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.OPEN"
+    status_6_connected = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.CONNECT"
+
+    manual_1 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_1.MANUAL"
+    manual_2 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_2.MANUAL"
+    manual_3 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_3.MANUAL"
+    manual_4 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_4.MANUAL"
+    manual_5 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_5.MANUAL"
+    manual_6 = "hvl-ipc.WINAC.SYSTEM_COMPONENTS.STICK_6.MANUAL"
+
+    @classmethod
+    def status_open(cls, number: int):
+        """
+        Get the status enum attribute for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the status enum
+        """
+
+        return getattr(cls, f"status_{number}_open")
+
+    @classmethod
+    def status_closed(cls, number: int):
+        """
+        Get the status enum attribute for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the status enum
+        """
+
+        return getattr(cls, f"status_{number}_closed")
+
+    @classmethod
+    def status_connected(cls, number: int):
+        """
+        Get the status enum attribute for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the status enum
+        """
+
+        return getattr(cls, f"status_{number}_connected")
+
+    @classmethod
+    def manual(cls, number: int):
+        """
+        Get the manual enum attribute for an earthing stick number.
+
+        :param number: the earthing stick (1..6)
+        :return: the manual enum
+        """
+
+        return getattr(cls, f"manual_{number}")
+
+
+@unique
+class Errors(ValueEnum):
+    """
+    Variable NodeID strings for information regarding error, warning and message
+    handling.
+    """
+
+    #: Boolean read-only variable telling if a stop is active.
+    stop = "hvl-ipc.WINAC.SYSTEMSTATE.ERROR"
+    stop_number = "hvl-ipc.WINAC.SYSTEMSTATE.Errornumber"
+
+    #: Writable boolean for the error quit button.
+    quit = "hvl-ipc.WINAC.SYSTEMSTATE.Faultconfirmation"
+
+
+class DoorStatus(IntEnum):
+    """
+    Possible status values for doors.
+    """
+
+    #: not enabled in Supercube HMI setup, this door is not supervised.
+    inactive = 0
+
+    #: Door is open.
+    open = 1
+
+    #: Door is closed, but not locked.
+    closed = 2
+
+    #: Door is closed and locked (safe state).
+    locked = 3
+
+    #: Door has an error or was opened in locked state (either with emergency stop or
+    #: from the inside).
+    error = 4
+
+
+class AlarmText(ValueEnum):
+    """
+    This enumeration contains textual representations for all error classes (stop,
+    warning and message) of the Supercube system. Use the :meth:`AlarmText.get`
+    method to retrieve the enum of an alarm number.
+    """
+
+    # No alarm
+    Alarm0 = "No Alarm."
+
+    # Safety elements
+    Alarm1 = "STOP Safety switch 1 error"
+    Alarm2 = "STOP Safety switch 2 error"
+    Alarm3 = "STOP Emergency Stop 1"
+    Alarm4 = "STOP Emergency Stop 2"
+    Alarm5 = "STOP Emergency Stop 3"
+    Alarm6 = "STOP Door 1 lock supervision"
+    Alarm7 = "STOP Door 2 lock supervision"
+    Alarm8 = "STOP Door 3 lock supervision"
+    Alarm9 = "STOP Earthing stick 1 error"
+    Alarm10 = "STOP Earthing stick 2 error"
+    Alarm11 = "STOP Earthing stick 3 error"
+    Alarm12 = "STOP Earthing stick 4 error"
+    Alarm13 = "STOP Earthing stick 5 error"
+    Alarm14 = "STOP Earthing stick 6 error"
+    Alarm17 = "STOP Source switch error"
+    Alarm19 = "STOP Fence 1 error"
+    Alarm20 = "STOP Fence 2 error"
+    Alarm21 = "STOP Control error"
+    Alarm22 = "STOP Power outage"
+
+    # generic not defined alarm text
+    not_defined = "NO ALARM TEXT DEFINED"
+
+    @classmethod
+    def get(cls, alarm: int):
+        """
+        Get the attribute of this enum for an alarm number.
+
+        :param alarm: the alarm number
+        :return: the enum for the desired alarm number
+        """
+
+        try:
+            return getattr(cls, f"Alarm{alarm}")
+        except AttributeError as e:
+            logger.error(str(e), exc_info=e)
+            return cls.not_defined
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/__init__.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/__init__.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-This module is a wrapper around LibTiePie SDK devices; see
-https://www.tiepie.com/en/libtiepie-sdk .
-
-The device classes adds simplifications for starting of the device (using serial
-number) and managing mutable configuration of both the device and oscilloscope's
-channels. This includes extra validation and typing hints support.
-
-Extra installation
-~~~~~~~~~~~~~~~~~~
-
-LibTiePie SDK library is available only on Windows and on Linux.
-
-To use this LibTiePie SDK devices wrapper:
-
-1. install the :code:`hvl_ccb` package with a :code:`tiepie` extra feature::
-
-        $ pip install "hvl_ccb[tiepie]"
-
-   this will install the Python bindings for the library.
-
-2. install the library
-
-    * on Linux: follow instructions in https://www.tiepie.com/en/libtiepie-sdk/linux ;
-    * on Windows: the additional DLL is included in Python bindings package.
-
-Troubleshooting
-...............
-
-On a Windows system, if you encounter an :code:`OSError` like this::
-
-    ...
-        self._handle = _dlopen(self._name, mode)
-    OSError: [WinError 126] The specified module could not be found
-
-most likely the :code:`python-libtiepie` package was installed in your
-:code:`site-packages/` directory as a :code:`python-libtiepie-*.egg` file via
-:code:`python setup.py install` or :code:`python setup.py develop` command. In such
-case uninstall the library and re-install it using :code:`pip`::
-
-    $ pip uninstall python-libtiepie
-    $ pip install python-libtiepie
-
-This should create :code:`libtiepie/` folder. Alternatively, manually move the folder
-:code:`libtiepie/` from inside of the :code:`.egg` archive file to the containing it
-:code:`site-packages/` directory (PyCharm's Project tool window supports reading and
-extracting from :code:`.egg` archives).
-
-"""
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+This module is a wrapper around LibTiePie SDK devices; see
+https://www.tiepie.com/en/libtiepie-sdk .
+
+The device classes adds simplifications for starting of the device (using serial
+number) and managing mutable configuration of both the device and oscilloscope's
+channels. This includes extra validation and typing hints support.
+
+Extra installation
+~~~~~~~~~~~~~~~~~~
+
+LibTiePie SDK library is available only on Windows and on Linux.
+
+To use this LibTiePie SDK devices wrapper:
+
+1. install the :code:`hvl_ccb` package with a :code:`tiepie` extra feature::
+
+        $ pip install "hvl_ccb[tiepie]"
+
+   this will install the Python bindings for the library.
+
+2. install the library
+
+    * on Linux: follow instructions in https://www.tiepie.com/en/libtiepie-sdk/linux ;
+    * on Windows: the additional DLL is included in Python bindings package.
+
+Troubleshooting
+...............
+
+On a Windows system, if you encounter an :code:`OSError` like this::
+
+    ...
+        self._handle = _dlopen(self._name, mode)
+    OSError: [WinError 126] The specified module could not be found
+
+most likely the :code:`python-libtiepie` package was installed in your
+:code:`site-packages/` directory as a :code:`python-libtiepie-*.egg` file via
+:code:`python setup.py install` or :code:`python setup.py develop` command. In such
+case uninstall the library and re-install it using :code:`pip`::
+
+    $ pip uninstall python-libtiepie
+    $ pip install python-libtiepie
+
+This should create :code:`libtiepie/` folder. Alternatively, manually move the folder
+:code:`libtiepie/` from inside of the :code:`.egg` archive file to the containing it
+:code:`site-packages/` directory (PyCharm's Project tool window supports reading and
+extracting from :code:`.egg` archives).
+
+"""
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/base.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/base.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,245 +1,245 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-
-import time
-import logging
-
-import libtiepie as ltp
-from libtiepie import generator as ltp_gen
-from libtiepie import i2chost as ltp_i2c
-from libtiepie import oscilloscope as ltp_osc
-from libtiepie.exceptions import LibTiePieException, InvalidDeviceSerialNumberError
-
-from ...configuration import configdataclass
-from ...utils.typing import Number
-from ...utils.enum import NameEnum
-
-from functools import wraps
-from typing import (
-    Callable,
-    Optional,
-    Tuple,
-    TypeVar,
-    Union,
-)
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class TiePieDeviceConfig:
-    """
-    Configuration dataclass for TiePie
-    """
-
-    serial_number: int
-    require_block_measurement_support: bool = True
-    n_max_try_get_device: int = 10
-    wait_sec_retry_get_device: Number = 1.0
-    is_data_ready_polling_interval_sec: Number = 0.01
-
-    def clean_values(self):
-        if self.serial_number <= 0:
-            raise ValueError("serial_number must be a positive integer.")
-        if self.n_max_try_get_device <= 0:
-            raise ValueError("n_max_try_get_device must be an positive integer.")
-        if self.wait_sec_retry_get_device <= 0:
-            raise ValueError("wait_sec_retry_get_device must be a positive number.")
-        if self.is_data_ready_polling_interval_sec <= 0:
-            raise ValueError(
-                "is_data_ready_polling_interval_sec must be a positive number."
-            )
-
-
-class TiePieDeviceType(NameEnum):
-    """
-    TiePie device type.
-    """
-
-    _init_ = "value ltp_class"
-    OSCILLOSCOPE = ltp.DEVICETYPE_OSCILLOSCOPE, ltp_osc.Oscilloscope
-    I2C = ltp.DEVICETYPE_I2CHOST, ltp_i2c.I2CHost
-    GENERATOR = ltp.DEVICETYPE_GENERATOR, ltp_gen.Generator
-
-
-class TiePieError(Exception):
-    """
-    Error of the class TiePie
-    """
-
-    pass
-
-
-def wrap_libtiepie_exception(func: Callable) -> Callable:
-    """
-    Decorator wrapper for `libtiepie` methods that use
-    `libtiepie.library.check_last_status_raise_on_error()` calls.
-
-    :param func: Function or method to be wrapped
-    :raises TiePieError: instead of `LibTiePieException` or one of its subtypes.
-    :return: whatever `func` returns
-    """
-
-    @wraps(func)
-    def wrapped_func(*args, **kwargs):
-        try:
-            return func(*args, **kwargs)
-        except LibTiePieException as e:
-            logger.error(str(e), exc_info=e)
-            raise TiePieError from e
-
-    return wrapped_func
-
-
-_LtpDeviceReturnType = TypeVar("_LtpDeviceReturnType")
-"""
-An auxiliary typing hint of a `libtiepie` device type for return value of
-the `get_device_by_serial_number` function and the wrapper methods using it.
-"""
-
-
-@wrap_libtiepie_exception
-def get_device_by_serial_number(
-    serial_number: int,
-    # Note: TiePieDeviceType aenum as a tuple to define a return value type
-    device_type: Union[str, Tuple[int, _LtpDeviceReturnType]],
-    n_max_try_get_device: int = 10,
-    wait_sec_retry_get_device: float = 1.0,
-) -> _LtpDeviceReturnType:
-    """
-    Open and return handle of TiePie device with a given serial number
-
-    :param serial_number: int serial number of the device
-    :param device_type: a `TiePieDeviceType` instance containing device identifier (int
-        number) and its corresponding class, both from `libtiepie`, or a string name
-        of such instance
-    :param n_max_try_get_device: maximal number of device list updates (int number)
-    :param wait_sec_retry_get_device: waiting time in seconds between retries (int
-        number)
-    :return: Instance of a `libtiepie`  device class according to the specified
-        `device_type`
-    :raises TiePieError: when there is no device with given serial number
-    :raises ValueError: when `device_type` is not an instance of `TiePieDeviceType`
-    """
-
-    device_type = TiePieDeviceType(device_type)
-
-    # include network search with ltp.device_list.update()
-    ltp.network.auto_detect_enabled = True
-
-    n_try = 0
-    device_list_item: Optional[ltp.devicelistitem.DeviceListItem] = None
-    while device_list_item is None and n_try < n_max_try_get_device:
-        n_try += 1
-        ltp.device_list.update()
-        if not ltp.device_list:
-            msg = f"Searching for device... (attempt #{n_try}/{n_max_try_get_device})"
-            if n_try < n_max_try_get_device:
-                logger.warning(msg)
-                time.sleep(wait_sec_retry_get_device)
-                continue
-            msg = f"No devices found to start (attempt #{n_try}/{n_max_try_get_device})"
-            logger.error(msg)
-            raise TiePieError(msg)
-
-        # if a device is found
-        try:
-            device_list_item = ltp.device_list.get_item_by_serial_number(serial_number)
-        except InvalidDeviceSerialNumberError as e:
-            msg = (
-                f"The device with serial number {serial_number} is not "
-                f"available; attempt #{n_try}/{n_max_try_get_device}."
-            )
-            if n_try < n_max_try_get_device:
-                logger.warning(msg)
-                time.sleep(wait_sec_retry_get_device)
-                continue
-            logger.error(str(e), exc_info=e)
-            raise TiePieError from e
-    assert device_list_item is not None
-
-    if not device_list_item.can_open(device_type.value):
-        msg = (
-            f"The device with serial number {serial_number} has no "
-            f"{device_type} available."
-        )
-        logger.error(msg)
-        raise TiePieError(msg)
-
-    return device_list_item.open_device(device_type.value)
-
-
-def _verify_via_libtiepie(
-    dev_obj: ltp.device.Device, verify_method_suffix: str, value: Number
-) -> Number:
-    """
-    Generic wrapper for `verify_SOMETHING` methods of the `libtiepie` device.
-    Additionally to returning a value that will be actually set,
-    gives an warning.
-
-    :param dev_obj: TiePie device object, which has the verify_SOMETHING method
-    :param verify_method_suffix: `libtiepie` devices verify_SOMETHING method
-    :param value: numeric value
-    :returns: Value that will be actually set instead of `value`.
-    :raises TiePieError: when status of underlying device gives an error
-    """
-    verify_method = getattr(
-        dev_obj,
-        f"verify_{verify_method_suffix}",
-    )
-    will_have_value = verify_method(value)
-    if will_have_value != value:
-        if verify_method_suffix == "record_length":
-            value_str = f"{value:_d}"
-            set_value = f"{will_have_value:_d}"
-        else:
-            value_str = f"{value:_.3f}"
-            set_value = f"{will_have_value:_.3f}"
-        msg = (
-            f"Can't set {verify_method_suffix} to "
-            f"{value_str}; instead {set_value} will be set."
-        )
-        logger.warning(msg)
-    return will_have_value
-
-
-def _require_dev_handle(device_type):
-    """
-    Create method decorator to check if the TiePie device handle is available.
-
-    :param device_type: the TiePie device type which device handle is required
-    :raises ValueError: when `device_type` is not an instance of `TiePieDeviceType`
-    """
-
-    device_type: TiePieDeviceType = TiePieDeviceType(device_type)
-
-    def wrapper(method):
-        """
-        Method decorator to check if a TiePie device handle is available; raises
-        `TiePieError` if hand is not available.
-
-        :param method: `TiePieDevice` instance method to wrap
-        :return: Whatever wrapped `method` returns
-        """
-
-        @wraps(method)
-        def wrapped_func(self, *args, **kwargs):
-            dev_str = None
-            if device_type is TiePieDeviceType.OSCILLOSCOPE and self._osc is None:
-                dev_str = "oscilloscope"
-            if device_type is TiePieDeviceType.GENERATOR and self._gen is None:
-                dev_str = "generator"
-            if device_type is TiePieDeviceType.I2C and self._i2c is None:
-                dev_str = "I2C host"
-            if dev_str is not None:
-                msg = f"The {dev_str} handle is not available; call `.start()` first."
-                logger.error(msg)
-                raise TiePieError(msg)
-            return method(self, *args, **kwargs)
-
-        return wrapped_func
-
-    return wrapper
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+
+import time
+import logging
+
+import libtiepie as ltp
+from libtiepie import generator as ltp_gen
+from libtiepie import i2chost as ltp_i2c
+from libtiepie import oscilloscope as ltp_osc
+from libtiepie.exceptions import LibTiePieException, InvalidDeviceSerialNumberError
+
+from hvl_ccb.dev.base import DeviceException
+from ...configuration import configdataclass
+from ...utils.typing import Number
+from ...utils.enum import NameEnum
+
+from functools import wraps
+from typing import (
+    Callable,
+    Optional,
+    Tuple,
+    TypeVar,
+    Union,
+)
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class TiePieDeviceConfig:
+    """
+    Configuration dataclass for TiePie
+    """
+
+    serial_number: int
+    require_block_measurement_support: bool = True
+    n_max_try_get_device: int = 10
+    wait_sec_retry_get_device: Number = 1.0
+    is_data_ready_polling_interval_sec: Number = 0.01
+
+    def clean_values(self):
+        if self.serial_number <= 0:
+            raise ValueError("serial_number must be a positive integer.")
+        if self.n_max_try_get_device <= 0:
+            raise ValueError("n_max_try_get_device must be an positive integer.")
+        if self.wait_sec_retry_get_device <= 0:
+            raise ValueError("wait_sec_retry_get_device must be a positive number.")
+        if self.is_data_ready_polling_interval_sec <= 0:
+            raise ValueError(
+                "is_data_ready_polling_interval_sec must be a positive number."
+            )
+
+
+class TiePieDeviceType(NameEnum, init="value ltp_class"):  # type:ignore
+    """
+    TiePie device type.
+    """
+
+    OSCILLOSCOPE = ltp.DEVICETYPE_OSCILLOSCOPE, ltp_osc.Oscilloscope
+    I2C = ltp.DEVICETYPE_I2CHOST, ltp_i2c.I2CHost
+    GENERATOR = ltp.DEVICETYPE_GENERATOR, ltp_gen.Generator
+
+
+class TiePieError(DeviceException):
+    """
+    Error of the class TiePie
+    """
+
+    pass
+
+
+def wrap_libtiepie_exception(func: Callable) -> Callable:
+    """
+    Decorator wrapper for `libtiepie` methods that use
+    `libtiepie.library.check_last_status_raise_on_error()` calls.
+
+    :param func: Function or method to be wrapped
+    :raises TiePieError: instead of `LibTiePieException` or one of its subtypes.
+    :return: whatever `func` returns
+    """
+
+    @wraps(func)
+    def wrapped_func(*args, **kwargs):
+        try:
+            return func(*args, **kwargs)
+        except LibTiePieException as e:
+            logger.error(str(e), exc_info=e)
+            raise TiePieError from e
+
+    return wrapped_func
+
+
+_LtpDeviceReturnType = TypeVar("_LtpDeviceReturnType")
+"""
+An auxiliary typing hint of a `libtiepie` device type for return value of
+the `get_device_by_serial_number` function and the wrapper methods using it.
+"""
+
+
+@wrap_libtiepie_exception
+def get_device_by_serial_number(
+    serial_number: int,
+    # Note: TiePieDeviceType aenum as a tuple to define a return value type
+    device_type: Union[str, Tuple[int, _LtpDeviceReturnType]],
+    n_max_try_get_device: int = 10,
+    wait_sec_retry_get_device: float = 1.0,
+) -> _LtpDeviceReturnType:
+    """
+    Open and return handle of TiePie device with a given serial number
+
+    :param serial_number: int serial number of the device
+    :param device_type: a `TiePieDeviceType` instance containing device identifier (int
+        number) and its corresponding class, both from `libtiepie`, or a string name
+        of such instance
+    :param n_max_try_get_device: maximal number of device list updates (int number)
+    :param wait_sec_retry_get_device: waiting time in seconds between retries (int
+        number)
+    :return: Instance of a `libtiepie`  device class according to the specified
+        `device_type`
+    :raises TiePieError: when there is no device with given serial number
+    :raises ValueError: when `device_type` is not an instance of `TiePieDeviceType`
+    """
+
+    device_type = TiePieDeviceType(device_type)
+
+    # include network search with ltp.device_list.update()
+    ltp.network.auto_detect_enabled = True
+
+    n_try = 0
+    device_list_item: Optional[ltp.devicelistitem.DeviceListItem] = None
+    while device_list_item is None and n_try < n_max_try_get_device:
+        n_try += 1
+        ltp.device_list.update()
+        if not ltp.device_list:
+            msg = f"Searching for device... (attempt #{n_try}/{n_max_try_get_device})"
+            if n_try < n_max_try_get_device:
+                logger.warning(msg)
+                time.sleep(wait_sec_retry_get_device)
+                continue
+            msg = f"No devices found to start (attempt #{n_try}/{n_max_try_get_device})"
+            logger.error(msg)
+            raise TiePieError(msg)
+
+        # if a device is found
+        try:
+            device_list_item = ltp.device_list.get_item_by_serial_number(serial_number)
+        except InvalidDeviceSerialNumberError as e:
+            msg = (
+                f"The device with serial number {serial_number} is not "
+                f"available; attempt #{n_try}/{n_max_try_get_device}."
+            )
+            if n_try < n_max_try_get_device:
+                logger.warning(msg)
+                time.sleep(wait_sec_retry_get_device)
+                continue
+            logger.error(str(e), exc_info=e)
+            raise TiePieError from e
+    assert device_list_item is not None
+
+    if not device_list_item.can_open(device_type.value):
+        msg = (
+            f"The device with serial number {serial_number} has no "
+            f"{device_type} available."
+        )
+        logger.error(msg)
+        raise TiePieError(msg)
+
+    return device_list_item.open_device(device_type.value)
+
+
+def _verify_via_libtiepie(
+    dev_obj: ltp.device.Device, verify_method_suffix: str, value: Number
+) -> Number:
+    """
+    Generic wrapper for `verify_SOMETHING` methods of the `libtiepie` device.
+    Additionally to returning a value that will be actually set,
+    gives an warning.
+
+    :param dev_obj: TiePie device object, which has the verify_SOMETHING method
+    :param verify_method_suffix: `libtiepie` devices verify_SOMETHING method
+    :param value: numeric value
+    :returns: Value that will be actually set instead of `value`.
+    :raises TiePieError: when status of underlying device gives an error
+    """
+    verify_method = getattr(
+        dev_obj,
+        f"verify_{verify_method_suffix}",
+    )
+    will_have_value = verify_method(value)
+    if will_have_value != value:
+        if verify_method_suffix == "record_length":
+            value_str = f"{value:_d}"
+            set_value = f"{will_have_value:_d}"
+        else:
+            value_str = f"{value:_.3f}"
+            set_value = f"{will_have_value:_.3f}"
+        msg = (
+            f"Can't set {verify_method_suffix} to "
+            f"{value_str}; instead {set_value} will be set."
+        )
+        logger.warning(msg)
+    return will_have_value
+
+
+def _require_dev_handle(device_type):
+    """
+    Create method decorator to check if the TiePie device handle is available.
+
+    :param device_type: the TiePie device type which device handle is required
+    :raises ValueError: when `device_type` is not an instance of `TiePieDeviceType`
+    """
+
+    device_type: TiePieDeviceType = TiePieDeviceType(device_type)
+
+    def wrapper(method):
+        """
+        Method decorator to check if a TiePie device handle is available; raises
+        `TiePieError` if hand is not available.
+
+        :param method: `TiePieDevice` instance method to wrap
+        :return: Whatever wrapped `method` returns
+        """
+
+        @wraps(method)
+        def wrapped_func(self, *args, **kwargs):
+            dev_str = None
+            if device_type is TiePieDeviceType.OSCILLOSCOPE and self._osc is None:
+                dev_str = "oscilloscope"
+            if device_type is TiePieDeviceType.GENERATOR and self._gen is None:
+                dev_str = "generator"
+            if device_type is TiePieDeviceType.I2C and self._i2c is None:
+                dev_str = "I2C host"
+            if dev_str is not None:
+                msg = f"The {dev_str} handle is not available; call `.start()` first."
+                logger.error(msg)
+                raise TiePieError(msg)
+            return method(self, *args, **kwargs)
+
+        return wrapped_func
+
+    return wrapper
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/channel.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/channel.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,327 +1,328 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-
-import logging
-from typing import (
-    Optional,
-    Union,
-)
-
-import libtiepie as ltp
-from libtiepie import oscilloscopechannel as ltp_osc_ch
-
-from .base import (
-    TiePieError,
-    wrap_libtiepie_exception,
-)
-from .utils import PublicPropertiesReprMixin
-from ...utils.enum import NameEnum
-from ...utils.typing import Number
-from ...utils.validation import (
-    validate_bool,
-    validate_number,
-)
-
-logger = logging.getLogger(__name__)
-
-
-class TiePieOscilloscopeChannelCoupling(NameEnum):
-    _init_ = "value description"
-    DCV = ltp.CK_DCV, "DC volt"
-    ACV = ltp.CK_ACV, "AC volt"
-    DCA = ltp.CK_DCA, "DC current"
-    ACA = ltp.CK_ACA, "AC current"
-
-
-class TiePieOscilloscopeRange(NameEnum):
-    TWO_HUNDRED_MILLI_VOLT = 0.2
-    FOUR_HUNDRED_MILLI_VOLT = 0.4
-    EIGHT_HUNDRED_MILLI_VOLT = 0.8
-    TWO_VOLT = 2
-    FOUR_VOLT = 4
-    EIGHT_VOLT = 8
-    TWENTY_VOLT = 20
-    FORTY_VOLT = 40
-    EIGHTY_VOLT = 80
-
-    @staticmethod
-    def suitable_range(value):
-        try:
-            return TiePieOscilloscopeRange(value)
-        except ValueError:
-            attrs = [ra.value for ra in TiePieOscilloscopeRange]
-            chosen_range: Optional[TiePieOscilloscopeRange] = None
-            for attr in attrs:
-                if value < attr:
-                    chosen_range = TiePieOscilloscopeRange(attr)
-                    logger.warning(
-                        f"Desired value ({value} V) not possible."
-                        f"Next larger range ({chosen_range.value} V) "
-                        f"selected."
-                    )
-                    break
-            if chosen_range is None:
-                chosen_range = TiePieOscilloscopeRange.EIGHTY_VOLT
-                logger.warning(
-                    f"Desired value ({value} V) is over the maximum; "
-                    f"largest range ({chosen_range.value} V) selected"
-                )
-            return chosen_range
-
-
-class TiePieOscilloscopeTriggerKind(NameEnum):
-    _init_ = "value description"
-    RISING = ltp.TK_RISINGEDGE, "Rising"
-    FALLING = ltp.TK_FALLINGEDGE, "Falling"
-    ANY = ltp.TK_ANYEDGE, "Any"
-    RISING_OR_FALLING = ltp.TK_ANYEDGE, "Rising or Falling"
-
-
-class TiePieOscilloscopeTriggerLevelMode(NameEnum):
-    _init_ = "value description"
-    UNKNOWN = ltp.TLM_UNKNOWN, "Unknown"
-    RELATIVE = ltp.TLM_RELATIVE, "Relative"
-    ABSOLUTE = ltp.TLM_ABSOLUTE, "Absolute"
-
-
-class SafeGround:
-    """
-    Class that dynamically adds the safe_ground_enabled attribute getter/setter
-    if the bound oscilloscope has the safe ground option.
-    """
-    def __get__(self, instance, owner):
-        if not instance.channel.has_safe_ground:
-            msg = "The oscilloscope has no safe ground option."
-            logger.error(msg)
-            raise TiePieError(msg)
-
-        return instance.channel.safe_ground_enabled
-
-    def __set__(self, instance, value):
-        if not instance.channel.has_safe_ground:
-            msg = "The oscilloscope has no safe ground option."
-            raise TiePieError(msg)
-        validate_bool("safe ground enabled", value, logger=logger)
-        instance.channel.safe_ground_enabled = value
-        if value:
-            msg = "enabled"
-        else:
-            msg = "disabled"
-        logger.info(f"Safe ground is set to {msg}.")
-
-
-class TiePieOscilloscopeChannelConfig(PublicPropertiesReprMixin):
-    """
-    Oscilloscope's channel configuration, with cleaning of
-    values in properties setters as well as setting and reading them on and
-    from the device's channel.
-    """
-
-    def __init__(self, ch_number: int, channel: ltp_osc_ch.OscilloscopeChannel):
-        self.ch_number: int = ch_number
-        self.channel: ltp_osc_ch.OscilloscopeChannel = channel
-        self.param_lim: TiePieOscilloscopeChannelConfigLimits = (
-            TiePieOscilloscopeChannelConfigLimits(osc_channel=channel)
-        )
-
-    @staticmethod
-    def clean_coupling(
-        coupling: Union[str, TiePieOscilloscopeChannelCoupling]
-    ) -> TiePieOscilloscopeChannelCoupling:
-        return TiePieOscilloscopeChannelCoupling(coupling)
-
-    @property  # type: ignore
-    @wrap_libtiepie_exception
-    def coupling(self) -> TiePieOscilloscopeChannelCoupling:
-        return TiePieOscilloscopeChannelCoupling(self.channel.coupling)
-
-    @coupling.setter
-    def coupling(self, coupling: Union[str, TiePieOscilloscopeChannelCoupling]) -> None:
-        self.channel.coupling = self.clean_coupling(coupling).value
-        logger.info(f"Coupling is set to {coupling}.")
-
-    @staticmethod
-    def clean_enabled(enabled: bool) -> bool:
-        validate_bool("channel enabled", enabled, logger=logger)
-        return enabled
-
-    @property
-    def enabled(self) -> bool:
-        return self.channel.enabled
-
-    @enabled.setter
-    def enabled(self, enabled: bool) -> None:
-        self.channel.enabled = self.clean_enabled(enabled)
-        if enabled:
-            msg = "enabled"
-        else:
-            msg = "disabled"
-        logger.info(f"Channel {self.ch_number} is set to {msg}.")
-
-    def clean_input_range(
-        self, input_range: Union[float, TiePieOscilloscopeRange]
-    ) -> TiePieOscilloscopeRange:
-        if not isinstance(input_range, TiePieOscilloscopeRange):
-            validate_number(
-                "input range",
-                input_range,
-                self.param_lim.input_range,
-                logger=logger,
-            )
-        return TiePieOscilloscopeRange.suitable_range(input_range)
-
-    @property
-    def input_range(self) -> TiePieOscilloscopeRange:
-        return TiePieOscilloscopeRange(self.channel.range)
-
-    @input_range.setter
-    def input_range(self, input_range: Union[float, TiePieOscilloscopeRange]) -> None:
-        input_range = self.clean_input_range(input_range).value
-        self.channel.range = input_range
-        self.param_lim.trigger_level_abs = (-input_range, input_range)
-        logger.info(f"input range is set to {self.channel.range} V.")
-
-    def clean_probe_offset(self, probe_offset: float) -> float:
-        validate_number(
-            "probe offset", probe_offset, self.param_lim.probe_offset, logger=logger
-        )
-        return float(probe_offset)
-
-    @property
-    def probe_offset(self) -> float:
-        return self.channel.probe_offset
-
-    @probe_offset.setter
-    def probe_offset(self, probe_offset: float) -> None:
-        self.channel.probe_offset = self.clean_probe_offset(probe_offset)
-        logger.info(f"Probe offset is set to {probe_offset:_.3f}.")
-
-    @property  # type: ignore
-    @wrap_libtiepie_exception
-    def has_safe_ground(self) -> bool:
-        """
-        Check whether bound oscilloscope device has "safe ground" option
-
-        :return: bool: 1=safe ground available
-        """
-        return self.channel.has_safe_ground
-
-    def clean_trigger_hysteresis(self, trigger_hysteresis: float) -> float:
-        validate_number(
-            "trigger hysteresis",
-            trigger_hysteresis,
-            self.param_lim.trigger_hysteresis,
-            logger=logger,
-        )
-        return float(trigger_hysteresis)
-
-    @property
-    def trigger_hysteresis(self) -> float:
-        return self.channel.trigger.hystereses[0]
-
-    @trigger_hysteresis.setter
-    def trigger_hysteresis(self, trigger_hysteresis: float) -> None:
-        self.channel.trigger.hystereses[0] = self.clean_trigger_hysteresis(
-            trigger_hysteresis
-        )
-        logger.info(f"Trigger hysteresis is set to {trigger_hysteresis}.")
-
-    @staticmethod
-    def clean_trigger_kind(
-        trigger_kind: Union[str, TiePieOscilloscopeTriggerKind]
-    ) -> TiePieOscilloscopeTriggerKind:
-        return TiePieOscilloscopeTriggerKind(trigger_kind)
-
-    @property
-    def trigger_kind(self) -> TiePieOscilloscopeTriggerKind:
-        return TiePieOscilloscopeTriggerKind(self.channel.trigger.kind)
-
-    @trigger_kind.setter
-    def trigger_kind(
-        self, trigger_kind: Union[str, TiePieOscilloscopeTriggerKind]
-    ) -> None:
-        self.channel.trigger.kind = self.clean_trigger_kind(trigger_kind).value
-        logger.info(f"Trigger kind is set to {trigger_kind}.")
-
-    @staticmethod
-    def clean_trigger_level_mode(
-        level_mode: Union[str, TiePieOscilloscopeTriggerLevelMode]
-    ) -> TiePieOscilloscopeTriggerLevelMode:
-        return TiePieOscilloscopeTriggerLevelMode(level_mode)
-
-    @property
-    def trigger_level_mode(self) -> TiePieOscilloscopeTriggerLevelMode:
-        return TiePieOscilloscopeTriggerLevelMode(self.channel.trigger.level_mode)
-
-    @trigger_level_mode.setter
-    def trigger_level_mode(
-        self, level_mode: Union[str, TiePieOscilloscopeTriggerLevelMode]
-    ) -> None:
-        level_mode_ = self.clean_trigger_level_mode(level_mode)
-        self.channel.trigger.level_mode = level_mode_.value
-        logger.info(f"Trigger level mode is set to {level_mode_.name}.")
-
-    def clean_trigger_level(self, trigger_level: Number) -> float:
-        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.RELATIVE:
-            validate_number(
-                "trigger level",
-                trigger_level,
-                self.param_lim.trigger_level_rel,
-                float,
-                logger=logger,
-            )
-        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.ABSOLUTE:
-            validate_number(
-                "trigger level",
-                trigger_level,
-                self.param_lim.trigger_level_abs,
-                (int, float),
-                logger=logger,
-            )
-        return float(trigger_level)
-
-    @property
-    def trigger_level(self) -> float:
-        return self.channel.trigger.levels[0]
-
-    @trigger_level.setter
-    def trigger_level(self, trigger_level: Number) -> None:
-        self.channel.trigger.levels[0] = self.clean_trigger_level(trigger_level)
-        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.RELATIVE:
-            logger.info(f"Trigger level is set to {trigger_level}.")
-        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.ABSOLUTE:
-            logger.info(f"Trigger level is set to {trigger_level} V.")
-
-    @staticmethod
-    def clean_trigger_enabled(trigger_enabled):
-        validate_bool("Trigger enabled", trigger_enabled, logger=logger)
-        return trigger_enabled
-
-    @property
-    def trigger_enabled(self) -> bool:
-        return self.channel.trigger.enabled
-
-    @trigger_enabled.setter
-    def trigger_enabled(self, trigger_enabled: bool) -> None:
-        self.channel.trigger.enabled = self.clean_trigger_enabled(trigger_enabled)
-        if trigger_enabled:
-            msg = "enabled"
-        else:
-            msg = "disabled"
-        logger.info(f"Trigger is set to {msg}.")
-
-
-class TiePieOscilloscopeChannelConfigLimits:
-    """
-    Default limits for oscilloscope channel parameters.
-    """
-
-    def __init__(self, osc_channel: ltp_osc_ch.OscilloscopeChannel) -> None:
-        self.input_range = (osc_channel.ranges[0], osc_channel.ranges[-1])  # [V]
-        self.probe_offset = (-1e6, 1e6)  # [V], [A] or [Ohm]
-        self.trigger_hysteresis = (0, 1)
-        self.trigger_level_rel = (0, 1)
-        self.trigger_level_abs = (-osc_channel.ranges[-1], osc_channel.ranges[-1])
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+
+import logging
+from typing import (
+    Optional,
+    Union,
+)
+
+import libtiepie as ltp
+from libtiepie import oscilloscopechannel as ltp_osc_ch
+
+from .base import (
+    TiePieError,
+    wrap_libtiepie_exception,
+)
+from .utils import PublicPropertiesReprMixin
+from ...utils.enum import NameEnum
+from ...utils.typing import Number
+from ...utils.validation import (
+    validate_bool,
+    validate_number,
+)
+
+logger = logging.getLogger(__name__)
+
+
+class TiePieOscilloscopeChannelCoupling(  # type:ignore
+    NameEnum, init="value description"
+):
+    DCV = ltp.CK_DCV, "DC volt"
+    ACV = ltp.CK_ACV, "AC volt"
+    DCA = ltp.CK_DCA, "DC current"
+    ACA = ltp.CK_ACA, "AC current"
+
+
+class TiePieOscilloscopeRange(NameEnum):
+    TWO_HUNDRED_MILLI_VOLT = 0.2
+    FOUR_HUNDRED_MILLI_VOLT = 0.4
+    EIGHT_HUNDRED_MILLI_VOLT = 0.8
+    TWO_VOLT = 2
+    FOUR_VOLT = 4
+    EIGHT_VOLT = 8
+    TWENTY_VOLT = 20
+    FORTY_VOLT = 40
+    EIGHTY_VOLT = 80
+
+    @staticmethod
+    def suitable_range(value):
+        try:
+            return TiePieOscilloscopeRange(value)
+        except ValueError:
+            attrs = [ra.value for ra in TiePieOscilloscopeRange]
+            chosen_range: Optional[TiePieOscilloscopeRange] = None
+            for attr in attrs:
+                if value < attr:
+                    chosen_range = TiePieOscilloscopeRange(attr)
+                    logger.warning(
+                        f"Desired value ({value} V) not possible."
+                        f"Next larger range ({chosen_range.value} V) "
+                        f"selected."
+                    )
+                    break
+            if chosen_range is None:
+                chosen_range = TiePieOscilloscopeRange.EIGHTY_VOLT
+                logger.warning(
+                    f"Desired value ({value} V) is over the maximum; "
+                    f"largest range ({chosen_range.value} V) selected"
+                )
+            return chosen_range
+
+
+class TiePieOscilloscopeTriggerKind(NameEnum, init="value description"):  # type:ignore
+    RISING = ltp.TK_RISINGEDGE, "Rising"
+    FALLING = ltp.TK_FALLINGEDGE, "Falling"
+    ANY = ltp.TK_ANYEDGE, "Any"
+    RISING_OR_FALLING = ltp.TK_ANYEDGE, "Rising or Falling"
+
+
+class TiePieOscilloscopeTriggerLevelMode(  # type:ignore
+    NameEnum, init="value description"
+):
+    UNKNOWN = ltp.TLM_UNKNOWN, "Unknown"
+    RELATIVE = ltp.TLM_RELATIVE, "Relative"
+    ABSOLUTE = ltp.TLM_ABSOLUTE, "Absolute"
+
+
+class SafeGround:
+    """
+    Class that dynamically adds the safe_ground_enabled attribute getter/setter
+    if the bound oscilloscope has the safe ground option.
+    """
+    def __get__(self, instance, owner):
+        if not instance.channel.has_safe_ground:
+            msg = "The oscilloscope has no safe ground option."
+            logger.error(msg)
+            raise TiePieError(msg)
+
+        return instance.channel.safe_ground_enabled
+
+    def __set__(self, instance, value):
+        if not instance.channel.has_safe_ground:
+            msg = "The oscilloscope has no safe ground option."
+            raise TiePieError(msg)
+        validate_bool("safe ground enabled", value, logger=logger)
+        instance.channel.safe_ground_enabled = value
+        if value:
+            msg = "enabled"
+        else:
+            msg = "disabled"
+        logger.info(f"Safe ground is set to {msg}.")
+
+
+class TiePieOscilloscopeChannelConfig(PublicPropertiesReprMixin):
+    """
+    Oscilloscope's channel configuration, with cleaning of
+    values in properties setters as well as setting and reading them on and
+    from the device's channel.
+    """
+
+    def __init__(self, ch_number: int, channel: ltp_osc_ch.OscilloscopeChannel):
+        self.ch_number: int = ch_number
+        self.channel: ltp_osc_ch.OscilloscopeChannel = channel
+        self.param_lim: TiePieOscilloscopeChannelConfigLimits = (
+            TiePieOscilloscopeChannelConfigLimits(osc_channel=channel)
+        )
+
+    @staticmethod
+    def clean_coupling(
+        coupling: Union[str, TiePieOscilloscopeChannelCoupling]
+    ) -> TiePieOscilloscopeChannelCoupling:
+        return TiePieOscilloscopeChannelCoupling(coupling)
+
+    @property  # type: ignore
+    @wrap_libtiepie_exception
+    def coupling(self) -> TiePieOscilloscopeChannelCoupling:
+        return TiePieOscilloscopeChannelCoupling(self.channel.coupling)
+
+    @coupling.setter
+    def coupling(self, coupling: Union[str, TiePieOscilloscopeChannelCoupling]) -> None:
+        self.channel.coupling = self.clean_coupling(coupling).value
+        logger.info(f"Coupling is set to {coupling}.")
+
+    @staticmethod
+    def clean_enabled(enabled: bool) -> bool:
+        validate_bool("channel enabled", enabled, logger=logger)
+        return enabled
+
+    @property
+    def enabled(self) -> bool:
+        return self.channel.enabled
+
+    @enabled.setter
+    def enabled(self, enabled: bool) -> None:
+        self.channel.enabled = self.clean_enabled(enabled)
+        if enabled:
+            msg = "enabled"
+        else:
+            msg = "disabled"
+        logger.info(f"Channel {self.ch_number} is set to {msg}.")
+
+    def clean_input_range(
+        self, input_range: Union[float, TiePieOscilloscopeRange]
+    ) -> TiePieOscilloscopeRange:
+        if not isinstance(input_range, TiePieOscilloscopeRange):
+            validate_number(
+                "input range",
+                input_range,
+                self.param_lim.input_range,
+                logger=logger,
+            )
+        return TiePieOscilloscopeRange.suitable_range(input_range)
+
+    @property
+    def input_range(self) -> TiePieOscilloscopeRange:
+        return TiePieOscilloscopeRange(self.channel.range)
+
+    @input_range.setter
+    def input_range(self, input_range: Union[float, TiePieOscilloscopeRange]) -> None:
+        input_range = self.clean_input_range(input_range).value
+        self.channel.range = input_range
+        self.param_lim.trigger_level_abs = (-input_range, input_range)
+        logger.info(f"input range is set to {self.channel.range} V.")
+
+    def clean_probe_offset(self, probe_offset: float) -> float:
+        validate_number(
+            "probe offset", probe_offset, self.param_lim.probe_offset, logger=logger
+        )
+        return float(probe_offset)
+
+    @property
+    def probe_offset(self) -> float:
+        return self.channel.probe_offset
+
+    @probe_offset.setter
+    def probe_offset(self, probe_offset: float) -> None:
+        self.channel.probe_offset = self.clean_probe_offset(probe_offset)
+        logger.info(f"Probe offset is set to {probe_offset:_.3f}.")
+
+    @property  # type: ignore
+    @wrap_libtiepie_exception
+    def has_safe_ground(self) -> bool:
+        """
+        Check whether bound oscilloscope device has "safe ground" option
+
+        :return: bool: 1=safe ground available
+        """
+        return self.channel.has_safe_ground
+
+    def clean_trigger_hysteresis(self, trigger_hysteresis: float) -> float:
+        validate_number(
+            "trigger hysteresis",
+            trigger_hysteresis,
+            self.param_lim.trigger_hysteresis,
+            logger=logger,
+        )
+        return float(trigger_hysteresis)
+
+    @property
+    def trigger_hysteresis(self) -> float:
+        return self.channel.trigger.hystereses[0]
+
+    @trigger_hysteresis.setter
+    def trigger_hysteresis(self, trigger_hysteresis: float) -> None:
+        self.channel.trigger.hystereses[0] = self.clean_trigger_hysteresis(
+            trigger_hysteresis
+        )
+        logger.info(f"Trigger hysteresis is set to {trigger_hysteresis}.")
+
+    @staticmethod
+    def clean_trigger_kind(
+        trigger_kind: Union[str, TiePieOscilloscopeTriggerKind]
+    ) -> TiePieOscilloscopeTriggerKind:
+        return TiePieOscilloscopeTriggerKind(trigger_kind)
+
+    @property
+    def trigger_kind(self) -> TiePieOscilloscopeTriggerKind:
+        return TiePieOscilloscopeTriggerKind(self.channel.trigger.kind)
+
+    @trigger_kind.setter
+    def trigger_kind(
+        self, trigger_kind: Union[str, TiePieOscilloscopeTriggerKind]
+    ) -> None:
+        self.channel.trigger.kind = self.clean_trigger_kind(trigger_kind).value
+        logger.info(f"Trigger kind is set to {trigger_kind}.")
+
+    @staticmethod
+    def clean_trigger_level_mode(
+        level_mode: Union[str, TiePieOscilloscopeTriggerLevelMode]
+    ) -> TiePieOscilloscopeTriggerLevelMode:
+        return TiePieOscilloscopeTriggerLevelMode(level_mode)
+
+    @property
+    def trigger_level_mode(self) -> TiePieOscilloscopeTriggerLevelMode:
+        return TiePieOscilloscopeTriggerLevelMode(self.channel.trigger.level_mode)
+
+    @trigger_level_mode.setter
+    def trigger_level_mode(
+        self, level_mode: Union[str, TiePieOscilloscopeTriggerLevelMode]
+    ) -> None:
+        level_mode_ = self.clean_trigger_level_mode(level_mode)
+        self.channel.trigger.level_mode = level_mode_.value
+        logger.info(f"Trigger level mode is set to {level_mode_.name}.")
+
+    def clean_trigger_level(self, trigger_level: Number) -> float:
+        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.RELATIVE:
+            validate_number(
+                "trigger level",
+                trigger_level,
+                self.param_lim.trigger_level_rel,
+                float,
+                logger=logger,
+            )
+        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.ABSOLUTE:
+            validate_number(
+                "trigger level",
+                trigger_level,
+                self.param_lim.trigger_level_abs,
+                (int, float),
+                logger=logger,
+            )
+        return float(trigger_level)
+
+    @property
+    def trigger_level(self) -> float:
+        return self.channel.trigger.levels[0]
+
+    @trigger_level.setter
+    def trigger_level(self, trigger_level: Number) -> None:
+        self.channel.trigger.levels[0] = self.clean_trigger_level(trigger_level)
+        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.RELATIVE:
+            logger.info(f"Trigger level is set to {trigger_level}.")
+        if self.trigger_level_mode == TiePieOscilloscopeTriggerLevelMode.ABSOLUTE:
+            logger.info(f"Trigger level is set to {trigger_level} V.")
+
+    @staticmethod
+    def clean_trigger_enabled(trigger_enabled):
+        validate_bool("Trigger enabled", trigger_enabled, logger=logger)
+        return trigger_enabled
+
+    @property
+    def trigger_enabled(self) -> bool:
+        return self.channel.trigger.enabled
+
+    @trigger_enabled.setter
+    def trigger_enabled(self, trigger_enabled: bool) -> None:
+        self.channel.trigger.enabled = self.clean_trigger_enabled(trigger_enabled)
+        if trigger_enabled:
+            msg = "enabled"
+        else:
+            msg = "disabled"
+        logger.info(f"Trigger is set to {msg}.")
+
+
+class TiePieOscilloscopeChannelConfigLimits:
+    """
+    Default limits for oscilloscope channel parameters.
+    """
+
+    def __init__(self, osc_channel: ltp_osc_ch.OscilloscopeChannel) -> None:
+        self.input_range = (osc_channel.ranges[0], osc_channel.ranges[-1])  # [V]
+        self.probe_offset = (-1e6, 1e6)  # [V], [A] or [Ohm]
+        self.trigger_hysteresis = (0, 1)
+        self.trigger_level_rel = (0, 1)
+        self.trigger_level_abs = (-osc_channel.ranges[-1], osc_channel.ranges[-1])
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/device.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/device.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-TiePie devices.
-"""
-
-import logging
-
-from .i2c import TiePieI2CHostMixin
-from .generator import TiePieGeneratorMixin
-from .oscilloscope import TiePieOscilloscope
-
-logger = logging.getLogger(__name__)
-
-
-class TiePieWS5(TiePieI2CHostMixin, TiePieGeneratorMixin, TiePieOscilloscope):
-    """
-    TiePie WS5 device.
-    """
-
-
-class TiePieHS5(TiePieI2CHostMixin, TiePieGeneratorMixin, TiePieOscilloscope):
-    """
-    TiePie HS5 device.
-    """
-
-
-class TiePieHS6(TiePieOscilloscope):
-    """
-    TiePie HS6 DIFF device.
-    """
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+TiePie devices.
+"""
+
+import logging
+
+from .i2c import TiePieI2CHostMixin
+from .generator import TiePieGeneratorMixin
+from .oscilloscope import TiePieOscilloscope
+
+logger = logging.getLogger(__name__)
+
+
+class TiePieWS5(TiePieI2CHostMixin, TiePieGeneratorMixin, TiePieOscilloscope):
+    """
+    TiePie WS5 device.
+    """
+
+
+class TiePieHS5(TiePieI2CHostMixin, TiePieGeneratorMixin, TiePieOscilloscope):
+    """
+    TiePie HS5 device.
+    """
+
+
+class TiePieHS6(TiePieOscilloscope):
+    """
+    TiePie HS6 DIFF device.
+    """
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/generator.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/generator.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,295 +1,294 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-
-import logging
-
-import libtiepie as ltp
-from libtiepie import generator as ltp_gen
-
-from ...utils.enum import NameEnum
-from array import array
-import numpy.typing as npt
-
-from typing import (
-    cast,
-    Optional,
-    Union,
-)
-from .base import (
-    TiePieDeviceType,
-    wrap_libtiepie_exception,
-    _verify_via_libtiepie,
-    _require_dev_handle,
-)
-from .utils import PublicPropertiesReprMixin
-from .oscilloscope import TiePieOscilloscope
-from ...utils.validation import (
-    validate_bool,
-    validate_number,
-)
-
-logger = logging.getLogger(__name__)
-
-
-class TiePieGeneratorSignalType(NameEnum):
-    _init_ = "value description"
-    UNKNOWN = ltp.ST_UNKNOWN, "Unknown"
-    SINE = ltp.ST_SINE, "Sine"
-    TRIANGLE = ltp.ST_TRIANGLE, "Triangle"
-    SQUARE = ltp.ST_SQUARE, "Square"
-    DC = ltp.ST_DC, "DC"
-    NOISE = ltp.ST_NOISE, "Noise"
-    ARBITRARY = ltp.ST_ARBITRARY, "Arbitrary"
-    PULSE = ltp.ST_PULSE, "Pulse"
-
-
-class TiePieGeneratorConfigLimits:
-    """
-    Default limits for generator parameters.
-    """
-
-    def __init__(self, dev_gen: ltp_gen.Generator) -> None:
-        self.frequency = (0, dev_gen.frequency_max)
-        self.amplitude = (0, dev_gen.amplitude_max)
-        self.offset = (None, dev_gen.offset_max)
-
-
-class TiePieGeneratorConfig(PublicPropertiesReprMixin):
-    """
-    Generator's configuration with cleaning of values in properties setters.
-    """
-
-    def __init__(self, dev_gen: ltp_gen.Generator):
-        self.dev_gen: ltp_gen.Generator = dev_gen
-        self._waveform: Optional[npt.NDArray] = None
-        self.param_lim: TiePieGeneratorConfigLimits = TiePieGeneratorConfigLimits(
-            dev_gen=dev_gen
-        )
-
-    def clean_frequency(self, frequency: float) -> float:
-        validate_number(
-            "Frequency", frequency, limits=self.param_lim.frequency, logger=logger
-        )
-        frequency = _verify_via_libtiepie(self.dev_gen, "frequency", frequency)
-        return float(frequency)
-
-    @property
-    def frequency(self) -> float:
-        return self.dev_gen.frequency
-
-    @frequency.setter
-    def frequency(self, frequency: float) -> None:
-        """
-        Set signal generator frequency.
-        :param frequency: Desired signal frequency in Hertz
-        """
-        frequency = self.clean_frequency(frequency)
-        self.dev_gen.frequency = frequency
-        logger.info(f"Generator frequency is set to {frequency} Hz.")
-
-    def clean_amplitude(self, amplitude: float) -> float:
-        validate_number(
-            "Generator amplitude",
-            amplitude,
-            limits=self.param_lim.amplitude,
-            logger=logger,
-        )
-        amplitude = _verify_via_libtiepie(self.dev_gen, "amplitude", amplitude)
-        return float(amplitude)
-
-    @property
-    def amplitude(self) -> float:
-        return self.dev_gen.amplitude
-
-    @amplitude.setter
-    def amplitude(self, amplitude: float) -> None:
-        """
-        Set signal generator amplitude (peak value).
-        :param amplitude: in Volts
-        """
-        amplitude = self.clean_amplitude(amplitude)
-        self.dev_gen.amplitude = amplitude
-        logger.info(f"Generator amplitude is set to {amplitude} V.")
-
-    def clean_offset(self, offset: float) -> float:
-        validate_number(
-            "Generator offset", offset, limits=self.param_lim.offset, logger=logger
-        )
-        offset = _verify_via_libtiepie(self.dev_gen, "offset", offset)
-        return float(offset)
-
-    @property
-    def offset(self) -> float:
-        return self.dev_gen.offset
-
-    @offset.setter
-    def offset(self, offset: float) -> None:
-        """
-        Set signal offset voltage.
-        :param offset: in Volts.
-        """
-        offset = self.clean_offset(offset)
-        self.dev_gen.offset = offset
-        logger.info(f"Generator offset is set to {offset} V.")
-
-    @staticmethod
-    def clean_signal_type(
-        signal_type: Union[int, TiePieGeneratorSignalType]
-    ) -> TiePieGeneratorSignalType:
-        return TiePieGeneratorSignalType(signal_type)
-
-    @property
-    def signal_type(self) -> TiePieGeneratorSignalType:
-        return TiePieGeneratorSignalType(self.dev_gen.signal_type)
-
-    @signal_type.setter
-    def signal_type(self, signal_type: Union[int, TiePieGeneratorSignalType]) -> None:
-        """
-        Set signal type.
-        :param signal_type: use TiePieGeneratorSignalType.SIGNAL_KEYWORD
-        """
-        self.dev_gen.signal_type = self.clean_signal_type(signal_type).value
-        logger.info(f"Signal type is set to {signal_type}.")
-
-    @staticmethod
-    def clean_enabled(enabled: bool) -> bool:
-        validate_bool("channel enabled", enabled, logger=logger)
-        return enabled
-
-    @property
-    def enabled(self) -> bool:
-        return self.dev_gen.output_on
-
-    @enabled.setter
-    def enabled(self, enabled: bool) -> None:
-        """
-        Enable generator (note: this will not yet start the signal generation)
-        :param enabled: if 'True', generator is enabled
-        """
-        self.dev_gen.output_on = self.clean_enabled(enabled)
-        if enabled:
-            msg = "enabled"
-        else:
-            msg = "disabled"
-        logger.info(f"Generator is set to {msg}.")
-
-    def clean_waveform(self, waveform: npt.NDArray) -> npt.NDArray:
-        validate_number("Waveform", waveform, (-1, 1), logger=logger)
-        waveform = waveform.squeeze()
-        set_data_length = _verify_via_libtiepie(
-            self.dev_gen, "data_length", waveform.size
-        )
-        if waveform.ndim != 1:
-            msg = "Waveform array must be 1-dimensional."
-            logger.error(msg)
-            raise ValueError(msg)
-        if set_data_length != waveform.size:
-            msg = (
-                f"Waveform with {waveform.size} samples not possible "
-                f"(max. is {set_data_length})."
-            )
-            logger.error(msg)
-            raise ValueError(msg)
-        return waveform
-
-    @property
-    def waveform(self) -> Optional[npt.NDArray]:
-        return self._waveform
-
-    @waveform.setter
-    def waveform(self, waveform: npt.NDArray):
-        """
-        Set arbitrary waveform for signal generation
-        (choose TiePieGeneratorSignalType.ARBITRARY)
-        :param waveform: desired waveform as a numpy array. The array will be scaled
-        by a multiplicative factor such that its absolute maximum value is 1. The
-        chosen 'amplitude' will thus be the absolute peak value of the generated
-        waveform.
-        """
-        waveform = self.clean_waveform(waveform)
-        self._waveform = waveform
-        waveform_array = array("f")
-        waveform_array.fromlist(waveform.tolist())
-        self.dev_gen.set_data(waveform_array)
-        logger.info("Arbitrary waveform data loaded")
-
-
-class TiePieGeneratorMixin:
-    """
-    TiePie Generator sub-device.
-
-    A wrapper for the `libtiepie.generator.Generator` class. To be mixed in with
-    `TiePieOscilloscope` base class.
-    """
-
-    def __init__(self, com, dev_config):
-        super().__init__(com, dev_config)
-
-        self._gen: Optional[ltp_gen.Generator] = None
-
-        self.config_gen: Optional[TiePieGeneratorConfig] = None
-        """
-        Generator's dynamical configuration.
-        """
-
-    @_require_dev_handle(TiePieDeviceType.GENERATOR)
-    def _gen_config_setup(self) -> None:
-        """
-        Setup dynamical configuration for the connected generator.
-        """
-        self.config_gen = TiePieGeneratorConfig(
-            dev_gen=self._gen,
-        )
-
-    def _gen_config_teardown(self) -> None:
-        self.config_gen = None
-
-    def _gen_close(self) -> None:
-        if self._gen is not None:
-            del self._gen
-            self._gen = None
-
-    def start(self) -> None:
-        """
-        Start the Generator.
-        """
-        super().start()  # type: ignore
-        logger.info("Starting generator")
-
-        self._gen = cast(TiePieOscilloscope, self)._get_device_by_serial_number(
-            TiePieDeviceType.GENERATOR
-        )
-        self._gen_config_setup()
-
-    @wrap_libtiepie_exception
-    def stop(self) -> None:
-        """
-        Stop the generator.
-        """
-        logger.info("Stopping generator")
-
-        self._gen_config_teardown()
-        self._gen_close()
-
-        super().stop()  # type: ignore
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.GENERATOR)
-    def generator_start(self):
-        """
-        Start signal generation.
-        """
-        self._gen.start()
-        logger.info("Starting signal generation")
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.GENERATOR)
-    def generator_stop(self):
-        """
-        Stop signal generation.
-        """
-        self._gen.stop()
-        logger.info("Stopping signal generation")
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+
+import logging
+
+import libtiepie as ltp
+from libtiepie import generator as ltp_gen
+
+from ...utils.enum import NameEnum
+from array import array
+import numpy.typing as npt
+
+from typing import (
+    cast,
+    Optional,
+    Union,
+)
+from .base import (
+    TiePieDeviceType,
+    wrap_libtiepie_exception,
+    _verify_via_libtiepie,
+    _require_dev_handle,
+)
+from .utils import PublicPropertiesReprMixin
+from .oscilloscope import TiePieOscilloscope
+from ...utils.validation import (
+    validate_bool,
+    validate_number,
+)
+
+logger = logging.getLogger(__name__)
+
+
+class TiePieGeneratorSignalType(NameEnum, init="value description"):  # type:ignore
+    UNKNOWN = ltp.ST_UNKNOWN, "Unknown"
+    SINE = ltp.ST_SINE, "Sine"
+    TRIANGLE = ltp.ST_TRIANGLE, "Triangle"
+    SQUARE = ltp.ST_SQUARE, "Square"
+    DC = ltp.ST_DC, "DC"
+    NOISE = ltp.ST_NOISE, "Noise"
+    ARBITRARY = ltp.ST_ARBITRARY, "Arbitrary"
+    PULSE = ltp.ST_PULSE, "Pulse"
+
+
+class TiePieGeneratorConfigLimits:
+    """
+    Default limits for generator parameters.
+    """
+
+    def __init__(self, dev_gen: ltp_gen.Generator) -> None:
+        self.frequency = (0, dev_gen.frequency_max)
+        self.amplitude = (0, dev_gen.amplitude_max)
+        self.offset = (None, dev_gen.offset_max)
+
+
+class TiePieGeneratorConfig(PublicPropertiesReprMixin):
+    """
+    Generator's configuration with cleaning of values in properties setters.
+    """
+
+    def __init__(self, dev_gen: ltp_gen.Generator):
+        self.dev_gen: ltp_gen.Generator = dev_gen
+        self._waveform: Optional[npt.NDArray] = None
+        self.param_lim: TiePieGeneratorConfigLimits = TiePieGeneratorConfigLimits(
+            dev_gen=dev_gen
+        )
+
+    def clean_frequency(self, frequency: float) -> float:
+        validate_number(
+            "Frequency", frequency, limits=self.param_lim.frequency, logger=logger
+        )
+        frequency = _verify_via_libtiepie(self.dev_gen, "frequency", frequency)
+        return float(frequency)
+
+    @property
+    def frequency(self) -> float:
+        return self.dev_gen.frequency
+
+    @frequency.setter
+    def frequency(self, frequency: float) -> None:
+        """
+        Set signal generator frequency.
+        :param frequency: Desired signal frequency in Hertz
+        """
+        frequency = self.clean_frequency(frequency)
+        self.dev_gen.frequency = frequency
+        logger.info(f"Generator frequency is set to {frequency} Hz.")
+
+    def clean_amplitude(self, amplitude: float) -> float:
+        validate_number(
+            "Generator amplitude",
+            amplitude,
+            limits=self.param_lim.amplitude,
+            logger=logger,
+        )
+        amplitude = _verify_via_libtiepie(self.dev_gen, "amplitude", amplitude)
+        return float(amplitude)
+
+    @property
+    def amplitude(self) -> float:
+        return self.dev_gen.amplitude
+
+    @amplitude.setter
+    def amplitude(self, amplitude: float) -> None:
+        """
+        Set signal generator amplitude (peak value).
+        :param amplitude: in Volts
+        """
+        amplitude = self.clean_amplitude(amplitude)
+        self.dev_gen.amplitude = amplitude
+        logger.info(f"Generator amplitude is set to {amplitude} V.")
+
+    def clean_offset(self, offset: float) -> float:
+        validate_number(
+            "Generator offset", offset, limits=self.param_lim.offset, logger=logger
+        )
+        offset = _verify_via_libtiepie(self.dev_gen, "offset", offset)
+        return float(offset)
+
+    @property
+    def offset(self) -> float:
+        return self.dev_gen.offset
+
+    @offset.setter
+    def offset(self, offset: float) -> None:
+        """
+        Set signal offset voltage.
+        :param offset: in Volts.
+        """
+        offset = self.clean_offset(offset)
+        self.dev_gen.offset = offset
+        logger.info(f"Generator offset is set to {offset} V.")
+
+    @staticmethod
+    def clean_signal_type(
+        signal_type: Union[int, TiePieGeneratorSignalType]
+    ) -> TiePieGeneratorSignalType:
+        return TiePieGeneratorSignalType(signal_type)
+
+    @property
+    def signal_type(self) -> TiePieGeneratorSignalType:
+        return TiePieGeneratorSignalType(self.dev_gen.signal_type)
+
+    @signal_type.setter
+    def signal_type(self, signal_type: Union[int, TiePieGeneratorSignalType]) -> None:
+        """
+        Set signal type.
+        :param signal_type: use TiePieGeneratorSignalType.SIGNAL_KEYWORD
+        """
+        self.dev_gen.signal_type = self.clean_signal_type(signal_type).value
+        logger.info(f"Signal type is set to {signal_type}.")
+
+    @staticmethod
+    def clean_enabled(enabled: bool) -> bool:
+        validate_bool("channel enabled", enabled, logger=logger)
+        return enabled
+
+    @property
+    def enabled(self) -> bool:
+        return self.dev_gen.output_on
+
+    @enabled.setter
+    def enabled(self, enabled: bool) -> None:
+        """
+        Enable generator (note: this will not yet start the signal generation)
+        :param enabled: if 'True', generator is enabled
+        """
+        self.dev_gen.output_on = self.clean_enabled(enabled)
+        if enabled:
+            msg = "enabled"
+        else:
+            msg = "disabled"
+        logger.info(f"Generator is set to {msg}.")
+
+    def clean_waveform(self, waveform: npt.NDArray) -> npt.NDArray:
+        validate_number("Waveform", waveform, (-1, 1), logger=logger)
+        waveform = waveform.squeeze()
+        set_data_length = _verify_via_libtiepie(
+            self.dev_gen, "data_length", waveform.size
+        )
+        if waveform.ndim != 1:
+            msg = "Waveform array must be 1-dimensional."
+            logger.error(msg)
+            raise ValueError(msg)
+        if set_data_length != waveform.size:
+            msg = (
+                f"Waveform with {waveform.size} samples not possible "
+                f"(max. is {set_data_length})."
+            )
+            logger.error(msg)
+            raise ValueError(msg)
+        return waveform
+
+    @property
+    def waveform(self) -> Optional[npt.NDArray]:
+        return self._waveform
+
+    @waveform.setter
+    def waveform(self, waveform: npt.NDArray):
+        """
+        Set arbitrary waveform for signal generation
+        (choose TiePieGeneratorSignalType.ARBITRARY)
+        :param waveform: desired waveform as a numpy array. The array will be scaled
+        by a multiplicative factor such that its absolute maximum value is 1. The
+        chosen 'amplitude' will thus be the absolute peak value of the generated
+        waveform.
+        """
+        waveform = self.clean_waveform(waveform)
+        self._waveform = waveform
+        waveform_array = array("f")
+        waveform_array.fromlist(waveform.tolist())
+        self.dev_gen.set_data(waveform_array)
+        logger.info("Arbitrary waveform data loaded")
+
+
+class TiePieGeneratorMixin:
+    """
+    TiePie Generator sub-device.
+
+    A wrapper for the `libtiepie.generator.Generator` class. To be mixed in with
+    `TiePieOscilloscope` base class.
+    """
+
+    def __init__(self, com, dev_config):
+        super().__init__(com, dev_config)
+
+        self._gen: Optional[ltp_gen.Generator] = None
+
+        self.config_gen: Optional[TiePieGeneratorConfig] = None
+        """
+        Generator's dynamical configuration.
+        """
+
+    @_require_dev_handle(TiePieDeviceType.GENERATOR)
+    def _gen_config_setup(self) -> None:
+        """
+        Setup dynamical configuration for the connected generator.
+        """
+        self.config_gen = TiePieGeneratorConfig(
+            dev_gen=self._gen,
+        )
+
+    def _gen_config_teardown(self) -> None:
+        self.config_gen = None
+
+    def _gen_close(self) -> None:
+        if self._gen is not None:
+            del self._gen
+            self._gen = None
+
+    def start(self) -> None:
+        """
+        Start the Generator.
+        """
+        super().start()  # type: ignore
+        logger.info("Starting generator")
+
+        self._gen = cast(TiePieOscilloscope, self)._get_device_by_serial_number(
+            TiePieDeviceType.GENERATOR
+        )
+        self._gen_config_setup()
+
+    @wrap_libtiepie_exception
+    def stop(self) -> None:
+        """
+        Stop the generator.
+        """
+        logger.info("Stopping generator")
+
+        self._gen_config_teardown()
+        self._gen_close()
+
+        super().stop()  # type: ignore
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.GENERATOR)
+    def generator_start(self):
+        """
+        Start signal generation.
+        """
+        self._gen.start()
+        logger.info("Starting signal generation")
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.GENERATOR)
+    def generator_stop(self):
+        """
+        Stop signal generation.
+        """
+        self._gen.stop()
+        logger.info("Stopping signal generation")
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/i2c.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/i2c.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-
-import logging
-
-from libtiepie import i2chost as ltp_i2c
-
-from typing import (
-    cast,
-    Optional,
-)
-
-from .base import (
-    TiePieDeviceType,
-    _require_dev_handle,
-    wrap_libtiepie_exception,
-)
-from .utils import PublicPropertiesReprMixin
-from .oscilloscope import TiePieOscilloscope
-
-logger = logging.getLogger(__name__)
-
-
-class TiePieI2CHostConfigLimits:
-    """
-    Default limits for I2C host parameters.
-    """
-
-    def __init__(self, dev_i2c: ltp_i2c.I2CHost) -> None:
-        # I2C Host
-        pass
-
-
-class TiePieI2CHostConfig(PublicPropertiesReprMixin):
-    """
-    I2C Host's configuration with cleaning of values in properties setters.
-    """
-
-    def __init__(self, dev_i2c: ltp_i2c.I2CHost):
-        self.dev_i2c: ltp_i2c.I2CHost = dev_i2c
-        self.param_lim: TiePieI2CHostConfigLimits = TiePieI2CHostConfigLimits(
-            dev_i2c=dev_i2c
-        )
-
-
-class TiePieI2CHostMixin:
-    """
-    TiePie I2CHost sub-device.
-
-    A wrapper for the `libtiepie.i2chost.I2CHost` class. To be mixed in with
-    `TiePieOscilloscope` base class.
-    """
-
-    def __init__(self, com, dev_config):
-        super().__init__(com, dev_config)
-
-        self._i2c: Optional[ltp_i2c.I2CHost] = None
-
-        self.config_i2c: Optional[TiePieI2CHostConfig] = None
-        """
-        I2C host's dynamical configuration.
-        """
-
-    @_require_dev_handle(TiePieDeviceType.I2C)
-    def _i2c_config_setup(self) -> None:
-        """
-        Setup dynamical configuration for the connected I2C host.
-        """
-        self.config_i2c = TiePieI2CHostConfig(
-            dev_i2c=self._i2c,
-        )
-
-    def _i2c_config_teardown(self) -> None:
-        """
-        Teardown dynamical configuration for the I2C Host.
-        """
-        self.config_i2c = None
-
-    def _i2c_close(self) -> None:
-        if self._i2c is not None:
-            del self._i2c
-            self._i2c = None
-
-    def start(self) -> None:
-        """
-        Start the I2C Host.
-        """
-        super().start()  # type: ignore
-        logger.info("Starting I2C host")
-
-        self._i2c = cast(TiePieOscilloscope, self)._get_device_by_serial_number(
-            TiePieDeviceType.I2C
-        )
-        self._i2c_config_setup()
-
-    @wrap_libtiepie_exception
-    def stop(self) -> None:
-        """
-        Stop the I2C host.
-        """
-        logger.info("Stopping I2C host")
-
-        self._i2c_config_teardown()
-        self._i2c_close()
-
-        super().stop()  # type: ignore
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+
+import logging
+
+from libtiepie import i2chost as ltp_i2c
+
+from typing import (
+    cast,
+    Optional,
+)
+
+from .base import (
+    TiePieDeviceType,
+    _require_dev_handle,
+    wrap_libtiepie_exception,
+)
+from .utils import PublicPropertiesReprMixin
+from .oscilloscope import TiePieOscilloscope
+
+logger = logging.getLogger(__name__)
+
+
+class TiePieI2CHostConfigLimits:
+    """
+    Default limits for I2C host parameters.
+    """
+
+    def __init__(self, dev_i2c: ltp_i2c.I2CHost) -> None:
+        # I2C Host
+        pass
+
+
+class TiePieI2CHostConfig(PublicPropertiesReprMixin):
+    """
+    I2C Host's configuration with cleaning of values in properties setters.
+    """
+
+    def __init__(self, dev_i2c: ltp_i2c.I2CHost):
+        self.dev_i2c: ltp_i2c.I2CHost = dev_i2c
+        self.param_lim: TiePieI2CHostConfigLimits = TiePieI2CHostConfigLimits(
+            dev_i2c=dev_i2c
+        )
+
+
+class TiePieI2CHostMixin:
+    """
+    TiePie I2CHost sub-device.
+
+    A wrapper for the `libtiepie.i2chost.I2CHost` class. To be mixed in with
+    `TiePieOscilloscope` base class.
+    """
+
+    def __init__(self, com, dev_config):
+        super().__init__(com, dev_config)
+
+        self._i2c: Optional[ltp_i2c.I2CHost] = None
+
+        self.config_i2c: Optional[TiePieI2CHostConfig] = None
+        """
+        I2C host's dynamical configuration.
+        """
+
+    @_require_dev_handle(TiePieDeviceType.I2C)
+    def _i2c_config_setup(self) -> None:
+        """
+        Setup dynamical configuration for the connected I2C host.
+        """
+        self.config_i2c = TiePieI2CHostConfig(
+            dev_i2c=self._i2c,
+        )
+
+    def _i2c_config_teardown(self) -> None:
+        """
+        Teardown dynamical configuration for the I2C Host.
+        """
+        self.config_i2c = None
+
+    def _i2c_close(self) -> None:
+        if self._i2c is not None:
+            del self._i2c
+            self._i2c = None
+
+    def start(self) -> None:
+        """
+        Start the I2C Host.
+        """
+        super().start()  # type: ignore
+        logger.info("Starting I2C host")
+
+        self._i2c = cast(TiePieOscilloscope, self)._get_device_by_serial_number(
+            TiePieDeviceType.I2C
+        )
+        self._i2c_config_setup()
+
+    @wrap_libtiepie_exception
+    def stop(self) -> None:
+        """
+        Stop the I2C host.
+        """
+        logger.info("Stopping I2C host")
+
+        self._i2c_config_teardown()
+        self._i2c_close()
+
+        super().stop()  # type: ignore
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/oscilloscope.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/oscilloscope.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,618 +1,619 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-
-import logging
-import time
-from typing import (
-    cast,
-    Dict,
-    Generator,
-    Optional,
-    Type,
-    Tuple,
-    Union,
-)
-
-import libtiepie as ltp
-import numpy as np
-import numpy.typing as npt
-from aenum import IntEnum
-from libtiepie import oscilloscope as ltp_osc
-
-from .base import (
-    TiePieDeviceConfig,
-    TiePieDeviceType,
-    TiePieError,
-    _LtpDeviceReturnType,
-    _verify_via_libtiepie,
-    _require_dev_handle,
-    wrap_libtiepie_exception,
-    get_device_by_serial_number,
-)
-from .channel import TiePieOscilloscopeChannelConfig, SafeGround
-from .utils import PublicPropertiesReprMixin
-from ..base import SingleCommDevice
-from ...comm import NullCommunicationProtocol
-from ...utils.enum import NameEnum
-from ...utils.typing import Number
-from ...utils.validation import validate_number
-
-logger = logging.getLogger(__name__)
-
-
-class TiePieOscilloscopeResolution(IntEnum):
-    EIGHT_BIT = 8
-    TWELVE_BIT = 12
-    FOURTEEN_BIT = 14
-    SIXTEEN_BIT = 16
-
-
-class TiePieOscilloscopeAutoResolutionModes(NameEnum):
-    _init_ = "value description"
-    UNKNOWN = ltp.AR_UNKNOWN, "Unknown"
-    DISABLED = ltp.AR_DISABLED, "Disabled"
-    NATIVEONLY = ltp.AR_NATIVEONLY, "Native only"
-    ALL = ltp.AR_ALL, "All"
-
-
-class TiePieOscilloscopeConfigLimits:
-    """
-    Default limits for oscilloscope parameters.
-    """
-
-    def __init__(self, dev_osc: ltp_osc.Oscilloscope) -> None:
-        self.record_length = (0, dev_osc.record_length_max)
-        self.sample_frequency = (0, dev_osc.sample_frequency_max)  # [samples/s]
-        self.pre_sample_ratio = (0, 1)
-        # self.trigger_delay = (0, dev_osc.trigger_delay_max)  # trigger_delay is not
-        # available for all instruments, cf. API from TiePie:
-        # Functions » Oscilloscope » Trigger » Delay
-
-
-class TiePieOscilloscopeConfig(PublicPropertiesReprMixin):
-    """
-    Oscilloscope's configuration with cleaning of values in properties setters.
-    """
-
-    def __init__(self, dev_osc: ltp_osc.Oscilloscope):
-        self.dev_osc: ltp_osc.Oscilloscope = dev_osc
-        self.param_lim: TiePieOscilloscopeConfigLimits = TiePieOscilloscopeConfigLimits(
-            dev_osc=dev_osc
-        )
-
-    def clean_pre_sample_ratio(self, pre_sample_ratio: float) -> float:
-        validate_number(
-            "pre sample ratio",
-            pre_sample_ratio,
-            self.param_lim.pre_sample_ratio,
-            logger=logger,
-        )
-        return float(pre_sample_ratio)
-
-    @property
-    def pre_sample_ratio(self) -> float:
-        return self.dev_osc.pre_sample_ratio
-
-    @pre_sample_ratio.setter
-    def pre_sample_ratio(self, pre_sample_ratio: float) -> None:
-        """
-        Set pre sample ratio
-
-        :param pre_sample_ratio: pre sample ratio numeric value.
-        :raise ValueError: If `pre_sample_ratio` is not a number between 0 and 1
-            (inclusive).
-        """
-        self.dev_osc.pre_sample_ratio = self.clean_pre_sample_ratio(pre_sample_ratio)
-        logger.info(f"Pre-sample ratio is set to {pre_sample_ratio}.")
-
-    def clean_record_length(self, record_length: Number) -> int:
-        validate_number(
-            "record length",
-            record_length,
-            limits=self.param_lim.record_length,
-            logger=logger,
-        )
-
-        if not (float(record_length).is_integer()):
-            raise ValueError(
-                f"The record_length has to be a value, that can be cast "
-                f"into an integer without significant precision loss; "
-                f"but {record_length:_d} was assigned."
-            )
-
-        return cast(
-            int,
-            _verify_via_libtiepie(self.dev_osc, "record_length", int(record_length)),
-        )
-
-    @property
-    def record_length(self) -> int:
-        return self.dev_osc.record_length
-
-    @record_length.setter
-    def record_length(self, record_length: int) -> None:
-        record_length = self.clean_record_length(record_length)
-        self.dev_osc.record_length = record_length
-        logger.info(f"Record length is set to {record_length:_d} Sa.")
-
-    @staticmethod
-    def clean_resolution(
-        resolution: Union[int, TiePieOscilloscopeResolution]
-    ) -> TiePieOscilloscopeResolution:
-        if not isinstance(resolution, TiePieOscilloscopeResolution):
-            validate_number("resolution", resolution, number_type=int, logger=logger)
-        return TiePieOscilloscopeResolution(resolution)
-
-    @property
-    def resolution(self) -> TiePieOscilloscopeResolution:
-        return self.dev_osc.resolution
-
-    @resolution.setter
-    def resolution(self, resolution: Union[int, TiePieOscilloscopeResolution]) -> None:
-        """
-        Setter for resolution of the Oscilloscope.
-
-        :param resolution: resolution integer.
-        :raises ValueError: if resolution is not one of
-            `TiePieOscilloscopeResolution` instance or integer values
-        """
-        self.dev_osc.resolution = self.clean_resolution(resolution)
-        logger.info(f"Resolution is set to {self.dev_osc.resolution} bit.")
-
-    @staticmethod
-    def clean_auto_resolution_mode(
-        auto_resolution_mode: Union[int, TiePieOscilloscopeAutoResolutionModes]
-    ) -> TiePieOscilloscopeAutoResolutionModes:
-        if not isinstance(auto_resolution_mode, TiePieOscilloscopeAutoResolutionModes):
-            validate_number(
-                "auto resolution mode",
-                auto_resolution_mode,
-                number_type=int,
-                logger=logger,
-            )
-        if isinstance(auto_resolution_mode, bool):
-            msg = "Auto resolution mode cannot be of boolean type"
-            logger.error(msg)
-            raise TypeError
-        return TiePieOscilloscopeAutoResolutionModes(auto_resolution_mode)
-
-    @property
-    def auto_resolution_mode(self) -> TiePieOscilloscopeAutoResolutionModes:
-        return TiePieOscilloscopeAutoResolutionModes(self.dev_osc.auto_resolution_mode)
-
-    @auto_resolution_mode.setter
-    def auto_resolution_mode(self, auto_resolution_mode):
-        self.dev_osc.auto_resolution_mode = self.clean_auto_resolution_mode(
-            auto_resolution_mode
-        ).value
-        logger.info(f"Auto resolution mode is set to {auto_resolution_mode}.")
-
-    def clean_sample_frequency(self, sample_frequency: float) -> float:
-        validate_number(
-            "sample frequency",
-            sample_frequency,
-            self.param_lim.sample_frequency,
-            logger=logger,
-        )
-        sample_frequency = _verify_via_libtiepie(
-            self.dev_osc, "sample_frequency", sample_frequency
-        )
-        return float(sample_frequency)
-
-    @property
-    def sample_frequency(self) -> float:
-        return self.dev_osc.sample_frequency
-
-    @sample_frequency.setter
-    def sample_frequency(self, sample_frequency: float):
-        """
-        Set sample frequency of the oscilloscope.
-
-        :param sample_frequency: frequency number to set
-        :raises ValueError: when frequency is not in device range
-        """
-        sample_frequency = self.clean_sample_frequency(sample_frequency)
-        self.dev_osc.sample_frequency = sample_frequency
-        logger.info(f"Sample frequency is set to {sample_frequency:_.3f} Sa/s.")
-
-    def clean_trigger_timeout(self, trigger_timeout: Optional[Number]) -> float:
-        if trigger_timeout in (None, ltp.const.TO_INFINITY):
-            # infinite timeout: `TO_INFINITY = -1` in `libtiepie.const`
-            trigger_timeout = ltp.const.TO_INFINITY
-        else:
-            validate_number(
-                "trigger timeout",
-                trigger_timeout,
-                limits=(0, None),
-                logger=logger,
-            )
-        trigger_timeout = _verify_via_libtiepie(
-            self.dev_osc, "trigger_time_out", cast(Number, trigger_timeout)
-        )
-        return float(trigger_timeout)
-
-    @property
-    def trigger_timeout(self) -> Optional[float]:
-        if self.dev_osc.trigger_time_out == -1:
-            return None
-        return self.dev_osc.trigger_time_out
-
-    @trigger_timeout.setter
-    def trigger_timeout(self, trigger_timeout: Optional[Number]) -> None:
-        """
-        Set trigger time-out.
-
-        :param trigger_timeout: Trigger timeout value, in seconds; `0`  forces
-            trigger to start immediately after starting a measurement;
-            None leads to no timeout
-        :raise ValueError: If trigger timeout is not a non-negative real number.
-        """
-        trigger_timeout = self.clean_trigger_timeout(trigger_timeout)
-        self.dev_osc.trigger_time_out = trigger_timeout
-        if trigger_timeout == -1:
-            logger.info("Trigger timeout is set to \u221e (INFINITY) s.")
-        else:
-            logger.info(f"Trigger timeout is set to {trigger_timeout} s.")
-
-
-class TiePieOscilloscope(SingleCommDevice):
-    """
-    TiePie oscilloscope.
-
-    A wrapper for TiePie oscilloscopes, based on the class
-    `libtiepie.oscilloscope.Oscilloscope` with simplifications for starting of the
-    device (using serial number) and managing mutable configuration of both the
-    device and its channels, including extra validation and typing hints support for
-    configurations.
-
-    Note that, in contrast to `libtiepie` library, since all physical TiePie devices
-    include an oscilloscope, this is the base class for all physical TiePie devices.
-    The additional TiePie sub-devices: "Generator" and "I2CHost", are mixed-in to this
-    base class in subclasses.
-
-    The channels use `1..N` numbering (not `0..N-1`), as in, e.g., the Multi Channel
-    software.
-    """
-
-    @staticmethod
-    def config_cls() -> Type[TiePieDeviceConfig]:
-        return TiePieDeviceConfig
-
-    @staticmethod
-    def default_com_cls() -> Type[NullCommunicationProtocol]:
-        return NullCommunicationProtocol
-
-    def __init__(self, com, dev_config) -> None:
-        """
-        Constructor for a TiePie device.
-        """
-        super().__init__(com, dev_config)
-
-        self._osc: Optional[ltp_osc.Oscilloscope] = None
-
-        self.config_osc: Optional[TiePieOscilloscopeConfig] = None
-        """
-        Oscilloscope's dynamical configuration.
-        """
-
-        self.config_osc_channel_dict: Dict[int, TiePieOscilloscopeChannelConfig] = {}
-        """
-        Channel configuration.
-        A `dict` mapping actual channel number, numbered `1..N`, to channel
-        configuration. The channel info is dynamically read from the device only on
-        the first `start()`; beforehand the `dict` is empty.
-        """
-
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def _osc_config_setup(self) -> None:
-        """
-        Setup dynamical configuration for the connected oscilloscope.
-        """
-        assert self._osc is not None
-        self.config_osc = TiePieOscilloscopeConfig(
-            dev_osc=self._osc,
-        )
-        for n in range(1, self.n_channels + 1):
-            self.config_osc_channel_dict[n] = TiePieOscilloscopeChannelConfig(
-                ch_number=n,
-                channel=self._osc.channels[n - 1],
-            )
-        if self.config_osc_channel_dict[1].has_safe_ground:
-            TiePieOscilloscopeChannelConfig.safe_ground_enabled = (  # type: ignore
-                SafeGround()
-            )
-
-    def _osc_config_teardown(self) -> None:
-        """
-        Teardown dynamical configuration for the oscilloscope.
-        """
-        self.config_osc = None
-        self.config_osc_channel_dict = {}
-
-    def _osc_close(self) -> None:
-        """
-        Close the wrapped `libtiepie` oscilloscope.
-        """
-        if self._osc is not None:
-            del self._osc
-            self._osc = None
-
-    def _get_device_by_serial_number(
-        self,
-        # Note: TiePieDeviceType aenum as a tuple to define a return value type
-        ltp_device_type: Tuple[int, _LtpDeviceReturnType],
-    ) -> _LtpDeviceReturnType:
-        """
-        Wrapper around `get_device_by_serial_number` using this device's config options.
-
-        :return: A `libtiepie` device object specific to a class it is called on.
-        """
-        return get_device_by_serial_number(
-            self.config.serial_number,
-            ltp_device_type,
-            n_max_try_get_device=self.config.n_max_try_get_device,
-            wait_sec_retry_get_device=self.config.wait_sec_retry_get_device,
-        )
-
-    @wrap_libtiepie_exception
-    def start(self) -> None:  # type: ignore
-        """
-        Start the oscilloscope.
-        """
-        logger.info(f"Starting {self}")
-        super().start()
-        logger.info(
-            f"Starting oscilloscope with serial number {self.config.serial_number}"
-        )
-
-        self._osc = self._get_device_by_serial_number(TiePieDeviceType.OSCILLOSCOPE)
-
-        # Check for block measurement support if required
-        if self.config.require_block_measurement_support and not (
-            self._osc.measure_modes & ltp.MM_BLOCK  # type: ignore
-        ):
-            self._osc_close()
-            msg = (
-                f"Oscilloscope with serial number {self.config.serial_number} does not "
-                f"have required block measurement support."
-            )
-            logger.error(msg)
-            raise TiePieError(msg)
-
-        self._osc_config_setup()
-
-    @wrap_libtiepie_exception
-    def stop(self) -> None:  # type: ignore
-        """
-        Stop the oscilloscope.
-        """
-        logger.info(f"Stopping {self}")
-        logger.info("Stopping oscilloscope")
-
-        self._osc_config_teardown()
-        self._osc_close()
-
-        super().stop()
-
-    @staticmethod
-    @wrap_libtiepie_exception
-    def list_devices() -> ltp.devicelist.DeviceList:
-        """
-        List available TiePie devices.
-
-        :return: libtiepie up to date list of devices
-        """
-        ltp.network.auto_detect_enabled = True
-        device_list = ltp.device_list
-        device_list.update()
-
-        # log devices list
-        if device_list:
-            logger.info("Available devices:\n")
-
-            for item in ltp.device_list:
-                logger.info(f"  Name:              {item.name}")
-                logger.info(f"  Serial number:     {item.serial_number}")
-                logger.info(f"  Available types:   {ltp.device_type_str(item.types)}")
-                if item.has_server:
-                    logger.info(
-                        f"  Server:            "
-                        f"{item.server.url}({item.server.name})"
-                    )
-                logger.info(
-                    f"  Can be opened as "
-                    f"Oscilloscope: {item.can_open(ltp.DEVICETYPE_OSCILLOSCOPE)}\n"
-                )
-
-        else:
-            logger.info("No devices found!")
-
-        return device_list
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def start_measurement(self) -> None:
-        """
-        Start a measurement using set configuration.
-
-        :raises TiePieError: when device is not started or status of underlying device
-            gives an error
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        self._osc.start()
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def is_triggered(self) -> bool:
-        """
-        Reports if TiePie has triggered. Maybe data is not yet available. One can
-        check with the function `is_measurement_data_ready()`.
-
-        :return: if a trigger event occurred
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        _is_triggered = self._osc.is_triggered
-        logger.debug(f"TiePie has triggered: {_is_triggered}")
-        return _is_triggered
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def is_measurement_data_ready(self) -> bool:
-        """
-        Reports if TiePie has data which is ready to collect
-
-        :return: if the data is ready to collect.
-        :raises TiePieError: when device is not started or status of underlying device
-            gives an error
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        _is_measurement_data_ready = self._osc.is_data_ready
-        logger.debug(f"TiePie has measurement data ready: {_is_measurement_data_ready}")
-        return _is_measurement_data_ready
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def force_trigger(self) -> None:
-        """
-        Forces the TiePie to trigger with a software sided trigger event.
-
-        :return None:
-        :raises TiePieError: when device is not started or status of underlying device
-            gives an error
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        self._osc.force_trigger()
-        logger.info("A force trigger was sent to TiePie")
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def _check_record_length(self, data_array: npt.NDArray) -> None:
-        """
-        Check record length
-
-        :param data_array: raw data from TiePie as np.ndarray, which is already
-            filtered
-        :return None:
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        # make mypy happy: config_osc could be None, which has no attributes
-        if self.config_osc is None:
-            logger.warning("Oscilloscope is not configured")
-            return None
-
-        record_length_actual = len(data_array[:, 0])
-        if record_length_actual < self.config_osc.record_length:
-            logger.warning(
-                "Less Data than expected: Most likely the trigger occurred "
-                "before all pre trigger samples could be recorded. "
-                "(pre_sample_ratio was to high)"
-            )
-
-        pre_sample_count = self._osc.valid_pre_sample_count
-        record_length_predicted = (
-            int(self.config_osc.record_length * (1 - self.config_osc.pre_sample_ratio))
-            + pre_sample_count
-        )
-        if not record_length_actual == record_length_predicted:
-            logger.warning(
-                f"The actual record length ({record_length_actual} Sa) "
-                f"is shorter than the "
-                f"predicted record length ({record_length_predicted} Sa)"
-            )
-
-    @wrap_libtiepie_exception
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    def collect_measurement_data(
-        self, timeout: Optional[Number] = 0
-    ) -> Optional[npt.NDArray]:
-        """
-        Try to collect the data from TiePie; return `None` if data is not ready.
-
-        :param timeout: The timeout to wait until data is available. This
-            option makes this function blocking the code. `timeout = None` blocks the
-            code infinitely till data will be available. Per default, the `timeout`
-            is set to `0`: The function will not block.
-        :return: Measurement data of only enabled channels and time vector in a
-            2D-`numpy.ndarray` with float sample data; or None if there is no data
-            available.
-        """
-        # make mypy happy w/ assert; `is None` check is already done in the
-        # `_require_dev_handle` method decorator
-        assert self._osc is not None
-        # make mypy happy: config_osc could be None, which has no attributes
-        if self.config_osc is None:
-            logger.warning("Oscilloscope is not configured")
-            return None
-
-        if timeout is not None and not isinstance(timeout, (float, int)):
-            msg = (
-                f"timeout must be non-negative number, "
-                f"but '{timeout}' of type {type(timeout)} was given"
-            )
-            logger.error(msg)
-            raise ValueError(msg)
-
-        # Wait till timeout or till data is ready
-        start_time = time.time()
-        while not self.is_measurement_data_ready() and (
-            timeout is None or (time.time() - start_time < timeout)
-        ):
-            time.sleep(self.config.is_data_ready_polling_interval_sec)
-
-        if not self.is_measurement_data_ready():
-            logger.warning(
-                f"Data from TiePie was not ready to collect "
-                f"during a timeout of {timeout} s."
-            )
-            return None
-
-        # Collect raw data from tiepie
-        data = self._osc.get_data()
-        # filter-out disabled channels entries
-        data_array = np.array(list(filter(None, data))).T
-
-        self._check_record_length(data_array)
-
-        pre_sample_count = self._osc.valid_pre_sample_count
-        record_length_actual = len(data_array[:, 0])
-        time_vector = np.arange(
-            -pre_sample_count, record_length_actual - pre_sample_count
-        )
-        time_vector = time_vector / self.config_osc.sample_frequency
-
-        return np.column_stack([time_vector, data_array])
-
-    @property  # type: ignore
-    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
-    @wrap_libtiepie_exception
-    def n_channels(self):
-        """
-        Number of channels in the oscilloscope.
-
-        :return: Number of channels.
-        """
-        return len(self._osc.channels)
-
-    @property
-    def channels_enabled(self) -> Generator[int, None, None]:
-        """
-        Yield numbers of enabled channels.
-
-        :return: Numbers of enabled channels
-        """
-        for (ch_nr, ch_config) in self.config_osc_channel_dict.items():
-            if ch_config.enabled:
-                yield ch_nr
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+
+import logging
+import time
+from typing import (
+    cast,
+    Dict,
+    Generator,
+    Optional,
+    Type,
+    Tuple,
+    Union,
+)
+
+import libtiepie as ltp
+import numpy as np
+import numpy.typing as npt
+from aenum import IntEnum
+from libtiepie import oscilloscope as ltp_osc
+
+from .base import (
+    TiePieDeviceConfig,
+    TiePieDeviceType,
+    TiePieError,
+    _LtpDeviceReturnType,
+    _verify_via_libtiepie,
+    _require_dev_handle,
+    wrap_libtiepie_exception,
+    get_device_by_serial_number,
+)
+from .channel import TiePieOscilloscopeChannelConfig, SafeGround
+from .utils import PublicPropertiesReprMixin
+from ..base import SingleCommDevice
+from ...comm import NullCommunicationProtocol
+from ...utils.enum import NameEnum
+from ...utils.typing import Number
+from ...utils.validation import validate_number
+
+logger = logging.getLogger(__name__)
+
+
+class TiePieOscilloscopeResolution(IntEnum):
+    EIGHT_BIT = 8
+    TWELVE_BIT = 12
+    FOURTEEN_BIT = 14
+    SIXTEEN_BIT = 16
+
+
+class TiePieOscilloscopeAutoResolutionModes(  # type:ignore
+    NameEnum, init="value description"
+):
+    UNKNOWN = ltp.AR_UNKNOWN, "Unknown"
+    DISABLED = ltp.AR_DISABLED, "Disabled"
+    NATIVEONLY = ltp.AR_NATIVEONLY, "Native only"
+    ALL = ltp.AR_ALL, "All"
+
+
+class TiePieOscilloscopeConfigLimits:
+    """
+    Default limits for oscilloscope parameters.
+    """
+
+    def __init__(self, dev_osc: ltp_osc.Oscilloscope) -> None:
+        self.record_length = (0, dev_osc.record_length_max)
+        self.sample_frequency = (0, dev_osc.sample_frequency_max)  # [samples/s]
+        self.pre_sample_ratio = (0, 1)
+        # self.trigger_delay = (0, dev_osc.trigger_delay_max)  # trigger_delay is not
+        # available for all instruments, cf. API from TiePie:
+        # Functions » Oscilloscope » Trigger » Delay
+
+
+class TiePieOscilloscopeConfig(PublicPropertiesReprMixin):
+    """
+    Oscilloscope's configuration with cleaning of values in properties setters.
+    """
+
+    def __init__(self, dev_osc: ltp_osc.Oscilloscope):
+        self.dev_osc: ltp_osc.Oscilloscope = dev_osc
+        self.param_lim: TiePieOscilloscopeConfigLimits = TiePieOscilloscopeConfigLimits(
+            dev_osc=dev_osc
+        )
+
+    def clean_pre_sample_ratio(self, pre_sample_ratio: float) -> float:
+        validate_number(
+            "pre sample ratio",
+            pre_sample_ratio,
+            self.param_lim.pre_sample_ratio,
+            logger=logger,
+        )
+        return float(pre_sample_ratio)
+
+    @property
+    def pre_sample_ratio(self) -> float:
+        return self.dev_osc.pre_sample_ratio
+
+    @pre_sample_ratio.setter
+    def pre_sample_ratio(self, pre_sample_ratio: float) -> None:
+        """
+        Set pre sample ratio
+
+        :param pre_sample_ratio: pre sample ratio numeric value.
+        :raise ValueError: If `pre_sample_ratio` is not a number between 0 and 1
+            (inclusive).
+        """
+        self.dev_osc.pre_sample_ratio = self.clean_pre_sample_ratio(pre_sample_ratio)
+        logger.info(f"Pre-sample ratio is set to {pre_sample_ratio}.")
+
+    def clean_record_length(self, record_length: Number) -> int:
+        validate_number(
+            "record length",
+            record_length,
+            limits=self.param_lim.record_length,
+            logger=logger,
+        )
+
+        if not (float(record_length).is_integer()):
+            raise ValueError(
+                f"The record_length has to be a value, that can be cast "
+                f"into an integer without significant precision loss; "
+                f"but {record_length:_d} was assigned."
+            )
+
+        return cast(
+            int,
+            _verify_via_libtiepie(self.dev_osc, "record_length", int(record_length)),
+        )
+
+    @property
+    def record_length(self) -> int:
+        return self.dev_osc.record_length
+
+    @record_length.setter
+    def record_length(self, record_length: int) -> None:
+        record_length = self.clean_record_length(record_length)
+        self.dev_osc.record_length = record_length
+        logger.info(f"Record length is set to {record_length:_d} Sa.")
+
+    @staticmethod
+    def clean_resolution(
+        resolution: Union[int, TiePieOscilloscopeResolution]
+    ) -> TiePieOscilloscopeResolution:
+        if not isinstance(resolution, TiePieOscilloscopeResolution):
+            validate_number("resolution", resolution, number_type=int, logger=logger)
+        return TiePieOscilloscopeResolution(resolution)
+
+    @property
+    def resolution(self) -> TiePieOscilloscopeResolution:
+        return self.dev_osc.resolution
+
+    @resolution.setter
+    def resolution(self, resolution: Union[int, TiePieOscilloscopeResolution]) -> None:
+        """
+        Setter for resolution of the Oscilloscope.
+
+        :param resolution: resolution integer.
+        :raises ValueError: if resolution is not one of
+            `TiePieOscilloscopeResolution` instance or integer values
+        """
+        self.dev_osc.resolution = self.clean_resolution(resolution)
+        logger.info(f"Resolution is set to {self.dev_osc.resolution} bit.")
+
+    @staticmethod
+    def clean_auto_resolution_mode(
+        auto_resolution_mode: Union[int, TiePieOscilloscopeAutoResolutionModes]
+    ) -> TiePieOscilloscopeAutoResolutionModes:
+        if not isinstance(auto_resolution_mode, TiePieOscilloscopeAutoResolutionModes):
+            validate_number(
+                "auto resolution mode",
+                auto_resolution_mode,
+                number_type=int,
+                logger=logger,
+            )
+        if isinstance(auto_resolution_mode, bool):
+            msg = "Auto resolution mode cannot be of boolean type"
+            logger.error(msg)
+            raise TypeError
+        return TiePieOscilloscopeAutoResolutionModes(auto_resolution_mode)
+
+    @property
+    def auto_resolution_mode(self) -> TiePieOscilloscopeAutoResolutionModes:
+        return TiePieOscilloscopeAutoResolutionModes(self.dev_osc.auto_resolution_mode)
+
+    @auto_resolution_mode.setter
+    def auto_resolution_mode(self, auto_resolution_mode):
+        self.dev_osc.auto_resolution_mode = self.clean_auto_resolution_mode(
+            auto_resolution_mode
+        ).value
+        logger.info(f"Auto resolution mode is set to {auto_resolution_mode}.")
+
+    def clean_sample_frequency(self, sample_frequency: float) -> float:
+        validate_number(
+            "sample frequency",
+            sample_frequency,
+            self.param_lim.sample_frequency,
+            logger=logger,
+        )
+        sample_frequency = _verify_via_libtiepie(
+            self.dev_osc, "sample_frequency", sample_frequency
+        )
+        return float(sample_frequency)
+
+    @property
+    def sample_frequency(self) -> float:
+        return self.dev_osc.sample_frequency
+
+    @sample_frequency.setter
+    def sample_frequency(self, sample_frequency: float):
+        """
+        Set sample frequency of the oscilloscope.
+
+        :param sample_frequency: frequency number to set
+        :raises ValueError: when frequency is not in device range
+        """
+        sample_frequency = self.clean_sample_frequency(sample_frequency)
+        self.dev_osc.sample_frequency = sample_frequency
+        logger.info(f"Sample frequency is set to {sample_frequency:_.3f} Sa/s.")
+
+    def clean_trigger_timeout(self, trigger_timeout: Optional[Number]) -> float:
+        if trigger_timeout in (None, ltp.const.TO_INFINITY):
+            # infinite timeout: `TO_INFINITY = -1` in `libtiepie.const`
+            trigger_timeout = ltp.const.TO_INFINITY
+        else:
+            validate_number(
+                "trigger timeout",
+                trigger_timeout,
+                limits=(0, None),
+                logger=logger,
+            )
+        trigger_timeout = _verify_via_libtiepie(
+            self.dev_osc, "trigger_time_out", cast(Number, trigger_timeout)
+        )
+        return float(trigger_timeout)
+
+    @property
+    def trigger_timeout(self) -> Optional[float]:
+        if self.dev_osc.trigger_time_out == -1:
+            return None
+        return self.dev_osc.trigger_time_out
+
+    @trigger_timeout.setter
+    def trigger_timeout(self, trigger_timeout: Optional[Number]) -> None:
+        """
+        Set trigger time-out.
+
+        :param trigger_timeout: Trigger timeout value, in seconds; `0`  forces
+            trigger to start immediately after starting a measurement;
+            None leads to no timeout
+        :raise ValueError: If trigger timeout is not a non-negative real number.
+        """
+        trigger_timeout = self.clean_trigger_timeout(trigger_timeout)
+        self.dev_osc.trigger_time_out = trigger_timeout
+        if trigger_timeout == -1:
+            logger.info("Trigger timeout is set to \u221e (INFINITY) s.")
+        else:
+            logger.info(f"Trigger timeout is set to {trigger_timeout} s.")
+
+
+class TiePieOscilloscope(SingleCommDevice):
+    """
+    TiePie oscilloscope.
+
+    A wrapper for TiePie oscilloscopes, based on the class
+    `libtiepie.oscilloscope.Oscilloscope` with simplifications for starting of the
+    device (using serial number) and managing mutable configuration of both the
+    device and its channels, including extra validation and typing hints support for
+    configurations.
+
+    Note that, in contrast to `libtiepie` library, since all physical TiePie devices
+    include an oscilloscope, this is the base class for all physical TiePie devices.
+    The additional TiePie sub-devices: "Generator" and "I2CHost", are mixed-in to this
+    base class in subclasses.
+
+    The channels use `1..N` numbering (not `0..N-1`), as in, e.g., the Multi Channel
+    software.
+    """
+
+    @staticmethod
+    def config_cls() -> Type[TiePieDeviceConfig]:
+        return TiePieDeviceConfig
+
+    @staticmethod
+    def default_com_cls() -> Type[NullCommunicationProtocol]:
+        return NullCommunicationProtocol
+
+    def __init__(self, com, dev_config) -> None:
+        """
+        Constructor for a TiePie device.
+        """
+        super().__init__(com, dev_config)
+
+        self._osc: Optional[ltp_osc.Oscilloscope] = None
+
+        self.config_osc: Optional[TiePieOscilloscopeConfig] = None
+        """
+        Oscilloscope's dynamical configuration.
+        """
+
+        self.config_osc_channel_dict: Dict[int, TiePieOscilloscopeChannelConfig] = {}
+        """
+        Channel configuration.
+        A `dict` mapping actual channel number, numbered `1..N`, to channel
+        configuration. The channel info is dynamically read from the device only on
+        the first `start()`; beforehand the `dict` is empty.
+        """
+
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def _osc_config_setup(self) -> None:
+        """
+        Setup dynamical configuration for the connected oscilloscope.
+        """
+        assert self._osc is not None
+        self.config_osc = TiePieOscilloscopeConfig(
+            dev_osc=self._osc,
+        )
+        for n in range(1, self.n_channels + 1):
+            self.config_osc_channel_dict[n] = TiePieOscilloscopeChannelConfig(
+                ch_number=n,
+                channel=self._osc.channels[n - 1],
+            )
+        if self.config_osc_channel_dict[1].has_safe_ground:
+            TiePieOscilloscopeChannelConfig.safe_ground_enabled = (  # type: ignore
+                SafeGround()
+            )
+
+    def _osc_config_teardown(self) -> None:
+        """
+        Teardown dynamical configuration for the oscilloscope.
+        """
+        self.config_osc = None
+        self.config_osc_channel_dict = {}
+
+    def _osc_close(self) -> None:
+        """
+        Close the wrapped `libtiepie` oscilloscope.
+        """
+        if self._osc is not None:
+            del self._osc
+            self._osc = None
+
+    def _get_device_by_serial_number(
+        self,
+        # Note: TiePieDeviceType aenum as a tuple to define a return value type
+        ltp_device_type: Tuple[int, _LtpDeviceReturnType],
+    ) -> _LtpDeviceReturnType:
+        """
+        Wrapper around `get_device_by_serial_number` using this device's config options.
+
+        :return: A `libtiepie` device object specific to a class it is called on.
+        """
+        return get_device_by_serial_number(
+            self.config.serial_number,
+            ltp_device_type,
+            n_max_try_get_device=self.config.n_max_try_get_device,
+            wait_sec_retry_get_device=self.config.wait_sec_retry_get_device,
+        )
+
+    @wrap_libtiepie_exception
+    def start(self) -> None:  # type: ignore
+        """
+        Start the oscilloscope.
+        """
+        logger.info(f"Starting {self}")
+        super().start()
+        logger.info(
+            f"Starting oscilloscope with serial number {self.config.serial_number}"
+        )
+
+        self._osc = self._get_device_by_serial_number(TiePieDeviceType.OSCILLOSCOPE)
+
+        # Check for block measurement support if required
+        if self.config.require_block_measurement_support and not (
+            self._osc.measure_modes & ltp.MM_BLOCK  # type: ignore
+        ):
+            self._osc_close()
+            msg = (
+                f"Oscilloscope with serial number {self.config.serial_number} does not "
+                f"have required block measurement support."
+            )
+            logger.error(msg)
+            raise TiePieError(msg)
+
+        self._osc_config_setup()
+
+    @wrap_libtiepie_exception
+    def stop(self) -> None:  # type: ignore
+        """
+        Stop the oscilloscope.
+        """
+        logger.info(f"Stopping {self}")
+        logger.info("Stopping oscilloscope")
+
+        self._osc_config_teardown()
+        self._osc_close()
+
+        super().stop()
+
+    @staticmethod
+    @wrap_libtiepie_exception
+    def list_devices() -> ltp.devicelist.DeviceList:
+        """
+        List available TiePie devices.
+
+        :return: libtiepie up to date list of devices
+        """
+        ltp.network.auto_detect_enabled = True
+        device_list = ltp.device_list
+        device_list.update()
+
+        # log devices list
+        if device_list:
+            logger.info("Available devices:\n")
+
+            for item in ltp.device_list:
+                logger.info(f"  Name:              {item.name}")
+                logger.info(f"  Serial number:     {item.serial_number}")
+                logger.info(f"  Available types:   {ltp.device_type_str(item.types)}")
+                if item.has_server:
+                    logger.info(
+                        f"  Server:            "
+                        f"{item.server.url}({item.server.name})"
+                    )
+                logger.info(
+                    f"  Can be opened as "
+                    f"Oscilloscope: {item.can_open(ltp.DEVICETYPE_OSCILLOSCOPE)}\n"
+                )
+
+        else:
+            logger.info("No devices found!")
+
+        return device_list
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def start_measurement(self) -> None:
+        """
+        Start a measurement using set configuration.
+
+        :raises TiePieError: when device is not started or status of underlying device
+            gives an error
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        self._osc.start()
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def is_triggered(self) -> bool:
+        """
+        Reports if TiePie has triggered. Maybe data is not yet available. One can
+        check with the function `is_measurement_data_ready()`.
+
+        :return: if a trigger event occurred
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        _is_triggered = self._osc.is_triggered
+        logger.debug(f"TiePie has triggered: {_is_triggered}")
+        return _is_triggered
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def is_measurement_data_ready(self) -> bool:
+        """
+        Reports if TiePie has data which is ready to collect
+
+        :return: if the data is ready to collect.
+        :raises TiePieError: when device is not started or status of underlying device
+            gives an error
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        _is_measurement_data_ready = self._osc.is_data_ready
+        logger.debug(f"TiePie has measurement data ready: {_is_measurement_data_ready}")
+        return _is_measurement_data_ready
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def force_trigger(self) -> None:
+        """
+        Forces the TiePie to trigger with a software sided trigger event.
+
+        :return None:
+        :raises TiePieError: when device is not started or status of underlying device
+            gives an error
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        self._osc.force_trigger()
+        logger.info("A force trigger was sent to TiePie")
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def _check_record_length(self, data_array: npt.NDArray) -> None:
+        """
+        Check record length
+
+        :param data_array: raw data from TiePie as np.ndarray, which is already
+            filtered
+        :return None:
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        # make mypy happy: config_osc could be None, which has no attributes
+        if self.config_osc is None:
+            logger.warning("Oscilloscope is not configured")
+            return None
+
+        record_length_actual = len(data_array[:, 0])
+        if record_length_actual < self.config_osc.record_length:
+            logger.warning(
+                "Less Data than expected: Most likely the trigger occurred "
+                "before all pre trigger samples could be recorded. "
+                "(pre_sample_ratio was to high)"
+            )
+
+        pre_sample_count = self._osc.valid_pre_sample_count
+        record_length_predicted = (
+            int(self.config_osc.record_length * (1 - self.config_osc.pre_sample_ratio))
+            + pre_sample_count
+        )
+        if not record_length_actual == record_length_predicted:
+            logger.warning(
+                f"The actual record length ({record_length_actual} Sa) "
+                f"is shorter than the "
+                f"predicted record length ({record_length_predicted} Sa)"
+            )
+
+    @wrap_libtiepie_exception
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    def collect_measurement_data(
+        self, timeout: Optional[Number] = 0
+    ) -> Optional[npt.NDArray]:
+        """
+        Try to collect the data from TiePie; return `None` if data is not ready.
+
+        :param timeout: The timeout to wait until data is available. This
+            option makes this function blocking the code. `timeout = None` blocks the
+            code infinitely till data will be available. Per default, the `timeout`
+            is set to `0`: The function will not block.
+        :return: Measurement data of only enabled channels and time vector in a
+            2D-`numpy.ndarray` with float sample data; or None if there is no data
+            available.
+        """
+        # make mypy happy w/ assert; `is None` check is already done in the
+        # `_require_dev_handle` method decorator
+        assert self._osc is not None
+        # make mypy happy: config_osc could be None, which has no attributes
+        if self.config_osc is None:
+            logger.warning("Oscilloscope is not configured")
+            return None
+
+        if timeout is not None and not isinstance(timeout, (float, int)):
+            msg = (
+                f"timeout must be non-negative number, "
+                f"but '{timeout}' of type {type(timeout)} was given"
+            )
+            logger.error(msg)
+            raise ValueError(msg)
+
+        # Wait till timeout or till data is ready
+        start_time = time.time()
+        while not self.is_measurement_data_ready() and (
+            timeout is None or (time.time() - start_time < timeout)
+        ):
+            time.sleep(self.config.is_data_ready_polling_interval_sec)
+
+        if not self.is_measurement_data_ready():
+            logger.warning(
+                f"Data from TiePie was not ready to collect "
+                f"during a timeout of {timeout} s."
+            )
+            return None
+
+        # Collect raw data from tiepie
+        data = self._osc.get_data()
+        # filter-out disabled channels entries
+        data_array: npt.NDArray = np.array(list(filter(None, data))).T
+
+        self._check_record_length(data_array)
+
+        pre_sample_count = self._osc.valid_pre_sample_count
+        record_length_actual = len(data_array[:, 0])
+        time_vector = np.arange(
+            -pre_sample_count, record_length_actual - pre_sample_count
+        )
+        time_vector = time_vector / self.config_osc.sample_frequency
+
+        return np.column_stack([time_vector, data_array])
+
+    @property  # type: ignore
+    @_require_dev_handle(TiePieDeviceType.OSCILLOSCOPE)
+    @wrap_libtiepie_exception
+    def n_channels(self):
+        """
+        Number of channels in the oscilloscope.
+
+        :return: Number of channels.
+        """
+        return len(self._osc.channels)
+
+    @property
+    def channels_enabled(self) -> Generator[int, None, None]:
+        """
+        Yield numbers of enabled channels.
+
+        :return: Numbers of enabled channels
+        """
+        for (ch_nr, ch_config) in self.config_osc_channel_dict.items():
+            if ch_config.enabled:
+                yield ch_nr
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/tiepie/utils.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/tiepie/utils.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-
-"""
-import logging
-
-from aenum import Enum
-
-logger = logging.getLogger(__name__)
-
-
-class PublicPropertiesReprMixin:
-    """General purpose utility mixin that overwrites object representation to a one
-    analogous to `dataclass` instances, but using public properties and their values
-    instead of `fields`.
-    """
-
-    def _public_properties_gen(self):
-        """
-        Generator that returns instance's properties names and their values,
-        for properties that do not start with `"_"`
-
-        :return: attribute name and value tuples
-        """
-        for name in dir(self):
-            if (
-                not (name.startswith("_") or name.startswith("clean"))
-                and isinstance(getattr(self, name), (int, float, str, Enum))
-            ):
-                yield name, getattr(self, name)
-
-    def __repr__(self):
-        attrs = ", ".join(
-            [f"{name}={value!r}" for name, value in self._public_properties_gen()]
-        )
-        return f"{self.__class__.__qualname__}({attrs})"
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+
+"""
+import logging
+
+from aenum import Enum
+
+logger = logging.getLogger(__name__)
+
+
+class PublicPropertiesReprMixin:
+    """General purpose utility mixin that overwrites object representation to a one
+    analogous to `dataclass` instances, but using public properties and their values
+    instead of `fields`.
+    """
+
+    def _public_properties_gen(self):
+        """
+        Generator that returns instance's properties names and their values,
+        for properties that do not start with `"_"`
+
+        :return: attribute name and value tuples
+        """
+        for name in dir(self):
+            if (
+                not (name.startswith("_") or name.startswith("clean"))
+                and isinstance(getattr(self, name), (int, float, str, Enum))
+            ):
+                yield name, getattr(self, name)
+
+    def __repr__(self):
+        attrs = ", ".join(
+            [f"{name}={value!r}" for name, value in self._public_properties_gen()]
+        )
+        return f"{self.__class__.__qualname__}({attrs})"
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/utils.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/utils.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,139 +1,139 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-import logging
-import time
-from concurrent.futures._base import Future
-from concurrent.futures.thread import ThreadPoolExecutor
-from threading import Event
-from typing import Callable, Optional
-
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-class Poller:
-    """
-    Poller class wrapping `concurrent.futures.ThreadPoolExecutor` which enables passing
-    of results and errors out of the polling thread.
-    """
-
-    def __init__(
-        self,
-        spoll_handler: Callable,
-        polling_delay_sec: Number = 0,
-        polling_interval_sec: Number = 1,
-        polling_timeout_sec: Optional[Number] = None,
-    ):
-        """
-        Initialize the polling helper.
-
-        :param spoll_handler: Polling function.
-        :param polling_delay_sec: Delay before starting the polling, in seconds.
-        :param polling_interval_sec: Polling interval, in seconds.
-        """
-
-        self.spoll_handler: Callable = spoll_handler
-        self.polling_delay_sec: Number = polling_delay_sec
-        self.polling_interval_sec: Number = polling_interval_sec
-        self.polling_timeout_sec: Optional[Number] = polling_timeout_sec
-        self._polling_future: Optional[Future] = None
-        self._polling_stop_event: Optional[Event] = None
-
-    def is_polling(self) -> bool:
-        """
-        Check if device status is being polled.
-
-        :return: `True` when polling thread is set and alive
-        """
-        return self._polling_future is not None and self._polling_future.running()
-
-    def _if_poll_again(
-        self, stop_event: Event, delay_sec: Number, stop_time: Optional[Number]
-    ) -> bool:
-        """
-        Check if to poll again.
-
-        :param stop_event: Polling stop event.
-        :param delay_sec: Delay time (in seconds).
-        :param stop_time: Absolute stop time.
-        :return: `True` if another polling handler call is due, `False` otherwise.
-        """
-        not_stopped = not stop_event.wait(delay_sec)
-        not_timeout = stop_time is None or time.time() < stop_time
-        return not_stopped and not_timeout
-
-    def _poll_until_stop_or_timeout(self, stop_event: Event) -> Optional[object]:
-        """
-        Thread for polling until stopped or timed-out.
-
-        :param stop_event: Event used to stop the polling
-        :return: Last result of the polling function call
-        """
-        start_time = time.time()
-        stop_time = (
-            (start_time + self.polling_timeout_sec)
-            if self.polling_timeout_sec
-            else None
-        )
-        last_result = None
-
-        if self._if_poll_again(stop_event, self.polling_delay_sec, stop_time):
-            last_result = self.spoll_handler()
-
-        while self._if_poll_again(stop_event, self.polling_interval_sec, stop_time):
-            last_result = self.spoll_handler()
-
-        return last_result
-
-    def start_polling(self) -> bool:
-        """
-        Start polling.
-
-        :return: `True` if was not polling before, `False` otherwise
-        """
-        was_not_polling = not self.is_polling()
-
-        if was_not_polling:
-            logger.info("Start polling")
-            self._polling_stop_event = Event()
-            pool = ThreadPoolExecutor(max_workers=1)
-            self._polling_future = pool.submit(
-                self._poll_until_stop_or_timeout, self._polling_stop_event
-            )
-
-        return was_not_polling
-
-    def stop_polling(self) -> bool:
-        """
-        Stop polling.
-
-        Wait for until polling function returns a result as well as any exception that
-        might have been raised within a thread.
-
-        :return: `True` if was polling before, `False` otherwise, and last result of
-            the polling function call.
-        :raises: polling function exceptions
-        """
-        was_polling = self.is_polling()
-
-        if was_polling:
-            logger.info("Stop polling")
-            if self._polling_stop_event is None:
-                raise RuntimeError("Was polling but stop event is missing.")
-            self._polling_stop_event.set()
-            if self._polling_future is None:
-                raise RuntimeError("Was polling but polling future is missing.")
-
-        return was_polling
-
-    def wait_for_polling_result(self):
-        """
-        Wait for until polling function returns a result as well as any exception that
-        might have been raised within a thread.
-
-        :return: polling function result
-        :raises: polling function errors
-        """
-
-        return self._polling_future.result()
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+import logging
+import time
+from concurrent.futures._base import Future
+from concurrent.futures.thread import ThreadPoolExecutor
+from threading import Event
+from typing import Callable, Optional
+
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+class Poller:
+    """
+    Poller class wrapping `concurrent.futures.ThreadPoolExecutor` which enables passing
+    of results and errors out of the polling thread.
+    """
+
+    def __init__(
+        self,
+        spoll_handler: Callable,
+        polling_delay_sec: Number = 0,
+        polling_interval_sec: Number = 1,
+        polling_timeout_sec: Optional[Number] = None,
+    ):
+        """
+        Initialize the polling helper.
+
+        :param spoll_handler: Polling function.
+        :param polling_delay_sec: Delay before starting the polling, in seconds.
+        :param polling_interval_sec: Polling interval, in seconds.
+        """
+
+        self.spoll_handler: Callable = spoll_handler
+        self.polling_delay_sec: Number = polling_delay_sec
+        self.polling_interval_sec: Number = polling_interval_sec
+        self.polling_timeout_sec: Optional[Number] = polling_timeout_sec
+        self._polling_future: Optional[Future] = None
+        self._polling_stop_event: Optional[Event] = None
+
+    def is_polling(self) -> bool:
+        """
+        Check if device status is being polled.
+
+        :return: `True` when polling thread is set and alive
+        """
+        return self._polling_future is not None and self._polling_future.running()
+
+    def _if_poll_again(
+        self, stop_event: Event, delay_sec: Number, stop_time: Optional[Number]
+    ) -> bool:
+        """
+        Check if to poll again.
+
+        :param stop_event: Polling stop event.
+        :param delay_sec: Delay time (in seconds).
+        :param stop_time: Absolute stop time.
+        :return: `True` if another polling handler call is due, `False` otherwise.
+        """
+        not_stopped = not stop_event.wait(delay_sec)
+        not_timeout = stop_time is None or time.time() < stop_time
+        return not_stopped and not_timeout
+
+    def _poll_until_stop_or_timeout(self, stop_event: Event) -> Optional[object]:
+        """
+        Thread for polling until stopped or timed-out.
+
+        :param stop_event: Event used to stop the polling
+        :return: Last result of the polling function call
+        """
+        start_time = time.time()
+        stop_time = (
+            (start_time + self.polling_timeout_sec)
+            if self.polling_timeout_sec
+            else None
+        )
+        last_result = None
+
+        if self._if_poll_again(stop_event, self.polling_delay_sec, stop_time):
+            last_result = self.spoll_handler()
+
+        while self._if_poll_again(stop_event, self.polling_interval_sec, stop_time):
+            last_result = self.spoll_handler()
+
+        return last_result
+
+    def start_polling(self) -> bool:
+        """
+        Start polling.
+
+        :return: `True` if was not polling before, `False` otherwise
+        """
+        was_not_polling = not self.is_polling()
+
+        if was_not_polling:
+            logger.info("Start polling")
+            self._polling_stop_event = Event()
+            pool = ThreadPoolExecutor(max_workers=1)
+            self._polling_future = pool.submit(
+                self._poll_until_stop_or_timeout, self._polling_stop_event
+            )
+
+        return was_not_polling
+
+    def stop_polling(self) -> bool:
+        """
+        Stop polling.
+
+        Wait for until polling function returns a result as well as any exception that
+        might have been raised within a thread.
+
+        :return: `True` if was polling before, `False` otherwise, and last result of
+            the polling function call.
+        :raises: polling function exceptions
+        """
+        was_polling = self.is_polling()
+
+        if was_polling:
+            logger.info("Stop polling")
+            if self._polling_stop_event is None:
+                raise RuntimeError("Was polling but stop event is missing.")
+            self._polling_stop_event.set()
+            if self._polling_future is None:
+                raise RuntimeError("Was polling but polling future is missing.")
+
+        return was_polling
+
+    def wait_for_polling_result(self):
+        """
+        Wait for until polling function returns a result as well as any exception that
+        might have been raised within a thread.
+
+        :return: polling function result
+        :raises: polling function errors
+        """
+
+        return self._polling_future.result()
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/dev/visa.py` & `hvl_ccb-0.9.0/hvl_ccb/dev/visa.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,233 +1,233 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-import logging
-import re
-from datetime import datetime, timedelta
-from time import sleep
-from typing import Type, Union, Optional
-
-from bitstring import BitArray
-
-from .base import SingleCommDevice
-from .utils import Poller
-from ..comm import VisaCommunication, VisaCommunicationConfig
-from ..configuration import configdataclass
-from ..utils.typing import Number
-
-logger = logging.getLogger(__name__)
-
-
-@configdataclass
-class _VisaDeviceConfigBase:
-    """
-    Required VisaDeviceConfig keys, separated from the default ones to enable config
-    extension by inheritance with required keys.
-    """
-
-    # NOTE: this class is unnecessary as there are no keys here; it's coded here only
-    # to illustrate a solution; for detailed explanations of the issue see:
-    # https://stackoverflow.com/questions/51575931/class-inheritance-in-python-3-7-dataclasses/
-    pass
-
-
-@configdataclass
-class _VisaDeviceConfigDefaultsBase:
-
-    spoll_interval: Number = 0.5
-    """
-    Seconds to wait between status polling.
-    """
-
-    spoll_start_delay: Number = 2
-    """
-    Seconds to delay the start of status polling.
-    """
-
-    def clean_values(self):
-        if self.spoll_interval <= 0:
-            raise ValueError("Polling interval needs to be positive.")
-
-        if self.spoll_start_delay < 0:
-            raise ValueError("Polling start delay needs to be non-negative.")
-
-
-@configdataclass
-class VisaDeviceConfig(_VisaDeviceConfigDefaultsBase, _VisaDeviceConfigBase):
-    """
-    Configdataclass for a VISA device.
-    """
-
-    pass
-
-
-class VisaDevice(SingleCommDevice):
-    """
-    Device communicating over the VISA protocol using VisaCommunication.
-    """
-
-    def __init__(
-        self,
-        com: Union[VisaCommunication, VisaCommunicationConfig, dict],
-        dev_config: Union[VisaDeviceConfig, dict, None] = None,
-    ) -> None:
-
-        super().__init__(com, dev_config)
-
-        self._spoll_thread: Union[Poller, None] = None
-
-        self._notify_operation_complete: bool = False
-
-    @staticmethod
-    def default_com_cls() -> Type[VisaCommunication]:
-        """
-        Return the default communication protocol for this device type, which is
-        VisaCommunication.
-
-        :return: the VisaCommunication class
-        """
-
-        return VisaCommunication
-
-    @staticmethod
-    def config_cls():
-        return VisaDeviceConfig
-
-    def get_identification(self) -> str:
-        """
-        Queries `"*IDN?"` and returns the identification string of the connected device.
-
-        :return: the identification string of the connected device
-        """
-
-        return self.com.query("*IDN?")
-
-    def start(self) -> None:
-        """
-        Start the VisaDevice. Sets up the status poller and starts it.
-
-        :return:
-        """
-        super().start()
-        self._spoll_thread = Poller(
-            polling_interval_sec=self.config.spoll_interval,
-            polling_delay_sec=self.config.spoll_start_delay,
-            spoll_handler=self.spoll_handler,
-        )
-        self._spoll_thread.start_polling()
-
-    def stop(self) -> None:
-        """
-        Stop the VisaDevice. Stops the polling thread and closes the communication
-        protocol.
-
-        :return:
-        """
-        if self._spoll_thread:
-            self._spoll_thread.stop_polling()
-        super().stop()
-
-    def spoll_handler(self):
-        """
-        Reads the status byte and decodes it. The status byte STB is defined in
-        IEEE 488.2. It provides a rough overview of the instrument status.
-
-        :return:
-        """
-        stb = self.com.spoll()
-
-        if stb:
-            bits = BitArray(length=8, int=stb)
-            bits.reverse()
-
-            if bits[0]:
-                # has no meaning, always zero
-                pass
-
-            if bits[1]:
-                # has no meaning, always zero
-                pass
-
-            if bits[2]:
-                # error queue contains new error
-                logger.debug(f"Error bit set in STB: {stb}")
-                self.get_error_queue()
-
-            if bits[3]:
-                # Questionable Status QUES summary bit
-                logger.debug(f"Questionable status bit set in STB: {stb}")
-
-            if bits[4]:
-                # Output buffer holds data (RTO 1024), MAV bit (Message available)
-                pass
-
-            if bits[5]:
-                # Event status byte ESB, summary of ESR register (RTO 1024)
-                logger.debug(f"Operation status bit set in STB: {stb}")
-
-                # read event status register
-                esr = int(self.com.query("*ESR?"))
-                esr_bits = BitArray(length=8, int=esr)
-                esr_bits.reverse()
-
-                if esr_bits[0]:
-                    # Operation complete bit set. This bit is set on receipt of the
-                    # command *OPC exactly when all previous commands have been
-                    # executed.
-                    logger.debug(f"Operation complete bit set in ESR: {esr}")
-                    self._notify_operation_complete = True
-
-            if bits[6]:
-                # RQS/MSS bit (RTO 1024)
-                pass
-
-            if bits[7]:
-                # Operation Status OPER summary bit
-                pass
-
-    def wait_operation_complete(self, timeout: Optional[float] = None) -> bool:
-        """
-        Waits for a operation complete event. Returns after timeout [s] has expired
-        or the operation complete event has been caught.
-
-        :param timeout: Time in seconds to wait for the event; `None` for no timeout.
-        :return: True, if OPC event is caught, False if timeout expired
-        """
-
-        # reset event bit
-        self._notify_operation_complete = False
-
-        # compute timeout
-        timeout_time = datetime.now() + timedelta(seconds=(timeout or 0))
-
-        # wait until event is caught
-        while not self._notify_operation_complete:
-            sleep(0.01)
-            if timeout is not None and datetime.now() > timeout_time:
-                break
-
-        # if event was caught, return true
-        if self._notify_operation_complete:
-            self._notify_operation_complete = False
-            return True
-
-        # if timeout expired, return false
-        return False
-
-    def get_error_queue(self) -> str:
-        """
-        Read out error queue and logs the error.
-
-        :return: Error string
-        """
-
-        err_string = self.com.query("SYSTem:ERRor:ALL?")
-        for error in re.findall("[^,]+,[^,]+", err_string):
-            logger.error(f"VISA Error from Device: {error}")
-        return err_string
-
-    def reset(self) -> None:
-        """
-        Send `"*RST"` and `"*CLS"` to the device. Typically sets a defined state.
-        """
-
-        self.com.write("*RST", "*CLS")
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+import logging
+import re
+from datetime import datetime, timedelta
+from time import sleep
+from typing import Type, Union, Optional
+
+from bitstring import BitArray
+
+from .base import SingleCommDevice
+from .utils import Poller
+from ..comm import VisaCommunication, VisaCommunicationConfig
+from ..configuration import configdataclass
+from ..utils.typing import Number
+
+logger = logging.getLogger(__name__)
+
+
+@configdataclass
+class _VisaDeviceConfigBase:
+    """
+    Required VisaDeviceConfig keys, separated from the default ones to enable config
+    extension by inheritance with required keys.
+    """
+
+    # NOTE: this class is unnecessary as there are no keys here; it's coded here only
+    # to illustrate a solution; for detailed explanations of the issue see:
+    # https://stackoverflow.com/questions/51575931/class-inheritance-in-python-3-7-dataclasses/
+    pass
+
+
+@configdataclass
+class _VisaDeviceConfigDefaultsBase:
+
+    spoll_interval: Number = 0.5
+    """
+    Seconds to wait between status polling.
+    """
+
+    spoll_start_delay: Number = 2
+    """
+    Seconds to delay the start of status polling.
+    """
+
+    def clean_values(self):
+        if self.spoll_interval <= 0:
+            raise ValueError("Polling interval needs to be positive.")
+
+        if self.spoll_start_delay < 0:
+            raise ValueError("Polling start delay needs to be non-negative.")
+
+
+@configdataclass
+class VisaDeviceConfig(_VisaDeviceConfigDefaultsBase, _VisaDeviceConfigBase):
+    """
+    Configdataclass for a VISA device.
+    """
+
+    pass
+
+
+class VisaDevice(SingleCommDevice):
+    """
+    Device communicating over the VISA protocol using VisaCommunication.
+    """
+
+    def __init__(
+        self,
+        com: Union[VisaCommunication, VisaCommunicationConfig, dict],
+        dev_config: Union[VisaDeviceConfig, dict, None] = None,
+    ) -> None:
+
+        super().__init__(com, dev_config)
+
+        self._spoll_thread: Union[Poller, None] = None
+
+        self._notify_operation_complete: bool = False
+
+    @staticmethod
+    def default_com_cls() -> Type[VisaCommunication]:
+        """
+        Return the default communication protocol for this device type, which is
+        VisaCommunication.
+
+        :return: the VisaCommunication class
+        """
+
+        return VisaCommunication
+
+    @staticmethod
+    def config_cls():
+        return VisaDeviceConfig
+
+    def get_identification(self) -> str:
+        """
+        Queries `"*IDN?"` and returns the identification string of the connected device.
+
+        :return: the identification string of the connected device
+        """
+
+        return self.com.query("*IDN?")
+
+    def start(self) -> None:
+        """
+        Start the VisaDevice. Sets up the status poller and starts it.
+
+        :return:
+        """
+        super().start()
+        self._spoll_thread = Poller(
+            polling_interval_sec=self.config.spoll_interval,
+            polling_delay_sec=self.config.spoll_start_delay,
+            spoll_handler=self.spoll_handler,
+        )
+        self._spoll_thread.start_polling()
+
+    def stop(self) -> None:
+        """
+        Stop the VisaDevice. Stops the polling thread and closes the communication
+        protocol.
+
+        :return:
+        """
+        if self._spoll_thread:
+            self._spoll_thread.stop_polling()
+        super().stop()
+
+    def spoll_handler(self):
+        """
+        Reads the status byte and decodes it. The status byte STB is defined in
+        IEEE 488.2. It provides a rough overview of the instrument status.
+
+        :return:
+        """
+        stb = self.com.spoll()
+
+        if stb:
+            bits = BitArray(length=8, int=stb)
+            bits.reverse()
+
+            if bits[0]:
+                # has no meaning, always zero
+                pass
+
+            if bits[1]:
+                # has no meaning, always zero
+                pass
+
+            if bits[2]:
+                # error queue contains new error
+                logger.debug(f"Error bit set in STB: {stb}")
+                self.get_error_queue()
+
+            if bits[3]:
+                # Questionable Status QUES summary bit
+                logger.debug(f"Questionable status bit set in STB: {stb}")
+
+            if bits[4]:
+                # Output buffer holds data (RTO 1024), MAV bit (Message available)
+                pass
+
+            if bits[5]:
+                # Event status byte ESB, summary of ESR register (RTO 1024)
+                logger.debug(f"Operation status bit set in STB: {stb}")
+
+                # read event status register
+                esr = int(self.com.query("*ESR?"))
+                esr_bits = BitArray(length=8, int=esr)
+                esr_bits.reverse()
+
+                if esr_bits[0]:
+                    # Operation complete bit set. This bit is set on receipt of the
+                    # command *OPC exactly when all previous commands have been
+                    # executed.
+                    logger.debug(f"Operation complete bit set in ESR: {esr}")
+                    self._notify_operation_complete = True
+
+            if bits[6]:
+                # RQS/MSS bit (RTO 1024)
+                pass
+
+            if bits[7]:
+                # Operation Status OPER summary bit
+                pass
+
+    def wait_operation_complete(self, timeout: Optional[float] = None) -> bool:
+        """
+        Waits for a operation complete event. Returns after timeout [s] has expired
+        or the operation complete event has been caught.
+
+        :param timeout: Time in seconds to wait for the event; `None` for no timeout.
+        :return: True, if OPC event is caught, False if timeout expired
+        """
+
+        # reset event bit
+        self._notify_operation_complete = False
+
+        # compute timeout
+        timeout_time = datetime.now() + timedelta(seconds=(timeout or 0))
+
+        # wait until event is caught
+        while not self._notify_operation_complete:
+            sleep(0.01)
+            if timeout is not None and datetime.now() > timeout_time:
+                break
+
+        # if event was caught, return true
+        if self._notify_operation_complete:
+            self._notify_operation_complete = False
+            return True
+
+        # if timeout expired, return false
+        return False
+
+    def get_error_queue(self) -> str:
+        """
+        Read out error queue and logs the error.
+
+        :return: Error string
+        """
+
+        err_string = self.com.query("SYSTem:ERRor:ALL?")
+        for error in re.findall("[^,]+,[^,]+", err_string):
+            logger.error(f"VISA Error from Device: {error}")
+        return err_string
+
+    def reset(self) -> None:
+        """
+        Send `"*RST"` and `"*CLS"` to the device. Typically sets a defined state.
+        """
+
+        self.com.write("*RST", "*CLS")
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/experiment_manager.py` & `hvl_ccb-0.9.0/hvl_ccb/experiment_manager.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,189 +1,189 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Main module containing the top level ExperimentManager class.
-Inherit from this class to implement your own experiment functionality in another
-project and it will help you start, stop and manage your devices.
-"""
-
-import logging
-from enum import Enum
-from typing import Dict
-
-from .dev import Device, DeviceSequenceMixin
-
-logger = logging.getLogger(__name__)
-
-
-class ExperimentStatus(Enum):
-    """
-    Enumeration for the experiment status
-    """
-
-    INITIALIZING = -1
-    INITIALIZED = 0
-    STARTING = 1
-    RUNNING = 2
-    FINISHING = 3
-    FINISHED = 4
-    ERROR = 5
-
-
-class ExperimentError(Exception):
-    """
-    Exception to indicate that the current status of the experiment manager is on
-    ERROR and thus no operations can be made until reset.
-    """
-
-
-class ExperimentManager(DeviceSequenceMixin):
-    """
-    Experiment Manager can start and stop communication protocols and devices.
-    It provides methods to queue commands to
-    devices and collect results.
-    """
-
-    def __new__(cls, *args, **kwargs) -> "ExperimentManager":
-        """
-        Construct a new `ExperimentManager` instance.
-
-        :param args: `__init__` arguments
-        :param kwargs: `__init__` keyword arguments
-        :return: `ExperimentManager` with status set to `ExperimentStatus.INITIALIZING`.
-        """
-        obj = super().__new__(cls)
-        # experiment manager status
-        obj._status = ExperimentStatus.INITIALIZING
-        return obj
-
-    def __init__(self, devices: Dict[str, Device]) -> None:
-        """
-        Initialize `ExperimentManager`. Takes a dictionary of instantiated devices
-        and initializes the experiment status to `ExperimentStatus.INITIALIZED`.
-
-        :param devices: Devices sequenced in the experiment.
-        """
-        super().__init__(devices)
-
-        self._change_status(ExperimentStatus.INITIALIZED)
-
-    def _change_status(self, new_status: ExperimentStatus) -> None:
-        """
-        Change the status of this experiment manager to a new value. Includes logging.
-
-        :param new_status: is the Enum of the new experiment status.
-        """
-
-        if new_status is not self._status:
-            log_msg = f"Experiment Status: {new_status} {new_status.name}"
-            # new status is different, log
-            if new_status is ExperimentStatus.ERROR:
-                logger.error(log_msg)
-            else:
-                logger.info(log_msg)
-            self._status: ExperimentStatus = new_status
-
-    def run(self) -> None:
-        """
-        Start experimental setup, start all devices.
-        """
-
-        self._change_status(ExperimentStatus.STARTING)
-
-        try:
-            super().start()
-        except Exception as e:
-            logger.error(str(e), exc_info=e)
-            self._change_status(ExperimentStatus.ERROR)
-            raise ExperimentError from e
-        else:
-            self._change_status(ExperimentStatus.RUNNING)
-
-    def finish(self) -> None:
-        """
-        Stop experimental setup, stop all devices.
-        """
-
-        self._change_status(ExperimentStatus.FINISHING)
-
-        try:
-            super().stop()
-        except Exception as e:
-            logger.error(str(e), exc_info=e)
-            self._change_status(ExperimentStatus.ERROR)
-            raise ExperimentError from e
-        else:
-            self._change_status(ExperimentStatus.FINISHED)
-
-    def start(self) -> None:
-        """
-        Alias for ExperimentManager.run()
-        """
-        self.run()
-
-    def stop(self) -> None:
-        """
-        Alias for ExperimentManager.finish()
-        """
-        self.finish()
-
-    @property
-    def status(self) -> ExperimentStatus:
-        """
-        Get experiment status.
-
-        :return: experiment status enum code.
-        """
-
-        return self._status
-
-    def is_finished(self) -> bool:
-        """
-        Returns true, if the status of the experiment manager is `finished`.
-
-        :return: True if finished, false otherwise
-        """
-        return self.status == ExperimentStatus.FINISHED
-
-    def is_running(self) -> bool:
-        """
-        Returns true, if the status of the experiment manager is `running`.
-
-        :return: True if running, false otherwise
-        """
-        return self.status == ExperimentStatus.RUNNING
-
-    def is_error(self) -> bool:
-        """
-        Returns true, if the status of the experiment manager is `error`.
-
-        :return: True if on error, false otherwise
-        """
-        return self.status == ExperimentStatus.ERROR
-
-    def add_device(self, name: str, device: Device) -> None:
-        """
-        Add a new device to the manager. If the experiment is running, automatically
-        start the device. If a device with this name already exists, raise an exception.
-
-        :param name: is the name of the device.
-        :param device: is the instantiated Device object.
-        :raise DeviceExistingException:
-        """
-
-        if self.status == ExperimentStatus.ERROR:
-            err_msg = "Experiment is on ERROR, cannot add device"
-            logger.error(err_msg)
-            raise ExperimentError(err_msg)
-
-        super().add_device(name, device)
-
-        # check experiment status and start device if started
-        if self.status == ExperimentStatus.RUNNING:
-            logger.info(f"Experiment is already RUNNING, start Device {device}")
-            try:
-                device.start()
-            except Exception as e:
-                logger.error(str(e), exc_info=e)
-                self._change_status(ExperimentStatus.ERROR)
-                raise ExperimentError from e
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Main module containing the top level ExperimentManager class.
+Inherit from this class to implement your own experiment functionality in another
+project and it will help you start, stop and manage your devices.
+"""
+
+import logging
+from enum import Enum
+from typing import Dict
+
+from .dev import Device, DeviceSequenceMixin
+
+logger = logging.getLogger(__name__)
+
+
+class ExperimentStatus(Enum):
+    """
+    Enumeration for the experiment status
+    """
+
+    INITIALIZING = -1
+    INITIALIZED = 0
+    STARTING = 1
+    RUNNING = 2
+    FINISHING = 3
+    FINISHED = 4
+    ERROR = 5
+
+
+class ExperimentError(Exception):
+    """
+    Exception to indicate that the current status of the experiment manager is on
+    ERROR and thus no operations can be made until reset.
+    """
+
+
+class ExperimentManager(DeviceSequenceMixin):
+    """
+    Experiment Manager can start and stop communication protocols and devices.
+    It provides methods to queue commands to
+    devices and collect results.
+    """
+
+    def __new__(cls, *args, **kwargs) -> "ExperimentManager":
+        """
+        Construct a new `ExperimentManager` instance.
+
+        :param args: `__init__` arguments
+        :param kwargs: `__init__` keyword arguments
+        :return: `ExperimentManager` with status set to `ExperimentStatus.INITIALIZING`.
+        """
+        obj = super().__new__(cls)
+        # experiment manager status
+        obj._status = ExperimentStatus.INITIALIZING
+        return obj
+
+    def __init__(self, devices: Dict[str, Device]) -> None:
+        """
+        Initialize `ExperimentManager`. Takes a dictionary of instantiated devices
+        and initializes the experiment status to `ExperimentStatus.INITIALIZED`.
+
+        :param devices: Devices sequenced in the experiment.
+        """
+        super().__init__(devices)
+
+        self._change_status(ExperimentStatus.INITIALIZED)
+
+    def _change_status(self, new_status: ExperimentStatus) -> None:
+        """
+        Change the status of this experiment manager to a new value. Includes logging.
+
+        :param new_status: is the Enum of the new experiment status.
+        """
+
+        if new_status is not self._status:
+            log_msg = f"Experiment Status: {new_status} {new_status.name}"
+            # new status is different, log
+            if new_status is ExperimentStatus.ERROR:
+                logger.error(log_msg)
+            else:
+                logger.info(log_msg)
+            self._status: ExperimentStatus = new_status
+
+    def run(self) -> None:
+        """
+        Start experimental setup, start all devices.
+        """
+
+        self._change_status(ExperimentStatus.STARTING)
+
+        try:
+            super().start()
+        except Exception as e:
+            logger.error(str(e), exc_info=e)
+            self._change_status(ExperimentStatus.ERROR)
+            raise ExperimentError from e
+        else:
+            self._change_status(ExperimentStatus.RUNNING)
+
+    def finish(self) -> None:
+        """
+        Stop experimental setup, stop all devices.
+        """
+
+        self._change_status(ExperimentStatus.FINISHING)
+
+        try:
+            super().stop()
+        except Exception as e:
+            logger.error(str(e), exc_info=e)
+            self._change_status(ExperimentStatus.ERROR)
+            raise ExperimentError from e
+        else:
+            self._change_status(ExperimentStatus.FINISHED)
+
+    def start(self) -> None:
+        """
+        Alias for ExperimentManager.run()
+        """
+        self.run()
+
+    def stop(self) -> None:
+        """
+        Alias for ExperimentManager.finish()
+        """
+        self.finish()
+
+    @property
+    def status(self) -> ExperimentStatus:
+        """
+        Get experiment status.
+
+        :return: experiment status enum code.
+        """
+
+        return self._status
+
+    def is_finished(self) -> bool:
+        """
+        Returns true, if the status of the experiment manager is `finished`.
+
+        :return: True if finished, false otherwise
+        """
+        return self.status == ExperimentStatus.FINISHED
+
+    def is_running(self) -> bool:
+        """
+        Returns true, if the status of the experiment manager is `running`.
+
+        :return: True if running, false otherwise
+        """
+        return self.status == ExperimentStatus.RUNNING
+
+    def is_error(self) -> bool:
+        """
+        Returns true, if the status of the experiment manager is `error`.
+
+        :return: True if on error, false otherwise
+        """
+        return self.status == ExperimentStatus.ERROR
+
+    def add_device(self, name: str, device: Device) -> None:
+        """
+        Add a new device to the manager. If the experiment is running, automatically
+        start the device. If a device with this name already exists, raise an exception.
+
+        :param name: is the name of the device.
+        :param device: is the instantiated Device object.
+        :raise DeviceExistingException:
+        """
+
+        if self.status == ExperimentStatus.ERROR:
+            err_msg = "Experiment is on ERROR, cannot add device"
+            logger.error(err_msg)
+            raise ExperimentError(err_msg)
+
+        super().add_device(name, device)
+
+        # check experiment status and start device if started
+        if self.status == ExperimentStatus.RUNNING:
+            logger.info(f"Experiment is already RUNNING, start Device {device}")
+            try:
+                device.start()
+            except Exception as e:
+                logger.error(str(e), exc_info=e)
+                self._change_status(ExperimentStatus.ERROR)
+                raise ExperimentError from e
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/utils/conversion_sensor.py` & `hvl_ccb-0.9.0/hvl_ccb/utils/conversion_sensor.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,149 +1,151 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-
-"""
-Sensors that are used by the devices implemented in the CCB
-"""
-
-import dataclasses
-import logging
-import typing
-from abc import ABC, abstractmethod
-from dataclasses import dataclass, fields
-
-import numpy as np
-import numpy.typing as npt
-
-from hvl_ccb.utils.conversion_unit import Temperature, preserve_type
-from hvl_ccb.utils.typing import ConvertableTypes
-from hvl_ccb.utils.validation import validate_number
-
-
-logger = logging.getLogger(__name__)
-
-
-@dataclass  # type: ignore
-class Sensor(ABC):
-    """
-    The BaseClass 'Sensor' is designed as a parent for all Sensors.
-    Each attribute must be added to '__setattr__', so that the value is verified each
-    time the value is changed.
-    It is important to mark attributes that should be constant with
-    'typing.ClassVar[...]'. Together with 'super().__setattr__(name, value)', this
-    guarantees that the values are protected and cannot be altered by the user.
-    """
-
-    @abstractmethod
-    def __setattr__(self, name, value):
-        if dataclasses._is_classvar(typing.get_type_hints(self)[name], typing):
-            field_names = [f"'{field.name}'" for field in fields(self)]
-            msg = (
-                f"Attribute {name} is a constant and cannot be changed. You can edit "
-                f"one of the following attributes instead: {', '.join(field_names)}"
-            )
-            logger.error(msg)
-            raise AttributeError(msg)
-
-    @abstractmethod
-    @preserve_type
-    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
-        pass
-
-
-@dataclass
-class LEM4000S(Sensor):
-    """
-    Converts the output voltage (V) to the measured current (A)
-    when using a LEM Current transducer LT 4000-S
-
-    """
-    CONVERSION: typing.ClassVar[int] = 5000
-    shunt: float = 1.2
-    calibration_factor: float = 1
-
-    def __setattr__(self, name, value):
-        super().__setattr__(name, value)
-        if name == 'shunt':
-            # ensure positive value, but also allow a very small shunt
-            validate_number('shunt', value, (1e-6, None))
-        if name == "calibration_factor":
-            # ensure a value close to 1, but also allow negative values
-            # for a reversed current sensor
-            validate_number("calibration_factor", abs(value), (0.9, 1.1))
-        self.__dict__[name] = value
-
-    @preserve_type
-    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
-        conversion = self.CONVERSION * self.calibration_factor
-        value = value / self.shunt * conversion  # type: ignore
-        return value
-
-
-@dataclass
-class LMT70A(Sensor):
-    """
-    Converts the output voltage (V) to the measured temperature (default °C)
-    when using a TI Precision Analog Temperature Sensor LMT70(A)
-
-    """
-    temperature_unit: Temperature = Temperature.CELSIUS
-
-    # look up table from datasheet
-    # first column: temperature in degree celsius
-    # second column: voltage in volt
-    # https://www.ti.com/lit/ds/symlink/lmt70a.pdf?ts=1631590373860
-    LUT: typing.ClassVar[npt.NDArray] = np.array(
-        [
-            [-55., 1.375219],
-            [-50., 1.350441],
-            [-40., 1.300593],
-            [-30., 1.250398],
-            [-20., 1.199884],
-            [-10., 1.14907],
-            [0., 1.097987],
-            [10., 1.046647],
-            [20., 0.99505],
-            [30., 0.943227],
-            [40., 0.891178],
-            [50., 0.838882],
-            [60., 0.78636],
-            [70., 0.733608],
-            [80., 0.680654],
-            [90., 0.62749],
-            [100., 0.574117],
-            [110., 0.520551],
-            [120., 0.46676],
-            [130., 0.412739],
-            [140., 0.358164],
-            [150., 0.302785]
-        ]
-    )
-
-    def __setattr__(self, name, value):
-        super().__setattr__(name, value)
-        if name == 'temperature_unit':
-            Temperature(value)
-        self.__dict__[name] = value
-
-    @preserve_type
-    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
-        """
-        NaN is returned for values that are not covered by the look up table
-        :param value: output voltage of the sensor.
-        :raise TypeError: for non convertable data types
-        :return: measured temperature (default °C)
-        """
-        try:
-            validate_number(
-                "value", value, (self.LUT[-1, 1], self.LUT[0, 1]), logger=logger
-            )
-        except ValueError:
-            mask = np.any([value < self.LUT[-1, 1], value > self.LUT[0, 1]], axis=0)
-            value[mask] = np.NaN  # type: ignore
-        logging.info(
-            "Use linear interpolation of lookup table provided in datasheet"
-        )
-        value = np.interp(value, self.LUT[::-1, 1], self.LUT[::-1, 0])
-        return Temperature.convert(
-            value, source=Temperature.CELSIUS, target=self.temperature_unit
-        )
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+
+"""
+Sensors that are used by the devices implemented in the CCB
+"""
+
+import dataclasses
+import logging
+import typing
+from abc import ABC, abstractmethod
+from dataclasses import dataclass, fields
+
+import numpy as np
+import numpy.typing as npt
+
+from hvl_ccb.utils.conversion_unit import Temperature, preserve_type
+from hvl_ccb.utils.typing import ConvertableTypes
+from hvl_ccb.utils.validation import validate_number
+
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass  # type: ignore
+class Sensor(ABC):
+    """
+    The BaseClass 'Sensor' is designed as a parent for all Sensors.
+    Each attribute must be added to '__setattr__', so that the value is verified each
+    time the value is changed.
+    It is important to mark attributes that should be constant with
+    'typing.ClassVar[...]'. Together with 'super().__setattr__(name, value)', this
+    guarantees that the values are protected and cannot be altered by the user.
+    """
+
+    @abstractmethod
+    def __setattr__(self, name, value):
+        if dataclasses._is_classvar(typing.get_type_hints(self)[name], typing):
+            field_names = [f"'{field.name}'" for field in fields(self)]
+            msg = (
+                f"Attribute {name} is a constant and cannot be changed. You can edit "
+                f"one of the following attributes instead: {', '.join(field_names)}"
+            )
+            logger.error(msg)
+            raise AttributeError(msg)
+
+    @abstractmethod
+    @preserve_type
+    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
+        pass
+
+
+@dataclass
+class LEM4000S(Sensor):
+    """
+    Converts the output voltage (V) to the measured current (A)
+    when using a LEM Current transducer LT 4000-S
+
+    """
+    CONVERSION: typing.ClassVar[int] = 5000
+    shunt: float = 1.2
+    calibration_factor: float = 1
+
+    def __setattr__(self, name, value):
+        super().__setattr__(name, value)
+        if name == 'shunt':
+            # ensure positive value, but also allow a very small shunt
+            validate_number('shunt', value, (1e-6, None))
+        if name == "calibration_factor":
+            # ensure a value close to 1, but also allow negative values
+            # for a reversed current sensor
+            validate_number("calibration_factor", abs(value), (0.9, 1.1))
+        self.__dict__[name] = value
+
+    @preserve_type
+    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
+        conversion = self.CONVERSION * self.calibration_factor
+        value = value / self.shunt * conversion  # type: ignore
+        return value
+
+
+@dataclass
+class LMT70A(Sensor):
+    """
+    Converts the output voltage (V) to the measured temperature (default °C)
+    when using a TI Precision Analog Temperature Sensor LMT70(A)
+
+    """
+    temperature_unit: Temperature = Temperature.CELSIUS
+
+    # look up table from datasheet
+    # first column: temperature in degree celsius
+    # second column: voltage in volt
+    # https://www.ti.com/lit/ds/symlink/lmt70a.pdf?ts=1631590373860
+    LUT: typing.ClassVar[npt.NDArray] = np.array(
+        [
+            [-55., 1.375219],
+            [-50., 1.350441],
+            [-40., 1.300593],
+            [-30., 1.250398],
+            [-20., 1.199884],
+            [-10., 1.14907],
+            [0., 1.097987],
+            [10., 1.046647],
+            [20., 0.99505],
+            [30., 0.943227],
+            [40., 0.891178],
+            [50., 0.838882],
+            [60., 0.78636],
+            [70., 0.733608],
+            [80., 0.680654],
+            [90., 0.62749],
+            [100., 0.574117],
+            [110., 0.520551],
+            [120., 0.46676],
+            [130., 0.412739],
+            [140., 0.358164],
+            [150., 0.302785]
+        ]
+    )
+
+    def __setattr__(self, name, value):
+        super().__setattr__(name, value)
+        if name == 'temperature_unit':
+            Temperature(value)
+        self.__dict__[name] = value
+
+    @preserve_type
+    def convert(self, value: ConvertableTypes) -> ConvertableTypes:
+        """
+        NaN is returned for values that are not covered by the look up table
+        :param value: output voltage of the sensor.
+        :raise TypeError: for non convertable data types
+        :return: measured temperature (default °C)
+        """
+        # cast necessary because of wrapper, which changes the type of value
+        value = typing.cast(npt.NDArray, value)
+        try:
+            validate_number(
+                "value", value, (self.LUT[-1, 1], self.LUT[0, 1]), logger=logger
+            )
+        except ValueError:
+            mask = np.any([value < self.LUT[-1, 1], value > self.LUT[0, 1]], axis=0)
+            value[mask] = np.NaN
+        logging.info(
+            "Use linear interpolation of lookup table provided in datasheet"
+        )
+        value = np.interp(value, self.LUT[::-1, 1], self.LUT[::-1, 0])
+        return Temperature.convert(
+            value, source=Temperature.CELSIUS, target=self.temperature_unit
+        )
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/utils/conversion_unit.py` & `hvl_ccb-0.9.0/hvl_ccb/utils/conversion_unit.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,163 +1,163 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-
-"""
-Unit conversion, within in the same group of units, for example Kelvin <-> Celsius
-"""
-
-from __future__ import annotations
-
-import logging
-from abc import abstractmethod
-from enum import Enum
-from typing import Union
-
-import numpy as np
-
-from hvl_ccb.utils.typing import ConvertableTypes
-from hvl_ccb.utils.validation import validate_number
-
-logger = logging.getLogger(__name__)
-
-
-def preserve_type(func):
-    """
-    This wrapper preserves the first order type of the input.
-    Upto now the type of the data stored in a list, tuple, array or dict
-    is not preserved.
-    Integer will be converted to float!
-    """
-
-    def wrap(self, value, **kwargs):
-        data_type = type(value)
-        validate_number("value", value, (-np.inf, np.inf), logger=logger)
-
-        if data_type == dict:
-            keys = list(value.keys())
-            value = list(value.values())
-
-        value_func = np.asarray(value, dtype=float)
-
-        value_func = func(self, value_func, **kwargs)
-
-        if data_type == list:
-            value = list(value_func)
-        elif isinstance(value, tuple) and hasattr(value, '_fields'):
-            value = data_type(*value_func)
-        elif data_type == tuple:
-            value = tuple(value_func)
-        elif data_type in (int, float):
-            value = float(value_func)
-        elif data_type == dict:
-            value = dict(zip(keys, list(value_func)))
-        else:
-            value = value_func
-        return value
-
-    return wrap
-
-
-class Unit(Enum):
-
-    @classmethod
-    @abstractmethod
-    @preserve_type
-    def convert(cls, value: ConvertableTypes, source, target) -> ConvertableTypes:
-        pass
-
-
-class Temperature(Unit):
-    K = 'K'
-    C = 'C'
-    F = 'F'
-    KELVIN = K
-    CELSIUS = C
-    FAHRENHEIT = F
-
-    @classmethod
-    @preserve_type
-    def convert(
-        cls,
-        value: ConvertableTypes,
-        source: Union[str, Temperature] = KELVIN,
-        target: Union[str, Temperature] = CELSIUS
-    ) -> ConvertableTypes:
-        try:
-            source = Temperature(source)
-            target = Temperature(target)
-        except ValueError:
-            logger.warning(
-                "One unit or both units for source and / or target temperature "
-                "are not valid.")
-            raise ValueError
-        if source == target:
-            return value
-
-        # convert source to kelvin
-        if source == cls.CELSIUS:
-            value = value + 273.15  # type: ignore
-        elif source == cls.FAHRENHEIT:
-            value = (value - 32) / 1.8 + 273.15  # type: ignore
-
-        # convert kelvin to target
-        if target == cls.CELSIUS:
-            value = value - 273.15  # type: ignore
-        elif target == cls.FAHRENHEIT:
-            value = (value - 273.15) * 1.8 + 32  # type: ignore
-        return value
-
-
-class Pressure(Unit):
-    PA = 'Pa'
-    BAR = 'bar'
-    ATM = 'atm'
-    PSI = 'psi'
-    MMHG = 'mmHg'
-    TORR = 'torr'
-    PASCAL = PA
-    ATMOSPHERE = ATM
-    POUNDS_PER_SQUARE_INCH = PSI
-    MILLIMETER_MERCURY = MMHG
-
-    @classmethod
-    @preserve_type
-    def convert(
-        cls,
-        value: ConvertableTypes,
-        source: Union[str, Pressure] = BAR,
-        target: Union[str, Pressure] = PASCAL
-    ) -> ConvertableTypes:
-        try:
-            source = Pressure(source)
-            target = Pressure(target)
-        except ValueError:
-            logger.warning(
-                "One unit or both units for source and / or target pressure "
-                "are not valid.")
-            raise ValueError
-        if source == target:
-            return value
-        # convert source to Pascal
-        if source == cls.BAR:
-            value = value * 1e5  # type: ignore
-        elif source == cls.ATMOSPHERE:
-            value = value * 101_325  # type: ignore
-        elif source == cls.TORR:
-            value = value * 101_325 / 760  # type: ignore
-        elif source == cls.MMHG:
-            value = value * 101_325 / 760 * 1.000_000_142_466  # type: ignore
-        elif source == cls.PSI:
-            value = value * 6_894.75728  # type: ignore
-
-        # convert from Pascal to target
-        if target == cls.BAR:
-            value = value / 1e5  # type: ignore
-        elif target == cls.ATMOSPHERE:
-            value = value / 101_325  # type: ignore
-        elif target == cls.TORR:
-            value = value / 101_325 * 760  # type: ignore
-        elif target == cls.MMHG:
-            value = value / 101_325 * 760 / 1.000_000_142_466  # type: ignore
-        elif target == cls.PSI:
-            value = value / 6_894.75728  # type: ignore
-        return value
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+
+"""
+Unit conversion, within in the same group of units, for example Kelvin <-> Celsius
+"""
+
+from __future__ import annotations
+
+import logging
+from abc import abstractmethod
+from enum import Enum
+from typing import Union
+
+import numpy as np
+
+from hvl_ccb.utils.typing import ConvertableTypes
+from hvl_ccb.utils.validation import validate_number
+
+logger = logging.getLogger(__name__)
+
+
+def preserve_type(func):
+    """
+    This wrapper preserves the first order type of the input.
+    Upto now the type of the data stored in a list, tuple, array or dict
+    is not preserved.
+    Integer will be converted to float!
+    """
+
+    def wrap(self, value, **kwargs):
+        data_type = type(value)
+        validate_number("value", value, (-np.inf, np.inf), logger=logger)
+
+        if data_type == dict:
+            keys = list(value.keys())
+            value = list(value.values())
+
+        value_func = np.asarray(value, dtype=float)
+
+        value_func = func(self, value_func, **kwargs)
+
+        if data_type == list:
+            value = list(value_func)
+        elif isinstance(value, tuple) and hasattr(value, '_fields'):
+            value = data_type(*value_func)
+        elif data_type == tuple:
+            value = tuple(value_func)
+        elif data_type in (int, float):
+            value = float(value_func)
+        elif data_type == dict:
+            value = dict(zip(keys, list(value_func)))
+        else:
+            value = value_func
+        return value
+
+    return wrap
+
+
+class Unit(Enum):
+
+    @classmethod
+    @abstractmethod
+    @preserve_type
+    def convert(cls, value: ConvertableTypes, source, target) -> ConvertableTypes:
+        pass
+
+
+class Temperature(Unit):
+    K = 'K'
+    C = 'C'
+    F = 'F'
+    KELVIN = K
+    CELSIUS = C
+    FAHRENHEIT = F
+
+    @classmethod
+    @preserve_type
+    def convert(
+        cls,
+        value: ConvertableTypes,
+        source: Union[str, Temperature] = KELVIN,
+        target: Union[str, Temperature] = CELSIUS
+    ) -> ConvertableTypes:
+        try:
+            source = Temperature(source)
+            target = Temperature(target)
+        except ValueError:
+            logger.warning(
+                "One unit or both units for source and / or target temperature "
+                "are not valid.")
+            raise ValueError
+        if source == target:
+            return value
+
+        # convert source to kelvin
+        if source == cls.CELSIUS:
+            value = value + 273.15  # type: ignore
+        elif source == cls.FAHRENHEIT:
+            value = (value - 32) / 1.8 + 273.15  # type: ignore
+
+        # convert kelvin to target
+        if target == cls.CELSIUS:
+            value = value - 273.15  # type: ignore
+        elif target == cls.FAHRENHEIT:
+            value = (value - 273.15) * 1.8 + 32  # type: ignore
+        return value
+
+
+class Pressure(Unit):
+    PA = 'Pa'
+    BAR = 'bar'
+    ATM = 'atm'
+    PSI = 'psi'
+    MMHG = 'mmHg'
+    TORR = 'torr'
+    PASCAL = PA
+    ATMOSPHERE = ATM
+    POUNDS_PER_SQUARE_INCH = PSI
+    MILLIMETER_MERCURY = MMHG
+
+    @classmethod
+    @preserve_type
+    def convert(
+        cls,
+        value: ConvertableTypes,
+        source: Union[str, Pressure] = BAR,
+        target: Union[str, Pressure] = PASCAL
+    ) -> ConvertableTypes:
+        try:
+            source = Pressure(source)
+            target = Pressure(target)
+        except ValueError:
+            logger.warning(
+                "One unit or both units for source and / or target pressure "
+                "are not valid.")
+            raise ValueError
+        if source == target:
+            return value
+        # convert source to Pascal
+        if source == cls.BAR:
+            value = value * 1e5  # type: ignore
+        elif source == cls.ATMOSPHERE:
+            value = value * 101_325  # type: ignore
+        elif source == cls.TORR:
+            value = value * 101_325 / 760  # type: ignore
+        elif source == cls.MMHG:
+            value = value * 101_325 / 760 * 1.000_000_142_466  # type: ignore
+        elif source == cls.PSI:
+            value = value * 6_894.75728  # type: ignore
+
+        # convert from Pascal to target
+        if target == cls.BAR:
+            value = value / 1e5  # type: ignore
+        elif target == cls.ATMOSPHERE:
+            value = value / 101_325  # type: ignore
+        elif target == cls.TORR:
+            value = value / 101_325 * 760  # type: ignore
+        elif target == cls.MMHG:
+            value = value / 101_325 * 760 / 1.000_000_142_466  # type: ignore
+        elif target == cls.PSI:
+            value = value / 6_894.75728  # type: ignore
+        return value
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb/utils/enum.py` & `hvl_ccb-0.9.0/hvl_ccb/utils/enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,71 +1,71 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-
-import logging
-import aenum
-
-logger = logging.getLogger(__name__)
-
-
-# Use abstract base class instead of Mixin to inherit from `aenum.Enum` to make Sphinx
-# detect inheritance correctly and create docs for derived enums, including such as
-# these in `dev.supercube.constants`. With Mixin approach, module-level enum classes
-# are not documented.
-class StrEnumBase(aenum.Enum):
-    """
-    String representation-based equality and lookup.
-    """
-
-    def __eq__(self, other):
-        return (self is other) or (other.__eq__(str(self)))
-
-    # use only with aenum enums
-    @classmethod
-    def _missing_value_(cls, value):
-        for member in cls:
-            if member == value:
-                return member
-
-    def __str__(self):
-        raise NotImplementedError
-
-    def __hash__(self):
-        return hash(str(self))
-
-
-unique = aenum.unique
-
-
-class ValueEnum(StrEnumBase):
-    """
-    Enum with string representation of values used as string representation, and with
-    lookup and equality based on this representation.
-
-    Attention: to avoid errors, best use together with `unique` enum decorator.
-    """
-
-    def __str__(self):
-        return str(self.value)
-
-
-class NameEnum(StrEnumBase):
-    """
-    Enum with names used as string representation, and with lookup and equality based on
-    this representation.
-    """
-
-    # convenience: enables `[]` name-based lookup with enum instances themselves
-    def __hash__(self):
-        return hash(str(self))
-
-    def __str__(self):
-        return self.name
-
-
-class AutoNumberNameEnum(NameEnum, aenum.AutoNumberEnum):
-    """
-    Auto-numbered enum with names used as string representation, and with lookup and
-    equality based on this representation.
-    """
-
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+
+import logging
+import aenum
+
+logger = logging.getLogger(__name__)
+
+
+# Use abstract base class instead of Mixin to inherit from `aenum.Enum` to make Sphinx
+# detect inheritance correctly and create docs for derived enums, including such as
+# these in `dev.supercube.constants`. With Mixin approach, module-level enum classes
+# are not documented.
+class StrEnumBase(aenum.Enum):
+    """
+    String representation-based equality and lookup.
+    """
+
+    def __eq__(self, other):
+        return (self is other) or (other.__eq__(str(self)))
+
+    # use only with aenum enums
+    @classmethod
+    def _missing_value_(cls, value):
+        for member in cls:
+            if member == value:
+                return member
+
+    def __str__(self):
+        raise NotImplementedError
+
+    def __hash__(self):
+        return hash(str(self))
+
+
+unique = aenum.unique
+
+
+class ValueEnum(StrEnumBase):
+    """
+    Enum with string representation of values used as string representation, and with
+    lookup and equality based on this representation.
+
+    Attention: to avoid errors, best use together with `unique` enum decorator.
+    """
+
+    def __str__(self):
+        return str(self.value)
+
+
+class NameEnum(StrEnumBase):
+    """
+    Enum with names used as string representation, and with lookup and equality based on
+    this representation.
+    """
+
+    # convenience: enables `[]` name-based lookup with enum instances themselves
+    def __hash__(self):
+        return hash(str(self))
+
+    def __str__(self):
+        return self.name
+
+
+class AutoNumberNameEnum(NameEnum, aenum.AutoNumberEnum):
+    """
+    Auto-numbered enum with names used as string representation, and with lookup and
+    equality based on this representation.
+    """
+
+    pass
```

### Comparing `hvl_ccb-0.8.5/hvl_ccb.egg-info/PKG-INFO` & `hvl_ccb-0.9.0/hvl_ccb.egg-info/PKG-INFO`

 * *Files 20% similar despite different names*

```diff
@@ -1,559 +1,604 @@
-Metadata-Version: 2.1
-Name: hvl-ccb
-Version: 0.8.5
-Summary: Python common code base to control devices high voltage research devices, in particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
-Home-page: https://gitlab.com/ethz_hvl/hvl_ccb/
-Author: ('Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, David Taylor',)
-Author-email: mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch
-License: GNU General Public License v3
-Description: ====================
-        HVL Common Code Base
-        ====================
-        
-        .. image:: https://img.shields.io/pypi/v/hvl_ccb?logo=PyPi
-           :target: https://pypi.org/project/hvl_ccb/
-           :alt: PyPI version
-        
-        .. image:: https://img.shields.io/pypi/pyversions/hvl_ccb?logo=Python
-           :target: https://pypi.org/project/hvl_ccb/
-           :alt: Supported Python versions
-        
-        .. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/master?logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/master
-            :alt: Pipeline status
-        
-        .. image:: https://img.shields.io/gitlab/coverage/ethz_hvl/hvl_ccb/master?logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/commits/master
-            :alt: Coverage report
-        
-        .. image:: https://img.shields.io/readthedocs/hvl_ccb?logo=read-the-docs
-            :target: https://hvl-ccb.readthedocs.io/en/stable/
-            :alt: Documentation Status
-        
-        .. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/devel?label=devel&logo=gitlab
-            :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/devel
-            :alt: Development pipeline status
-        
-        Python common code base to control devices high voltage research devices, in
-        particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH.
-        
-        
-        * Free software: GNU General Public License v3
-        * Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-        
-        
-        Features
-        --------
-        
-        For managing multi-device experiments instantiate the :code:`ExperimentManager`
-        utility class.
-        
-        Devices
-        ~~~~~~~
-        
-        The devices wrappers in :code:`hvl_ccb` provide a standardised API with configuration
-        dataclasses, various settings and options enumerations, as well as start/stop methods.
-        Currently, wrappers to control the following devices are available:
-        
-        +-------------------------+------------------------------------------------------------+
-        | Function/Type           | Devices                                                    |
-        +=========================+============================================================+
-        | Data acquisition        | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
-        |                         | | Pico Technology PT-104 Platinum Resistance Data Logger   |
-        |                         |   (requires `PicoSDK`_/`libusbpt104`_)                     |
-        +-------------------------+------------------------------------------------------------+
-        | Digital IO              | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
-        +-------------------------+------------------------------------------------------------+
-        | Experiment control      | | HVL Supercube with and without Frequency Converter       |
-        +-------------------------+------------------------------------------------------------+
-        | Gas Analyser            | | MBW 973-SF6 gas dew point mirror analyzer                |
-        |                         | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for    |
-        |                         |   compact pressure gauges                                  |
-        |                         | | SST Luminox oxygen sensor                                |
-        +-------------------------+------------------------------------------------------------+
-        | I2C host                | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
-        +-------------------------+------------------------------------------------------------+
-        | Laser                   | | CryLaS pulsed laser                                      |
-        |                         | | CryLaS laser attenuator                                  |
-        +-------------------------+------------------------------------------------------------+
-        | Oscilloscope            | | Rhode & Schwarz RTO 1024                                 |
-        |                         | | TiePie (HS5, HS6, WS5; requries `LibTiePie SDK`_)        |
-        +-------------------------+------------------------------------------------------------+
-        | Power supply            | | Elektro-Automatik PSI9000                                |
-        |                         | | FuG Elektronik                                           |
-        |                         | | Heinzinger PNC                                           |
-        |                         | | Technix capacitor charger                                |
-        +-------------------------+------------------------------------------------------------+
-        | Stepper motor drive     | | Newport SMC100PP                                         |
-        |                         | | Schneider Electric ILS2T                                 |
-        +-------------------------+------------------------------------------------------------+
-        | Temperature control     | | Lauda PRO RP 245 E circulation thermostat                |
-        +-------------------------+------------------------------------------------------------+
-        | Waveform generator      | | TiePie (HS5, WS5; requries `LibTiePie SDK`_)             |
-        +-------------------------+------------------------------------------------------------+
-        
-        Each device uses at least one standardised communication protocol wrapper.
-        
-        Communication protocols
-        ~~~~~~~~~~~~~~~~~~~~~~~
-        
-        In :code:`hvl_ccb` by "communication protocol" we mean different levels of
-        communication standards, from the low level actual communication protocols like
-        serial communication to application level interfaces like VISA TCP standard. There
-        are also devices in :code:`hvl_ccb` that use dummy communication protocol concept;
-        this is because these devices build on propriety vendor libraries that communicate
-        with vendor devices, like in case of the TiePie devices.
-        
-        The communication protocol wrappers in :code:`hvl_ccb` provide a standardised API with
-        configuration dataclasses, as well as open/close, and read/write/query methods.
-        Currently, wrappers to use the following communication protocols are available:
-        
-        +------------------------+-------------------------------------------------------------+
-        | Communication protocol | Devices using                                               |
-        +========================+=============================================================+
-        | Modbus TCP             | | Schneider Electric ILS2T stepper motor drive              |
-        +------------------------+-------------------------------------------------------------+
-        | OPC UA                 | | HVL Supercube with and without Frequency Converter        |
-        +------------------------+-------------------------------------------------------------+
-        | Serial                 | | CryLaS pulsed laser and laser attenuator                  |
-        |                        | | FuG Elektronik power supply (e.g. capacitor charger HCK)  |
-        |                        |   using the Probus V protocol                               |
-        |                        | | Heinzinger PNC power supply                               |
-        |                        |   using Heinzinger Digital Interface I/II                   |
-        |                        | | SST Luminox oxygen sensor                                 |
-        |                        | | MBW 973-SF6 gas dew point mirror analyzer                 |
-        |                        | | Newport SMC100PP single axis driver for 2-phase stepper   |
-        |                        |   motors                                                    |
-        |                        | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for     |
-        |                        |   compact pressure gauges                                   |
-        |                        | | Technix capacitor charger                                 |
-        +------------------------+-------------------------------------------------------------+
-        | TCP                    | | Lauda PRO RP 245 E circulation thermostat                 |
-        +------------------------+-------------------------------------------------------------+
-        | Telnet                 | | Technix capacitor charger                                 |
-        +------------------------+-------------------------------------------------------------+
-        | VISA TCP               | | Elektro-Automatik PSI9000 DC power supply                 |
-        |                        | | Rhode & Schwarz RTO 1024 oscilloscope                     |
-        +------------------------+-------------------------------------------------------------+
-        | *propriety*            | | LabJack (T4, T7, T7-PRO) devices, which communicate via   |
-        |                        |   `LJM Library`_                                            |
-        |                        | | Pico Technology PT-104 Platinum Resistance Data Logger,   |
-        |                        |   which communicate via `PicoSDK`_/`libusbpt104`_           |
-        |                        | | TiePie (HS5, HS6, WS5) oscilloscopes, generators and I2C  |
-        |                        |   hosts, which communicate via `LibTiePie SDK`_             |
-        +------------------------+-------------------------------------------------------------+
-        
-        .. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
-        .. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
-        .. _`LJM Library`: https://labjack.com/ljm
-        .. _`PicoSDK`: https://www.picotech.com/downloads
-        
-        Documentation
-        -------------
-        
-        Note: if you're planning to contribute to the :code:`hvl_ccb` project do read
-        beforehand the **Contributing** section in the HVL CCB documentation.
-        
-        Do either:
-        
-        * read `HVL CCB documentation at RTD`_,
-        
-        or
-        
-        * build and read HVL CCB documentation locally; install first `Graphviz`_ (make sure
-          to have the :code:`dot` command in the executable search path) and the Python
-          build requirements for documentation::
-        
-            $ pip install docs/requirements.txt
-        
-          and then either on Windows in Git BASH run::
-        
-            $ ./make.sh docs
-        
-          or from any other shell with GNU Make installed run::
-        
-            $ make docs
-        
-          The target index HTML (:code:`"docs/_build/html/index.html"`) should open
-          automatically in your Web browser.
-        
-        .. _`Graphviz`: https://graphviz.org/
-        .. _`HVL CCB documentation at RTD`: https://readthedocs.org/projects/hvl-ccb/
-        
-        Credits
-        -------
-        
-        This package was created with Cookiecutter_ and the
-        `audreyr/cookiecutter-pypackage`_ project template.
-        
-        .. _Cookiecutter: https://github.com/audreyr/cookiecutter
-        .. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage
-        
-        
-        ============
-        Installation
-        ============
-        
-        
-        Stable release
-        --------------
-        
-        To install HVL Common Code Base, run this command in your terminal:
-        
-        .. code-block:: console
-        
-            $ pip install hvl_ccb
-        
-        To install HVL Common Code Base with optional Python libraries that require manual
-        installations of additional system libraries, you need to specify on installation
-        extra requirements corresponding to these controllers. For instance, to install
-        Python requirements for LabJack and TiePie devices, run:
-        
-        .. code-block:: console
-        
-            $ pip install "hvl_ccb[tiepie,labjack]"
-        
-        See below for the info about additional system libraries and the corresponding extra
-        requirements.
-        
-        To install all extra requirements run:
-        
-        .. code-block:: console
-        
-            $ pip install "hvl_ccb[all]"
-        
-        This is the preferred method to install HVL Common Code Base, as it will always install
-        the most recent stable release.
-        
-        If you don't have `pip`_ installed, this `Python installation guide`_ can guide
-        you through the process.
-        
-        .. _pip: https://pip.pypa.io
-        .. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
-        
-        
-        From sources
-        ------------
-        
-        The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
-        
-        You can either clone the repository:
-        
-        .. code-block:: console
-        
-            $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
-        
-        Or download the `tarball`_:
-        
-        .. code-block:: console
-        
-            $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-        
-        Once you have a copy of the source, you can install it with:
-        
-        .. code-block:: console
-        
-            $ pip install .
-        
-        
-        .. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
-        .. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
-        
-        
-        Additional system libraries
-        ---------------------------
-        
-        If you have installed `hvl_ccb` with any of the extra features corresponding to
-        device controllers, you must additionally install respective system library; these are:
-        
-        +-------------------------+------------------------------------------------------------+
-        | Extra feature           | Additional system library                                  |
-        +=========================+============================================================+
-        | :code:`labjack`         | `LJM Library`_                                             |
-        +-------------------------+------------------------------------------------------------+
-        | :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
-        +-------------------------+------------------------------------------------------------+
-        | :code:`tiepie`          | `LibTiePie SDK`_                                           |
-        +-------------------------+------------------------------------------------------------+
-        
-        For more details on installation of the libraries see docstrings of the corresponding
-        :code:`hvl_ccb` modules.
-        
-        .. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
-        .. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
-        .. _`LJM Library`: https://labjack.com/ljm
-        .. _`PicoSDK`: https://www.picotech.com/downloads
-        
-        
-        =======
-        History
-        =======
-        
-        0.8.5 (2021-11-05)
-        ------------------
-        
-        * Added arbitrary waveform for TiePie signal generation, configurable via
-          :code:`dev.tiepie.generator.TiePieGeneratorConfig.waveform` property.
-        * In :code:`utils.conversion_sensor`: improvements for class constants; removed SciPy
-          dependency.
-        * Added Python 3.10 support.
-        
-        0.8.4 (2021-10-22)
-        ------------------
-        
-        * :code:`utils.validation.validate_number` extension to handle NumPy arrays and
-          array-like objects.
-        * :code:`utils.conversion_unit` utility classes handle correctly :code:`NamedTuple`
-          instances.
-        * :code:`utils.conversion_sensor` and :code:`utils.conversion_unit` code
-          simplification (no :code:`transfer_function_order` attribute) and cleanups.
-        * Fixed incorrect error logging in :code:`configuration.configdataclass`.
-        * :code:`comm.telnet.TelnetCommunication` tests fixes for local run errors.
-        
-        0.8.3 (2021-09-27)
-        ------------------
-        
-        * New data conversion functions in :code:`utils.conversion_sensor` and
-          :code:`utils.conversion_unit` modules. Note: to use these functions you must install
-          :code:`hvl_ccb` with extra requirement, either :code:`hvl_ccb[conversion]` or
-          :code:`hvl_ccb[all]`.
-        * Improved documentation with respect to installation of external libraries.
-        
-        0.8.2 (2021-08-27)
-        ------------------
-        
-        * New functionality in :code:`dev.labjack.LabJack`:
-            * configure clock and send timed pulse sequences
-            * set DAC/analog output voltage
-        * Bugfix: ignore random bits sent by to :code:`dev.newport.NewportSMC100PP`
-          controller during start-up/powering-up.
-        
-        0.8.1 (2021-08-13)
-        ------------------
-        
-        * Add Python version check (min version error; max version warning).
-        * Daily checks for upstream dependencies compatibility and devel environment
-          improvements.
-        
-        0.8.0 (2021-07-02)
-        ------------------
-        
-        * TCP communication protocol.
-        * Lauda PRO RP 245 E circulation thermostat device over TCP.
-        * Pico Technology PT-104 Platinum Resistance Data Logger device as a wrapper of the
-          Python bindings for the PicoSDK.
-        * In :code:`com.visa.VisaCommunication`: periodic status polling when VISA/TCP keep
-          alive connection is not supported by a host.
-        
-        0.7.1 (2021-06-04)
-        ------------------
-        
-        * New :code:`utils.validation` submodule with :code:`validate_bool` and
-          :code:`validate_number` utilities extracted from internal use within a
-          :code:`dev.tiepie` subpackage.
-        * In :code:`comm.serial.SerialCommunication`:
-             * strict encoding errors handling strategy for subclasses,
-             * user warning for a low communication timeout value.
-        
-        0.7.0 (2021-05-25)
-        ------------------
-        
-        * The :code:`dev.tiepie` module was splitted into a subpackage with, in particular,
-          submodules for each of the device types -- :code:`oscilloscope`, :code:`generator`,
-          and :code:`i2c` -- and with backward-incompatible direct imports from the submodules.
-        * In :code:`dev.technix`:
-              * fixed communication crash on nested status byte query;
-              * added enums for GET and SET register commands.
-        * Further minor logging improvements: added missing module level logger and removed some
-          error logs in :code:`except` blocks used for a flow control.
-        * In :code:`examples/` folder renamed consistently all the examples.
-        * In API documentation: fix incorrect links mapping on inheritance diagrams.
-        
-        0.6.1 (2021-05-08)
-        ------------------
-        
-        * In :code:`dev.tiepie`:
-              * dynamically set oscilloscope's channel limits in
-                :code:`OscilloscopeChannelParameterLimits`: :code:`input_range` and
-                :code:`trigger_level_abs`, incl. update of latter on each change of
-                :code:`input_range` value of a :code:`TiePieOscilloscopeChannelConfig`
-                instances;
-              * quick fix for opening of combined instruments by disabling
-                :code:`OscilloscopeParameterLimits.trigger_delay` (an advanced feature);
-              * enable automatic devices detection to be able to find network devices with
-                :code:`TiePieOscilloscope.list_devices()`.
-        * Fix :code:`examples/example_labjack.py`.
-        * Improved logging: consistently use module level loggers, and always log exception
-          tracebacks.
-        * Improve API documentation: separate pages per modules, each with an inheritance
-          diagram as an overview.
-        
-        0.6.0 (2021-04-23)
-        ------------------
-        
-        * Technix capacitor charger using either serial connection or Telnet protocol.
-        * Extensions, improvements and fixes in existing devices:
-           * In :code:`dev.tiepie.TiePieOscilloscope`:
-               * redesigned measurement start and data collection API, incl. time out
-                 argument, with no/infinite time out option;
-               * trigger allows now a no/infinite time out;
-               * record length and trigger level were fixed to accept, respectively, floating
-                 point and integer numbers;
-               * fixed resolution validation bug;
-           * :code:`dev.heinzinger.HeinzingerDI` and `dev.rs_rto1024.RTO1024` instances are now
-             resilient to multiple :code:`stop()` calls.
-           * In :code:`dev.crylas.CryLasLaser`: default configuration timeout and
-             polling period were adjusted;
-           * Fixed PSI9080 example script.
-        * Package and source code improvements:
-           * Update to backward-incompatible :code:`pyvisa-py>=0.5.2`. Developers, do update
-             your local development environments!
-           * External libraries, like LibTiePie SDK or LJM Library, are now not installed by
-             default; they are now extra installation options.
-           * Added Python 3.9 support.
-           * Improved number formatting in logs.
-           * Typing improvements and fixes for :code:`mypy>=0.800`.
-        
-        0.5.0 (2020-11-11)
-        ------------------
-        
-        * TiePie USB oscilloscope, generator and I2C host devices, as a wrapper of the Python
-          bindings for the LibTiePie SDK.
-        * a FuG Elektronik Power Supply (e.g. Capacitor Charger HCK) using the built-in ADDAT
-          controller with the Probus V protocol over a serial connection
-        * All devices poling status or measurements use now a :code:`dev.utils.Poller` utility
-          class.
-        * Extensions and improvements in existing devices:
-            * In :code:`dev.rs_rto1024.RTO1024`: added Channel state, scale, range,
-              position and offset accessors, and measurements activation and read methods.
-            * In :code:`dev.sst_luminox.Luminox`: added querying for all measurements
-              in polling mode, and made output mode activation more robust.
-            * In :code:`dev.newport.NewportSMC100PP`: an error-prone
-              :code:`wait_until_move_finished` method of replaced by a fixed waiting time,
-              device operations are now robust to a power supply cut, and device restart is not
-              required to apply a start configuration.
-        * Other minor improvements:
-            * Single failure-safe starting and stopping of devices sequenced via
-              :code:`dev.base.DeviceSequenceMixin`.
-            * Moved :code:`read_text_nonempty` up to :code:`comm.serial.SerialCommunication`.
-            * Added development Dockerfile.
-            * Updated package and development dependencies: :code:`pymodbus`,
-              :code:`pytest-mock`.
-        
-        0.4.0 (2020-07-16)
-        ------------------
-        
-        * Significantly improved new Supercube device controller:
-            - more robust error-handling,
-            - status polling with generic :code:`Poller` helper,
-            - messages and status boards.
-            - tested with a physical device,
-        * Improved OPC UA client wrapper, with better error handling, incl. re-tries on
-          :code:`concurrent.futures.TimeoutError`.
-        * SST Luminox Oxygen sensor device controller.
-        * Backward-incompatible changes:
-            - :code:`CommunicationProtocol.access_lock` has changed type from
-              :code:`threading.Lock` to :code:`threading.RLock`.
-            - :code:`ILS2T.relative_step` and :code:`ILS2T.absolute_position` are now called,
-              respectively, :code:`ILS2T.write_relative_step` and
-              :code:`ILS2T.write_absolute_position`.
-        * Minor bugfixes and improvements:
-            - fix use of max resolution in :code:`Labjack.set_ain_resolution()`,
-            - resolve ILS2T devices relative and absolute position setters race condition,
-            - added acoustic horn function in the 2015 Supercube.
-        * Toolchain changes:
-            - add Python 3.8 support,
-            - drop pytest-runner support,
-            - ensure compatibility with :code:`labjack_ljm` 2019 version library.
-        
-        0.3.5 (2020-02-18)
-        ------------------
-        
-        * Fix issue with reading integers from LabJack LJM Library (device's product ID, serial
-          number etc.)
-        * Fix development requirements specification (tox version).
-        
-        0.3.4 (2019-12-20)
-        ------------------
-        
-        * New devices using serial connection:
-            * Heinzinger Digital Interface I/II and a Heinzinger PNC power supply
-            * Q-switched Pulsed Laser and a laser attenuator from CryLas
-            * Newport SMC100PP single axis motion controller for 2-phase stepper motors
-            * Pfeiffer TPG controller (TPG 25x, TPG 26x and TPG 36x) for Compact pressure Gauges
-        * PEP 561 compatibility and related corrections for static type checking (now in CI)
-        * Refactorings:
-            * Protected non-thread safe read and write in communication protocols
-            * Device sequence mixin: start/stop, add/rm and lookup
-            * `.format()` to f-strings
-            * more enumerations and a quite some improvements of existing code
-        * Improved error docstrings (:code:`:raises:` annotations) and extended tests for
-          errors.
-        
-        0.3.3 (2019-05-08)
-        ------------------
-        
-        * Use PyPI labjack-ljm (no external dependencies)
-        
-        
-        0.3.2 (2019-05-08)
-        ------------------
-        
-        * INSTALLATION.rst with LJMPython prerequisite info
-        
-        
-        0.3.1 (2019-05-02)
-        ------------------
-        
-        * readthedocs.org support
-        
-        0.3 (2019-05-02)
-        ----------------
-        
-        * Prevent an automatic close of VISA connection when not used.
-        * Rhode & Schwarz RTO 1024 oscilloscope using VISA interface over TCP::INSTR.
-        * Extended tests incl. messages sent to devices.
-        * Added Supercube device using an OPC UA client
-        * Added Supercube 2015 device using an OPC UA client (for interfacing with old system
-          version)
-        
-        0.2.1 (2019-04-01)
-        ------------------
-        
-        * Fix issue with LJMPython not being installed automatically with setuptools.
-        
-        0.2.0 (2019-03-31)
-        ------------------
-        
-        * LabJack LJM Library communication wrapper and LabJack device.
-        * Modbus TCP communication protocol.
-        * Schneider Electric ILS2T stepper motor drive device.
-        * Elektro-Automatik PSI9000 current source device and VISA communication wrapper.
-        * Separate configuration classes for communication protocols and devices.
-        * Simple experiment manager class.
-        
-        0.1.0 (2019-02-06)
-        ------------------
-        
-        * Communication protocol base and serial communication implementation.
-        * Device base and MBW973 implementation.
-        
-Keywords: hvl_ccb
-Platform: UNKNOWN
-Classifier: Development Status :: 4 - Beta
-Classifier: Intended Audience :: Developers
-Classifier: Intended Audience :: Education
-Classifier: Intended Audience :: Science/Research
-Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
-Classifier: Natural Language :: English
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Requires-Python: >=3.7
-Description-Content-Type: text/x-rst
-Provides-Extra: all
-Provides-Extra: tiepie
-Provides-Extra: labjack
-Provides-Extra: picotech
+Metadata-Version: 2.1
+Name: hvl-ccb
+Version: 0.9.0
+Summary: Python common code base to control devices high voltage research devices, in particular, as used in Christian Franck's High Voltage Lab (HVL), D-ITET, ETH
+Home-page: https://gitlab.com/ethz_hvl/hvl_ccb/
+Author: ('Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, Henning Janssen, David Taylor',)
+Author-email: mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch
+License: GNU General Public License v3
+Keywords: hvl_ccb
+Platform: UNKNOWN
+Classifier: Development Status :: 4 - Beta
+Classifier: Intended Audience :: Developers
+Classifier: Intended Audience :: Education
+Classifier: Intended Audience :: Science/Research
+Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+Classifier: Natural Language :: English
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.7
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Requires-Python: >=3.7
+Description-Content-Type: text/x-rst
+Provides-Extra: all
+Provides-Extra: tiepie
+Provides-Extra: labjack
+Provides-Extra: picotech
+License-File: LICENSE
+License-File: AUTHORS.rst
+
+====================
+HVL Common Code Base
+====================
+
+.. image:: https://img.shields.io/pypi/v/hvl_ccb?logo=PyPi
+   :target: https://pypi.org/project/hvl_ccb/
+   :alt: PyPI version
+
+.. image:: https://img.shields.io/pypi/pyversions/hvl_ccb?logo=Python
+   :target: https://pypi.org/project/hvl_ccb/
+   :alt: Supported Python versions
+
+.. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/master?logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/master
+    :alt: Pipeline status
+
+.. image:: https://img.shields.io/gitlab/coverage/ethz_hvl/hvl_ccb/master?logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/commits/master
+    :alt: Coverage report
+
+.. image:: https://img.shields.io/readthedocs/hvl_ccb?logo=read-the-docs
+    :target: https://hvl-ccb.readthedocs.io/en/stable/
+    :alt: Documentation Status
+
+.. image:: https://img.shields.io/gitlab/pipeline/ethz_hvl/hvl_ccb/devel?label=devel&logo=gitlab
+    :target: https://gitlab.com/ethz_hvl/hvl_ccb/-/tree/devel
+    :alt: Development pipeline status
+
+Python common code base (CCB) to control devices, which are used in high-voltage
+research. All implemented devices are used and tested in the High Voltage Laboratory
+(`HVL`_) of the Federal Institute of Technology Zurich (ETH Zurich).
+
+* Free software: GNU General Public License v3
+* Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+
+.. _`HVL`: https://hvl.ee.ethz.ch/
+
+Features
+--------
+
+For managing multi-device experiments instantiate the :code:`ExperimentManager`
+utility class.
+
+Devices
+~~~~~~~
+
+The device wrappers in :code:`hvl_ccb` provide a standardised API with configuration
+dataclasses, various settings and options, as well as start/stop methods.
+Currently wrappers are available to control the following devices:
+
++-------------------------+------------------------------------------------------------+
+| Function/Type           | Devices                                                    |
++=========================+============================================================+
+| Data acquisition        | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
+|                         | | Pico Technology PT-104 Platinum Resistance Data Logger   |
+|                         |   (requires `PicoSDK`_/`libusbpt104`_)                     |
++-------------------------+------------------------------------------------------------+
+| Digital Delay Generator | | Highland T560                                            |
++-------------------------+------------------------------------------------------------+
+| Digital IO              | | LabJack (T4, T7, T7-PRO; requires `LJM Library`_)        |
++-------------------------+------------------------------------------------------------+
+| Experiment control      | | HVL Supercube with and without Frequency Converter       |
++-------------------------+------------------------------------------------------------+
+| Gas Analyser            | | MBW 973-SF6 gas dew point mirror analyzer                |
+|                         | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for    |
+|                         |   compact pressure gauges                                  |
+|                         | | SST Luminox oxygen sensor                                |
++-------------------------+------------------------------------------------------------+
+| I2C host                | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
++-------------------------+------------------------------------------------------------+
+| Laser                   | | CryLaS pulsed laser                                      |
+|                         | | CryLaS laser attenuator                                  |
++-------------------------+------------------------------------------------------------+
+| Oscilloscope            | | Rhode & Schwarz RTO 1024                                 |
+|                         | | TiePie (HS5, HS6, WS5; requires `LibTiePie SDK`_)        |
++-------------------------+------------------------------------------------------------+
+| Power supply            | | Elektro-Automatik PSI9000                                |
+|                         | | FuG Elektronik                                           |
+|                         | | Heinzinger PNC                                           |
+|                         | | Technix capacitor charger                                |
++-------------------------+------------------------------------------------------------+
+| Stepper motor drive     | | Newport SMC100PP                                         |
+|                         | | Schneider Electric ILS2T                                 |
++-------------------------+------------------------------------------------------------+
+| Temperature control     | | Lauda PRO RP 245 E circulation thermostat                |
++-------------------------+------------------------------------------------------------+
+| Waveform generator      | | TiePie (HS5, WS5; requires `LibTiePie SDK`_)             |
++-------------------------+------------------------------------------------------------+
+
+Each device uses at least one standardised communication protocol wrapper.
+
+Communication protocols
+~~~~~~~~~~~~~~~~~~~~~~~
+
+In :code:`hvl_ccb` by "communication protocol" we mean different levels of
+communication standards, from the low level actual communication protocols like
+serial communication to application level interfaces like VISA TCP standard. There
+are also devices in :code:`hvl_ccb` that use a dummy communication protocol;
+this is because these devices are build on proprietary manufacturer libraries that
+communicate with the corresponding devices, as in the case of TiePie or LabJack devices.
+
+The communication protocol wrappers in :code:`hvl_ccb` provide a standardised API with
+configuration dataclasses, as well as open/close and read/write/query methods.
+Currently, wrappers for the following communication protocols are available:
+
++------------------------+-------------------------------------------------------------+
+| Communication protocol | Devices using                                               |
++========================+=============================================================+
+| Modbus TCP             | | Schneider Electric ILS2T stepper motor drive              |
++------------------------+-------------------------------------------------------------+
+| OPC UA                 | | HVL Supercube with and without Frequency Converter        |
++------------------------+-------------------------------------------------------------+
+| Serial                 | | CryLaS pulsed laser and laser attenuator                  |
+|                        | | FuG Elektronik power supply (e.g. capacitor charger HCK)  |
+|                        |   using the Probus V protocol                               |
+|                        | | Heinzinger PNC power supply                               |
+|                        |   using Heinzinger Digital Interface I/II                   |
+|                        | | SST Luminox oxygen sensor                                 |
+|                        | | MBW 973-SF6 gas dew point mirror analyzer                 |
+|                        | | Newport SMC100PP single axis driver for 2-phase stepper   |
+|                        |   motors                                                    |
+|                        | | Pfeiffer Vacuum TPG (25x, 26x and 36x) controller for     |
+|                        |   compact pressure gauges                                   |
+|                        | | Technix capacitor charger                                 |
++------------------------+-------------------------------------------------------------+
+| TCP                    | | Lauda PRO RP 245 E circulation thermostat                 |
++------------------------+-------------------------------------------------------------+
+| Telnet                 | | Technix capacitor charger                                 |
++------------------------+-------------------------------------------------------------+
+| VISA TCP               | | Elektro-Automatik PSI9000 DC power supply                 |
+|                        | | Rhode & Schwarz RTO 1024 oscilloscope                     |
++------------------------+-------------------------------------------------------------+
+| *propriety*            | | LabJack (T4, T7, T7-PRO) devices, which communicate via   |
+|                        |   `LJM Library`_                                            |
+|                        | | Pico Technology PT-104 Platinum Resistance Data Logger,   |
+|                        |   which communicate via `PicoSDK`_/`libusbpt104`_           |
+|                        | | TiePie (HS5, HS6, WS5) oscilloscopes, generators and I2C  |
+|                        |   hosts, which communicate via `LibTiePie SDK`_             |
++------------------------+-------------------------------------------------------------+
+
+.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
+.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
+.. _`LJM Library`: https://labjack.com/ljm
+.. _`PicoSDK`: https://www.picotech.com/downloads
+
+Sensor and Unit Conversion Utility
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+The Sensor and Unit Conversion Utility is a submodule that allows on the one hand a
+unified implementation of hardware-sensors and on the other hand provides a unified
+way to convert units. The utility can be used with single numbers (:code:`int`,
+:code:`float`) as well as array-like structures containing single numbers
+(:code:`np.array()`, :code:`list`, :code:`dict`, :code:`tuple`).
+
+Currently the following sensors are implemented:
+
+- LEM LT 4000S
+- LMT 70A
+
+The following unit conversion classes are implemented:
+
+- Temperature (Kelvin, Celsius, Fahrenheit)
+- Pressure (Pascal, Bar, Atmosphere, Psi, Torr, Millimeter Mercury)
+
+
+Documentation
+-------------
+
+Note: if you're planning to contribute to the :code:`hvl_ccb` project read
+the **Contributing** section in the HVL CCB documentation.
+
+Do either:
+
+* read `HVL CCB documentation at RTD`_,
+
+or
+
+* build and read HVL CCB documentation locally; install first `Graphviz`_ (make sure
+  to have the :code:`dot` command in the executable search path) and the Python
+  build requirements for documentation::
+
+    $ pip install docs/requirements.txt
+
+  and then either on Windows in Git BASH run::
+
+    $ ./make.sh docs
+
+  or from any other shell with GNU Make installed run::
+
+    $ make docs
+
+  The target index HTML (:code:`"docs/_build/html/index.html"`) should open
+  automatically in your Web browser.
+
+.. _`Graphviz`: https://graphviz.org/
+.. _`HVL CCB documentation at RTD`: https://readthedocs.org/projects/hvl-ccb/
+
+Credits
+-------
+
+This package was created with Cookiecutter_ and the
+`audreyr/cookiecutter-pypackage`_ project template.
+
+.. _Cookiecutter: https://github.com/audreyr/cookiecutter
+.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage
+
+
+============
+Installation
+============
+
+
+Stable release
+--------------
+
+To install HVL Common Code Base, run this command in your terminal:
+
+.. code-block:: console
+
+    $ pip install hvl_ccb
+
+To install HVL Common Code Base with optional Python libraries that require manual
+installations of additional system libraries, you need to specify on installation
+extra requirements corresponding to these controllers. For instance, to install
+Python requirements for LabJack and TiePie devices, run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[tiepie,labjack]"
+
+See below for the info about additional system libraries and the corresponding extra
+requirements.
+
+To install all extra requirements run:
+
+.. code-block:: console
+
+    $ pip install "hvl_ccb[all]"
+
+This is the preferred method to install HVL Common Code Base, as it will always install
+the most recent stable release.
+
+If you don't have `pip`_ installed, this `Python installation guide`_ can guide
+you through the process.
+
+.. _pip: https://pip.pypa.io
+.. _Python installation guide: http://docs.python-guide.org/en/latest/starting/installation/
+
+
+From sources
+------------
+
+The sources for HVL Common Code Base can be downloaded from the `GitLab repo`_.
+
+You can either clone the repository:
+
+.. code-block:: console
+
+    $ git clone git@gitlab.com:ethz_hvl/hvl_ccb.git
+
+Or download the `tarball`_:
+
+.. code-block:: console
+
+    $ curl  -OL https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+Once you have a copy of the source, you can install it with:
+
+.. code-block:: console
+
+    $ pip install .
+
+
+.. _GitLab repo: https://gitlab.com/ethz_hvl/hvl_ccb
+.. _tarball: https://gitlab.com/ethz_hvl/hvl_ccb/-/archive/master/hvl_ccb.tar.gz
+
+
+Additional system libraries
+---------------------------
+
+If you have installed `hvl_ccb` with any of the extra features corresponding to
+device controllers, you must additionally install respective system library; these are:
+
++-------------------------+------------------------------------------------------------+
+| Extra feature           | Additional system library                                  |
++=========================+============================================================+
+| :code:`labjack`         | `LJM Library`_                                             |
++-------------------------+------------------------------------------------------------+
+| :code:`picotech`        | `PicoSDK`_ (Windows) / `libusbpt104`_ (Ubuntu/Debian)      |
++-------------------------+------------------------------------------------------------+
+| :code:`tiepie`          | `LibTiePie SDK`_                                           |
++-------------------------+------------------------------------------------------------+
+
+For more details on installation of the libraries see docstrings of the corresponding
+:code:`hvl_ccb` modules.
+
+.. _`LibTiePie SDK`: https://www.tiepie.com/en/libtiepie-sdk
+.. _`libusbpt104`: https://labs.picotech.com/debian/pool/main/libu/libusbpt104/
+.. _`LJM Library`: https://labjack.com/ljm
+.. _`PicoSDK`: https://www.picotech.com/downloads
+
+
+=======
+History
+=======
+
+0.9.0 (2022-01-07)
+------------------
+
+* New device: Highland T560 digital delay and pulse generator over Telnet.
+* Rework of the Technix Capacitor Charger.
+    * Moved into a separate sub-package
+    * NEW import over :code:`import hvl_ccb.dev.technix as XXX`
+    * Slightly adapted behaviour
+* Add :code:`validate_tcp_port` to validate port number.
+* Add :code:`validate_and_resolve_host` to validate and resolve host names and IPs.
+    * Remove requirement :code:`IPy`
+* Add a unified CCB Exception schema for all devices and communication protocols.
+* Add data conversion functions to README.
+* Update CI and devel images from Debian 10 buster to Debian 11 bullseye.
+* Fix typing due to numpy update.
+* Fix incorrect overloading of :code:`clean_values()` in classes of
+  type :code:`XCommunicationConfig`.
+
+0.8.5 (2021-11-05)
+------------------
+
+* Added arbitrary waveform for TiePie signal generation, configurable via
+  :code:`dev.tiepie.generator.TiePieGeneratorConfig.waveform` property.
+* In :code:`utils.conversion_sensor`: improvements for class constants; removed SciPy
+  dependency.
+* Added Python 3.10 support.
+
+0.8.4 (2021-10-22)
+------------------
+
+* :code:`utils.validation.validate_number` extension to handle NumPy arrays and
+  array-like objects.
+* :code:`utils.conversion_unit` utility classes handle correctly :code:`NamedTuple`
+  instances.
+* :code:`utils.conversion_sensor` and :code:`utils.conversion_unit` code
+  simplification (no :code:`transfer_function_order` attribute) and cleanups.
+* Fixed incorrect error logging in :code:`configuration.configdataclass`.
+* :code:`comm.telnet.TelnetCommunication` tests fixes for local run errors.
+
+0.8.3 (2021-09-27)
+------------------
+
+* New data conversion functions in :code:`utils.conversion_sensor` and
+  :code:`utils.conversion_unit` modules. Note: to use these functions you must install
+  :code:`hvl_ccb` with extra requirement, either :code:`hvl_ccb[conversion]` or
+  :code:`hvl_ccb[all]`.
+* Improved documentation with respect to installation of external libraries.
+
+0.8.2 (2021-08-27)
+------------------
+
+* New functionality in :code:`dev.labjack.LabJack`:
+    * configure clock and send timed pulse sequences
+    * set DAC/analog output voltage
+* Bugfix: ignore random bits sent by to :code:`dev.newport.NewportSMC100PP`
+  controller during start-up/powering-up.
+
+0.8.1 (2021-08-13)
+------------------
+
+* Add Python version check (min version error; max version warning).
+* Daily checks for upstream dependencies compatibility and devel environment
+  improvements.
+
+0.8.0 (2021-07-02)
+------------------
+
+* TCP communication protocol.
+* Lauda PRO RP 245 E circulation thermostat device over TCP.
+* Pico Technology PT-104 Platinum Resistance Data Logger device as a wrapper of the
+  Python bindings for the PicoSDK.
+* In :code:`com.visa.VisaCommunication`: periodic status polling when VISA/TCP keep
+  alive connection is not supported by a host.
+
+0.7.1 (2021-06-04)
+------------------
+
+* New :code:`utils.validation` submodule with :code:`validate_bool` and
+  :code:`validate_number` utilities extracted from internal use within a
+  :code:`dev.tiepie` subpackage.
+* In :code:`comm.serial.SerialCommunication`:
+     * strict encoding errors handling strategy for subclasses,
+     * user warning for a low communication timeout value.
+
+0.7.0 (2021-05-25)
+------------------
+
+* The :code:`dev.tiepie` module was splitted into a subpackage with, in particular,
+  submodules for each of the device types -- :code:`oscilloscope`, :code:`generator`,
+  and :code:`i2c` -- and with backward-incompatible direct imports from the submodules.
+* In :code:`dev.technix`:
+      * fixed communication crash on nested status byte query;
+      * added enums for GET and SET register commands.
+* Further minor logging improvements: added missing module level logger and removed some
+  error logs in :code:`except` blocks used for a flow control.
+* In :code:`examples/` folder renamed consistently all the examples.
+* In API documentation: fix incorrect links mapping on inheritance diagrams.
+
+0.6.1 (2021-05-08)
+------------------
+
+* In :code:`dev.tiepie`:
+      * dynamically set oscilloscope's channel limits in
+        :code:`OscilloscopeChannelParameterLimits`: :code:`input_range` and
+        :code:`trigger_level_abs`, incl. update of latter on each change of
+        :code:`input_range` value of a :code:`TiePieOscilloscopeChannelConfig`
+        instances;
+      * quick fix for opening of combined instruments by disabling
+        :code:`OscilloscopeParameterLimits.trigger_delay` (an advanced feature);
+      * enable automatic devices detection to be able to find network devices with
+        :code:`TiePieOscilloscope.list_devices()`.
+* Fix :code:`examples/example_labjack.py`.
+* Improved logging: consistently use module level loggers, and always log exception
+  tracebacks.
+* Improve API documentation: separate pages per modules, each with an inheritance
+  diagram as an overview.
+
+0.6.0 (2021-04-23)
+------------------
+
+* Technix capacitor charger using either serial connection or Telnet protocol.
+* Extensions, improvements and fixes in existing devices:
+   * In :code:`dev.tiepie.TiePieOscilloscope`:
+       * redesigned measurement start and data collection API, incl. time out
+         argument, with no/infinite time out option;
+       * trigger allows now a no/infinite time out;
+       * record length and trigger level were fixed to accept, respectively, floating
+         point and integer numbers;
+       * fixed resolution validation bug;
+   * :code:`dev.heinzinger.HeinzingerDI` and `dev.rs_rto1024.RTO1024` instances are now
+     resilient to multiple :code:`stop()` calls.
+   * In :code:`dev.crylas.CryLasLaser`: default configuration timeout and
+     polling period were adjusted;
+   * Fixed PSI9080 example script.
+* Package and source code improvements:
+   * Update to backward-incompatible :code:`pyvisa-py>=0.5.2`. Developers, do update
+     your local development environments!
+   * External libraries, like LibTiePie SDK or LJM Library, are now not installed by
+     default; they are now extra installation options.
+   * Added Python 3.9 support.
+   * Improved number formatting in logs.
+   * Typing improvements and fixes for :code:`mypy>=0.800`.
+
+0.5.0 (2020-11-11)
+------------------
+
+* TiePie USB oscilloscope, generator and I2C host devices, as a wrapper of the Python
+  bindings for the LibTiePie SDK.
+* a FuG Elektronik Power Supply (e.g. Capacitor Charger HCK) using the built-in ADDAT
+  controller with the Probus V protocol over a serial connection
+* All devices poling status or measurements use now a :code:`dev.utils.Poller` utility
+  class.
+* Extensions and improvements in existing devices:
+    * In :code:`dev.rs_rto1024.RTO1024`: added Channel state, scale, range,
+      position and offset accessors, and measurements activation and read methods.
+    * In :code:`dev.sst_luminox.Luminox`: added querying for all measurements
+      in polling mode, and made output mode activation more robust.
+    * In :code:`dev.newport.NewportSMC100PP`: an error-prone
+      :code:`wait_until_move_finished` method of replaced by a fixed waiting time,
+      device operations are now robust to a power supply cut, and device restart is not
+      required to apply a start configuration.
+* Other minor improvements:
+    * Single failure-safe starting and stopping of devices sequenced via
+      :code:`dev.base.DeviceSequenceMixin`.
+    * Moved :code:`read_text_nonempty` up to :code:`comm.serial.SerialCommunication`.
+    * Added development Dockerfile.
+    * Updated package and development dependencies: :code:`pymodbus`,
+      :code:`pytest-mock`.
+
+0.4.0 (2020-07-16)
+------------------
+
+* Significantly improved new Supercube device controller:
+    - more robust error-handling,
+    - status polling with generic :code:`Poller` helper,
+    - messages and status boards.
+    - tested with a physical device,
+* Improved OPC UA client wrapper, with better error handling, incl. re-tries on
+  :code:`concurrent.futures.TimeoutError`.
+* SST Luminox Oxygen sensor device controller.
+* Backward-incompatible changes:
+    - :code:`CommunicationProtocol.access_lock` has changed type from
+      :code:`threading.Lock` to :code:`threading.RLock`.
+    - :code:`ILS2T.relative_step` and :code:`ILS2T.absolute_position` are now called,
+      respectively, :code:`ILS2T.write_relative_step` and
+      :code:`ILS2T.write_absolute_position`.
+* Minor bugfixes and improvements:
+    - fix use of max resolution in :code:`Labjack.set_ain_resolution()`,
+    - resolve ILS2T devices relative and absolute position setters race condition,
+    - added acoustic horn function in the 2015 Supercube.
+* Toolchain changes:
+    - add Python 3.8 support,
+    - drop pytest-runner support,
+    - ensure compatibility with :code:`labjack_ljm` 2019 version library.
+
+0.3.5 (2020-02-18)
+------------------
+
+* Fix issue with reading integers from LabJack LJM Library (device's product ID, serial
+  number etc.)
+* Fix development requirements specification (tox version).
+
+0.3.4 (2019-12-20)
+------------------
+
+* New devices using serial connection:
+    * Heinzinger Digital Interface I/II and a Heinzinger PNC power supply
+    * Q-switched Pulsed Laser and a laser attenuator from CryLas
+    * Newport SMC100PP single axis motion controller for 2-phase stepper motors
+    * Pfeiffer TPG controller (TPG 25x, TPG 26x and TPG 36x) for Compact pressure Gauges
+* PEP 561 compatibility and related corrections for static type checking (now in CI)
+* Refactorings:
+    * Protected non-thread safe read and write in communication protocols
+    * Device sequence mixin: start/stop, add/rm and lookup
+    * `.format()` to f-strings
+    * more enumerations and a quite some improvements of existing code
+* Improved error docstrings (:code:`:raises:` annotations) and extended tests for
+  errors.
+
+0.3.3 (2019-05-08)
+------------------
+
+* Use PyPI labjack-ljm (no external dependencies)
+
+
+0.3.2 (2019-05-08)
+------------------
+
+* INSTALLATION.rst with LJMPython prerequisite info
+
+
+0.3.1 (2019-05-02)
+------------------
+
+* readthedocs.org support
+
+0.3 (2019-05-02)
+----------------
+
+* Prevent an automatic close of VISA connection when not used.
+* Rhode & Schwarz RTO 1024 oscilloscope using VISA interface over TCP::INSTR.
+* Extended tests incl. messages sent to devices.
+* Added Supercube device using an OPC UA client
+* Added Supercube 2015 device using an OPC UA client (for interfacing with old system
+  version)
+
+0.2.1 (2019-04-01)
+------------------
+
+* Fix issue with LJMPython not being installed automatically with setuptools.
+
+0.2.0 (2019-03-31)
+------------------
+
+* LabJack LJM Library communication wrapper and LabJack device.
+* Modbus TCP communication protocol.
+* Schneider Electric ILS2T stepper motor drive device.
+* Elektro-Automatik PSI9000 current source device and VISA communication wrapper.
+* Separate configuration classes for communication protocols and devices.
+* Simple experiment manager class.
+
+0.1.0 (2019-02-06)
+------------------
+
+* Communication protocol base and serial communication implementation.
+* Device base and MBW973 implementation.
+
+
```

### Comparing `hvl_ccb-0.8.5/setup.py` & `hvl_ccb-0.9.0/setup.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,116 +1,115 @@
-#!/usr/bin/env python
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""The setup script."""
-import sys
-
-from setuptools import setup, find_packages
-
-# Note: compare only major and minor version numbers
-python_min_version = (3, 7,)
-python_max_version = (3, 10,)
-python_version = sys.version_info[:2]
-python_min_version_str = '.'.join(map(str, python_min_version))
-python_max_version_str = '.'.join(map(str, python_max_version))
-if python_version < python_min_version:
-    import platform
-    print(
-        'ERROR: You are using Python {}; Python >={} is required.'.format(
-            platform.python_version(),
-            python_min_version_str,
-        ),
-    )
-    sys.exit(-1)
-if python_version > python_max_version:
-    import platform
-    print(
-        'WARNING: You are using Python {}; Python <={} is officially supported.'.format(
-            platform.python_version(),
-            python_max_version_str,
-        ),
-    )
-
-with open('README.rst') as readme_file:
-    readme = readme_file.read()
-
-with open('INSTALLATION.rst') as installation_file:
-    installation = installation_file.read()
-
-with open('HISTORY.rst') as history_file:
-    history = history_file.read()
-
-requirements = [
-    'pyserial>=3.4',
-    'pymodbus>=2.3.0',
-    'IPy>=0.83',
-    'bitstring>=3.1.5',
-    'pyvisa>=1.11.3',
-    'pyvisa-py>=0.5.2',
-    'typeguard>=2.3.0',
-    'aenum>=2.1.2',
-    'opcua>=0.98.6',
-    'cryptography>=2.6.1',  # optional dependency of the opcua package
-    'openpyxl>=2.6.2',
-    'numpy>=1.21.0',
-]
-
-tiepie = ['python-libtiepie>=0.7']
-labjack = ['labjack-ljm>=1.20.0']
-picotech = ['PicoSDK>=1.0']
-all_libs = tiepie + labjack + picotech
-
-extra_requirements = {
-    'all': all_libs,
-    'tiepie': tiepie,
-    'labjack': labjack,
-    'picotech': picotech,
-}
-
-
-dependency_links = []
-
-setup(
-    author=(
-        'Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, '
-        'Henning Janssen, David Taylor',
-    ),
-    author_email=(
-        'mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, '
-        'chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch'
-    ),
-    classifiers=[
-        'Development Status :: 4 - Beta',
-        'Intended Audience :: Developers',
-        'Intended Audience :: Education',
-        'Intended Audience :: Science/Research',
-        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',
-        'Natural Language :: English',
-        'Programming Language :: Python :: 3',
-    ] + [
-        'Programming Language :: Python :: 3.{}'.format(i)
-        for i in range(python_min_version[1], python_max_version[1] + 1)
-    ],
-    description=(
-        'Python common code base to control devices high voltage research devices, in '
-        'particular, as used in Christian Franck\'s High Voltage Lab (HVL), D-ITET, ETH'
-    ),
-    entry_points={},
-    python_requires='>={}'.format(python_min_version_str),
-    install_requires=requirements,
-    extras_require=extra_requirements,
-    dependency_links=dependency_links,
-    license='GNU General Public License v3',
-    long_description=readme + '\n\n' + installation + '\n\n' + history,
-    long_description_content_type='text/x-rst',
-    include_package_data=True,
-    keywords='hvl_ccb',
-    name='hvl_ccb',
-    package_data={
-        'hvl_ccb': ['py.typed'],
-    },
-    packages=find_packages(),
-    test_suite='tests',
-    url='https://gitlab.com/ethz_hvl/hvl_ccb/',
-    version='0.8.5',
-    zip_safe=False,
-)
+#!/usr/bin/env python
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""The setup script."""
+import sys
+
+from setuptools import setup, find_packages
+
+# Note: compare only major and minor version numbers
+python_min_version = (3, 7,)
+python_max_version = (3, 10,)
+python_version = sys.version_info[:2]
+python_min_version_str = '.'.join(map(str, python_min_version))
+python_max_version_str = '.'.join(map(str, python_max_version))
+if python_version < python_min_version:
+    import platform
+    print(
+        'ERROR: You are using Python {}; Python >={} is required.'.format(
+            platform.python_version(),
+            python_min_version_str,
+        ),
+    )
+    sys.exit(-1)
+if python_version > python_max_version:
+    import platform
+    print(
+        'WARNING: You are using Python {}; Python <={} is officially supported.'.format(
+            platform.python_version(),
+            python_max_version_str,
+        ),
+    )
+
+with open('README.rst') as readme_file:
+    readme = readme_file.read()
+
+with open('INSTALLATION.rst') as installation_file:
+    installation = installation_file.read()
+
+with open('HISTORY.rst') as history_file:
+    history = history_file.read()
+
+requirements = [
+    'pyserial>=3.4',
+    'pymodbus>=2.3.0',
+    'bitstring>=3.1.5',
+    'pyvisa>=1.11.3',
+    'pyvisa-py>=0.5.2',
+    'typeguard>=2.3.0',
+    'aenum>=2.1.2',
+    'opcua>=0.98.6',
+    'cryptography>=2.6.1',  # optional dependency of the opcua package
+    'openpyxl>=2.6.2',
+    'numpy>=1.21.0',
+]
+
+tiepie = ['python-libtiepie>=0.7']
+labjack = ['labjack-ljm>=1.20.0']
+picotech = ['PicoSDK>=1.0']
+all_libs = tiepie + labjack + picotech
+
+extra_requirements = {
+    'all': all_libs,
+    'tiepie': tiepie,
+    'labjack': labjack,
+    'picotech': picotech,
+}
+
+
+dependency_links = []
+
+setup(
+    author=(
+        'Mikołaj Rybiński, David Graber, Henrik Menne, Alise Chachereau, '
+        'Henning Janssen, David Taylor',
+    ),
+    author_email=(
+        'mikolaj.rybinski@id.ethz.ch, dev@davidgraber.ch, henrik.menne@eeh.ee.ethz.ch, '
+        'chachereau@eeh.ee.ethz.ch, janssen@eeh.ee.ethz.ch, dtaylor@ethz.ch'
+    ),
+    classifiers=[
+        'Development Status :: 4 - Beta',
+        'Intended Audience :: Developers',
+        'Intended Audience :: Education',
+        'Intended Audience :: Science/Research',
+        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',
+        'Natural Language :: English',
+        'Programming Language :: Python :: 3',
+    ] + [
+        'Programming Language :: Python :: 3.{}'.format(i)
+        for i in range(python_min_version[1], python_max_version[1] + 1)
+    ],
+    description=(
+        'Python common code base to control devices high voltage research devices, in '
+        'particular, as used in Christian Franck\'s High Voltage Lab (HVL), D-ITET, ETH'
+    ),
+    entry_points={},
+    python_requires='>={}'.format(python_min_version_str),
+    install_requires=requirements,
+    extras_require=extra_requirements,
+    dependency_links=dependency_links,
+    license='GNU General Public License v3',
+    long_description=readme + '\n\n' + installation + '\n\n' + history,
+    long_description_content_type='text/x-rst',
+    include_package_data=True,
+    keywords='hvl_ccb',
+    name='hvl_ccb',
+    package_data={
+        'hvl_ccb': ['py.typed'],
+    },
+    packages=find_packages(),
+    test_suite='tests',
+    url='https://gitlab.com/ethz_hvl/hvl_ccb/',
+    version='0.9.0',
+    zip_safe=False,
+)
```

### Comparing `hvl_ccb-0.8.5/tests/masked_comm/labjack_ljm.py` & `hvl_ccb-0.9.0/tests/masked_comm/labjack_ljm.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,75 +1,75 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Masked version of LJM Communication for testing purposes.
-"""
-
-import logging
-from collections import defaultdict
-from numbers import Real
-from queue import Queue
-from typing import Union, Sequence
-
-from hvl_ccb import comm
-
-logger = logging.getLogger(__name__)
-
-
-class MaskedLJMCommunication(comm.LJMCommunication):
-    """
-    Masks the LJMCommunication protocol disabling read and write to be able to test
-    the functionality of devices without
-    """
-
-    def __init__(self, configuration):
-        super().__init__(configuration)
-
-        self._read_buffer = defaultdict(Queue)
-        self._write_buffer = Queue()
-
-    def read_name(self, *names: str, return_num_type=float):
-
-        try:
-            out = tuple(
-                (
-                    self._cast_read_value(
-                        name,
-                        self._read_buffer[name].get(),
-                        return_num_type=return_num_type,
-                    )
-                    if not self._read_buffer[name].empty()
-                    else return_num_type(0)
-                )
-                for name in names
-            )
-        except ValueError as e:
-            logger.error(str(e), exc_info=e)
-            raise TypeError from e
-
-        return out[0] if len(out) == 1 else out
-
-    def write_name(
-        self, name: Union[Sequence[str], str], value: Union[Sequence[object], object]
-    ):
-
-        if isinstance(name, str):
-            name = [name]
-            value = [value]
-
-        for pair in zip(name, value):
-            self._write_buffer.put(pair)
-
-    def write_address(
-        self, address: Union[Sequence[int], int], value: Union[Sequence[object], object]
-    ):
-        pass
-
-    def put_name(self, name: str, value: object):
-        # Note: labjack library returns `float` (`ctypes.c_double`?), even when `int`
-        #       value is expected, but allow also in tests mock values with invalid type
-        if isinstance(value, Real):
-            value = float(value)
-        self._read_buffer[name].put(value)
-
-    def get_written(self):
-        return self._write_buffer.get() if not self._write_buffer.empty() else None
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Masked version of LJM Communication for testing purposes.
+"""
+
+import logging
+from collections import defaultdict
+from numbers import Real
+from queue import Queue
+from typing import Union, Sequence
+
+from hvl_ccb import comm
+
+logger = logging.getLogger(__name__)
+
+
+class MaskedLJMCommunication(comm.LJMCommunication):
+    """
+    Masks the LJMCommunication protocol disabling read and write to be able to test
+    the functionality of devices without
+    """
+
+    def __init__(self, configuration):
+        super().__init__(configuration)
+
+        self._read_buffer = defaultdict(Queue)
+        self._write_buffer = Queue()
+
+    def read_name(self, *names: str, return_num_type=float):
+
+        try:
+            out = tuple(
+                (
+                    self._cast_read_value(
+                        name,
+                        self._read_buffer[name].get(),
+                        return_num_type=return_num_type,
+                    )
+                    if not self._read_buffer[name].empty()
+                    else return_num_type(0)
+                )
+                for name in names
+            )
+        except ValueError as e:
+            logger.error(str(e), exc_info=e)
+            raise TypeError from e
+
+        return out[0] if len(out) == 1 else out
+
+    def write_name(
+        self, name: Union[Sequence[str], str], value: Union[Sequence[object], object]
+    ):
+
+        if isinstance(name, str):
+            name = [name]
+            value = [value]
+
+        for pair in zip(name, value):
+            self._write_buffer.put(pair)
+
+    def write_address(
+        self, address: Union[Sequence[int], int], value: Union[Sequence[object], object]
+    ):
+        pass
+
+    def put_name(self, name: str, value: object):
+        # Note: labjack library returns `float` (`ctypes.c_double`?), even when `int`
+        #       value is expected, but allow also in tests mock values with invalid type
+        if isinstance(value, Real):
+            value = float(value)
+        self._read_buffer[name].put(value)
+
+    def get_written(self):
+        return self._write_buffer.get() if not self._write_buffer.empty() else None
```

### Comparing `hvl_ccb-0.8.5/tests/masked_comm/serial.py` & `hvl_ccb-0.9.0/tests/masked_comm/serial.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,92 +1,92 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Masked version of SerialCommunication for testing purposes.
-"""
-
-from queue import Queue
-
-from hvl_ccb.comm import SerialCommunication
-from hvl_ccb.dev import (
-    CryLasLaserSerialCommunication,
-    FuGSerialCommunication,
-    HeinzingerSerialCommunication,
-    LuminoxSerialCommunication,
-    NewportSMC100PPSerialCommunication,
-    PfeifferTPGSerialCommunication,
-    TechnixSerialCommunication,
-)
-
-
-class LoopSerialCommunication(SerialCommunication):
-    """
-    Serial communication for the tests with "loop://" port. Masks `write` method
-    and adds `put_text` method to put actual values for the serial communication
-    protocol to read with the `read_text` method.
-    """
-
-    def __init__(self, configuration):
-        super().__init__(configuration)
-
-        self._write_buffer = Queue()
-
-    def write(
-        self,
-        text: str,
-    ):
-        self._write_buffer.put(text)
-
-    def put_text(self, text: str):
-        # super().write(text)
-        super().write_bytes(
-            text.encode(encoding=self.config.encoding) + self.config.terminator
-        )
-
-    def write_bytes(self, data: bytes):
-        self._write_buffer.put(data)
-
-    def put_bytes(self, data: bytes):
-        super().write_bytes(data)
-
-    def get_written(self):
-        return self._write_buffer.get() if not self._write_buffer.empty() else None
-
-
-class CryLasLaserLoopSerialCommunication(
-    CryLasLaserSerialCommunication, LoopSerialCommunication
-):
-    pass
-
-
-class FuGLoopSerialCommunication(FuGSerialCommunication, LoopSerialCommunication):
-    pass
-
-
-class HeinzingerLoopSerialCommunication(
-    HeinzingerSerialCommunication, LoopSerialCommunication
-):
-    pass
-
-
-class LuminoxLoopSerialCommunication(
-    LuminoxSerialCommunication, LoopSerialCommunication
-):
-    pass
-
-
-class NewportLoopSerialCommunication(
-    NewportSMC100PPSerialCommunication, LoopSerialCommunication
-):
-    pass
-
-
-class PfeifferTPGLoopSerialCommunication(
-    PfeifferTPGSerialCommunication, LoopSerialCommunication
-):
-    pass
-
-
-class TechnixLoopSerialCommunication(
-    TechnixSerialCommunication, LoopSerialCommunication
-):
-    pass
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Masked version of SerialCommunication for testing purposes.
+"""
+
+from queue import Queue
+
+from hvl_ccb.comm import SerialCommunication
+from hvl_ccb.dev import (
+    CryLasLaserSerialCommunication,
+    FuGSerialCommunication,
+    HeinzingerSerialCommunication,
+    LuminoxSerialCommunication,
+    NewportSMC100PPSerialCommunication,
+    PfeifferTPGSerialCommunication,
+)
+from hvl_ccb.dev.technix import TechnixSerialCommunication
+
+
+class LoopSerialCommunication(SerialCommunication):
+    """
+    Serial communication for the tests with "loop://" port. Masks `write` method
+    and adds `put_text` method to put actual values for the serial communication
+    protocol to read with the `read_text` method.
+    """
+
+    def __init__(self, configuration):
+        super().__init__(configuration)
+
+        self._write_buffer = Queue()
+
+    def write(
+        self,
+        text: str,
+    ):
+        self._write_buffer.put(text)
+
+    def put_text(self, text: str):
+        # super().write(text)
+        super().write_bytes(
+            text.encode(encoding=self.config.encoding) + self.config.terminator
+        )
+
+    def write_bytes(self, data: bytes):
+        self._write_buffer.put(data)
+
+    def put_bytes(self, data: bytes):
+        super().write_bytes(data)
+
+    def get_written(self):
+        return self._write_buffer.get() if not self._write_buffer.empty() else None
+
+
+class CryLasLaserLoopSerialCommunication(
+    CryLasLaserSerialCommunication, LoopSerialCommunication
+):
+    pass
+
+
+class FuGLoopSerialCommunication(FuGSerialCommunication, LoopSerialCommunication):
+    pass
+
+
+class HeinzingerLoopSerialCommunication(
+    HeinzingerSerialCommunication, LoopSerialCommunication
+):
+    pass
+
+
+class LuminoxLoopSerialCommunication(
+    LuminoxSerialCommunication, LoopSerialCommunication
+):
+    pass
+
+
+class NewportLoopSerialCommunication(
+    NewportSMC100PPSerialCommunication, LoopSerialCommunication
+):
+    pass
+
+
+class PfeifferTPGLoopSerialCommunication(
+    PfeifferTPGSerialCommunication, LoopSerialCommunication
+):
+    pass
+
+
+class TechnixLoopSerialCommunication(
+    TechnixSerialCommunication, LoopSerialCommunication
+):
+    pass
```

### Comparing `hvl_ccb-0.8.5/tests/masked_comm/tcp.py` & `hvl_ccb-0.9.0/tests/masked_comm/tcp.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,81 +1,81 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Mock TCP servers
-"""
-
-import socket
-import time
-
-from hvl_ccb.dev import lauda
-
-
-class FakeTCP:
-    """
-    Class implementing a mock TCP server
-    """
-
-    def __init__(self, _SOCK_TIMEOUT):
-        self._SOCK_TIMEOUT = _SOCK_TIMEOUT
-
-    def run_fake_server(self, host, port, term="\r\n", wait_sec_rw=0.005):
-        # Run a server to listen for a connection and then close it
-        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
-            server_sock.settimeout(self._SOCK_TIMEOUT)
-            server_sock.bind((host, port))
-            server_sock.listen(0)
-            connection, client_address = server_sock.accept()
-            with connection:
-                # Receive the data and retransmit it
-                while True:
-                    data = connection.recv(64)
-                    if not data:
-                        break
-                    parsed = data.decode("ascii")
-                    if "TYPE" in parsed:
-                        connection.sendall(bytes(f"RP245 PRO{term}", "ascii"))
-                    elif "IN_PV_00" in parsed:
-                        connection.sendall(bytes(f"OK{term}25.00{term}", "ascii"))
-                    elif "FOO" in parsed:
-                        connection.sendall(bytes(f"ERR01{term}", "ascii"))
-                    elif (
-                        parsed == f"{lauda.LaudaProRp245eCommand.STOP}{term}"
-                        or "end" in parsed
-                    ):
-                        connection.sendall(data)
-                        break
-                    else:
-                        connection.sendall(data)
-                    time.sleep(min(wait_sec_rw, self._SOCK_TIMEOUT / 5))
-                # close the connection in a timely fashion => call shutdown before close
-                connection.shutdown(socket.SHUT_RDWR)
-
-    def run_bad_fake_server(self, host, port, term="\r\n", wait_sec_rw=0.005):
-        # Run a server to listen for a connection and then close it
-        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
-            server_sock.settimeout(self._SOCK_TIMEOUT)
-            server_sock.bind((host, port))
-            server_sock.listen(0)
-            connection, client_address = server_sock.accept()
-            with connection:
-                # Receive the data and retransmit it
-                while True:
-                    data = connection.recv(64)
-                    if not data:
-                        break
-                    parsed = data.decode("ascii")
-                    if "TYPE" in parsed:
-                        connection.sendall(
-                            bytes(f"Chuck Norris was here{term}", "ascii")
-                        )
-                    elif (
-                        parsed == f"{self.chiller.LaudaProRp245eCommand.STOP}{term}"
-                        or "end" in parsed
-                    ):
-                        connection.sendall(data)
-                        break
-                    else:
-                        connection.sendall(data)
-                    time.sleep(min(wait_sec_rw, self._SOCK_TIMEOUT / 5))
-                # close the connection in a timely fashion => call shutdown before close
-                connection.shutdown(socket.SHUT_RDWR)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Mock TCP servers
+"""
+
+import socket
+import time
+
+from hvl_ccb.dev import lauda
+
+
+class FakeTCP:
+    """
+    Class implementing a mock TCP server
+    """
+
+    def __init__(self, _SOCK_TIMEOUT):
+        self._SOCK_TIMEOUT = _SOCK_TIMEOUT
+
+    def run_fake_server(self, host, port, term="\r\n", wait_sec_rw=0.005):
+        # Run a server to listen for a connection and then close it
+        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
+            server_sock.settimeout(self._SOCK_TIMEOUT)
+            server_sock.bind((host, port))
+            server_sock.listen(0)
+            connection, client_address = server_sock.accept()
+            with connection:
+                # Receive the data and retransmit it
+                while True:
+                    data = connection.recv(64)
+                    if not data:
+                        break
+                    parsed = data.decode("ascii")
+                    if "TYPE" in parsed:
+                        connection.sendall(bytes(f"RP245 PRO{term}", "ascii"))
+                    elif "IN_PV_00" in parsed:
+                        connection.sendall(bytes(f"OK{term}25.00{term}", "ascii"))
+                    elif "FOO" in parsed:
+                        connection.sendall(bytes(f"ERR01{term}", "ascii"))
+                    elif (
+                        parsed == f"{lauda.LaudaProRp245eCommand.STOP}{term}"
+                        or "end" in parsed
+                    ):
+                        connection.sendall(data)
+                        break
+                    else:
+                        connection.sendall(data)
+                    time.sleep(min(wait_sec_rw, self._SOCK_TIMEOUT / 5))
+                # close the connection in a timely fashion => call shutdown before close
+                connection.shutdown(socket.SHUT_RDWR)
+
+    def run_bad_fake_server(self, host, port, term="\r\n", wait_sec_rw=0.005):
+        # Run a server to listen for a connection and then close it
+        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_sock:
+            server_sock.settimeout(self._SOCK_TIMEOUT)
+            server_sock.bind((host, port))
+            server_sock.listen(0)
+            connection, client_address = server_sock.accept()
+            with connection:
+                # Receive the data and retransmit it
+                while True:
+                    data = connection.recv(64)
+                    if not data:
+                        break
+                    parsed = data.decode("ascii")
+                    if "TYPE" in parsed:
+                        connection.sendall(
+                            bytes(f"Chuck Norris was here{term}", "ascii")
+                        )
+                    elif (
+                        parsed == f"{self.chiller.LaudaProRp245eCommand.STOP}{term}"
+                        or "end" in parsed
+                    ):
+                        connection.sendall(data)
+                        break
+                    else:
+                        connection.sendall(data)
+                    time.sleep(min(wait_sec_rw, self._SOCK_TIMEOUT / 5))
+                # close the connection in a timely fashion => call shutdown before close
+                connection.shutdown(socket.SHUT_RDWR)
```

### Comparing `hvl_ccb-0.8.5/tests/masked_comm/visa.py` & `hvl_ccb-0.9.0/tests/masked_comm/visa.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-VISA masked communication protocol module.
-"""
-
-from collections import defaultdict
-from queue import Queue
-from typing import Union, Tuple
-
-from hvl_ccb.comm import VisaCommunication
-
-
-class MaskedVisaCommunication(VisaCommunication):
-    """
-    Masked version of VisaCommunication to simulate messages.
-    """
-
-    def __init__(self, *args, **kwargs):
-        super().__init__(*args, **kwargs)
-
-        self._read_buffer = defaultdict(Queue)
-        self._write_buffer = Queue()
-
-        self.stb = 0
-
-    def open(self) -> None:
-        pass
-
-    def close(self):
-        pass
-
-    def write(self, *commands: str) -> None:
-        if '*OPC' in commands:
-            # operation complete request set, immediately reply
-            self.put_name('*ESR?', '1')
-
-        for command in commands:
-            self._write_buffer.put(command)
-
-    def query(self, *commands: str) -> Union[str, Tuple[str, ...]]:
-        out = [
-            self._read_buffer[command].get() if not self._read_buffer[command].empty()
-            else '0'
-            for command in commands
-        ]
-
-        return out[0] if len(out) == 1 else tuple(out)
-
-    def spoll(self) -> int:
-        return self.stb
-
-    def put_name(self, command: str, string: str) -> None:
-        self._read_buffer[command].put(string)
-
-    def get_written(self) -> Union[str, None]:
-        return self._write_buffer.get() if not self._write_buffer.empty() else None
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+VISA masked communication protocol module.
+"""
+
+from collections import defaultdict
+from queue import Queue
+from typing import Union, Tuple
+
+from hvl_ccb.comm import VisaCommunication
+
+
+class MaskedVisaCommunication(VisaCommunication):
+    """
+    Masked version of VisaCommunication to simulate messages.
+    """
+
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+
+        self._read_buffer = defaultdict(Queue)
+        self._write_buffer = Queue()
+
+        self.stb = 0
+
+    def open(self) -> None:
+        pass
+
+    def close(self):
+        pass
+
+    def write(self, *commands: str) -> None:
+        if '*OPC' in commands:
+            # operation complete request set, immediately reply
+            self.put_name('*ESR?', '1')
+
+        for command in commands:
+            self._write_buffer.put(command)
+
+    def query(self, *commands: str) -> Union[str, Tuple[str, ...]]:
+        out = [
+            self._read_buffer[command].get() if not self._read_buffer[command].empty()
+            else '0'
+            for command in commands
+        ]
+
+        return out[0] if len(out) == 1 else tuple(out)
+
+    def spoll(self) -> int:
+        return self.stb
+
+    def put_name(self, command: str, string: str) -> None:
+        self._read_buffer[command].put(string)
+
+    def get_written(self) -> Union[str, None]:
+        return self._write_buffer.get() if not self._write_buffer.empty() else None
```

### Comparing `hvl_ccb-0.8.5/tests/mock_libtiepie/devicelist.py` & `hvl_ccb-0.9.0/tests/mock_libtiepie/devicelist.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Mock DeviceList
-"""
-
-from libtiepie.devicelist import DeviceList as LtpDeviceList
-
-from .const import (
-    MOCK_GENERATOR_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
-    MOCK_I2CHOST_SERIAL_NUMBER,
-    MOCK_DEVICE_SERIAL_NUMBER
-)
-from .devicelistitem import DeviceListItem
-
-
-class DeviceList(LtpDeviceList):
-    """"""
-
-    def __init__(self):
-        self.__clear_devices()
-
-    # Enable mock patching with bool method used in the `update()` method
-    def mock_devices(self):
-        return True
-
-    def __clear_devices(self):
-        self._devices_by_serial_number = dict()
-        self._devices_by_index = list()
-
-    def __getitem__(self, index):
-        return self._devices_by_index[index]
-
-    def __len__(self):
-        return self.count
-
-    def __add_device(self, serial_number):
-        item = DeviceListItem(serial_number)
-        self._devices_by_serial_number[serial_number] = item
-        self._devices_by_index.append(item)
-
-    def get_item_by_serial_number(self, serial_number):
-        return self._devices_by_serial_number[serial_number]
-
-    def update(self):
-        if self.mock_devices():
-            self.__add_device(
-                MOCK_DEVICE_SERIAL_NUMBER,
-            )  # add device with oscilloscope, generator and I2C host
-            self.__add_device(
-                MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-            )  # add device with oscilloscope only
-            self.__add_device(
-                MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
-            )  # add device with oscilloscope only (without block measurement)
-            self.__add_device(
-                MOCK_GENERATOR_SERIAL_NUMBER,
-            )  # add device with generator only
-            self.__add_device(
-                MOCK_I2CHOST_SERIAL_NUMBER,
-            )  # add device with I2C host only
-        else:
-            self.__clear_devices()
-
-    def _get_count(self):
-        return len(self._devices_by_serial_number)
-
-    count = property(_get_count)
-
-
-device_list = DeviceList()
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Mock DeviceList
+"""
+
+from libtiepie.devicelist import DeviceList as LtpDeviceList
+
+from .const import (
+    MOCK_GENERATOR_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
+    MOCK_I2CHOST_SERIAL_NUMBER,
+    MOCK_DEVICE_SERIAL_NUMBER
+)
+from .devicelistitem import DeviceListItem
+
+
+class DeviceList(LtpDeviceList):
+    """"""
+
+    def __init__(self):
+        self.__clear_devices()
+
+    # Enable mock patching with bool method used in the `update()` method
+    def mock_devices(self):
+        return True
+
+    def __clear_devices(self):
+        self._devices_by_serial_number = dict()
+        self._devices_by_index = list()
+
+    def __getitem__(self, index):
+        return self._devices_by_index[index]
+
+    def __len__(self):
+        return self.count
+
+    def __add_device(self, serial_number):
+        item = DeviceListItem(serial_number)
+        self._devices_by_serial_number[serial_number] = item
+        self._devices_by_index.append(item)
+
+    def get_item_by_serial_number(self, serial_number):
+        return self._devices_by_serial_number[serial_number]
+
+    def update(self):
+        if self.mock_devices():
+            self.__add_device(
+                MOCK_DEVICE_SERIAL_NUMBER,
+            )  # add device with oscilloscope, generator and I2C host
+            self.__add_device(
+                MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+            )  # add device with oscilloscope only
+            self.__add_device(
+                MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
+            )  # add device with oscilloscope only (without block measurement)
+            self.__add_device(
+                MOCK_GENERATOR_SERIAL_NUMBER,
+            )  # add device with generator only
+            self.__add_device(
+                MOCK_I2CHOST_SERIAL_NUMBER,
+            )  # add device with I2C host only
+        else:
+            self.__clear_devices()
+
+    def _get_count(self):
+        return len(self._devices_by_serial_number)
+
+    count = property(_get_count)
+
+
+device_list = DeviceList()
```

### Comparing `hvl_ccb-0.8.5/tests/mock_libtiepie/devicelistitem.py` & `hvl_ccb-0.9.0/tests/mock_libtiepie/devicelistitem.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,142 +1,142 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Mock DeviceListItem
-"""
-
-import libtiepie as ltp
-from libtiepie.devicelistitem import DeviceListItem as LtpDeviceListItem
-
-from hvl_ccb.dev import (
-    TiePieDeviceType,
-)
-from mock_libtiepie.const import (
-    MOCK_I2CHOST_SERIAL_NUMBER,
-    MOCK_GENERATOR_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
-    MOCK_DEVICE_SERIAL_NUMBER,
-)
-from .generator import Generator
-from .i2chost import I2CHost
-from .oscilloscope import Oscilloscope
-from .server import Server
-
-
-class DeviceListItem(LtpDeviceListItem):
-    """"""
-
-    def __init__(self, serial_number):
-        self._serial_number = serial_number
-        self._oscilloscope = Oscilloscope(self._serial_number)
-        self._generator = Generator(self._serial_number)
-        self._i2chost = I2CHost(self._serial_number)
-
-    def open_device(self, device_type):
-        """ Open a device .
-
-        :param device_type: A device type.
-        :returns: Instance of :class:`.Oscilloscope`, :class:`.Generator` or
-            :class:`.I2CHost`.
-        """
-        if device_type == ltp.DEVICETYPE_OSCILLOSCOPE:
-            return self.open_oscilloscope()
-
-        if device_type == ltp.DEVICETYPE_GENERATOR:
-            return self.open_generator()
-
-        if device_type == ltp.DEVICETYPE_I2CHOST:
-            return self.open_i2chost()
-
-        return super().open_device(device_type)
-
-    def open_oscilloscope(self):
-        """ Open an oscilloscope .
-        :returns: Instance of :class:`.Oscilloscope`.
-        """
-        return self._oscilloscope
-
-    def open_generator(self):
-        """ Open a generator .
-        :returns: Instance of :class:`.Generator`.
-        """
-        return self._generator
-
-    def open_i2chost(self):
-        """ Open an I2C host .
-                :returns: Instance of :class:`.i2chost`.
-                """
-        return self._i2chost
-
-    def can_open(self, device_type):
-        """ Check whether the listed device can be opened.
-        :param device_type: A device type.
-        :returns: ``True`` if the device can be opened or ``False`` if not.
-        """
-        if device_type is TiePieDeviceType.OSCILLOSCOPE.value:
-            if self._serial_number in (
-                MOCK_DEVICE_SERIAL_NUMBER,
-                MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-                MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
-            ):
-                return True
-        if device_type is TiePieDeviceType.GENERATOR.value:
-            if self._serial_number in (
-                MOCK_DEVICE_SERIAL_NUMBER,
-                MOCK_GENERATOR_SERIAL_NUMBER
-            ):
-                return True
-        if device_type is TiePieDeviceType.I2C.value:
-            if self._serial_number in (
-                MOCK_DEVICE_SERIAL_NUMBER,
-                MOCK_I2CHOST_SERIAL_NUMBER
-            ):
-                return True
-        else:
-            return False
-
-    def _get_name(self):
-        """ Full name. """
-        return "Mocked name for device with serial number " + str(self._serial_number)
-
-    def _get_has_server(self):
-        """ Check whether the listed device is connected to a server. """
-        return True
-
-    def _get_serial_number(self):
-        """ Serial number. """
-        return self._serial_number
-
-    def _get_server(self):
-        """ Server handle of the server the listed device is connected to. """
-        return Server("127.0.0.1")
-
-    def device_type_str(self, value):
-        """ Device types. """
-        _str = ""
-        if self._serial_number == (
-            MOCK_DEVICE_SERIAL_NUMBER
-        ):
-            _str = "Oscilloscope, Generator, I2CHost"
-        if self._serial_number == (
-            MOCK_OSCILLOSCOPE_SERIAL_NUMBER
-        ):
-            _str = "Oscilloscope"
-        if self._serial_number == (
-            MOCK_GENERATOR_SERIAL_NUMBER
-        ):
-            _str = "Generator"
-        if self._serial_number == (
-            MOCK_I2CHOST_SERIAL_NUMBER
-        ):
-            _str = "I2C Host"
-        return _str
-
-    def _get_types(self):
-        return 1
-
-    name = property(_get_name)
-    has_server = property(_get_has_server)
-    serial_number = property(_get_serial_number)
-    server = property(_get_server)
-    types = property(_get_types)
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Mock DeviceListItem
+"""
+
+import libtiepie as ltp
+from libtiepie.devicelistitem import DeviceListItem as LtpDeviceListItem
+
+from hvl_ccb.dev import (
+    TiePieDeviceType,
+)
+from mock_libtiepie.const import (
+    MOCK_I2CHOST_SERIAL_NUMBER,
+    MOCK_GENERATOR_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
+    MOCK_DEVICE_SERIAL_NUMBER,
+)
+from .generator import Generator
+from .i2chost import I2CHost
+from .oscilloscope import Oscilloscope
+from .server import Server
+
+
+class DeviceListItem(LtpDeviceListItem):
+    """"""
+
+    def __init__(self, serial_number):
+        self._serial_number = serial_number
+        self._oscilloscope = Oscilloscope(self._serial_number)
+        self._generator = Generator(self._serial_number)
+        self._i2chost = I2CHost(self._serial_number)
+
+    def open_device(self, device_type):
+        """ Open a device .
+
+        :param device_type: A device type.
+        :returns: Instance of :class:`.Oscilloscope`, :class:`.Generator` or
+            :class:`.I2CHost`.
+        """
+        if device_type == ltp.DEVICETYPE_OSCILLOSCOPE:
+            return self.open_oscilloscope()
+
+        if device_type == ltp.DEVICETYPE_GENERATOR:
+            return self.open_generator()
+
+        if device_type == ltp.DEVICETYPE_I2CHOST:
+            return self.open_i2chost()
+
+        return super().open_device(device_type)
+
+    def open_oscilloscope(self):
+        """ Open an oscilloscope .
+        :returns: Instance of :class:`.Oscilloscope`.
+        """
+        return self._oscilloscope
+
+    def open_generator(self):
+        """ Open a generator .
+        :returns: Instance of :class:`.Generator`.
+        """
+        return self._generator
+
+    def open_i2chost(self):
+        """ Open an I2C host .
+                :returns: Instance of :class:`.i2chost`.
+                """
+        return self._i2chost
+
+    def can_open(self, device_type):
+        """ Check whether the listed device can be opened.
+        :param device_type: A device type.
+        :returns: ``True`` if the device can be opened or ``False`` if not.
+        """
+        if device_type is TiePieDeviceType.OSCILLOSCOPE.value:
+            if self._serial_number in (
+                MOCK_DEVICE_SERIAL_NUMBER,
+                MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+                MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
+            ):
+                return True
+        if device_type is TiePieDeviceType.GENERATOR.value:
+            if self._serial_number in (
+                MOCK_DEVICE_SERIAL_NUMBER,
+                MOCK_GENERATOR_SERIAL_NUMBER
+            ):
+                return True
+        if device_type is TiePieDeviceType.I2C.value:
+            if self._serial_number in (
+                MOCK_DEVICE_SERIAL_NUMBER,
+                MOCK_I2CHOST_SERIAL_NUMBER
+            ):
+                return True
+        else:
+            return False
+
+    def _get_name(self):
+        """ Full name. """
+        return "Mocked name for device with serial number " + str(self._serial_number)
+
+    def _get_has_server(self):
+        """ Check whether the listed device is connected to a server. """
+        return True
+
+    def _get_serial_number(self):
+        """ Serial number. """
+        return self._serial_number
+
+    def _get_server(self):
+        """ Server handle of the server the listed device is connected to. """
+        return Server("127.0.0.1")
+
+    def device_type_str(self, value):
+        """ Device types. """
+        _str = ""
+        if self._serial_number == (
+            MOCK_DEVICE_SERIAL_NUMBER
+        ):
+            _str = "Oscilloscope, Generator, I2CHost"
+        if self._serial_number == (
+            MOCK_OSCILLOSCOPE_SERIAL_NUMBER
+        ):
+            _str = "Oscilloscope"
+        if self._serial_number == (
+            MOCK_GENERATOR_SERIAL_NUMBER
+        ):
+            _str = "Generator"
+        if self._serial_number == (
+            MOCK_I2CHOST_SERIAL_NUMBER
+        ):
+            _str = "I2C Host"
+        return _str
+
+    def _get_types(self):
+        return 1
+
+    name = property(_get_name)
+    has_server = property(_get_has_server)
+    serial_number = property(_get_serial_number)
+    server = property(_get_server)
+    types = property(_get_types)
```

### Comparing `hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechanneltrigger.py` & `hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechanneltrigger.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,52 +1,52 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Mock OscilloscopeChannelTrigger
-"""
-
-import libtiepie.const as const
-from libtiepie.oscilloscopechanneltrigger import (
-    OscilloscopeChannelTrigger as LtpOscilloscopeChannelTrigger,
-)
-
-from .oscilloscopechanneltriggerhystereses import OscilloscopeChannelTriggerHystereses
-from .oscilloscopechanneltriggerlevels import OscilloscopeChannelTriggerLevels
-
-
-class OscilloscopeChannelTrigger(LtpOscilloscopeChannelTrigger):
-    def __init__(self):
-        self._enabled = False
-        self._hystereses = OscilloscopeChannelTriggerHystereses()
-        self._levels = OscilloscopeChannelTriggerLevels()
-        self._kind = const.TK_ANYEDGE
-        self._level_mode = const.TLM_UNKNOWN
-
-    def _get_enabled(self):
-        return self._enabled
-
-    def _set_enabled(self, value):
-        self._enabled = value
-
-    def _get_hystereses(self):
-        return self._hystereses
-
-    def _get_levels(self):
-        return self._levels
-
-    def _get_kind(self):
-        return self._kind
-
-    def _set_kind(self, value):
-        self._kind = value
-
-    def _get_level_mode(self):
-        return self._level_mode
-
-    def _set_level_mode(self, value):
-        self._level_mode = value
-
-    enabled = property(_get_enabled, _set_enabled)
-    hystereses = property(_get_hystereses)
-    levels = property(_get_levels)
-    kind = property(_get_kind, _set_kind)
-    level_mode = property(_get_level_mode, _set_level_mode)
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Mock OscilloscopeChannelTrigger
+"""
+
+import libtiepie.const as const
+from libtiepie.oscilloscopechanneltrigger import (
+    OscilloscopeChannelTrigger as LtpOscilloscopeChannelTrigger,
+)
+
+from .oscilloscopechanneltriggerhystereses import OscilloscopeChannelTriggerHystereses
+from .oscilloscopechanneltriggerlevels import OscilloscopeChannelTriggerLevels
+
+
+class OscilloscopeChannelTrigger(LtpOscilloscopeChannelTrigger):
+    def __init__(self):
+        self._enabled = False
+        self._hystereses = OscilloscopeChannelTriggerHystereses()
+        self._levels = OscilloscopeChannelTriggerLevels()
+        self._kind = const.TK_ANYEDGE
+        self._level_mode = const.TLM_UNKNOWN
+
+    def _get_enabled(self):
+        return self._enabled
+
+    def _set_enabled(self, value):
+        self._enabled = value
+
+    def _get_hystereses(self):
+        return self._hystereses
+
+    def _get_levels(self):
+        return self._levels
+
+    def _get_kind(self):
+        return self._kind
+
+    def _set_kind(self, value):
+        self._kind = value
+
+    def _get_level_mode(self):
+        return self._level_mode
+
+    def _set_level_mode(self, value):
+        self._level_mode = value
+
+    enabled = property(_get_enabled, _set_enabled)
+    hystereses = property(_get_hystereses)
+    levels = property(_get_levels)
+    kind = property(_get_kind, _set_kind)
+    level_mode = property(_get_level_mode, _set_level_mode)
```

### Comparing `hvl_ccb-0.8.5/tests/mock_libtiepie/oscilloscopechanneltriggerhystereses.py` & `hvl_ccb-0.9.0/tests/mock_libtiepie/oscilloscopechanneltriggerlevels.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Mock OscilloscopeChannelTriggerHystereses
-"""
-
-from libtiepie.oscilloscopechanneltriggerhystereses import (
-    OscilloscopeChannelTriggerHystereses as LtpOscilloscopeChannelTriggerHystereses,
-)
-
-
-class OscilloscopeChannelTriggerHystereses(LtpOscilloscopeChannelTriggerHystereses):
-    def __init__(self):
-        self.items = [1, 2, 3]
-
-    def __getitem__(self, index):
-        return self.items[index]
-
-    def __setitem__(self, index, value):
-        self.items[index] = value
-
-    def __len__(self):
-        return self.count
-
-    def _get_count(self):
-        return len(self.items)
-
-    count = property(_get_count)
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Mock OscilloscopeChannelTriggerHystereses
+"""
+
+from libtiepie.oscilloscopechanneltriggerlevels import (
+    OscilloscopeChannelTriggerLevels as LtpOscilloscopeChannelTriggerLevels,
+)
+
+
+class OscilloscopeChannelTriggerLevels(LtpOscilloscopeChannelTriggerLevels):
+    def __init__(self):
+        self.items = [1, 2, 3]
+
+    def __getitem__(self, index):
+        return self.items[index]
+
+    def __setitem__(self, index, value):
+        self.items[index] = value
+
+    def __len__(self):
+        return self.count
+
+    def _get_count(self):
+        return len(self.items)
+
+    count = property(_get_count)
```

### Comparing `hvl_ccb-0.8.5/tests/test_comm_base.py` & `hvl_ccb-0.9.0/tests/test_comm_base.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the base class CommunicationProtocol.
-"""
-
-import pytest
-
-from hvl_ccb.comm import NullCommunicationProtocol
-from hvl_ccb.comm.base import AsyncCommunicationProtocolConfig
-from hvl_ccb.configuration import EmptyConfig
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "terminator": b"",
-        "encoding": "ascii",
-        "encoding_error_handling": "strict",
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 5,
-    }
-
-
-def test_com_config(com_config):
-    config = AsyncCommunicationProtocolConfig(**com_config)
-    for key, value in com_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"encoding": "enigma"},
-        {"encoding_error_handling": "miracle"},
-        {"wait_sec_read_text_nonempty": 0},
-        {"wait_sec_read_text_nonempty": -1},
-        {"default_n_attempts_read_text_nonempty": 0},
-        {"default_n_attempts_read_text_nonempty": -1},
-    ],
-)
-def test_invalid_config_dict(com_config, wrong_config_dict):
-    invalid_config = dict(com_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        AsyncCommunicationProtocolConfig(**invalid_config)
-
-
-def test_instantiation():
-
-    for arg in (EmptyConfig(), {}, None):
-        with NullCommunicationProtocol(arg) as com:
-            assert com is not None
-            assert isinstance(com.config, EmptyConfig)
-
-    with pytest.raises(TypeError):
-        NullCommunicationProtocol({"extra_key": 0})
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the base class CommunicationProtocol.
+"""
+
+import pytest
+
+from hvl_ccb.comm import NullCommunicationProtocol
+from hvl_ccb.comm.base import AsyncCommunicationProtocolConfig
+from hvl_ccb.configuration import EmptyConfig
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "terminator": b"",
+        "encoding": "ascii",
+        "encoding_error_handling": "strict",
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 5,
+    }
+
+
+def test_com_config(com_config):
+    config = AsyncCommunicationProtocolConfig(**com_config)
+    for key, value in com_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"encoding": "enigma"},
+        {"encoding_error_handling": "miracle"},
+        {"wait_sec_read_text_nonempty": 0},
+        {"wait_sec_read_text_nonempty": -1},
+        {"default_n_attempts_read_text_nonempty": 0},
+        {"default_n_attempts_read_text_nonempty": -1},
+    ],
+)
+def test_invalid_config_dict(com_config, wrong_config_dict):
+    invalid_config = dict(com_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        AsyncCommunicationProtocolConfig(**invalid_config)
+
+
+def test_instantiation():
+
+    for arg in (EmptyConfig(), {}, None):
+        with NullCommunicationProtocol(arg) as com:
+            assert com is not None
+            assert isinstance(com.config, EmptyConfig)
+
+    with pytest.raises(TypeError):
+        NullCommunicationProtocol({"extra_key": 0})
```

### Comparing `hvl_ccb-0.8.5/tests/test_comm_labjack_ljm.py` & `hvl_ccb-0.9.0/tests/test_comm_labjack_ljm.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,141 +1,141 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the .comm.labjack_ljm subpackage.
-"""
-
-import logging
-from collections import abc
-
-import pytest
-
-from hvl_ccb.comm import (
-    LJMCommunication,
-    LJMCommunicationConfig,
-    LJMCommunicationError,
-)
-
-logging.disable(logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def testconfig():
-    return {
-        # identifier = -2 specifies LJM DEMO mode, see
-        # https://labjack.com/support/software/api/ljm/demo-mode
-        # however `ljm.getHandleInfo(-2)` raises
-        # `LJMError: LJM library error code 1224 LJME_DEVICE_NOT_OPEN`
-        "identifier": "-2"
-    }
-
-
-@pytest.fixture
-def com(testconfig):
-    with LJMCommunication(testconfig) as com:
-        yield com
-
-
-def test_labjack_config_cleaning():
-    with pytest.raises(ValueError):
-        LJMCommunicationConfig(device_type="T5")
-
-    with pytest.raises(ValueError):
-        LJMCommunicationConfig(device_type="T7-Pro")
-    config = LJMCommunicationConfig(device_type="T7_PRO")
-    assert config.device_type is LJMCommunicationConfig.DeviceType.T7_PRO
-
-    with pytest.raises(ValueError):
-        LJMCommunicationConfig(connection_type="Gardena")
-    config = LJMCommunicationConfig(connection_type="TCP")
-    assert config.connection_type is LJMCommunicationConfig.ConnectionType.TCP
-
-
-def test_labjack_config_enums():
-    config = LJMCommunicationConfig(device_type=LJMCommunicationConfig.DeviceType.T4)
-    assert config.device_type == "T4"
-    device_type = LJMCommunicationConfig.DeviceType.get_by_p_id(config.device_type.p_id)
-    assert device_type is LJMCommunicationConfig.DeviceType.T4
-    # test device with unambiguous Product ID
-    config = LJMCommunicationConfig(
-        device_type=LJMCommunicationConfig.DeviceType.T7_PRO
-    )
-    assert config.device_type == "T7_PRO"
-    device_types = LJMCommunicationConfig.DeviceType.get_by_p_id(
-        config.device_type.p_id
-    )
-    assert device_types == [
-        LJMCommunicationConfig.DeviceType.T7,
-        LJMCommunicationConfig.DeviceType.T7_PRO,
-    ]
-
-    config = LJMCommunicationConfig(
-        connection_type=LJMCommunicationConfig.ConnectionType.TCP
-    )
-    assert config.connection_type == "TCP"
-
-
-def test_open(testconfig):
-    com = LJMCommunication(testconfig)
-    assert not com.is_open
-    com.open()
-    assert com.is_open
-    com.open()
-    assert com.is_open
-    com.close()
-    assert not com.is_open
-
-    failing_config = dict(testconfig)
-    failing_config["identifier"] = "this_is_an_invalid_identifier"
-    com = LJMCommunication(failing_config)
-    assert not com.is_open
-    with pytest.raises(LJMCommunicationError):
-        com.open()
-    assert not com.is_open
-
-    # opening T7-Pro version works same as opening T7
-    working_config = dict(testconfig)
-    for device_type in ("T7_PRO", LJMCommunicationConfig.DeviceType.T7_PRO):
-        working_config["device_type"] = device_type
-        assert not com.is_open
-        with LJMCommunication(working_config) as com:
-            assert com.is_open
-        assert not com.is_open
-
-
-def test_read_name(com):
-    assert com.read_name("SERIAL_NUMBER") == 0.0
-    assert com.read_name("SERIAL_NUMBER", "SERIAL_NUMBER") == [0.0, 0.0]
-    sn_int = com.read_name("SERIAL_NUMBER", return_num_type=int)
-    assert isinstance(sn_int, int) and sn_int == 0
-
-    with pytest.raises(TypeError):
-        com.read_name(123)
-
-
-def test_write_name(com):
-    # Attention:
-    # > With demo mode, functions like LJM_eReadNames return meaningless values. Future
-    # > versions of LJM might return different values.
-    com.write_name("test", 10)
-    assert com.read_name("test") == 0.0
-
-    with pytest.raises(LJMCommunicationError):
-        com.write_name("blah", 0)
-
-    com.write_names({"DAC0": 1, "AIN0": 2})
-    read_values = com.read_name("DAC0", "AIN0")
-    assert isinstance(read_values, abc.Sequence) and len(read_values) == 2
-
-    with pytest.raises(LJMCommunicationError):
-        com.write_names({"blah": 0})
-
-    with pytest.raises(TypeError):
-        com.write_name(123, 456)
-
-    with pytest.raises(TypeError):
-        com.write_names({123: 456})
-
-
-# def test_write_address(com):
-#     with pytest.raises(LJMCommunicationError):
-#         com.write_address(1234, 5678)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the .comm.labjack_ljm subpackage.
+"""
+
+import logging
+from collections import abc
+
+import pytest
+
+from hvl_ccb.comm import (
+    LJMCommunication,
+    LJMCommunicationConfig,
+    LJMCommunicationError,
+)
+
+logging.disable(logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def testconfig():
+    return {
+        # identifier = -2 specifies LJM DEMO mode, see
+        # https://labjack.com/support/software/api/ljm/demo-mode
+        # however `ljm.getHandleInfo(-2)` raises
+        # `LJMError: LJM library error code 1224 LJME_DEVICE_NOT_OPEN`
+        "identifier": "-2"
+    }
+
+
+@pytest.fixture
+def com(testconfig):
+    with LJMCommunication(testconfig) as com:
+        yield com
+
+
+def test_labjack_config_cleaning():
+    with pytest.raises(ValueError):
+        LJMCommunicationConfig(device_type="T5")
+
+    with pytest.raises(ValueError):
+        LJMCommunicationConfig(device_type="T7-Pro")
+    config = LJMCommunicationConfig(device_type="T7_PRO")
+    assert config.device_type is LJMCommunicationConfig.DeviceType.T7_PRO
+
+    with pytest.raises(ValueError):
+        LJMCommunicationConfig(connection_type="Gardena")
+    config = LJMCommunicationConfig(connection_type="TCP")
+    assert config.connection_type is LJMCommunicationConfig.ConnectionType.TCP
+
+
+def test_labjack_config_enums():
+    config = LJMCommunicationConfig(device_type=LJMCommunicationConfig.DeviceType.T4)
+    assert config.device_type == "T4"
+    device_type = LJMCommunicationConfig.DeviceType.get_by_p_id(config.device_type.p_id)
+    assert device_type is LJMCommunicationConfig.DeviceType.T4
+    # test device with unambiguous Product ID
+    config = LJMCommunicationConfig(
+        device_type=LJMCommunicationConfig.DeviceType.T7_PRO
+    )
+    assert config.device_type == "T7_PRO"
+    device_types = LJMCommunicationConfig.DeviceType.get_by_p_id(
+        config.device_type.p_id
+    )
+    assert device_types == [
+        LJMCommunicationConfig.DeviceType.T7,
+        LJMCommunicationConfig.DeviceType.T7_PRO,
+    ]
+
+    config = LJMCommunicationConfig(
+        connection_type=LJMCommunicationConfig.ConnectionType.TCP
+    )
+    assert config.connection_type == "TCP"
+
+
+def test_open(testconfig):
+    com = LJMCommunication(testconfig)
+    assert not com.is_open
+    com.open()
+    assert com.is_open
+    com.open()
+    assert com.is_open
+    com.close()
+    assert not com.is_open
+
+    failing_config = dict(testconfig)
+    failing_config["identifier"] = "this_is_an_invalid_identifier"
+    com = LJMCommunication(failing_config)
+    assert not com.is_open
+    with pytest.raises(LJMCommunicationError):
+        com.open()
+    assert not com.is_open
+
+    # opening T7-Pro version works same as opening T7
+    working_config = dict(testconfig)
+    for device_type in ("T7_PRO", LJMCommunicationConfig.DeviceType.T7_PRO):
+        working_config["device_type"] = device_type
+        assert not com.is_open
+        with LJMCommunication(working_config) as com:
+            assert com.is_open
+        assert not com.is_open
+
+
+def test_read_name(com):
+    assert com.read_name("SERIAL_NUMBER") == 0.0
+    assert com.read_name("SERIAL_NUMBER", "SERIAL_NUMBER") == [0.0, 0.0]
+    sn_int = com.read_name("SERIAL_NUMBER", return_num_type=int)
+    assert isinstance(sn_int, int) and sn_int == 0
+
+    with pytest.raises(TypeError):
+        com.read_name(123)
+
+
+def test_write_name(com):
+    # Attention:
+    # > With demo mode, functions like LJM_eReadNames return meaningless values. Future
+    # > versions of LJM might return different values.
+    com.write_name("test", 10)
+    assert com.read_name("test") == 0.0
+
+    with pytest.raises(LJMCommunicationError):
+        com.write_name("blah", 0)
+
+    com.write_names({"DAC0": 1, "AIN0": 2})
+    read_values = com.read_name("DAC0", "AIN0")
+    assert isinstance(read_values, abc.Sequence) and len(read_values) == 2
+
+    with pytest.raises(LJMCommunicationError):
+        com.write_names({"blah": 0})
+
+    with pytest.raises(TypeError):
+        com.write_name(123, 456)
+
+    with pytest.raises(TypeError):
+        com.write_names({123: 456})
+
+
+# def test_write_address(com):
+#     with pytest.raises(LJMCommunicationError):
+#         com.write_address(1234, 5678)
```

### Comparing `hvl_ccb-0.8.5/tests/test_comm_opcua.py` & `hvl_ccb-0.9.0/tests/test_comm_opcua.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,238 +1,233 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the OPC UA communication protocol.
-"""
-
-from time import sleep
-from typing import Type
-
-import pytest
-from pytest_mock import MockerFixture
-
-from hvl_ccb.comm import (
-    OpcUaCommunication,
-    OpcUaCommunicationConfig,
-    OpcUaCommunicationIOError,
-    OpcUaCommunicationTimeoutError,
-    OpcUaSubHandler,
-)
-from opctools import DemoServer
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "host": "localhost",
-        "port": 14125,
-        "endpoint_name": "",
-        "sub_handler": MySubHandler(),
-        "update_period": 10,
-        "wait_timeout_retry_sec": 0.01,
-        "max_timeout_retry_nr": 3,
-    }
-
-
-def test_com_config(com_config):
-    # test default values
-    config = OpcUaCommunicationConfig(**{
-        key: com_config[key] for key in OpcUaCommunicationConfig.required_keys()
-    })
-    for key, value in OpcUaCommunicationConfig.optional_defaults().items():
-        assert getattr(config, key) == value
-
-    # test setting test values
-    config = OpcUaCommunicationConfig(**com_config)
-    for key, value in com_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"update_period": -100},
-        {"update_period": 0},
-        {"wait_timeout_retry_sec": -0.01},
-        {"wait_timeout_retry_sec": 0},
-        {"max_timeout_retry_nr": -1},
-    ],
-)
-def test_invalid_config_dict(com_config, wrong_config_dict):
-    invalid_config = dict(com_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        OpcUaCommunicationConfig(**invalid_config)
-
-
-@pytest.fixture(scope="function")
-def demo_opcua_server():
-    opcua_server = DemoServer(100, "x", 14125)
-    opcua_server.start()
-
-    yield opcua_server
-
-    opcua_server.stop()
-
-
-@pytest.fixture(scope="function")
-def connected_comm_protocol(com_config, demo_opcua_server):
-    opc_comm = OpcUaCommunication(com_config)
-    opc_comm.open()
-    yield opc_comm
-    opc_comm.close()
-
-
-class MySubHandler(OpcUaSubHandler):
-    def __init__(self):
-        self.change_counter = 0
-
-    def datachange_notification(self, node, val, data):
-        super().datachange_notification(node, val, data)
-        print(node, val, data)
-        self.change_counter += 1
-
-
-def test_opcua_open_close(com_config, demo_opcua_server):
-    # comm I/O errors on open
-    config_dict = dict(com_config)
-    for config_key, wrong_value in (
-        ("host", "Not a host"),
-        ("port", 0),
-    ):
-        config_dict[config_key] = wrong_value
-        opc_comm = OpcUaCommunication(config_dict)
-        assert opc_comm is not None
-
-        assert not opc_comm.is_open
-        with pytest.raises(OpcUaCommunicationIOError):
-            opc_comm.open()
-        assert not opc_comm.is_open
-
-    # successful open and close
-    opc_comm = OpcUaCommunication(com_config)
-    assert opc_comm is not None
-
-    try:
-        assert not opc_comm.is_open
-        opc_comm.open()
-        assert opc_comm.is_open
-    finally:
-        opc_comm.close()
-        assert not opc_comm.is_open
-
-
-def test_read(connected_comm_protocol, demo_opcua_server):
-    demo_opcua_server.add_var("testvar_read", 1.23, True)
-    assert connected_comm_protocol.read("testvar_read", 100) == 1.23
-
-
-def test_write_read(com_config, demo_opcua_server):
-    demo_opcua_server.add_var("testvar_write", 1.23, True)
-
-    comm_protocol = OpcUaCommunication(com_config)
-
-    with pytest.raises(OpcUaCommunicationIOError):
-        comm_protocol.write("testvar_write", 100, 2.04)
-    with pytest.raises(OpcUaCommunicationIOError):
-        comm_protocol.read("testvar_write", 100)
-
-    comm_protocol.open()
-    try:
-        comm_protocol.write("testvar_write", 100, 2.04)
-        assert comm_protocol.read("testvar_write", 100) == 2.04
-    finally:
-        comm_protocol.close()
-
-
-def _test_write_client_error(
-    raised_error: Type[Exception], expected_error: Type[OpcUaCommunicationIOError],
-    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
-):
-    comm_protocol = OpcUaCommunication(com_config)
-
-    comm_protocol.open()
-
-    # patch UASocketClient.send_request to raise a mock TimeoutError as if coming from
-    # used therein concurrent.futures.Future
-
-    # Use bound method (otherwise live unpatch does not work):
-    send_request_orig = comm_protocol._client.uaclient._uasocket.send_request
-
-    def send_request(self, request, callback=None, **kwargs):
-        if not callback:
-            raise raised_error("mock error")
-        # method already bound - ignore `self`
-        return send_request_orig(request, callback, **kwargs)
-
-    mocker.patch(
-        "opcua.client.ua_client.UASocketClient.send_request",
-        side_effect=send_request,
-        autospec=True,
-    )
-
-    # check error caught and wrapped
-
-    with pytest.raises(expected_error):
-        comm_protocol.write("testvar_write", 100, 2.04)
-
-    # comm is closed already on re-tries fails, but should be idempotent
-
-    mocker.patch(
-        "opcua.client.ua_client.UASocketClient.send_request",
-        side_effect=send_request_orig,
-    )
-
-    comm_protocol.close()
-
-
-def test_write_timeout_error(
-    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
-):
-    from concurrent.futures import TimeoutError
-    _test_write_client_error(
-        TimeoutError, OpcUaCommunicationTimeoutError,
-        com_config, demo_opcua_server, mocker,
-    )
-
-
-def test_write_cancelled_error(
-    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
-):
-    from concurrent.futures import CancelledError
-    _test_write_client_error(
-        CancelledError, OpcUaCommunicationIOError,
-        com_config, demo_opcua_server, mocker,
-    )
-
-
-def test_init_monitored_nodes(com_config, demo_opcua_server):
-    demo_opcua_server.add_var("mon1", 0, False)
-    demo_opcua_server.add_var("mon2", 0, False)
-    demo_opcua_server.add_var("mon3", 0, False)
-
-    comm_protocol = OpcUaCommunication(com_config)
-
-    with pytest.raises(OpcUaCommunicationIOError):
-        comm_protocol.init_monitored_nodes("mon1", 100)
-    with pytest.raises(OpcUaCommunicationIOError):
-        comm_protocol.init_monitored_nodes(["mon2", "mon3"], 100)
-
-    comm_protocol.open()
-    try:
-        comm_protocol.init_monitored_nodes("mon1", 100)
-        comm_protocol.init_monitored_nodes(["mon2", "mon3"], 100)
-    finally:
-        comm_protocol.close()
-
-
-def test_datachange(connected_comm_protocol, demo_opcua_server):
-    demo_opcua_server.add_var("test_datachange", 0.1, True)
-    connected_comm_protocol.init_monitored_nodes("test_datachange", 100)
-    sleep(0.05)
-
-    counter_before = connected_comm_protocol._sub_handler.change_counter
-    demo_opcua_server.set_var("test_datachange", 0.2)
-    assert demo_opcua_server.get_var("test_datachange") == 0.2
-    sleep(0.05)
-    counter_after = connected_comm_protocol._sub_handler.change_counter
-    assert counter_after == counter_before + 1
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the OPC UA communication protocol.
+"""
+
+from time import sleep
+from typing import Type
+
+import pytest
+from pytest_mock import MockerFixture
+
+from hvl_ccb.comm import (
+    OpcUaCommunication,
+    OpcUaCommunicationConfig,
+    OpcUaCommunicationIOError,
+    OpcUaCommunicationTimeoutError,
+    OpcUaSubHandler,
+)
+from opctools import DemoServer
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "host": "127.0.0.1",
+        "port": 14125,
+        "endpoint_name": "",
+        "sub_handler": MySubHandler(),
+        "update_period": 10,
+        "wait_timeout_retry_sec": 0.01,
+        "max_timeout_retry_nr": 3,
+    }
+
+
+def test_com_config(com_config):
+    # test default values
+    config = OpcUaCommunicationConfig(**{
+        key: com_config[key] for key in OpcUaCommunicationConfig.required_keys()
+    })
+    for key, value in OpcUaCommunicationConfig.optional_defaults().items():
+        assert getattr(config, key) == value
+
+    # test setting test values
+    config = OpcUaCommunicationConfig(**com_config)
+    for key, value in com_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"update_period": -100},
+        {"update_period": 0},
+        {"wait_timeout_retry_sec": -0.01},
+        {"wait_timeout_retry_sec": 0},
+        {"max_timeout_retry_nr": -1},
+    ],
+)
+def test_invalid_config_dict(com_config, wrong_config_dict):
+    invalid_config = dict(com_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        OpcUaCommunicationConfig(**invalid_config)
+
+
+@pytest.fixture(scope="function")
+def demo_opcua_server():
+    opcua_server = DemoServer(100, "x", 14125)
+    opcua_server.start()
+
+    yield opcua_server
+
+    opcua_server.stop()
+
+
+@pytest.fixture(scope="function")
+def connected_comm_protocol(com_config, demo_opcua_server):
+    opc_comm = OpcUaCommunication(com_config)
+    opc_comm.open()
+    yield opc_comm
+    opc_comm.close()
+
+
+class MySubHandler(OpcUaSubHandler):
+    def __init__(self):
+        self.change_counter = 0
+
+    def datachange_notification(self, node, val, data):
+        super().datachange_notification(node, val, data)
+        print(node, val, data)
+        self.change_counter += 1
+
+
+def test_opcua_open_close(com_config, demo_opcua_server):
+    # comm I/O errors on open
+    config_dict = dict(com_config)
+    for config_key, wrong_value in (
+        ("host", "Not a host"),
+        ("port", 0),
+    ):
+        config_dict[config_key] = wrong_value
+        with pytest.raises(ValueError):
+            OpcUaCommunication(config_dict)
+
+    # successful open and close
+    opc_comm = OpcUaCommunication(com_config)
+    assert opc_comm is not None
+
+    try:
+        assert not opc_comm.is_open
+        opc_comm.open()
+        assert opc_comm.is_open
+    finally:
+        opc_comm.close()
+        assert not opc_comm.is_open
+
+
+def test_read(connected_comm_protocol, demo_opcua_server):
+    demo_opcua_server.add_var("testvar_read", 1.23, True)
+    assert connected_comm_protocol.read("testvar_read", 100) == 1.23
+
+
+def test_write_read(com_config, demo_opcua_server):
+    demo_opcua_server.add_var("testvar_write", 1.23, True)
+
+    comm_protocol = OpcUaCommunication(com_config)
+
+    with pytest.raises(OpcUaCommunicationIOError):
+        comm_protocol.write("testvar_write", 100, 2.04)
+    with pytest.raises(OpcUaCommunicationIOError):
+        comm_protocol.read("testvar_write", 100)
+
+    comm_protocol.open()
+    try:
+        comm_protocol.write("testvar_write", 100, 2.04)
+        assert comm_protocol.read("testvar_write", 100) == 2.04
+    finally:
+        comm_protocol.close()
+
+
+def _test_write_client_error(
+    raised_error: Type[Exception], expected_error: Type[OpcUaCommunicationIOError],
+    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
+):
+    comm_protocol = OpcUaCommunication(com_config)
+
+    comm_protocol.open()
+
+    # patch UASocketClient.send_request to raise a mock TimeoutError as if coming from
+    # used therein concurrent.futures.Future
+
+    # Use bound method (otherwise live unpatch does not work):
+    send_request_orig = comm_protocol._client.uaclient._uasocket.send_request
+
+    def send_request(self, request, callback=None, **kwargs):
+        if not callback:
+            raise raised_error("mock error")
+        # method already bound - ignore `self`
+        return send_request_orig(request, callback, **kwargs)
+
+    mocker.patch(
+        "opcua.client.ua_client.UASocketClient.send_request",
+        side_effect=send_request,
+        autospec=True,
+    )
+
+    # check error caught and wrapped
+
+    with pytest.raises(expected_error):
+        comm_protocol.write("testvar_write", 100, 2.04)
+
+    # comm is closed already on re-tries fails, but should be idempotent
+
+    mocker.patch(
+        "opcua.client.ua_client.UASocketClient.send_request",
+        side_effect=send_request_orig,
+    )
+
+    comm_protocol.close()
+
+
+def test_write_timeout_error(
+    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
+):
+    from concurrent.futures import TimeoutError
+    _test_write_client_error(
+        TimeoutError, OpcUaCommunicationTimeoutError,
+        com_config, demo_opcua_server, mocker,
+    )
+
+
+def test_write_cancelled_error(
+    com_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
+):
+    from concurrent.futures import CancelledError
+    _test_write_client_error(
+        CancelledError, OpcUaCommunicationIOError,
+        com_config, demo_opcua_server, mocker,
+    )
+
+
+def test_init_monitored_nodes(com_config, demo_opcua_server):
+    demo_opcua_server.add_var("mon1", 0, False)
+    demo_opcua_server.add_var("mon2", 0, False)
+    demo_opcua_server.add_var("mon3", 0, False)
+
+    comm_protocol = OpcUaCommunication(com_config)
+
+    with pytest.raises(OpcUaCommunicationIOError):
+        comm_protocol.init_monitored_nodes("mon1", 100)
+    with pytest.raises(OpcUaCommunicationIOError):
+        comm_protocol.init_monitored_nodes(["mon2", "mon3"], 100)
+
+    comm_protocol.open()
+    try:
+        comm_protocol.init_monitored_nodes("mon1", 100)
+        comm_protocol.init_monitored_nodes(["mon2", "mon3"], 100)
+    finally:
+        comm_protocol.close()
+
+
+def test_datachange(connected_comm_protocol, demo_opcua_server):
+    demo_opcua_server.add_var("test_datachange", 0.1, True)
+    connected_comm_protocol.init_monitored_nodes("test_datachange", 100)
+    sleep(0.05)
+
+    counter_before = connected_comm_protocol._sub_handler.change_counter
+    demo_opcua_server.set_var("test_datachange", 0.2)
+    assert demo_opcua_server.get_var("test_datachange") == 0.2
+    sleep(0.05)
+    counter_after = connected_comm_protocol._sub_handler.change_counter
+    assert counter_after == counter_before + 1
```

### Comparing `hvl_ccb-0.8.5/tests/test_comm_serial.py` & `hvl_ccb-0.9.0/tests/test_comm_serial.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,184 +1,184 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for .comm sub-package
-"""
-import time
-
-import pytest
-
-from hvl_ccb.comm import (
-    SerialCommunication,
-    SerialCommunicationConfig,
-    SerialCommunicationIOError,
-)
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 115200,
-        "parity": SerialCommunicationConfig.Parity.NONE,
-        "stopbits": SerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": SerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 0.2,
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 5,
-    }
-
-
-def test_com_config(com_config):
-    config = SerialCommunicationConfig(**com_config)
-    for key, value in com_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"parity": "B"},
-        {"stopbits": 2.5},
-        {"bytesize": 9},
-        {"timeout": -1},
-        {"wait_sec_read_text_nonempty": 0},
-        {"wait_sec_read_text_nonempty": -1},
-        {"default_n_attempts_read_text_nonempty": 0},
-        {"default_n_attempts_read_text_nonempty": -1},
-    ],
-)
-def test_invalid_config_dict(com_config, wrong_config_dict):
-    invalid_config = dict(com_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        SerialCommunicationConfig(**invalid_config)
-
-
-def _decode_terminator(com_config):
-    return SerialCommunicationConfig(**com_config).terminator.decode(
-        SerialCommunicationConfig.encoding
-    )
-
-
-def test_timeout(com_config):
-    with SerialCommunication(com_config) as sc:
-        started_at = time.time()
-        assert sc.read() == ""
-        elapsed = time.time() - started_at
-        timeout = com_config["timeout"]
-        assert elapsed >= timeout
-        assert elapsed < 1.25 * timeout
-
-
-def _test_loop_serial_communication_text(com_config, sc):
-    # send some text
-    test_strings = [
-        "Test message 1",
-        "testmessage2",
-        "190testmessage: 3",
-    ]
-
-    for t in test_strings:
-        # send line
-        sc.write(t)
-        # read back line
-        answer = sc.read()
-        assert answer == t + _decode_terminator(com_config)
-
-
-def _test_loop_serial_communication_bytes(com_config, sc):
-    # send some bytes
-    test_bytes = [
-        b"Test message 1",
-        b"testmessage2",
-        b"190testmessage: 3",
-    ]
-
-    for d in test_bytes:
-        # send line
-        sc.write_bytes(d)
-        # read back bytes
-        answer = sc.read_bytes()
-        assert answer == d
-
-
-def test_serial_open_error(com_config):
-
-    config_dict = dict(com_config)
-    config_dict["port"] = "12345666"
-    com = SerialCommunication(config_dict)
-    with pytest.raises(SerialCommunicationIOError):
-        com.open()
-
-
-def test_serial_open_write_read_close(com_config):
-    """
-    Tests SerialCommunication
-    """
-
-    # manually open/close port
-    sc = SerialCommunication(com_config)
-    assert sc is not None
-    assert not sc.is_open
-    sc.open()
-    assert sc.is_open
-    sc.open()  # no error when re-opening an open port
-    _test_loop_serial_communication_text(com_config, sc)
-    _test_loop_serial_communication_bytes(com_config, sc)
-    sc.close()
-    assert not sc.is_open
-
-    # or use with statement
-    with SerialCommunication(com_config) as sc:
-        assert sc is not None
-        assert sc.is_open
-        _test_loop_serial_communication_text(com_config, sc)
-
-
-def test_serial_write_read_error(com_config):
-
-    sc = SerialCommunication(com_config)
-
-    # port not opened => errors
-    assert not sc.is_open
-    with pytest.raises(SerialCommunicationIOError):
-        sc.write("anything")
-    with pytest.raises(SerialCommunicationIOError):
-        sc.read()
-    with pytest.raises(SerialCommunicationIOError):
-        sc.write_bytes(b"anything")
-    with pytest.raises(SerialCommunicationIOError):
-        sc.read_bytes()
-
-    # nothing to read => empty output
-    sc.open()
-    assert sc.is_open
-    assert sc.read() == ""
-    assert sc.read_bytes() == b""
-
-
-def test_serial_read_nonempty(com_config):
-    # manually open/close port
-    sc = SerialCommunication(com_config)
-    sc.open()
-    # send some text
-    test_strings = [
-        "Test message 1",
-        "",
-        "",
-        "testmessage2",
-        "",
-        "190testmessage: 3",
-    ]
-
-    for t in test_strings:
-        # send line
-        sc.write(t)
-        if t:
-            # read back all previous empty lines until the non-empty one appears
-            answer = sc.read_nonempty()
-            assert answer == t
-        else:
-            answer = sc.read_nonempty()
-            assert answer is None
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for .comm sub-package
+"""
+import time
+
+import pytest
+
+from hvl_ccb.comm import (
+    SerialCommunication,
+    SerialCommunicationConfig,
+    SerialCommunicationIOError,
+)
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 115200,
+        "parity": SerialCommunicationConfig.Parity.NONE,
+        "stopbits": SerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": SerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 0.2,
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 5,
+    }
+
+
+def test_com_config(com_config):
+    config = SerialCommunicationConfig(**com_config)
+    for key, value in com_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"parity": "B"},
+        {"stopbits": 2.5},
+        {"bytesize": 9},
+        {"timeout": -1},
+        {"wait_sec_read_text_nonempty": 0},
+        {"wait_sec_read_text_nonempty": -1},
+        {"default_n_attempts_read_text_nonempty": 0},
+        {"default_n_attempts_read_text_nonempty": -1},
+    ],
+)
+def test_invalid_config_dict(com_config, wrong_config_dict):
+    invalid_config = dict(com_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        SerialCommunicationConfig(**invalid_config)
+
+
+def _decode_terminator(com_config):
+    return SerialCommunicationConfig(**com_config).terminator.decode(
+        SerialCommunicationConfig.encoding
+    )
+
+
+def test_timeout(com_config):
+    with SerialCommunication(com_config) as sc:
+        started_at = time.time()
+        assert sc.read() == ""
+        elapsed = time.time() - started_at
+        timeout = com_config["timeout"]
+        assert elapsed >= timeout
+        assert elapsed < 1.25 * timeout
+
+
+def _test_loop_serial_communication_text(com_config, sc):
+    # send some text
+    test_strings = [
+        "Test message 1",
+        "testmessage2",
+        "190testmessage: 3",
+    ]
+
+    for t in test_strings:
+        # send line
+        sc.write(t)
+        # read back line
+        answer = sc.read()
+        assert answer == t + _decode_terminator(com_config)
+
+
+def _test_loop_serial_communication_bytes(com_config, sc):
+    # send some bytes
+    test_bytes = [
+        b"Test message 1",
+        b"testmessage2",
+        b"190testmessage: 3",
+    ]
+
+    for d in test_bytes:
+        # send line
+        sc.write_bytes(d)
+        # read back bytes
+        answer = sc.read_bytes()
+        assert answer == d
+
+
+def test_serial_open_error(com_config):
+
+    config_dict = dict(com_config)
+    config_dict["port"] = "12345666"
+    com = SerialCommunication(config_dict)
+    with pytest.raises(SerialCommunicationIOError):
+        com.open()
+
+
+def test_serial_open_write_read_close(com_config):
+    """
+    Tests SerialCommunication
+    """
+
+    # manually open/close port
+    sc = SerialCommunication(com_config)
+    assert sc is not None
+    assert not sc.is_open
+    sc.open()
+    assert sc.is_open
+    sc.open()  # no error when re-opening an open port
+    _test_loop_serial_communication_text(com_config, sc)
+    _test_loop_serial_communication_bytes(com_config, sc)
+    sc.close()
+    assert not sc.is_open
+
+    # or use with statement
+    with SerialCommunication(com_config) as sc:
+        assert sc is not None
+        assert sc.is_open
+        _test_loop_serial_communication_text(com_config, sc)
+
+
+def test_serial_write_read_error(com_config):
+
+    sc = SerialCommunication(com_config)
+
+    # port not opened => errors
+    assert not sc.is_open
+    with pytest.raises(SerialCommunicationIOError):
+        sc.write("anything")
+    with pytest.raises(SerialCommunicationIOError):
+        sc.read()
+    with pytest.raises(SerialCommunicationIOError):
+        sc.write_bytes(b"anything")
+    with pytest.raises(SerialCommunicationIOError):
+        sc.read_bytes()
+
+    # nothing to read => empty output
+    sc.open()
+    assert sc.is_open
+    assert sc.read() == ""
+    assert sc.read_bytes() == b""
+
+
+def test_serial_read_nonempty(com_config):
+    # manually open/close port
+    sc = SerialCommunication(com_config)
+    sc.open()
+    # send some text
+    test_strings = [
+        "Test message 1",
+        "",
+        "",
+        "testmessage2",
+        "",
+        "190testmessage: 3",
+    ]
+
+    for t in test_strings:
+        # send line
+        sc.write(t)
+        if t:
+            # read back all previous empty lines until the non-empty one appears
+            answer = sc.read_nonempty()
+            assert answer == t
+        else:
+            answer = sc.read_nonempty()
+            assert answer is None
```

### Comparing `hvl_ccb-0.8.5/tests/test_comm_visa.py` & `hvl_ccb-0.9.0/tests/test_comm_visa.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,118 +1,115 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the VISA CommunicationProtocol.
-"""
-
-import dataclasses
-
-import pytest
-
-from hvl_ccb.comm import (
-    VisaCommunication,
-    VisaCommunicationError,
-    VisaCommunicationConfig,
-)
-
-
-@pytest.fixture(scope='module')
-def testconfig_instr():
-    return VisaCommunicationConfig(
-        interface_type=VisaCommunicationConfig.InterfaceType.TCPIP_INSTR,
-        host='127.0.0.1',
-        open_timeout=1,
-    )
-
-
-@pytest.fixture(scope='module')
-def testconfig_socket():
-    return VisaCommunicationConfig(
-        interface_type=VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET,
-        host='127.0.0.1',
-        open_timeout=1,
-    )
-
-
-def test_visa_config(testconfig_instr, testconfig_socket):
-    vcom = VisaCommunication(testconfig_instr)
-    assert vcom is not None
-
-    # test string value for interface_type
-    vcom = VisaCommunication(
-        dataclasses.replace(testconfig_instr, interface_type='TCPIP_INSTR')
-    )
-    assert vcom.config.interface_type == testconfig_instr.interface_type
-
-    vcom = VisaCommunication(testconfig_socket)
-    assert vcom is not None
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, host='localhost')
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, board=-1)
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, timeout=-1)
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, open_timeout=-1)
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, write_termination='bla')
-
-    with pytest.raises(ValueError):
-        dataclasses.replace(testconfig_instr, read_termination='\n\r')
-
-
-def test_visa_open_close(testconfig_instr):
-    vcom_default_backend = VisaCommunication(testconfig_instr)
-
-    # AttributeError should be caught
-    vcom_default_backend.close()
-
-    # open should raise a communication error, here from visa.VisaIOError
-    with pytest.raises(VisaCommunicationError):
-        vcom_default_backend.open()
-
-    # test with pyvisa-py as backend (this will run on GitLab runners, as NI-VISA is
-    # not installed there
-    pyvisa_py_config = dataclasses.replace(testconfig_instr, visa_backend='@py')
-    vcom_pyvisa_py_backend = VisaCommunication(pyvisa_py_config)
-
-    with pytest.raises(VisaCommunicationError):
-        vcom_pyvisa_py_backend.open()
-
-
-def test_generate_cmd_string():
-    assert VisaCommunication._generate_cmd_string(('cmd1', 'cmd2')) == \
-        'cmd1' + VisaCommunication.MULTI_COMMANDS_SEPARATOR + 'cmd2'
-
-    with pytest.raises(VisaCommunicationError):
-        VisaCommunication._generate_cmd_string(
-            tuple(
-                [f'cmd{i}'
-                 for i in range(0, VisaCommunication.MULTI_COMMANDS_MAX + 1)]
-            )
-        )
-
-
-def test_read_write(testconfig_socket):
-    com_socket = VisaCommunication(testconfig_socket)
-
-    with pytest.raises(VisaCommunicationError):
-        com_socket.write('bla')
-
-    with pytest.raises(VisaCommunicationError):
-        com_socket.query('bla')
-
-
-def test_spoll(testconfig_socket, testconfig_instr):
-    com_socket = VisaCommunication(testconfig_socket)
-    com_instr = VisaCommunication(testconfig_instr)
-
-    with pytest.raises(VisaCommunicationError):
-        com_socket.spoll()
-
-    with pytest.raises(VisaCommunicationError):
-        com_instr.spoll()
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the VISA CommunicationProtocol.
+"""
+
+import dataclasses
+
+import pytest
+
+from hvl_ccb.comm import (
+    VisaCommunication,
+    VisaCommunicationError,
+    VisaCommunicationConfig,
+)
+
+
+@pytest.fixture(scope='module')
+def testconfig_instr():
+    return VisaCommunicationConfig(
+        interface_type=VisaCommunicationConfig.InterfaceType.TCPIP_INSTR,
+        host='127.0.0.1',
+        open_timeout=1,
+    )
+
+
+@pytest.fixture(scope='module')
+def testconfig_socket():
+    return VisaCommunicationConfig(
+        interface_type=VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET,
+        host='127.0.0.1',
+        open_timeout=1,
+    )
+
+
+def test_visa_config(testconfig_instr, testconfig_socket):
+    vcom = VisaCommunication(testconfig_instr)
+    assert vcom is not None
+
+    # test string value for interface_type
+    vcom = VisaCommunication(
+        dataclasses.replace(testconfig_instr, interface_type='TCPIP_INSTR')
+    )
+    assert vcom.config.interface_type == testconfig_instr.interface_type
+
+    vcom = VisaCommunication(testconfig_socket)
+    assert vcom is not None
+
+    with pytest.raises(ValueError):
+        dataclasses.replace(testconfig_instr, board=-1)
+
+    with pytest.raises(ValueError):
+        dataclasses.replace(testconfig_instr, timeout=-1)
+
+    with pytest.raises(ValueError):
+        dataclasses.replace(testconfig_instr, open_timeout=-1)
+
+    with pytest.raises(ValueError):
+        dataclasses.replace(testconfig_instr, write_termination='bla')
+
+    with pytest.raises(ValueError):
+        dataclasses.replace(testconfig_instr, read_termination='\n\r')
+
+
+def test_visa_open_close(testconfig_instr):
+    vcom_default_backend = VisaCommunication(testconfig_instr)
+
+    # AttributeError should be caught
+    vcom_default_backend.close()
+
+    # open should raise a communication error, here from visa.VisaIOError
+    with pytest.raises(VisaCommunicationError):
+        vcom_default_backend.open()
+
+    # test with pyvisa-py as backend (this will run on GitLab runners, as NI-VISA is
+    # not installed there
+    pyvisa_py_config = dataclasses.replace(testconfig_instr, visa_backend='@py')
+    vcom_pyvisa_py_backend = VisaCommunication(pyvisa_py_config)
+
+    with pytest.raises(VisaCommunicationError):
+        vcom_pyvisa_py_backend.open()
+
+
+def test_generate_cmd_string():
+    assert VisaCommunication._generate_cmd_string(('cmd1', 'cmd2')) == \
+        'cmd1' + VisaCommunication.MULTI_COMMANDS_SEPARATOR + 'cmd2'
+
+    with pytest.raises(VisaCommunicationError):
+        VisaCommunication._generate_cmd_string(
+            tuple(
+                [f'cmd{i}'
+                 for i in range(0, VisaCommunication.MULTI_COMMANDS_MAX + 1)]
+            )
+        )
+
+
+def test_read_write(testconfig_socket):
+    com_socket = VisaCommunication(testconfig_socket)
+
+    with pytest.raises(VisaCommunicationError):
+        com_socket.write('bla')
+
+    with pytest.raises(VisaCommunicationError):
+        com_socket.query('bla')
+
+
+def test_spoll(testconfig_socket, testconfig_instr):
+    com_socket = VisaCommunication(testconfig_socket)
+    com_instr = VisaCommunication(testconfig_instr)
+
+    with pytest.raises(VisaCommunicationError):
+        com_socket.spoll()
+
+    with pytest.raises(VisaCommunicationError):
+        com_instr.spoll()
```

### Comparing `hvl_ccb-0.8.5/tests/test_configuration.py` & `hvl_ccb-0.9.0/tests/test_configuration.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,188 +1,188 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for configuration.py: Mixin and class decorator configdataclass
-"""
-
-import os
-from typing import List, Union
-
-import pytest
-
-from hvl_ccb.configuration import ConfigurationMixin, configdataclass, EmptyConfig
-
-
-@configdataclass
-class GenericTypeHintsConfiguration:
-    field1: List
-    field2: List[int]
-    field3: list
-
-
-@configdataclass
-class MyConfiguration:
-    field1: int
-    field2: str = "hello"
-
-    def clean_values(self):
-        if self.field1 == 0:
-            raise ValueError("field1 is not allowed to be 0")
-
-        if self.field2 == "":
-            self.force_value("field2", "EMPTY")
-
-    def post_force_value(self, fieldname, value):
-        self.post_force_value.applied_to.append(fieldname)
-
-    post_force_value.applied_to = []
-
-
-@configdataclass
-class SimpleConfiguration:
-    field1: str = "field1"
-
-
-class MyClassHasConfiguration(ConfigurationMixin):
-    @staticmethod
-    def config_cls():
-        return MyConfiguration
-
-
-# TESTS
-def test_generic_type_hints():
-    GenericTypeHintsConfiguration(["a"], [1], ["a"])
-    with pytest.raises(TypeError):
-        GenericTypeHintsConfiguration(("a",), [1], ["a"])
-    with pytest.raises(TypeError):
-        GenericTypeHintsConfiguration(["a"], [1], ("a",))
-    with pytest.raises(TypeError):
-        GenericTypeHintsConfiguration(["a"], ["a"], ["a"])
-
-
-def test_inheritance():
-    @configdataclass
-    class SubMyConfiguration(MyConfiguration):
-        field1: int = 3
-        field3: int = 5
-
-    assert SubMyConfiguration.optional_defaults() == {
-        "field1": 3,
-        "field2": "hello",
-        "field3": 5,
-    }
-
-    SubMyConfiguration()
-
-    with pytest.raises(AttributeError):
-
-        @configdataclass
-        class SubFailingConfiguration(MyConfiguration):
-            def keys(self):
-                pass
-
-
-def test_configdataclass():
-    SimpleConfiguration()
-
-    # test own clean_values implementation
-    with pytest.raises(ValueError):
-        MyConfiguration(0)
-
-    # test force_value
-    config = MyConfiguration(1, field2="")
-    assert config.field2 == "EMPTY"
-    assert config.post_force_value.applied_to == ["field2"]
-
-    # test convenience functions
-    assert MyConfiguration.optional_defaults() == {"field2": "hello"}
-    assert MyConfiguration.required_keys() == ["field1"]
-    assert MyConfiguration.keys() == ["field1", "field2"]
-
-    # typing is enforced
-    with pytest.raises(TypeError):
-        MyConfiguration("test")
-
-
-def test_configdataclass_with_generic():
-    @configdataclass
-    class ConfigurationWithGeneric:
-        number: Union[int, float]
-
-    with pytest.raises(TypeError):
-        ConfigurationWithGeneric("1")
-    assert ConfigurationWithGeneric(1).number == 1
-    assert ConfigurationWithGeneric(1.0).number == 1.0
-
-
-def test_configdataclass_fromdict():
-    test_config = {"field1": 1, "field2": "otherstring"}
-
-    my_class = MyClassHasConfiguration(test_config)
-    assert my_class.config.field1 == 1
-    assert my_class.config.field2 == "otherstring"
-
-    test_config_2 = {"field3": 3, "field4": 4}
-
-    # superfluous fields are not allowed
-    with pytest.raises(TypeError):
-        MyClassHasConfiguration(test_config_2)
-
-    # non-configdataclasses are not allowed
-    with pytest.raises(TypeError):
-
-        class WrongDefaultConfigDataclass(ConfigurationMixin):
-            @staticmethod
-            def config_cls():
-                class NotAConfigDataclass:
-                    field1: int = 0
-
-                return NotAConfigDataclass
-
-        WrongDefaultConfigDataclass({"field1": 1})
-
-
-def test_empty_config():
-    config = EmptyConfig()
-    assert not config.required_keys()
-    assert not config.keys()
-
-
-def test_configuration_mixin():
-    test_config = MyConfiguration(1)
-    my_class = MyClassHasConfiguration(test_config)
-    assert my_class.config == test_config
-
-    with pytest.raises(TypeError):
-        MyClassHasConfiguration(object)
-
-
-def test_json_save_load():
-    """
-    Test the JSON configuration save and load feature.
-    """
-
-    c = MyClassHasConfiguration({"field1": 1})
-    c.configuration_save_json("test.json")
-
-    # create new protocol from that JSON configuration
-    d = MyClassHasConfiguration.from_json("test.json")
-
-    # clean up, delete file
-    os.remove("test.json")
-
-    assert c.config == d.config
-
-
-def test_unfrozen():
-    @configdataclass(frozen=False)
-    class Test:
-        field1: int = 3
-
-    test = Test()
-    assert test.field1 == 3
-    test.field1 = 5
-    assert test.field1 == 5
-
-    # attention: typing is not enforced!
-    test.field1 = "bla"
-    assert test.field1 == "bla"
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for configuration.py: Mixin and class decorator configdataclass
+"""
+
+import os
+from typing import List, Union
+
+import pytest
+
+from hvl_ccb.configuration import ConfigurationMixin, configdataclass, EmptyConfig
+
+
+@configdataclass
+class GenericTypeHintsConfiguration:
+    field1: List
+    field2: List[int]
+    field3: list
+
+
+@configdataclass
+class MyConfiguration:
+    field1: int
+    field2: str = "hello"
+
+    def clean_values(self):
+        if self.field1 == 0:
+            raise ValueError("field1 is not allowed to be 0")
+
+        if self.field2 == "":
+            self.force_value("field2", "EMPTY")
+
+    def post_force_value(self, fieldname, value):
+        self.post_force_value.applied_to.append(fieldname)
+
+    post_force_value.applied_to = []
+
+
+@configdataclass
+class SimpleConfiguration:
+    field1: str = "field1"
+
+
+class MyClassHasConfiguration(ConfigurationMixin):
+    @staticmethod
+    def config_cls():
+        return MyConfiguration
+
+
+# TESTS
+def test_generic_type_hints():
+    GenericTypeHintsConfiguration(["a"], [1], ["a"])
+    with pytest.raises(TypeError):
+        GenericTypeHintsConfiguration(("a",), [1], ["a"])
+    with pytest.raises(TypeError):
+        GenericTypeHintsConfiguration(["a"], [1], ("a",))
+    with pytest.raises(TypeError):
+        GenericTypeHintsConfiguration(["a"], ["a"], ["a"])
+
+
+def test_inheritance():
+    @configdataclass
+    class SubMyConfiguration(MyConfiguration):
+        field1: int = 3
+        field3: int = 5
+
+    assert SubMyConfiguration.optional_defaults() == {
+        "field1": 3,
+        "field2": "hello",
+        "field3": 5,
+    }
+
+    SubMyConfiguration()
+
+    with pytest.raises(AttributeError):
+
+        @configdataclass
+        class SubFailingConfiguration(MyConfiguration):
+            def keys(self):
+                pass
+
+
+def test_configdataclass():
+    SimpleConfiguration()
+
+    # test own clean_values implementation
+    with pytest.raises(ValueError):
+        MyConfiguration(0)
+
+    # test force_value
+    config = MyConfiguration(1, field2="")
+    assert config.field2 == "EMPTY"
+    assert config.post_force_value.applied_to == ["field2"]
+
+    # test convenience functions
+    assert MyConfiguration.optional_defaults() == {"field2": "hello"}
+    assert MyConfiguration.required_keys() == ["field1"]
+    assert MyConfiguration.keys() == ["field1", "field2"]
+
+    # typing is enforced
+    with pytest.raises(TypeError):
+        MyConfiguration("test")
+
+
+def test_configdataclass_with_generic():
+    @configdataclass
+    class ConfigurationWithGeneric:
+        number: Union[int, float]
+
+    with pytest.raises(TypeError):
+        ConfigurationWithGeneric("1")
+    assert ConfigurationWithGeneric(1).number == 1
+    assert ConfigurationWithGeneric(1.0).number == 1.0
+
+
+def test_configdataclass_fromdict():
+    test_config = {"field1": 1, "field2": "otherstring"}
+
+    my_class = MyClassHasConfiguration(test_config)
+    assert my_class.config.field1 == 1
+    assert my_class.config.field2 == "otherstring"
+
+    test_config_2 = {"field3": 3, "field4": 4}
+
+    # superfluous fields are not allowed
+    with pytest.raises(TypeError):
+        MyClassHasConfiguration(test_config_2)
+
+    # non-configdataclasses are not allowed
+    with pytest.raises(TypeError):
+
+        class WrongDefaultConfigDataclass(ConfigurationMixin):
+            @staticmethod
+            def config_cls():
+                class NotAConfigDataclass:
+                    field1: int = 0
+
+                return NotAConfigDataclass
+
+        WrongDefaultConfigDataclass({"field1": 1})
+
+
+def test_empty_config():
+    config = EmptyConfig()
+    assert not config.required_keys()
+    assert not config.keys()
+
+
+def test_configuration_mixin():
+    test_config = MyConfiguration(1)
+    my_class = MyClassHasConfiguration(test_config)
+    assert my_class.config == test_config
+
+    with pytest.raises(TypeError):
+        MyClassHasConfiguration(object)
+
+
+def test_json_save_load():
+    """
+    Test the JSON configuration save and load feature.
+    """
+
+    c = MyClassHasConfiguration({"field1": 1})
+    c.configuration_save_json("test.json")
+
+    # create new protocol from that JSON configuration
+    d = MyClassHasConfiguration.from_json("test.json")
+
+    # clean up, delete file
+    os.remove("test.json")
+
+    assert c.config == d.config
+
+
+def test_unfrozen():
+    @configdataclass(frozen=False)
+    class Test:
+        field1: int = 3
+
+    test = Test()
+    assert test.field1 == 3
+    test.field1 = 5
+    assert test.field1 == 5
+
+    # attention: typing is not enforced!
+    test.field1 = "bla"
+    assert test.field1 == "bla"
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_base.py` & `hvl_ccb-0.9.0/tests/test_dev_base.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,195 +1,195 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the dev.base module classes.
-"""
-
-from typing import Type
-
-import pytest
-
-from hvl_ccb.comm import NullCommunicationProtocol
-from hvl_ccb.configuration import EmptyConfig
-from hvl_ccb.dev import (
-    Device,
-    DeviceSequenceMixin,
-    DeviceExistingException,
-    DeviceFailuresException,
-    SingleCommDevice,
-)
-
-# make Device instantiable
-Device.__abstractmethods__ = frozenset()
-
-
-class DeviceFailStart(Device):
-    def start(self):
-        raise ValueError("Error during start")
-
-    def stop(self):
-        pass
-
-
-class DeviceFailStop(Device):
-    def start(self):
-        pass
-
-    def stop(self):
-        raise ValueError("Error during start")
-
-
-class DeviceSequence(DeviceSequenceMixin):
-    pass
-
-
-def test_device_sequence_access():
-
-    dev = Device()
-
-    ddict = {"dev": dev}
-
-    dseq = DeviceSequence(ddict)
-
-    assert dseq.get_device("dev") is dev
-
-    for name, device in dseq.get_devices():
-        assert ddict[name] is device
-
-    # same devices, same sequence
-    assert dseq == DeviceSequence(ddict)
-
-    with pytest.raises(ValueError):
-        dseq.remove_device("not there")
-
-    with pytest.raises(DeviceExistingException):
-        dseq.add_device("dev", dev)
-
-    dev2 = Device()
-    dseq.add_device("dev2", dev2)
-    assert dseq.get_device("dev2") is dev2
-    assert dseq != DeviceSequence(ddict)
-
-
-def test_device_sequence_dot_lookup():
-
-    dev1 = Device()
-    dev2 = Device()
-
-    ddict = {
-        "dev1": dev1,
-        "dev2": dev2,
-    }
-
-    seq = DeviceSequence(ddict)
-
-    assert seq.dev1 is dev1
-    assert seq.dev2 is dev2
-
-    # adding device which name over-shadows attr/method
-    with pytest.raises(ValueError):
-        DeviceSequence({"dev1": dev1, "_devices": dev2})
-
-    # adding single device which name over-shadows an attr/method
-    with pytest.raises(ValueError):
-        seq.add_device("start", Device())
-
-
-class NullDevice(SingleCommDevice):
-    @staticmethod
-    def default_com_cls() -> Type[NullCommunicationProtocol]:
-        return NullCommunicationProtocol
-
-    def start(self):
-        pass
-
-    def stop(self):
-        pass
-
-
-def test_null_device():
-    dev_config = EmptyConfig()
-    for arg in (NullCommunicationProtocol({}), EmptyConfig(), {}, None):
-        dev = NullDevice(arg, dev_config=dev_config)
-        assert dev is not None
-        assert isinstance(dev.com.config, EmptyConfig)
-
-    with pytest.raises(TypeError):
-        NullDevice(None, {"extra_key": 0})
-
-
-def test_device_sequence_start():
-
-    # case 1: some devices fail
-    dev1 = Device()
-    dev2 = DeviceFailStart()
-    dev3 = Device()
-    dev4 = DeviceFailStart()
-
-    ddict = {
-        "dev1": dev1,
-        "dev2": dev2,
-        "dev3": dev3,
-        "dev4": dev4,
-    }
-
-    seq = DeviceSequence(ddict)
-    # check that the exception is raised
-    with pytest.raises(DeviceFailuresException) as e:
-        seq.start()
-    # check the exception arguments
-    assert e.value.failures.keys() == seq.devices_failed_start.keys()
-    assert all([isinstance(v, ValueError) for v in e.value.failures.values()])
-
-    assert seq.devices_failed_start == {"dev2": dev2, "dev4": dev4}
-    assert not seq.devices_failed_stop
-
-    # case 2: all devices work
-
-    # removing failing devices
-    seq.remove_device("dev2")
-    seq.remove_device("dev4")
-    assert seq._devices == {"dev1": dev1, "dev3": dev3}
-    assert not seq.devices_failed_start
-
-    seq.start()
-    assert not seq.devices_failed_start
-    assert not seq.devices_failed_stop
-
-
-def test_device_sequence_stop():
-
-    # case 1: some devices fail
-    dev1 = Device()
-    dev2 = DeviceFailStop()
-    dev3 = Device()
-    dev4 = DeviceFailStop()
-
-    ddict = {
-        "dev1": dev1,
-        "dev2": dev2,
-        "dev3": dev3,
-        "dev4": dev4,
-    }
-
-    seq = DeviceSequence(ddict)
-    # check that the exception is raised
-    with pytest.raises(DeviceFailuresException) as e:
-        seq.stop()
-    # check the exception arguments
-    assert e.value.failures.keys() == seq.devices_failed_stop.keys()
-    assert all([isinstance(v, ValueError) for v in e.value.failures.values()])
-
-    assert seq.devices_failed_stop == {"dev2": dev2, "dev4": dev4}
-    assert not seq.devices_failed_start
-
-    # case 2: all devices work
-
-    # removing failing devices
-    seq.remove_device("dev2")
-    seq.remove_device("dev4")
-    assert seq._devices == {"dev1": dev1, "dev3": dev3}
-    assert not seq.devices_failed_stop
-
-    seq.stop()
-    assert not seq.devices_failed_start
-    assert not seq.devices_failed_stop
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the dev.base module classes.
+"""
+
+from typing import Type
+
+import pytest
+
+from hvl_ccb.comm import NullCommunicationProtocol
+from hvl_ccb.configuration import EmptyConfig
+from hvl_ccb.dev import (
+    Device,
+    DeviceSequenceMixin,
+    DeviceExistingException,
+    DeviceFailuresException,
+    SingleCommDevice,
+)
+
+# make Device instantiable
+Device.__abstractmethods__ = frozenset()
+
+
+class DeviceFailStart(Device):
+    def start(self):
+        raise ValueError("Error during start")
+
+    def stop(self):
+        pass
+
+
+class DeviceFailStop(Device):
+    def start(self):
+        pass
+
+    def stop(self):
+        raise ValueError("Error during start")
+
+
+class DeviceSequence(DeviceSequenceMixin):
+    pass
+
+
+def test_device_sequence_access():
+
+    dev = Device()
+
+    ddict = {"dev": dev}
+
+    dseq = DeviceSequence(ddict)
+
+    assert dseq.get_device("dev") is dev
+
+    for name, device in dseq.get_devices():
+        assert ddict[name] is device
+
+    # same devices, same sequence
+    assert dseq == DeviceSequence(ddict)
+
+    with pytest.raises(ValueError):
+        dseq.remove_device("not there")
+
+    with pytest.raises(DeviceExistingException):
+        dseq.add_device("dev", dev)
+
+    dev2 = Device()
+    dseq.add_device("dev2", dev2)
+    assert dseq.get_device("dev2") is dev2
+    assert dseq != DeviceSequence(ddict)
+
+
+def test_device_sequence_dot_lookup():
+
+    dev1 = Device()
+    dev2 = Device()
+
+    ddict = {
+        "dev1": dev1,
+        "dev2": dev2,
+    }
+
+    seq = DeviceSequence(ddict)
+
+    assert seq.dev1 is dev1
+    assert seq.dev2 is dev2
+
+    # adding device which name over-shadows attr/method
+    with pytest.raises(ValueError):
+        DeviceSequence({"dev1": dev1, "_devices": dev2})
+
+    # adding single device which name over-shadows an attr/method
+    with pytest.raises(ValueError):
+        seq.add_device("start", Device())
+
+
+class NullDevice(SingleCommDevice):
+    @staticmethod
+    def default_com_cls() -> Type[NullCommunicationProtocol]:
+        return NullCommunicationProtocol
+
+    def start(self):
+        pass
+
+    def stop(self):
+        pass
+
+
+def test_null_device():
+    dev_config = EmptyConfig()
+    for arg in (NullCommunicationProtocol({}), EmptyConfig(), {}, None):
+        dev = NullDevice(arg, dev_config=dev_config)
+        assert dev is not None
+        assert isinstance(dev.com.config, EmptyConfig)
+
+    with pytest.raises(TypeError):
+        NullDevice(None, {"extra_key": 0})
+
+
+def test_device_sequence_start():
+
+    # case 1: some devices fail
+    dev1 = Device()
+    dev2 = DeviceFailStart()
+    dev3 = Device()
+    dev4 = DeviceFailStart()
+
+    ddict = {
+        "dev1": dev1,
+        "dev2": dev2,
+        "dev3": dev3,
+        "dev4": dev4,
+    }
+
+    seq = DeviceSequence(ddict)
+    # check that the exception is raised
+    with pytest.raises(DeviceFailuresException) as e:
+        seq.start()
+    # check the exception arguments
+    assert e.value.failures.keys() == seq.devices_failed_start.keys()
+    assert all([isinstance(v, ValueError) for v in e.value.failures.values()])
+
+    assert seq.devices_failed_start == {"dev2": dev2, "dev4": dev4}
+    assert not seq.devices_failed_stop
+
+    # case 2: all devices work
+
+    # removing failing devices
+    seq.remove_device("dev2")
+    seq.remove_device("dev4")
+    assert seq._devices == {"dev1": dev1, "dev3": dev3}
+    assert not seq.devices_failed_start
+
+    seq.start()
+    assert not seq.devices_failed_start
+    assert not seq.devices_failed_stop
+
+
+def test_device_sequence_stop():
+
+    # case 1: some devices fail
+    dev1 = Device()
+    dev2 = DeviceFailStop()
+    dev3 = Device()
+    dev4 = DeviceFailStop()
+
+    ddict = {
+        "dev1": dev1,
+        "dev2": dev2,
+        "dev3": dev3,
+        "dev4": dev4,
+    }
+
+    seq = DeviceSequence(ddict)
+    # check that the exception is raised
+    with pytest.raises(DeviceFailuresException) as e:
+        seq.stop()
+    # check the exception arguments
+    assert e.value.failures.keys() == seq.devices_failed_stop.keys()
+    assert all([isinstance(v, ValueError) for v in e.value.failures.values()])
+
+    assert seq.devices_failed_stop == {"dev2": dev2, "dev4": dev4}
+    assert not seq.devices_failed_start
+
+    # case 2: all devices work
+
+    # removing failing devices
+    seq.remove_device("dev2")
+    seq.remove_device("dev4")
+    assert seq._devices == {"dev1": dev1, "dev3": dev3}
+    assert not seq.devices_failed_stop
+
+    seq.stop()
+    assert not seq.devices_failed_start
+    assert not seq.devices_failed_stop
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_crylas.py` & `hvl_ccb-0.9.0/tests/test_dev_crylas.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,787 +1,787 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the .dev.crylas sub-package.
-"""
-
-import logging
-import time
-
-import pytest
-
-from hvl_ccb import comm, dev
-from masked_comm.serial import (
-    LoopSerialCommunication,
-    CryLasLaserLoopSerialCommunication,
-)
-
-logging.basicConfig(level=logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def laser_com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 19200,
-        "parity": dev.CryLasLaserSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.CryLasLaserSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.CryLasLaserSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\n",
-        "timeout": 0.1,
-    }
-
-
-@pytest.fixture(scope="module")
-def laser_config():
-    return {
-        "polling_period": 0.05,
-        "auto_laser_on": False,
-        "init_shutter_status": dev.CryLasLaserConfig.ShutterStatus.CLOSED,
-    }
-
-
-@pytest.fixture
-def started_laser(laser_com_config, laser_config):
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    com.open()
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text(dev.CryLasLaser.AnswersStatus.READY.value)
-    com.put_text("")
-    with dev.CryLasLaser(com, laser_config) as las:
-        while com.get_written() is not None:
-            pass
-        yield com, las
-
-
-def test_laser_com(laser_com_config):
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    # test error when com closed
-    assert not com.is_open
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.query("attempting to do a query while com is closed", "prefix")
-    # the com still gets written
-    com.get_written()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.query_all("attempting to do a query while com is closed", "prefix")
-    # the com still gets written
-    com.get_written()
-    # test query and query_all work when com opened
-    com.open()
-    com.put_text("ignore this first")
-    com.put_text("prefix hello")
-    assert com.query("query", "prefix", "post query command") == "prefix hello"
-    assert com.get_written() == "query"
-    assert com.get_written() == "post query command"
-    com.put_text("ignore this first")
-    com.put_text("prefix hello")
-    com.put_text("prefix hi")
-    com.put_text("prefix welcome")
-    com.put_text(f"{dev.CryLasLaserSerialCommunication.READ_TEXT_SKIP_PREFIXES[0]} nah")
-    com.put_text("")
-    assert com.query_all("query", "prefix") == [
-        "prefix hello",
-        "prefix hi",
-        "prefix welcome",
-    ]
-    assert com.get_written() == "query"
-    com.close()
-
-
-def test_laser_instantiation(laser_com_config, laser_config):
-    las = dev.CryLasLaser(laser_com_config)
-    assert las is not None
-
-    wrong_config = dict(laser_config)
-    wrong_config["polling_period"] = [-1]
-    with pytest.raises(TypeError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["polling_period"] = -1
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-
-    wrong_config = dict(laser_config)
-    wrong_config["calibration_factor"] = None
-    with pytest.raises(TypeError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["calibration_factor"] = -0.1
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["calibration_factor"] = 0
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-
-    wrong_config = dict(laser_config)
-    wrong_config["polling_timeout"] = "NaN"
-    with pytest.raises(TypeError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["polling_timeout"] = -0.5
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["polling_timeout"] = 0
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-
-    wrong_config = dict(laser_config)
-    wrong_config["init_shutter_status"] = ()
-    with pytest.raises(TypeError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-    wrong_config["init_shutter_status"] = 2
-    with pytest.raises(ValueError):
-        dev.CryLasLaser(laser_com_config, wrong_config)
-
-
-def test_laser_start(laser_com_config, laser_config):
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    las = dev.CryLasLaser(com, laser_config)
-    com.open()
-    # starting again should work
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    las.start()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    # test case: system not immediately ready, execution not blocked
-    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    las.start()
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    las.close_shutter()
-    # waiting for the polling thread
-    las.wait_until_ready()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-
-    # error on input jibrish
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    las = dev.CryLasLaser(com, laser_config)
-    com.open()
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text("STATUS: Not one of expected answers")
-    with pytest.raises(ValueError):
-        las.start()
-
-
-def test_laser_wait_until_ready(laser_com_config, laser_config):
-    # test case: system not immediately ready, execution blocked
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-
-    las = dev.CryLasLaser(com, laser_config)
-    com.open()
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    las.start()
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    las.wait_until_ready()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    las.close_shutter()
-    com.put_text(dev.CryLasLaser.AnswersStatus.INACTIVE.value)
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert not com.is_open
-
-    # wait on start
-    laser_config_dict = dict(laser_config)
-    las = dev.CryLasLaser(com, laser_config_dict)
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    las.start()
-    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.close_shutter()
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-
-    # no wait if already ready
-    las = dev.CryLasLaser(com, laser_config)
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    las.start()
-    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
-    las.wait_until_ready()
-    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-
-
-def test_status_polling_end(laser_com_config, laser_config):
-    # test case: system not immediately ready, execution blocked
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-
-    # stop status polling on device stop
-    laser_config_dict = dict(laser_config)
-    # set polling period big enough for stop() to trigger before inactive status is read
-    laser_config_dict["polling_period"] = 0.2
-    las = dev.CryLasLaser(com, laser_config_dict)
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-    las.start()
-    las._start_polling()  # BLAH: call internal (other are blocking)
-    time.sleep(0.1)  # let the polling thread startup
-    assert las._is_polling()  # BLAH: call internal (make public?)
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-
-    # status polling timeout error
-    laser_config_dict = dict(laser_config)
-    # set polling period big enough
-    laser_config_dict["polling_period"] = 0.2
-    laser_config_dict["polling_timeout"] = laser_config_dict["polling_period"] / 10
-    las = dev.CryLasLaser(com, laser_config_dict)
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    las.start()
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    with pytest.raises(dev.CryLasLaserError):
-        las.wait_until_ready()
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-
-
-def test_laser_stop(started_laser):
-    com, las = started_laser
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert not com.is_open
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    assert las.shutter_status == las.ShutterStatus.CLOSED
-    # stop is an idempotent operation
-    las.stop()
-    assert not com.is_open
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    assert las.shutter_status == las.ShutterStatus.CLOSED
-
-
-def test_laser_on(started_laser, laser_config):
-    com, las = started_laser
-    # normal case
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    com.put_text("")
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    las.laser_on()
-    assert com.get_written() == "LASER ON"
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    # case laser not ready
-    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
-    with pytest.raises(dev.CryLasLaserNotReadyError):
-        las.laser_on()
-    # case laser already on
-    las.laser_status = las.LaserStatus.READY_ACTIVE
-    com.put_text("Laser is already on")
-    las.laser_on()
-    # case command fails
-    las.laser_status = las.LaserStatus.READY_INACTIVE
-    com.put_text("The command is not working")
-    with pytest.raises(dev.CryLasLaserError):
-        las.laser_on()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert not com.is_open
-
-    laser_config_dict = dict(laser_config)
-    laser_config_dict["auto_laser_on"] = True
-    las = dev.CryLasLaser(com, laser_config_dict)
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    las.start()
-    las.wait_until_ready()
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    las.laser_on()
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    assert not com.is_open
-
-    laser_config_dict = dict(laser_config)
-    laser_config_dict["auto_laser_on"] = True
-    las = dev.CryLasLaser(com, laser_config_dict)
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.open()
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    las.start()
-    las.wait_until_ready()
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    com.put_text("")
-    las.laser_on()
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_off(started_laser):
-    com, las = started_laser
-    # normal case
-    las.laser_status = las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    las.laser_off()
-    assert com.get_written() == "LASER OFF"
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    # case laser already off
-    las.laser_status = las.LaserStatus.READY_INACTIVE
-    com.put_text("Laser is already off")
-    las.laser_off()
-    # case command fails
-    las.laser_status = las.LaserStatus.READY_ACTIVE
-    com.put_text("The command is not working")
-    with pytest.raises(dev.CryLasLaserError):
-        las.laser_off()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_open_shutter(started_laser):
-    com, las = started_laser
-    # normal case
-    com.put_text(las.AnswersShutter.OPENED.value)
-    las.open_shutter()
-    assert com.get_written() == "Shutter 1"
-    assert las.shutter_status == las.ShutterStatus.OPENED
-    # case command fails
-    com.put_text("The command is not working")
-    with pytest.raises(dev.CryLasLaserError):
-        las.open_shutter()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_close_shutter(started_laser):
-    com, las = started_laser
-    # normal case
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.close_shutter()
-    assert com.get_written() == "Shutter 0"
-    assert las.shutter_status == las.ShutterStatus.CLOSED
-    # case command fails
-    com.put_text("The command is not working")
-    with pytest.raises(dev.CryLasLaserError):
-        las.close_shutter()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_set_init_shutter_status(laser_com_config, laser_config):
-    # test with init CLOSED
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    las = dev.CryLasLaser(com, laser_config)
-    # test when command fails
-    com.open()
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.set_init_shutter_status()
-    # test when command succeeds and there is nothing to do
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.set_init_shutter_status()
-    # test when command succeeds and the laser should be closed
-    com.put_text(las.AnswersShutter.OPENED.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.set_init_shutter_status()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.stop()
-    # test with init OPENED
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-    laser_config["init_shutter_status"] = dev.CryLasLaserConfig.ShutterStatus.OPENED
-    las = dev.CryLasLaser(com, laser_config)
-    com.open()
-    # test when command succeeds and there is nothing to do
-    com.put_text(las.AnswersShutter.OPENED.value)
-    las.set_init_shutter_status()
-    # test when command succeeds and the laser should be opened
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersShutter.OPENED.value)
-    las.set_init_shutter_status()
-    # teardown
-    laser_config["init_shutter_status"] = dev.CryLasLaserConfig.ShutterStatus.CLOSED
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_update_laser_status(started_laser):
-    com, las = started_laser
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    # no answer error
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_laser_status()
-    # unexpected answer error
-    com.put_text(las.AnswersStatus.TEC1.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_laser_status()
-    # ignore some lines and updated status
-    com.put_text(las.AnswersShutter.OPENED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-    las.update_laser_status()
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text("")
-    las.update_laser_status()
-    assert las.laser_status == las.LaserStatus.READY_INACTIVE
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    com.put_text("")
-    las.update_laser_status()
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_laser_status()
-    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-    las.update_laser_status()
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_update_shutter_status(started_laser):
-    com, las = started_laser
-    com.put_text(las.AnswersShutter.CLOSED.value)
-    las.update_shutter_status()
-    assert las.shutter_status == las.ShutterStatus.CLOSED
-    com.put_text(las.AnswersShutter.OPENED.value)
-    las.update_shutter_status()
-    assert las.shutter_status == las.ShutterStatus.OPENED
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_shutter_status()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_update_repetition_rate(started_laser):
-    com, las = started_laser
-    com.put_text("Impuls=enabled 10Hz")
-    las.update_repetition_rate()
-    assert las.repetition_rate == las.RepetitionRates.SOFTWARE_INTERNAL_TEN
-    com.put_text("Impuls=disabled, extern Trigger")
-    las.update_repetition_rate()
-    assert las.repetition_rate == las.RepetitionRates.HARDWARE
-    com.put_text("no answer to query")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_repetition_rate()
-    com.put_text("Impuls=enabled but no number provided")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_repetition_rate()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_update_target_pulse_energy(started_laser):
-    com, las = started_laser
-    com.put_text("PD-Sollwert=46000")
-    las.update_target_pulse_energy()
-    assert las.target_pulse_energy == int(46000 * las.config.calibration_factor / 1000)
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.update_target_pulse_energy()
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_get_pulse_energy_and_rate(started_laser):
-    com, las = started_laser
-    # test that the command works
-    com.put_text(
-        "IST: LDTemp=0, NLOTemp=1, CaseTemp=2,"
-        " PD=46000, D_I= 4, freq=0, LDE=5, RegOFF=7"
-    )
-    assert las.get_pulse_energy_and_rate() == (200, 0)
-    assert com.get_written() == "DB1"
-    assert com.get_written() == "DB0"
-    # test that the command fails
-    com.put_text("")
-    with pytest.raises(dev.CryLasLaserError):
-        las.get_pulse_energy_and_rate()
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_set_repetition_rate(started_laser):
-    com, las = started_laser
-    # check param type int
-    com.put_text("Impuls=enabled 10Hz")
-    las.set_repetition_rate(10)
-    assert las.repetition_rate.value == 10
-    assert com.get_written() == f"BOO IP{las.RepetitionRates(10).send_value}"
-    # check param type RepetitionRates
-    com.put_text("Impuls=enabled 20Hz")
-    las.set_repetition_rate(las.RepetitionRates(20))
-    assert las.repetition_rate == las.RepetitionRates(20)
-    assert com.get_written() == f"BOO IP{las.RepetitionRates(20).send_value}"
-    # check value Error
-    with pytest.raises(ValueError):
-        las.set_repetition_rate(30)
-    # command fails
-    com.put_text("This did not work")
-    with pytest.raises(dev.CryLasLaserError):
-        las.set_repetition_rate(10)
-    # hardware trigger
-    com.put_text("No answer is expected in this case")
-    las.set_repetition_rate(0)
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_set_pulse_energy(started_laser):
-    com, las = started_laser
-    # case successful
-    val = 100
-    cmd_val = int(val * 1000 / las.config.calibration_factor)
-    com.put_text(f"PD-Sollwert={cmd_val}")
-    las.set_pulse_energy(val)
-    assert las.target_pulse_energy == int(
-        cmd_val * las.config.calibration_factor / 1000
-    )
-    assert com.get_written() == f"BOO SE {cmd_val}"
-    # case unsuccessful
-    val = 100
-    cmd_val = int(val * 1000 / las.config.calibration_factor)
-    com.put_text("PD-Sollwert=46000")
-    with pytest.raises(dev.CryLasLaserError):
-        las.set_pulse_energy(val)
-    assert com.get_written() == f"BOO SE {cmd_val}"
-    # case command fails
-    com.put_text("The command failed")
-    with pytest.raises(dev.CryLasLaserError):
-        las.set_pulse_energy(val)
-    # teardown
-    com.put_text(las.AnswersStatus.INACTIVE.value)
-    com.put_text(las.AnswersShutter.CLOSED.value)
-
-
-def test_laser_com_error(laser_com_config, laser_config):
-
-    wrong_config = dict(laser_com_config)
-    wrong_config["port"] = "NOT A PORT"
-    las = dev.CryLasLaser(wrong_config, laser_config)
-    assert not las.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.start()
-
-    las = dev.CryLasLaser(laser_com_config, laser_config)
-    assert not las.com.is_open
-
-    assert las.laser_status is las.LaserStatus.UNREADY_INACTIVE
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.wait_until_ready()
-    las.laser_status = las.LaserStatus.READY_INACTIVE
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.laser_on()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.laser_off()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.open_shutter()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.close_shutter()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.set_init_shutter_status()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.update_laser_status()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.update_shutter_status()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.update_repetition_rate()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.update_target_pulse_energy()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.get_pulse_energy_and_rate()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.set_repetition_rate(dev.CryLasLaser.RepetitionRates.SOFTWARE_INTERNAL_TEN)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        las.set_pulse_energy(200)
-
-
-def test_auto_laser_on(laser_com_config, laser_config):
-    com = CryLasLaserLoopSerialCommunication(laser_com_config)
-
-    config_where_auto_laser_is_on = dict(laser_config)
-    config_where_auto_laser_is_on["auto_laser_on"] = True
-
-    las = dev.CryLasLaser(com, config_where_auto_laser_is_on)
-
-    com.open()
-
-    # answers to queries made during start()
-    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
-    com.put_text(las.AnswersStatus.HEAD.value)
-    com.put_text("")
-
-    # check that the laser status is inactive before start()
-    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
-
-    las.start()
-
-    # queries that should have been made during start
-    assert com.get_written() == "Shutter"
-    assert com.get_written() == "STATUS"
-
-    com.put_text(las.AnswersStatus.READY.value)
-    com.put_text(las.AnswersStatus.ACTIVE.value)
-    com.put_text("")
-
-    time.sleep(1)
-    assert com.get_written() == "STATUS"
-    assert com.get_written() == "LASER ON"
-
-    assert las.laser_status == las.LaserStatus.READY_ACTIVE
-
-
-# tests attenuator
-
-
-@pytest.fixture(scope="module")
-def attenuator_com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": dev.CryLasLaserSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.CryLasLaserSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.CryLasLaserSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"",
-        "timeout": 0.1,
-    }
-
-
-@pytest.fixture(scope="module")
-def attenuator_config():
-    return {
-        "init_attenuation": 0,
-        "response_sleep_time": 0.01,
-    }
-
-
-@pytest.fixture
-def started_attenuator(attenuator_com_config, attenuator_config):
-    serial_port = LoopSerialCommunication(attenuator_com_config)
-    serial_port.open()
-    serial_port.put_bytes(bytes([0, 0]))
-    with dev.CryLasAttenuator(serial_port, attenuator_config) as att:
-        while serial_port.get_written() is not None:
-            pass
-        yield serial_port, att
-
-
-def test_attenuator_instantiation(attenuator_com_config, attenuator_config):
-    att = dev.CryLasAttenuator(attenuator_com_config)
-    assert att is not None
-
-    wrong_config = dict(attenuator_config)
-    wrong_config["init_attenuation"] = -1
-    with pytest.raises(ValueError):
-        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
-
-    wrong_config = dict(attenuator_config)
-    wrong_config["response_sleep_time"] = 0
-    with pytest.raises(ValueError):
-        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
-    wrong_config["response_sleep_time"] = -0.1
-    with pytest.raises(ValueError):
-        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
-
-
-def test_attenuator_start(started_attenuator):
-    com, att = started_attenuator
-    com.put_bytes(bytes([0, 0]))
-    att.start()
-    assert com.get_written()
-
-
-def test_attenuator_set_attenuation(started_attenuator):
-    com, att = started_attenuator
-    com.put_bytes(bytes([0, 0]))
-    att.set_attenuation(50)
-    assert att.attenuation == 50
-    com.put_bytes(bytes([1, 0]))
-    with pytest.raises(dev.CryLasAttenuatorError):
-        att.set_attenuation(50)
-    with pytest.raises(ValueError):
-        att.set_attenuation(-1)
-
-
-def test_attenuator_com_error(attenuator_com_config, attenuator_config):
-
-    wrong_config = dict(attenuator_com_config)
-    wrong_config["port"] = "NOT A PORT"
-    att = dev.CryLasAttenuator(wrong_config, attenuator_config)
-    assert not att.com.is_open
-    with pytest.raises(comm.SerialCommunicationIOError):
-        att.start()
-
-    att = dev.CryLasAttenuator(attenuator_com_config, attenuator_config)
-    assert not att.com.is_open
-    with pytest.raises(comm.SerialCommunicationIOError):
-        att.set_attenuation(50)
-
-
-def test_attenuator_set_init_attenuation(started_attenuator):
-    com, att = started_attenuator
-    com.put_bytes(bytes([0, 0]))
-    att.set_init_attenuation()
-    assert att.attenuation == att.config.init_attenuation
-
-
-def test_attenuator_set_transmission(started_attenuator):
-    com, att = started_attenuator
-    com.put_bytes(bytes([0, 0]))
-    att.set_transmission(50)
-    assert att.transmission == 50
-    com.put_bytes(bytes([1, 0]))
-    with pytest.raises(dev.CryLasAttenuatorError):
-        att.set_transmission(50)
-    with pytest.raises(ValueError):
-        att.set_transmission(-1)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the .dev.crylas sub-package.
+"""
+
+import logging
+import time
+
+import pytest
+
+from hvl_ccb import comm, dev
+from masked_comm.serial import (
+    LoopSerialCommunication,
+    CryLasLaserLoopSerialCommunication,
+)
+
+logging.basicConfig(level=logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def laser_com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 19200,
+        "parity": dev.CryLasLaserSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.CryLasLaserSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.CryLasLaserSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\n",
+        "timeout": 0.1,
+    }
+
+
+@pytest.fixture(scope="module")
+def laser_config():
+    return {
+        "polling_period": 0.05,
+        "auto_laser_on": False,
+        "init_shutter_status": dev.CryLasLaserConfig.ShutterStatus.CLOSED,
+    }
+
+
+@pytest.fixture
+def started_laser(laser_com_config, laser_config):
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    com.open()
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text(dev.CryLasLaser.AnswersStatus.READY.value)
+    com.put_text("")
+    with dev.CryLasLaser(com, laser_config) as las:
+        while com.get_written() is not None:
+            pass
+        yield com, las
+
+
+def test_laser_com(laser_com_config):
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    # test error when com closed
+    assert not com.is_open
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.query("attempting to do a query while com is closed", "prefix")
+    # the com still gets written
+    com.get_written()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.query_all("attempting to do a query while com is closed", "prefix")
+    # the com still gets written
+    com.get_written()
+    # test query and query_all work when com opened
+    com.open()
+    com.put_text("ignore this first")
+    com.put_text("prefix hello")
+    assert com.query("query", "prefix", "post query command") == "prefix hello"
+    assert com.get_written() == "query"
+    assert com.get_written() == "post query command"
+    com.put_text("ignore this first")
+    com.put_text("prefix hello")
+    com.put_text("prefix hi")
+    com.put_text("prefix welcome")
+    com.put_text(f"{dev.CryLasLaserSerialCommunication.READ_TEXT_SKIP_PREFIXES[0]} nah")
+    com.put_text("")
+    assert com.query_all("query", "prefix") == [
+        "prefix hello",
+        "prefix hi",
+        "prefix welcome",
+    ]
+    assert com.get_written() == "query"
+    com.close()
+
+
+def test_laser_instantiation(laser_com_config, laser_config):
+    las = dev.CryLasLaser(laser_com_config)
+    assert las is not None
+
+    wrong_config = dict(laser_config)
+    wrong_config["polling_period"] = [-1]
+    with pytest.raises(TypeError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["polling_period"] = -1
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+
+    wrong_config = dict(laser_config)
+    wrong_config["calibration_factor"] = None
+    with pytest.raises(TypeError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["calibration_factor"] = -0.1
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["calibration_factor"] = 0
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+
+    wrong_config = dict(laser_config)
+    wrong_config["polling_timeout"] = "NaN"
+    with pytest.raises(TypeError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["polling_timeout"] = -0.5
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["polling_timeout"] = 0
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+
+    wrong_config = dict(laser_config)
+    wrong_config["init_shutter_status"] = ()
+    with pytest.raises(TypeError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+    wrong_config["init_shutter_status"] = 2
+    with pytest.raises(ValueError):
+        dev.CryLasLaser(laser_com_config, wrong_config)
+
+
+def test_laser_start(laser_com_config, laser_config):
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    las = dev.CryLasLaser(com, laser_config)
+    com.open()
+    # starting again should work
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    las.start()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    # test case: system not immediately ready, execution not blocked
+    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    las.start()
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    las.close_shutter()
+    # waiting for the polling thread
+    las.wait_until_ready()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+
+    # error on input jibrish
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    las = dev.CryLasLaser(com, laser_config)
+    com.open()
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text("STATUS: Not one of expected answers")
+    with pytest.raises(ValueError):
+        las.start()
+
+
+def test_laser_wait_until_ready(laser_com_config, laser_config):
+    # test case: system not immediately ready, execution blocked
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+
+    las = dev.CryLasLaser(com, laser_config)
+    com.open()
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    las.start()
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    las.wait_until_ready()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    las.close_shutter()
+    com.put_text(dev.CryLasLaser.AnswersStatus.INACTIVE.value)
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert not com.is_open
+
+    # wait on start
+    laser_config_dict = dict(laser_config)
+    las = dev.CryLasLaser(com, laser_config_dict)
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    las.start()
+    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.close_shutter()
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+
+    # no wait if already ready
+    las = dev.CryLasLaser(com, laser_config)
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    las.start()
+    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
+    las.wait_until_ready()
+    assert las.laser_status != las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+
+
+def test_status_polling_end(laser_com_config, laser_config):
+    # test case: system not immediately ready, execution blocked
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+
+    # stop status polling on device stop
+    laser_config_dict = dict(laser_config)
+    # set polling period big enough for stop() to trigger before inactive status is read
+    laser_config_dict["polling_period"] = 0.2
+    las = dev.CryLasLaser(com, laser_config_dict)
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+    las.start()
+    las._start_polling()  # BLAH: call internal (other are blocking)
+    time.sleep(0.1)  # let the polling thread startup
+    assert las._is_polling()  # BLAH: call internal (make public?)
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+
+    # status polling timeout error
+    laser_config_dict = dict(laser_config)
+    # set polling period big enough
+    laser_config_dict["polling_period"] = 0.2
+    laser_config_dict["polling_timeout"] = laser_config_dict["polling_period"] / 10
+    las = dev.CryLasLaser(com, laser_config_dict)
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    las.start()
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    with pytest.raises(dev.CryLasLaserError):
+        las.wait_until_ready()
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+
+
+def test_laser_stop(started_laser):
+    com, las = started_laser
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert not com.is_open
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    assert las.shutter_status == las.ShutterStatus.CLOSED
+    # stop is an idempotent operation
+    las.stop()
+    assert not com.is_open
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    assert las.shutter_status == las.ShutterStatus.CLOSED
+
+
+def test_laser_on(started_laser, laser_config):
+    com, las = started_laser
+    # normal case
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    com.put_text("")
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    las.laser_on()
+    assert com.get_written() == "LASER ON"
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    # case laser not ready
+    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
+    with pytest.raises(dev.CryLasLaserNotReadyError):
+        las.laser_on()
+    # case laser already on
+    las.laser_status = las.LaserStatus.READY_ACTIVE
+    com.put_text("Laser is already on")
+    las.laser_on()
+    # case command fails
+    las.laser_status = las.LaserStatus.READY_INACTIVE
+    com.put_text("The command is not working")
+    with pytest.raises(dev.CryLasLaserError):
+        las.laser_on()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert not com.is_open
+
+    laser_config_dict = dict(laser_config)
+    laser_config_dict["auto_laser_on"] = True
+    las = dev.CryLasLaser(com, laser_config_dict)
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    las.start()
+    las.wait_until_ready()
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    las.laser_on()
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    assert not com.is_open
+
+    laser_config_dict = dict(laser_config)
+    laser_config_dict["auto_laser_on"] = True
+    las = dev.CryLasLaser(com, laser_config_dict)
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.open()
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    las.start()
+    las.wait_until_ready()
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    com.put_text("")
+    las.laser_on()
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_off(started_laser):
+    com, las = started_laser
+    # normal case
+    las.laser_status = las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    las.laser_off()
+    assert com.get_written() == "LASER OFF"
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    # case laser already off
+    las.laser_status = las.LaserStatus.READY_INACTIVE
+    com.put_text("Laser is already off")
+    las.laser_off()
+    # case command fails
+    las.laser_status = las.LaserStatus.READY_ACTIVE
+    com.put_text("The command is not working")
+    with pytest.raises(dev.CryLasLaserError):
+        las.laser_off()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_open_shutter(started_laser):
+    com, las = started_laser
+    # normal case
+    com.put_text(las.AnswersShutter.OPENED.value)
+    las.open_shutter()
+    assert com.get_written() == "Shutter 1"
+    assert las.shutter_status == las.ShutterStatus.OPENED
+    # case command fails
+    com.put_text("The command is not working")
+    with pytest.raises(dev.CryLasLaserError):
+        las.open_shutter()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_close_shutter(started_laser):
+    com, las = started_laser
+    # normal case
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.close_shutter()
+    assert com.get_written() == "Shutter 0"
+    assert las.shutter_status == las.ShutterStatus.CLOSED
+    # case command fails
+    com.put_text("The command is not working")
+    with pytest.raises(dev.CryLasLaserError):
+        las.close_shutter()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_set_init_shutter_status(laser_com_config, laser_config):
+    # test with init CLOSED
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    las = dev.CryLasLaser(com, laser_config)
+    # test when command fails
+    com.open()
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.set_init_shutter_status()
+    # test when command succeeds and there is nothing to do
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.set_init_shutter_status()
+    # test when command succeeds and the laser should be closed
+    com.put_text(las.AnswersShutter.OPENED.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.set_init_shutter_status()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.stop()
+    # test with init OPENED
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+    laser_config["init_shutter_status"] = dev.CryLasLaserConfig.ShutterStatus.OPENED
+    las = dev.CryLasLaser(com, laser_config)
+    com.open()
+    # test when command succeeds and there is nothing to do
+    com.put_text(las.AnswersShutter.OPENED.value)
+    las.set_init_shutter_status()
+    # test when command succeeds and the laser should be opened
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersShutter.OPENED.value)
+    las.set_init_shutter_status()
+    # teardown
+    laser_config["init_shutter_status"] = dev.CryLasLaserConfig.ShutterStatus.CLOSED
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_update_laser_status(started_laser):
+    com, las = started_laser
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    # no answer error
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_laser_status()
+    # unexpected answer error
+    com.put_text(las.AnswersStatus.TEC1.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_laser_status()
+    # ignore some lines and updated status
+    com.put_text(las.AnswersShutter.OPENED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+    las.update_laser_status()
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text("")
+    las.update_laser_status()
+    assert las.laser_status == las.LaserStatus.READY_INACTIVE
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    com.put_text("")
+    las.update_laser_status()
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_laser_status()
+    las.laser_status = las.LaserStatus.UNREADY_INACTIVE
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+    las.update_laser_status()
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_update_shutter_status(started_laser):
+    com, las = started_laser
+    com.put_text(las.AnswersShutter.CLOSED.value)
+    las.update_shutter_status()
+    assert las.shutter_status == las.ShutterStatus.CLOSED
+    com.put_text(las.AnswersShutter.OPENED.value)
+    las.update_shutter_status()
+    assert las.shutter_status == las.ShutterStatus.OPENED
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_shutter_status()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_update_repetition_rate(started_laser):
+    com, las = started_laser
+    com.put_text("Impuls=enabled 10Hz")
+    las.update_repetition_rate()
+    assert las.repetition_rate == las.RepetitionRates.SOFTWARE_INTERNAL_TEN
+    com.put_text("Impuls=disabled, extern Trigger")
+    las.update_repetition_rate()
+    assert las.repetition_rate == las.RepetitionRates.HARDWARE
+    com.put_text("no answer to query")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_repetition_rate()
+    com.put_text("Impuls=enabled but no number provided")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_repetition_rate()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_update_target_pulse_energy(started_laser):
+    com, las = started_laser
+    com.put_text("PD-Sollwert=46000")
+    las.update_target_pulse_energy()
+    assert las.target_pulse_energy == int(46000 * las.config.calibration_factor / 1000)
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.update_target_pulse_energy()
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_get_pulse_energy_and_rate(started_laser):
+    com, las = started_laser
+    # test that the command works
+    com.put_text(
+        "IST: LDTemp=0, NLOTemp=1, CaseTemp=2,"
+        " PD=46000, D_I= 4, freq=0, LDE=5, RegOFF=7"
+    )
+    assert las.get_pulse_energy_and_rate() == (200, 0)
+    assert com.get_written() == "DB1"
+    assert com.get_written() == "DB0"
+    # test that the command fails
+    com.put_text("")
+    with pytest.raises(dev.CryLasLaserError):
+        las.get_pulse_energy_and_rate()
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_set_repetition_rate(started_laser):
+    com, las = started_laser
+    # check param type int
+    com.put_text("Impuls=enabled 10Hz")
+    las.set_repetition_rate(10)
+    assert las.repetition_rate.value == 10
+    assert com.get_written() == f"BOO IP{las.RepetitionRates(10).send_value}"
+    # check param type RepetitionRates
+    com.put_text("Impuls=enabled 20Hz")
+    las.set_repetition_rate(las.RepetitionRates(20))
+    assert las.repetition_rate == las.RepetitionRates(20)
+    assert com.get_written() == f"BOO IP{las.RepetitionRates(20).send_value}"
+    # check value Error
+    with pytest.raises(ValueError):
+        las.set_repetition_rate(30)
+    # command fails
+    com.put_text("This did not work")
+    with pytest.raises(dev.CryLasLaserError):
+        las.set_repetition_rate(10)
+    # hardware trigger
+    com.put_text("No answer is expected in this case")
+    las.set_repetition_rate(0)
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_set_pulse_energy(started_laser):
+    com, las = started_laser
+    # case successful
+    val = 100
+    cmd_val = int(val * 1000 / las.config.calibration_factor)
+    com.put_text(f"PD-Sollwert={cmd_val}")
+    las.set_pulse_energy(val)
+    assert las.target_pulse_energy == int(
+        cmd_val * las.config.calibration_factor / 1000
+    )
+    assert com.get_written() == f"BOO SE {cmd_val}"
+    # case unsuccessful
+    val = 100
+    cmd_val = int(val * 1000 / las.config.calibration_factor)
+    com.put_text("PD-Sollwert=46000")
+    with pytest.raises(dev.CryLasLaserError):
+        las.set_pulse_energy(val)
+    assert com.get_written() == f"BOO SE {cmd_val}"
+    # case command fails
+    com.put_text("The command failed")
+    with pytest.raises(dev.CryLasLaserError):
+        las.set_pulse_energy(val)
+    # teardown
+    com.put_text(las.AnswersStatus.INACTIVE.value)
+    com.put_text(las.AnswersShutter.CLOSED.value)
+
+
+def test_laser_com_error(laser_com_config, laser_config):
+
+    wrong_config = dict(laser_com_config)
+    wrong_config["port"] = "NOT A PORT"
+    las = dev.CryLasLaser(wrong_config, laser_config)
+    assert not las.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.start()
+
+    las = dev.CryLasLaser(laser_com_config, laser_config)
+    assert not las.com.is_open
+
+    assert las.laser_status is las.LaserStatus.UNREADY_INACTIVE
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.wait_until_ready()
+    las.laser_status = las.LaserStatus.READY_INACTIVE
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.laser_on()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.laser_off()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.open_shutter()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.close_shutter()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.set_init_shutter_status()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.update_laser_status()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.update_shutter_status()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.update_repetition_rate()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.update_target_pulse_energy()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.get_pulse_energy_and_rate()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.set_repetition_rate(dev.CryLasLaser.RepetitionRates.SOFTWARE_INTERNAL_TEN)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        las.set_pulse_energy(200)
+
+
+def test_auto_laser_on(laser_com_config, laser_config):
+    com = CryLasLaserLoopSerialCommunication(laser_com_config)
+
+    config_where_auto_laser_is_on = dict(laser_config)
+    config_where_auto_laser_is_on["auto_laser_on"] = True
+
+    las = dev.CryLasLaser(com, config_where_auto_laser_is_on)
+
+    com.open()
+
+    # answers to queries made during start()
+    com.put_text(dev.CryLasLaser.AnswersShutter.CLOSED.value)
+    com.put_text(las.AnswersStatus.HEAD.value)
+    com.put_text("")
+
+    # check that the laser status is inactive before start()
+    assert las.laser_status == las.LaserStatus.UNREADY_INACTIVE
+
+    las.start()
+
+    # queries that should have been made during start
+    assert com.get_written() == "Shutter"
+    assert com.get_written() == "STATUS"
+
+    com.put_text(las.AnswersStatus.READY.value)
+    com.put_text(las.AnswersStatus.ACTIVE.value)
+    com.put_text("")
+
+    time.sleep(1)
+    assert com.get_written() == "STATUS"
+    assert com.get_written() == "LASER ON"
+
+    assert las.laser_status == las.LaserStatus.READY_ACTIVE
+
+
+# tests attenuator
+
+
+@pytest.fixture(scope="module")
+def attenuator_com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": dev.CryLasLaserSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.CryLasLaserSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.CryLasLaserSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"",
+        "timeout": 0.1,
+    }
+
+
+@pytest.fixture(scope="module")
+def attenuator_config():
+    return {
+        "init_attenuation": 0,
+        "response_sleep_time": 0.01,
+    }
+
+
+@pytest.fixture
+def started_attenuator(attenuator_com_config, attenuator_config):
+    serial_port = LoopSerialCommunication(attenuator_com_config)
+    serial_port.open()
+    serial_port.put_bytes(bytes([0, 0]))
+    with dev.CryLasAttenuator(serial_port, attenuator_config) as att:
+        while serial_port.get_written() is not None:
+            pass
+        yield serial_port, att
+
+
+def test_attenuator_instantiation(attenuator_com_config, attenuator_config):
+    att = dev.CryLasAttenuator(attenuator_com_config)
+    assert att is not None
+
+    wrong_config = dict(attenuator_config)
+    wrong_config["init_attenuation"] = -1
+    with pytest.raises(ValueError):
+        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
+
+    wrong_config = dict(attenuator_config)
+    wrong_config["response_sleep_time"] = 0
+    with pytest.raises(ValueError):
+        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
+    wrong_config["response_sleep_time"] = -0.1
+    with pytest.raises(ValueError):
+        dev.CryLasAttenuator(attenuator_com_config, wrong_config)
+
+
+def test_attenuator_start(started_attenuator):
+    com, att = started_attenuator
+    com.put_bytes(bytes([0, 0]))
+    att.start()
+    assert com.get_written()
+
+
+def test_attenuator_set_attenuation(started_attenuator):
+    com, att = started_attenuator
+    com.put_bytes(bytes([0, 0]))
+    att.set_attenuation(50)
+    assert att.attenuation == 50
+    com.put_bytes(bytes([1, 0]))
+    with pytest.raises(dev.CryLasAttenuatorError):
+        att.set_attenuation(50)
+    with pytest.raises(ValueError):
+        att.set_attenuation(-1)
+
+
+def test_attenuator_com_error(attenuator_com_config, attenuator_config):
+
+    wrong_config = dict(attenuator_com_config)
+    wrong_config["port"] = "NOT A PORT"
+    att = dev.CryLasAttenuator(wrong_config, attenuator_config)
+    assert not att.com.is_open
+    with pytest.raises(comm.SerialCommunicationIOError):
+        att.start()
+
+    att = dev.CryLasAttenuator(attenuator_com_config, attenuator_config)
+    assert not att.com.is_open
+    with pytest.raises(comm.SerialCommunicationIOError):
+        att.set_attenuation(50)
+
+
+def test_attenuator_set_init_attenuation(started_attenuator):
+    com, att = started_attenuator
+    com.put_bytes(bytes([0, 0]))
+    att.set_init_attenuation()
+    assert att.attenuation == att.config.init_attenuation
+
+
+def test_attenuator_set_transmission(started_attenuator):
+    com, att = started_attenuator
+    com.put_bytes(bytes([0, 0]))
+    att.set_transmission(50)
+    assert att.transmission == 50
+    com.put_bytes(bytes([1, 0]))
+    with pytest.raises(dev.CryLasAttenuatorError):
+        att.set_transmission(50)
+    with pytest.raises(ValueError):
+        att.set_transmission(-1)
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_ea_psi9000.py` & `hvl_ccb-0.9.0/tests/test_dev_ea_psi9000.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,344 +1,344 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the Elektro Automatik PSI 9000 power supply device classes.
-"""
-
-import pytest
-
-from hvl_ccb.dev import (
-    PSI9000,
-    PSI9000Error,
-    PSI9000VisaCommunicationConfig,
-    PSI9000Config,
-)
-from masked_comm import MaskedVisaCommunication
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "interface_type": PSI9000VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET,
-        "host": "127.0.0.1",
-        "open_timeout": 10,
-        "timeout": 50,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "spoll_interval": 0.01,
-        "spoll_start_delay": 0,
-        "wait_sec_system_lock": 0.01,
-        "wait_sec_settings_effect": 0.01,
-        "wait_sec_initialisation": 0.01,
-    }
-
-
-@pytest.fixture
-def testdev(com_config, dev_config):
-    com = MaskedVisaCommunication(com_config)
-    dev = PSI9000(com, dev_config)
-    return dev
-
-
-def test_dev_config(dev_config):
-    # currently there are no non-default config values
-    PSI9000Config()
-
-    config = PSI9000Config(**dev_config)
-    for key, value in dev_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"power_limit": -1.0},
-        {"voltage_lower_limit": 20, "voltage_upper_limit": 19.0},
-        {
-            "voltage_lower_limit": 4,
-            "voltage_upper_limit": PSI9000Config._VOLTAGE_UPPER_LIMIT + 1,
-        },
-        {"current_lower_limit": -1.0},
-        {
-            "current_lower_limit": 4,
-            "current_upper_limit": PSI9000Config._CURRENT_UPPER_LIMIT + 1,
-        },
-        {"wait_sec_system_lock": 0},
-        {"wait_sec_system_lock": -1},
-        {"wait_sec_settings_effect": 0},
-        {"wait_sec_initialisation": 0},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_config_dict):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        PSI9000Config(**invalid_config)
-
-
-def test_instantiation(com_config):
-    power_supply = PSI9000(com_config)
-    assert power_supply is not None
-
-
-def test_start_stop(testdev: PSI9000):
-    power_supply = testdev
-    test_com = power_supply.com
-
-    power_supply.start()
-
-    # stop successful
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    test_com.put_name("OUTput?", "OFF")
-    power_supply.stop()
-
-    # stop successful: output and lock on
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    test_com.put_name("OUTPut?", "ON")
-    test_com.put_name("SOURce:VOLTage?", "0 V")
-    test_com.put_name("SOURce:CURRent?", "0 A")
-    test_com.put_name("OUTPut?", "OFF")
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    power_supply.stop()
-
-
-def test_locking(testdev: PSI9000):
-    power_supply = testdev
-    test_com = power_supply.com
-
-    # lock failed
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_system_lock(True)
-    assert test_com.get_written() == "SYSTem:LOCK ON"
-
-    # lock successful
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    power_supply.set_system_lock(True)
-    assert test_com.get_written() == "SYSTem:LOCK ON"
-
-    # unlock failed due to still on current
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    test_com.put_name("MEASure:VOLTage?", "20 V")
-    test_com.put_name("MEASure:CURRent?", "100 A")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_system_lock(False)
-    assert test_com.get_written() is None
-
-    # unlock failed
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    test_com.put_name("MEASure:VOLTage?", "0 V")
-    test_com.put_name("MEASure:CURRent?", "0 A")
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_system_lock(False)
-    assert test_com.get_written() == "SYSTem:LOCK OFF"
-
-    # unlock successful
-    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
-    test_com.put_name("MEASure:VOLTage?", "0 V")
-    test_com.put_name("MEASure:CURRent?", "0 A")
-    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
-    power_supply.set_system_lock(False)
-    assert test_com.get_written() == "SYSTem:LOCK OFF"
-
-    # illegal answer
-    test_com.put_name("SYSTem:LOCK:OWNer?", "bla")
-    with pytest.raises(PSI9000Error):
-        power_supply.get_system_lock()
-
-
-def test_output(testdev: PSI9000):
-    power_supply = testdev
-    test_com = power_supply.com
-
-    test_com.put_name("OUTPut?", "ON")
-    assert power_supply.get_output()
-
-    test_com.put_name("OUTPut?", "OFF")
-    assert not power_supply.get_output()
-
-    test_com.put_name("OUTPut?", "bla")
-    with pytest.raises(PSI9000Error):
-        power_supply.get_output()
-
-    # setting output
-    test_com.put_name("OUTPut?", "ON")
-    power_supply.set_output(True)
-    assert test_com.get_written() == "OUTPut ON"
-
-    test_com.put_name("OUTPut?", "OFF")
-    power_supply.set_output(False)
-    assert test_com.get_written() == "OUTPut OFF"
-
-    test_com.put_name("OUTPut?", "ON")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_output(False)
-    assert test_com.get_written() == "OUTPut OFF"
-
-    test_com.put_name("OUTPut?", "OFF")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_output(True)
-    assert test_com.get_written() == "OUTPut ON"
-
-
-def test_get_uip_upper_limits(testdev: PSI9000):
-    test_com = testdev.com
-
-    # get upper limits
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "1000 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    assert testdev.get_uip_upper_limits() == (80, 1000, 10000)
-
-
-def test_get_ui_lower_limits(testdev: PSI9000):
-    test_com = testdev.com
-
-    # get lower limits
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
-    assert testdev.get_ui_lower_limits() == (2, 5)
-
-
-def test_set_upper_limits(testdev: PSI9000):
-    test_com = testdev.com
-
-    # set upper limits, success
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "10 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "20 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    testdev.set_upper_limits(10, 20, 10000)
-    assert test_com.get_written() == "SOURce:VOLTage:LIMit:HIGH 10"
-    assert test_com.get_written() == "SOURce:CURRent:LIMit:HIGH 20"
-    assert test_com.get_written() == "SOURce:POWer:LIMit:HIGH 10000"
-
-    # set upper limits, set fail
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "10 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "200 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    with pytest.raises(PSI9000Error):
-        testdev.set_upper_limits(10, 20, 10000)
-    assert test_com.get_written() == "SOURce:VOLTage:LIMit:HIGH 10"
-    assert test_com.get_written() == "SOURce:CURRent:LIMit:HIGH 20"
-    assert test_com.get_written() == "SOURce:POWer:LIMit:HIGH 10000"
-
-    # set upper limits, limit fail
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "20 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
-    with pytest.raises(ValueError):
-        testdev.set_upper_limits(10, 20, 10000)
-    assert test_com.get_written() is None
-
-
-def test_set_lower_limits(testdev: PSI9000):
-    test_com = testdev.com
-
-    # set lower limits, success
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5.2 A")
-    testdev.set_lower_limits(2, 5.2)
-    assert test_com.get_written() == "SOURce:VOLTage:LIMit:LOW 2"
-    assert test_com.get_written() == "SOURce:CURRent:LIMit:LOW 5.2"
-
-    # set lower limits, set fail
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "50 A")
-    with pytest.raises(PSI9000Error):
-        testdev.set_lower_limits(2, 5)
-    assert test_com.get_written() == "SOURce:VOLTage:LIMit:LOW 2"
-    assert test_com.get_written() == "SOURce:CURRent:LIMit:LOW 5"
-
-    # set lower limits, limit fail
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "1 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "20 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    with pytest.raises(ValueError):
-        testdev.set_lower_limits(0.5, 500)
-    assert test_com.get_written() is None
-
-
-def test_set_voltage_current(testdev: PSI9000):
-    power_supply = testdev
-    test_com = power_supply.com
-
-    test_com.put_name("SOURce:VOLTage?", "20.2 V")
-    test_com.put_name("SOURce:CURRent?", "123.4 A")
-    power_supply.set_voltage_current(20.2, 123.4)
-    assert test_com.get_written() == "SOURce:VOLTage 20.200000"
-    assert test_com.get_written() == "SOURce:CURRent 123.400000"
-
-    test_com.put_name("SOURce:VOLTage?", "20.2 V")
-    test_com.put_name("SOURce:CURRent?", "10 A")
-    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "20 V")
-    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
-    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
-    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "1 V")
-    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
-    with pytest.raises(PSI9000Error):
-        power_supply.set_voltage_current(20.2, 123.4)
-    assert test_com.get_written() == "SOURce:VOLTage 20.200000"
-    assert test_com.get_written() == "SOURce:CURRent 123.400000"
-
-
-def test_check_master_slave_config(testdev: PSI9000):
-    power_supply = testdev
-    test_com = power_supply.com
-
-    # MS disabled
-    test_com.put_name("SYSTem:MS:ENABle?", "OFF")
-    with pytest.raises(PSI9000Error):
-        power_supply.check_master_slave_config()
-    assert test_com.get_written() is None
-
-    # device is not MASTER
-    test_com.put_name("SYSTem:MS:ENABle?", "ON")
-    test_com.put_name("SYSTem:MS:LINK?", "SLAVE")
-    with pytest.raises(PSI9000Error):
-        power_supply.check_master_slave_config()
-    assert test_com.get_written() is None
-
-    # initialization failed
-    test_com.put_name("SYSTem:MS:ENABle?", "ON")
-    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
-    test_com.put_name("SYSTem:MS:CONDition?", "NOT_INIT")
-    with pytest.raises(PSI9000Error):
-        power_supply.check_master_slave_config()
-    assert test_com.get_written() == "SYSTem:MS:INITialisation"
-
-    # wrong expected voltage, current nominal values
-    test_com.put_name("SYSTem:MS:ENABle?", "ON")
-    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
-    test_com.put_name("SYSTem:MS:CONDition?", "INIT")
-    test_com.put_name("SYSTem:MS:NOMinal:VOLTage?", f"{PSI9000.MS_NOMINAL_VOLTAGE} V")
-    test_com.put_name(
-        "SYSTem:MS:NOMinal:CURRent?", f"{PSI9000.MS_NOMINAL_CURRENT - 1} A"
-    )
-    with pytest.raises(PSI9000Error):
-        power_supply.check_master_slave_config()
-    assert test_com.get_written() == "SYSTem:MS:INITialisation"
-
-    # all right
-    # wrong expected voltage, current nominal values
-    test_com.put_name("SYSTem:MS:ENABle?", "ON")
-    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
-    test_com.put_name("SYSTem:MS:CONDition?", "INIT")
-    test_com.put_name("SYSTem:MS:NOMinal:VOLTage?", f"{PSI9000.MS_NOMINAL_VOLTAGE} V")
-    test_com.put_name("SYSTem:MS:NOMinal:CURRent?", f"{PSI9000.MS_NOMINAL_CURRENT} A")
-    power_supply.check_master_slave_config()
-    assert test_com.get_written() == "SYSTem:MS:INITialisation"
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the Elektro Automatik PSI 9000 power supply device classes.
+"""
+
+import pytest
+
+from hvl_ccb.dev import (
+    PSI9000,
+    PSI9000Error,
+    PSI9000VisaCommunicationConfig,
+    PSI9000Config,
+)
+from masked_comm import MaskedVisaCommunication
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "interface_type": PSI9000VisaCommunicationConfig.InterfaceType.TCPIP_SOCKET,
+        "host": "127.0.0.1",
+        "open_timeout": 10,
+        "timeout": 50,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "spoll_interval": 0.01,
+        "spoll_start_delay": 0,
+        "wait_sec_system_lock": 0.01,
+        "wait_sec_settings_effect": 0.01,
+        "wait_sec_initialisation": 0.01,
+    }
+
+
+@pytest.fixture
+def testdev(com_config, dev_config):
+    com = MaskedVisaCommunication(com_config)
+    dev = PSI9000(com, dev_config)
+    return dev
+
+
+def test_dev_config(dev_config):
+    # currently there are no non-default config values
+    PSI9000Config()
+
+    config = PSI9000Config(**dev_config)
+    for key, value in dev_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"power_limit": -1.0},
+        {"voltage_lower_limit": 20, "voltage_upper_limit": 19.0},
+        {
+            "voltage_lower_limit": 4,
+            "voltage_upper_limit": PSI9000Config._VOLTAGE_UPPER_LIMIT + 1,
+        },
+        {"current_lower_limit": -1.0},
+        {
+            "current_lower_limit": 4,
+            "current_upper_limit": PSI9000Config._CURRENT_UPPER_LIMIT + 1,
+        },
+        {"wait_sec_system_lock": 0},
+        {"wait_sec_system_lock": -1},
+        {"wait_sec_settings_effect": 0},
+        {"wait_sec_initialisation": 0},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_config_dict):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        PSI9000Config(**invalid_config)
+
+
+def test_instantiation(com_config):
+    power_supply = PSI9000(com_config)
+    assert power_supply is not None
+
+
+def test_start_stop(testdev: PSI9000):
+    power_supply = testdev
+    test_com = power_supply.com
+
+    power_supply.start()
+
+    # stop successful
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    test_com.put_name("OUTput?", "OFF")
+    power_supply.stop()
+
+    # stop successful: output and lock on
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    test_com.put_name("OUTPut?", "ON")
+    test_com.put_name("SOURce:VOLTage?", "0 V")
+    test_com.put_name("SOURce:CURRent?", "0 A")
+    test_com.put_name("OUTPut?", "OFF")
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    power_supply.stop()
+
+
+def test_locking(testdev: PSI9000):
+    power_supply = testdev
+    test_com = power_supply.com
+
+    # lock failed
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_system_lock(True)
+    assert test_com.get_written() == "SYSTem:LOCK ON"
+
+    # lock successful
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    power_supply.set_system_lock(True)
+    assert test_com.get_written() == "SYSTem:LOCK ON"
+
+    # unlock failed due to still on current
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    test_com.put_name("MEASure:VOLTage?", "20 V")
+    test_com.put_name("MEASure:CURRent?", "100 A")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_system_lock(False)
+    assert test_com.get_written() is None
+
+    # unlock failed
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    test_com.put_name("MEASure:VOLTage?", "0 V")
+    test_com.put_name("MEASure:CURRent?", "0 A")
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_system_lock(False)
+    assert test_com.get_written() == "SYSTem:LOCK OFF"
+
+    # unlock successful
+    test_com.put_name("SYSTem:LOCK:OWNer?", "REMOTE")
+    test_com.put_name("MEASure:VOLTage?", "0 V")
+    test_com.put_name("MEASure:CURRent?", "0 A")
+    test_com.put_name("SYSTem:LOCK:OWNer?", "NONE")
+    power_supply.set_system_lock(False)
+    assert test_com.get_written() == "SYSTem:LOCK OFF"
+
+    # illegal answer
+    test_com.put_name("SYSTem:LOCK:OWNer?", "bla")
+    with pytest.raises(PSI9000Error):
+        power_supply.get_system_lock()
+
+
+def test_output(testdev: PSI9000):
+    power_supply = testdev
+    test_com = power_supply.com
+
+    test_com.put_name("OUTPut?", "ON")
+    assert power_supply.get_output()
+
+    test_com.put_name("OUTPut?", "OFF")
+    assert not power_supply.get_output()
+
+    test_com.put_name("OUTPut?", "bla")
+    with pytest.raises(PSI9000Error):
+        power_supply.get_output()
+
+    # setting output
+    test_com.put_name("OUTPut?", "ON")
+    power_supply.set_output(True)
+    assert test_com.get_written() == "OUTPut ON"
+
+    test_com.put_name("OUTPut?", "OFF")
+    power_supply.set_output(False)
+    assert test_com.get_written() == "OUTPut OFF"
+
+    test_com.put_name("OUTPut?", "ON")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_output(False)
+    assert test_com.get_written() == "OUTPut OFF"
+
+    test_com.put_name("OUTPut?", "OFF")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_output(True)
+    assert test_com.get_written() == "OUTPut ON"
+
+
+def test_get_uip_upper_limits(testdev: PSI9000):
+    test_com = testdev.com
+
+    # get upper limits
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "1000 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    assert testdev.get_uip_upper_limits() == (80, 1000, 10000)
+
+
+def test_get_ui_lower_limits(testdev: PSI9000):
+    test_com = testdev.com
+
+    # get lower limits
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
+    assert testdev.get_ui_lower_limits() == (2, 5)
+
+
+def test_set_upper_limits(testdev: PSI9000):
+    test_com = testdev.com
+
+    # set upper limits, success
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "10 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "20 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    testdev.set_upper_limits(10, 20, 10000)
+    assert test_com.get_written() == "SOURce:VOLTage:LIMit:HIGH 10"
+    assert test_com.get_written() == "SOURce:CURRent:LIMit:HIGH 20"
+    assert test_com.get_written() == "SOURce:POWer:LIMit:HIGH 10000"
+
+    # set upper limits, set fail
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "10 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "200 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    with pytest.raises(PSI9000Error):
+        testdev.set_upper_limits(10, 20, 10000)
+    assert test_com.get_written() == "SOURce:VOLTage:LIMit:HIGH 10"
+    assert test_com.get_written() == "SOURce:CURRent:LIMit:HIGH 20"
+    assert test_com.get_written() == "SOURce:POWer:LIMit:HIGH 10000"
+
+    # set upper limits, limit fail
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "20 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
+    with pytest.raises(ValueError):
+        testdev.set_upper_limits(10, 20, 10000)
+    assert test_com.get_written() is None
+
+
+def test_set_lower_limits(testdev: PSI9000):
+    test_com = testdev.com
+
+    # set lower limits, success
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5.2 A")
+    testdev.set_lower_limits(2, 5.2)
+    assert test_com.get_written() == "SOURce:VOLTage:LIMit:LOW 2"
+    assert test_com.get_written() == "SOURce:CURRent:LIMit:LOW 5.2"
+
+    # set lower limits, set fail
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "80 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "2 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "50 A")
+    with pytest.raises(PSI9000Error):
+        testdev.set_lower_limits(2, 5)
+    assert test_com.get_written() == "SOURce:VOLTage:LIMit:LOW 2"
+    assert test_com.get_written() == "SOURce:CURRent:LIMit:LOW 5"
+
+    # set lower limits, limit fail
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "1 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "20 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    with pytest.raises(ValueError):
+        testdev.set_lower_limits(0.5, 500)
+    assert test_com.get_written() is None
+
+
+def test_set_voltage_current(testdev: PSI9000):
+    power_supply = testdev
+    test_com = power_supply.com
+
+    test_com.put_name("SOURce:VOLTage?", "20.2 V")
+    test_com.put_name("SOURce:CURRent?", "123.4 A")
+    power_supply.set_voltage_current(20.2, 123.4)
+    assert test_com.get_written() == "SOURce:VOLTage 20.200000"
+    assert test_com.get_written() == "SOURce:CURRent 123.400000"
+
+    test_com.put_name("SOURce:VOLTage?", "20.2 V")
+    test_com.put_name("SOURce:CURRent?", "10 A")
+    test_com.put_name("SOURce:VOLTage:LIMit:HIGH?", "20 V")
+    test_com.put_name("SOURce:CURRent:LIMit:HIGH?", "2000 A")
+    test_com.put_name("SOURce:POWer:LIMit:HIGH?", "10000 W")
+    test_com.put_name("SOURce:VOLTage:LIMit:LOW?", "1 V")
+    test_com.put_name("SOURce:CURRent:LIMit:LOW?", "5 A")
+    with pytest.raises(PSI9000Error):
+        power_supply.set_voltage_current(20.2, 123.4)
+    assert test_com.get_written() == "SOURce:VOLTage 20.200000"
+    assert test_com.get_written() == "SOURce:CURRent 123.400000"
+
+
+def test_check_master_slave_config(testdev: PSI9000):
+    power_supply = testdev
+    test_com = power_supply.com
+
+    # MS disabled
+    test_com.put_name("SYSTem:MS:ENABle?", "OFF")
+    with pytest.raises(PSI9000Error):
+        power_supply.check_master_slave_config()
+    assert test_com.get_written() is None
+
+    # device is not MASTER
+    test_com.put_name("SYSTem:MS:ENABle?", "ON")
+    test_com.put_name("SYSTem:MS:LINK?", "SLAVE")
+    with pytest.raises(PSI9000Error):
+        power_supply.check_master_slave_config()
+    assert test_com.get_written() is None
+
+    # initialization failed
+    test_com.put_name("SYSTem:MS:ENABle?", "ON")
+    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
+    test_com.put_name("SYSTem:MS:CONDition?", "NOT_INIT")
+    with pytest.raises(PSI9000Error):
+        power_supply.check_master_slave_config()
+    assert test_com.get_written() == "SYSTem:MS:INITialisation"
+
+    # wrong expected voltage, current nominal values
+    test_com.put_name("SYSTem:MS:ENABle?", "ON")
+    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
+    test_com.put_name("SYSTem:MS:CONDition?", "INIT")
+    test_com.put_name("SYSTem:MS:NOMinal:VOLTage?", f"{PSI9000.MS_NOMINAL_VOLTAGE} V")
+    test_com.put_name(
+        "SYSTem:MS:NOMinal:CURRent?", f"{PSI9000.MS_NOMINAL_CURRENT - 1} A"
+    )
+    with pytest.raises(PSI9000Error):
+        power_supply.check_master_slave_config()
+    assert test_com.get_written() == "SYSTem:MS:INITialisation"
+
+    # all right
+    # wrong expected voltage, current nominal values
+    test_com.put_name("SYSTem:MS:ENABle?", "ON")
+    test_com.put_name("SYSTem:MS:LINK?", "MASTER")
+    test_com.put_name("SYSTem:MS:CONDition?", "INIT")
+    test_com.put_name("SYSTem:MS:NOMinal:VOLTage?", f"{PSI9000.MS_NOMINAL_VOLTAGE} V")
+    test_com.put_name("SYSTem:MS:NOMinal:CURRent?", f"{PSI9000.MS_NOMINAL_CURRENT} A")
+    power_supply.check_master_slave_config()
+    assert test_com.get_written() == "SYSTem:MS:INITialisation"
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_fug.py` & `hvl_ccb-0.9.0/tests/test_dev_fug.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,479 +1,479 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the .dev.fug sub-package.
-"""
-
-import logging
-
-import pytest
-
-from hvl_ccb import dev
-from hvl_ccb.dev.fug import FuGProbusIV, FuGProbusIVCommands
-from masked_comm.serial import FuGLoopSerialCommunication  # type: ignore
-
-logging.basicConfig(level=logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": dev.FuGSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.FuGSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.FuGSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 0.01,
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 5,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {}
-
-
-def started_devices(com_config, dev_config):
-    com = FuGLoopSerialCommunication(com_config)
-    com.open()
-    fug = dev.FuG(com, dev_config)
-
-    return com, fug
-
-
-def fully_started_devices(com_config, dev_config):
-    com, fug = started_devices(com_config, dev_config)
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    fug.start()
-    assert com.get_written() == "*IDN?"
-    assert com.get_written() == "*IDN?"
-
-    return com, fug
-
-
-def test_pytest():
-    assert 1
-
-
-def test_loop(com_config):
-    com = FuGLoopSerialCommunication(com_config)
-    com.open()
-    com.put_text("test")
-
-    assert com is not None
-
-
-class ConcreteFuG(FuGProbusIV):
-    def start(self):
-        super().start()
-
-
-def test_instantiation(com_config, dev_config):
-    di = ConcreteFuG(com_config)
-    assert di is not None
-
-    di = ConcreteFuG(com_config, dev_config)
-    assert di is not None
-
-
-def test_start(com_config, dev_config):
-    com, fug = started_devices(com_config, dev_config)
-
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    fug.start()
-
-    assert com.get_written() == "*IDN?"
-    assert com.get_written() == "*IDN?"
-
-    assert fug._serial_number == "17022-01-01"
-    assert fug._model == "HCK"
-    assert fug.max_current_hardware == 80e-3
-    assert fug._max_power_hardware == 800
-    assert fug.max_voltage_hardware == 20e3
-    assert fug.max_current == 80e-3
-    assert fug.max_voltage == 20e3
-
-    assert fug is not None
-
-
-@pytest.fixture(scope="module")
-def wrong_com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": dev.FuGSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.FuGSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.FuGSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 3,
-        "wait_sec_read_text_nonempty": -1,
-        "default_n_attempts_read_text_nonempty": 5,
-    }
-
-
-@pytest.fixture(scope="module")
-def wrong_dev_config():
-    return {
-        "wait_sec_stop_commands": -1,
-    }
-
-
-def test_wrong_configs(wrong_com_config, wrong_dev_config, com_config):
-    with pytest.raises(ValueError):
-        com = FuGLoopSerialCommunication(wrong_com_config)
-    assert "com" not in locals()
-
-    com = FuGLoopSerialCommunication(com_config)
-    com.open()
-    with pytest.raises(ValueError):
-        fug = dev.FuG(com, wrong_dev_config)
-    assert "fug" not in locals()
-
-
-starts_data = [
-    (0, 0, 80e-3, 20e3, 80e-3, 20e3),
-    (1, 100e3, 80e-3, 20e3, 80e-3, 20e3),
-    (50e-3, 15e3, 50e-3, 15e3, 80e-3, 20e3),
-]
-
-
-@pytest.mark.parametrize("start_data", starts_data)
-def test_starts(com_config, dev_config, start_data):
-    com, fug = started_devices(com_config, dev_config)
-
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    fug.start(max_current=start_data[0], max_voltage=start_data[1])
-
-    assert fug.max_current == start_data[2]
-    assert fug.max_voltage == start_data[3]
-    assert fug.max_current_hardware == start_data[4]
-    assert fug.max_voltage_hardware == start_data[5]
-
-
-def test_idn_not_regognizable(com_config, dev_config):
-    com, fug = started_devices(com_config, dev_config)
-    com.put_text("FUG HCK 800 MOD 17022-01-01")
-    com.put_text("FUG HCK 800 MOD 17022-01-01")
-    with pytest.raises(dev.FuGError):
-        fug.start()
-
-
-def test_setregisters(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("S0:0")
-    assert fug.voltage.setvalue == 0
-    assert com.get_written() == ">S0 ?"
-
-    com.put_text("E0")
-    fug.voltage = 1000
-    assert com.get_written() == ">S0 1000"
-
-    with pytest.raises(dev.FuGError):
-        fug.voltage = 100e3
-    assert com.get_written() is None
-
-    with pytest.raises(ValueError):
-        fug.voltage = -1
-    assert com.get_written() is None
-
-    com.put_text("S0A:250")
-    assert fug.voltage.actualsetvalue == 250
-    assert com.get_written() == ">S0A ?"
-    com.put_text("E0")
-    fug.voltage.actualsetvalue = 333
-    assert com.get_written() == ">S0A 333"
-
-    com.put_text("S0R:10")
-    assert fug.voltage.ramprate == 10
-    assert com.get_written() == ">S0R ?"
-    com.put_text("E0")
-    fug.voltage.ramprate = 10
-    assert com.get_written() == ">S0R 10"
-
-    com.put_text("S0B:0")
-    assert fug.voltage.rampmode == dev.FuGRampModes.IMMEDIATELY
-    assert com.get_written() == ">S0B ?"
-    com.put_text("E0")
-    fug.voltage.rampmode = dev.FuGRampModes.FOLLOWRAMP
-    assert com.get_written() == ">S0B 1"
-    com.put_text("E0")
-    fug.voltage.rampmode = 1
-    assert com.get_written() == ">S0B 1"
-    with pytest.raises(dev.FuGError):
-        fug.voltage.rampmode = 10
-    assert com.get_written() is None
-
-    with pytest.raises(dev.FuGError):
-        fug.voltage.rampstate = dev.FuGDigitalVal.ON
-    assert com.get_written() is None
-    com.put_text("S0S:0")
-    assert fug.voltage.rampstate == dev.FuGDigitalVal.OFF
-    assert com.get_written() == ">S0S ?"
-
-    com.put_text("S0H:1")
-    assert fug.voltage.high_resolution == dev.FuGDigitalVal.YES
-    assert com.get_written() == ">S0H ?"
-    com.put_text("E0")
-    fug.voltage.high_resolution = dev.FuGDigitalVal.YES
-    assert com.get_written() == ">S0H 1"
-    com.put_text("E0")
-    fug.voltage.high_resolution = dev.FuGDigitalVal.NO
-    assert com.get_written() == ">S0H 0"
-    com.put_text("E0")
-    fug.voltage.high_resolution = 1
-    assert com.get_written() == ">S0H 1"
-    with pytest.raises(dev.FuGError):
-        fug.voltage.high_resolution = 1024
-    assert com.get_written() is None
-
-    com.put_text("E0")
-    fug.current = 80e-3
-    assert com.get_written() == ">S1 0.08"
-
-
-def test_digital_output_registers(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("E0")
-    fug.outX0.out = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">B0 1"
-    com.put_text("E0")
-    fug.outX0.out = dev.FuGDigitalVal.NO
-    assert com.get_written() == ">B0 0"
-    com.put_text("B0:1")
-    assert fug.outX0.out == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">B0 ?"
-
-    com.put_text("B0A:0")
-    assert fug.outX0.status == dev.FuGDigitalVal.NO
-    assert com.get_written() == ">B0A ?"
-    with pytest.raises(dev.FuGError):
-        fug.outX0.status = dev.FuGDigitalVal.ON
-    assert com.get_written() is None
-
-    com.put_text("E0")
-    fug.outX1.out = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">B1 1"
-
-    com.put_text("E0")
-    fug.outX2.out = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">B2 1"
-
-    com.put_text("E0")
-    fug.outXCMD.out = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">BX 1"
-
-    com.put_text("E0")
-    fug.on = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">BON 1"
-
-    com.put_text("E0")
-    fug.on = 1
-    assert com.get_written() == ">BON 1"
-    with pytest.raises(dev.FuGError):
-        fug.on = 23
-    assert com.get_written() is None
-
-
-def test_monitors(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("M0:1000")
-    assert fug.voltage_monitor.value == 1000
-    assert com.get_written() == ">M0 ?"
-    with pytest.raises(dev.FuGError):
-        fug.voltage_monitor.value = 0
-    assert com.get_written() is None
-
-    com.put_text("M0R:1000")
-    assert fug.voltage_monitor.value_raw == 1000
-    assert com.get_written() == ">M0R ?"
-    with pytest.raises(dev.FuGError):
-        fug.voltage_monitor.value_raw = 0
-    assert com.get_written() is None
-
-    com.put_text("M0I:0")
-    assert fug.voltage_monitor.adc_mode == dev.FuGMonitorModes.T256US
-    assert com.get_written() == ">M0I ?"
-    com.put_text("E0")
-    fug.voltage_monitor.adc_mode = dev.FuGMonitorModes.T40MS
-    assert com.get_written() == ">M0I 4"
-    com.put_text("E0")
-    fug.voltage_monitor.adc_mode = 6
-    assert com.get_written() == ">M0I 6"
-    with pytest.raises(dev.FuGError):
-        fug.voltage_monitor.adc_mode = 12
-    assert com.get_written() is None
-
-    com.put_text("M1:0.0123")
-    assert fug.current_monitor.value == 0.0123
-    assert com.get_written() == ">M1 ?"
-
-
-def test_digital_inputs(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("DVR:1")
-    assert fug.di.cv_mode == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">DVR ?"
-    com.put_text("DIR:1")
-    assert fug.di.cc_mode == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">DIR ?"
-    com.put_text("D3R:0")
-    assert fug.di.reg_3 == dev.FuGDigitalVal.OFF
-    assert com.get_written() == ">D3R ?"
-    com.put_text("DX:0")
-    assert fug.di.x_stat == dev.FuGDigitalVal.OFF
-    assert com.get_written() == ">DX ?"
-    com.put_text("DON:1")
-    assert fug.di.on == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">DON ?"
-    com.put_text("DSD:1")
-    assert fug.di.digital_control == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">DSD ?"
-    com.put_text("DSA:1")
-    assert fug.di.analog_control == dev.FuGDigitalVal.ON
-    assert com.get_written() == ">DSA ?"
-    com.put_text("DCAL:0")
-    assert fug.di.calibration_mode == dev.FuGDigitalVal.OFF
-    assert com.get_written() == ">DCAL ?"
-
-
-def test_config_registers(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("KT:2")
-    assert fug.config_status.terminator == dev.FuGTerminators.LF
-    assert com.get_written() == ">KT ?"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.terminator = 5
-    assert com.get_written() is None
-    com.put_text("E0")
-    fug.config_status.terminator = dev.FuGTerminators.LF
-    assert com.get_written() == ">KT 2"
-
-    answer = "01011101"
-    com.put_text("KS:" + answer)
-    assert fug.config_status.status == answer
-    assert com.get_written() == ">KS ?"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.status = answer
-    assert com.get_written() is None
-
-    com.put_text("KQS:1")
-    assert fug.config_status.srq_status == "1"
-    assert com.get_written() == ">KQS ?"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.srq_status = "something"
-    assert com.get_written() is None
-
-    com.put_text("KQM:0")
-    assert fug.config_status.srq_mask == 0
-    assert com.get_written() == ">KQM ?"
-    com.put_text("E0")
-    fug.config_status.srq_mask = 1
-    assert com.get_written() == ">KQM 1"
-
-    com.put_text("KX:0")
-    assert fug.config_status.execute_on_x == dev.FuGDigitalVal.NO
-    assert com.get_written() == ">KX ?"
-    com.put_text("E0")
-    fug.config_status.execute_on_x = dev.FuGDigitalVal.YES
-    assert com.get_written() == ">KX 1"
-    com.put_text("E0")
-    fug.config_status.execute_on_x = dev.FuGDigitalVal.NO
-    assert com.get_written() == ">KX 0"
-    com.put_text("E0")
-    fug.config_status.execute_on_x = 1
-    assert com.get_written() == ">KX 1"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.execute_on_x = 10
-    assert com.get_written() is None
-
-    com.put_text("KN:0")
-    assert fug.config_status.readback_data == dev.FuGReadbackChannels.VOLTAGE
-    assert com.get_written() == ">KN ?"
-    com.put_text("E0")
-    fug.config_status.readback_data = dev.FuGReadbackChannels.RATEDCURRENT
-    assert com.get_written() == ">KN 4"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.readback_data = 33
-    assert com.get_written() is None
-
-    com.put_text("E4")
-    with pytest.raises(dev.FuGError):
-        assert fug.config_status.most_recent_error == "something"
-    assert com.get_written() == ">KE ?"
-    with pytest.raises(dev.FuGError):
-        fug.config_status.most_recent_error = "something"
-    assert com.get_written() is None
-
-
-def test_timeout(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    with pytest.raises(dev.FuGError):
-        fug.on = dev.FuGDigitalVal.ON
-
-
-def test_unkown_errorcode(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("E9999")
-    with pytest.raises(dev.FuGError):
-        fug.on = dev.FuGDigitalVal.ON
-    assert com.get_written() == ">BON 1"
-
-
-def test_wrong_return_register(com_config, dev_config):
-    com, fug = fully_started_devices(com_config, dev_config)
-
-    com.put_text("M0:1000")
-    with pytest.raises(dev.FuGError):
-        assert fug.current_monitor.value == 0.001
-    assert com.get_written() == ">M1 ?"
-
-
-def started_retro(com_config, dev_config):
-
-    class FuGProbusIVDevice(FuGProbusIV):
-        def start(self):
-            return super().start()
-
-    com = FuGLoopSerialCommunication(com_config)
-    com.open()
-    fug = FuGProbusIVDevice(com, dev_config)
-    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
-    fug.start()
-    assert com.get_written() == "*IDN?"
-
-    return com, fug
-
-
-def test_retrodevices(com_config, dev_config):
-    com, fug = started_retro(com_config, dev_config)
-
-    assert com is not None
-    assert fug is not None
-
-    assert fug._interface_version == "FUG HCK 800 - 20 000 MOD 17022-01-01"
-    assert fug.__repr__() == "FuGProbus(FUG HCK 800 - 20 000 MOD 17022-01-01)"
-
-    com.put_text("something")
-    assert fug.command(FuGProbusIVCommands.QUERY) == "something"
-    assert com.get_written() == "?"
-
-    assert com.get_written() is None
-    with pytest.raises(dev.FuGError):
-        fug.command(FuGProbusIVCommands.POLARITY)
-    assert com.get_written() is None
-
-    com.put_text("E0")
-    com.put_text("E0")
-    fug.stop()
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the .dev.fug sub-package.
+"""
+
+import logging
+
+import pytest
+
+from hvl_ccb import dev
+from hvl_ccb.dev.fug import FuGProbusIV, FuGProbusIVCommands
+from masked_comm.serial import FuGLoopSerialCommunication  # type: ignore
+
+logging.basicConfig(level=logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": dev.FuGSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.FuGSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.FuGSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 0.01,
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 5,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {}
+
+
+def started_devices(com_config, dev_config):
+    com = FuGLoopSerialCommunication(com_config)
+    com.open()
+    fug = dev.FuG(com, dev_config)
+
+    return com, fug
+
+
+def fully_started_devices(com_config, dev_config):
+    com, fug = started_devices(com_config, dev_config)
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    fug.start()
+    assert com.get_written() == "*IDN?"
+    assert com.get_written() == "*IDN?"
+
+    return com, fug
+
+
+def test_pytest():
+    assert 1
+
+
+def test_loop(com_config):
+    com = FuGLoopSerialCommunication(com_config)
+    com.open()
+    com.put_text("test")
+
+    assert com is not None
+
+
+class ConcreteFuG(FuGProbusIV):
+    def start(self):
+        super().start()
+
+
+def test_instantiation(com_config, dev_config):
+    di = ConcreteFuG(com_config)
+    assert di is not None
+
+    di = ConcreteFuG(com_config, dev_config)
+    assert di is not None
+
+
+def test_start(com_config, dev_config):
+    com, fug = started_devices(com_config, dev_config)
+
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    fug.start()
+
+    assert com.get_written() == "*IDN?"
+    assert com.get_written() == "*IDN?"
+
+    assert fug._serial_number == "17022-01-01"
+    assert fug._model == "HCK"
+    assert fug.max_current_hardware == 80e-3
+    assert fug._max_power_hardware == 800
+    assert fug.max_voltage_hardware == 20e3
+    assert fug.max_current == 80e-3
+    assert fug.max_voltage == 20e3
+
+    assert fug is not None
+
+
+@pytest.fixture(scope="module")
+def wrong_com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": dev.FuGSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.FuGSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.FuGSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 3,
+        "wait_sec_read_text_nonempty": -1,
+        "default_n_attempts_read_text_nonempty": 5,
+    }
+
+
+@pytest.fixture(scope="module")
+def wrong_dev_config():
+    return {
+        "wait_sec_stop_commands": -1,
+    }
+
+
+def test_wrong_configs(wrong_com_config, wrong_dev_config, com_config):
+    with pytest.raises(ValueError):
+        com = FuGLoopSerialCommunication(wrong_com_config)
+    assert "com" not in locals()
+
+    com = FuGLoopSerialCommunication(com_config)
+    com.open()
+    with pytest.raises(ValueError):
+        fug = dev.FuG(com, wrong_dev_config)
+    assert "fug" not in locals()
+
+
+starts_data = [
+    (0, 0, 80e-3, 20e3, 80e-3, 20e3),
+    (1, 100e3, 80e-3, 20e3, 80e-3, 20e3),
+    (50e-3, 15e3, 50e-3, 15e3, 80e-3, 20e3),
+]
+
+
+@pytest.mark.parametrize("start_data", starts_data)
+def test_starts(com_config, dev_config, start_data):
+    com, fug = started_devices(com_config, dev_config)
+
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    fug.start(max_current=start_data[0], max_voltage=start_data[1])
+
+    assert fug.max_current == start_data[2]
+    assert fug.max_voltage == start_data[3]
+    assert fug.max_current_hardware == start_data[4]
+    assert fug.max_voltage_hardware == start_data[5]
+
+
+def test_idn_not_regognizable(com_config, dev_config):
+    com, fug = started_devices(com_config, dev_config)
+    com.put_text("FUG HCK 800 MOD 17022-01-01")
+    com.put_text("FUG HCK 800 MOD 17022-01-01")
+    with pytest.raises(dev.FuGError):
+        fug.start()
+
+
+def test_setregisters(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("S0:0")
+    assert fug.voltage.setvalue == 0
+    assert com.get_written() == ">S0 ?"
+
+    com.put_text("E0")
+    fug.voltage = 1000
+    assert com.get_written() == ">S0 1000"
+
+    with pytest.raises(dev.FuGError):
+        fug.voltage = 100e3
+    assert com.get_written() is None
+
+    with pytest.raises(ValueError):
+        fug.voltage = -1
+    assert com.get_written() is None
+
+    com.put_text("S0A:250")
+    assert fug.voltage.actualsetvalue == 250
+    assert com.get_written() == ">S0A ?"
+    com.put_text("E0")
+    fug.voltage.actualsetvalue = 333
+    assert com.get_written() == ">S0A 333"
+
+    com.put_text("S0R:10")
+    assert fug.voltage.ramprate == 10
+    assert com.get_written() == ">S0R ?"
+    com.put_text("E0")
+    fug.voltage.ramprate = 10
+    assert com.get_written() == ">S0R 10"
+
+    com.put_text("S0B:0")
+    assert fug.voltage.rampmode == dev.FuGRampModes.IMMEDIATELY
+    assert com.get_written() == ">S0B ?"
+    com.put_text("E0")
+    fug.voltage.rampmode = dev.FuGRampModes.FOLLOWRAMP
+    assert com.get_written() == ">S0B 1"
+    com.put_text("E0")
+    fug.voltage.rampmode = 1
+    assert com.get_written() == ">S0B 1"
+    with pytest.raises(dev.FuGError):
+        fug.voltage.rampmode = 10
+    assert com.get_written() is None
+
+    with pytest.raises(dev.FuGError):
+        fug.voltage.rampstate = dev.FuGDigitalVal.ON
+    assert com.get_written() is None
+    com.put_text("S0S:0")
+    assert fug.voltage.rampstate == dev.FuGDigitalVal.OFF
+    assert com.get_written() == ">S0S ?"
+
+    com.put_text("S0H:1")
+    assert fug.voltage.high_resolution == dev.FuGDigitalVal.YES
+    assert com.get_written() == ">S0H ?"
+    com.put_text("E0")
+    fug.voltage.high_resolution = dev.FuGDigitalVal.YES
+    assert com.get_written() == ">S0H 1"
+    com.put_text("E0")
+    fug.voltage.high_resolution = dev.FuGDigitalVal.NO
+    assert com.get_written() == ">S0H 0"
+    com.put_text("E0")
+    fug.voltage.high_resolution = 1
+    assert com.get_written() == ">S0H 1"
+    with pytest.raises(dev.FuGError):
+        fug.voltage.high_resolution = 1024
+    assert com.get_written() is None
+
+    com.put_text("E0")
+    fug.current = 80e-3
+    assert com.get_written() == ">S1 0.08"
+
+
+def test_digital_output_registers(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("E0")
+    fug.outX0.out = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">B0 1"
+    com.put_text("E0")
+    fug.outX0.out = dev.FuGDigitalVal.NO
+    assert com.get_written() == ">B0 0"
+    com.put_text("B0:1")
+    assert fug.outX0.out == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">B0 ?"
+
+    com.put_text("B0A:0")
+    assert fug.outX0.status == dev.FuGDigitalVal.NO
+    assert com.get_written() == ">B0A ?"
+    with pytest.raises(dev.FuGError):
+        fug.outX0.status = dev.FuGDigitalVal.ON
+    assert com.get_written() is None
+
+    com.put_text("E0")
+    fug.outX1.out = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">B1 1"
+
+    com.put_text("E0")
+    fug.outX2.out = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">B2 1"
+
+    com.put_text("E0")
+    fug.outXCMD.out = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">BX 1"
+
+    com.put_text("E0")
+    fug.on = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">BON 1"
+
+    com.put_text("E0")
+    fug.on = 1
+    assert com.get_written() == ">BON 1"
+    with pytest.raises(dev.FuGError):
+        fug.on = 23
+    assert com.get_written() is None
+
+
+def test_monitors(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("M0:1000")
+    assert fug.voltage_monitor.value == 1000
+    assert com.get_written() == ">M0 ?"
+    with pytest.raises(dev.FuGError):
+        fug.voltage_monitor.value = 0
+    assert com.get_written() is None
+
+    com.put_text("M0R:1000")
+    assert fug.voltage_monitor.value_raw == 1000
+    assert com.get_written() == ">M0R ?"
+    with pytest.raises(dev.FuGError):
+        fug.voltage_monitor.value_raw = 0
+    assert com.get_written() is None
+
+    com.put_text("M0I:0")
+    assert fug.voltage_monitor.adc_mode == dev.FuGMonitorModes.T256US
+    assert com.get_written() == ">M0I ?"
+    com.put_text("E0")
+    fug.voltage_monitor.adc_mode = dev.FuGMonitorModes.T40MS
+    assert com.get_written() == ">M0I 4"
+    com.put_text("E0")
+    fug.voltage_monitor.adc_mode = 6
+    assert com.get_written() == ">M0I 6"
+    with pytest.raises(dev.FuGError):
+        fug.voltage_monitor.adc_mode = 12
+    assert com.get_written() is None
+
+    com.put_text("M1:0.0123")
+    assert fug.current_monitor.value == 0.0123
+    assert com.get_written() == ">M1 ?"
+
+
+def test_digital_inputs(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("DVR:1")
+    assert fug.di.cv_mode == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">DVR ?"
+    com.put_text("DIR:1")
+    assert fug.di.cc_mode == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">DIR ?"
+    com.put_text("D3R:0")
+    assert fug.di.reg_3 == dev.FuGDigitalVal.OFF
+    assert com.get_written() == ">D3R ?"
+    com.put_text("DX:0")
+    assert fug.di.x_stat == dev.FuGDigitalVal.OFF
+    assert com.get_written() == ">DX ?"
+    com.put_text("DON:1")
+    assert fug.di.on == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">DON ?"
+    com.put_text("DSD:1")
+    assert fug.di.digital_control == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">DSD ?"
+    com.put_text("DSA:1")
+    assert fug.di.analog_control == dev.FuGDigitalVal.ON
+    assert com.get_written() == ">DSA ?"
+    com.put_text("DCAL:0")
+    assert fug.di.calibration_mode == dev.FuGDigitalVal.OFF
+    assert com.get_written() == ">DCAL ?"
+
+
+def test_config_registers(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("KT:2")
+    assert fug.config_status.terminator == dev.FuGTerminators.LF
+    assert com.get_written() == ">KT ?"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.terminator = 5
+    assert com.get_written() is None
+    com.put_text("E0")
+    fug.config_status.terminator = dev.FuGTerminators.LF
+    assert com.get_written() == ">KT 2"
+
+    answer = "01011101"
+    com.put_text("KS:" + answer)
+    assert fug.config_status.status == answer
+    assert com.get_written() == ">KS ?"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.status = answer
+    assert com.get_written() is None
+
+    com.put_text("KQS:1")
+    assert fug.config_status.srq_status == "1"
+    assert com.get_written() == ">KQS ?"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.srq_status = "something"
+    assert com.get_written() is None
+
+    com.put_text("KQM:0")
+    assert fug.config_status.srq_mask == 0
+    assert com.get_written() == ">KQM ?"
+    com.put_text("E0")
+    fug.config_status.srq_mask = 1
+    assert com.get_written() == ">KQM 1"
+
+    com.put_text("KX:0")
+    assert fug.config_status.execute_on_x == dev.FuGDigitalVal.NO
+    assert com.get_written() == ">KX ?"
+    com.put_text("E0")
+    fug.config_status.execute_on_x = dev.FuGDigitalVal.YES
+    assert com.get_written() == ">KX 1"
+    com.put_text("E0")
+    fug.config_status.execute_on_x = dev.FuGDigitalVal.NO
+    assert com.get_written() == ">KX 0"
+    com.put_text("E0")
+    fug.config_status.execute_on_x = 1
+    assert com.get_written() == ">KX 1"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.execute_on_x = 10
+    assert com.get_written() is None
+
+    com.put_text("KN:0")
+    assert fug.config_status.readback_data == dev.FuGReadbackChannels.VOLTAGE
+    assert com.get_written() == ">KN ?"
+    com.put_text("E0")
+    fug.config_status.readback_data = dev.FuGReadbackChannels.RATEDCURRENT
+    assert com.get_written() == ">KN 4"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.readback_data = 33
+    assert com.get_written() is None
+
+    com.put_text("E4")
+    with pytest.raises(dev.FuGError):
+        assert fug.config_status.most_recent_error == "something"
+    assert com.get_written() == ">KE ?"
+    with pytest.raises(dev.FuGError):
+        fug.config_status.most_recent_error = "something"
+    assert com.get_written() is None
+
+
+def test_timeout(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    with pytest.raises(dev.FuGError):
+        fug.on = dev.FuGDigitalVal.ON
+
+
+def test_unkown_errorcode(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("E9999")
+    with pytest.raises(dev.FuGError):
+        fug.on = dev.FuGDigitalVal.ON
+    assert com.get_written() == ">BON 1"
+
+
+def test_wrong_return_register(com_config, dev_config):
+    com, fug = fully_started_devices(com_config, dev_config)
+
+    com.put_text("M0:1000")
+    with pytest.raises(dev.FuGError):
+        assert fug.current_monitor.value == 0.001
+    assert com.get_written() == ">M1 ?"
+
+
+def started_retro(com_config, dev_config):
+
+    class FuGProbusIVDevice(FuGProbusIV):
+        def start(self):
+            return super().start()
+
+    com = FuGLoopSerialCommunication(com_config)
+    com.open()
+    fug = FuGProbusIVDevice(com, dev_config)
+    com.put_text("FUG HCK 800 - 20 000 MOD 17022-01-01")
+    fug.start()
+    assert com.get_written() == "*IDN?"
+
+    return com, fug
+
+
+def test_retrodevices(com_config, dev_config):
+    com, fug = started_retro(com_config, dev_config)
+
+    assert com is not None
+    assert fug is not None
+
+    assert fug._interface_version == "FUG HCK 800 - 20 000 MOD 17022-01-01"
+    assert fug.__repr__() == "FuGProbus(FUG HCK 800 - 20 000 MOD 17022-01-01)"
+
+    com.put_text("something")
+    assert fug.command(FuGProbusIVCommands.QUERY) == "something"
+    assert com.get_written() == "?"
+
+    assert com.get_written() is None
+    with pytest.raises(dev.FuGError):
+        fug.command(FuGProbusIVCommands.POLARITY)
+    assert com.get_written() is None
+
+    com.put_text("E0")
+    com.put_text("E0")
+    fug.stop()
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_heinzinger.py` & `hvl_ccb-0.9.0/tests/test_dev_heinzinger.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,386 +1,386 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the .dev.heinzinger_pnc sub-package.
-"""
-
-import logging
-
-import pytest
-
-from hvl_ccb import comm, dev
-from masked_comm.serial import HeinzingerLoopSerialCommunication
-
-logging.basicConfig(level=logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": dev.HeinzingerSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.HeinzingerSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.HeinzingerSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 3,
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 5,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "default_number_of_recordings": 16,
-        "number_of_decimals": 6,
-        "wait_sec_stop_commands": 0.01,
-    }
-
-
-class ConcreteHeinzingerDI(dev.HeinzingerDI):
-    def start(self):
-        super().start()
-
-
-@pytest.fixture
-def started_heinzinger_di(com_config, dev_config):
-    serial_port = HeinzingerLoopSerialCommunication(com_config)
-    serial_port.open()
-    serial_port.put_text("my_interface_version")
-    with ConcreteHeinzingerDI(serial_port, dev_config) as di:
-        while serial_port.get_written() is not None:
-            pass
-        yield serial_port, di
-
-
-@pytest.fixture
-def start_pnc_device(com_config, dev_config):
-    def _start_pnc_device(serial_number):
-        serial_port = HeinzingerLoopSerialCommunication(com_config)
-        serial_port.open()
-        serial_port.put_text("my_interface_version")
-        serial_port.put_text(serial_number)
-
-        def started_pnc():
-            with dev.HeinzingerPNC(serial_port, dev_config) as pnc:
-                while serial_port.get_written() is not None:
-                    pass
-                yield serial_port, pnc
-
-        return started_pnc()
-
-    return _start_pnc_device
-
-
-def test_di_number_of_recordings(started_heinzinger_di):
-    com, di = started_heinzinger_di
-
-    # set a new value
-    di.set_number_of_recordings(4)
-    assert com.get_written() == "AVER 4"
-
-    com.put_text("4")
-    assert di.get_number_of_recordings() == 4
-
-    # assigning integer not amongst accepted values
-    with pytest.raises(ValueError):
-        di.set_number_of_recordings(3)
-
-
-def test_com_config(com_config):
-    config = dev.HeinzingerSerialCommunicationConfig(**com_config)
-    for key, value in com_config.items():
-        assert getattr(config, key) == value
-
-
-def test_dev_config(dev_config):
-    # currently there are no non-default config values
-    dev.HeinzingerConfig()
-
-    config = dev.HeinzingerConfig(**dev_config)
-    for key, value in dev_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"default_number_of_recordings": 0},
-        {"number_of_decimals": 0},
-        {"number_of_decimals": 11},
-        {"wait_sec_stop_commands": 0},
-        {"number_of_decimals": 6, "wait_sec_stop_commands": -1},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_config_dict):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        dev.HeinzingerConfig(**invalid_config)
-
-
-def test_di_instantiation(com_config, dev_config):
-    di = ConcreteHeinzingerDI(com_config)
-    assert di is not None
-
-    di = ConcreteHeinzingerDI(com_config, dev_config)
-    assert di is not None
-
-
-def test_di_start(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    # starting again should work
-    com.put_text("my_interface_version")
-    di.start()
-    assert com.get_written() == "VERS?"
-
-
-def test_di_stop(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    # starting again should work
-    di.stop()
-    assert com.get_written() == "VOLT 0.000000"
-    assert com.get_written() == "OUTP OFF"
-
-    # check that a second stop() works
-    di.stop()
-    assert not com.get_written()
-
-
-def test_di_output_status(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    assert di.output_status == di.OutputStatus.UNKNOWN
-    di.output_on()
-    assert di.output_status == di.OutputStatus.ON
-    di.output_off()
-    assert di.output_status == di.OutputStatus.OFF
-
-
-def test_di_output_on(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    di.output_on()
-    assert com.get_written() == "OUTP ON"
-    assert di.output_status == di.OutputStatus.ON
-
-
-def test_di_output_off(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    di.output_off()
-    assert com.get_written() == "OUTP OFF"
-    assert di.output_status == di.OutputStatus.OFF
-
-
-def test_di_set_voltage(started_heinzinger_di):
-    com, di = started_heinzinger_di
-
-    # test if the correct text is sent to the com
-    di.set_voltage(0.123456789)
-    assert com.get_written().strip() == "VOLT 0.123457"
-
-
-def test_di_measure_voltage(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    volt = 1.2
-    com.put_text(str(volt))
-    result = di.measure_voltage()
-    assert result == volt and com.get_written() == "MEAS:VOLT?"
-
-
-def test_di_set_current(started_heinzinger_di):
-    com, di = started_heinzinger_di
-
-    # test if the correct text is sent to the com
-    di.set_current(0.123456789)
-    assert com.get_written().strip() == "CURR 0.123457"
-
-
-def test_di_measure_current(started_heinzinger_di):
-    com, di = started_heinzinger_di
-    curr = 0.25
-    com.put_text(str(curr))
-    result = di.measure_current()
-    assert result == curr and com.get_written() == "MEAS:CURR?"
-
-
-def test_di_com_error(com_config, dev_config):
-
-    wrong_config = dict(com_config)
-    wrong_config["port"] = "NOT A PORT"
-    di = ConcreteHeinzingerDI(wrong_config, dev_config)
-    assert not di.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.start()
-
-    di = ConcreteHeinzingerDI(com_config, dev_config)
-    assert not di.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.reset_interface()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.get_interface_version()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.get_serial_number()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.output_on()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.output_off()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.get_number_of_recordings()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.set_number_of_recordings(dev.HeinzingerConfig.RecordingsEnum.EIGHT)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.measure_voltage()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.set_voltage(1)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.get_voltage()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.measure_current()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.set_current(1)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        di.get_current()
-
-
-def test_pnc_instantiation(com_config, dev_config):
-    pnc = dev.HeinzingerPNC(com_config)
-    assert pnc is not None
-
-    wrong_config = dict(dev_config)
-    wrong_config["default_number_of_recordings"] = 0
-    with pytest.raises(ValueError):
-        dev.HeinzingerPNC(com_config, wrong_config)
-
-    assert pnc.unit_voltage == dev.HeinzingerPNC.UnitVoltage.UNKNOWN
-    assert pnc.unit_current == dev.HeinzingerPNC.UnitCurrent.UNKNOWN
-
-
-def test_pnc_com_error(com_config, dev_config):
-    pnc = dev.HeinzingerPNC(com_config)
-    assert not pnc.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        pnc.identify_device()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        pnc.set_voltage(0)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        pnc.set_current(0)
-
-
-# test different possible serial numbers to check if the info is read correctly
-devices_data = [
-    ("PNChp 60000-1neg 354211082", 60000, 1, dev.HeinzingerPNC.UnitVoltage.V, "mA"),
-    ("314807440/PNChp 60000-1neg.", 60000, 1, "V", dev.HeinzingerPNC.UnitCurrent.mA),
-    ("PNChp 1500-40 ump. 375214277", 1500, 40, "V", "mA"),
-    ("PNC 100000-6pos 375214277", 100, 6, dev.HeinzingerPNC.UnitVoltage.kV, "mA"),
-    ("PNC 600-3000pos 375214277", 600, 3, "V", dev.HeinzingerPNC.UnitCurrent.A),
-]
-
-
-@pytest.mark.parametrize("device_data", devices_data)
-def test_pnc_start(start_pnc_device, com_config, device_data):
-    started_pnc = start_pnc_device(device_data[0])
-    com, pnc = next(started_pnc)
-
-    # starting the device again should work
-    com.put_text("my_interface_version")
-    com.put_text(device_data[0])
-    pnc.start()
-    assert com.get_written() == "VERS?"
-    assert com.get_written() == "*IDN?"
-    assert pnc.max_voltage_hardware == pnc.max_voltage == device_data[1]
-    assert pnc.max_current_hardware == pnc.max_current == device_data[2]
-    assert pnc.unit_voltage == device_data[3]
-    assert pnc.unit_current == device_data[4]
-    assert com.get_written() == "AVER " + str(
-        pnc.config.default_number_of_recordings.value
-    )
-
-
-def test_pnc_not_recognized(start_pnc_device):
-    with pytest.raises(dev.HeinzingerPNCDeviceNotRecognizedException):
-        next(start_pnc_device("ABC 600-3000pos 375214277"))
-
-
-def test_pnc_set_max_voltage(start_pnc_device):
-    started_pnc = start_pnc_device("PNC 600-3000pos 375214277")
-    com, pnc = next(started_pnc)
-
-    # set max_voltage to half the current value
-    next_value = pnc.max_voltage / 2
-    pnc.max_voltage = next_value
-    assert pnc.max_voltage == next_value
-
-    # assigning value higher than hardware maximum
-    with pytest.raises(ValueError):
-        pnc.max_voltage = pnc.max_voltage_hardware * 2
-
-    # assigning negative value
-    with pytest.raises(ValueError):
-        pnc.max_voltage = -1
-
-
-def test_pnc_set_max_current(start_pnc_device):
-    started_pnc = start_pnc_device("PNC 600-3000pos 375214277")
-    com, pnc = next(started_pnc)
-
-    # set max_voltage to half the current value
-    next_value = pnc.max_current / 2
-    pnc.max_current = next_value
-    assert pnc.max_current == next_value
-
-    # assigning value higher than hardware maximum
-    with pytest.raises(ValueError):
-        pnc.max_current = pnc.max_current_hardware * 2
-
-    # assigning negative value
-    with pytest.raises(ValueError):
-        pnc.max_current = -1
-
-
-# test different values for voltage and current
-devices_u = [
-    ("PNC 600-3000pos 375214277", 600, "VOLT 600.000000", 700),
-    ("PNChp 1500-40 ump. 375214277", 1, "VOLT 1.000000", 1600),
-    ("PNChp 60000-1neg 354211082", 50000, "VOLT 50000.000000", 60000.1),
-    ("PNC 100000-6pos 375214277", 100, "VOLT 100.000000", 101),
-]
-
-
-@pytest.mark.parametrize("device_data", devices_u)
-def test_pnc_set_voltage(start_pnc_device, device_data):
-    started_pnc = start_pnc_device(device_data[0])
-    com, pnc = next(started_pnc)
-
-    # test if the correct text is sent to the com
-    pnc.set_voltage(device_data[1])
-    assert com.get_written().strip() == device_data[2]
-
-    # test if an error is raised when trying to set a too high voltage
-    with pytest.raises(dev.HeinzingerPNCMaxVoltageExceededException):
-        pnc.set_voltage(device_data[3])
-
-
-# test different values for voltage and current
-devices_i = [
-    ("PNC 600-3000pos 375214277", 2.999999, "CURR 2.999999", 1000),
-    ("PNChp 1500-40 ump. 375214277", 39, "CURR 39.000000", 41),
-    ("PNChp 60000-1neg 354211082", 1, "CURR 1.000000", 2),
-    ("PNC 100000-6pos 375214277", 0, "CURR 0.000000", 6.1),
-]
-
-
-@pytest.mark.parametrize("device_data", devices_i)
-def test_pnc_set_current(start_pnc_device, device_data):
-    started_pnc = start_pnc_device(device_data[0])
-    com, pnc = next(started_pnc)
-
-    # test if the correct text is sent to the com
-    pnc.set_current(device_data[1])
-    assert com.get_written().strip() == device_data[2]
-
-    # test if an error is raised when trying to set a too high current
-    with pytest.raises(dev.HeinzingerPNCMaxCurrentExceededException):
-        pnc.set_current(device_data[3])
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the .dev.heinzinger_pnc sub-package.
+"""
+
+import logging
+
+import pytest
+
+from hvl_ccb import comm, dev
+from masked_comm.serial import HeinzingerLoopSerialCommunication
+
+logging.basicConfig(level=logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": dev.HeinzingerSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.HeinzingerSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.HeinzingerSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 3,
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 5,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "default_number_of_recordings": 16,
+        "number_of_decimals": 6,
+        "wait_sec_stop_commands": 0.01,
+    }
+
+
+class ConcreteHeinzingerDI(dev.HeinzingerDI):
+    def start(self):
+        super().start()
+
+
+@pytest.fixture
+def started_heinzinger_di(com_config, dev_config):
+    serial_port = HeinzingerLoopSerialCommunication(com_config)
+    serial_port.open()
+    serial_port.put_text("my_interface_version")
+    with ConcreteHeinzingerDI(serial_port, dev_config) as di:
+        while serial_port.get_written() is not None:
+            pass
+        yield serial_port, di
+
+
+@pytest.fixture
+def start_pnc_device(com_config, dev_config):
+    def _start_pnc_device(serial_number):
+        serial_port = HeinzingerLoopSerialCommunication(com_config)
+        serial_port.open()
+        serial_port.put_text("my_interface_version")
+        serial_port.put_text(serial_number)
+
+        def started_pnc():
+            with dev.HeinzingerPNC(serial_port, dev_config) as pnc:
+                while serial_port.get_written() is not None:
+                    pass
+                yield serial_port, pnc
+
+        return started_pnc()
+
+    return _start_pnc_device
+
+
+def test_di_number_of_recordings(started_heinzinger_di):
+    com, di = started_heinzinger_di
+
+    # set a new value
+    di.set_number_of_recordings(4)
+    assert com.get_written() == "AVER 4"
+
+    com.put_text("4")
+    assert di.get_number_of_recordings() == 4
+
+    # assigning integer not amongst accepted values
+    with pytest.raises(ValueError):
+        di.set_number_of_recordings(3)
+
+
+def test_com_config(com_config):
+    config = dev.HeinzingerSerialCommunicationConfig(**com_config)
+    for key, value in com_config.items():
+        assert getattr(config, key) == value
+
+
+def test_dev_config(dev_config):
+    # currently there are no non-default config values
+    dev.HeinzingerConfig()
+
+    config = dev.HeinzingerConfig(**dev_config)
+    for key, value in dev_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"default_number_of_recordings": 0},
+        {"number_of_decimals": 0},
+        {"number_of_decimals": 11},
+        {"wait_sec_stop_commands": 0},
+        {"number_of_decimals": 6, "wait_sec_stop_commands": -1},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_config_dict):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        dev.HeinzingerConfig(**invalid_config)
+
+
+def test_di_instantiation(com_config, dev_config):
+    di = ConcreteHeinzingerDI(com_config)
+    assert di is not None
+
+    di = ConcreteHeinzingerDI(com_config, dev_config)
+    assert di is not None
+
+
+def test_di_start(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    # starting again should work
+    com.put_text("my_interface_version")
+    di.start()
+    assert com.get_written() == "VERS?"
+
+
+def test_di_stop(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    # starting again should work
+    di.stop()
+    assert com.get_written() == "VOLT 0.000000"
+    assert com.get_written() == "OUTP OFF"
+
+    # check that a second stop() works
+    di.stop()
+    assert not com.get_written()
+
+
+def test_di_output_status(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    assert di.output_status == di.OutputStatus.UNKNOWN
+    di.output_on()
+    assert di.output_status == di.OutputStatus.ON
+    di.output_off()
+    assert di.output_status == di.OutputStatus.OFF
+
+
+def test_di_output_on(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    di.output_on()
+    assert com.get_written() == "OUTP ON"
+    assert di.output_status == di.OutputStatus.ON
+
+
+def test_di_output_off(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    di.output_off()
+    assert com.get_written() == "OUTP OFF"
+    assert di.output_status == di.OutputStatus.OFF
+
+
+def test_di_set_voltage(started_heinzinger_di):
+    com, di = started_heinzinger_di
+
+    # test if the correct text is sent to the com
+    di.set_voltage(0.123456789)
+    assert com.get_written().strip() == "VOLT 0.123457"
+
+
+def test_di_measure_voltage(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    volt = 1.2
+    com.put_text(str(volt))
+    result = di.measure_voltage()
+    assert result == volt and com.get_written() == "MEAS:VOLT?"
+
+
+def test_di_set_current(started_heinzinger_di):
+    com, di = started_heinzinger_di
+
+    # test if the correct text is sent to the com
+    di.set_current(0.123456789)
+    assert com.get_written().strip() == "CURR 0.123457"
+
+
+def test_di_measure_current(started_heinzinger_di):
+    com, di = started_heinzinger_di
+    curr = 0.25
+    com.put_text(str(curr))
+    result = di.measure_current()
+    assert result == curr and com.get_written() == "MEAS:CURR?"
+
+
+def test_di_com_error(com_config, dev_config):
+
+    wrong_config = dict(com_config)
+    wrong_config["port"] = "NOT A PORT"
+    di = ConcreteHeinzingerDI(wrong_config, dev_config)
+    assert not di.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.start()
+
+    di = ConcreteHeinzingerDI(com_config, dev_config)
+    assert not di.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.reset_interface()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.get_interface_version()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.get_serial_number()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.output_on()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.output_off()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.get_number_of_recordings()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.set_number_of_recordings(dev.HeinzingerConfig.RecordingsEnum.EIGHT)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.measure_voltage()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.set_voltage(1)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.get_voltage()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.measure_current()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.set_current(1)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        di.get_current()
+
+
+def test_pnc_instantiation(com_config, dev_config):
+    pnc = dev.HeinzingerPNC(com_config)
+    assert pnc is not None
+
+    wrong_config = dict(dev_config)
+    wrong_config["default_number_of_recordings"] = 0
+    with pytest.raises(ValueError):
+        dev.HeinzingerPNC(com_config, wrong_config)
+
+    assert pnc.unit_voltage == dev.HeinzingerPNC.UnitVoltage.UNKNOWN
+    assert pnc.unit_current == dev.HeinzingerPNC.UnitCurrent.UNKNOWN
+
+
+def test_pnc_com_error(com_config, dev_config):
+    pnc = dev.HeinzingerPNC(com_config)
+    assert not pnc.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        pnc.identify_device()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        pnc.set_voltage(0)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        pnc.set_current(0)
+
+
+# test different possible serial numbers to check if the info is read correctly
+devices_data = [
+    ("PNChp 60000-1neg 354211082", 60000, 1, dev.HeinzingerPNC.UnitVoltage.V, "mA"),
+    ("314807440/PNChp 60000-1neg.", 60000, 1, "V", dev.HeinzingerPNC.UnitCurrent.mA),
+    ("PNChp 1500-40 ump. 375214277", 1500, 40, "V", "mA"),
+    ("PNC 100000-6pos 375214277", 100, 6, dev.HeinzingerPNC.UnitVoltage.kV, "mA"),
+    ("PNC 600-3000pos 375214277", 600, 3, "V", dev.HeinzingerPNC.UnitCurrent.A),
+]
+
+
+@pytest.mark.parametrize("device_data", devices_data)
+def test_pnc_start(start_pnc_device, com_config, device_data):
+    started_pnc = start_pnc_device(device_data[0])
+    com, pnc = next(started_pnc)
+
+    # starting the device again should work
+    com.put_text("my_interface_version")
+    com.put_text(device_data[0])
+    pnc.start()
+    assert com.get_written() == "VERS?"
+    assert com.get_written() == "*IDN?"
+    assert pnc.max_voltage_hardware == pnc.max_voltage == device_data[1]
+    assert pnc.max_current_hardware == pnc.max_current == device_data[2]
+    assert pnc.unit_voltage == device_data[3]
+    assert pnc.unit_current == device_data[4]
+    assert com.get_written() == "AVER " + str(
+        pnc.config.default_number_of_recordings.value
+    )
+
+
+def test_pnc_not_recognized(start_pnc_device):
+    with pytest.raises(dev.HeinzingerPNCDeviceNotRecognizedException):
+        next(start_pnc_device("ABC 600-3000pos 375214277"))
+
+
+def test_pnc_set_max_voltage(start_pnc_device):
+    started_pnc = start_pnc_device("PNC 600-3000pos 375214277")
+    com, pnc = next(started_pnc)
+
+    # set max_voltage to half the current value
+    next_value = pnc.max_voltage / 2
+    pnc.max_voltage = next_value
+    assert pnc.max_voltage == next_value
+
+    # assigning value higher than hardware maximum
+    with pytest.raises(ValueError):
+        pnc.max_voltage = pnc.max_voltage_hardware * 2
+
+    # assigning negative value
+    with pytest.raises(ValueError):
+        pnc.max_voltage = -1
+
+
+def test_pnc_set_max_current(start_pnc_device):
+    started_pnc = start_pnc_device("PNC 600-3000pos 375214277")
+    com, pnc = next(started_pnc)
+
+    # set max_voltage to half the current value
+    next_value = pnc.max_current / 2
+    pnc.max_current = next_value
+    assert pnc.max_current == next_value
+
+    # assigning value higher than hardware maximum
+    with pytest.raises(ValueError):
+        pnc.max_current = pnc.max_current_hardware * 2
+
+    # assigning negative value
+    with pytest.raises(ValueError):
+        pnc.max_current = -1
+
+
+# test different values for voltage and current
+devices_u = [
+    ("PNC 600-3000pos 375214277", 600, "VOLT 600.000000", 700),
+    ("PNChp 1500-40 ump. 375214277", 1, "VOLT 1.000000", 1600),
+    ("PNChp 60000-1neg 354211082", 50000, "VOLT 50000.000000", 60000.1),
+    ("PNC 100000-6pos 375214277", 100, "VOLT 100.000000", 101),
+]
+
+
+@pytest.mark.parametrize("device_data", devices_u)
+def test_pnc_set_voltage(start_pnc_device, device_data):
+    started_pnc = start_pnc_device(device_data[0])
+    com, pnc = next(started_pnc)
+
+    # test if the correct text is sent to the com
+    pnc.set_voltage(device_data[1])
+    assert com.get_written().strip() == device_data[2]
+
+    # test if an error is raised when trying to set a too high voltage
+    with pytest.raises(dev.HeinzingerPNCMaxVoltageExceededException):
+        pnc.set_voltage(device_data[3])
+
+
+# test different values for voltage and current
+devices_i = [
+    ("PNC 600-3000pos 375214277", 2.999999, "CURR 2.999999", 1000),
+    ("PNChp 1500-40 ump. 375214277", 39, "CURR 39.000000", 41),
+    ("PNChp 60000-1neg 354211082", 1, "CURR 1.000000", 2),
+    ("PNC 100000-6pos 375214277", 0, "CURR 0.000000", 6.1),
+]
+
+
+@pytest.mark.parametrize("device_data", devices_i)
+def test_pnc_set_current(start_pnc_device, device_data):
+    started_pnc = start_pnc_device(device_data[0])
+    com, pnc = next(started_pnc)
+
+    # test if the correct text is sent to the com
+    pnc.set_current(device_data[1])
+    assert com.get_written().strip() == device_data[2]
+
+    # test if an error is raised when trying to set a too high current
+    with pytest.raises(dev.HeinzingerPNCMaxCurrentExceededException):
+        pnc.set_current(device_data[3])
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_labjack.py` & `hvl_ccb-0.9.0/tests/test_dev_labjack.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,332 +1,332 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the dev.labjack module.
-"""
-
-import pytest
-
-from hvl_ccb.dev import LabJack, LabJackError, LabJackIdentifierDIOError
-from masked_comm import MaskedLJMCommunication
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "device_type": "ANY",
-        "connection_type": "ANY",
-        "identifier": "-2"  # identifier = -2 specifies LJM DEMO mode, see
-        # https://labjack.com/support/software/api/ljm/demo-mode
-    }
-
-
-@pytest.fixture
-def started_dev_comm(com_config):
-    com = MaskedLJMCommunication(com_config)
-    with LabJack(com) as lj:
-        yield lj, com
-
-
-def _force_dt(lj, com, dt):
-    com.config.force_value("device_type", dt)
-    com.put_name("PRODUCT_ID", dt.p_id)
-    lj.get_product_type(force_query_id=True)
-
-
-@pytest.fixture
-def started_dev_comm_with_t7pro(started_dev_comm):
-    lj, com = started_dev_comm
-    # force T7-Pro device for following tests
-    _force_dt(lj, com, com.config.DeviceType.T7_PRO)
-    lj.get_product_type()
-    yield lj, com
-
-
-@pytest.fixture
-def started_dev_comm_with_t4(started_dev_comm):
-    lj, com = started_dev_comm
-    # force T4 device for following tests
-    _force_dt(lj, com, com.config.DeviceType.T4)
-    lj.get_product_type()
-    yield lj, com
-
-
-def test_instantiation(com_config):
-    lj = LabJack(com_config)
-    assert lj is not None
-
-
-def test_get_serial_number(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("SERIAL_NUMBER", 1234)
-    assert lj.get_serial_number() == 1234
-    with pytest.raises(TypeError):
-        com.put_name("SERIAL_NUMBER", 1234.5)
-        lj.get_serial_number()
-
-
-def test_get_sbus_temp(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("SBUS0_TEMP", 298.15)
-    assert lj.get_sbus_temp(0) == 298.15
-    com.put_name("SBUS0_TEMP", "Not a float")
-    with pytest.raises(TypeError):
-        lj.get_sbus_temp(0)
-
-
-def test_get_sbus_rh(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("SBUS0_RH", 40.5)
-    assert lj.get_sbus_rh(0) == 40.5
-    com.put_name("SBUS0_RH", "Not a float")
-    with pytest.raises(TypeError):
-        lj.get_sbus_rh(0)
-
-
-def test_get_ain(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("AIN0", 1.23)
-    assert lj.get_ain(0) == 1.23
-    # multiple reads at once
-    channels = ("AIN0", "AIN1")
-    outputs = (5.00, 0.16)
-    for channel, output in zip(channels, outputs):
-        com.put_name(channel, output)
-    assert lj.get_ain(0, 1) == outputs
-
-
-def test_set_ain_range(started_dev_comm):
-    lj, com = started_dev_comm
-
-    lj.set_ain_range(0, lj.AInRange.TEN)
-    assert com.get_written() == ("AIN0_RANGE", 10)
-
-    lj.set_ain_range(0, lj.AInRange.ONE_TENTH)
-    assert com.get_written() == ("AIN0_RANGE", 0.1)
-
-    with pytest.raises(ValueError):
-        lj.set_ain_range(0, 0.2)
-    assert com.get_written() is None
-
-
-def test_set_ain_resolution(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-
-    ain_max_res = com.config.device_type.ain_max_resolution
-    with pytest.raises(LabJackError):
-        lj.set_ain_resolution(0, ain_max_res + 1)
-    assert com.get_written() is None
-
-    for res in range(ain_max_res + 1):
-        lj.set_ain_resolution(0, res)
-        assert com.get_written() == ("AIN0_RESOLUTION_INDEX", res)
-
-    with pytest.raises(LabJackError):
-        lj.set_ain_resolution(0, -1)
-    assert com.get_written() is None
-
-    with pytest.raises(LabJackError):
-        lj.set_ain_resolution(0, com.config.device_type.ain_max_resolution + 1)
-    assert com.get_written() is None
-
-
-def test_set_ain_differential(started_dev_comm):
-    lj, com = started_dev_comm
-
-    lj.set_ain_differential(4, True)
-    assert com.get_written() == ("AIN4_NEGATIVE_CH", 5)
-
-    lj.set_ain_differential(4, False)
-    assert com.get_written() == ("AIN4_NEGATIVE_CH", 199)
-
-    with pytest.raises(LabJackError):
-        lj.set_ain_differential(5, True)
-    assert com.get_written() is None
-
-    with pytest.raises(LabJackError):
-        lj.set_ain_differential(14, True)
-    assert com.get_written() is None
-
-
-def test_set_ain_thermocouple(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-
-    lj.set_ain_thermocouple(0, None)
-    lj.set_ain_thermocouple(0, lj.ThermocoupleType.NONE)
-    lj.set_ain_thermocouple(0, "K")
-    lj.set_ain_thermocouple(0, lj.ThermocoupleType.K)
-    with pytest.raises(ValueError):
-        lj.set_ain_thermocouple(0, "B")
-
-    lj.set_ain_thermocouple(0, thermocouple="T", unit="F")
-    lj.set_ain_thermocouple(0, thermocouple="T", unit=lj.TemperatureUnit.F)
-    with pytest.raises(ValueError):
-        lj.set_ain_thermocouple(0, "K", unit="B")
-
-    lj.set_ain_thermocouple(0, thermocouple="T", cjc_type="lm34")
-    lj.set_ain_thermocouple(0, thermocouple="T", cjc_type=lj.CjcType.lm34)
-    with pytest.raises(ValueError):
-        lj.set_ain_thermocouple(0, "K", cjc_type="LM35")
-
-
-def test_read_thermocouple(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("AIN0_EF_READ_A", 244.3)
-    assert lj.read_thermocouple(0) == 244.30
-    com.put_name("AIN0_EF_READ_A", "Not a float")
-    with pytest.raises(TypeError):
-        lj.read_thermocouple(0)
-
-
-def test_read_resistance(started_dev_comm):
-    lj, com = started_dev_comm
-    com.put_name("AIN0_EF_READ_A", 20.00)
-    assert lj.read_resistance(0) == 20.00
-    com.put_name("AIN0_EF_READ_A", "Not a float")
-    with pytest.raises(TypeError):
-        lj.read_resistance(0)
-
-
-def test_set_ain_resistance(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.set_ain_resistance(channel=2, vrange=lj.AInRange.ONE, resolution=8)
-
-
-def test_get_product_id(started_dev_comm):
-    lj, com = started_dev_comm
-    p_id = com.config.device_type.p_id
-    com.put_name("PRODUCT_ID", p_id)
-    assert lj.get_product_id() is int(p_id)
-    for wrong_p_id in ("Not an ID", 4.7):
-        com.put_name("PRODUCT_ID", wrong_p_id)
-        with pytest.raises(TypeError):
-            lj.get_product_id()
-
-
-def test_get_product_type(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    assert lj.get_product_type() is com.config.device_type
-    # config device matches none of T7 devices from ID
-    com.config.force_value("device_type", com.config.DeviceType.T4)
-    com.put_name("PRODUCT_ID", com.config.DeviceType.T7_PRO.p_id)
-    with pytest.raises(LabJackIdentifierDIOError):
-        lj.get_product_type(force_query_id=True)
-    # force no device type configured for the following tests => return T7 as a first
-    # to match the unambiguous product ID for T7 devices
-    com.config.force_value("device_type", None)
-    com.put_name("PRODUCT_ID", com.config.DeviceType.T7_PRO.p_id)
-    assert lj.get_product_type(force_query_id=True) is com.config.DeviceType.T7
-    # force specific device type for following tests
-    for dt in (
-        com.config.DeviceType.T7_PRO,
-        com.config.DeviceType.T7,
-        com.config.DeviceType.T4,
-    ):
-        _force_dt(lj, com, dt)
-        assert lj.get_product_type() is dt
-
-
-def test_get_product_name(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    assert lj.get_product_name() == lj.com.config.device_type
-
-
-def test_get_cal_current_source(started_dev_comm):
-    lj, com = started_dev_comm
-    for ten_name in ("10uA", lj.CalMicroAmpere.TEN):
-        com.put_name(lj.CalMicroAmpere.TEN.current_source_query, 10.001)
-        assert lj.get_cal_current_source(ten_name) == 10.001
-    com.put_name(lj.CalMicroAmpere.TEN.current_source_query, "Not a float")
-    with pytest.raises(TypeError):
-        lj.get_cal_current_source(lj.CalMicroAmpere.TEN)
-    for two_hundred_name in ("200uA", lj.CalMicroAmpere.TWO_HUNDRED):
-        com.put_name(lj.CalMicroAmpere.TWO_HUNDRED.current_source_query, 200.001)
-        assert lj.get_cal_current_source(two_hundred_name) == 200.001
-
-
-def test_get_digital_input(started_dev_comm_with_t4):
-    lj, com = started_dev_comm_with_t4
-
-    com.put_name("EIO0", lj.DIOStatus.LOW)
-    assert lj.get_digital_input("EIO0") == lj.DIOStatus.LOW
-    com.put_name("EIO0", lj.DIOStatus.HIGH)
-    assert lj.get_digital_input("EIO0") == lj.DIOStatus.HIGH
-    com.put_name("EIO0", 2.0)
-    with pytest.raises(LabJackIdentifierDIOError):
-        lj.get_digital_input("EIO0")
-
-    with pytest.raises(TypeError):
-        com.put_name("EIO0", 2.5)
-        lj.get_digital_input("EIO0")
-
-    with pytest.raises(ValueError):
-        lj.get_digital_input("Not a DIO Channel address")
-
-    dio = lj.DIOChannel.MIO0  # only avail on T7
-    com.put_name(dio.name, 0)
-    with pytest.raises(LabJackIdentifierDIOError):
-        lj.get_digital_input(dio)
-
-
-def test_set_digital_output(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-
-    lj.set_digital_output("FIO0", lj.DIOStatus.HIGH)
-    assert com.get_written() == ("FIO0", lj.DIOStatus.HIGH)
-
-    with pytest.raises(LabJackIdentifierDIOError):
-        lj.set_digital_output("AIO0", 1)
-
-
-def test_get_clock(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.get_clock()
-
-
-def test_set_clock(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.set_clock()
-    lj.set_clock(80_000_000)
-    lj.set_clock(clock_frequency=5_000_000, clock_period=0)
-    with pytest.raises(ValueError):
-        lj.set_clock(10_000)
-    with pytest.raises(ValueError):
-        lj.set_clock(clock_frequency=80_000_000, clock_period=1_000_000)
-
-
-def test_config_high_pulse(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.config_high_pulse(address="FIO0", t_start=0, t_width=1)
-    with pytest.raises(LabJackError):
-        lj.config_high_pulse(address="FIO6", t_start=0, t_width=1)
-    lj.config_high_pulse(address="FIO0", t_start=999.999, t_width=.001, n_pulses=1000)
-    with pytest.raises(TypeError):
-        lj.config_high_pulse(address="FIO0", t_start=.21, t_width=.22, n_pulses=.23)
-    with pytest.raises(ValueError):
-        lj.config_high_pulse(address="FIO0", t_start=.2, t_width=-1)
-
-
-def test_send_pulses(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.configured_pulse_addresses = ["FIO0", "FIO2"]
-    lj.send_pulses("FIO0", "FIO2")
-    with pytest.raises(LabJackError):
-        lj.send_pulses("FIO0", "FIO3")
-
-
-def test_disable_pulses(started_dev_comm_with_t7pro):
-    lj, com = started_dev_comm_with_t7pro
-    lj.disable_pulses()
-    lj.configured_pulse_addresses = ["FIO0", "FIO2", "FIO4", "FIO5"]
-    lj.disable_pulses("FIO3", "FIO5")
-    lj.disable_pulses()
-    assert lj.configured_pulse_addresses == []
-
-
-def test_set_analog_output(started_dev_comm):
-    lj, com = started_dev_comm
-
-    lj.set_analog_output(1, 2.5)
-    assert com.get_written() == ("DAC1", 2.5)
-    lj.set_analog_output(0, 2)
-    assert com.get_written() == ("DAC0", 2)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the dev.labjack module.
+"""
+
+import pytest
+
+from hvl_ccb.dev import LabJack, LabJackError, LabJackIdentifierDIOError
+from masked_comm import MaskedLJMCommunication
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "device_type": "ANY",
+        "connection_type": "ANY",
+        "identifier": "-2"  # identifier = -2 specifies LJM DEMO mode, see
+        # https://labjack.com/support/software/api/ljm/demo-mode
+    }
+
+
+@pytest.fixture
+def started_dev_comm(com_config):
+    com = MaskedLJMCommunication(com_config)
+    with LabJack(com) as lj:
+        yield lj, com
+
+
+def _force_dt(lj, com, dt):
+    com.config.force_value("device_type", dt)
+    com.put_name("PRODUCT_ID", dt.p_id)
+    lj.get_product_type(force_query_id=True)
+
+
+@pytest.fixture
+def started_dev_comm_with_t7pro(started_dev_comm):
+    lj, com = started_dev_comm
+    # force T7-Pro device for following tests
+    _force_dt(lj, com, com.config.DeviceType.T7_PRO)
+    lj.get_product_type()
+    yield lj, com
+
+
+@pytest.fixture
+def started_dev_comm_with_t4(started_dev_comm):
+    lj, com = started_dev_comm
+    # force T4 device for following tests
+    _force_dt(lj, com, com.config.DeviceType.T4)
+    lj.get_product_type()
+    yield lj, com
+
+
+def test_instantiation(com_config):
+    lj = LabJack(com_config)
+    assert lj is not None
+
+
+def test_get_serial_number(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("SERIAL_NUMBER", 1234)
+    assert lj.get_serial_number() == 1234
+    with pytest.raises(TypeError):
+        com.put_name("SERIAL_NUMBER", 1234.5)
+        lj.get_serial_number()
+
+
+def test_get_sbus_temp(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("SBUS0_TEMP", 298.15)
+    assert lj.get_sbus_temp(0) == 298.15
+    com.put_name("SBUS0_TEMP", "Not a float")
+    with pytest.raises(TypeError):
+        lj.get_sbus_temp(0)
+
+
+def test_get_sbus_rh(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("SBUS0_RH", 40.5)
+    assert lj.get_sbus_rh(0) == 40.5
+    com.put_name("SBUS0_RH", "Not a float")
+    with pytest.raises(TypeError):
+        lj.get_sbus_rh(0)
+
+
+def test_get_ain(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("AIN0", 1.23)
+    assert lj.get_ain(0) == 1.23
+    # multiple reads at once
+    channels = ("AIN0", "AIN1")
+    outputs = (5.00, 0.16)
+    for channel, output in zip(channels, outputs):
+        com.put_name(channel, output)
+    assert lj.get_ain(0, 1) == outputs
+
+
+def test_set_ain_range(started_dev_comm):
+    lj, com = started_dev_comm
+
+    lj.set_ain_range(0, lj.AInRange.TEN)
+    assert com.get_written() == ("AIN0_RANGE", 10)
+
+    lj.set_ain_range(0, lj.AInRange.ONE_TENTH)
+    assert com.get_written() == ("AIN0_RANGE", 0.1)
+
+    with pytest.raises(ValueError):
+        lj.set_ain_range(0, 0.2)
+    assert com.get_written() is None
+
+
+def test_set_ain_resolution(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+
+    ain_max_res = com.config.device_type.ain_max_resolution
+    with pytest.raises(LabJackError):
+        lj.set_ain_resolution(0, ain_max_res + 1)
+    assert com.get_written() is None
+
+    for res in range(ain_max_res + 1):
+        lj.set_ain_resolution(0, res)
+        assert com.get_written() == ("AIN0_RESOLUTION_INDEX", res)
+
+    with pytest.raises(LabJackError):
+        lj.set_ain_resolution(0, -1)
+    assert com.get_written() is None
+
+    with pytest.raises(LabJackError):
+        lj.set_ain_resolution(0, com.config.device_type.ain_max_resolution + 1)
+    assert com.get_written() is None
+
+
+def test_set_ain_differential(started_dev_comm):
+    lj, com = started_dev_comm
+
+    lj.set_ain_differential(4, True)
+    assert com.get_written() == ("AIN4_NEGATIVE_CH", 5)
+
+    lj.set_ain_differential(4, False)
+    assert com.get_written() == ("AIN4_NEGATIVE_CH", 199)
+
+    with pytest.raises(LabJackError):
+        lj.set_ain_differential(5, True)
+    assert com.get_written() is None
+
+    with pytest.raises(LabJackError):
+        lj.set_ain_differential(14, True)
+    assert com.get_written() is None
+
+
+def test_set_ain_thermocouple(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+
+    lj.set_ain_thermocouple(0, None)
+    lj.set_ain_thermocouple(0, lj.ThermocoupleType.NONE)
+    lj.set_ain_thermocouple(0, "K")
+    lj.set_ain_thermocouple(0, lj.ThermocoupleType.K)
+    with pytest.raises(ValueError):
+        lj.set_ain_thermocouple(0, "B")
+
+    lj.set_ain_thermocouple(0, thermocouple="T", unit="F")
+    lj.set_ain_thermocouple(0, thermocouple="T", unit=lj.TemperatureUnit.F)
+    with pytest.raises(ValueError):
+        lj.set_ain_thermocouple(0, "K", unit="B")
+
+    lj.set_ain_thermocouple(0, thermocouple="T", cjc_type="lm34")
+    lj.set_ain_thermocouple(0, thermocouple="T", cjc_type=lj.CjcType.lm34)
+    with pytest.raises(ValueError):
+        lj.set_ain_thermocouple(0, "K", cjc_type="LM35")
+
+
+def test_read_thermocouple(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("AIN0_EF_READ_A", 244.3)
+    assert lj.read_thermocouple(0) == 244.30
+    com.put_name("AIN0_EF_READ_A", "Not a float")
+    with pytest.raises(TypeError):
+        lj.read_thermocouple(0)
+
+
+def test_read_resistance(started_dev_comm):
+    lj, com = started_dev_comm
+    com.put_name("AIN0_EF_READ_A", 20.00)
+    assert lj.read_resistance(0) == 20.00
+    com.put_name("AIN0_EF_READ_A", "Not a float")
+    with pytest.raises(TypeError):
+        lj.read_resistance(0)
+
+
+def test_set_ain_resistance(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.set_ain_resistance(channel=2, vrange=lj.AInRange.ONE, resolution=8)
+
+
+def test_get_product_id(started_dev_comm):
+    lj, com = started_dev_comm
+    p_id = com.config.device_type.p_id
+    com.put_name("PRODUCT_ID", p_id)
+    assert lj.get_product_id() is int(p_id)
+    for wrong_p_id in ("Not an ID", 4.7):
+        com.put_name("PRODUCT_ID", wrong_p_id)
+        with pytest.raises(TypeError):
+            lj.get_product_id()
+
+
+def test_get_product_type(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    assert lj.get_product_type() is com.config.device_type
+    # config device matches none of T7 devices from ID
+    com.config.force_value("device_type", com.config.DeviceType.T4)
+    com.put_name("PRODUCT_ID", com.config.DeviceType.T7_PRO.p_id)
+    with pytest.raises(LabJackIdentifierDIOError):
+        lj.get_product_type(force_query_id=True)
+    # force no device type configured for the following tests => return T7 as a first
+    # to match the unambiguous product ID for T7 devices
+    com.config.force_value("device_type", None)
+    com.put_name("PRODUCT_ID", com.config.DeviceType.T7_PRO.p_id)
+    assert lj.get_product_type(force_query_id=True) is com.config.DeviceType.T7
+    # force specific device type for following tests
+    for dt in (
+        com.config.DeviceType.T7_PRO,
+        com.config.DeviceType.T7,
+        com.config.DeviceType.T4,
+    ):
+        _force_dt(lj, com, dt)
+        assert lj.get_product_type() is dt
+
+
+def test_get_product_name(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    assert lj.get_product_name() == lj.com.config.device_type
+
+
+def test_get_cal_current_source(started_dev_comm):
+    lj, com = started_dev_comm
+    for ten_name in ("10uA", lj.CalMicroAmpere.TEN):
+        com.put_name(lj.CalMicroAmpere.TEN.current_source_query, 10.001)
+        assert lj.get_cal_current_source(ten_name) == 10.001
+    com.put_name(lj.CalMicroAmpere.TEN.current_source_query, "Not a float")
+    with pytest.raises(TypeError):
+        lj.get_cal_current_source(lj.CalMicroAmpere.TEN)
+    for two_hundred_name in ("200uA", lj.CalMicroAmpere.TWO_HUNDRED):
+        com.put_name(lj.CalMicroAmpere.TWO_HUNDRED.current_source_query, 200.001)
+        assert lj.get_cal_current_source(two_hundred_name) == 200.001
+
+
+def test_get_digital_input(started_dev_comm_with_t4):
+    lj, com = started_dev_comm_with_t4
+
+    com.put_name("EIO0", lj.DIOStatus.LOW)
+    assert lj.get_digital_input("EIO0") == lj.DIOStatus.LOW
+    com.put_name("EIO0", lj.DIOStatus.HIGH)
+    assert lj.get_digital_input("EIO0") == lj.DIOStatus.HIGH
+    com.put_name("EIO0", 2.0)
+    with pytest.raises(LabJackIdentifierDIOError):
+        lj.get_digital_input("EIO0")
+
+    with pytest.raises(TypeError):
+        com.put_name("EIO0", 2.5)
+        lj.get_digital_input("EIO0")
+
+    with pytest.raises(ValueError):
+        lj.get_digital_input("Not a DIO Channel address")
+
+    dio = lj.DIOChannel.MIO0  # only avail on T7
+    com.put_name(dio.name, 0)
+    with pytest.raises(LabJackIdentifierDIOError):
+        lj.get_digital_input(dio)
+
+
+def test_set_digital_output(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+
+    lj.set_digital_output("FIO0", lj.DIOStatus.HIGH)
+    assert com.get_written() == ("FIO0", lj.DIOStatus.HIGH)
+
+    with pytest.raises(LabJackIdentifierDIOError):
+        lj.set_digital_output("AIO0", 1)
+
+
+def test_get_clock(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.get_clock()
+
+
+def test_set_clock(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.set_clock()
+    lj.set_clock(80_000_000)
+    lj.set_clock(clock_frequency=5_000_000, clock_period=0)
+    with pytest.raises(ValueError):
+        lj.set_clock(10_000)
+    with pytest.raises(ValueError):
+        lj.set_clock(clock_frequency=80_000_000, clock_period=1_000_000)
+
+
+def test_config_high_pulse(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.config_high_pulse(address="FIO0", t_start=0, t_width=1)
+    with pytest.raises(LabJackError):
+        lj.config_high_pulse(address="FIO6", t_start=0, t_width=1)
+    lj.config_high_pulse(address="FIO0", t_start=999.999, t_width=.001, n_pulses=1000)
+    with pytest.raises(TypeError):
+        lj.config_high_pulse(address="FIO0", t_start=.21, t_width=.22, n_pulses=.23)
+    with pytest.raises(ValueError):
+        lj.config_high_pulse(address="FIO0", t_start=.2, t_width=-1)
+
+
+def test_send_pulses(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.configured_pulse_addresses = ["FIO0", "FIO2"]
+    lj.send_pulses("FIO0", "FIO2")
+    with pytest.raises(LabJackError):
+        lj.send_pulses("FIO0", "FIO3")
+
+
+def test_disable_pulses(started_dev_comm_with_t7pro):
+    lj, com = started_dev_comm_with_t7pro
+    lj.disable_pulses()
+    lj.configured_pulse_addresses = ["FIO0", "FIO2", "FIO4", "FIO5"]
+    lj.disable_pulses("FIO3", "FIO5")
+    lj.disable_pulses()
+    assert lj.configured_pulse_addresses == []
+
+
+def test_set_analog_output(started_dev_comm):
+    lj, com = started_dev_comm
+
+    lj.set_analog_output(1, 2.5)
+    assert com.get_written() == ("DAC1", 2.5)
+    lj.set_analog_output(0, 2)
+    assert com.get_written() == ("DAC0", 2)
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_lauda.py` & `hvl_ccb-0.9.0/tests/test_dev_lauda.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,291 +1,291 @@
-#  Copyright (c) 2019-2020 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Testing Lauda PRO RP245E driver. Makes use of the socket library (TCP comm).
-"""
-
-import socket
-import time
-from concurrent.futures import ThreadPoolExecutor
-from unittest.mock import patch
-
-import pytest
-from pytest_mock import MockerFixture
-
-from hvl_ccb.dev import lauda
-from masked_comm import tcp
-
-_SOCK_TIMEOUT = 0.1
-
-fake_tcp = tcp.FakeTCP(_SOCK_TIMEOUT)
-
-
-def _get_free_tcp_port(host):
-    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
-        sock.bind((host, 0))
-        addr, port = sock.getsockname()
-    return port
-
-
-@pytest.fixture(scope="function")
-def com_config():
-    host = "127.0.0.1"
-    return {
-        "host": host,
-        "port": _get_free_tcp_port(host),  # find a free TCP port dynamically
-        "bufsize": 128,
-        "terminator": "\r\n",
-        "wait_sec_pre_read_or_write": 0.005,
-    }
-
-
-def test_com_config(com_config):
-    config = lauda.LaudaProRp245eTcpCommunicationConfig(**com_config)
-    for key, value in com_config.items():
-        assert getattr(config, key) == value
-
-
-# Test here only lauda-specific com fields; rest should be tested in tcp com tests
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"wait_sec_pre_read_or_write": -0.5},
-        {"terminator": "NotATerminator"},
-    ],
-)
-def test_invalid_com_config_dict(com_config, wrong_config_dict):
-    invalid_config = dict(com_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        lauda.LaudaProRp245eTcpCommunicationConfig(**invalid_config)
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "operation_mode": 2,
-        "control_mode": 0,
-    }
-
-
-def test_dev_config(dev_config):
-    # currently there are no non-default config values
-    lauda.LaudaProRp245eConfig()
-
-    config = lauda.LaudaProRp245eConfig(**dev_config)
-    for key, value in dev_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"operation_mode": 123},
-        {"control_mode": 123},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_config_dict):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        lauda.LaudaProRp245eConfig(**invalid_config)
-
-
-# Beware: scope has to match scope of the com_config fixture
-@pytest.fixture(scope="function")
-def startchiller(com_config) -> lauda:
-    with ThreadPoolExecutor(max_workers=1) as executor:
-        executor.submit(
-            fake_tcp.run_fake_server,
-            com_config["host"],
-            com_config["port"],
-            com_config["terminator"],
-            com_config["wait_sec_pre_read_or_write"],
-        )
-        # give some time to startup the server
-        time.sleep(_SOCK_TIMEOUT / 5)
-        with lauda.LaudaProRp245e(com_config) as chill:
-            yield chill
-
-
-def test_lauda_connected_to_wrong_device(com_config):
-    com = lauda.LaudaProRp245e.default_com_cls()(com_config)
-    with ThreadPoolExecutor(max_workers=1) as executor:
-        executor.submit(
-            fake_tcp.run_bad_fake_server,
-            com.config.host,
-            com.config.port,
-            com.config.terminator,
-            com.config.wait_sec_pre_read_or_write,
-        )
-        # give some time to startup the server
-        time.sleep(_SOCK_TIMEOUT / 5)
-        with pytest.raises(lauda.LaudaProRp245eCommandError):
-            lauda.LaudaProRp245e(com).start()
-        # manually stop the bad server
-        com.query_command(lauda.LaudaProRp245eCommand.STOP)
-
-
-def test_get_device_type(startchiller):
-    chill = startchiller
-    assert chill.get_device_type() == "RP245 PRO"
-
-
-def test_pause(startchiller, mocker: MockerFixture):
-    chill = startchiller
-
-    def pause(self):
-        # prevent premature shutdown of module-scoped test tcp server by sending
-        # lowercase `STOP` command (cf. `run_fake_server` above)
-        with self.com.access_lock:
-            super(lauda.LaudaProRp245eTcpCommunication, self.com).write(
-                lauda.LaudaProRp245eCommand.STOP.value.lower()
-                + self.com.config.terminator
-            )
-            reply = self.com.read()
-        if "ERR" in reply:
-            raise lauda.LaudaProRp245eCommandError
-        return reply.upper()
-
-    mocker.patch(
-        "hvl_ccb.dev.lauda.LaudaProRp245e.pause",
-        side_effect=pause,
-        autospec=True,
-    )
-
-    assert chill.pause() == lauda.LaudaProRp245eCommand.STOP.value
-
-
-def test_read_error(startchiller):
-    chill = startchiller
-
-    with patch(
-        "hvl_ccb.dev.lauda.LaudaProRp245eTcpCommunication.read",
-        return_value="ERR",
-    ):
-        with pytest.raises(lauda.LaudaProRp245eCommandError):
-            # don't use pause() as it sends successful STOP that kills the FakeTCP
-            chill.start_ramp()
-
-
-def test_run(startchiller):
-    chill = startchiller
-    assert chill.run() == lauda.LaudaProRp245eCommand.START.value
-
-
-def test_set_external_temp(startchiller):
-    chill = startchiller
-    ext = 20.00
-    assert chill.set_external_temp(ext) == "".join(
-        [lauda.LaudaProRp245eCommand.EXTERNAL_TEMP.value, "%.2f" % ext]
-    )
-
-
-def test_set_temp_set_point(startchiller):
-    chill = startchiller
-    ext = 25.00
-    assert chill.set_temp_set_point(ext) == "".join(
-        [lauda.LaudaProRp245eCommand.TEMP_SET_POINT.value, "%.2f" % ext]
-    )
-
-
-def test_correct_pump_level(startchiller):
-    chill = startchiller
-    ext = 3
-    assert (
-        chill.set_pump_level(ext)
-        == f"{lauda.LaudaProRp245eCommand.PUMP_LEVEL.value}{ext}"
-    )
-
-
-def test_wrong_pump_level(startchiller):
-    chill = startchiller
-    ext = 15
-    with pytest.raises(ValueError):
-        chill.set_pump_level(ext)
-
-
-def test_correct_control_mode(startchiller):
-    chill = startchiller
-    ext = 0
-    assert (
-        chill.set_control_mode(0)
-        == f"{lauda.LaudaProRp245eCommand.CONT_MODE.value}{ext}"
-    )
-
-
-def test_wrong_control_mode(startchiller):
-    chill = startchiller
-    with pytest.raises(ValueError):
-        chill.set_control_mode(6)
-
-
-def test_correct_ramp_program(startchiller):
-    chill = startchiller
-    ext = 1
-    assert chill.set_ramp_program(ext) == "".join(
-        [lauda.LaudaProRp245eCommand.RAMP_SELECT.value, str(ext)]
-    )
-
-
-def test_wrong_ramp_program(startchiller):
-    chill = startchiller
-    with pytest.raises(ValueError):
-        chill.set_ramp_program(6)
-
-
-def test_start_ramp(startchiller):
-    chill = startchiller
-    assert chill.start_ramp() == lauda.LaudaProRp245eCommand.RAMP_START.value
-
-
-def test_pause_ramp(startchiller):
-    chill = startchiller
-    assert chill.pause_ramp() == lauda.LaudaProRp245eCommand.RAMP_PAUSE.value
-
-
-def test_continue_ramp(startchiller):
-    chill = startchiller
-    assert chill.continue_ramp() == lauda.LaudaProRp245eCommand.RAMP_CONTINUE.value
-
-
-def test_stop_ramp(startchiller):
-    chill = startchiller
-    assert chill.stop_ramp() == lauda.LaudaProRp245eCommand.RAMP_STOP.value
-
-
-def test_set_ramp_iterations(startchiller):
-    chill = startchiller
-    ext = 3
-    assert chill.set_ramp_iterations(ext) == "".join(
-        [lauda.LaudaProRp245eCommand.RAMP_ITERATIONS.value, str(ext)]
-    )
-
-
-def test_reset_ramp(startchiller):
-    chill = startchiller
-    assert chill.reset_ramp() == lauda.LaudaProRp245eCommand.RAMP_DELETE.value
-
-
-def test_set_ramp_segment(startchiller):
-    chill = startchiller
-    temp = 10.00
-    dur = 0
-    tol = 0.00
-    pump = 3
-    segment = f"{temp:.2f}_{dur}_{tol:.2f}_{pump}"
-    assert (
-        chill.set_ramp_segment(temp, dur, tol, pump)
-        == f"{lauda.LaudaProRp245eCommand.RAMP_SET.value}{segment}"
-    )
-
-
-def test_get_bath_temp(startchiller):
-    chill = startchiller
-    assert chill.get_bath_temp() == 25.00
-
-
-def test_returns_error(startchiller):
-    chill = startchiller
-    with pytest.raises(lauda.LaudaProRp245eCommandError):
-        chill.com.query_command("FOOBAR")
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Testing Lauda PRO RP245E driver. Makes use of the socket library (TCP comm).
+"""
+
+import socket
+import time
+from concurrent.futures import ThreadPoolExecutor
+from unittest.mock import patch
+
+import pytest
+from pytest_mock import MockerFixture
+
+from hvl_ccb.dev import lauda
+from masked_comm import tcp
+
+_SOCK_TIMEOUT = 0.1
+
+fake_tcp = tcp.FakeTCP(_SOCK_TIMEOUT)
+
+
+def _get_free_tcp_port(host):
+    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
+        sock.bind((host, 0))
+        addr, port = sock.getsockname()
+    return port
+
+
+@pytest.fixture(scope="function")
+def com_config():
+    host = "127.0.0.1"
+    return {
+        "host": host,
+        "port": _get_free_tcp_port(host),  # find a free TCP port dynamically
+        "bufsize": 128,
+        "terminator": "\r\n",
+        "wait_sec_pre_read_or_write": 0.005,
+    }
+
+
+def test_com_config(com_config):
+    config = lauda.LaudaProRp245eTcpCommunicationConfig(**com_config)
+    for key, value in com_config.items():
+        assert getattr(config, key) == value
+
+
+# Test here only lauda-specific com fields; rest should be tested in tcp com tests
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"wait_sec_pre_read_or_write": -0.5},
+        {"terminator": "NotATerminator"},
+    ],
+)
+def test_invalid_com_config_dict(com_config, wrong_config_dict):
+    invalid_config = dict(com_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        lauda.LaudaProRp245eTcpCommunicationConfig(**invalid_config)
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "operation_mode": 2,
+        "control_mode": 0,
+    }
+
+
+def test_dev_config(dev_config):
+    # currently there are no non-default config values
+    lauda.LaudaProRp245eConfig()
+
+    config = lauda.LaudaProRp245eConfig(**dev_config)
+    for key, value in dev_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"operation_mode": 123},
+        {"control_mode": 123},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_config_dict):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        lauda.LaudaProRp245eConfig(**invalid_config)
+
+
+# Beware: scope has to match scope of the com_config fixture
+@pytest.fixture(scope="function")
+def startchiller(com_config) -> lauda:
+    with ThreadPoolExecutor(max_workers=1) as executor:
+        executor.submit(
+            fake_tcp.run_fake_server,
+            com_config["host"],
+            com_config["port"],
+            com_config["terminator"],
+            com_config["wait_sec_pre_read_or_write"],
+        )
+        # give some time to startup the server
+        time.sleep(_SOCK_TIMEOUT / 5)
+        with lauda.LaudaProRp245e(com_config) as chill:
+            yield chill
+
+
+def test_lauda_connected_to_wrong_device(com_config):
+    com = lauda.LaudaProRp245e.default_com_cls()(com_config)
+    with ThreadPoolExecutor(max_workers=1) as executor:
+        executor.submit(
+            fake_tcp.run_bad_fake_server,
+            com.config.host,
+            com.config.port,
+            com.config.terminator,
+            com.config.wait_sec_pre_read_or_write,
+        )
+        # give some time to startup the server
+        time.sleep(_SOCK_TIMEOUT / 5)
+        with pytest.raises(lauda.LaudaProRp245eCommandError):
+            lauda.LaudaProRp245e(com).start()
+        # manually stop the bad server
+        com.query_command(lauda.LaudaProRp245eCommand.STOP)
+
+
+def test_get_device_type(startchiller):
+    chill = startchiller
+    assert chill.get_device_type() == "RP245 PRO"
+
+
+def test_pause(startchiller, mocker: MockerFixture):
+    chill = startchiller
+
+    def pause(self):
+        # prevent premature shutdown of module-scoped test tcp server by sending
+        # lowercase `STOP` command (cf. `run_fake_server` above)
+        with self.com.access_lock:
+            super(lauda.LaudaProRp245eTcpCommunication, self.com).write(
+                lauda.LaudaProRp245eCommand.STOP.value.lower()
+                + self.com.config.terminator
+            )
+            reply = self.com.read()
+        if "ERR" in reply:
+            raise lauda.LaudaProRp245eCommandError
+        return reply.upper()
+
+    mocker.patch(
+        "hvl_ccb.dev.lauda.LaudaProRp245e.pause",
+        side_effect=pause,
+        autospec=True,
+    )
+
+    assert chill.pause() == lauda.LaudaProRp245eCommand.STOP.value
+
+
+def test_read_error(startchiller):
+    chill = startchiller
+
+    with patch(
+        "hvl_ccb.dev.lauda.LaudaProRp245eTcpCommunication.read",
+        return_value="ERR",
+    ):
+        with pytest.raises(lauda.LaudaProRp245eCommandError):
+            # don't use pause() as it sends successful STOP that kills the FakeTCP
+            chill.start_ramp()
+
+
+def test_run(startchiller):
+    chill = startchiller
+    assert chill.run() == lauda.LaudaProRp245eCommand.START.value
+
+
+def test_set_external_temp(startchiller):
+    chill = startchiller
+    ext = 20.00
+    assert chill.set_external_temp(ext) == "".join(
+        [lauda.LaudaProRp245eCommand.EXTERNAL_TEMP.value, "%.2f" % ext]
+    )
+
+
+def test_set_temp_set_point(startchiller):
+    chill = startchiller
+    ext = 25.00
+    assert chill.set_temp_set_point(ext) == "".join(
+        [lauda.LaudaProRp245eCommand.TEMP_SET_POINT.value, "%.2f" % ext]
+    )
+
+
+def test_correct_pump_level(startchiller):
+    chill = startchiller
+    ext = 3
+    assert (
+        chill.set_pump_level(ext)
+        == f"{lauda.LaudaProRp245eCommand.PUMP_LEVEL.value}{ext}"
+    )
+
+
+def test_wrong_pump_level(startchiller):
+    chill = startchiller
+    ext = 15
+    with pytest.raises(ValueError):
+        chill.set_pump_level(ext)
+
+
+def test_correct_control_mode(startchiller):
+    chill = startchiller
+    ext = 0
+    assert (
+        chill.set_control_mode(0)
+        == f"{lauda.LaudaProRp245eCommand.CONT_MODE.value}{ext}"
+    )
+
+
+def test_wrong_control_mode(startchiller):
+    chill = startchiller
+    with pytest.raises(ValueError):
+        chill.set_control_mode(6)
+
+
+def test_correct_ramp_program(startchiller):
+    chill = startchiller
+    ext = 1
+    assert chill.set_ramp_program(ext) == "".join(
+        [lauda.LaudaProRp245eCommand.RAMP_SELECT.value, str(ext)]
+    )
+
+
+def test_wrong_ramp_program(startchiller):
+    chill = startchiller
+    with pytest.raises(ValueError):
+        chill.set_ramp_program(6)
+
+
+def test_start_ramp(startchiller):
+    chill = startchiller
+    assert chill.start_ramp() == lauda.LaudaProRp245eCommand.RAMP_START.value
+
+
+def test_pause_ramp(startchiller):
+    chill = startchiller
+    assert chill.pause_ramp() == lauda.LaudaProRp245eCommand.RAMP_PAUSE.value
+
+
+def test_continue_ramp(startchiller):
+    chill = startchiller
+    assert chill.continue_ramp() == lauda.LaudaProRp245eCommand.RAMP_CONTINUE.value
+
+
+def test_stop_ramp(startchiller):
+    chill = startchiller
+    assert chill.stop_ramp() == lauda.LaudaProRp245eCommand.RAMP_STOP.value
+
+
+def test_set_ramp_iterations(startchiller):
+    chill = startchiller
+    ext = 3
+    assert chill.set_ramp_iterations(ext) == "".join(
+        [lauda.LaudaProRp245eCommand.RAMP_ITERATIONS.value, str(ext)]
+    )
+
+
+def test_reset_ramp(startchiller):
+    chill = startchiller
+    assert chill.reset_ramp() == lauda.LaudaProRp245eCommand.RAMP_DELETE.value
+
+
+def test_set_ramp_segment(startchiller):
+    chill = startchiller
+    temp = 10.00
+    dur = 0
+    tol = 0.00
+    pump = 3
+    segment = f"{temp:.2f}_{dur}_{tol:.2f}_{pump}"
+    assert (
+        chill.set_ramp_segment(temp, dur, tol, pump)
+        == f"{lauda.LaudaProRp245eCommand.RAMP_SET.value}{segment}"
+    )
+
+
+def test_get_bath_temp(startchiller):
+    chill = startchiller
+    assert chill.get_bath_temp() == 25.00
+
+
+def test_returns_error(startchiller):
+    chill = startchiller
+    with pytest.raises(lauda.LaudaProRp245eCommandError):
+        chill.com.query_command("FOOBAR")
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_newport.py` & `hvl_ccb-0.9.0/tests/test_dev_newport.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,735 +1,735 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the dev.newport sub-package.
-"""
-
-import logging
-
-import pytest
-
-from hvl_ccb import dev, comm
-from masked_comm.serial import NewportLoopSerialCommunication
-
-logging.basicConfig(level=logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 57600,
-        "parity": dev.NewportSMC100PPSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.NewportSMC100PPSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.NewportSMC100PPSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 0.05,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "address": 1,
-        "user_position_offset": 10,
-        "screw_scaling": 1,
-        "exit_configuration_wait_sec": 0.01,
-        "move_wait_sec": 0.01,
-        "acceleration": 10,
-        "backlash_compensation": 0,
-        "hysteresis_compensation": 0.015,
-        "micro_step_per_full_step_factor": 100,
-        "motion_distance_per_full_step": 0.01,
-        "home_search_type": 2,
-        "jerk_time": 0.04,
-        "home_search_velocity": 4,
-        "home_search_timeout": 1.01,
-        "home_search_polling_interval": 0.01,
-        "peak_output_current_limit": 0.4,
-        "rs485_address": 2,
-        "negative_software_limit": -23.5,
-        "positive_software_limit": 25,
-        "velocity": 4,
-        "base_velocity": 0,
-        "stage_configuration": 3,
-    }
-
-
-@pytest.fixture
-def started_newport(com_config, dev_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-
-    mot = dev.NewportSMC100PP(com, dev_config)
-    motor_config = mot.config.motor_config
-
-    # put answer to get_state query (NO_REF)
-    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
-    com.put_text(f"{dev_config['address']}TS0000{state}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # put answer to get_configuration query (matching config values)
-    com.put_text("1PW1")
-    com.put_text("1ID hello")
-    for param in motor_config:
-        cmd = dev.NewportConfigCommands(param).name
-        val = motor_config[param]  # matching config values
-        com.put_text(f"1{cmd}{val}")
-        logging.debug(f"putting to com: 1{cmd}{val}")
-    com.put_text("1PW0")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # put answer to initialize command
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # put answer to get_state query in wait_until_motor_initialized (READY)
-    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
-    com.put_text(f"{dev_config['address']}TS0000{state}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # put position as if just initialized
-    mot.position = dev_config["user_position_offset"]
-
-    with mot:
-        while com.get_written() is not None:
-            pass
-        yield com, mot
-        if com.is_open:
-            # required for a correct dev stop
-            # Note: this should be rather mot.is_started
-            com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-
-def test_com_read_text(com_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-    # check that no error is raised
-    com.put_text('regular text')
-    assert com.read_text().strip() == 'regular text'
-    # check that NewportMotorPowerSupplyWasCutError is raised
-    com.put_text('\x00regular text')
-    with pytest.raises(dev.NewportMotorPowerSupplyWasCutError):
-        com.read_text()
-    com.put_bytes(b'\xf8\x00')
-    with pytest.raises(dev.NewportMotorPowerSupplyWasCutError):
-        com.read_text()
-
-
-def test_com_check_for_error(com_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-    # check that no error is raised
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    com.check_for_error(1)
-    assert com.get_written() == "1TE"
-    # check that NewportControllerError is raised
-    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
-    with pytest.raises(dev.NewportControllerError):
-        com.check_for_error(1)
-    assert com.get_written() == "1TE"
-    # check that SerialCommunicationIOError is raised if the com is closed
-    com.close()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.check_for_error(1)
-
-
-def test_com_send_command(com_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-
-    # check that the correct message is sent
-    add = 3
-    cmd = "command"
-    param = 32.5
-    com._send_command_without_checking_error(add, cmd, param)
-    assert com.get_written() == f"{add}{cmd}{param}"
-
-    # check that the command is sent an no error is signaled
-
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    com.send_command(1, "command", 12)
-    assert com.get_written() == "1command12"
-    assert com.get_written() == "1TE"
-    # check that NewportControllerError is raised
-    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
-    with pytest.raises(dev.NewportControllerError):
-        com.send_command(1, "command")
-    assert com.get_written() == "1command"
-    assert com.get_written() == "1TE"
-    # check that SerialCommunicationIOError is raised if the com is closed
-    com.close()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.send_command(1, "command")
-
-
-def test_com_query(com_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-    # check that the correct answer is returned
-    com.put_text("1query answer")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert com.query(1, "query", "?") == "answer"
-    assert com.get_written() == "1query?"
-    assert com.get_written() == "1TE"
-    # also without param
-    com.put_text("1query answer")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert com.query(1, "query") == "answer"
-    # check that NewportSerialCommunicationError is raised if unexpected answer
-    com.put_text("")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    with pytest.raises(dev.NewportSerialCommunicationError):
-        com.query(1, "query")
-    # check that NewportControllerError is raised
-    com.put_text("wrong answer")
-    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
-    with pytest.raises(dev.NewportControllerError):
-        com.query(1, "query")
-    # check that SerialCommunicationIOError is raised if the com is closed
-    com.close()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.query(1, "query")
-
-
-def test_com_query_multiple(com_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-
-    # normal case
-    add = 3
-    cmd = "ZT"
-    prefixes = ["one", "two", "three"]
-    values = [1, 2, 3]
-    for p, v in zip(prefixes, values):
-        com.put_text(f"{p}{v}")
-    com.put_text(f"{add}TE{com.ControllerErrors.NO_ERROR.value}")
-    assert com.query_multiple(add, cmd, prefixes) == [str(v) for v in values]
-
-    # wrong prefix
-    wrong_prefixes = ["one", "two", "four"]
-    for p, v in zip(prefixes, values):
-        com.put_text(f"{p}{v}")
-    com.put_text(f"{add}TE{com.ControllerErrors.NO_ERROR.value}")
-    with pytest.raises(dev.NewportSerialCommunicationError):
-        com.query_multiple(add, cmd, wrong_prefixes)
-
-    # check that NewportControllerError is raised
-    for p, v in zip(prefixes, values):
-        com.put_text(f"{p}{v}")
-    com.put_text(f"{add}TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
-    with pytest.raises(dev.NewportControllerError):
-        com.query_multiple(add, cmd, prefixes)
-
-    # check that SerialCommunicationIOError is raised if the com is closed
-    com.close()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        com.query_multiple(add, cmd, prefixes)
-
-
-def test_dev_config(dev_config):
-    # currently there are no non-default config values
-    dev.NewportSMC100PPConfig()
-
-    config = dev.NewportSMC100PPConfig(**dev_config)
-    for key, value in dev_config.items():
-        assert getattr(config, key) == value
-
-    # test _motor_config update on force_value
-    fieldname = "acceleration"
-    value = dict(dev_config)[fieldname]
-    # first call to motor_config creates cache
-    assert config.motor_config[fieldname] == value
-    value = value - 1
-    config.force_value(fieldname, value)
-    # check that cache is updated
-    assert config.motor_config[fieldname] == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"address": -1},
-        {"screw_scaling": -1},
-        {"exit_configuration_wait_sec": -1},
-        {"move_wait_sec": -1},
-        {"acceleration": -1},
-        {"backlash_compensation": -1},
-        {"hysteresis_compensation": -1},
-        {"micro_step_per_full_step_factor": -1},
-        {"motion_distance_per_full_step": -1},
-        {"home_search_type": -1},
-        {"jerk_time": -1},
-        {"home_search_velocity": -1},
-        {"home_search_timeout": -1},
-        {"home_search_polling_interval": -1},
-        {"peak_output_current_limit": -1},
-        {"rs485_address": -1},
-        {"negative_software_limit": 1},
-        {"positive_software_limit": -1},
-        {"velocity": -1},
-        {"base_velocity": -1},
-        {"stage_configuration": -1},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_config_dict):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        dev.NewportSMC100PPConfig(**invalid_config)
-
-
-def test_newport_instantiation(com_config, dev_config):
-    mot = dev.NewportSMC100PP(com_config)
-    assert mot is not None
-
-    mot = dev.NewportSMC100PP(com_config, dev_config)
-    assert mot is not None
-
-
-def test_newport_com_errors(com_config, dev_config):
-
-    wrong_com_config = dict(com_config)
-    wrong_com_config["port"] = "NOT A PORT"
-    mot = dev.NewportSMC100PP(wrong_com_config, dev_config)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.start()
-
-    mot = dev.NewportSMC100PP(com_config, dev_config)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_state()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_motor_configuration()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.go_to_configuration()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.set_motor_configuration()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.exit_configuration()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.initialize()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.wait_until_motor_initialized()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.reset()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_position()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.move_to_absolute_position(10)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.go_home()
-    mot.position = 1
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.move_to_relative_position(1)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_move_duration(10)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.stop_motion()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_acceleration()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.set_acceleration(10)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_controller_information()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_positive_software_limit()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.set_positive_software_limit(1)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.get_negative_software_limit()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        mot.set_negative_software_limit(-1)
-
-
-def test_start_and_initialize(com_config, dev_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-
-    # case 1: config unchanged and in NO_REF state
-    mot = dev.NewportSMC100PP(com, dev_config)
-
-    # answer to get_state
-    state_message = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET
-    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # answer to get_motor_configuration
-    config = mot.config.motor_config
-    com.put_text("1PW1")
-    com.put_text("1ID hello")
-    for param in config:
-        cmd = dev.NewportConfigCommands(param).name
-        val = config[param]  # matching config values
-        com.put_text(f"1{cmd}{val}")
-        logging.debug(f"putting to com: 1{cmd}{val}")
-    com.put_text("1PW0")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # answer to initialize
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answer to wait_until_motor_initialized
-    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
-    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    mot.start()
-    assert mot.state == state_message.state
-
-
-def test_start_and_configure(com_config, dev_config):
-    com = NewportLoopSerialCommunication(com_config)
-    com.open()
-
-    # case 2: config changed and in READY state
-    mot = dev.NewportSMC100PP(com, dev_config)
-
-    # answer to get_state
-    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
-    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # answer to get_motor_configuration
-    config = mot.config.motor_config
-    com.put_text("1PW1")
-    com.put_text("1ID hello")
-    for param in config:
-        cmd = dev.NewportConfigCommands(param).name
-        val = config[param] + 1  # changed config values
-        com.put_text(f"1{cmd}{val}")
-        logging.debug(f"putting to com: 1{cmd}{val}")
-    com.put_text("1PW0")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    #  answer to reset
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    com.put_text("I just did a reset and I feel talkative.")
-
-    # answer to go_to_configuration
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answer to set_motor_configuration
-    params = [p for p in config if not ("compensation" in p and config[p] == 0)]
-    for _ in params:
-        com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answer to exit_configuration
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    # answer to initialize
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answer to wait_until_motor_initialized
-    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
-    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-
-    mot.start()
-    assert mot.state == state_message.state
-
-
-def test_stop(started_newport):
-    com, mot = started_newport
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.stop()
-
-
-def test_get_state(started_newport):
-    com, mot = started_newport
-
-    state = dev.NewportSMC100PP.StateMessages.MOVING.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.get_state()
-    assert com.get_written() == "1TS"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.MOVING
-
-    # test with another address
-    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
-    com.put_text("3TS0000" + state)
-    com.put_text("3TE" + com.ControllerErrors.NO_ERROR.value)
-    mot.get_state(3)
-    assert com.get_written() == "3TS"
-    assert com.get_written() == "3TE"
-    assert mot.state == mot.States.READY
-
-    # test when the motor reports an error
-    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_READY.value
-    com.put_text("1TS0013" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    with pytest.raises(dev.NewportMotorError):
-        mot.get_state()
-    com.get_written()
-    com.get_written()
-
-    # test when an NewportMotorPowerSupplyWasCutError occurs and is skipped
-    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_READY.value
-    com.put_text("\x001TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.get_state()
-    assert com.get_written() == "1TS"
-    assert com.get_written() == "1TE"
-    assert com.get_written() == "1TS"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.DISABLE
-
-
-def test_get_motor_configuration(started_newport):
-    com, mot = started_newport
-
-    com.put_text("1PW1")
-    com.put_text("1ID hello")
-    for param in mot.config.motor_config:
-        cmd = dev.NewportConfigCommands(param).name
-        val = mot.config.motor_config[param]
-        com.put_text(f"1{cmd}{val}")
-        logging.debug(f"putting to com: 1{cmd}{val}")
-    com.put_text("1PW0")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_motor_configuration() == mot.config.motor_config
-    assert com.get_written() == "1ZT"
-    assert com.get_written() == "1TE"
-
-
-def test_go_to_configuration(started_newport):
-    com, mot = started_newport
-    # artificially put the controller in NOT REFERENCED state
-    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.get_state()
-    com.get_written()
-    com.get_written()
-    # start the test
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.go_to_configuration()
-    assert com.get_written() == "1PW1"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.CONFIG
-
-
-def test_set_motor_configuration(started_newport):
-    com, mot = started_newport
-
-    config = mot.config.motor_config
-    params = [p for p in config if not ("compensation" in p and config[p] == 0)]
-    # normal case
-    for _ in params:
-        com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.set_motor_configuration()
-    for param in params:
-        cmd = dev.NewportConfigCommands(param).name
-        val = config[param]
-        assert com.get_written() == f"1{cmd}{val}"
-        assert com.get_written() == "1TE"
-    # controller error
-    error = com.ControllerErrors.PARAM_MISSING_OR_INVALID.value
-    com.put_text(f"1TE{error}")
-    with pytest.raises(dev.NewportControllerError):
-        mot.set_motor_configuration()
-
-
-def test_exit_configuration(started_newport):
-    com, mot = started_newport
-    # start the test
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.exit_configuration()
-    assert com.get_written() == "1PW0"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.NO_REF
-
-
-def test_initialize(started_newport):
-    com, mot = started_newport
-    # start the test
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.initialize()
-    assert com.get_written() == "1OR"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.READY
-
-
-def test_wait_until_motor_initialized(started_newport):
-    com, mot = started_newport
-    # normal case
-    state = dev.NewportSMC100PP.StateMessages.HOMING_FROM_RS232.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.wait_until_motor_initialized()
-    # unexpected final state or timeout
-    state = dev.NewportSMC100PP.StateMessages.HOMING_FROM_RS232.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_MOVING.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    with pytest.raises(dev.NewportControllerError):
-        mot.wait_until_motor_initialized()
-
-
-def test_reset(started_newport):
-    com, mot = started_newport
-    # start the test
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    com.put_text("I just did a reset and I feel talkative.")
-    mot.reset()
-    assert com.get_written() == "1RS"
-    assert com.get_written() == "1TE"
-    assert mot.state == mot.States.NO_REF
-
-
-def test_get_position(started_newport):
-    com, mot = started_newport
-    # start the test
-    pos = 12
-    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_position() == pos
-    assert com.get_written() == "1TP"
-    assert com.get_written() == "1TE"
-
-    # check that an error is raised if the position is ambiguous
-    com.put_text("1TP0")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answer to the get_state() query
-    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
-    com.put_text("1TS0000" + state)
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    with pytest.raises(dev.NewportUncertainPositionError):
-        mot.get_position()
-
-
-def test_move_to_absolute_position(started_newport):
-    com, mot = started_newport
-    # start the test
-    pos = 3
-    # answers to get_position()
-    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answers to absolute move command
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.move_to_absolute_position(pos)
-    assert com.get_written() == "1TP"
-    assert com.get_written() == "1TE"
-    assert com.get_written() == f"1PA{pos-mot.config.user_position_offset}"
-    assert com.get_written() == "1TE"
-
-
-def test_go_home(started_newport):
-    com, mot = started_newport
-    # start the test
-    pos = 3
-    # answers to get_position()
-    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    # answers to homing command
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.go_home()
-    assert com.get_written() == "1TP"
-    assert com.get_written() == "1TE"
-    assert com.get_written() == "1PA0"
-    assert com.get_written() == "1TE"
-
-
-def test_move_to_relative_position(started_newport):
-    com, mot = started_newport
-    # start the test
-    pos = -3
-    mot.position = 20
-    # answers to relative move command
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.move_to_relative_position(pos)
-    assert com.get_written() == f"1PR{pos}"
-    assert com.get_written() == "1TE"
-
-
-def test_get_move_duration(started_newport):
-    com, mot = started_newport
-    dist = -3
-    duration = 5.2
-    mot.position = 0
-    com.put_text(f"1PT{duration}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_move_duration(dist) == duration
-    assert com.get_written() == f"1PT{abs(dist)}"
-    assert com.get_written() == "1TE"
-
-
-def test_stop_motion(started_newport):
-    com, mot = started_newport
-    # test if stop_motion_works
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.stop_motion()
-    assert com.get_written() == "ST"
-    assert com.get_written() == "1TE"
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.stop_motion(1)
-    assert com.get_written() == "1ST"
-    assert com.get_written() == "1TE"
-
-
-def test_get_acceleration(started_newport):
-    com, mot = started_newport
-    acc = 5
-    com.put_text(f"1AC{acc}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_acceleration() == acc
-    assert com.get_written() == "1AC?"
-    assert com.get_written() == "1TE"
-
-
-def test_set_acceleration(started_newport):
-    com, mot = started_newport
-    acc = 5
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.set_acceleration(acc)
-    assert com.get_written() == f"1AC{acc}"
-    assert com.get_written() == "1TE"
-
-
-def test_get_controller_information(started_newport):
-    com, mot = started_newport
-    com.put_text("1VE SMC100PP")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_controller_information() == "SMC100PP"
-    assert com.get_written() == "1VE?"
-    assert com.get_written() == "1TE"
-
-
-def test_get_positive_software_limit(started_newport):
-    com, mot = started_newport
-    lim = 5
-    com.put_text(f"1SR{lim}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_positive_software_limit() == lim
-    assert com.get_written() == "1SR?"
-    assert com.get_written() == "1TE"
-
-
-def test_get_negative_software_limit(started_newport):
-    com, mot = started_newport
-    lim = -5
-    com.put_text(f"1SL{lim}")
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    assert mot.get_negative_software_limit() == lim
-    assert com.get_written() == "1SL?"
-    assert com.get_written() == "1TE"
-
-
-def test_set_positive_software_limit(started_newport):
-    com, mot = started_newport
-    lim = 5
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.set_positive_software_limit(lim)
-    assert com.get_written() == f"1SR{lim}"
-    assert com.get_written() == "1TE"
-
-
-def test_set_negative_software_limit(started_newport):
-    com, mot = started_newport
-    lim = -5
-    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
-    mot.set_negative_software_limit(lim)
-    assert com.get_written() == f"1SL{lim}"
-    assert com.get_written() == "1TE"
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the dev.newport sub-package.
+"""
+
+import logging
+
+import pytest
+
+from hvl_ccb import dev, comm
+from masked_comm.serial import NewportLoopSerialCommunication
+
+logging.basicConfig(level=logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 57600,
+        "parity": dev.NewportSMC100PPSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.NewportSMC100PPSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.NewportSMC100PPSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 0.05,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "address": 1,
+        "user_position_offset": 10,
+        "screw_scaling": 1,
+        "exit_configuration_wait_sec": 0.01,
+        "move_wait_sec": 0.01,
+        "acceleration": 10,
+        "backlash_compensation": 0,
+        "hysteresis_compensation": 0.015,
+        "micro_step_per_full_step_factor": 100,
+        "motion_distance_per_full_step": 0.01,
+        "home_search_type": 2,
+        "jerk_time": 0.04,
+        "home_search_velocity": 4,
+        "home_search_timeout": 1.01,
+        "home_search_polling_interval": 0.01,
+        "peak_output_current_limit": 0.4,
+        "rs485_address": 2,
+        "negative_software_limit": -23.5,
+        "positive_software_limit": 25,
+        "velocity": 4,
+        "base_velocity": 0,
+        "stage_configuration": 3,
+    }
+
+
+@pytest.fixture
+def started_newport(com_config, dev_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+
+    mot = dev.NewportSMC100PP(com, dev_config)
+    motor_config = mot.config.motor_config
+
+    # put answer to get_state query (NO_REF)
+    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
+    com.put_text(f"{dev_config['address']}TS0000{state}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # put answer to get_configuration query (matching config values)
+    com.put_text("1PW1")
+    com.put_text("1ID hello")
+    for param in motor_config:
+        cmd = dev.NewportConfigCommands(param).name
+        val = motor_config[param]  # matching config values
+        com.put_text(f"1{cmd}{val}")
+        logging.debug(f"putting to com: 1{cmd}{val}")
+    com.put_text("1PW0")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # put answer to initialize command
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # put answer to get_state query in wait_until_motor_initialized (READY)
+    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
+    com.put_text(f"{dev_config['address']}TS0000{state}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # put position as if just initialized
+    mot.position = dev_config["user_position_offset"]
+
+    with mot:
+        while com.get_written() is not None:
+            pass
+        yield com, mot
+        if com.is_open:
+            # required for a correct dev stop
+            # Note: this should be rather mot.is_started
+            com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+
+def test_com_read_text(com_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+    # check that no error is raised
+    com.put_text('regular text')
+    assert com.read_text().strip() == 'regular text'
+    # check that NewportMotorPowerSupplyWasCutError is raised
+    com.put_text('\x00regular text')
+    with pytest.raises(dev.NewportMotorPowerSupplyWasCutError):
+        com.read_text()
+    com.put_bytes(b'\xf8\x00')
+    with pytest.raises(dev.NewportMotorPowerSupplyWasCutError):
+        com.read_text()
+
+
+def test_com_check_for_error(com_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+    # check that no error is raised
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    com.check_for_error(1)
+    assert com.get_written() == "1TE"
+    # check that NewportControllerError is raised
+    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
+    with pytest.raises(dev.NewportControllerError):
+        com.check_for_error(1)
+    assert com.get_written() == "1TE"
+    # check that SerialCommunicationIOError is raised if the com is closed
+    com.close()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.check_for_error(1)
+
+
+def test_com_send_command(com_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+
+    # check that the correct message is sent
+    add = 3
+    cmd = "command"
+    param = 32.5
+    com._send_command_without_checking_error(add, cmd, param)
+    assert com.get_written() == f"{add}{cmd}{param}"
+
+    # check that the command is sent an no error is signaled
+
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    com.send_command(1, "command", 12)
+    assert com.get_written() == "1command12"
+    assert com.get_written() == "1TE"
+    # check that NewportControllerError is raised
+    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
+    with pytest.raises(dev.NewportControllerError):
+        com.send_command(1, "command")
+    assert com.get_written() == "1command"
+    assert com.get_written() == "1TE"
+    # check that SerialCommunicationIOError is raised if the com is closed
+    com.close()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.send_command(1, "command")
+
+
+def test_com_query(com_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+    # check that the correct answer is returned
+    com.put_text("1query answer")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert com.query(1, "query", "?") == "answer"
+    assert com.get_written() == "1query?"
+    assert com.get_written() == "1TE"
+    # also without param
+    com.put_text("1query answer")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert com.query(1, "query") == "answer"
+    # check that NewportSerialCommunicationError is raised if unexpected answer
+    com.put_text("")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    with pytest.raises(dev.NewportSerialCommunicationError):
+        com.query(1, "query")
+    # check that NewportControllerError is raised
+    com.put_text("wrong answer")
+    com.put_text(f"1TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
+    with pytest.raises(dev.NewportControllerError):
+        com.query(1, "query")
+    # check that SerialCommunicationIOError is raised if the com is closed
+    com.close()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.query(1, "query")
+
+
+def test_com_query_multiple(com_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+
+    # normal case
+    add = 3
+    cmd = "ZT"
+    prefixes = ["one", "two", "three"]
+    values = [1, 2, 3]
+    for p, v in zip(prefixes, values):
+        com.put_text(f"{p}{v}")
+    com.put_text(f"{add}TE{com.ControllerErrors.NO_ERROR.value}")
+    assert com.query_multiple(add, cmd, prefixes) == [str(v) for v in values]
+
+    # wrong prefix
+    wrong_prefixes = ["one", "two", "four"]
+    for p, v in zip(prefixes, values):
+        com.put_text(f"{p}{v}")
+    com.put_text(f"{add}TE{com.ControllerErrors.NO_ERROR.value}")
+    with pytest.raises(dev.NewportSerialCommunicationError):
+        com.query_multiple(add, cmd, wrong_prefixes)
+
+    # check that NewportControllerError is raised
+    for p, v in zip(prefixes, values):
+        com.put_text(f"{p}{v}")
+    com.put_text(f"{add}TE{com.ControllerErrors.CMD_NOT_ALLOWED.value}")
+    with pytest.raises(dev.NewportControllerError):
+        com.query_multiple(add, cmd, prefixes)
+
+    # check that SerialCommunicationIOError is raised if the com is closed
+    com.close()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        com.query_multiple(add, cmd, prefixes)
+
+
+def test_dev_config(dev_config):
+    # currently there are no non-default config values
+    dev.NewportSMC100PPConfig()
+
+    config = dev.NewportSMC100PPConfig(**dev_config)
+    for key, value in dev_config.items():
+        assert getattr(config, key) == value
+
+    # test _motor_config update on force_value
+    fieldname = "acceleration"
+    value = dict(dev_config)[fieldname]
+    # first call to motor_config creates cache
+    assert config.motor_config[fieldname] == value
+    value = value - 1
+    config.force_value(fieldname, value)
+    # check that cache is updated
+    assert config.motor_config[fieldname] == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"address": -1},
+        {"screw_scaling": -1},
+        {"exit_configuration_wait_sec": -1},
+        {"move_wait_sec": -1},
+        {"acceleration": -1},
+        {"backlash_compensation": -1},
+        {"hysteresis_compensation": -1},
+        {"micro_step_per_full_step_factor": -1},
+        {"motion_distance_per_full_step": -1},
+        {"home_search_type": -1},
+        {"jerk_time": -1},
+        {"home_search_velocity": -1},
+        {"home_search_timeout": -1},
+        {"home_search_polling_interval": -1},
+        {"peak_output_current_limit": -1},
+        {"rs485_address": -1},
+        {"negative_software_limit": 1},
+        {"positive_software_limit": -1},
+        {"velocity": -1},
+        {"base_velocity": -1},
+        {"stage_configuration": -1},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_config_dict):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        dev.NewportSMC100PPConfig(**invalid_config)
+
+
+def test_newport_instantiation(com_config, dev_config):
+    mot = dev.NewportSMC100PP(com_config)
+    assert mot is not None
+
+    mot = dev.NewportSMC100PP(com_config, dev_config)
+    assert mot is not None
+
+
+def test_newport_com_errors(com_config, dev_config):
+
+    wrong_com_config = dict(com_config)
+    wrong_com_config["port"] = "NOT A PORT"
+    mot = dev.NewportSMC100PP(wrong_com_config, dev_config)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.start()
+
+    mot = dev.NewportSMC100PP(com_config, dev_config)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_state()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_motor_configuration()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.go_to_configuration()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.set_motor_configuration()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.exit_configuration()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.initialize()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.wait_until_motor_initialized()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.reset()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_position()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.move_to_absolute_position(10)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.go_home()
+    mot.position = 1
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.move_to_relative_position(1)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_move_duration(10)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.stop_motion()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_acceleration()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.set_acceleration(10)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_controller_information()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_positive_software_limit()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.set_positive_software_limit(1)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.get_negative_software_limit()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        mot.set_negative_software_limit(-1)
+
+
+def test_start_and_initialize(com_config, dev_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+
+    # case 1: config unchanged and in NO_REF state
+    mot = dev.NewportSMC100PP(com, dev_config)
+
+    # answer to get_state
+    state_message = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET
+    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # answer to get_motor_configuration
+    config = mot.config.motor_config
+    com.put_text("1PW1")
+    com.put_text("1ID hello")
+    for param in config:
+        cmd = dev.NewportConfigCommands(param).name
+        val = config[param]  # matching config values
+        com.put_text(f"1{cmd}{val}")
+        logging.debug(f"putting to com: 1{cmd}{val}")
+    com.put_text("1PW0")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # answer to initialize
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answer to wait_until_motor_initialized
+    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
+    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    mot.start()
+    assert mot.state == state_message.state
+
+
+def test_start_and_configure(com_config, dev_config):
+    com = NewportLoopSerialCommunication(com_config)
+    com.open()
+
+    # case 2: config changed and in READY state
+    mot = dev.NewportSMC100PP(com, dev_config)
+
+    # answer to get_state
+    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
+    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # answer to get_motor_configuration
+    config = mot.config.motor_config
+    com.put_text("1PW1")
+    com.put_text("1ID hello")
+    for param in config:
+        cmd = dev.NewportConfigCommands(param).name
+        val = config[param] + 1  # changed config values
+        com.put_text(f"1{cmd}{val}")
+        logging.debug(f"putting to com: 1{cmd}{val}")
+    com.put_text("1PW0")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    #  answer to reset
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    com.put_text("I just did a reset and I feel talkative.")
+
+    # answer to go_to_configuration
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answer to set_motor_configuration
+    params = [p for p in config if not ("compensation" in p and config[p] == 0)]
+    for _ in params:
+        com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answer to exit_configuration
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    # answer to initialize
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answer to wait_until_motor_initialized
+    state_message = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING
+    com.put_text(f"{dev_config['address']}TS0000" + state_message.value)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+
+    mot.start()
+    assert mot.state == state_message.state
+
+
+def test_stop(started_newport):
+    com, mot = started_newport
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.stop()
+
+
+def test_get_state(started_newport):
+    com, mot = started_newport
+
+    state = dev.NewportSMC100PP.StateMessages.MOVING.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.get_state()
+    assert com.get_written() == "1TS"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.MOVING
+
+    # test with another address
+    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
+    com.put_text("3TS0000" + state)
+    com.put_text("3TE" + com.ControllerErrors.NO_ERROR.value)
+    mot.get_state(3)
+    assert com.get_written() == "3TS"
+    assert com.get_written() == "3TE"
+    assert mot.state == mot.States.READY
+
+    # test when the motor reports an error
+    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_READY.value
+    com.put_text("1TS0013" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    with pytest.raises(dev.NewportMotorError):
+        mot.get_state()
+    com.get_written()
+    com.get_written()
+
+    # test when an NewportMotorPowerSupplyWasCutError occurs and is skipped
+    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_READY.value
+    com.put_text("\x001TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.get_state()
+    assert com.get_written() == "1TS"
+    assert com.get_written() == "1TE"
+    assert com.get_written() == "1TS"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.DISABLE
+
+
+def test_get_motor_configuration(started_newport):
+    com, mot = started_newport
+
+    com.put_text("1PW1")
+    com.put_text("1ID hello")
+    for param in mot.config.motor_config:
+        cmd = dev.NewportConfigCommands(param).name
+        val = mot.config.motor_config[param]
+        com.put_text(f"1{cmd}{val}")
+        logging.debug(f"putting to com: 1{cmd}{val}")
+    com.put_text("1PW0")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_motor_configuration() == mot.config.motor_config
+    assert com.get_written() == "1ZT"
+    assert com.get_written() == "1TE"
+
+
+def test_go_to_configuration(started_newport):
+    com, mot = started_newport
+    # artificially put the controller in NOT REFERENCED state
+    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.get_state()
+    com.get_written()
+    com.get_written()
+    # start the test
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.go_to_configuration()
+    assert com.get_written() == "1PW1"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.CONFIG
+
+
+def test_set_motor_configuration(started_newport):
+    com, mot = started_newport
+
+    config = mot.config.motor_config
+    params = [p for p in config if not ("compensation" in p and config[p] == 0)]
+    # normal case
+    for _ in params:
+        com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.set_motor_configuration()
+    for param in params:
+        cmd = dev.NewportConfigCommands(param).name
+        val = config[param]
+        assert com.get_written() == f"1{cmd}{val}"
+        assert com.get_written() == "1TE"
+    # controller error
+    error = com.ControllerErrors.PARAM_MISSING_OR_INVALID.value
+    com.put_text(f"1TE{error}")
+    with pytest.raises(dev.NewportControllerError):
+        mot.set_motor_configuration()
+
+
+def test_exit_configuration(started_newport):
+    com, mot = started_newport
+    # start the test
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.exit_configuration()
+    assert com.get_written() == "1PW0"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.NO_REF
+
+
+def test_initialize(started_newport):
+    com, mot = started_newport
+    # start the test
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.initialize()
+    assert com.get_written() == "1OR"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.READY
+
+
+def test_wait_until_motor_initialized(started_newport):
+    com, mot = started_newport
+    # normal case
+    state = dev.NewportSMC100PP.StateMessages.HOMING_FROM_RS232.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    state = dev.NewportSMC100PP.StateMessages.READY_FROM_HOMING.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.wait_until_motor_initialized()
+    # unexpected final state or timeout
+    state = dev.NewportSMC100PP.StateMessages.HOMING_FROM_RS232.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    state = dev.NewportSMC100PP.StateMessages.DISABLE_FROM_MOVING.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    with pytest.raises(dev.NewportControllerError):
+        mot.wait_until_motor_initialized()
+
+
+def test_reset(started_newport):
+    com, mot = started_newport
+    # start the test
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    com.put_text("I just did a reset and I feel talkative.")
+    mot.reset()
+    assert com.get_written() == "1RS"
+    assert com.get_written() == "1TE"
+    assert mot.state == mot.States.NO_REF
+
+
+def test_get_position(started_newport):
+    com, mot = started_newport
+    # start the test
+    pos = 12
+    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_position() == pos
+    assert com.get_written() == "1TP"
+    assert com.get_written() == "1TE"
+
+    # check that an error is raised if the position is ambiguous
+    com.put_text("1TP0")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answer to the get_state() query
+    state = dev.NewportSMC100PP.StateMessages.NO_REF_FROM_RESET.value
+    com.put_text("1TS0000" + state)
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    with pytest.raises(dev.NewportUncertainPositionError):
+        mot.get_position()
+
+
+def test_move_to_absolute_position(started_newport):
+    com, mot = started_newport
+    # start the test
+    pos = 3
+    # answers to get_position()
+    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answers to absolute move command
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.move_to_absolute_position(pos)
+    assert com.get_written() == "1TP"
+    assert com.get_written() == "1TE"
+    assert com.get_written() == f"1PA{pos-mot.config.user_position_offset}"
+    assert com.get_written() == "1TE"
+
+
+def test_go_home(started_newport):
+    com, mot = started_newport
+    # start the test
+    pos = 3
+    # answers to get_position()
+    com.put_text(f"1TP{pos - mot.config.user_position_offset}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    # answers to homing command
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.go_home()
+    assert com.get_written() == "1TP"
+    assert com.get_written() == "1TE"
+    assert com.get_written() == "1PA0"
+    assert com.get_written() == "1TE"
+
+
+def test_move_to_relative_position(started_newport):
+    com, mot = started_newport
+    # start the test
+    pos = -3
+    mot.position = 20
+    # answers to relative move command
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.move_to_relative_position(pos)
+    assert com.get_written() == f"1PR{pos}"
+    assert com.get_written() == "1TE"
+
+
+def test_get_move_duration(started_newport):
+    com, mot = started_newport
+    dist = -3
+    duration = 5.2
+    mot.position = 0
+    com.put_text(f"1PT{duration}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_move_duration(dist) == duration
+    assert com.get_written() == f"1PT{abs(dist)}"
+    assert com.get_written() == "1TE"
+
+
+def test_stop_motion(started_newport):
+    com, mot = started_newport
+    # test if stop_motion_works
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.stop_motion()
+    assert com.get_written() == "ST"
+    assert com.get_written() == "1TE"
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.stop_motion(1)
+    assert com.get_written() == "1ST"
+    assert com.get_written() == "1TE"
+
+
+def test_get_acceleration(started_newport):
+    com, mot = started_newport
+    acc = 5
+    com.put_text(f"1AC{acc}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_acceleration() == acc
+    assert com.get_written() == "1AC?"
+    assert com.get_written() == "1TE"
+
+
+def test_set_acceleration(started_newport):
+    com, mot = started_newport
+    acc = 5
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.set_acceleration(acc)
+    assert com.get_written() == f"1AC{acc}"
+    assert com.get_written() == "1TE"
+
+
+def test_get_controller_information(started_newport):
+    com, mot = started_newport
+    com.put_text("1VE SMC100PP")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_controller_information() == "SMC100PP"
+    assert com.get_written() == "1VE?"
+    assert com.get_written() == "1TE"
+
+
+def test_get_positive_software_limit(started_newport):
+    com, mot = started_newport
+    lim = 5
+    com.put_text(f"1SR{lim}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_positive_software_limit() == lim
+    assert com.get_written() == "1SR?"
+    assert com.get_written() == "1TE"
+
+
+def test_get_negative_software_limit(started_newport):
+    com, mot = started_newport
+    lim = -5
+    com.put_text(f"1SL{lim}")
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    assert mot.get_negative_software_limit() == lim
+    assert com.get_written() == "1SL?"
+    assert com.get_written() == "1TE"
+
+
+def test_set_positive_software_limit(started_newport):
+    com, mot = started_newport
+    lim = 5
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.set_positive_software_limit(lim)
+    assert com.get_written() == f"1SR{lim}"
+    assert com.get_written() == "1TE"
+
+
+def test_set_negative_software_limit(started_newport):
+    com, mot = started_newport
+    lim = -5
+    com.put_text(f"1TE{com.ControllerErrors.NO_ERROR.value}")
+    mot.set_negative_software_limit(lim)
+    assert com.get_written() == f"1SL{lim}"
+    assert com.get_written() == "1TE"
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_pfeiffer_tpg.py` & `hvl_ccb-0.9.0/tests/test_dev_pfeiffer_tpg.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,316 +1,316 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the .dev.pfeiffer_tpg sub-package.
-"""
-
-import logging
-
-import pytest
-
-from hvl_ccb import comm, dev
-from masked_comm.serial import PfeifferTPGLoopSerialCommunication
-
-logging.basicConfig(level=logging.ERROR)
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": dev.PfeifferTPGSerialCommunicationConfig.Parity.NONE,
-        "stopbits": dev.PfeifferTPGSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": dev.PfeifferTPGSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "terminator": b"\r\n",
-        "timeout": 3,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {"model": dev.PfeifferTPGConfig.Model.TPG25xA}
-
-
-@pytest.fixture
-def started_pfeiffer_tpg(com_config, dev_config):
-    com = PfeifferTPGLoopSerialCommunication(com_config)
-    com.open()
-    com.put_text(chr(6))
-    com.put_text(
-        ",".join(
-            [
-                dev.PfeifferTPG.SensorTypes.CMR.name,
-                dev.PfeifferTPG.SensorTypes.noSENSOR.name,
-            ]
-        )
-    )
-    with dev.PfeifferTPG(com, dev_config) as pg:
-        while com.get_written() is not None:
-            pass
-        yield com, pg
-
-
-def test_pfeiffer_tpg_instantiation(com_config, dev_config):
-    pg = dev.PfeifferTPG(com_config, dev_config)
-    assert pg is not None
-    assert pg.unit == "mbar"
-
-    # another valid config
-    config_dict = dict(dev_config)
-    config_dict["model"] = "TPGx6x"
-    dev.PfeifferTPG(com_config, config_dict)
-
-    # wrong config
-    config_dict["model"] = "wrong_name"
-    with pytest.raises(ValueError):
-        dev.PfeifferTPG(com_config, config_dict)
-
-
-def test_com_send_command(com_config):
-    com = PfeifferTPGLoopSerialCommunication(com_config)
-    com.open()
-    com.put_text(chr(6))
-    com.send_command("this is the command")
-    assert com.get_written() == "this is the command"
-    com.put_text("not an acknowledgement")
-    with pytest.raises(dev.PfeifferTPGError):
-        com.send_command("this command is not acknowledged")
-    com.close()
-
-
-def test_com_query(com_config):
-    com = PfeifferTPGLoopSerialCommunication(com_config)
-    com.open()
-    com.put_text(chr(6))
-    com.put_text("this is the answer")
-    assert com.query("this is the query") == "this is the answer"
-    assert com.get_written() == "this is the query"
-    assert com.get_written() == chr(5)
-    com.put_text("not an acknowledgement")
-    with pytest.raises(dev.PfeifferTPGError):
-        com.query("this query is not acknowledged")
-    com.put_text(chr(6))
-    com.put_text("")
-    with pytest.raises(dev.PfeifferTPGError):
-        com.query("the answer to this query is empty")
-    com.close()
-
-
-def test_pfeiffer_tpg_start(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    # starting again should work
-    com.put_text(chr(6))
-    com.put_text(",".join(["Unknown", dev.PfeifferTPG.SensorTypes.CMR.name]))
-    pg.start()
-    assert pg.number_of_sensors == 2
-    assert pg.sensors[0] == "Unknown"
-    assert pg.sensors[1] == "APR/CMR Linear Gauge"
-
-
-def test_pfeiffer_com_error(com_config, dev_config):
-    wrong_config = dict(com_config)
-    wrong_config["port"] = "NOT A PORT"
-    tpg = dev.PfeifferTPG(wrong_config, dev_config)
-    assert not tpg.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.start()
-
-    tpg = dev.PfeifferTPG(com_config, dev_config)
-    assert not tpg.com.is_open
-
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.identify_sensors()
-    tpg.sensors = [0]
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.measure(1)
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.measure_all()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.set_full_scale_unitless([1])
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.get_full_scale_unitless()
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.set_full_scale_mbar([100])
-    with pytest.raises(comm.SerialCommunicationIOError):
-        tpg.get_full_scale_mbar()
-
-
-def test_identify_sensors(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    # example with 3 sensors
-    com.put_text(chr(6))
-    com.put_text(
-        ",".join(
-            [
-                dev.PfeifferTPG.SensorTypes.PKR.name,
-                dev.PfeifferTPG.SensorTypes.CMR.name,
-                dev.PfeifferTPG.SensorTypes.IKR.name,
-            ]
-        )
-    )
-    pg.identify_sensors()
-    assert com.get_written() == "TID"
-    assert com.get_written() == chr(5)
-    assert pg.number_of_sensors == 3
-    assert pg.sensors[0] == dev.PfeifferTPG.SensorTypes.PKR.name
-    assert pg.sensors[1] == dev.PfeifferTPG.SensorTypes.CMR.name
-    assert pg.sensors[2] == dev.PfeifferTPG.SensorTypes.IKR.name
-    # wrong answer from device
-    com.put_text("this will make the command fail")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.identify_sensors()
-
-
-def test_set_display_unit(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    # valid str argument
-    com.put_text(chr(6))
-    pg.set_display_unit("mbar")
-    # valid PressureUnits argument
-    com.put_text(chr(6))
-    pg.set_display_unit(pg.PressureUnits.Pascal)
-    # valid PressureUnits argument but no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.set_display_unit(pg.PressureUnits.Pascal)
-    # invalid str argument
-    with pytest.raises(ValueError):
-        pg.set_display_unit("Not an accepted unit")
-
-
-def test_measure(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    # normal case
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Ok.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Ok.name, 1.234e-2)
-    assert com.get_written() == "PR2"
-    # underrange
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Underrange.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Underrange.name, 1.234e-2)
-    # overrange
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Overrange.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Overrange.name, 1.234e-2)
-    # error
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Sensor_error.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Sensor_error.name, 1.234e-2)
-    # off
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Sensor_off.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Sensor_off.name, 1.234e-2)
-    # none
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.No_sensor.value},1.234E-02")
-    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.No_sensor.name, 1.234e-2)
-    # identification error
-    com.put_text(chr(6))
-    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Identification_error.value},1.234E-02")
-    assert pg.measure(2) == (
-        dev.PfeifferTPG.SensorStatus.Identification_error.name,
-        1.234e-2,
-    )
-    # wrong channel
-    with pytest.raises(ValueError):
-        pg.measure(12)
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.measure(1)
-
-
-def test_measure_all(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    # normal case
-    com.put_text(chr(6))
-    com.put_text(
-        f"{dev.PfeifferTPG.SensorStatus.Identification_error.value},1.234E-02,"
-        f"{dev.PfeifferTPG.SensorStatus.Ok.value},1.234E-02"
-    )
-    assert pg.measure_all() == [
-        (dev.PfeifferTPG.SensorStatus.Identification_error.name, 1.234e-2),
-        (dev.PfeifferTPG.SensorStatus.Ok.name, 1.234e-2),
-    ]
-    assert com.get_written() == "PRX"
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.measure_all()
-
-
-def test_set_full_scale_unitless(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    com.put_text(chr(6))
-    pg.set_full_scale_unitless([1, 2])
-    assert com.get_written() == "FSR,1,2"
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.set_full_scale_unitless([1, 2])
-    # wrong values
-    com.put_text(chr(6))
-    with pytest.raises(ValueError):
-        pg.set_full_scale_unitless([12, 24])
-    # wrong number of values
-    com.put_text(chr(6))
-    with pytest.raises(ValueError):
-        pg.set_full_scale_unitless([12, 24, 32])
-
-
-def test_get_full_scale_unitless(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    com.put_text(chr(6))
-    com.put_text("2,0")
-    assert pg.get_full_scale_unitless() == [2, 0]
-    assert com.get_written() == "FSR"
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.get_full_scale_unitless()
-    # wrong answer from device
-    com.put_text(chr(6))
-    com.put_text("12,24")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.get_full_scale_unitless()
-
-
-def test_set_full_scale_mbar(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    com.put_text(chr(6))
-    pg.set_full_scale_mbar([100, 1])
-    fsr = pg.config.model.full_scale_ranges
-    assert com.get_written() == f"FSR,{fsr[100]},{fsr[1]}"
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.set_full_scale_mbar([100, 1])
-    # wrong values
-    com.put_text(chr(6))
-    with pytest.raises(ValueError):
-        pg.set_full_scale_mbar([12, 24])
-    # wrong number of values
-    com.put_text(chr(6))
-    with pytest.raises(ValueError):
-        pg.set_full_scale_mbar([12, 24, 32])
-
-
-def test_get_full_scale_mbar(started_pfeiffer_tpg):
-    com, pg = started_pfeiffer_tpg
-    com.put_text(chr(6))
-    com.put_text("2,0")
-    fsr_rev = pg.config.model.full_scale_ranges_reversed
-    assert pg.get_full_scale_mbar() == [fsr_rev[2], fsr_rev[0]]
-    assert com.get_written() == "FSR"
-    # no acknowledgment from device
-    com.put_text("not an acknowledgment")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.get_full_scale_mbar()
-    # wrong answer from device
-    com.put_text(chr(6))
-    com.put_text("12,24")
-    with pytest.raises(dev.PfeifferTPGError):
-        pg.get_full_scale_mbar()
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the .dev.pfeiffer_tpg sub-package.
+"""
+
+import logging
+
+import pytest
+
+from hvl_ccb import comm, dev
+from masked_comm.serial import PfeifferTPGLoopSerialCommunication
+
+logging.basicConfig(level=logging.ERROR)
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": dev.PfeifferTPGSerialCommunicationConfig.Parity.NONE,
+        "stopbits": dev.PfeifferTPGSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": dev.PfeifferTPGSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "terminator": b"\r\n",
+        "timeout": 3,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {"model": dev.PfeifferTPGConfig.Model.TPG25xA}
+
+
+@pytest.fixture
+def started_pfeiffer_tpg(com_config, dev_config):
+    com = PfeifferTPGLoopSerialCommunication(com_config)
+    com.open()
+    com.put_text(chr(6))
+    com.put_text(
+        ",".join(
+            [
+                dev.PfeifferTPG.SensorTypes.CMR.name,
+                dev.PfeifferTPG.SensorTypes.noSENSOR.name,
+            ]
+        )
+    )
+    with dev.PfeifferTPG(com, dev_config) as pg:
+        while com.get_written() is not None:
+            pass
+        yield com, pg
+
+
+def test_pfeiffer_tpg_instantiation(com_config, dev_config):
+    pg = dev.PfeifferTPG(com_config, dev_config)
+    assert pg is not None
+    assert pg.unit == "mbar"
+
+    # another valid config
+    config_dict = dict(dev_config)
+    config_dict["model"] = "TPGx6x"
+    dev.PfeifferTPG(com_config, config_dict)
+
+    # wrong config
+    config_dict["model"] = "wrong_name"
+    with pytest.raises(ValueError):
+        dev.PfeifferTPG(com_config, config_dict)
+
+
+def test_com_send_command(com_config):
+    com = PfeifferTPGLoopSerialCommunication(com_config)
+    com.open()
+    com.put_text(chr(6))
+    com.send_command("this is the command")
+    assert com.get_written() == "this is the command"
+    com.put_text("not an acknowledgement")
+    with pytest.raises(dev.PfeifferTPGError):
+        com.send_command("this command is not acknowledged")
+    com.close()
+
+
+def test_com_query(com_config):
+    com = PfeifferTPGLoopSerialCommunication(com_config)
+    com.open()
+    com.put_text(chr(6))
+    com.put_text("this is the answer")
+    assert com.query("this is the query") == "this is the answer"
+    assert com.get_written() == "this is the query"
+    assert com.get_written() == chr(5)
+    com.put_text("not an acknowledgement")
+    with pytest.raises(dev.PfeifferTPGError):
+        com.query("this query is not acknowledged")
+    com.put_text(chr(6))
+    com.put_text("")
+    with pytest.raises(dev.PfeifferTPGError):
+        com.query("the answer to this query is empty")
+    com.close()
+
+
+def test_pfeiffer_tpg_start(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    # starting again should work
+    com.put_text(chr(6))
+    com.put_text(",".join(["Unknown", dev.PfeifferTPG.SensorTypes.CMR.name]))
+    pg.start()
+    assert pg.number_of_sensors == 2
+    assert pg.sensors[0] == "Unknown"
+    assert pg.sensors[1] == "APR/CMR Linear Gauge"
+
+
+def test_pfeiffer_com_error(com_config, dev_config):
+    wrong_config = dict(com_config)
+    wrong_config["port"] = "NOT A PORT"
+    tpg = dev.PfeifferTPG(wrong_config, dev_config)
+    assert not tpg.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.start()
+
+    tpg = dev.PfeifferTPG(com_config, dev_config)
+    assert not tpg.com.is_open
+
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.identify_sensors()
+    tpg.sensors = [0]
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.measure(1)
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.measure_all()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.set_full_scale_unitless([1])
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.get_full_scale_unitless()
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.set_full_scale_mbar([100])
+    with pytest.raises(comm.SerialCommunicationIOError):
+        tpg.get_full_scale_mbar()
+
+
+def test_identify_sensors(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    # example with 3 sensors
+    com.put_text(chr(6))
+    com.put_text(
+        ",".join(
+            [
+                dev.PfeifferTPG.SensorTypes.PKR.name,
+                dev.PfeifferTPG.SensorTypes.CMR.name,
+                dev.PfeifferTPG.SensorTypes.IKR.name,
+            ]
+        )
+    )
+    pg.identify_sensors()
+    assert com.get_written() == "TID"
+    assert com.get_written() == chr(5)
+    assert pg.number_of_sensors == 3
+    assert pg.sensors[0] == dev.PfeifferTPG.SensorTypes.PKR.name
+    assert pg.sensors[1] == dev.PfeifferTPG.SensorTypes.CMR.name
+    assert pg.sensors[2] == dev.PfeifferTPG.SensorTypes.IKR.name
+    # wrong answer from device
+    com.put_text("this will make the command fail")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.identify_sensors()
+
+
+def test_set_display_unit(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    # valid str argument
+    com.put_text(chr(6))
+    pg.set_display_unit("mbar")
+    # valid PressureUnits argument
+    com.put_text(chr(6))
+    pg.set_display_unit(pg.PressureUnits.Pascal)
+    # valid PressureUnits argument but no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.set_display_unit(pg.PressureUnits.Pascal)
+    # invalid str argument
+    with pytest.raises(ValueError):
+        pg.set_display_unit("Not an accepted unit")
+
+
+def test_measure(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    # normal case
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Ok.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Ok.name, 1.234e-2)
+    assert com.get_written() == "PR2"
+    # underrange
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Underrange.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Underrange.name, 1.234e-2)
+    # overrange
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Overrange.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Overrange.name, 1.234e-2)
+    # error
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Sensor_error.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Sensor_error.name, 1.234e-2)
+    # off
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Sensor_off.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.Sensor_off.name, 1.234e-2)
+    # none
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.No_sensor.value},1.234E-02")
+    assert pg.measure(2) == (dev.PfeifferTPG.SensorStatus.No_sensor.name, 1.234e-2)
+    # identification error
+    com.put_text(chr(6))
+    com.put_text(f"{dev.PfeifferTPG.SensorStatus.Identification_error.value},1.234E-02")
+    assert pg.measure(2) == (
+        dev.PfeifferTPG.SensorStatus.Identification_error.name,
+        1.234e-2,
+    )
+    # wrong channel
+    with pytest.raises(ValueError):
+        pg.measure(12)
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.measure(1)
+
+
+def test_measure_all(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    # normal case
+    com.put_text(chr(6))
+    com.put_text(
+        f"{dev.PfeifferTPG.SensorStatus.Identification_error.value},1.234E-02,"
+        f"{dev.PfeifferTPG.SensorStatus.Ok.value},1.234E-02"
+    )
+    assert pg.measure_all() == [
+        (dev.PfeifferTPG.SensorStatus.Identification_error.name, 1.234e-2),
+        (dev.PfeifferTPG.SensorStatus.Ok.name, 1.234e-2),
+    ]
+    assert com.get_written() == "PRX"
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.measure_all()
+
+
+def test_set_full_scale_unitless(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    com.put_text(chr(6))
+    pg.set_full_scale_unitless([1, 2])
+    assert com.get_written() == "FSR,1,2"
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.set_full_scale_unitless([1, 2])
+    # wrong values
+    com.put_text(chr(6))
+    with pytest.raises(ValueError):
+        pg.set_full_scale_unitless([12, 24])
+    # wrong number of values
+    com.put_text(chr(6))
+    with pytest.raises(ValueError):
+        pg.set_full_scale_unitless([12, 24, 32])
+
+
+def test_get_full_scale_unitless(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    com.put_text(chr(6))
+    com.put_text("2,0")
+    assert pg.get_full_scale_unitless() == [2, 0]
+    assert com.get_written() == "FSR"
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.get_full_scale_unitless()
+    # wrong answer from device
+    com.put_text(chr(6))
+    com.put_text("12,24")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.get_full_scale_unitless()
+
+
+def test_set_full_scale_mbar(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    com.put_text(chr(6))
+    pg.set_full_scale_mbar([100, 1])
+    fsr = pg.config.model.full_scale_ranges
+    assert com.get_written() == f"FSR,{fsr[100]},{fsr[1]}"
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.set_full_scale_mbar([100, 1])
+    # wrong values
+    com.put_text(chr(6))
+    with pytest.raises(ValueError):
+        pg.set_full_scale_mbar([12, 24])
+    # wrong number of values
+    com.put_text(chr(6))
+    with pytest.raises(ValueError):
+        pg.set_full_scale_mbar([12, 24, 32])
+
+
+def test_get_full_scale_mbar(started_pfeiffer_tpg):
+    com, pg = started_pfeiffer_tpg
+    com.put_text(chr(6))
+    com.put_text("2,0")
+    fsr_rev = pg.config.model.full_scale_ranges_reversed
+    assert pg.get_full_scale_mbar() == [fsr_rev[2], fsr_rev[0]]
+    assert com.get_written() == "FSR"
+    # no acknowledgment from device
+    com.put_text("not an acknowledgment")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.get_full_scale_mbar()
+    # wrong answer from device
+    com.put_text(chr(6))
+    com.put_text("12,24")
+    with pytest.raises(dev.PfeifferTPGError):
+        pg.get_full_scale_mbar()
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_sst_luminox.py` & `hvl_ccb-0.9.0/tests/test_dev_sst_luminox.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,269 +1,269 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the SST Luminox Oxygen sensor device class.
-"""
-
-import pytest
-
-from hvl_ccb.comm import SerialCommunicationIOError
-from hvl_ccb.dev import (
-    Luminox,
-    LuminoxConfig,
-    LuminoxMeasurementType,
-    LuminoxMeasurementTypeError,
-    LuminoxOutputMode,
-    LuminoxOutputModeError,
-)
-from masked_comm.serial import LuminoxLoopSerialCommunication
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "port": "loop://?logging=debug",
-        "timeout": 0.05,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "wait_sec_post_activate": 0.01,
-        "wait_sec_trials_activate": 0.01,
-        "nr_trials_activate": 1,
-    }
-
-
-@pytest.fixture
-def testdev(com_config, dev_config):
-    serial_port = LuminoxLoopSerialCommunication(com_config)
-    with Luminox(serial_port, dev_config) as lumi:
-        while serial_port.get_written() is not None:
-            pass
-        yield serial_port, lumi
-
-
-@pytest.mark.parametrize(
-    "config_key,wrong_value",
-    [
-        ("wait_sec_post_activate", 0),
-        ("wait_sec_post_activate", -1),
-        ("wait_sec_trials_activate", 0),
-        ("wait_sec_trials_activate", -1),
-        ("nr_trials_activate", 0),
-    ],
-)
-def test_invalid_config_value(dev_config, config_key, wrong_value):
-    invalid_config = dict(dev_config)
-    invalid_config[config_key] = wrong_value
-    with pytest.raises(ValueError):
-        LuminoxConfig(**invalid_config)
-
-
-def test_instantiation(com_config, dev_config):
-    mbw = Luminox(com_config, dev_config)
-    assert mbw is not None
-
-
-def test_com_error(com_config, dev_config):
-    wrong_config = dict(com_config)
-    wrong_config["port"] = "NOT A PORT"
-    lumi = Luminox(wrong_config, dev_config)
-    assert not lumi.com.is_open
-
-    with pytest.raises(SerialCommunicationIOError):
-        lumi.start()
-
-    lumi = Luminox(com_config, dev_config)
-    assert not lumi.com.is_open
-
-
-def test_activate_output(testdev):
-    com, lumi = testdev
-    com.put_text(f"M 00{com.config.terminator_str()}")
-    lumi.activate_output(LuminoxOutputMode.streaming)
-    assert lumi.output == LuminoxOutputMode.streaming
-
-    with pytest.raises(LuminoxOutputModeError):
-        lumi.activate_output(LuminoxOutputMode.polling)
-
-
-def test_start(testdev):
-    com, lumi = testdev
-
-    # starting again should work
-    lumi.start()
-
-
-def test_read_stream(testdev):
-    com, lumi = testdev
-    expected_measurement_values = {
-        LuminoxMeasurementType.partial_pressure_o2: "0190.1",
-        LuminoxMeasurementType.temperature_sensor: "-27.3",
-        LuminoxMeasurementType.barometric_pressure: "0970",
-        LuminoxMeasurementType.percent_o2: "020.31",
-        LuminoxMeasurementType.sensor_status: "0000",
-    }
-    read_txt_stream = (
-        " ".join(
-            f"{measurement} {value}"
-            for (measurement, value) in expected_measurement_values.items()
-        )
-        + com.config.terminator_str()
-    )
-    com.put_text(read_txt_stream)
-
-    lumi.output = LuminoxOutputMode.polling
-    with pytest.raises(LuminoxOutputModeError):
-        lumi.read_streaming()
-
-    lumi.output = LuminoxOutputMode.streaming
-    readout = lumi.read_streaming()
-    expected_measurement_values = {
-        measurement: float(value)
-        for (measurement, value) in expected_measurement_values.items()
-    }
-    assert readout == expected_measurement_values
-
-
-@pytest.mark.parametrize(
-    "wrong_stream_read",
-    [
-        "O 0190.1 T -27.3 P  e 0000 % 020.31",  # missing value
-        "O 0190.1 T -27.3 P 0970 e 0000 % ",  # missing value #2
-        "O 0190.1 T -27.3 0970 e 0000 % 020.31",  # missing type symbol
-    ],
-)
-def test_read_stream_measurement_type_error(testdev, wrong_stream_read):
-    com, lumi = testdev
-    lumi.output = LuminoxOutputMode.streaming
-    com.put_text(wrong_stream_read)
-    with pytest.raises(LuminoxMeasurementTypeError):
-        lumi.read_streaming()
-
-
-@pytest.mark.parametrize(
-    "measurement_type, value_str",
-    [
-        (LuminoxMeasurementType.partial_pressure_o2, f"{190.1:06.1f}"),
-        (LuminoxMeasurementType.temperature_sensor, f"{-12.3:05.1f}"),
-        (LuminoxMeasurementType.serial_number, "00123 56895"),
-    ],
-)
-def test_query_single_measurement(testdev, measurement_type, value_str):
-    com, lumi = testdev
-
-    com.put_text(f"{measurement_type.command} {value_str}{com.config.terminator_str()}")
-
-    lumi.output = LuminoxOutputMode.polling
-    value = lumi.query_polling(measurement_type)
-    expected_value = measurement_type.cast_type(value_str)
-    assert value == expected_value
-
-
-def test_query_single_measurement_all_measurements(testdev):
-    com, lumi = testdev
-
-    expected_measurement_values = {
-        LuminoxMeasurementType.partial_pressure_o2: "0190.1",
-        LuminoxMeasurementType.temperature_sensor: "-27.3",
-        LuminoxMeasurementType.barometric_pressure: "0970",
-        LuminoxMeasurementType.percent_o2: "020.31",
-        LuminoxMeasurementType.sensor_status: "0000",
-    }
-    read_txt_stream = (
-        " ".join(
-            f"{measurement} {value}"
-            for (measurement, value) in expected_measurement_values.items()
-        )
-        + com.config.terminator_str()
-    )
-    com.put_text(read_txt_stream)
-
-    lumi.output = LuminoxOutputMode.polling
-    value = lumi.query_polling(LuminoxMeasurementType.all_measurements)
-    expected_measurement_values = {
-        measurement: float(value)
-        for (measurement, value) in expected_measurement_values.items()
-    }
-    assert value == expected_measurement_values
-
-
-def test_query_single_measurement_error_streaming_mode(testdev):
-    com, lumi = testdev
-
-    measurement_type = LuminoxMeasurementType.partial_pressure_o2
-    expected_value = 190.1
-    com.put_text(
-        f"{measurement_type} {expected_value:06.1f}" f"{com.config.terminator_str()}"
-    )
-
-    lumi.output = LuminoxOutputMode.streaming
-    with pytest.raises(LuminoxOutputModeError):
-        lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
-
-
-def test_query_single_measurement_warning(testdev):
-    com, lumi = testdev
-
-    expected_value = 190.1
-    com.put_text(
-        f"{LuminoxMeasurementType.partial_pressure_o2} {expected_value:06.1f}"
-        f" IGNORE ME{com.config.terminator_str()}"
-    )
-
-    lumi.output = LuminoxOutputMode.polling
-    value = lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
-    assert value == expected_value
-    # opt: check if the warning was actually issued
-
-
-@pytest.mark.parametrize(
-    "wrong_partial_pressure_o2_read",
-    [
-        "Z 0190.1",  # wrong type symbol
-        str(LuminoxMeasurementType.partial_pressure_o2),  # missing value
-        "0190.1",  # missing type symbol
-    ],
-)
-def test_query_single_measurement_type_error(testdev, wrong_partial_pressure_o2_read):
-    com, lumi = testdev
-    lumi.output = LuminoxOutputMode.polling
-    com.put_text(wrong_partial_pressure_o2_read)
-    with pytest.raises(LuminoxMeasurementTypeError):
-        lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
-
-
-def test_query_single_measurement_str_enum_name(testdev):
-    com, lumi = testdev
-
-    measurement_type = LuminoxMeasurementType.serial_number
-    expected_value = "00123 56895"
-    com.put_text(
-        f"{measurement_type.command} {expected_value}{com.config.terminator_str()}"
-    )
-
-    lumi.output = LuminoxOutputMode.polling
-    value = lumi.query_polling(measurement_type.name)
-    assert value == expected_value
-
-    with pytest.raises(ValueError):
-        lumi.query_polling(measurement_type.name.replace("_", " "))
-
-
-def test_query_single_measurement_str_enum_value(testdev):
-    com, lumi = testdev
-
-    measurement_type = LuminoxMeasurementType.serial_number
-    expected_value = "00123 56895"
-    com.put_text(
-        f"{measurement_type.command} {expected_value}{com.config.terminator_str()}"
-    )
-
-    lumi.output = LuminoxOutputMode.polling
-    value = lumi.query_polling(measurement_type.value)
-    assert value == expected_value
-
-    with pytest.raises(ValueError):
-        lumi.query_polling(measurement_type.command + " ?")
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the SST Luminox Oxygen sensor device class.
+"""
+
+import pytest
+
+from hvl_ccb.comm import SerialCommunicationIOError
+from hvl_ccb.dev import (
+    Luminox,
+    LuminoxConfig,
+    LuminoxMeasurementType,
+    LuminoxMeasurementTypeError,
+    LuminoxOutputMode,
+    LuminoxOutputModeError,
+)
+from masked_comm.serial import LuminoxLoopSerialCommunication
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "port": "loop://?logging=debug",
+        "timeout": 0.05,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "wait_sec_post_activate": 0.01,
+        "wait_sec_trials_activate": 0.01,
+        "nr_trials_activate": 1,
+    }
+
+
+@pytest.fixture
+def testdev(com_config, dev_config):
+    serial_port = LuminoxLoopSerialCommunication(com_config)
+    with Luminox(serial_port, dev_config) as lumi:
+        while serial_port.get_written() is not None:
+            pass
+        yield serial_port, lumi
+
+
+@pytest.mark.parametrize(
+    "config_key,wrong_value",
+    [
+        ("wait_sec_post_activate", 0),
+        ("wait_sec_post_activate", -1),
+        ("wait_sec_trials_activate", 0),
+        ("wait_sec_trials_activate", -1),
+        ("nr_trials_activate", 0),
+    ],
+)
+def test_invalid_config_value(dev_config, config_key, wrong_value):
+    invalid_config = dict(dev_config)
+    invalid_config[config_key] = wrong_value
+    with pytest.raises(ValueError):
+        LuminoxConfig(**invalid_config)
+
+
+def test_instantiation(com_config, dev_config):
+    mbw = Luminox(com_config, dev_config)
+    assert mbw is not None
+
+
+def test_com_error(com_config, dev_config):
+    wrong_config = dict(com_config)
+    wrong_config["port"] = "NOT A PORT"
+    lumi = Luminox(wrong_config, dev_config)
+    assert not lumi.com.is_open
+
+    with pytest.raises(SerialCommunicationIOError):
+        lumi.start()
+
+    lumi = Luminox(com_config, dev_config)
+    assert not lumi.com.is_open
+
+
+def test_activate_output(testdev):
+    com, lumi = testdev
+    com.put_text(f"M 00{com.config.terminator_str()}")
+    lumi.activate_output(LuminoxOutputMode.streaming)
+    assert lumi.output == LuminoxOutputMode.streaming
+
+    with pytest.raises(LuminoxOutputModeError):
+        lumi.activate_output(LuminoxOutputMode.polling)
+
+
+def test_start(testdev):
+    com, lumi = testdev
+
+    # starting again should work
+    lumi.start()
+
+
+def test_read_stream(testdev):
+    com, lumi = testdev
+    expected_measurement_values = {
+        LuminoxMeasurementType.partial_pressure_o2: "0190.1",
+        LuminoxMeasurementType.temperature_sensor: "-27.3",
+        LuminoxMeasurementType.barometric_pressure: "0970",
+        LuminoxMeasurementType.percent_o2: "020.31",
+        LuminoxMeasurementType.sensor_status: "0000",
+    }
+    read_txt_stream = (
+        " ".join(
+            f"{measurement} {value}"
+            for (measurement, value) in expected_measurement_values.items()
+        )
+        + com.config.terminator_str()
+    )
+    com.put_text(read_txt_stream)
+
+    lumi.output = LuminoxOutputMode.polling
+    with pytest.raises(LuminoxOutputModeError):
+        lumi.read_streaming()
+
+    lumi.output = LuminoxOutputMode.streaming
+    readout = lumi.read_streaming()
+    expected_measurement_values = {
+        measurement: float(value)
+        for (measurement, value) in expected_measurement_values.items()
+    }
+    assert readout == expected_measurement_values
+
+
+@pytest.mark.parametrize(
+    "wrong_stream_read",
+    [
+        "O 0190.1 T -27.3 P  e 0000 % 020.31",  # missing value
+        "O 0190.1 T -27.3 P 0970 e 0000 % ",  # missing value #2
+        "O 0190.1 T -27.3 0970 e 0000 % 020.31",  # missing type symbol
+    ],
+)
+def test_read_stream_measurement_type_error(testdev, wrong_stream_read):
+    com, lumi = testdev
+    lumi.output = LuminoxOutputMode.streaming
+    com.put_text(wrong_stream_read)
+    with pytest.raises(LuminoxMeasurementTypeError):
+        lumi.read_streaming()
+
+
+@pytest.mark.parametrize(
+    "measurement_type, value_str",
+    [
+        (LuminoxMeasurementType.partial_pressure_o2, f"{190.1:06.1f}"),
+        (LuminoxMeasurementType.temperature_sensor, f"{-12.3:05.1f}"),
+        (LuminoxMeasurementType.serial_number, "00123 56895"),
+    ],
+)
+def test_query_single_measurement(testdev, measurement_type, value_str):
+    com, lumi = testdev
+
+    com.put_text(f"{measurement_type.command} {value_str}{com.config.terminator_str()}")
+
+    lumi.output = LuminoxOutputMode.polling
+    value = lumi.query_polling(measurement_type)
+    expected_value = measurement_type.cast_type(value_str)
+    assert value == expected_value
+
+
+def test_query_single_measurement_all_measurements(testdev):
+    com, lumi = testdev
+
+    expected_measurement_values = {
+        LuminoxMeasurementType.partial_pressure_o2: "0190.1",
+        LuminoxMeasurementType.temperature_sensor: "-27.3",
+        LuminoxMeasurementType.barometric_pressure: "0970",
+        LuminoxMeasurementType.percent_o2: "020.31",
+        LuminoxMeasurementType.sensor_status: "0000",
+    }
+    read_txt_stream = (
+        " ".join(
+            f"{measurement} {value}"
+            for (measurement, value) in expected_measurement_values.items()
+        )
+        + com.config.terminator_str()
+    )
+    com.put_text(read_txt_stream)
+
+    lumi.output = LuminoxOutputMode.polling
+    value = lumi.query_polling(LuminoxMeasurementType.all_measurements)
+    expected_measurement_values = {
+        measurement: float(value)
+        for (measurement, value) in expected_measurement_values.items()
+    }
+    assert value == expected_measurement_values
+
+
+def test_query_single_measurement_error_streaming_mode(testdev):
+    com, lumi = testdev
+
+    measurement_type = LuminoxMeasurementType.partial_pressure_o2
+    expected_value = 190.1
+    com.put_text(
+        f"{measurement_type} {expected_value:06.1f}" f"{com.config.terminator_str()}"
+    )
+
+    lumi.output = LuminoxOutputMode.streaming
+    with pytest.raises(LuminoxOutputModeError):
+        lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
+
+
+def test_query_single_measurement_warning(testdev):
+    com, lumi = testdev
+
+    expected_value = 190.1
+    com.put_text(
+        f"{LuminoxMeasurementType.partial_pressure_o2} {expected_value:06.1f}"
+        f" IGNORE ME{com.config.terminator_str()}"
+    )
+
+    lumi.output = LuminoxOutputMode.polling
+    value = lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
+    assert value == expected_value
+    # opt: check if the warning was actually issued
+
+
+@pytest.mark.parametrize(
+    "wrong_partial_pressure_o2_read",
+    [
+        "Z 0190.1",  # wrong type symbol
+        str(LuminoxMeasurementType.partial_pressure_o2),  # missing value
+        "0190.1",  # missing type symbol
+    ],
+)
+def test_query_single_measurement_type_error(testdev, wrong_partial_pressure_o2_read):
+    com, lumi = testdev
+    lumi.output = LuminoxOutputMode.polling
+    com.put_text(wrong_partial_pressure_o2_read)
+    with pytest.raises(LuminoxMeasurementTypeError):
+        lumi.query_polling(LuminoxMeasurementType.partial_pressure_o2)
+
+
+def test_query_single_measurement_str_enum_name(testdev):
+    com, lumi = testdev
+
+    measurement_type = LuminoxMeasurementType.serial_number
+    expected_value = "00123 56895"
+    com.put_text(
+        f"{measurement_type.command} {expected_value}{com.config.terminator_str()}"
+    )
+
+    lumi.output = LuminoxOutputMode.polling
+    value = lumi.query_polling(measurement_type.name)
+    assert value == expected_value
+
+    with pytest.raises(ValueError):
+        lumi.query_polling(measurement_type.name.replace("_", " "))
+
+
+def test_query_single_measurement_str_enum_value(testdev):
+    com, lumi = testdev
+
+    measurement_type = LuminoxMeasurementType.serial_number
+    expected_value = "00123 56895"
+    com.put_text(
+        f"{measurement_type.command} {expected_value}{com.config.terminator_str()}"
+    )
+
+    lumi.output = LuminoxOutputMode.polling
+    value = lumi.query_polling(measurement_type.value)
+    assert value == expected_value
+
+    with pytest.raises(ValueError):
+        lumi.query_polling(measurement_type.command + " ?")
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_supercube.py` & `hvl_ccb-0.9.0/tests/test_dev_supercube.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,542 +1,542 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Test module for the Supercube base device class.
-"""
-
-import logging
-from time import sleep
-from typing import List
-
-import pytest
-from pytest_mock import MockerFixture
-
-from hvl_ccb.comm import OpcUaCommunicationIOError, OpcUaCommunicationTimeoutError
-from hvl_ccb.dev.supercube import constants
-from hvl_ccb.dev.supercube.base import (
-    SupercubeBase,
-    SupercubeConfiguration,
-    SupercubeEarthingStickOperationError,
-    SupercubeOpcUaCommunication,
-)
-from opctools import DemoServer
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "namespace_index": 3,
-        "polling_delay_sec": 0.05,
-        "polling_interval_sec": 0.01,
-    }
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {
-        "host": "localhost",
-        "port": 14123,
-        "endpoint_name": "",
-        "update_period": 10,
-        "wait_timeout_retry_sec": 0.01,
-        "max_timeout_retry_nr": 3,
-    }
-
-
-@pytest.fixture(scope="function")
-def demo_opcua_server(dev_config):
-    opcua_server = DemoServer(dev_config["namespace_index"], "B", 14123)
-    opcua_server.start()
-
-    # add socket nodes
-    for socket in constants.GeneralSockets:
-        opcua_server.add_var(socket, False, True)
-
-    # add support input and output nodes
-    for support in constants.GeneralSupport:
-        opcua_server.add_var(support, False, True)
-
-    for i, alarm in enumerate(constants.Alarms):
-        opcua_server.add_var(alarm, bool(i % 2), False)
-
-    # add remote control vars
-    opcua_server.add_var(constants.OpcControl.active, False, True)
-    opcua_server.add_var(constants.OpcControl.live, False, True)
-
-    yield opcua_server
-
-    opcua_server.stop()
-
-
-@pytest.fixture(scope="function")
-def opened_supercube_com(
-    com_config, dev_config, demo_opcua_server: DemoServer,
-):
-    opc_comm = SupercubeOpcUaCommunication(com_config)
-    opc_comm.open()
-    yield opc_comm
-    opc_comm.close()
-
-
-def _get_logged_messages(
-    caplog, expected_logger_name: str, expected_level: int,
-) -> List[str]:
-    return [
-        message
-        for logger_name, level, message in caplog.record_tuples
-        if logger_name == expected_logger_name and level == expected_level
-    ]
-
-
-def test_supercube_subscription_handler_datachange_safetystatus(
-    opened_supercube_com: SupercubeOpcUaCommunication,
-    dev_config: dict,
-    demo_opcua_server: DemoServer,
-    caplog,  # pytest._logging.LogCaptureFixture
-):
-    ns_index = dev_config["namespace_index"]
-
-    caplog.set_level(logging.INFO)
-
-    # test a status datachange
-    demo_opcua_server.add_var(
-        constants.Safety.status, int(constants.SafetyStatus.Initializing), True,
-    )
-    opened_supercube_com.init_monitored_nodes(str(constants.Safety.status), ns_index)
-    sleep(0.05)
-
-    demo_opcua_server.set_var(
-        constants.Safety.status, int(constants.SafetyStatus.GreenNotReady),
-    )
-    sleep(0.05)
-
-    # FIXME: does not work in gitlab CI
-    # check presence of log messages in a correct order
-    # assert [
-    #     f"Safety: {str(constants.SafetyStatus.Initializing)}",
-    #     f"Safety: {str(constants.SafetyStatus.GreenNotReady)}",
-    # ] == _get_logged_messages(caplog, "hvl_ccb.dev.supercube.base", logging.INFO)
-
-
-def test_supercube_subscription_handler_datachange_earthingstickstatus(
-    opened_supercube_com: SupercubeOpcUaCommunication,
-    dev_config: dict,
-    demo_opcua_server: DemoServer,
-    caplog,  # pytest._logging.LogCaptureFixture
-):
-    ns_index = dev_config["namespace_index"]
-
-    caplog.set_level(logging.INFO)
-
-    # test an earthing stick status datachange
-    ess_tuple = constants.EarthingStick.statuses()
-    for ess in ess_tuple:
-        demo_opcua_server.add_var(
-            ess, int(constants.EarthingStickStatus.inactive), True,
-        )
-    opened_supercube_com.init_monitored_nodes(ess_tuple, ns_index)
-    sleep(0.05)
-
-    for ess in ess_tuple:
-        demo_opcua_server.set_var(ess, int(constants.EarthingStickStatus.closed))
-    sleep(0.05)
-
-    # FIXME: does not work in gitlab CI
-    # check presence of log messages in a correct order
-    # assert (
-    #     [
-    #         f"Earthing {ess.number}: {str(constants.EarthingStickStatus.inactive)}"
-    #         for ess in ess_tuple
-    #     ]
-    #     + [
-    #         f"Earthing {ess.number}: {str(constants.EarthingStickStatus.closed)}"
-    #         for ess in ess_tuple
-    #     ]
-    # ) == _get_logged_messages(caplog, "hvl_ccb.dev.supercube.base", logging.INFO)
-
-
-@pytest.fixture(scope="function")
-def cube(com_config, dev_config, demo_opcua_server: DemoServer):
-    cube = SupercubeBase(com_config, dev_config)
-    cube.start()
-    yield cube
-    cube.stop()
-
-
-def test_dev_config(dev_config):
-    # currently there are no non-default config values
-    SupercubeConfiguration()
-
-    config = SupercubeConfiguration(**dev_config)
-    for key, value in dev_config.items():
-        assert getattr(config, key) == value
-
-
-@pytest.mark.parametrize(
-    "wrong_config_dict",
-    [
-        {"namespace_index": -1},
-        {"polling_interval_sec": -1},
-        {"polling_interval_sec": 0},
-        {"polling_delay_sec": -1},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_config_dict):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_config_dict)
-    with pytest.raises(ValueError):
-        SupercubeConfiguration(**invalid_config)
-
-
-def test_set_remote_control(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    cube.set_remote_control(False)
-    assert demo_opcua_server.get_var(constants.OpcControl.active) is False
-    cube.set_remote_control(True)
-    assert demo_opcua_server.get_var(constants.OpcControl.active) is True
-
-
-def test_status_poller(
-    com_config, dev_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
-):
-
-    cube = SupercubeBase(com_config, dev_config)
-    poller = cube.status_poller
-    assert poller is not None
-    assert poller.polling_delay_sec == dev_config["polling_delay_sec"]
-    assert poller.polling_interval_sec == dev_config["polling_interval_sec"]
-    assert poller.polling_timeout_sec is None
-    assert poller.spoll_handler == cube._spoll_handler
-
-    spy_spoll_handler = mocker.spy(poller, "spoll_handler")
-    spy_start_polling = mocker.spy(poller, "start_polling")
-    spy_stop_polling = mocker.spy(poller, "stop_polling")
-
-    poller.stop_polling()
-    assert spy_stop_polling.spy_return is False
-
-    cube.start()
-
-    spy_start_polling.assert_called()
-    assert spy_start_polling.spy_return is True
-
-    poller.start_polling()
-    assert spy_start_polling.spy_return is False
-
-    sleep(dev_config["polling_delay_sec"] + 3 * dev_config["polling_interval_sec"])
-    spy_spoll_handler.assert_called()
-    assert spy_spoll_handler.spy_return is None
-
-    cube.stop()
-    spy_stop_polling.assert_called()
-    assert spy_stop_polling.spy_return is True
-
-
-def test_status_poller_timeout_error(
-    com_config, dev_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
-):
-
-    cube = SupercubeBase(com_config, dev_config)
-    cube.start()
-    assert cube.status_poller.is_polling()
-    assert cube.com.is_open
-
-    # patch UASocketClient.send_request to raise a mock TimeoutError as if coming from
-    # used therein concurrent.futures.Future;
-    # raise error only on disable remote control done via poller thread on stop()
-    # => write(constants.OpcControl.active, False)
-
-    # Use bound method (otherwise live unpatch does not work):
-    send_request_orig = cube.com._client.uaclient._uasocket.send_request
-
-    def send_request(self, request, *args, **kwargs):
-        if (
-            hasattr(request, "Parameters")
-            and hasattr(request.Parameters, "NodesToWrite")
-        ):
-            node_to_write = request.Parameters.NodesToWrite[0]
-            if (
-                node_to_write.NodeId.Identifier == constants.OpcControl.active
-                and node_to_write.Value.Value.Value is False
-            ):
-                from concurrent.futures import TimeoutError
-
-                raise TimeoutError("mock timeout error")
-        # method already bound - ignore `self`
-        return send_request_orig(request, *args, **kwargs)
-
-    mocker.patch(
-        "opcua.client.ua_client.UASocketClient.send_request",
-        side_effect=send_request,
-        autospec=True,
-    )
-
-    # check poller thread error caught and wrapped
-    with pytest.raises(OpcUaCommunicationTimeoutError):
-        cube.set_remote_control(False)
-    assert not cube.status_poller.is_polling()
-    assert cube.com.is_open
-
-    # check that stopping also does raises the error, but cleans up otherwise
-    with pytest.raises(OpcUaCommunicationTimeoutError):
-        cube.stop()
-    assert not cube.status_poller.is_polling()
-    assert not cube.com.is_open
-
-    # unpatch and try to stop dev again - will raise error due to broken com,
-    # but not the timeout
-    mocker.patch(
-        "opcua.client.ua_client.UASocketClient.send_request",
-        side_effect=send_request_orig,
-    )
-
-    with pytest.raises(OpcUaCommunicationIOError) as excinfo:
-        cube.stop()
-        assert excinfo.type is not OpcUaCommunicationTimeoutError
-    assert not cube.status_poller.is_polling()
-    assert not cube.com.is_open
-
-
-def test_get_support_input(cube: SupercubeBase):
-    assert cube.get_support_input(1, 1) is False
-
-    with pytest.raises(ValueError):
-        cube.get_support_input(1, 123)
-    with pytest.raises(ValueError):
-        cube.get_support_input(123, 1)
-
-
-def test_get_set_support_output(cube: SupercubeBase):
-    cube.set_support_output(1, 1, False)
-    assert cube.get_support_output(1, 1) is False
-    cube.set_support_output(1, 1, True)
-    assert cube.get_support_output(1, 1) is True
-
-    with pytest.raises(ValueError):
-        cube.get_support_output(1, 123)
-    with pytest.raises(ValueError):
-        cube.get_support_output(123, 1)
-    with pytest.raises(ValueError):
-        cube.set_support_output(1, 123, False)
-    with pytest.raises(ValueError):
-        cube.set_support_output(123, 1, False)
-
-
-def test_set_support_output_impulse(cube: SupercubeBase):
-    cube.set_support_output_impulse(2, 2, 0.01, True)
-
-    with pytest.raises(ValueError):
-        cube.set_support_output_impulse(1, 123)
-    with pytest.raises(ValueError):
-        cube.set_support_output_impulse(123, 1)
-
-
-def test_get_t13_socket(cube: SupercubeBase):
-    assert cube.get_t13_socket(1) is False
-    cube.set_t13_socket(1, True)
-    assert cube.get_t13_socket(1) is True
-
-    with pytest.raises(ValueError):
-        cube.get_t13_socket(4)
-
-
-def test_set_t13_socket(cube: SupercubeBase):
-    cube.set_t13_socket(1, True)
-
-    with pytest.raises(ValueError):
-        cube.set_t13_socket(4, False)
-
-    with pytest.raises(ValueError):
-        cube.set_t13_socket(1, "on")
-
-
-def test_get_cee16(cube: SupercubeBase):
-    cube.set_cee16_socket(False)
-    assert cube.get_cee16_socket() is False
-    cube.set_cee16_socket(True)
-    assert cube.get_cee16_socket() is True
-
-
-def test_set_cee16(cube: SupercubeBase):
-    cube.set_cee16_socket(True)
-    cube.set_cee16_socket(False)
-
-    with pytest.raises(ValueError):
-        cube.set_cee16_socket(1)
-
-    with pytest.raises(ValueError):
-        cube.set_cee16_socket("on")
-
-
-def test_get_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.Safety.status, 1, False)
-    assert cube.get_status() == constants.SafetyStatus.GreenNotReady
-
-    demo_opcua_server.set_var(constants.Safety.status, 2)
-    assert cube.get_status() == constants.SafetyStatus.GreenReady
-
-
-def test_ready(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.Safety.switch_to_ready, False, True)
-    cube.ready(True)
-    assert demo_opcua_server.get_var(constants.Safety.switch_to_ready) is True
-
-
-def test_operate(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.Safety.switch_to_operate, False, True)
-    cube.operate(True)
-    assert demo_opcua_server.get_var(constants.Safety.switch_to_operate) is True
-
-
-def test_get_measurement_ratio(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.MeasurementsDividerRatio.input_1, 123.4, False)
-    assert cube.get_measurement_ratio(1) == 123.4
-
-    with pytest.raises(ValueError):
-        cube.get_measurement_ratio(123)
-
-
-def test_get_measurement_voltage(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.MeasurementsScaledInput.input_1, 110_000, False)
-    assert cube.get_measurement_voltage(1) == 110_000.0
-
-    with pytest.raises(ValueError):
-        cube.get_measurement_voltage(123)
-
-
-def test_get_earthing_stick_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.EarthingStick.status_1, 1, False)
-    assert cube.get_earthing_stick_status(1) == constants.EarthingStickStatus(1)
-
-    with pytest.raises(ValueError):
-        cube.get_earthing_stick_status(123)
-
-
-def test_get_earthing_stick_operating_status(
-    cube: SupercubeBase, demo_opcua_server: DemoServer
-):
-    demo_opcua_server.add_var(
-        constants.EarthingStick.operating_status_1,
-        constants.EarthingStickOperatingStatus.auto,
-        False,
-    )
-    assert (
-        cube.get_earthing_stick_operating_status(1)
-        is constants.EarthingStickOperatingStatus.auto
-    )
-
-    with pytest.raises(ValueError):
-        cube.get_earthing_stick_operating_status(123)
-
-
-def test_get_earthing_stick_manual(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(
-        constants.EarthingStick.manual_1,
-        bool(constants.EarthingStickOperation.close),
-        False,
-    )
-    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.close
-
-    with pytest.raises(ValueError):
-        cube.get_earthing_stick_manual(123)
-
-
-def test_operate_earthing_stick(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(
-        constants.EarthingStick.operating_status_1,
-        constants.EarthingStickOperatingStatus.manual,
-        False,
-    )
-    demo_opcua_server.add_var(
-        constants.EarthingStick.manual_1,
-        bool(constants.EarthingStickOperation.open),
-        True,
-    )
-    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.open
-    cube.operate_earthing_stick(1, constants.EarthingStickOperation.close)
-    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.close
-
-
-def test_operate_earthing_stick_error(
-    cube: SupercubeBase, demo_opcua_server: DemoServer,
-):
-    demo_opcua_server.add_var(
-        constants.EarthingStick.operating_status_1,
-        constants.EarthingStickOperatingStatus.auto,
-        False,
-    )
-    with pytest.raises(SupercubeEarthingStickOperationError):
-        cube.operate_earthing_stick(1, constants.EarthingStickOperation.close)
-
-
-def test_quit_error(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.Errors.quit, False, True)
-    cube.quit_error()
-    assert demo_opcua_server.get_var(constants.Errors.quit) is False
-
-
-def test_get_door_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.Door.status_1, 2, False)
-    assert cube.get_door_status(1) == constants.DoorStatus(2)
-
-
-def test_get_earthing_rod_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
-    demo_opcua_server.add_var(constants.EarthingRod.status_1, 0, False)
-    assert cube.get_earthing_rod_status(1) == constants.EarthingRodStatus(0)
-
-
-def test_set_status_board(cube: SupercubeBase, demo_opcua_server: DemoServer):
-
-    n_max = len(constants.MessageBoard)
-
-    with pytest.raises(ValueError):
-        cube.set_status_board(["x"] * (n_max + 1))
-    with pytest.raises(ValueError):
-        cube.set_status_board(["x"], pos=[n_max])
-
-    for line in constants.MessageBoard:
-        demo_opcua_server.add_var(line, "", True)
-
-    msgs = ["Hello World", "Hello Fabian", "Hello HVL"]
-
-    cube.set_status_board(msgs[:1])
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)) == msgs[0]
-    cube.set_status_board(msgs[:1], pos=[1], clear_board=False)
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)) == msgs[0]
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(2)) == msgs[0]
-
-    positions = [4, 8, 12]
-    cube.set_status_board(msgs, positions, clear_board=False)
-    for i, p in enumerate(positions):
-        assert demo_opcua_server.get_var(constants.MessageBoard.line(p+1)) == msgs[i]
-
-    cube.set_status_board([str(i) for i in range(15)])
-    for i in range(15):
-        assert demo_opcua_server.get_var(constants.MessageBoard.line(i+1)) == str(i)
-
-
-def test_set_message_board(cube: SupercubeBase, demo_opcua_server: DemoServer):
-
-    n_max = len(constants.MessageBoard)
-
-    with pytest.raises(ValueError):
-        cube.set_message_board(["x"] * (n_max + 1))
-
-    for line in constants.MessageBoard:
-        demo_opcua_server.add_var(line, "", True)
-
-    msgs = ["ERROR: This is unexpected", "Good choice"]
-    cube.set_message_board(msgs[:1])
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)).endswith(msgs[0])
-
-    # push two messages to first two lines, in the given order
-    cube.set_message_board(msgs)
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)).endswith(msgs[0])
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(2)).endswith(msgs[1])
-    assert demo_opcua_server.get_var(constants.MessageBoard.line(3)).endswith(msgs[0])
-
-    # overwrite all messages except last, which is pushed to be last line
-    cube.set_message_board("x" * (n_max - 1))
-    for n in range(len(constants.MessageBoard)-1):
-        assert demo_opcua_server.get_var(constants.MessageBoard.line(n+1)).endswith("x")
-    last_msg = demo_opcua_server.get_var(constants.MessageBoard.line(n_max))
-    assert last_msg.endswith(msgs[0])
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Test module for the Supercube base device class.
+"""
+
+import logging
+from time import sleep
+from typing import List
+
+import pytest
+from pytest_mock import MockerFixture
+
+from hvl_ccb.comm import OpcUaCommunicationIOError, OpcUaCommunicationTimeoutError
+from hvl_ccb.dev.supercube import constants
+from hvl_ccb.dev.supercube.base import (
+    SupercubeBase,
+    SupercubeConfiguration,
+    SupercubeEarthingStickOperationError,
+    SupercubeOpcUaCommunication,
+)
+from opctools import DemoServer
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "namespace_index": 3,
+        "polling_delay_sec": 0.05,
+        "polling_interval_sec": 0.01,
+    }
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {
+        "host": "localhost",
+        "port": 14123,
+        "endpoint_name": "",
+        "update_period": 10,
+        "wait_timeout_retry_sec": 0.01,
+        "max_timeout_retry_nr": 3,
+    }
+
+
+@pytest.fixture(scope="function")
+def demo_opcua_server(dev_config):
+    opcua_server = DemoServer(dev_config["namespace_index"], "B", 14123)
+    opcua_server.start()
+
+    # add socket nodes
+    for socket in constants.GeneralSockets:
+        opcua_server.add_var(socket, False, True)
+
+    # add support input and output nodes
+    for support in constants.GeneralSupport:
+        opcua_server.add_var(support, False, True)
+
+    for i, alarm in enumerate(constants.Alarms):
+        opcua_server.add_var(alarm, bool(i % 2), False)
+
+    # add remote control vars
+    opcua_server.add_var(constants.OpcControl.active, False, True)
+    opcua_server.add_var(constants.OpcControl.live, False, True)
+
+    yield opcua_server
+
+    opcua_server.stop()
+
+
+@pytest.fixture(scope="function")
+def opened_supercube_com(
+    com_config, dev_config, demo_opcua_server: DemoServer,
+):
+    opc_comm = SupercubeOpcUaCommunication(com_config)
+    opc_comm.open()
+    yield opc_comm
+    opc_comm.close()
+
+
+def _get_logged_messages(
+    caplog, expected_logger_name: str, expected_level: int,
+) -> List[str]:
+    return [
+        message
+        for logger_name, level, message in caplog.record_tuples
+        if logger_name == expected_logger_name and level == expected_level
+    ]
+
+
+def test_supercube_subscription_handler_datachange_safetystatus(
+    opened_supercube_com: SupercubeOpcUaCommunication,
+    dev_config: dict,
+    demo_opcua_server: DemoServer,
+    caplog,  # pytest._logging.LogCaptureFixture
+):
+    ns_index = dev_config["namespace_index"]
+
+    caplog.set_level(logging.INFO)
+
+    # test a status datachange
+    demo_opcua_server.add_var(
+        constants.Safety.status, int(constants.SafetyStatus.Initializing), True,
+    )
+    opened_supercube_com.init_monitored_nodes(str(constants.Safety.status), ns_index)
+    sleep(0.05)
+
+    demo_opcua_server.set_var(
+        constants.Safety.status, int(constants.SafetyStatus.GreenNotReady),
+    )
+    sleep(0.05)
+
+    # FIXME: does not work in gitlab CI
+    # check presence of log messages in a correct order
+    # assert [
+    #     f"Safety: {str(constants.SafetyStatus.Initializing)}",
+    #     f"Safety: {str(constants.SafetyStatus.GreenNotReady)}",
+    # ] == _get_logged_messages(caplog, "hvl_ccb.dev.supercube.base", logging.INFO)
+
+
+def test_supercube_subscription_handler_datachange_earthingstickstatus(
+    opened_supercube_com: SupercubeOpcUaCommunication,
+    dev_config: dict,
+    demo_opcua_server: DemoServer,
+    caplog,  # pytest._logging.LogCaptureFixture
+):
+    ns_index = dev_config["namespace_index"]
+
+    caplog.set_level(logging.INFO)
+
+    # test an earthing stick status datachange
+    ess_tuple = constants.EarthingStick.statuses()
+    for ess in ess_tuple:
+        demo_opcua_server.add_var(
+            ess, int(constants.EarthingStickStatus.inactive), True,
+        )
+    opened_supercube_com.init_monitored_nodes(ess_tuple, ns_index)
+    sleep(0.05)
+
+    for ess in ess_tuple:
+        demo_opcua_server.set_var(ess, int(constants.EarthingStickStatus.closed))
+    sleep(0.05)
+
+    # FIXME: does not work in gitlab CI
+    # check presence of log messages in a correct order
+    # assert (
+    #     [
+    #         f"Earthing {ess.number}: {str(constants.EarthingStickStatus.inactive)}"
+    #         for ess in ess_tuple
+    #     ]
+    #     + [
+    #         f"Earthing {ess.number}: {str(constants.EarthingStickStatus.closed)}"
+    #         for ess in ess_tuple
+    #     ]
+    # ) == _get_logged_messages(caplog, "hvl_ccb.dev.supercube.base", logging.INFO)
+
+
+@pytest.fixture(scope="function")
+def cube(com_config, dev_config, demo_opcua_server: DemoServer):
+    cube = SupercubeBase(com_config, dev_config)
+    cube.start()
+    yield cube
+    cube.stop()
+
+
+def test_dev_config(dev_config):
+    # currently there are no non-default config values
+    SupercubeConfiguration()
+
+    config = SupercubeConfiguration(**dev_config)
+    for key, value in dev_config.items():
+        assert getattr(config, key) == value
+
+
+@pytest.mark.parametrize(
+    "wrong_config_dict",
+    [
+        {"namespace_index": -1},
+        {"polling_interval_sec": -1},
+        {"polling_interval_sec": 0},
+        {"polling_delay_sec": -1},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_config_dict):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_config_dict)
+    with pytest.raises(ValueError):
+        SupercubeConfiguration(**invalid_config)
+
+
+def test_set_remote_control(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    cube.set_remote_control(False)
+    assert demo_opcua_server.get_var(constants.OpcControl.active) is False
+    cube.set_remote_control(True)
+    assert demo_opcua_server.get_var(constants.OpcControl.active) is True
+
+
+def test_status_poller(
+    com_config, dev_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
+):
+
+    cube = SupercubeBase(com_config, dev_config)
+    poller = cube.status_poller
+    assert poller is not None
+    assert poller.polling_delay_sec == dev_config["polling_delay_sec"]
+    assert poller.polling_interval_sec == dev_config["polling_interval_sec"]
+    assert poller.polling_timeout_sec is None
+    assert poller.spoll_handler == cube._spoll_handler
+
+    spy_spoll_handler = mocker.spy(poller, "spoll_handler")
+    spy_start_polling = mocker.spy(poller, "start_polling")
+    spy_stop_polling = mocker.spy(poller, "stop_polling")
+
+    poller.stop_polling()
+    assert spy_stop_polling.spy_return is False
+
+    cube.start()
+
+    spy_start_polling.assert_called()
+    assert spy_start_polling.spy_return is True
+
+    poller.start_polling()
+    assert spy_start_polling.spy_return is False
+
+    sleep(dev_config["polling_delay_sec"] + 3 * dev_config["polling_interval_sec"])
+    spy_spoll_handler.assert_called()
+    assert spy_spoll_handler.spy_return is None
+
+    cube.stop()
+    spy_stop_polling.assert_called()
+    assert spy_stop_polling.spy_return is True
+
+
+def test_status_poller_timeout_error(
+    com_config, dev_config, demo_opcua_server: DemoServer, mocker: MockerFixture,
+):
+
+    cube = SupercubeBase(com_config, dev_config)
+    cube.start()
+    assert cube.status_poller.is_polling()
+    assert cube.com.is_open
+
+    # patch UASocketClient.send_request to raise a mock TimeoutError as if coming from
+    # used therein concurrent.futures.Future;
+    # raise error only on disable remote control done via poller thread on stop()
+    # => write(constants.OpcControl.active, False)
+
+    # Use bound method (otherwise live unpatch does not work):
+    send_request_orig = cube.com._client.uaclient._uasocket.send_request
+
+    def send_request(self, request, *args, **kwargs):
+        if (
+            hasattr(request, "Parameters")
+            and hasattr(request.Parameters, "NodesToWrite")
+        ):
+            node_to_write = request.Parameters.NodesToWrite[0]
+            if (
+                node_to_write.NodeId.Identifier == constants.OpcControl.active
+                and node_to_write.Value.Value.Value is False
+            ):
+                from concurrent.futures import TimeoutError
+
+                raise TimeoutError("mock timeout error")
+        # method already bound - ignore `self`
+        return send_request_orig(request, *args, **kwargs)
+
+    mocker.patch(
+        "opcua.client.ua_client.UASocketClient.send_request",
+        side_effect=send_request,
+        autospec=True,
+    )
+
+    # check poller thread error caught and wrapped
+    with pytest.raises(OpcUaCommunicationTimeoutError):
+        cube.set_remote_control(False)
+    assert not cube.status_poller.is_polling()
+    assert cube.com.is_open
+
+    # check that stopping also does raises the error, but cleans up otherwise
+    with pytest.raises(OpcUaCommunicationTimeoutError):
+        cube.stop()
+    assert not cube.status_poller.is_polling()
+    assert not cube.com.is_open
+
+    # unpatch and try to stop dev again - will raise error due to broken com,
+    # but not the timeout
+    mocker.patch(
+        "opcua.client.ua_client.UASocketClient.send_request",
+        side_effect=send_request_orig,
+    )
+
+    with pytest.raises(OpcUaCommunicationIOError) as excinfo:
+        cube.stop()
+        assert excinfo.type is not OpcUaCommunicationTimeoutError
+    assert not cube.status_poller.is_polling()
+    assert not cube.com.is_open
+
+
+def test_get_support_input(cube: SupercubeBase):
+    assert cube.get_support_input(1, 1) is False
+
+    with pytest.raises(ValueError):
+        cube.get_support_input(1, 123)
+    with pytest.raises(ValueError):
+        cube.get_support_input(123, 1)
+
+
+def test_get_set_support_output(cube: SupercubeBase):
+    cube.set_support_output(1, 1, False)
+    assert cube.get_support_output(1, 1) is False
+    cube.set_support_output(1, 1, True)
+    assert cube.get_support_output(1, 1) is True
+
+    with pytest.raises(ValueError):
+        cube.get_support_output(1, 123)
+    with pytest.raises(ValueError):
+        cube.get_support_output(123, 1)
+    with pytest.raises(ValueError):
+        cube.set_support_output(1, 123, False)
+    with pytest.raises(ValueError):
+        cube.set_support_output(123, 1, False)
+
+
+def test_set_support_output_impulse(cube: SupercubeBase):
+    cube.set_support_output_impulse(2, 2, 0.01, True)
+
+    with pytest.raises(ValueError):
+        cube.set_support_output_impulse(1, 123)
+    with pytest.raises(ValueError):
+        cube.set_support_output_impulse(123, 1)
+
+
+def test_get_t13_socket(cube: SupercubeBase):
+    assert cube.get_t13_socket(1) is False
+    cube.set_t13_socket(1, True)
+    assert cube.get_t13_socket(1) is True
+
+    with pytest.raises(ValueError):
+        cube.get_t13_socket(4)
+
+
+def test_set_t13_socket(cube: SupercubeBase):
+    cube.set_t13_socket(1, True)
+
+    with pytest.raises(ValueError):
+        cube.set_t13_socket(4, False)
+
+    with pytest.raises(ValueError):
+        cube.set_t13_socket(1, "on")
+
+
+def test_get_cee16(cube: SupercubeBase):
+    cube.set_cee16_socket(False)
+    assert cube.get_cee16_socket() is False
+    cube.set_cee16_socket(True)
+    assert cube.get_cee16_socket() is True
+
+
+def test_set_cee16(cube: SupercubeBase):
+    cube.set_cee16_socket(True)
+    cube.set_cee16_socket(False)
+
+    with pytest.raises(ValueError):
+        cube.set_cee16_socket(1)
+
+    with pytest.raises(ValueError):
+        cube.set_cee16_socket("on")
+
+
+def test_get_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.Safety.status, 1, False)
+    assert cube.get_status() == constants.SafetyStatus.GreenNotReady
+
+    demo_opcua_server.set_var(constants.Safety.status, 2)
+    assert cube.get_status() == constants.SafetyStatus.GreenReady
+
+
+def test_ready(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.Safety.switch_to_ready, False, True)
+    cube.ready(True)
+    assert demo_opcua_server.get_var(constants.Safety.switch_to_ready) is True
+
+
+def test_operate(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.Safety.switch_to_operate, False, True)
+    cube.operate(True)
+    assert demo_opcua_server.get_var(constants.Safety.switch_to_operate) is True
+
+
+def test_get_measurement_ratio(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.MeasurementsDividerRatio.input_1, 123.4, False)
+    assert cube.get_measurement_ratio(1) == 123.4
+
+    with pytest.raises(ValueError):
+        cube.get_measurement_ratio(123)
+
+
+def test_get_measurement_voltage(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.MeasurementsScaledInput.input_1, 110_000, False)
+    assert cube.get_measurement_voltage(1) == 110_000.0
+
+    with pytest.raises(ValueError):
+        cube.get_measurement_voltage(123)
+
+
+def test_get_earthing_stick_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.EarthingStick.status_1, 1, False)
+    assert cube.get_earthing_stick_status(1) == constants.EarthingStickStatus(1)
+
+    with pytest.raises(ValueError):
+        cube.get_earthing_stick_status(123)
+
+
+def test_get_earthing_stick_operating_status(
+    cube: SupercubeBase, demo_opcua_server: DemoServer
+):
+    demo_opcua_server.add_var(
+        constants.EarthingStick.operating_status_1,
+        constants.EarthingStickOperatingStatus.auto,
+        False,
+    )
+    assert (
+        cube.get_earthing_stick_operating_status(1)
+        is constants.EarthingStickOperatingStatus.auto
+    )
+
+    with pytest.raises(ValueError):
+        cube.get_earthing_stick_operating_status(123)
+
+
+def test_get_earthing_stick_manual(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(
+        constants.EarthingStick.manual_1,
+        bool(constants.EarthingStickOperation.close),
+        False,
+    )
+    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.close
+
+    with pytest.raises(ValueError):
+        cube.get_earthing_stick_manual(123)
+
+
+def test_operate_earthing_stick(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(
+        constants.EarthingStick.operating_status_1,
+        constants.EarthingStickOperatingStatus.manual,
+        False,
+    )
+    demo_opcua_server.add_var(
+        constants.EarthingStick.manual_1,
+        bool(constants.EarthingStickOperation.open),
+        True,
+    )
+    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.open
+    cube.operate_earthing_stick(1, constants.EarthingStickOperation.close)
+    assert cube.get_earthing_stick_manual(1) is constants.EarthingStickOperation.close
+
+
+def test_operate_earthing_stick_error(
+    cube: SupercubeBase, demo_opcua_server: DemoServer,
+):
+    demo_opcua_server.add_var(
+        constants.EarthingStick.operating_status_1,
+        constants.EarthingStickOperatingStatus.auto,
+        False,
+    )
+    with pytest.raises(SupercubeEarthingStickOperationError):
+        cube.operate_earthing_stick(1, constants.EarthingStickOperation.close)
+
+
+def test_quit_error(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.Errors.quit, False, True)
+    cube.quit_error()
+    assert demo_opcua_server.get_var(constants.Errors.quit) is False
+
+
+def test_get_door_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.Door.status_1, 2, False)
+    assert cube.get_door_status(1) == constants.DoorStatus(2)
+
+
+def test_get_earthing_rod_status(cube: SupercubeBase, demo_opcua_server: DemoServer):
+    demo_opcua_server.add_var(constants.EarthingRod.status_1, 0, False)
+    assert cube.get_earthing_rod_status(1) == constants.EarthingRodStatus(0)
+
+
+def test_set_status_board(cube: SupercubeBase, demo_opcua_server: DemoServer):
+
+    n_max = len(constants.MessageBoard)
+
+    with pytest.raises(ValueError):
+        cube.set_status_board(["x"] * (n_max + 1))
+    with pytest.raises(ValueError):
+        cube.set_status_board(["x"], pos=[n_max])
+
+    for line in constants.MessageBoard:
+        demo_opcua_server.add_var(line, "", True)
+
+    msgs = ["Hello World", "Hello Fabian", "Hello HVL"]
+
+    cube.set_status_board(msgs[:1])
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)) == msgs[0]
+    cube.set_status_board(msgs[:1], pos=[1], clear_board=False)
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)) == msgs[0]
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(2)) == msgs[0]
+
+    positions = [4, 8, 12]
+    cube.set_status_board(msgs, positions, clear_board=False)
+    for i, p in enumerate(positions):
+        assert demo_opcua_server.get_var(constants.MessageBoard.line(p+1)) == msgs[i]
+
+    cube.set_status_board([str(i) for i in range(15)])
+    for i in range(15):
+        assert demo_opcua_server.get_var(constants.MessageBoard.line(i+1)) == str(i)
+
+
+def test_set_message_board(cube: SupercubeBase, demo_opcua_server: DemoServer):
+
+    n_max = len(constants.MessageBoard)
+
+    with pytest.raises(ValueError):
+        cube.set_message_board(["x"] * (n_max + 1))
+
+    for line in constants.MessageBoard:
+        demo_opcua_server.add_var(line, "", True)
+
+    msgs = ["ERROR: This is unexpected", "Good choice"]
+    cube.set_message_board(msgs[:1])
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)).endswith(msgs[0])
+
+    # push two messages to first two lines, in the given order
+    cube.set_message_board(msgs)
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(1)).endswith(msgs[0])
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(2)).endswith(msgs[1])
+    assert demo_opcua_server.get_var(constants.MessageBoard.line(3)).endswith(msgs[0])
+
+    # overwrite all messages except last, which is pushed to be last line
+    cube.set_message_board("x" * (n_max - 1))
+    for n in range(len(constants.MessageBoard)-1):
+        assert demo_opcua_server.get_var(constants.MessageBoard.line(n+1)).endswith("x")
+    last_msg = demo_opcua_server.get_var(constants.MessageBoard.line(n_max))
+    assert last_msg.endswith(msgs[0])
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_supercube_a.py` & `hvl_ccb-0.9.0/tests/test_dev_supercube_a.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,112 +1,112 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Test module for the Supercube Variant A class.
-"""
-
-import pytest
-
-from hvl_ccb.dev.supercube import SupercubeWithFU, constants
-from opctools import DemoServer
-
-
-@pytest.fixture(scope='module')
-def dev_config():
-    return {
-        'namespace_index': 3,
-    }
-
-
-@pytest.fixture(scope='module')
-def com_config():
-    return {
-        'host': 'localhost',
-        'port': 14124,
-        'endpoint_name': ''
-    }
-
-
-@pytest.fixture(scope='module')
-def demo_server(dev_config):
-    opcua_server = DemoServer(dev_config['namespace_index'], 'B', 14124)
-    opcua_server.start()
-
-    # add socket nodes
-    for socket in constants.GeneralSockets:
-        opcua_server.add_var(socket, False, True)
-
-    # add support input and output nodes
-    for support in constants.GeneralSupport:
-        opcua_server.add_var(support, False, True)
-
-    opcua_server.add_var(constants.OpcControl.active, False, True)
-
-    yield opcua_server
-
-    opcua_server.stop()
-
-
-@pytest.fixture(scope='module')
-def cube(com_config, dev_config, demo_server):
-    cube = SupercubeWithFU(com_config, dev_config)
-    cube.start()
-    yield cube
-    cube.stop()
-
-
-def test_instantiation(com_config):
-    cube = SupercubeWithFU(com_config)
-    assert cube is not None
-
-
-def test_set_target_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.voltage_target, 0.0, True)
-    cube.set_target_voltage(20)
-    assert demo_server.get_var(constants.Power.voltage_target) == 20.0
-
-
-def test_get_target_voltage(cube: SupercubeWithFU):
-    cube.set_target_voltage(23.2e3)
-    assert cube.get_target_voltage() == 23.2e3
-
-
-def test_get_max_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.voltage_max, 80, False)
-    assert cube.get_max_voltage() == 80.0
-
-
-def test_set_slope(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.voltage_slope, 1.5, True)
-    cube.set_slope(5.5)
-    assert demo_server.get_var(constants.Power.voltage_slope) == 5.5
-
-
-def test_get_primary_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.voltage_primary, 23.2, False)
-    assert cube.get_primary_voltage() == 23.2
-
-
-def test_get_primary_current(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.current_primary, 1.2, False)
-    assert cube.get_primary_current() == 1.2
-
-
-def test_get_frequency(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.frequency, 50, False)
-    assert cube.get_frequency() == 50.0
-
-
-def test_get_power_setup(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.Power.setup, 1, False)
-    assert cube.get_power_setup() == constants.PowerSetup(1)
-
-
-def test_get_fso_active(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.BreakdownDetection.activated, True, False)
-    assert cube.get_fso_active() is True
-
-
-def test_fso_reset(cube: SupercubeWithFU, demo_server: DemoServer):
-    demo_server.add_var(constants.BreakdownDetection.reset, False, True)
-    cube.fso_reset()
-    assert demo_server.get_var(constants.BreakdownDetection.reset) is False
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Test module for the Supercube Variant A class.
+"""
+
+import pytest
+
+from hvl_ccb.dev.supercube import SupercubeWithFU, constants
+from opctools import DemoServer
+
+
+@pytest.fixture(scope='module')
+def dev_config():
+    return {
+        'namespace_index': 3,
+    }
+
+
+@pytest.fixture(scope='module')
+def com_config():
+    return {
+        'host': 'localhost',
+        'port': 14124,
+        'endpoint_name': ''
+    }
+
+
+@pytest.fixture(scope='module')
+def demo_server(dev_config):
+    opcua_server = DemoServer(dev_config['namespace_index'], 'B', 14124)
+    opcua_server.start()
+
+    # add socket nodes
+    for socket in constants.GeneralSockets:
+        opcua_server.add_var(socket, False, True)
+
+    # add support input and output nodes
+    for support in constants.GeneralSupport:
+        opcua_server.add_var(support, False, True)
+
+    opcua_server.add_var(constants.OpcControl.active, False, True)
+
+    yield opcua_server
+
+    opcua_server.stop()
+
+
+@pytest.fixture(scope='module')
+def cube(com_config, dev_config, demo_server):
+    cube = SupercubeWithFU(com_config, dev_config)
+    cube.start()
+    yield cube
+    cube.stop()
+
+
+def test_instantiation(com_config):
+    cube = SupercubeWithFU(com_config)
+    assert cube is not None
+
+
+def test_set_target_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.voltage_target, 0.0, True)
+    cube.set_target_voltage(20)
+    assert demo_server.get_var(constants.Power.voltage_target) == 20.0
+
+
+def test_get_target_voltage(cube: SupercubeWithFU):
+    cube.set_target_voltage(23.2e3)
+    assert cube.get_target_voltage() == 23.2e3
+
+
+def test_get_max_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.voltage_max, 80, False)
+    assert cube.get_max_voltage() == 80.0
+
+
+def test_set_slope(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.voltage_slope, 1.5, True)
+    cube.set_slope(5.5)
+    assert demo_server.get_var(constants.Power.voltage_slope) == 5.5
+
+
+def test_get_primary_voltage(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.voltage_primary, 23.2, False)
+    assert cube.get_primary_voltage() == 23.2
+
+
+def test_get_primary_current(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.current_primary, 1.2, False)
+    assert cube.get_primary_current() == 1.2
+
+
+def test_get_frequency(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.frequency, 50, False)
+    assert cube.get_frequency() == 50.0
+
+
+def test_get_power_setup(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.Power.setup, 1, False)
+    assert cube.get_power_setup() == constants.PowerSetup(1)
+
+
+def test_get_fso_active(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.BreakdownDetection.activated, True, False)
+    assert cube.get_fso_active() is True
+
+
+def test_fso_reset(cube: SupercubeWithFU, demo_server: DemoServer):
+    demo_server.add_var(constants.BreakdownDetection.reset, False, True)
+    cube.fso_reset()
+    assert demo_server.get_var(constants.BreakdownDetection.reset) is False
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_supercube_constants.py` & `hvl_ccb-0.9.0/tests/test_dev_supercube_constants.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,83 +1,83 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Test module for the supercube constants enums.
-"""
-
-import pytest
-
-from hvl_ccb.dev.supercube import constants
-
-
-def test_support_output():
-    assert constants.GeneralSupport.output(1, 1) == constants.GeneralSupport.out_1_1
-    assert constants.GeneralSupport.output(5, 2) == constants.GeneralSupport.out_5_2
-    with pytest.raises(ValueError):
-        constants.GeneralSupport.output(3, 3)
-
-
-def test_support_input():
-    assert constants.GeneralSupport.input(1, 1) == constants.GeneralSupport.in_1_1
-    assert constants.GeneralSupport.input(5, 2) == constants.GeneralSupport.in_5_2
-    with pytest.raises(ValueError):
-        constants.GeneralSupport.input(3, 3)
-
-
-def test_measurements_scaled_input():
-    assert (constants.MeasurementsScaledInput.input(1) ==
-            constants.MeasurementsScaledInput.input_1)
-    assert (constants.MeasurementsScaledInput.input(3) ==
-            constants.MeasurementsScaledInput.input_3)
-    for n in (0, 5):
-        with pytest.raises(ValueError):
-            constants.MeasurementsScaledInput.input(n)
-
-
-def test_measurements_divider_ratio():
-    assert (constants.MeasurementsDividerRatio.input(1) ==
-            constants.MeasurementsDividerRatio.input_1)
-    assert (constants.MeasurementsDividerRatio.input(3) ==
-            constants.MeasurementsDividerRatio.input_3)
-    for n in (0, 5):
-        with pytest.raises(ValueError):
-            constants.MeasurementsDividerRatio.input(n)
-
-
-def test_earthing_stick_status():
-    assert (constants.EarthingStick.status(3) ==
-            constants.EarthingStick.status_3)
-    with pytest.raises(AttributeError):
-        constants.MeasurementsDividerRatio.status(7)
-
-
-def test_earthing_stick_manual():
-    assert (constants.EarthingStick.manual(2) ==
-            constants.EarthingStick.manual_2)
-    with pytest.raises(ValueError):
-        constants.EarthingStick.manual(7)
-
-
-def test_alarms():
-    assert constants.Alarms.Alarm(33) == constants.Alarms.Alarm33
-    for n in (0, 152):
-        with pytest.raises(ValueError):
-            constants.Alarms.Alarm(n)
-
-
-def test_door():
-    assert constants.Door.status(3) == constants.Door.status_3
-    for n in (0, 4):
-        with pytest.raises(ValueError):
-            constants.Door.status(n)
-
-
-def test_alarm_text():
-    assert constants.AlarmText.get(1) == constants.AlarmText.Alarm1
-    assert constants.AlarmText.get(1000) == constants.AlarmText.not_defined
-
-
-def test_message_board():
-    assert constants.MessageBoard.line(3) == constants.MessageBoard.line_3
-    for n in (0, 16):
-        with pytest.raises(ValueError):
-            constants.MessageBoard.line(n)
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Test module for the supercube constants enums.
+"""
+
+import pytest
+
+from hvl_ccb.dev.supercube import constants
+
+
+def test_support_output():
+    assert constants.GeneralSupport.output(1, 1) == constants.GeneralSupport.out_1_1
+    assert constants.GeneralSupport.output(5, 2) == constants.GeneralSupport.out_5_2
+    with pytest.raises(ValueError):
+        constants.GeneralSupport.output(3, 3)
+
+
+def test_support_input():
+    assert constants.GeneralSupport.input(1, 1) == constants.GeneralSupport.in_1_1
+    assert constants.GeneralSupport.input(5, 2) == constants.GeneralSupport.in_5_2
+    with pytest.raises(ValueError):
+        constants.GeneralSupport.input(3, 3)
+
+
+def test_measurements_scaled_input():
+    assert (constants.MeasurementsScaledInput.input(1) ==
+            constants.MeasurementsScaledInput.input_1)
+    assert (constants.MeasurementsScaledInput.input(3) ==
+            constants.MeasurementsScaledInput.input_3)
+    for n in (0, 5):
+        with pytest.raises(ValueError):
+            constants.MeasurementsScaledInput.input(n)
+
+
+def test_measurements_divider_ratio():
+    assert (constants.MeasurementsDividerRatio.input(1) ==
+            constants.MeasurementsDividerRatio.input_1)
+    assert (constants.MeasurementsDividerRatio.input(3) ==
+            constants.MeasurementsDividerRatio.input_3)
+    for n in (0, 5):
+        with pytest.raises(ValueError):
+            constants.MeasurementsDividerRatio.input(n)
+
+
+def test_earthing_stick_status():
+    assert (constants.EarthingStick.status(3) ==
+            constants.EarthingStick.status_3)
+    with pytest.raises(AttributeError):
+        constants.MeasurementsDividerRatio.status(7)
+
+
+def test_earthing_stick_manual():
+    assert (constants.EarthingStick.manual(2) ==
+            constants.EarthingStick.manual_2)
+    with pytest.raises(ValueError):
+        constants.EarthingStick.manual(7)
+
+
+def test_alarms():
+    assert constants.Alarms.Alarm(33) == constants.Alarms.Alarm33
+    for n in (0, 152):
+        with pytest.raises(ValueError):
+            constants.Alarms.Alarm(n)
+
+
+def test_door():
+    assert constants.Door.status(3) == constants.Door.status_3
+    for n in (0, 4):
+        with pytest.raises(ValueError):
+            constants.Door.status(n)
+
+
+def test_alarm_text():
+    assert constants.AlarmText.get(1) == constants.AlarmText.Alarm1
+    assert constants.AlarmText.get(1000) == constants.AlarmText.not_defined
+
+
+def test_message_board():
+    assert constants.MessageBoard.line(3) == constants.MessageBoard.line_3
+    for n in (0, 16):
+        with pytest.raises(ValueError):
+            constants.MessageBoard.line(n)
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_technix.py` & `hvl_ccb-0.9.0/tests/test_dev_technix.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,280 +1,301 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for .dev sub-package technix
-"""
-import logging
-from time import sleep
-
-import pytest
-
-from hvl_ccb.dev import (
-    TechnixTelnetCommunication,
-    Technix,
-    TechnixError,
-    TechnixSerialCommunication,
-)
-from hvl_ccb.dev.technix import TechnixSerialCommunicationConfig
-from masked_comm import LocalTechnixServer
-from masked_comm.serial import TechnixLoopSerialCommunication
-from masked_comm.uitls import get_free_tcp_port
-
-logging.basicConfig(level=logging.DEBUG)
-
-
-@pytest.fixture(scope="function")
-def com_telnet():
-    host = "127.0.0.1"
-    return {
-        "host": host,
-        "port": get_free_tcp_port(host),
-        "timeout": 0.01,
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 2,
-    }
-
-
-@pytest.fixture(scope="module")
-def com_serial():
-    return {
-        "port": "loop://?logging=debug",
-        "baudrate": 9600,
-        "parity": TechnixSerialCommunicationConfig.Parity.NONE,
-        "stopbits": TechnixSerialCommunicationConfig.Stopbits.ONE,
-        "bytesize": TechnixSerialCommunicationConfig.Bytesize.EIGHTBITS,
-        "timeout": 0.01,
-        "wait_sec_read_text_nonempty": 0.01,
-        "default_n_attempts_read_text_nonempty": 2,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config_telnet():
-    return {
-        "max_voltage": 10000,
-        "max_current": 1.5,
-        "communication_channel": TechnixTelnetCommunication,
-        "post_stop_pause_sec": 0.01,
-        "register_pulse_time": 0.01,
-    }
-
-
-@pytest.fixture(scope="module")
-def dev_config_serial():
-    return {
-        "max_voltage": 10000,
-        "max_current": 1.5,
-        "communication_channel": TechnixSerialCommunication,
-        "post_stop_pause_sec": 0.01,
-        "register_pulse_time": 0.01,
-    }
-
-
-def start_technix_telnet(com, dev_config):
-    # Start server and listen
-    ts = LocalTechnixServer(port=com["port"], timeout=com["timeout"])
-    # Connect with the client to the server
-    tex = Technix(com, dev_config)
-    # Open/accept the connection from the client to the server
-    ts.open()
-
-    return ts, tex
-
-
-def full_start_devices(com, dev_config):
-    ts, tex = start_technix_telnet(com, dev_config)
-    tex.start()
-    return ts, tex
-
-
-def test_devices(com_telnet, dev_config_telnet):
-    ts, tex = start_technix_telnet(com_telnet, dev_config_telnet)
-    assert ts is not None
-    assert tex.__class__ is Technix
-    tex.stop()
-    ts.close()
-
-
-def test_watchdog(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-    sleep(5)
-
-    tex.stop()
-    ts.close()
-
-
-def test_status_byte(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    # Wrong status byte
-    with pytest.raises(TechnixError):
-        ts.status = 1000
-        tex.get_status_byte()
-
-    ts.status = 1
-    assert tex.get_status_byte().__repr__() == "StatusByte: 00000001"
-    assert tex.get_status_byte().msb_first(0) is None
-
-    tex.stop()
-    ts.close()
-
-
-def test_no_properties(com_telnet, dev_config_telnet):
-    ts, tex = start_technix_telnet(com_telnet, dev_config_telnet)
-
-    assert tex.voltage_regulation is None
-    assert tex.hv is None
-    assert tex.remote is None
-    assert tex.inhibit is None
-
-    tex.stop()
-    ts.close()
-
-
-def test_properties(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    ts.status = 0
-    tex.get_status_byte()
-    assert not tex.voltage_regulation
-    assert not tex.hv
-    assert tex.remote
-    assert tex.inhibit
-
-    ts.status = (1 << 0) + (1 << 3) + (1 << 6) + (1 << 7)
-    tex.get_status_byte()
-    assert tex.voltage_regulation
-    assert tex.hv
-    assert not tex.remote
-    assert not tex.inhibit
-
-    tex.stop()
-    ts.close()
-
-
-def test_voltage_current(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    assert tex.max_voltage == 10000
-    assert tex.max_current == 1.5
-
-    ts.custom_answer = "d1,102"
-    tex.voltage = 250
-    assert ts.last_request == "d1,102"
-
-    ts.custom_answer = "d2,2730"
-    tex.current = 1
-    assert ts.last_request == "d2,2730"
-
-    ts.custom_answer = "a12048"
-    assert int(tex.voltage) == 5001
-    assert ts.last_request == "a1"
-
-    ts.custom_answer = "a23000"
-    assert int(tex.current * 1000) == 1098
-    assert ts.last_request == "a2"
-
-    with pytest.raises(TechnixError):
-        tex.voltage = 1e6
-    with pytest.raises(TechnixError):
-        tex.current = 1e6
-
-    tex.stop()
-    ts.close()
-
-
-def test_hv_remote(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    with pytest.raises(TechnixError):
-        tex.hv = 100
-    tex.hv = 1
-    tex.hv = True
-    tex.hv = 0
-    tex.hv = False
-
-    with pytest.raises(TechnixError):
-        tex.remote = 100
-
-    with pytest.raises(TechnixError):
-        tex.inhibit = 100
-    tex.inhibit = True
-
-    tex.stop()
-    ts.close()
-
-
-def test_fault_detection(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    tex.get_status_byte()
-    assert tex._real_status
-    with pytest.raises(TechnixError):
-        ts.status = 127
-        tex.get_status_byte()
-
-    ts.close()
-
-
-def test_no_or_wrong_reply(com_telnet, dev_config_telnet):
-    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
-
-    with pytest.raises(TechnixError):
-        ts.listen_and_repeat = []
-        tex.inhibit = 0
-
-    with pytest.raises(TechnixError):
-        ts.custom_answer = "P7,1"
-        ts.listen_and_repeat = []
-        tex.inhibit = 0
-
-    with pytest.raises(TechnixError):
-        ts.custom_answer = "d1,1234"
-        assert tex.current == 666
-
-    ts.close()
-
-
-def start_serial_devices(com_serial, dev_config_serial):
-    com = TechnixLoopSerialCommunication(com_serial)
-    com.open()
-
-    tex = Technix(com, dev_config_serial)
-
-    com.put_text("P7,0")
-    com.put_text("P6,1")
-    com.put_text("P6,0")
-    com.put_text("E0")  # status byte for the polling thread
-    tex.start()
-    assert com.get_written() == "P7,0"
-    assert com.get_written() == "P6,1"
-    assert com.get_written() == "P6,0"
-    sleep(0.1)  # time for the polling thread to start
-    assert com.get_written() == "E"
-    return com, tex
-
-
-def test_serial(com_serial, dev_config_serial):
-    com, tex = start_serial_devices(com_serial, dev_config_serial)
-
-    com.put_text("E0")
-    assert tex.get_status_byte().__repr__() == "StatusByte: 00000000"
-    assert tex._real_status
-    assert com.get_written() == "E"
-
-    com.put_text("P6,1")
-    com.put_text("P6,0")
-    com.put_text("P7,1")
-    tex.stop()
-    assert com.get_written() == "P6,1"
-    assert com.get_written() == "P6,0"
-    assert com.get_written() == "P7,1"
-
-    com.close()
-
-
-def test_serial_no_answer(com_serial, dev_config_serial):
-    com, tex = start_serial_devices(com_serial, dev_config_serial)
-
-    with pytest.raises(TechnixError):
-        assert tex.get_status_byte().__repr__() == "StatusByte: 00000000"
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for .dev sub-package technix
+"""
+import logging
+from time import sleep
+
+import pytest
+
+from hvl_ccb.dev.technix import (
+    Technix,
+    TechnixError,
+    TechnixTelnetCommunication,
+    TechnixSerialCommunication,
+    TechnixSerialCommunicationConfig,
+)
+from hvl_ccb.dev.technix.base import _Status, _GetRegisters
+from masked_comm import LocalTechnixServer
+from masked_comm.serial import TechnixLoopSerialCommunication
+from masked_comm.uitls import get_free_tcp_port
+
+logging.basicConfig(level=logging.DEBUG)
+
+
+@pytest.fixture(scope="function")
+def com_telnet():
+    host = "127.0.0.1"
+    return {
+        "host": host,
+        "port": get_free_tcp_port(host),
+        "timeout": 0.01,
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 2,
+    }
+
+
+@pytest.fixture(scope="module")
+def com_serial():
+    return {
+        "port": "loop://?logging=debug",
+        "baudrate": 9600,
+        "parity": TechnixSerialCommunicationConfig.Parity.NONE,
+        "stopbits": TechnixSerialCommunicationConfig.Stopbits.ONE,
+        "bytesize": TechnixSerialCommunicationConfig.Bytesize.EIGHTBITS,
+        "timeout": 0.01,
+        "wait_sec_read_text_nonempty": 0.01,
+        "default_n_attempts_read_text_nonempty": 2,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config_telnet():
+    return {
+        "max_voltage": 10000,
+        "max_current": 1.5,
+        "communication_channel": TechnixTelnetCommunication,
+        "post_stop_pause_sec": 0.01,
+        "register_pulse_time": 0.01,
+        "polling_interval_sec": 1,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config_telnet_voltage_measurement():
+    return {
+        "max_voltage": 10000,
+        "max_current": 1.5,
+        "communication_channel": TechnixTelnetCommunication,
+        "post_stop_pause_sec": 0.01,
+        "register_pulse_time": 0.01,
+        "read_output_while_polling": True,
+    }
+
+
+@pytest.fixture(scope="module")
+def dev_config_serial():
+    return {
+        "max_voltage": 10000,
+        "max_current": 1.5,
+        "communication_channel": TechnixSerialCommunication,
+        "post_stop_pause_sec": 0.01,
+        "register_pulse_time": 0.01,
+    }
+
+
+def start_technix_telnet(com, dev_config):
+    # Start server and listen
+    ts = LocalTechnixServer(port=com["port"], timeout=com["timeout"])
+    # Connect with the client to the server
+    tex = Technix(com, dev_config)
+    # Open/accept the connection from the client to the server
+    ts.open()
+
+    return ts, tex
+
+
+def full_start_devices(com, dev_config):
+    ts, tex = start_technix_telnet(com, dev_config)
+    tex.start()
+    return ts, tex
+
+
+def test_devices(com_telnet, dev_config_telnet):
+    ts, tex = start_technix_telnet(com_telnet, dev_config_telnet)
+    assert ts is not None
+    assert tex.__class__ is Technix
+
+    assert not tex.is_started
+    tex.start()
+    tex.query_status()
+    tex.start()
+
+    assert tex.is_started
+
+    tex.stop()
+    tex.stop()
+    ts.close()
+
+
+def test_no_properties(com_telnet, dev_config_telnet):
+    """Device is not fully started, statuses are None"""
+    ts, tex = start_technix_telnet(com_telnet, dev_config_telnet)
+
+    assert tex.voltage_regulation is None
+    assert tex.output is None
+    assert tex.remote is None
+    assert tex.inhibit is None
+    assert tex.open_interlock is None
+
+    assert tex.voltage is None
+    assert tex.current is None
+
+    tex.stop()
+    ts.close()
+
+
+def test_wrong_command(com_telnet, dev_config_telnet):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
+
+    listen_and_repeat = ts.listen_and_repeat
+
+    with pytest.raises(TechnixError):
+        tex.com.query("no_register")
+    with pytest.raises(TechnixError):
+        ts.custom_answer = "P7,1"
+        ts.listen_and_repeat = []
+        tex.inhibit = True
+    with pytest.raises(TechnixError):
+        ts.custom_answer = "P7,1"
+        ts.listen_and_repeat = []
+        tex._get_register(_GetRegisters.VOLTAGE)
+
+    ts.listen_and_repeat = listen_and_repeat
+
+    tex.stop()
+    ts.close()
+
+
+def test_watchdog(com_telnet, dev_config_telnet):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
+    sleep(2)
+    assert tex.is_started
+
+    ts.status = 0b010
+    sleep(2)
+    assert not tex._status_poller.is_polling()
+    assert not tex.is_started
+
+    tex.stop()
+    ts.close()
+
+
+def test_status(com_telnet, dev_config_telnet):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
+
+    # Wrong status byte
+    with pytest.raises(ValueError):
+        ts.status = 1000
+        tex.query_status()
+
+    # Correct status
+    value = 38
+    assert value == 0b00100110
+    ts.status = value
+    tex.query_status()
+    assert tex.status == _Status(False, not False, True, False, False, True,
+                                 True, False, None, None)
+    assert tex.inhibit is False
+    assert tex.remote is True
+    assert tex.output is False
+    assert tex.open_interlock is True
+    assert tex.voltage_regulation is False
+
+    # Status fault and closed interlock
+    with pytest.raises(TechnixError):
+        ts.status = 0b010
+        tex.query_status()
+
+    tex.stop()
+    ts.close()
+
+
+def test_voltage_current(com_telnet, dev_config_telnet):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
+
+    tex.query_status()
+
+    assert tex.max_voltage == 10000
+    assert tex.max_current == 1.5
+
+    ts.custom_answer = "d1,102"
+    tex.voltage = 250
+    assert ts.last_request == "d1,102"
+
+    ts.custom_answer = "d2,2730"
+    tex.current = 1
+    assert ts.last_request == "d2,2730"
+
+    ts.custom_answer = "a12048"
+    assert int(tex.voltage) == 5001
+    assert ts.last_request == "a1"
+
+    ts.custom_answer = "a23000"
+    assert int(tex.current * 1000) == 1098
+    assert ts.last_request == "a2"
+
+    with pytest.raises(ValueError):
+        tex.voltage = 1e6
+    with pytest.raises(ValueError):
+        tex.current = 1e6
+
+    tex.stop()
+    ts.close()
+
+
+def test_voltage_current_with_status(com_telnet, dev_config_telnet_voltage_measurement):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet_voltage_measurement)
+    ts.voltage = 819
+    ts.current = 2730
+
+    tex.query_status()
+    assert tex.voltage == 2000
+    assert tex.current == 1
+
+    tex.stop()
+    ts.close()
+
+
+def test_hv_remote_inhibit(com_telnet, dev_config_telnet):
+    ts, tex = full_start_devices(com_telnet, dev_config_telnet)
+
+    tex.output = True
+    tex.output = False
+    tex.remote = True
+    tex.remote = False
+    tex.inhibit = True
+    tex.inhibit = False
+
+    with pytest.raises(TypeError):
+        tex.output = 100
+        tex.remote = 1
+        tex.inhibit = "ON"
+
+    tex.stop()
+    ts.close()
+
+
+def start_serial_devices(com_serial, dev_config_serial):
+    com = TechnixLoopSerialCommunication(com_serial)
+    com.open()
+
+    tex = Technix(com, dev_config_serial)
+
+    com.put_text("P7,0")
+    com.put_text("P6,1")
+    com.put_text("P6,0")
+    com.put_text("P8,0")
+    com.put_text("E0")  # status byte for the polling thread
+    tex.start()
+    assert com.get_written() == "P7,0"
+    assert com.get_written() == "P6,1"
+    assert com.get_written() == "P6,0"
+    assert com.get_written() == "P8,0"
+    sleep(0.1)  # time for the polling thread to start
+    assert com.get_written() == "E"
+    return com, tex
+
+
+def test_serial(com_serial, dev_config_serial):
+    com, tex = start_serial_devices(com_serial, dev_config_serial)
+
+    com.put_text("P6,1")
+    com.put_text("P6,0")
+    com.put_text("P7,1")
+    tex.stop()
+    assert com.get_written() == "P6,1"
+    assert com.get_written() == "P6,0"
+    assert com.get_written() == "P7,1"
+
+    com.close()
```

### Comparing `hvl_ccb-0.8.5/tests/test_dev_tiepie.py` & `hvl_ccb-0.9.0/tests/test_dev_tiepie.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,841 +1,841 @@
-#  Copyright (c) 2020-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for TiePie
-"""
-
-import sys
-
-import libtiepie as ltp
-import numpy as np
-import pytest
-from libtiepie.exceptions import LibTiePieException, InvalidDeviceSerialNumberError
-from pytest_mock import MockerFixture
-
-from hvl_ccb.dev import (
-    TiePieError,
-    TiePieDeviceType,
-    TiePieOscilloscope,
-    TiePieWS5,
-    TiePieHS6,
-    TiePieHS5,
-    TiePieOscilloscopeResolution,
-    TiePieOscilloscopeChannelCoupling,
-    TiePieOscilloscopeTriggerKind,
-    TiePieOscilloscopeRange,
-    TiePieOscilloscopeTriggerLevelMode,
-    TiePieGeneratorSignalType,
-    TiePieOscilloscopeAutoResolutionModes,
-    TiePieDeviceConfig,
-    TiePieI2CHostMixin,
-    TiePieGeneratorMixin,
-    get_device_by_serial_number,
-    _verify_via_libtiepie,
-)
-from mock_libtiepie.const import (
-    MOCK_I2CHOST_SERIAL_NUMBER,
-    MOCK_GENERATOR_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
-    MOCK_DEVICE_SERIAL_NUMBER,
-)
-
-"""
-Mocking libtiepie
-"""
-from mock_libtiepie import oscilloscope as _oscilloscope  # noqa: E402
-from mock_libtiepie import generator as _generator  # noqa: E402
-from mock_libtiepie import i2chost as _i2chost  # noqa: E402
-from mock_libtiepie.devicelist import device_list as _device_list  # noqa: E402
-
-libtiepie = sys.modules["libtiepie"]
-
-libtiepie.device_list = _device_list
-libtiepie.oscilloscope = _oscilloscope
-libtiepie.generator = _generator
-libtiepie.i2chost = _i2chost
-
-sys.modules["libtiepie"] = libtiepie
-
-
-@pytest.fixture(scope="module")
-def com_config():
-    return {}
-
-
-@pytest.fixture(scope="module")
-def dev_config():
-    return {
-        "serial_number": MOCK_DEVICE_SERIAL_NUMBER,
-        "n_max_try_get_device": 2,
-        "wait_sec_retry_get_device": 0.01,
-    }
-
-
-def test_instantiation(com_config, dev_config):
-    dev_hs6 = TiePieHS6(com_config, dev_config)
-    assert dev_hs6 is not None
-    dev_hs5 = TiePieHS5(com_config, dev_config)
-    assert dev_hs5 is not None
-    dev_ws5 = TiePieWS5(com_config, dev_config)
-    assert dev_ws5 is not None
-
-
-def test_wrap_libtiepie_exception(com_config, dev_config, mocker: MockerFixture):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    def raise_libtiepie_exception():
-        raise LibTiePieException(0, "mock")
-
-    mocker.patch(
-        "libtiepie.device_list.update",
-        side_effect=raise_libtiepie_exception,
-        autospec=True,
-    )
-
-    with pytest.raises(TiePieError):
-        dev_osc.list_devices()
-
-    with pytest.raises(TiePieError):
-        get_device_by_serial_number(
-            dev_osc.config.serial_number, TiePieDeviceType.OSCILLOSCOPE
-        )
-
-    with pytest.raises(TiePieError):
-        dev_osc.start()
-
-
-def test_list_devices(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    list_devices = dev_osc.list_devices()
-    assert list_devices is not None
-
-
-def test_list_devices_none_available(com_config, dev_config, mocker: MockerFixture):
-    # simulate absence of devices
-    mock_devices = mocker.patch.object(libtiepie.device_list, "mock_devices")
-    mock_devices.return_value = False
-
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    list_devices = dev_osc.list_devices()
-    assert not list_devices
-
-
-def test_get_device_by_serial_number():
-    dev_osc = get_device_by_serial_number(
-        MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-        TiePieDeviceType.OSCILLOSCOPE,
-    )
-    assert dev_osc is not None
-
-    dev_gen = get_device_by_serial_number(
-        MOCK_GENERATOR_SERIAL_NUMBER,
-        TiePieDeviceType.GENERATOR,
-    )
-    assert dev_gen is not None
-
-    dev_i2c = get_device_by_serial_number(
-        MOCK_I2CHOST_SERIAL_NUMBER,
-        TiePieDeviceType.I2C,
-    )
-    assert dev_i2c is not None
-
-
-@pytest.mark.parametrize(
-    "wrong_dev_config",
-    [
-        {"serial_number": -23},
-        {"n_max_try_get_device": 0},
-        {"wait_sec_retry_get_device": 0.0},
-        {"is_data_ready_polling_interval_sec": 0.0},
-    ],
-)
-def test_invalid_config_dict(dev_config, wrong_dev_config):
-    invalid_config = dict(dev_config)
-    invalid_config.update(wrong_dev_config)
-    with pytest.raises(ValueError):
-        TiePieDeviceConfig(**invalid_config)
-
-
-def test_get_device_by_serial_number_not_available(dev_config, mocker: MockerFixture):
-    # simulate absence of devices
-    mock_devices = mocker.patch.object(libtiepie.device_list, "mock_devices")
-    mock_devices.return_value = False
-
-    with pytest.raises(TiePieError):
-        get_device_by_serial_number(
-            MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-            TiePieDeviceType.OSCILLOSCOPE,
-            n_max_try_get_device=dev_config["n_max_try_get_device"],
-            wait_sec_retry_get_device=dev_config["wait_sec_retry_get_device"],
-        )
-
-
-def test_get_device_by_serial_number_wrong_device_type():
-    with pytest.raises(TiePieError):
-        get_device_by_serial_number(
-            MOCK_GENERATOR_SERIAL_NUMBER,
-            TiePieDeviceType.OSCILLOSCOPE,
-        )
-
-
-def test_get_device_by_serial_number_invalid_device_sn(
-    dev_config,
-    mocker: MockerFixture,
-):
-    # simulate invalid device serian number error
-    get_item_by_serial_number = mocker.patch.object(
-        libtiepie.device_list,
-        "get_item_by_serial_number",
-    )
-    get_item_by_serial_number.side_effect = InvalidDeviceSerialNumberError
-
-    with pytest.raises(TiePieError):
-        get_device_by_serial_number(
-            MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-            TiePieDeviceType.OSCILLOSCOPE,
-            n_max_try_get_device=dev_config["n_max_try_get_device"],
-            wait_sec_retry_get_device=dev_config["wait_sec_retry_get_device"],
-        )
-
-
-def test_block_measurement_support():
-    dev_osc = TiePieOscilloscope(
-        {},
-        {"serial_number": MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2},
-    )
-
-    with pytest.raises(TiePieError):
-        dev_osc.start()
-
-
-def test_channel_config_on_start_stop(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    assert not dev_osc.config_osc_channel_dict
-    # with pytest.raises(TiePieError):
-    #     dev_osc.n_channels
-
-    dev_osc.start()
-
-    n_channels = dev_osc.n_channels
-
-    for ch_nr in range(1, n_channels + 1):
-        assert ch_nr in dev_osc.config_osc_channel_dict
-        assert not dev_osc.config_osc_channel_dict[ch_nr].enabled
-
-    for wrong_ch_nr in (0, dev_osc.n_channels + 1):
-        with pytest.raises(KeyError):
-            dev_osc.config_osc_channel_dict[wrong_ch_nr]
-
-    dev_osc.stop()
-
-
-def test_channels_enabled(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    dev_osc.start()
-    for ch_config in dev_osc.config_osc_channel_dict.values():
-        ch_config.enabled = True
-    assert list(dev_osc.channels_enabled) == list(
-        dev_osc.config_osc_channel_dict.keys()
-    )
-    dev_osc.config_osc_channel_dict[1].enabled = False
-    dev_osc.stop()
-
-
-def test_n_channels(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    dev_osc.start()
-    assert dev_osc.n_channels == 3
-    dev_osc.stop()
-
-
-def test_dev_osc_not_running(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    with pytest.raises(TiePieError):
-        dev_osc.n_channels == 3
-
-    class TiePieGeneratorOscilloscope(TiePieGeneratorMixin, TiePieOscilloscope):
-        pass
-
-    dev_gen = TiePieGeneratorOscilloscope(com_config, dev_config)
-    with pytest.raises(TiePieError):
-        dev_gen.generator_start()
-
-    class TiePieI2CHostOscilloscope(TiePieI2CHostMixin, TiePieOscilloscope):
-        pass
-
-    dev_i2c = TiePieI2CHostOscilloscope(com_config, dev_config)
-
-    with pytest.raises(TiePieError):
-        dev_i2c._i2c_config_setup()  # ATM only priv method avail for testing
-
-
-def test_safe_ground_enabled(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
-        assert ch_config.safe_ground_enabled is False
-
-    for ch_nr in [1, 3]:
-        dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled = True
-    for ch_nr in [2]:
-        assert dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled is False
-
-    dev_osc.stop()
-
-
-def test_safe_ground_not_available(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
-        ch_config.channel.disable_safe_ground_option()
-
-    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
-        with pytest.raises(TiePieError):
-            dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled = True
-        with pytest.raises(TiePieError):
-            dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled
-
-    dev_osc.stop()
-
-
-def test_trigger_enabled(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
-        ch_config.trigger_enabled = False
-        assert ch_config.trigger_enabled is False
-
-    dev_osc.start()
-
-    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
-        assert ch_config.trigger_enabled is False
-
-    for ch_nr in [1, 3]:
-        dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled = True
-        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is True
-
-    for ch_nr in [2]:
-        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is False
-
-    for ch_nr in [3]:
-        dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled = False
-
-    for ch_nr in [1]:
-        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is True
-
-    for ch_nr in [2, 3]:
-        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is False
-
-    dev_osc.stop()
-
-
-def test_scope_config_set(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    assert dev_osc.config_osc is None
-
-    dev_osc.start()
-
-    config_osc = dev_osc.config_osc
-
-    # record length
-    record_length_value = 100
-    config_osc.record_length = record_length_value
-    assert config_osc.record_length == record_length_value
-
-    record_length_value = 1e6
-    config_osc.record_length = record_length_value
-    assert config_osc.record_length == record_length_value
-
-    # sample frequency
-    sample_frequency_value = 1e6
-    config_osc.sample_frequency = sample_frequency_value
-    assert config_osc.sample_frequency == sample_frequency_value
-
-    # pre-sample ratio
-    pre_sample_ratio_value = 0.2
-    config_osc.pre_sample_ratio = pre_sample_ratio_value
-    assert config_osc.pre_sample_ratio == pre_sample_ratio_value
-
-    # resolution
-    resolution = TiePieOscilloscopeResolution.FOURTEEN_BIT
-    config_osc.resolution = resolution
-    assert config_osc.resolution == resolution
-
-    # trigger timeout
-    trigger_timeouts = [0, 1, 1.5]
-    for trigger_timeout in trigger_timeouts:
-        config_osc.trigger_timeout = trigger_timeout
-        assert config_osc.trigger_timeout == trigger_timeout
-
-    trigger_timeouts = [None, -1, ltp.TO_INFINITY]
-    for trigger_timeout in trigger_timeouts:
-        config_osc.trigger_timeout = trigger_timeout
-        assert config_osc.trigger_timeout is None
-
-    # auto resolution mode
-    auto_resolution_mode = TiePieOscilloscopeAutoResolutionModes.DISABLED
-    config_osc.auto_resolution_mode = auto_resolution_mode
-    assert config_osc.auto_resolution_mode == auto_resolution_mode
-
-    dev_osc.stop()
-
-    assert dev_osc.config_osc is None
-
-
-def test_scope_config_set_invalid(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    config_osc = dev_osc.config_osc
-
-    # sample_frequency
-    with pytest.raises(ValueError):
-        config_osc.sample_frequency = -1
-    with pytest.raises(ValueError):
-        config_osc.sample_frequency = 1e14
-    with pytest.raises(TypeError):
-        config_osc.sample_frequency = "1"
-
-    # record_length
-    with pytest.raises(ValueError):
-        config_osc.record_length = -1
-    with pytest.raises(TypeError):
-        config_osc.record_length = "1"
-    with pytest.raises(ValueError):
-        config_osc.record_length = 1.5
-
-    # pre_sample_ratio
-    for v in (-0.1, 1.1):
-        with pytest.raises(ValueError):
-            config_osc.pre_sample_ratio = v
-    with pytest.raises(TypeError):
-        config_osc.pre_sample_ratio = "0.5"
-
-    # resolution
-    with pytest.raises(ValueError):
-        config_osc.resolution = 1
-    with pytest.raises(TypeError):
-        config_osc.resolution = "8"
-
-    # trigger_timeout
-    with pytest.raises(ValueError):
-        config_osc.trigger_timeout = -0.1
-    with pytest.raises(ValueError):
-        config_osc.trigger_timeout = -1.1
-    with pytest.raises(TypeError):
-        config_osc.trigger_timeout = "123"
-
-    # auto resolution mode
-    with pytest.raises(TypeError):
-        config_osc.auto_resolution_mode = False
-    with pytest.raises(TypeError):
-        config_osc.auto_resolution_mode = "Disabled"
-
-
-def test_channel_config_set(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    assert not dev_osc.config_osc_channel_dict
-
-    dev_osc.start()
-
-    assert dev_osc.config_osc_channel_dict
-
-    # Channel 2
-    ch2_config = dev_osc.config_osc_channel_dict[2]
-
-    # coupling
-    coupling_value = TiePieOscilloscopeChannelCoupling.ACV
-    ch2_config.coupling = coupling_value
-    assert ch2_config.coupling == coupling_value
-
-    ch2_config.coupling = "ACV"
-    assert ch2_config.coupling is TiePieOscilloscopeChannelCoupling.ACV
-
-    # enabled
-    enabled_value = True
-    ch2_config.enabled = enabled_value
-    assert ch2_config.enabled == enabled_value
-
-    # range
-    range_value = TiePieOscilloscopeRange.TWENTY_VOLT
-    ch2_config.input_range = range_value
-    assert ch2_config.input_range == range_value
-
-    for v, ir in (
-        (20, TiePieOscilloscopeRange.TWENTY_VOLT),
-        (21, TiePieOscilloscopeRange.FORTY_VOLT),
-        (79.9, TiePieOscilloscopeRange.EIGHTY_VOLT),
-    ):
-        ch2_config.input_range = v
-        assert ch2_config.input_range is ir
-
-    # probe offset
-    probe_offset_value = 1
-    ch2_config.probe_offset = probe_offset_value
-    assert ch2_config.probe_offset == probe_offset_value
-
-    # safe ground enabled
-    ch2_config.channel.enable_safe_ground_option()
-    safe_ground_enabled_value = True
-    ch2_config.safe_ground_enabled = safe_ground_enabled_value
-    assert ch2_config.safe_ground_enabled == safe_ground_enabled_value
-    ch2_config.safe_ground_enabled = False
-    assert ch2_config.safe_ground_enabled is False
-
-    # trigger level mode
-    trigger_level_mode_value = TiePieOscilloscopeTriggerLevelMode.ABSOLUTE
-    ch2_config.trigger_level_mode = trigger_level_mode_value
-    assert ch2_config.trigger_level_mode == trigger_level_mode_value
-
-    # trigger level
-    trigger_level_value = 0.5
-    ch2_config.trigger_level = trigger_level_value
-    assert ch2_config.trigger_level == trigger_level_value
-
-    trigger_level_value = 1
-    ch2_config.trigger_level = trigger_level_value
-    assert ch2_config.trigger_level == trigger_level_value
-
-    # trigger level mode
-    trigger_level_mode_value = TiePieOscilloscopeTriggerLevelMode.RELATIVE
-    ch2_config.trigger_level_mode = trigger_level_mode_value
-    assert ch2_config.trigger_level_mode == trigger_level_mode_value
-
-    # trigger level
-    trigger_level_value = 0.5
-    ch2_config.trigger_level = trigger_level_value
-    assert ch2_config.trigger_level == trigger_level_value
-
-    # trigger hysteresis
-    trigger_hysteresis_value = 0.05
-    ch2_config.trigger_hysteresis = trigger_hysteresis_value
-    assert ch2_config.trigger_hysteresis == trigger_hysteresis_value
-
-    # trigger kind
-    trigger_kind_value = TiePieOscilloscopeTriggerKind.RISING_OR_FALLING
-    ch2_config.trigger_kind = trigger_kind_value
-    assert ch2_config.trigger_kind == trigger_kind_value
-
-    ch2_config.trigger_kind = "FALLING"
-    assert ch2_config.trigger_kind is TiePieOscilloscopeTriggerKind.FALLING
-
-    # trigger enabled
-    trigger_enabled_value = True
-    ch2_config.trigger_enabled = trigger_enabled_value
-    assert ch2_config.trigger_enabled == trigger_enabled_value
-
-    dev_osc.stop()
-
-    assert not dev_osc.config_osc_channel_dict
-
-
-def test_channel_config_set_invalid(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    assert not dev_osc.config_osc_channel_dict
-
-    dev_osc.start()
-
-    # Channel 2
-    ch_config = dev_osc.config_osc_channel_dict[2]
-
-    # coupling
-    for v in ("dcv", 123):
-        with pytest.raises(ValueError):
-            ch_config.coupling = v
-
-    # enabled
-    for v in ("True", 1):
-        with pytest.raises(TypeError):
-            ch_config.enabled = v
-
-    # input_range
-    with pytest.raises(TypeError):
-        ch_config.input_range = "40"
-
-    with pytest.raises(ValueError):
-        ch_config.input_range = 234567
-
-    # probe_offset
-    for v in (-1e7, 1e7):
-        with pytest.raises(ValueError):
-            ch_config.probe_offset = v
-    with pytest.raises(TypeError):
-        ch_config.probe_offset = "1"
-
-    # safe_ground_enabled
-    for v in ("True", 1):
-        with pytest.raises(TypeError):
-            ch_config.safe_ground_enabled = v
-
-    # trigger_hysteresis
-    for v in (-0.1, 1.1):
-        with pytest.raises(ValueError):
-            ch_config.trigger_hysteresis = v
-    with pytest.raises(TypeError):
-        ch_config.trigger_hysteresis = "0.5"
-
-    # trigger_kind
-    for v in ("any", "Any", 123):
-        with pytest.raises(ValueError):
-            ch_config.trigger_kind = v
-
-    # trigger_enabled
-    for v in ("True", 1):
-        with pytest.raises(TypeError):
-            ch_config.trigger_enabled = v
-
-
-def test_trigger_check(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    assert dev_osc.is_triggered() is False
-    dev_osc.force_trigger()
-    dev_osc.config_osc.dev_osc.is_triggered = True
-    assert dev_osc.is_triggered() is True
-
-    dev_osc.stop()
-
-
-_record_length = 7
-_valid_pre_sample_count = 3
-_sample_frequency = 1000
-_pre_sample_ratio = 0.5
-
-
-def _test_measure_data(data, rec_lngth_reduced=0):
-    assert len(data) == _record_length - rec_lngth_reduced
-    for i, ch_data in enumerate(data.T):
-        _test_measure_data_ch(i + 1, ch_data, rec_lngth_reduced=rec_lngth_reduced)
-
-
-def _test_measure_data_ch(ch_nr, ch_data, rec_lngth_reduced=0):
-    assert len(ch_data) == _record_length - rec_lngth_reduced
-    for i in range(_record_length - rec_lngth_reduced):
-        if ch_nr == 1:  # Check time vector
-            assert ch_data[i] == (i - _valid_pre_sample_count) / _sample_frequency
-        else:
-            assert ch_data[i] == float(i)
-
-
-def _test_measure_and_collect(dev_osc, timeout, rec_lngth_reduced=0):
-    # Enable all channels for measurement
-    for ch in dev_osc.config_osc_channel_dict.values():
-        ch.enabled = True
-
-    dev_osc.config_osc.dev_osc.record_length = _record_length + 1
-    dev_osc.config_osc.dev_osc.valid_pre_sample_count = _valid_pre_sample_count
-    dev_osc.config_osc.dev_osc.sample_frequency = _sample_frequency
-    dev_osc.config_osc.dev_osc.pre_sample_ratio = _pre_sample_ratio
-
-    # Let the oscilloscope gather data
-    dev_osc.start_measurement()
-
-    if dev_osc.is_measurement_data_ready():
-        data = dev_osc.collect_measurement_data(timeout)
-
-    assert all(isinstance(x, np.ndarray) for x in data)
-
-    _test_measure_data(data, rec_lngth_reduced=rec_lngth_reduced)
-
-
-def test_measure_and_collect(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    timeout = 0  # Same as default option
-    _test_measure_and_collect(dev_osc, timeout)
-
-    timeout = 0.2
-    _test_measure_and_collect(dev_osc, timeout)
-
-    timeout = None
-    _test_measure_and_collect(dev_osc, timeout)
-
-    timeout = 0  # Same as default option, but truncated data
-    dev_osc.config_osc.dev_osc.mock_reduce_data = 1
-    _test_measure_and_collect(dev_osc, timeout, rec_lngth_reduced=1)
-
-    dev_osc.stop()
-
-
-def test_measure_and_collect_fail(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-
-    dev_osc.start()
-
-    # string as timeout
-    timeout = "a"
-    with pytest.raises(ValueError):
-        dev_osc.collect_measurement_data(timeout)
-
-    timeout = 0.2
-    dev_osc.config_osc.dev_osc.is_data_ready = False
-    assert dev_osc.collect_measurement_data(timeout) is None
-
-    dev_osc.config_osc = None
-    assert dev_osc.collect_measurement_data(timeout) is None
-    assert dev_osc._check_record_length(np.zeros(1)) is None
-
-    dev_osc.stop()
-
-
-def test_generator_config_set(com_config, dev_config):
-    dev_ws5 = TiePieWS5(com_config, dev_config)
-    assert dev_ws5 is not None
-
-    assert dev_ws5.config_gen is None
-
-    dev_ws5.start()
-
-    config_gen = dev_ws5.config_gen
-
-    # frequency
-    frequency_value = 1e6
-    config_gen.frequency = frequency_value
-    assert config_gen.frequency == frequency_value
-
-    # amplitude
-    amplitude_value = 2
-    config_gen.amplitude = amplitude_value
-    assert config_gen.amplitude == amplitude_value
-
-    # offset
-    offset_value = 1
-    config_gen.offset = offset_value
-    assert config_gen.offset == offset_value
-
-    # signal type
-    signal_type = TiePieGeneratorSignalType.SINE
-    config_gen.signal_type = signal_type
-    assert config_gen.signal_type == signal_type
-
-    # arbitrary waveform
-    t_axis = np.linspace(0, 100, 8192)  # Create signal array
-    waveform = np.sin(t_axis) * (1 - t_axis / 100)
-    config_gen.waveform = waveform
-    assert config_gen.waveform.all() == waveform.all()
-
-    # Create 2dim waveform
-    waveform = np.array([waveform, waveform])
-    with pytest.raises(ValueError):
-        config_gen.waveform = waveform
-
-    # Create signal array that is too large
-    t_axis = np.linspace(0, 100, 10_001)
-    waveform = np.sin(t_axis) * (1 - t_axis / 100)
-    with pytest.raises(ValueError):
-        config_gen.waveform = waveform
-
-    # enabled
-    enabled_value = True
-    config_gen.enabled = enabled_value
-    assert config_gen.enabled == enabled_value
-    config_gen.enabled = False
-    assert config_gen.enabled is False
-
-    dev_ws5.stop()
-
-    assert dev_ws5.config_gen is None
-
-
-def test_generator_config_set_invalid(com_config, dev_config):
-    dev_ws5 = TiePieWS5(com_config, dev_config)
-    assert dev_ws5 is not None
-
-    dev_ws5.start()
-
-    config_gen = dev_ws5.config_gen
-
-    # frequency
-    with pytest.raises(ValueError):
-        config_gen.frequency = -1
-    with pytest.raises(ValueError):
-        config_gen.frequency = 1e14
-    with pytest.raises(TypeError):
-        config_gen.frequency = "1"
-
-    # amplitude
-    with pytest.raises(ValueError):
-        config_gen.amplitude = -1
-    with pytest.raises(ValueError):
-        config_gen.amplitude = 100
-    with pytest.raises(TypeError):
-        config_gen.frequency = "1"
-
-    # offset
-    with pytest.raises(ValueError):
-        config_gen.offset = 100
-    with pytest.raises(TypeError):
-        config_gen.offset = "1"
-
-    # signal type
-    with pytest.raises(ValueError):
-        config_gen.signal_type = "sin"
-
-    # arbitrary waveform
-    with pytest.raises(ValueError):
-        config_gen.waveform = [1, 2, 3]
-
-    # enabled
-    for v in ("True", 1):
-        with pytest.raises(TypeError):
-            config_gen.enabled = v
-
-    dev_ws5.stop()
-
-
-def test_generate_signal(com_config, dev_config):
-    dev_ws5 = TiePieWS5(com_config, dev_config)
-    assert dev_ws5 is not None
-
-    dev_ws5.start()
-
-    dev_ws5.generator_start()
-    dev_ws5.generator_stop()
-
-    dev_ws5.stop()
-
-
-def test_verify_via_libtiepie():
-    dev_osc = get_device_by_serial_number(
-        MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
-        TiePieDeviceType.OSCILLOSCOPE,
-    )
-    assert dev_osc is not None
-    assert _verify_via_libtiepie(dev_osc, "sample_frequency", 1e6) == 1e6
-    assert _verify_via_libtiepie(dev_osc, "record_length", 10) == 10
-
-
-def test_config_print_values(com_config, dev_config):
-    dev_osc = TiePieOscilloscope(com_config, dev_config)
-    dev_osc.start()
-    config_osc = dev_osc.config_osc
-    config_osc.record_length = 100
-    assert f"record_length={config_osc.record_length!r}" in str(config_osc)
-
-    ch_config = dev_osc.config_osc_channel_dict[1]
-    assert f"enabled={ch_config.enabled!r}" in str(ch_config)
-    ch_config.enabled = not ch_config.enabled
-    assert f"enabled={ch_config.enabled!r}" in str(ch_config)
-
-    dev_ws5 = TiePieWS5(com_config, dev_config)
-    dev_ws5.start()
-    config_gen = dev_ws5.config_gen
-    config_gen.amplitude = 12
-    assert f"amplitude={config_gen.amplitude!r}" in str(config_gen)
-
-    config_i2c = dev_ws5.config_i2c
-    assert "()" in str(config_i2c)  # no config properties yet
+#  Copyright (c) 2020-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for TiePie
+"""
+
+import sys
+
+import libtiepie as ltp
+import numpy as np
+import pytest
+from libtiepie.exceptions import LibTiePieException, InvalidDeviceSerialNumberError
+from pytest_mock import MockerFixture
+
+from hvl_ccb.dev import (
+    TiePieError,
+    TiePieDeviceType,
+    TiePieOscilloscope,
+    TiePieWS5,
+    TiePieHS6,
+    TiePieHS5,
+    TiePieOscilloscopeResolution,
+    TiePieOscilloscopeChannelCoupling,
+    TiePieOscilloscopeTriggerKind,
+    TiePieOscilloscopeRange,
+    TiePieOscilloscopeTriggerLevelMode,
+    TiePieGeneratorSignalType,
+    TiePieOscilloscopeAutoResolutionModes,
+    TiePieDeviceConfig,
+    TiePieI2CHostMixin,
+    TiePieGeneratorMixin,
+    get_device_by_serial_number,
+    _verify_via_libtiepie,
+)
+from mock_libtiepie.const import (
+    MOCK_I2CHOST_SERIAL_NUMBER,
+    MOCK_GENERATOR_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+    MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2,
+    MOCK_DEVICE_SERIAL_NUMBER,
+)
+
+"""
+Mocking libtiepie
+"""
+from mock_libtiepie import oscilloscope as _oscilloscope  # noqa: E402
+from mock_libtiepie import generator as _generator  # noqa: E402
+from mock_libtiepie import i2chost as _i2chost  # noqa: E402
+from mock_libtiepie.devicelist import device_list as _device_list  # noqa: E402
+
+libtiepie = sys.modules["libtiepie"]
+
+libtiepie.device_list = _device_list
+libtiepie.oscilloscope = _oscilloscope
+libtiepie.generator = _generator
+libtiepie.i2chost = _i2chost
+
+sys.modules["libtiepie"] = libtiepie
+
+
+@pytest.fixture(scope="module")
+def com_config():
+    return {}
+
+
+@pytest.fixture(scope="module")
+def dev_config():
+    return {
+        "serial_number": MOCK_DEVICE_SERIAL_NUMBER,
+        "n_max_try_get_device": 2,
+        "wait_sec_retry_get_device": 0.01,
+    }
+
+
+def test_instantiation(com_config, dev_config):
+    dev_hs6 = TiePieHS6(com_config, dev_config)
+    assert dev_hs6 is not None
+    dev_hs5 = TiePieHS5(com_config, dev_config)
+    assert dev_hs5 is not None
+    dev_ws5 = TiePieWS5(com_config, dev_config)
+    assert dev_ws5 is not None
+
+
+def test_wrap_libtiepie_exception(com_config, dev_config, mocker: MockerFixture):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    def raise_libtiepie_exception():
+        raise LibTiePieException(0, "mock")
+
+    mocker.patch(
+        "libtiepie.device_list.update",
+        side_effect=raise_libtiepie_exception,
+        autospec=True,
+    )
+
+    with pytest.raises(TiePieError):
+        dev_osc.list_devices()
+
+    with pytest.raises(TiePieError):
+        get_device_by_serial_number(
+            dev_osc.config.serial_number, TiePieDeviceType.OSCILLOSCOPE
+        )
+
+    with pytest.raises(TiePieError):
+        dev_osc.start()
+
+
+def test_list_devices(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    list_devices = dev_osc.list_devices()
+    assert list_devices is not None
+
+
+def test_list_devices_none_available(com_config, dev_config, mocker: MockerFixture):
+    # simulate absence of devices
+    mock_devices = mocker.patch.object(libtiepie.device_list, "mock_devices")
+    mock_devices.return_value = False
+
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    list_devices = dev_osc.list_devices()
+    assert not list_devices
+
+
+def test_get_device_by_serial_number():
+    dev_osc = get_device_by_serial_number(
+        MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+        TiePieDeviceType.OSCILLOSCOPE,
+    )
+    assert dev_osc is not None
+
+    dev_gen = get_device_by_serial_number(
+        MOCK_GENERATOR_SERIAL_NUMBER,
+        TiePieDeviceType.GENERATOR,
+    )
+    assert dev_gen is not None
+
+    dev_i2c = get_device_by_serial_number(
+        MOCK_I2CHOST_SERIAL_NUMBER,
+        TiePieDeviceType.I2C,
+    )
+    assert dev_i2c is not None
+
+
+@pytest.mark.parametrize(
+    "wrong_dev_config",
+    [
+        {"serial_number": -23},
+        {"n_max_try_get_device": 0},
+        {"wait_sec_retry_get_device": 0.0},
+        {"is_data_ready_polling_interval_sec": 0.0},
+    ],
+)
+def test_invalid_config_dict(dev_config, wrong_dev_config):
+    invalid_config = dict(dev_config)
+    invalid_config.update(wrong_dev_config)
+    with pytest.raises(ValueError):
+        TiePieDeviceConfig(**invalid_config)
+
+
+def test_get_device_by_serial_number_not_available(dev_config, mocker: MockerFixture):
+    # simulate absence of devices
+    mock_devices = mocker.patch.object(libtiepie.device_list, "mock_devices")
+    mock_devices.return_value = False
+
+    with pytest.raises(TiePieError):
+        get_device_by_serial_number(
+            MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+            TiePieDeviceType.OSCILLOSCOPE,
+            n_max_try_get_device=dev_config["n_max_try_get_device"],
+            wait_sec_retry_get_device=dev_config["wait_sec_retry_get_device"],
+        )
+
+
+def test_get_device_by_serial_number_wrong_device_type():
+    with pytest.raises(TiePieError):
+        get_device_by_serial_number(
+            MOCK_GENERATOR_SERIAL_NUMBER,
+            TiePieDeviceType.OSCILLOSCOPE,
+        )
+
+
+def test_get_device_by_serial_number_invalid_device_sn(
+    dev_config,
+    mocker: MockerFixture,
+):
+    # simulate invalid device serian number error
+    get_item_by_serial_number = mocker.patch.object(
+        libtiepie.device_list,
+        "get_item_by_serial_number",
+    )
+    get_item_by_serial_number.side_effect = InvalidDeviceSerialNumberError
+
+    with pytest.raises(TiePieError):
+        get_device_by_serial_number(
+            MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+            TiePieDeviceType.OSCILLOSCOPE,
+            n_max_try_get_device=dev_config["n_max_try_get_device"],
+            wait_sec_retry_get_device=dev_config["wait_sec_retry_get_device"],
+        )
+
+
+def test_block_measurement_support():
+    dev_osc = TiePieOscilloscope(
+        {},
+        {"serial_number": MOCK_OSCILLOSCOPE_SERIAL_NUMBER_2},
+    )
+
+    with pytest.raises(TiePieError):
+        dev_osc.start()
+
+
+def test_channel_config_on_start_stop(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    assert not dev_osc.config_osc_channel_dict
+    # with pytest.raises(TiePieError):
+    #     dev_osc.n_channels
+
+    dev_osc.start()
+
+    n_channels = dev_osc.n_channels
+
+    for ch_nr in range(1, n_channels + 1):
+        assert ch_nr in dev_osc.config_osc_channel_dict
+        assert not dev_osc.config_osc_channel_dict[ch_nr].enabled
+
+    for wrong_ch_nr in (0, dev_osc.n_channels + 1):
+        with pytest.raises(KeyError):
+            dev_osc.config_osc_channel_dict[wrong_ch_nr]
+
+    dev_osc.stop()
+
+
+def test_channels_enabled(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    dev_osc.start()
+    for ch_config in dev_osc.config_osc_channel_dict.values():
+        ch_config.enabled = True
+    assert list(dev_osc.channels_enabled) == list(
+        dev_osc.config_osc_channel_dict.keys()
+    )
+    dev_osc.config_osc_channel_dict[1].enabled = False
+    dev_osc.stop()
+
+
+def test_n_channels(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    dev_osc.start()
+    assert dev_osc.n_channels == 3
+    dev_osc.stop()
+
+
+def test_dev_osc_not_running(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    with pytest.raises(TiePieError):
+        dev_osc.n_channels == 3
+
+    class TiePieGeneratorOscilloscope(TiePieGeneratorMixin, TiePieOscilloscope):
+        pass
+
+    dev_gen = TiePieGeneratorOscilloscope(com_config, dev_config)
+    with pytest.raises(TiePieError):
+        dev_gen.generator_start()
+
+    class TiePieI2CHostOscilloscope(TiePieI2CHostMixin, TiePieOscilloscope):
+        pass
+
+    dev_i2c = TiePieI2CHostOscilloscope(com_config, dev_config)
+
+    with pytest.raises(TiePieError):
+        dev_i2c._i2c_config_setup()  # ATM only priv method avail for testing
+
+
+def test_safe_ground_enabled(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
+        assert ch_config.safe_ground_enabled is False
+
+    for ch_nr in [1, 3]:
+        dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled = True
+    for ch_nr in [2]:
+        assert dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled is False
+
+    dev_osc.stop()
+
+
+def test_safe_ground_not_available(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
+        ch_config.channel.disable_safe_ground_option()
+
+    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
+        with pytest.raises(TiePieError):
+            dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled = True
+        with pytest.raises(TiePieError):
+            dev_osc.config_osc_channel_dict[ch_nr].safe_ground_enabled
+
+    dev_osc.stop()
+
+
+def test_trigger_enabled(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
+        ch_config.trigger_enabled = False
+        assert ch_config.trigger_enabled is False
+
+    dev_osc.start()
+
+    for ch_nr, ch_config in dev_osc.config_osc_channel_dict.items():
+        assert ch_config.trigger_enabled is False
+
+    for ch_nr in [1, 3]:
+        dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled = True
+        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is True
+
+    for ch_nr in [2]:
+        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is False
+
+    for ch_nr in [3]:
+        dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled = False
+
+    for ch_nr in [1]:
+        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is True
+
+    for ch_nr in [2, 3]:
+        assert dev_osc.config_osc_channel_dict[ch_nr].trigger_enabled is False
+
+    dev_osc.stop()
+
+
+def test_scope_config_set(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    assert dev_osc.config_osc is None
+
+    dev_osc.start()
+
+    config_osc = dev_osc.config_osc
+
+    # record length
+    record_length_value = 100
+    config_osc.record_length = record_length_value
+    assert config_osc.record_length == record_length_value
+
+    record_length_value = 1e6
+    config_osc.record_length = record_length_value
+    assert config_osc.record_length == record_length_value
+
+    # sample frequency
+    sample_frequency_value = 1e6
+    config_osc.sample_frequency = sample_frequency_value
+    assert config_osc.sample_frequency == sample_frequency_value
+
+    # pre-sample ratio
+    pre_sample_ratio_value = 0.2
+    config_osc.pre_sample_ratio = pre_sample_ratio_value
+    assert config_osc.pre_sample_ratio == pre_sample_ratio_value
+
+    # resolution
+    resolution = TiePieOscilloscopeResolution.FOURTEEN_BIT
+    config_osc.resolution = resolution
+    assert config_osc.resolution == resolution
+
+    # trigger timeout
+    trigger_timeouts = [0, 1, 1.5]
+    for trigger_timeout in trigger_timeouts:
+        config_osc.trigger_timeout = trigger_timeout
+        assert config_osc.trigger_timeout == trigger_timeout
+
+    trigger_timeouts = [None, -1, ltp.TO_INFINITY]
+    for trigger_timeout in trigger_timeouts:
+        config_osc.trigger_timeout = trigger_timeout
+        assert config_osc.trigger_timeout is None
+
+    # auto resolution mode
+    auto_resolution_mode = TiePieOscilloscopeAutoResolutionModes.DISABLED
+    config_osc.auto_resolution_mode = auto_resolution_mode
+    assert config_osc.auto_resolution_mode == auto_resolution_mode
+
+    dev_osc.stop()
+
+    assert dev_osc.config_osc is None
+
+
+def test_scope_config_set_invalid(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    config_osc = dev_osc.config_osc
+
+    # sample_frequency
+    with pytest.raises(ValueError):
+        config_osc.sample_frequency = -1
+    with pytest.raises(ValueError):
+        config_osc.sample_frequency = 1e14
+    with pytest.raises(TypeError):
+        config_osc.sample_frequency = "1"
+
+    # record_length
+    with pytest.raises(ValueError):
+        config_osc.record_length = -1
+    with pytest.raises(TypeError):
+        config_osc.record_length = "1"
+    with pytest.raises(ValueError):
+        config_osc.record_length = 1.5
+
+    # pre_sample_ratio
+    for v in (-0.1, 1.1):
+        with pytest.raises(ValueError):
+            config_osc.pre_sample_ratio = v
+    with pytest.raises(TypeError):
+        config_osc.pre_sample_ratio = "0.5"
+
+    # resolution
+    with pytest.raises(ValueError):
+        config_osc.resolution = 1
+    with pytest.raises(TypeError):
+        config_osc.resolution = "8"
+
+    # trigger_timeout
+    with pytest.raises(ValueError):
+        config_osc.trigger_timeout = -0.1
+    with pytest.raises(ValueError):
+        config_osc.trigger_timeout = -1.1
+    with pytest.raises(TypeError):
+        config_osc.trigger_timeout = "123"
+
+    # auto resolution mode
+    with pytest.raises(TypeError):
+        config_osc.auto_resolution_mode = False
+    with pytest.raises(TypeError):
+        config_osc.auto_resolution_mode = "Disabled"
+
+
+def test_channel_config_set(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    assert not dev_osc.config_osc_channel_dict
+
+    dev_osc.start()
+
+    assert dev_osc.config_osc_channel_dict
+
+    # Channel 2
+    ch2_config = dev_osc.config_osc_channel_dict[2]
+
+    # coupling
+    coupling_value = TiePieOscilloscopeChannelCoupling.ACV
+    ch2_config.coupling = coupling_value
+    assert ch2_config.coupling == coupling_value
+
+    ch2_config.coupling = "ACV"
+    assert ch2_config.coupling is TiePieOscilloscopeChannelCoupling.ACV
+
+    # enabled
+    enabled_value = True
+    ch2_config.enabled = enabled_value
+    assert ch2_config.enabled == enabled_value
+
+    # range
+    range_value = TiePieOscilloscopeRange.TWENTY_VOLT
+    ch2_config.input_range = range_value
+    assert ch2_config.input_range == range_value
+
+    for v, ir in (
+        (20, TiePieOscilloscopeRange.TWENTY_VOLT),
+        (21, TiePieOscilloscopeRange.FORTY_VOLT),
+        (79.9, TiePieOscilloscopeRange.EIGHTY_VOLT),
+    ):
+        ch2_config.input_range = v
+        assert ch2_config.input_range is ir
+
+    # probe offset
+    probe_offset_value = 1
+    ch2_config.probe_offset = probe_offset_value
+    assert ch2_config.probe_offset == probe_offset_value
+
+    # safe ground enabled
+    ch2_config.channel.enable_safe_ground_option()
+    safe_ground_enabled_value = True
+    ch2_config.safe_ground_enabled = safe_ground_enabled_value
+    assert ch2_config.safe_ground_enabled == safe_ground_enabled_value
+    ch2_config.safe_ground_enabled = False
+    assert ch2_config.safe_ground_enabled is False
+
+    # trigger level mode
+    trigger_level_mode_value = TiePieOscilloscopeTriggerLevelMode.ABSOLUTE
+    ch2_config.trigger_level_mode = trigger_level_mode_value
+    assert ch2_config.trigger_level_mode == trigger_level_mode_value
+
+    # trigger level
+    trigger_level_value = 0.5
+    ch2_config.trigger_level = trigger_level_value
+    assert ch2_config.trigger_level == trigger_level_value
+
+    trigger_level_value = 1
+    ch2_config.trigger_level = trigger_level_value
+    assert ch2_config.trigger_level == trigger_level_value
+
+    # trigger level mode
+    trigger_level_mode_value = TiePieOscilloscopeTriggerLevelMode.RELATIVE
+    ch2_config.trigger_level_mode = trigger_level_mode_value
+    assert ch2_config.trigger_level_mode == trigger_level_mode_value
+
+    # trigger level
+    trigger_level_value = 0.5
+    ch2_config.trigger_level = trigger_level_value
+    assert ch2_config.trigger_level == trigger_level_value
+
+    # trigger hysteresis
+    trigger_hysteresis_value = 0.05
+    ch2_config.trigger_hysteresis = trigger_hysteresis_value
+    assert ch2_config.trigger_hysteresis == trigger_hysteresis_value
+
+    # trigger kind
+    trigger_kind_value = TiePieOscilloscopeTriggerKind.RISING_OR_FALLING
+    ch2_config.trigger_kind = trigger_kind_value
+    assert ch2_config.trigger_kind == trigger_kind_value
+
+    ch2_config.trigger_kind = "FALLING"
+    assert ch2_config.trigger_kind is TiePieOscilloscopeTriggerKind.FALLING
+
+    # trigger enabled
+    trigger_enabled_value = True
+    ch2_config.trigger_enabled = trigger_enabled_value
+    assert ch2_config.trigger_enabled == trigger_enabled_value
+
+    dev_osc.stop()
+
+    assert not dev_osc.config_osc_channel_dict
+
+
+def test_channel_config_set_invalid(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    assert not dev_osc.config_osc_channel_dict
+
+    dev_osc.start()
+
+    # Channel 2
+    ch_config = dev_osc.config_osc_channel_dict[2]
+
+    # coupling
+    for v in ("dcv", 123):
+        with pytest.raises(ValueError):
+            ch_config.coupling = v
+
+    # enabled
+    for v in ("True", 1):
+        with pytest.raises(TypeError):
+            ch_config.enabled = v
+
+    # input_range
+    with pytest.raises(TypeError):
+        ch_config.input_range = "40"
+
+    with pytest.raises(ValueError):
+        ch_config.input_range = 234567
+
+    # probe_offset
+    for v in (-1e7, 1e7):
+        with pytest.raises(ValueError):
+            ch_config.probe_offset = v
+    with pytest.raises(TypeError):
+        ch_config.probe_offset = "1"
+
+    # safe_ground_enabled
+    for v in ("True", 1):
+        with pytest.raises(TypeError):
+            ch_config.safe_ground_enabled = v
+
+    # trigger_hysteresis
+    for v in (-0.1, 1.1):
+        with pytest.raises(ValueError):
+            ch_config.trigger_hysteresis = v
+    with pytest.raises(TypeError):
+        ch_config.trigger_hysteresis = "0.5"
+
+    # trigger_kind
+    for v in ("any", "Any", 123):
+        with pytest.raises(ValueError):
+            ch_config.trigger_kind = v
+
+    # trigger_enabled
+    for v in ("True", 1):
+        with pytest.raises(TypeError):
+            ch_config.trigger_enabled = v
+
+
+def test_trigger_check(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    assert dev_osc.is_triggered() is False
+    dev_osc.force_trigger()
+    dev_osc.config_osc.dev_osc.is_triggered = True
+    assert dev_osc.is_triggered() is True
+
+    dev_osc.stop()
+
+
+_record_length = 7
+_valid_pre_sample_count = 3
+_sample_frequency = 1000
+_pre_sample_ratio = 0.5
+
+
+def _test_measure_data(data, rec_lngth_reduced=0):
+    assert len(data) == _record_length - rec_lngth_reduced
+    for i, ch_data in enumerate(data.T):
+        _test_measure_data_ch(i + 1, ch_data, rec_lngth_reduced=rec_lngth_reduced)
+
+
+def _test_measure_data_ch(ch_nr, ch_data, rec_lngth_reduced=0):
+    assert len(ch_data) == _record_length - rec_lngth_reduced
+    for i in range(_record_length - rec_lngth_reduced):
+        if ch_nr == 1:  # Check time vector
+            assert ch_data[i] == (i - _valid_pre_sample_count) / _sample_frequency
+        else:
+            assert ch_data[i] == float(i)
+
+
+def _test_measure_and_collect(dev_osc, timeout, rec_lngth_reduced=0):
+    # Enable all channels for measurement
+    for ch in dev_osc.config_osc_channel_dict.values():
+        ch.enabled = True
+
+    dev_osc.config_osc.dev_osc.record_length = _record_length + 1
+    dev_osc.config_osc.dev_osc.valid_pre_sample_count = _valid_pre_sample_count
+    dev_osc.config_osc.dev_osc.sample_frequency = _sample_frequency
+    dev_osc.config_osc.dev_osc.pre_sample_ratio = _pre_sample_ratio
+
+    # Let the oscilloscope gather data
+    dev_osc.start_measurement()
+
+    if dev_osc.is_measurement_data_ready():
+        data = dev_osc.collect_measurement_data(timeout)
+
+    assert all(isinstance(x, np.ndarray) for x in data)
+
+    _test_measure_data(data, rec_lngth_reduced=rec_lngth_reduced)
+
+
+def test_measure_and_collect(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    timeout = 0  # Same as default option
+    _test_measure_and_collect(dev_osc, timeout)
+
+    timeout = 0.2
+    _test_measure_and_collect(dev_osc, timeout)
+
+    timeout = None
+    _test_measure_and_collect(dev_osc, timeout)
+
+    timeout = 0  # Same as default option, but truncated data
+    dev_osc.config_osc.dev_osc.mock_reduce_data = 1
+    _test_measure_and_collect(dev_osc, timeout, rec_lngth_reduced=1)
+
+    dev_osc.stop()
+
+
+def test_measure_and_collect_fail(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+
+    dev_osc.start()
+
+    # string as timeout
+    timeout = "a"
+    with pytest.raises(ValueError):
+        dev_osc.collect_measurement_data(timeout)
+
+    timeout = 0.2
+    dev_osc.config_osc.dev_osc.is_data_ready = False
+    assert dev_osc.collect_measurement_data(timeout) is None
+
+    dev_osc.config_osc = None
+    assert dev_osc.collect_measurement_data(timeout) is None
+    assert dev_osc._check_record_length(np.zeros(1)) is None
+
+    dev_osc.stop()
+
+
+def test_generator_config_set(com_config, dev_config):
+    dev_ws5 = TiePieWS5(com_config, dev_config)
+    assert dev_ws5 is not None
+
+    assert dev_ws5.config_gen is None
+
+    dev_ws5.start()
+
+    config_gen = dev_ws5.config_gen
+
+    # frequency
+    frequency_value = 1e6
+    config_gen.frequency = frequency_value
+    assert config_gen.frequency == frequency_value
+
+    # amplitude
+    amplitude_value = 2
+    config_gen.amplitude = amplitude_value
+    assert config_gen.amplitude == amplitude_value
+
+    # offset
+    offset_value = 1
+    config_gen.offset = offset_value
+    assert config_gen.offset == offset_value
+
+    # signal type
+    signal_type = TiePieGeneratorSignalType.SINE
+    config_gen.signal_type = signal_type
+    assert config_gen.signal_type == signal_type
+
+    # arbitrary waveform
+    t_axis = np.linspace(0, 100, 8192)  # Create signal array
+    waveform = np.sin(t_axis) * (1 - t_axis / 100)
+    config_gen.waveform = waveform
+    assert config_gen.waveform.all() == waveform.all()
+
+    # Create 2dim waveform
+    waveform = np.array([waveform, waveform])
+    with pytest.raises(ValueError):
+        config_gen.waveform = waveform
+
+    # Create signal array that is too large
+    t_axis = np.linspace(0, 100, 10_001)
+    waveform = np.sin(t_axis) * (1 - t_axis / 100)
+    with pytest.raises(ValueError):
+        config_gen.waveform = waveform
+
+    # enabled
+    enabled_value = True
+    config_gen.enabled = enabled_value
+    assert config_gen.enabled == enabled_value
+    config_gen.enabled = False
+    assert config_gen.enabled is False
+
+    dev_ws5.stop()
+
+    assert dev_ws5.config_gen is None
+
+
+def test_generator_config_set_invalid(com_config, dev_config):
+    dev_ws5 = TiePieWS5(com_config, dev_config)
+    assert dev_ws5 is not None
+
+    dev_ws5.start()
+
+    config_gen = dev_ws5.config_gen
+
+    # frequency
+    with pytest.raises(ValueError):
+        config_gen.frequency = -1
+    with pytest.raises(ValueError):
+        config_gen.frequency = 1e14
+    with pytest.raises(TypeError):
+        config_gen.frequency = "1"
+
+    # amplitude
+    with pytest.raises(ValueError):
+        config_gen.amplitude = -1
+    with pytest.raises(ValueError):
+        config_gen.amplitude = 100
+    with pytest.raises(TypeError):
+        config_gen.frequency = "1"
+
+    # offset
+    with pytest.raises(ValueError):
+        config_gen.offset = 100
+    with pytest.raises(TypeError):
+        config_gen.offset = "1"
+
+    # signal type
+    with pytest.raises(ValueError):
+        config_gen.signal_type = "sin"
+
+    # arbitrary waveform
+    with pytest.raises(ValueError):
+        config_gen.waveform = [1, 2, 3]
+
+    # enabled
+    for v in ("True", 1):
+        with pytest.raises(TypeError):
+            config_gen.enabled = v
+
+    dev_ws5.stop()
+
+
+def test_generate_signal(com_config, dev_config):
+    dev_ws5 = TiePieWS5(com_config, dev_config)
+    assert dev_ws5 is not None
+
+    dev_ws5.start()
+
+    dev_ws5.generator_start()
+    dev_ws5.generator_stop()
+
+    dev_ws5.stop()
+
+
+def test_verify_via_libtiepie():
+    dev_osc = get_device_by_serial_number(
+        MOCK_OSCILLOSCOPE_SERIAL_NUMBER,
+        TiePieDeviceType.OSCILLOSCOPE,
+    )
+    assert dev_osc is not None
+    assert _verify_via_libtiepie(dev_osc, "sample_frequency", 1e6) == 1e6
+    assert _verify_via_libtiepie(dev_osc, "record_length", 10) == 10
+
+
+def test_config_print_values(com_config, dev_config):
+    dev_osc = TiePieOscilloscope(com_config, dev_config)
+    dev_osc.start()
+    config_osc = dev_osc.config_osc
+    config_osc.record_length = 100
+    assert f"record_length={config_osc.record_length!r}" in str(config_osc)
+
+    ch_config = dev_osc.config_osc_channel_dict[1]
+    assert f"enabled={ch_config.enabled!r}" in str(ch_config)
+    ch_config.enabled = not ch_config.enabled
+    assert f"enabled={ch_config.enabled!r}" in str(ch_config)
+
+    dev_ws5 = TiePieWS5(com_config, dev_config)
+    dev_ws5.start()
+    config_gen = dev_ws5.config_gen
+    config_gen.amplitude = 12
+    assert f"amplitude={config_gen.amplitude!r}" in str(config_gen)
+
+    config_i2c = dev_ws5.config_i2c
+    assert "()" in str(config_i2c)  # no config properties yet
```

### Comparing `hvl_ccb-0.8.5/tests/test_experiment_manager.py` & `hvl_ccb-0.9.0/tests/test_experiment_manager.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,102 +1,102 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for the ExperimentManager class.
-"""
-
-import pytest
-
-from hvl_ccb import ExperimentManager, ExperimentStatus, ExperimentError
-from hvl_ccb.dev import Device, DeviceExistingException
-
-# make Device instantiable
-Device.__abstractmethods__ = frozenset()
-
-
-class FailingDeviceException(Exception):
-    pass
-
-
-class FailingDevice(Device):
-    def start(self):
-        raise FailingDeviceException
-
-    def stop(self):
-        raise FailingDeviceException
-
-
-def test_manager():
-
-    dev1 = Device()
-    dev2 = Device()
-    dev3 = Device()
-    fail1 = FailingDevice()
-
-    devicelist = {
-        'dev1': dev1,
-    }
-
-    mgr = ExperimentManager(devicelist)
-
-    # start / stop with failing device
-    mgr.add_device('failing', fail1)
-    with pytest.raises(ExperimentError):
-        mgr.run()
-    assert mgr.status == ExperimentStatus.ERROR
-    assert mgr.is_error()
-
-    with pytest.raises(ExperimentError):
-        mgr.finish()
-    assert mgr.status == ExperimentStatus.ERROR
-    assert mgr.remove_device('failing') == fail1
-    mgr.finish()
-    assert mgr.status == ExperimentStatus.FINISHED
-
-    # add device while running
-    mgr.run()
-    mgr.add_device('dev2', dev2)
-    mgr.finish()
-
-    # add failing device while running, add clean device while ERROR
-    mgr.run()
-    with pytest.raises(ExperimentError):
-        mgr.add_device('failing', fail1)
-    assert mgr.status == ExperimentStatus.ERROR
-
-    with pytest.raises(ExperimentError):
-        mgr.add_device('dev3', dev3)
-
-    mgr.remove_device('failing')
-    mgr.finish()
-
-    # add existing device
-    with pytest.raises(DeviceExistingException):
-        mgr.add_device('dev1', dev3)
-
-    # print all devices
-    for i, (name, dev) in enumerate(mgr.get_devices()):
-        print(f"#{i} {name}: {dev}")
-
-
-def test_manager_status():
-    mgr = ExperimentManager(
-        {
-            'dev1': Device()
-        }
-    )
-
-    assert mgr.status == ExperimentStatus.INITIALIZED
-
-    assert not mgr.is_running()
-    assert not mgr.is_finished()
-
-    mgr.run()
-    assert not mgr.is_finished()
-    assert mgr.is_running()
-
-    mgr.finish()
-    assert mgr.is_finished()
-    assert not mgr.is_running()
-
-    mgr.start()
-    mgr.stop()
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for the ExperimentManager class.
+"""
+
+import pytest
+
+from hvl_ccb import ExperimentManager, ExperimentStatus, ExperimentError
+from hvl_ccb.dev import Device, DeviceExistingException
+
+# make Device instantiable
+Device.__abstractmethods__ = frozenset()
+
+
+class FailingDeviceException(Exception):
+    pass
+
+
+class FailingDevice(Device):
+    def start(self):
+        raise FailingDeviceException
+
+    def stop(self):
+        raise FailingDeviceException
+
+
+def test_manager():
+
+    dev1 = Device()
+    dev2 = Device()
+    dev3 = Device()
+    fail1 = FailingDevice()
+
+    devicelist = {
+        'dev1': dev1,
+    }
+
+    mgr = ExperimentManager(devicelist)
+
+    # start / stop with failing device
+    mgr.add_device('failing', fail1)
+    with pytest.raises(ExperimentError):
+        mgr.run()
+    assert mgr.status == ExperimentStatus.ERROR
+    assert mgr.is_error()
+
+    with pytest.raises(ExperimentError):
+        mgr.finish()
+    assert mgr.status == ExperimentStatus.ERROR
+    assert mgr.remove_device('failing') == fail1
+    mgr.finish()
+    assert mgr.status == ExperimentStatus.FINISHED
+
+    # add device while running
+    mgr.run()
+    mgr.add_device('dev2', dev2)
+    mgr.finish()
+
+    # add failing device while running, add clean device while ERROR
+    mgr.run()
+    with pytest.raises(ExperimentError):
+        mgr.add_device('failing', fail1)
+    assert mgr.status == ExperimentStatus.ERROR
+
+    with pytest.raises(ExperimentError):
+        mgr.add_device('dev3', dev3)
+
+    mgr.remove_device('failing')
+    mgr.finish()
+
+    # add existing device
+    with pytest.raises(DeviceExistingException):
+        mgr.add_device('dev1', dev3)
+
+    # print all devices
+    for i, (name, dev) in enumerate(mgr.get_devices()):
+        print(f"#{i} {name}: {dev}")
+
+
+def test_manager_status():
+    mgr = ExperimentManager(
+        {
+            'dev1': Device()
+        }
+    )
+
+    assert mgr.status == ExperimentStatus.INITIALIZED
+
+    assert not mgr.is_running()
+    assert not mgr.is_finished()
+
+    mgr.run()
+    assert not mgr.is_finished()
+    assert mgr.is_running()
+
+    mgr.finish()
+    assert mgr.is_finished()
+    assert not mgr.is_running()
+
+    mgr.start()
+    mgr.stop()
```

### Comparing `hvl_ccb-0.8.5/tests/test_utils_conversion.py` & `hvl_ccb-0.9.0/tests/test_utils_conversion.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,108 +1,108 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for Unit Conversion Utils
-"""
-
-import pytest
-import numpy as np
-from typing import NamedTuple
-from collections import namedtuple
-
-from hvl_ccb.utils.conversion_unit import (
-    Temperature,
-    Pressure,
-)
-
-
-class TestTempNamedTuple(NamedTuple):
-    field_a: float = 273.15
-    field_b: float = 293.15
-    field_c: float = 313.15
-
-
-TestTempNamedTuple2 = namedtuple(
-    "TestTempNamedTuple2", ["field_a", "field_b", "field_c"]
-)
-
-
-def test_temperature():
-    assert Temperature.convert(293.15) == 20.
-    assert Temperature.convert(273.15) == 0.
-    assert round(Temperature.convert(293), 2) == 19.85
-    assert Temperature.convert(
-        300, source=Temperature.CELSIUS, target=Temperature.FAHRENHEIT
-    ) == 572
-    assert Temperature.convert(
-        572, source=Temperature.FAHRENHEIT, target=Temperature.CELSIUS
-    ) == 300
-    assert Temperature.convert(
-        302., source=Temperature.FAHRENHEIT, target=Temperature.KELVIN
-    ) == 423.15
-    assert Temperature.convert(
-        423.15, source=Temperature.KELVIN, target=Temperature.FAHRENHEIT
-    ) == 302.
-    assert Temperature.convert(
-        125., source=Temperature.CELSIUS, target=Temperature.KELVIN
-    ) == 398.15
-    assert Temperature.convert([273.15, 293.15, 313.15]) == [0, 20, 40]
-    assert Temperature.convert((273.15, 293.15, 313.15)) == (0, 20, 40)
-    with pytest.raises(TypeError):
-        Temperature.convert([273.15, '293.15', 313.15])
-    assert Temperature.convert(
-        {'temp1': 273.15, 'temp2': 293.15}) == {'temp1': 0, 'temp2': 20}
-    assert np.all(
-        Temperature.convert(np.array([273.15, 293.15, 313.15])) == np.array([0, 20, 40])
-    )
-    assert Temperature.convert(
-        20, source=Temperature.KELVIN, target=Temperature.KELVIN
-    ) == 20
-    assert Temperature.convert(TestTempNamedTuple()) == TestTempNamedTuple(0, 20, 40)
-    assert Temperature.convert(
-        TestTempNamedTuple2(273.15, 293.15, 313.15)) == TestTempNamedTuple2(0, 20, 40)
-    with pytest.raises(TypeError):
-        Temperature.convert(
-            '20.', source=Temperature.KELVIN, target=Temperature.KELVIN
-        )
-    with pytest.raises(ValueError):
-        Temperature.convert(
-            20., source='k', target=Temperature.CELSIUS
-        )
-    with pytest.raises(TypeError):
-        Temperature.convert(
-            [20, 'a'], source='k', target=Temperature.CELSIUS
-        )
-
-
-def test_pressure():
-    assert Pressure.convert(1., source=Pressure.BAR, target=Pressure.PASCAL) == 1e5
-    assert round(Pressure.convert(
-        1., source=Pressure.MMHG, target=Pressure.PASCAL
-    ), 3) == 133.322
-    assert Pressure.convert(
-        1., source=Pressure.ATMOSPHERE, target=Pressure.PASCAL) == 101325
-    assert round(Pressure.convert(
-        1., source=Pressure.PSI, target=Pressure.PASCAL
-    ), 2) == 6894.76
-    assert round(Pressure.convert(
-        1., source=Pressure.TORR, target=Pressure.PASCAL
-    ), 2) == 133.32
-    assert Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.BAR
-    ) == 1.
-    assert round(Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.MMHG
-    ), 5) == 750.06158
-    assert round(Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.ATMOSPHERE
-    ), 8) == 0.98692327
-    assert round(Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.PSI
-    ), 5) == 14.50377
-    assert round(Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.TORR
-    ), 5) == 750.06168
-    assert Pressure.convert(
-        100_000., source=Pressure.PASCAL, target=Pressure.PASCAL) == 100_000.
-    with pytest.raises(ValueError):
-        Pressure.convert(1., source='Bar', target=Pressure.MMHG)
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for Unit Conversion Utils
+"""
+
+import pytest
+import numpy as np
+from typing import NamedTuple
+from collections import namedtuple
+
+from hvl_ccb.utils.conversion_unit import (
+    Temperature,
+    Pressure,
+)
+
+
+class TestTempNamedTuple(NamedTuple):
+    field_a: float = 273.15
+    field_b: float = 293.15
+    field_c: float = 313.15
+
+
+TestTempNamedTuple2 = namedtuple(
+    "TestTempNamedTuple2", ["field_a", "field_b", "field_c"]
+)
+
+
+def test_temperature():
+    assert Temperature.convert(293.15) == 20.
+    assert Temperature.convert(273.15) == 0.
+    assert round(Temperature.convert(293), 2) == 19.85
+    assert Temperature.convert(
+        300, source=Temperature.CELSIUS, target=Temperature.FAHRENHEIT
+    ) == 572
+    assert Temperature.convert(
+        572, source=Temperature.FAHRENHEIT, target=Temperature.CELSIUS
+    ) == 300
+    assert Temperature.convert(
+        302., source=Temperature.FAHRENHEIT, target=Temperature.KELVIN
+    ) == 423.15
+    assert Temperature.convert(
+        423.15, source=Temperature.KELVIN, target=Temperature.FAHRENHEIT
+    ) == 302.
+    assert Temperature.convert(
+        125., source=Temperature.CELSIUS, target=Temperature.KELVIN
+    ) == 398.15
+    assert Temperature.convert([273.15, 293.15, 313.15]) == [0, 20, 40]
+    assert Temperature.convert((273.15, 293.15, 313.15)) == (0, 20, 40)
+    with pytest.raises(TypeError):
+        Temperature.convert([273.15, '293.15', 313.15])
+    assert Temperature.convert(
+        {'temp1': 273.15, 'temp2': 293.15}) == {'temp1': 0, 'temp2': 20}
+    assert np.all(
+        Temperature.convert(np.array([273.15, 293.15, 313.15])) == np.array([0, 20, 40])
+    )
+    assert Temperature.convert(
+        20, source=Temperature.KELVIN, target=Temperature.KELVIN
+    ) == 20
+    assert Temperature.convert(TestTempNamedTuple()) == TestTempNamedTuple(0, 20, 40)
+    assert Temperature.convert(
+        TestTempNamedTuple2(273.15, 293.15, 313.15)) == TestTempNamedTuple2(0, 20, 40)
+    with pytest.raises(TypeError):
+        Temperature.convert(
+            '20.', source=Temperature.KELVIN, target=Temperature.KELVIN
+        )
+    with pytest.raises(ValueError):
+        Temperature.convert(
+            20., source='k', target=Temperature.CELSIUS
+        )
+    with pytest.raises(TypeError):
+        Temperature.convert(
+            [20, 'a'], source='k', target=Temperature.CELSIUS
+        )
+
+
+def test_pressure():
+    assert Pressure.convert(1., source=Pressure.BAR, target=Pressure.PASCAL) == 1e5
+    assert round(Pressure.convert(
+        1., source=Pressure.MMHG, target=Pressure.PASCAL
+    ), 3) == 133.322
+    assert Pressure.convert(
+        1., source=Pressure.ATMOSPHERE, target=Pressure.PASCAL) == 101325
+    assert round(Pressure.convert(
+        1., source=Pressure.PSI, target=Pressure.PASCAL
+    ), 2) == 6894.76
+    assert round(Pressure.convert(
+        1., source=Pressure.TORR, target=Pressure.PASCAL
+    ), 2) == 133.32
+    assert Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.BAR
+    ) == 1.
+    assert round(Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.MMHG
+    ), 5) == 750.06158
+    assert round(Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.ATMOSPHERE
+    ), 8) == 0.98692327
+    assert round(Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.PSI
+    ), 5) == 14.50377
+    assert round(Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.TORR
+    ), 5) == 750.06168
+    assert Pressure.convert(
+        100_000., source=Pressure.PASCAL, target=Pressure.PASCAL) == 100_000.
+    with pytest.raises(ValueError):
+        Pressure.convert(1., source='Bar', target=Pressure.MMHG)
```

### Comparing `hvl_ccb-0.8.5/tests/test_utils_conversion_sensor.py` & `hvl_ccb-0.9.0/tests/test_utils_conversion_sensor.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,42 +1,42 @@
-#  Copyright (c) 2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for Sensor Conversion Utils
-"""
-
-import pytest
-import numpy as np
-
-from hvl_ccb.utils.conversion_sensor import (
-    LEM4000S,
-    LMT70A
-)
-
-
-def test_lem4000s():
-    lem = LEM4000S()
-    assert lem.shunt == 1.2
-    lem.shunt = 2
-    assert lem.shunt == 2
-    with pytest.raises(ValueError):
-        lem.shunt = -1
-    with pytest.raises(AttributeError):
-        lem.CONVERSION = 1
-    with pytest.raises(ValueError):
-        lem.calibration_factor = 1.5
-    lem.shunt = 1.2
-    assert lem.convert(1.2) == 5000
-    lem.calibration_factor = 1.05
-    assert lem.convert(1.2) == 5250
-    lem.calibration_factor = -1.05
-    assert lem.convert(1.2) == -5250
-
-
-def test_lmt70a():
-    lmt = LMT70A()
-    with pytest.raises(AttributeError):
-        lmt.LUT = 1
-    with pytest.raises(ValueError):
-        lmt.temperature_unit = 'R'
-    assert lmt.convert(0.943227) == 30
-    assert np.isnan(lmt.convert(0.3))
+#  Copyright (c) 2021-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for Sensor Conversion Utils
+"""
+
+import pytest
+import numpy as np
+
+from hvl_ccb.utils.conversion_sensor import (
+    LEM4000S,
+    LMT70A
+)
+
+
+def test_lem4000s():
+    lem = LEM4000S()
+    assert lem.shunt == 1.2
+    lem.shunt = 2
+    assert lem.shunt == 2
+    with pytest.raises(ValueError):
+        lem.shunt = -1
+    with pytest.raises(AttributeError):
+        lem.CONVERSION = 1
+    with pytest.raises(ValueError):
+        lem.calibration_factor = 1.5
+    lem.shunt = 1.2
+    assert lem.convert(1.2) == 5000
+    lem.calibration_factor = 1.05
+    assert lem.convert(1.2) == 5250
+    lem.calibration_factor = -1.05
+    assert lem.convert(1.2) == -5250
+
+
+def test_lmt70a():
+    lmt = LMT70A()
+    with pytest.raises(AttributeError):
+        lmt.LUT = 1
+    with pytest.raises(ValueError):
+        lmt.temperature_unit = 'R'
+    assert lmt.convert(0.943227) == 30
+    assert np.isnan(lmt.convert(0.3))
```

### Comparing `hvl_ccb-0.8.5/tests/test_utils_enum.py` & `hvl_ccb-0.9.0/tests/test_utils_enum.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,113 +1,113 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Tests for Enum utils.
-"""
-
-import pytest
-
-from hvl_ccb.utils.enum import (
-    AutoNumberNameEnum,
-    NameEnum,
-    StrEnumBase,
-    ValueEnum,
-    unique,
-)
-
-
-def test_strenumbase():
-    @unique
-    class E(StrEnumBase):
-        A = "a"
-
-    with pytest.raises(NotImplementedError):
-        E.A == "a"
-
-
-def test_valueenum():
-
-    with pytest.raises(ValueError):
-        @unique
-        class F(ValueEnum):
-            A = "a"
-            B = "a"
-
-    @unique
-    class E(ValueEnum):
-        A = "a"
-        B = "b"
-
-    a = E("a")
-    assert hash(a) == hash(a.value)
-    assert a.value == a
-    assert a == "a"
-    assert str(a) == "a"
-    assert a == E.A
-
-    assert E["A"] is a
-    with pytest.raises(KeyError):
-        E["a"]
-    with pytest.raises(KeyError):
-        E[a]
-
-    assert a != 0
-    assert a != 1
-
-    b = E("b")
-    assert hash(b) == hash(b.value)
-    assert a != b
-    assert a != "b"
-    assert a != E.B
-
-
-def test_nameenum():
-
-    class E(NameEnum):
-        _init_ = 'custom_name'
-        a = 2
-        b = 4
-
-    a = E("a")
-    assert hash(a) == hash(a.name)
-    assert a.name == a
-    assert a == "a"
-    assert str(a) == "a"
-    assert a == E.a
-
-    assert a != 2
-    assert a.custom_name == 2
-
-    assert E["a"] is a
-    assert E[a] is a
-
-    b = E("b")
-    assert hash(b) == hash(b.name)
-    assert a != b
-    assert a != "b"
-    assert a != E.b
-
-
-def test_autonumbernameenum():
-
-    class E(AutoNumberNameEnum):
-        a = ()
-        b = ()
-
-    a = E("a")
-    assert hash(a) == hash(a.name)
-    assert a.name == a
-    assert a == "a"
-    assert str(a) == "a"
-    assert a == E.a
-
-    assert a != 0
-    assert a != 1
-
-    assert E["a"] is a
-    assert E[a] is a
-
-    b = E("b")
-    assert hash(b) == hash(b.name)
-    assert a != b
-    assert a != "b"
-    assert a != E.b
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Tests for Enum utils.
+"""
+
+import pytest
+
+from hvl_ccb.utils.enum import (
+    AutoNumberNameEnum,
+    NameEnum,
+    StrEnumBase,
+    ValueEnum,
+    unique,
+)
+
+
+def test_strenumbase():
+    @unique
+    class E(StrEnumBase):
+        A = "a"
+
+    with pytest.raises(NotImplementedError):
+        E.A == "a"
+
+
+def test_valueenum():
+
+    with pytest.raises(ValueError):
+        @unique
+        class F(ValueEnum):
+            A = "a"
+            B = "a"
+
+    @unique
+    class E(ValueEnum):
+        A = "a"
+        B = "b"
+
+    a = E("a")
+    assert hash(a) == hash(a.value)
+    assert a.value == a
+    assert a == "a"
+    assert str(a) == "a"
+    assert a == E.A
+
+    assert E["A"] is a
+    with pytest.raises(KeyError):
+        E["a"]
+    with pytest.raises(KeyError):
+        E[a]
+
+    assert a != 0
+    assert a != 1
+
+    b = E("b")
+    assert hash(b) == hash(b.value)
+    assert a != b
+    assert a != "b"
+    assert a != E.B
+
+
+def test_nameenum():
+
+    class E(NameEnum):
+        _init_ = 'custom_name'
+        a = 2
+        b = 4
+
+    a = E("a")
+    assert hash(a) == hash(a.name)
+    assert a.name == a
+    assert a == "a"
+    assert str(a) == "a"
+    assert a == E.a
+
+    assert a != 2
+    assert a.custom_name == 2
+
+    assert E["a"] is a
+    assert E[a] is a
+
+    b = E("b")
+    assert hash(b) == hash(b.name)
+    assert a != b
+    assert a != "b"
+    assert a != E.b
+
+
+def test_autonumbernameenum():
+
+    class E(AutoNumberNameEnum):
+        a = ()
+        b = ()
+
+    a = E("a")
+    assert hash(a) == hash(a.name)
+    assert a.name == a
+    assert a == "a"
+    assert str(a) == "a"
+    assert a == E.a
+
+    assert a != 0
+    assert a != 1
+
+    assert E["a"] is a
+    assert E[a] is a
+
+    b = E("b")
+    assert hash(b) == hash(b.name)
+    assert a != b
+    assert a != "b"
+    assert a != E.b
```

### Comparing `hvl_ccb-0.8.5/tests/test_utils_typing.py` & `hvl_ccb-0.9.0/tests/test_utils_typing.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-#  Copyright (c) 2019-2021 ETH Zurich, SIS ID and HVL D-ITET
-#
-"""
-Test for typing utils
-"""
-import sys
-from typing import List, Union, Callable
-
-import pytest
-
-from hvl_ccb.utils.typing import (
-    is_generic_type_hint,
-    check_generic_type,
-)
-
-
-def test_is_generic_type_hint():
-
-    for type_ in (1, "a", (), list, int, str, object):
-        assert not is_generic_type_hint(type_)
-
-    for type_ in (List[int], List, Union[None, List[int]], Union, Callable):
-        assert is_generic_type_hint(type_)
-
-    if sys.version_info >= (3, 9):
-        for type_ in (list[int],):  # PEP 585
-            assert is_generic_type_hint(type_)
-
-
-def test_check_generic_type():
-
-    with pytest.raises(ValueError):
-        check_generic_type([], list)
-
-    assert check_generic_type([], List) is None
-
-    with pytest.raises(TypeError):
-        check_generic_type(["a"], List[int])
-
-    assert check_generic_type([1, 2], List[int]) is None
-
-    with pytest.raises(TypeError):
-        check_generic_type([1, 1.0], List[int])
-
-    assert check_generic_type([1, 1.0], List[Union[int, float]]) is None
-    assert check_generic_type(None, Union[None, List[int]]) is None
-    assert check_generic_type([1, 2], Union[None, List[int]]) is None
+#  Copyright (c) 2019-2022 ETH Zurich, SIS ID and HVL D-ITET
+#
+"""
+Test for typing utils
+"""
+import sys
+from typing import List, Union, Callable
+
+import pytest
+
+from hvl_ccb.utils.typing import (
+    is_generic_type_hint,
+    check_generic_type,
+)
+
+
+def test_is_generic_type_hint():
+
+    for type_ in (1, "a", (), list, int, str, object):
+        assert not is_generic_type_hint(type_)
+
+    for type_ in (List[int], List, Union[None, List[int]], Union, Callable):
+        assert is_generic_type_hint(type_)
+
+    if sys.version_info >= (3, 9):
+        for type_ in (list[int],):  # PEP 585
+            assert is_generic_type_hint(type_)
+
+
+def test_check_generic_type():
+
+    with pytest.raises(ValueError):
+        check_generic_type([], list)
+
+    assert check_generic_type([], List) is None
+
+    with pytest.raises(TypeError):
+        check_generic_type(["a"], List[int])
+
+    assert check_generic_type([1, 2], List[int]) is None
+
+    with pytest.raises(TypeError):
+        check_generic_type([1, 1.0], List[int])
+
+    assert check_generic_type([1, 1.0], List[Union[int, float]]) is None
+    assert check_generic_type(None, Union[None, List[int]]) is None
+    assert check_generic_type([1, 2], Union[None, List[int]]) is None
```

