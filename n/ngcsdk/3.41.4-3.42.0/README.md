# Comparing `tmp/ngcsdk-3.41.4-py3-none-any.whl.zip` & `tmp/ngcsdk-3.42.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,25 +1,25 @@
-Zip file size: 2098749 bytes, number of entries: 1479
+Zip file size: 1579018 bytes, number of entries: 1041
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 basecommand/api/__init__.py
 -rw-r--r--  2.0 unx     5054 b- defN 80-Jan-01 00:00 basecommand/api/aces.py
 -rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 basecommand/api/basecommand.py
 -rw-r--r--  2.0 unx    17648 b- defN 80-Jan-01 00:00 basecommand/api/datamover.py
--rw-r--r--  2.0 unx    37715 b- defN 80-Jan-01 00:00 basecommand/api/dataset.py
+-rw-r--r--  2.0 unx    37721 b- defN 80-Jan-01 00:00 basecommand/api/dataset.py
 -rw-r--r--  2.0 unx    10766 b- defN 80-Jan-01 00:00 basecommand/api/dockerwrappers.py
 -rw-r--r--  2.0 unx    35840 b- defN 80-Jan-01 00:00 basecommand/api/jobs.py
 -rw-r--r--  2.0 unx     3348 b- defN 80-Jan-01 00:00 basecommand/api/kubewrappers.py
 -rw-r--r--  2.0 unx     6847 b- defN 80-Jan-01 00:00 basecommand/api/measurements.py
 -rw-r--r--  2.0 unx     1902 b- defN 80-Jan-01 00:00 basecommand/api/quickstart.py
--rw-r--r--  2.0 unx    36723 b- defN 80-Jan-01 00:00 basecommand/api/quickstart_cluster.py
--rw-r--r--  2.0 unx    21025 b- defN 80-Jan-01 00:00 basecommand/api/quickstart_project.py
+-rw-r--r--  2.0 unx    36782 b- defN 80-Jan-01 00:00 basecommand/api/quickstart_cluster.py
+-rw-r--r--  2.0 unx    21034 b- defN 80-Jan-01 00:00 basecommand/api/quickstart_project.py
 -rw-r--r--  2.0 unx    21946 b- defN 80-Jan-01 00:00 basecommand/api/resource.py
 -rw-r--r--  2.0 unx    14101 b- defN 80-Jan-01 00:00 basecommand/api/resultset.py
 -rw-r--r--  2.0 unx     3845 b- defN 80-Jan-01 00:00 basecommand/api/search.py
 -rw-r--r--  2.0 unx    11345 b- defN 80-Jan-01 00:00 basecommand/api/utils.py
--rw-r--r--  2.0 unx    29537 b- defN 80-Jan-01 00:00 basecommand/api/workspace.py
+-rw-r--r--  2.0 unx    29665 b- defN 80-Jan-01 00:00 basecommand/api/workspace.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 basecommand/command/__init__.py
 -rw-r--r--  2.0 unx     4173 b- defN 80-Jan-01 00:00 basecommand/command/aces.py
 -rw-r--r--  2.0 unx     1318 b- defN 80-Jan-01 00:00 basecommand/command/all_commands.py
 -rw-r--r--  2.0 unx    16025 b- defN 80-Jan-01 00:00 basecommand/command/args_validation.py
 -rw-r--r--  2.0 unx      680 b- defN 80-Jan-01 00:00 basecommand/command/base_command.py
 -rw-r--r--  2.0 unx    51055 b- defN 80-Jan-01 00:00 basecommand/command/batch.py
 -rw-r--r--  2.0 unx     1786 b- defN 80-Jan-01 00:00 basecommand/command/completers.py
@@ -28,20 +28,69 @@
 -rw-r--r--  2.0 unx     8911 b- defN 80-Jan-01 00:00 basecommand/command/datamover/export_dataset.py
 -rw-r--r--  2.0 unx     8976 b- defN 80-Jan-01 00:00 basecommand/command/datamover/export_workspace.py
 -rw-r--r--  2.0 unx    11086 b- defN 80-Jan-01 00:00 basecommand/command/datamover/import_dataset.py
 -rw-r--r--  2.0 unx    10720 b- defN 80-Jan-01 00:00 basecommand/command/datamover/import_workspace.py
 -rw-r--r--  2.0 unx    22299 b- defN 80-Jan-01 00:00 basecommand/command/datamover/utils.py
 -rw-r--r--  2.0 unx    21705 b- defN 80-Jan-01 00:00 basecommand/command/datamover_command.py
 -rw-r--r--  2.0 unx     1127 b- defN 80-Jan-01 00:00 basecommand/command/quickstart.py
--rw-r--r--  2.0 unx    30285 b- defN 80-Jan-01 00:00 basecommand/command/quickstart_cluster.py
--rw-r--r--  2.0 unx    44566 b- defN 80-Jan-01 00:00 basecommand/command/quickstart_project.py
+-rw-r--r--  2.0 unx    30309 b- defN 80-Jan-01 00:00 basecommand/command/quickstart_cluster.py
+-rw-r--r--  2.0 unx    44630 b- defN 80-Jan-01 00:00 basecommand/command/quickstart_project.py
 -rw-r--r--  2.0 unx    11402 b- defN 80-Jan-01 00:00 basecommand/command/resource.py
 -rw-r--r--  2.0 unx     7684 b- defN 80-Jan-01 00:00 basecommand/command/result.py
 -rw-r--r--  2.0 unx    21896 b- defN 80-Jan-01 00:00 basecommand/command/workspace.py
 -rw-r--r--  2.0 unx     3864 b- defN 80-Jan-01 00:00 basecommand/constants.py
+-rw-r--r--  2.0 unx     3174 b- defN 80-Jan-01 00:00 basecommand/data/pym/AdditionalOpenPortURLs.py
+-rw-r--r--  2.0 unx     3633 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterComponent.py
+-rw-r--r--  2.0 unx     6010 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterComponentModifyParams.py
+-rw-r--r--  2.0 unx     6742 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterComponentParams.py
+-rw-r--r--  2.0 unx     3019 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterCreateRequest.py
+-rw-r--r--  2.0 unx     7701 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterInfo.py
+-rw-r--r--  2.0 unx     3089 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterInfoResponse.py
+-rw-r--r--  2.0 unx     9539 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterInstance.py
+-rw-r--r--  2.0 unx     3490 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterInstanceInfo.py
+-rw-r--r--  2.0 unx     3365 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterInstanceTypesResponse.py
+-rw-r--r--  2.0 unx     3149 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterListResponse.py
+-rw-r--r--  2.0 unx    30037 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterModifyParams.py
+-rw-r--r--  2.0 unx     3333 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterModifyRequest.py
+-rw-r--r--  2.0 unx    30984 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterParams.py
+-rw-r--r--  2.0 unx     6221 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterPortMapping.py
+-rw-r--r--  2.0 unx    12789 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterRequestStatus.py
+-rw-r--r--  2.0 unx      191 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterStatusEnum.py
+-rw-r--r--  2.0 unx     3210 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterSuccessResponse.py
+-rw-r--r--  2.0 unx     3048 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterTelemetry.py
+-rw-r--r--  2.0 unx      102 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterTypeEnum.py
+-rw-r--r--  2.0 unx     5293 b- defN 80-Jan-01 00:00 basecommand/data/pym/ClusterURLs.py
+-rw-r--r--  2.0 unx     3188 b- defN 80-Jan-01 00:00 basecommand/data/pym/DataInput.py
+-rw-r--r--  2.0 unx     2982 b- defN 80-Jan-01 00:00 basecommand/data/pym/Dataset.py
+-rw-r--r--  2.0 unx     2943 b- defN 80-Jan-01 00:00 basecommand/data/pym/Env.py
+-rw-r--r--  2.0 unx     4484 b- defN 80-Jan-01 00:00 basecommand/data/pym/HealthInfoItem.py
+-rw-r--r--  2.0 unx     4004 b- defN 80-Jan-01 00:00 basecommand/data/pym/HealthResponse.py
+-rw-r--r--  2.0 unx     5276 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectCreateRequest.py
+-rw-r--r--  2.0 unx     7374 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectDetails.py
+-rw-r--r--  2.0 unx     4120 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectInfoResponse.py
+-rw-r--r--  2.0 unx     3119 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectListResponse.py
+-rw-r--r--  2.0 unx     2976 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectModifyParams.py
+-rw-r--r--  2.0 unx     3080 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectModifyRequest.py
+-rw-r--r--  2.0 unx     3303 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectParams.py
+-rw-r--r--  2.0 unx     4714 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectRequestStatus.py
+-rw-r--r--  2.0 unx     3210 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectSuccessResponse.py
+-rw-r--r--  2.0 unx     3129 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateCreateRequest.py
+-rw-r--r--  2.0 unx     5220 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateInfoResponse.py
+-rw-r--r--  2.0 unx     8708 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateListParams.py
+-rw-r--r--  2.0 unx     3224 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateListResponse.py
+-rw-r--r--  2.0 unx     3223 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateModificationRequest.py
+-rw-r--r--  2.0 unx     6830 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateModifyParams.py
+-rw-r--r--  2.0 unx     7106 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateParams.py
+-rw-r--r--  2.0 unx    17506 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateParamsDeprecated.py
+-rw-r--r--  2.0 unx     2752 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateRequestStatus.py
+-rw-r--r--  2.0 unx     3333 b- defN 80-Jan-01 00:00 basecommand/data/pym/ProjectTemplateSuccessResponse.py
+-rw-r--r--  2.0 unx     3314 b- defN 80-Jan-01 00:00 basecommand/data/pym/SecretKeySpec.py
+-rw-r--r--  2.0 unx     4057 b- defN 80-Jan-01 00:00 basecommand/data/pym/SecretSpec.py
+-rw-r--r--  2.0 unx     4074 b- defN 80-Jan-01 00:00 basecommand/data/pym/Workspace.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 basecommand/data/pym/__init__.py
 -rw-r--r--  2.0 unx      724 b- defN 80-Jan-01 00:00 basecommand/environ.py
 -rw-r--r--  2.0 unx      567 b- defN 80-Jan-01 00:00 basecommand/errors.py
 -rw-r--r--  2.0 unx     1695 b- defN 80-Jan-01 00:00 basecommand/model/dataset.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 basecommand/printer/__init__.py
 -rw-r--r--  2.0 unx    10016 b- defN 80-Jan-01 00:00 basecommand/printer/aces.py
 -rw-r--r--  2.0 unx    29561 b- defN 80-Jan-01 00:00 basecommand/printer/batch.py
 -rw-r--r--  2.0 unx    12360 b- defN 80-Jan-01 00:00 basecommand/printer/datamover.py
@@ -102,15 +151,15 @@
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 forge/printer/__init__.py
 -rw-r--r--  2.0 unx     6520 b- defN 80-Jan-01 00:00 forge/printer/allocation.py
 -rw-r--r--  2.0 unx     3765 b- defN 80-Jan-01 00:00 forge/printer/constraint.py
 -rw-r--r--  2.0 unx     6016 b- defN 80-Jan-01 00:00 forge/printer/infiniband.py
 -rw-r--r--  2.0 unx    14131 b- defN 80-Jan-01 00:00 forge/printer/instance.py
 -rw-r--r--  2.0 unx     9778 b- defN 80-Jan-01 00:00 forge/printer/instance_type.py
 -rw-r--r--  2.0 unx     5774 b- defN 80-Jan-01 00:00 forge/printer/ipblock.py
--rw-r--r--  2.0 unx     9515 b- defN 80-Jan-01 00:00 forge/printer/machine.py
+-rw-r--r--  2.0 unx     9883 b- defN 80-Jan-01 00:00 forge/printer/machine.py
 -rw-r--r--  2.0 unx     6805 b- defN 80-Jan-01 00:00 forge/printer/operating_system.py
 -rw-r--r--  2.0 unx     4861 b- defN 80-Jan-01 00:00 forge/printer/provider.py
 -rw-r--r--  2.0 unx     7019 b- defN 80-Jan-01 00:00 forge/printer/rule.py
 -rw-r--r--  2.0 unx     6497 b- defN 80-Jan-01 00:00 forge/printer/site.py
 -rw-r--r--  2.0 unx     4815 b- defN 80-Jan-01 00:00 forge/printer/ssh_key.py
 -rw-r--r--  2.0 unx     9171 b- defN 80-Jan-01 00:00 forge/printer/ssh_key_group.py
 -rw-r--r--  2.0 unx     6169 b- defN 80-Jan-01 00:00 forge/printer/subnet.py
@@ -128,15 +177,15 @@
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/command/__init__.py
 -rw-r--r--  2.0 unx    13108 b- defN 80-Jan-01 00:00 ngcbpc/command/args_validation.py
 -rw-r--r--  2.0 unx    14002 b- defN 80-Jan-01 00:00 ngcbpc/command/clicommand.py
 -rw-r--r--  2.0 unx     1540 b- defN 80-Jan-01 00:00 ngcbpc/command/completers.py
 -rw-r--r--  2.0 unx    24492 b- defN 80-Jan-01 00:00 ngcbpc/command/config.py
 -rw-r--r--  2.0 unx     4150 b- defN 80-Jan-01 00:00 ngcbpc/command/global_args.py
 -rw-r--r--  2.0 unx     9883 b- defN 80-Jan-01 00:00 ngcbpc/command/parser.py
--rw-r--r--  2.0 unx    12660 b- defN 80-Jan-01 00:00 ngcbpc/constants.py
+-rw-r--r--  2.0 unx    12815 b- defN 80-Jan-01 00:00 ngcbpc/constants.py
 -rw-r--r--  2.0 unx    29186 b- defN 80-Jan-01 00:00 ngcbpc/data/api/Ace.py
 -rw-r--r--  2.0 unx    24775 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceCreateRequest.py
 -rw-r--r--  2.0 unx     2612 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceHealth.py
 -rw-r--r--  2.0 unx    30841 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceInstance.py
 -rw-r--r--  2.0 unx     5090 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceInstancePrices.py
 -rw-r--r--  2.0 unx     3229 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceInstancePricesResponse.py
 -rw-r--r--  2.0 unx      108 b- defN 80-Jan-01 00:00 ngcbpc/data/api/AceInstanceTypeEnum.py
@@ -410,14 +459,213 @@
 -rw-r--r--  2.0 unx     4112 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WebhookListResponse.py
 -rw-r--r--  2.0 unx     2860 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WebhookResponse.py
 -rw-r--r--  2.0 unx     5270 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WorkspaceCreateRequest.py
 -rw-r--r--  2.0 unx     5272 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WorkspaceListResponse.py
 -rw-r--r--  2.0 unx     3019 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WorkspaceResponse.py
 -rw-r--r--  2.0 unx     3430 b- defN 80-Jan-01 00:00 ngcbpc/data/api/WorkspaceUpdateRequest.py
 -rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngcbpc/data/api/__init__.py
+-rw-r--r--  2.0 unx     7525 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AIFoundationModel.py
+-rw-r--r--  2.0 unx     4299 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AIPlaygroundCreateRequest.py
+-rw-r--r--  2.0 unx     7548 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AIPlaygroundResponse.py
+-rw-r--r--  2.0 unx     3461 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AIPlaygroundUpdateRequest.py
+-rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AccessTypeEnum.py
+-rw-r--r--  2.0 unx      552 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ApplicationType.py
+-rw-r--r--  2.0 unx    24085 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Artifact.py
+-rw-r--r--  2.0 unx     3124 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactAttribute.py
+-rw-r--r--  2.0 unx     3524 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactCatalogFlags.py
+-rw-r--r--  2.0 unx    15113 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactCreateRequest.py
+-rw-r--r--  2.0 unx     9003 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactDeploymentParameters.py
+-rw-r--r--  2.0 unx     3853 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactDownloadAllRequest.py
+-rw-r--r--  2.0 unx     5910 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactDownloadAllResponse.py
+-rw-r--r--  2.0 unx     4808 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactDownloadRequest.py
+-rw-r--r--  2.0 unx     3732 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactDownloadResponse.py
+-rw-r--r--  2.0 unx     5414 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactEvent.py
+-rw-r--r--  2.0 unx     4148 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactListResponse.py
+-rw-r--r--  2.0 unx     4967 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactPublishRequest.py
+-rw-r--r--  2.0 unx     2961 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactResponse.py
+-rw-r--r--  2.0 unx      146 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactTypeEnum.py
+-rw-r--r--  2.0 unx    13199 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactUpdateRequest.py
+-rw-r--r--  2.0 unx    10576 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersion.py
+-rw-r--r--  2.0 unx     3799 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersionCreateRequest.py
+-rw-r--r--  2.0 unx     6261 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersionFileListResponse.py
+-rw-r--r--  2.0 unx     5241 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersionListResponse.py
+-rw-r--r--  2.0 unx     4083 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersionResponse.py
+-rw-r--r--  2.0 unx     3979 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ArtifactVersionUpdateRequest.py
+-rw-r--r--  2.0 unx    19418 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Asset.py
+-rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetCdnProviderTypeEnum.py
+-rw-r--r--  2.0 unx     2864 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetResponse.py
+-rw-r--r--  2.0 unx     3575 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetSimplified.py
+-rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetStatusTypeEnum.py
+-rw-r--r--  2.0 unx     4470 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetStorageEvent.py
+-rw-r--r--  2.0 unx       97 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetStorageTypeEnum.py
+-rw-r--r--  2.0 unx     7178 b- defN 80-Jan-01 00:00 ngcbpc/data/model/AssetUpdateRequest.py
+-rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CatalogArtifactMetadata.py
+-rw-r--r--  2.0 unx     3994 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloneArtifactVersionFilesRequest.py
+-rw-r--r--  2.0 unx     3916 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloneableArtifact.py
+-rw-r--r--  2.0 unx    10280 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloudServiceProvider.py
+-rw-r--r--  2.0 unx     6963 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloudServiceProviderCreateRequest.py
+-rw-r--r--  2.0 unx     4414 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloudServiceProviderListResponse.py
+-rw-r--r--  2.0 unx     6037 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CloudServiceProviderUpdateRequest.py
+-rw-r--r--  2.0 unx    18935 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Collection.py
+-rw-r--r--  2.0 unx      510 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionCategoryType.py
+-rw-r--r--  2.0 unx    13636 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionCreateRequest.py
+-rw-r--r--  2.0 unx     4192 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionListResponse.py
+-rw-r--r--  2.0 unx     3343 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionOperation.py
+-rw-r--r--  2.0 unx      131 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionOperationType.py
+-rw-r--r--  2.0 unx     2338 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionPatchRequest.py
+-rw-r--r--  2.0 unx     4970 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionPublishRequest.py
+-rw-r--r--  2.0 unx     3020 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionResponse.py
+-rw-r--r--  2.0 unx     3610 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionSimplified.py
+-rw-r--r--  2.0 unx    11520 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CollectionUpdateRequest.py
+-rw-r--r--  2.0 unx     3329 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CountableResource.py
+-rw-r--r--  2.0 unx     2799 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CustomMetric.py
+-rw-r--r--  2.0 unx     3003 b- defN 80-Jan-01 00:00 ngcbpc/data/model/CustomMetricGroup.py
+-rw-r--r--  2.0 unx     3803 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Dataset.py
+-rw-r--r--  2.0 unx     6861 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentArtifactParameters.py
+-rw-r--r--  2.0 unx     1683 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentCpuParameters.py
+-rw-r--r--  2.0 unx     2160 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentCpuParametersMeta.py
+-rw-r--r--  2.0 unx     2387 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentGpuParameters.py
+-rw-r--r--  2.0 unx     3127 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentGpuParametersMeta.py
+-rw-r--r--  2.0 unx     1787 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentMemoryParameters.py
+-rw-r--r--  2.0 unx     2288 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentMemoryParametersMeta.py
+-rw-r--r--  2.0 unx     8995 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParameters.py
+-rw-r--r--  2.0 unx     8305 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersCreateRequest.py
+-rw-r--r--  2.0 unx     6237 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersListResponse.py
+-rw-r--r--  2.0 unx     6125 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersMeta.py
+-rw-r--r--  2.0 unx     5840 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersMetaCreateRequest.py
+-rw-r--r--  2.0 unx     5216 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersMetaListResponse.py
+-rw-r--r--  2.0 unx     5458 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersMetaUpdateRequest.py
+-rw-r--r--  2.0 unx     8308 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentParametersUpdateRequest.py
+-rw-r--r--  2.0 unx     1789 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentStorageParameters.py
+-rw-r--r--  2.0 unx     2291 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentStorageParametersMeta.py
+-rw-r--r--  2.0 unx     8291 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentUrlCreateRequest.py
+-rw-r--r--  2.0 unx     4823 b- defN 80-Jan-01 00:00 ngcbpc/data/model/DeploymentUrlResponse.py
+-rw-r--r--  2.0 unx     2941 b- defN 80-Jan-01 00:00 ngcbpc/data/model/EnumerableResource.py
+-rw-r--r--  2.0 unx     3164 b- defN 80-Jan-01 00:00 ngcbpc/data/model/EnumerableResourceItem.py
+-rw-r--r--  2.0 unx     6436 b- defN 80-Jan-01 00:00 ngcbpc/data/model/File.py
+-rw-r--r--  2.0 unx      197 b- defN 80-Jan-01 00:00 ngcbpc/data/model/FrameworkType.py
+-rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Health.py
+-rw-r--r--  2.0 unx     1989 b- defN 80-Jan-01 00:00 ngcbpc/data/model/HealthResponse.py
+-rw-r--r--  2.0 unx     3845 b- defN 80-Jan-01 00:00 ngcbpc/data/model/HelmChartDependency.py
+-rw-r--r--  2.0 unx     3171 b- defN 80-Jan-01 00:00 ngcbpc/data/model/HelmChartMaintainer.py
+-rw-r--r--  2.0 unx    12667 b- defN 80-Jan-01 00:00 ngcbpc/data/model/HelmChartVersion.py
+-rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngcbpc/data/model/MetaData.py
+-rw-r--r--  2.0 unx    30696 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Model.py
+-rw-r--r--  2.0 unx    22262 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelCreateRequest.py
+-rw-r--r--  2.0 unx     2882 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelCreateResponse.py
+-rw-r--r--  2.0 unx     5242 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelFile.py
+-rw-r--r--  2.0 unx      221 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelFormatType.py
+-rw-r--r--  2.0 unx     4063 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelListResponse.py
+-rw-r--r--  2.0 unx     2871 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelResponse.py
+-rw-r--r--  2.0 unx     3575 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelSimplified.py
+-rw-r--r--  2.0 unx    20197 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelUpdateRequest.py
+-rw-r--r--  2.0 unx    15426 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersion.py
+-rw-r--r--  2.0 unx    13578 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionCreateRequest.py
+-rw-r--r--  2.0 unx     3924 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionCreateResponse.py
+-rw-r--r--  2.0 unx     6072 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionFileListResponse.py
+-rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionListResponse.py
+-rw-r--r--  2.0 unx     3923 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionResponse.py
+-rw-r--r--  2.0 unx    12069 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ModelVersionUpdateRequest.py
+-rw-r--r--  2.0 unx     5878 b- defN 80-Jan-01 00:00 ngcbpc/data/model/MultipartUploadAbortRequest.py
+-rw-r--r--  2.0 unx     6906 b- defN 80-Jan-01 00:00 ngcbpc/data/model/MultipartUploadCompleteRequest.py
+-rw-r--r--  2.0 unx     7401 b- defN 80-Jan-01 00:00 ngcbpc/data/model/MultipartUploadCreateRequest.py
+-rw-r--r--  2.0 unx     6049 b- defN 80-Jan-01 00:00 ngcbpc/data/model/MultipartUploadCreateResponse.py
+-rw-r--r--  2.0 unx     4827 b- defN 80-Jan-01 00:00 ngcbpc/data/model/PaginationInfo.py
+-rw-r--r--  2.0 unx      130 b- defN 80-Jan-01 00:00 ngcbpc/data/model/PrecisionType.py
+-rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 ngcbpc/data/model/ProductNamesEnum.py
+-rw-r--r--  2.0 unx    27541 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Recipe.py
+-rw-r--r--  2.0 unx    19453 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeCreateRequest.py
+-rw-r--r--  2.0 unx     5249 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeFile.py
+-rw-r--r--  2.0 unx     4085 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeListResponse.py
+-rw-r--r--  2.0 unx     2890 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeResponse.py
+-rw-r--r--  2.0 unx    17702 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeUpdateRequest.py
+-rw-r--r--  2.0 unx    17930 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersion.py
+-rw-r--r--  2.0 unx    15539 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersionCreateRequest.py
+-rw-r--r--  2.0 unx     6142 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersionFileListResponse.py
+-rw-r--r--  2.0 unx     5130 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersionListResponse.py
+-rw-r--r--  2.0 unx     3964 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersionResponse.py
+-rw-r--r--  2.0 unx    14027 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RecipeVersionUpdateRequest.py
+-rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 ngcbpc/data/model/RequestStatus.py
+-rw-r--r--  2.0 unx     1976 b- defN 80-Jan-01 00:00 ngcbpc/data/model/Response.py
+-rw-r--r--  2.0 unx      358 b- defN 80-Jan-01 00:00 ngcbpc/data/model/SortOrderEnum.py
+-rw-r--r--  2.0 unx      359 b- defN 80-Jan-01 00:00 ngcbpc/data/model/StatusCode.py
+-rw-r--r--  2.0 unx      121 b- defN 80-Jan-01 00:00 ngcbpc/data/model/VersionStatusEnum.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngcbpc/data/model/__init__.py
+-rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AccessTypeEnum.py
+-rw-r--r--  2.0 unx     1719 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Actor.py
+-rw-r--r--  2.0 unx     4859 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Allowlist.py
+-rw-r--r--  2.0 unx     3193 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AllowlistItem.py
+-rw-r--r--  2.0 unx     4036 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Analysis.py
+-rw-r--r--  2.0 unx      139 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AnalysisStatus.py
+-rw-r--r--  2.0 unx     2347 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AnchoreParameter.py
+-rw-r--r--  2.0 unx     9910 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AnchorePolicyBundle.py
+-rw-r--r--  2.0 unx     6971 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/AnchorePolicyBundleRecord.py
+-rw-r--r--  2.0 unx     5543 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/BaseImageDetails.py
+-rw-r--r--  2.0 unx     1732 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/BaseImageList.py
+-rw-r--r--  2.0 unx     2142 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/BaseImagesDetailResponse.py
+-rw-r--r--  2.0 unx     1666 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/BlobSum.py
+-rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/CatalogArtifactMetadata.py
+-rw-r--r--  2.0 unx     2020 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Envelope.py
+-rw-r--r--  2.0 unx     4956 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/EventRequest.py
+-rw-r--r--  2.0 unx     2664 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/EventSource.py
+-rw-r--r--  2.0 unx     6419 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/EventTarget.py
+-rw-r--r--  2.0 unx     8208 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/GetManifestByTagResponse.py
+-rw-r--r--  2.0 unx     3749 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/GetRepositoryTagVexResponse.py
+-rw-r--r--  2.0 unx     3392 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/GetTagsResponse.py
+-rw-r--r--  2.0 unx     2451 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Header.py
+-rw-r--r--  2.0 unx     1797 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/HistoryLayer.py
+-rw-r--r--  2.0 unx     8463 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageArchitectureVariant.py
+-rw-r--r--  2.0 unx     2972 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageDeleteRequest.py
+-rw-r--r--  2.0 unx     8722 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageOwnerDetails.py
+-rw-r--r--  2.0 unx     2342 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageRef.py
+-rw-r--r--  2.0 unx    10863 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageScanDetails.py
+-rw-r--r--  2.0 unx     4699 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageSelectionRule.py
+-rw-r--r--  2.0 unx     2557 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ImageSignature.py
+-rw-r--r--  2.0 unx     4468 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Jwk.py
+-rw-r--r--  2.0 unx     7637 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ManifestByTagV2Response.py
+-rw-r--r--  2.0 unx     4764 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ManifestListByTagV2Response.py
+-rw-r--r--  2.0 unx     3209 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ManifestV2Config.py
+-rw-r--r--  2.0 unx     3186 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ManifestV2Layer.py
+-rw-r--r--  2.0 unx     6468 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/MappingRule.py
+-rw-r--r--  2.0 unx    12531 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/MetaImageDetails.py
+-rw-r--r--  2.0 unx     5927 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/MetaImageDetailsList.py
+-rw-r--r--  2.0 unx     3998 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/OciIndexManifest.py
+-rw-r--r--  2.0 unx     4703 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/OciIndexResponse.py
+-rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/PaginationInfo.py
+-rw-r--r--  2.0 unx     4309 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Platform.py
+-rw-r--r--  2.0 unx     4840 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/PlatformManifest.py
+-rw-r--r--  2.0 unx     4845 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/PolicyRule.py
+-rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ProductNamesEnum.py
+-rw-r--r--  2.0 unx     6858 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RegistryEvent.py
+-rw-r--r--  2.0 unx    27728 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Repository.py
+-rw-r--r--  2.0 unx    11157 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryCreateRequest.py
+-rw-r--r--  2.0 unx    11907 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryImageDetails.py
+-rw-r--r--  2.0 unx     4159 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryImageDetailsList.py
+-rw-r--r--  2.0 unx     5902 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryImageScanComplete.py
+-rw-r--r--  2.0 unx     4440 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryImagesDeletedEvent.py
+-rw-r--r--  2.0 unx    16048 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryInfoUpdateRequest.py
+-rw-r--r--  2.0 unx     1677 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryLabelsPatchRequest.py
+-rw-r--r--  2.0 unx     4182 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryList.py
+-rw-r--r--  2.0 unx     2672 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryTagVexByDigest.py
+-rw-r--r--  2.0 unx     2528 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryTagVexDetail.py
+-rw-r--r--  2.0 unx     2758 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RepositoryTagsCountResponse.py
+-rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RequestStatus.py
+-rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/Response.py
+-rw-r--r--  2.0 unx     4870 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/RuleSet.py
+-rw-r--r--  2.0 unx     7489 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ScanIssue.py
+-rw-r--r--  2.0 unx     2486 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ScanIssueCount.py
+-rw-r--r--  2.0 unx      137 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ScanIssueSeverity.py
+-rw-r--r--  2.0 unx      138 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ScanStatus.py
+-rw-r--r--  2.0 unx      102 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/ScanType.py
+-rw-r--r--  2.0 unx     7621 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/SecurityRatingDescription.py
+-rw-r--r--  2.0 unx      119 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/SecurityRatingType.py
+-rw-r--r--  2.0 unx     2081 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/SecurityRatingsResponse.py
+-rw-r--r--  2.0 unx      317 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/StatusCode.py
+-rw-r--r--  2.0 unx     1766 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/TagUpdateRequest.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngcbpc/data/registry/__init__.py
 -rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngcbpc/data/search/AccessTypeEnum.py
 -rw-r--r--  2.0 unx     3344 b- defN 80-Jan-01 00:00 ngcbpc/data/search/CountParams.py
 -rw-r--r--  2.0 unx     3146 b- defN 80-Jan-01 00:00 ngcbpc/data/search/CountParamsField.py
 -rw-r--r--  2.0 unx     3360 b- defN 80-Jan-01 00:00 ngcbpc/data/search/CountResponse.py
 -rw-r--r--  2.0 unx     4031 b- defN 80-Jan-01 00:00 ngcbpc/data/search/CountResponseCount.py
 -rw-r--r--  2.0 unx     2046 b- defN 80-Jan-01 00:00 ngcbpc/data/search/CountResponseParams.py
 -rw-r--r--  2.0 unx     4468 b- defN 80-Jan-01 00:00 ngcbpc/data/search/Health.py
@@ -448,31 +696,131 @@
 -rw-r--r--  2.0 unx    10137 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchParams.py
 -rw-r--r--  2.0 unx     3716 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchPopularityUpdateQueueMsg.py
 -rw-r--r--  2.0 unx     3224 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchQueueMsg.py
 -rw-r--r--  2.0 unx     5330 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchResponse.py
 -rw-r--r--  2.0 unx     4724 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchResponseResult.py
 -rw-r--r--  2.0 unx    22530 b- defN 80-Jan-01 00:00 ngcbpc/data/search/SearchResponseResultResource.py
 -rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngcbpc/data/search/__init__.py
+-rw-r--r--  2.0 unx     9513 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/AccountInfo.py
+-rw-r--r--  2.0 unx     1859 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/AddRolesRequest.py
+-rw-r--r--  2.0 unx     3615 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/AlternateContact.py
+-rw-r--r--  2.0 unx     9270 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKey.py
+-rw-r--r--  2.0 unx     5026 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKeyPolicy.py
+-rw-r--r--  2.0 unx     4981 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKeyRequest.py
+-rw-r--r--  2.0 unx     2848 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKeyResponse.py
+-rw-r--r--  2.0 unx      113 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKeyStatusEnum.py
+-rw-r--r--  2.0 unx      144 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ApiKeyTypeEnum.py
+-rw-r--r--  2.0 unx     4899 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/CreateBillingAccountRequest.py
+-rw-r--r--  2.0 unx     3418 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/CreateBillingAccountResponse.py
+-rw-r--r--  2.0 unx     1864 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/CreateUserRolesRequest.py
+-rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/EmailTemplateDataSourceEnum.py
+-rw-r--r--  2.0 unx      305 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/EmailTemplateTypeEnum.py
+-rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ErrorResponse.py
+-rw-r--r--  2.0 unx     2690 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/GetUchIdByOrgResponse.py
+-rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/Health.py
+-rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/HealthResponse.py
+-rw-r--r--  2.0 unx     7085 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpLock.py
+-rw-r--r--  2.0 unx     3320 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpLockResponse.py
+-rw-r--r--  2.0 unx    10866 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpRule.py
+-rw-r--r--  2.0 unx     4541 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpRuleListResponse.py
+-rw-r--r--  2.0 unx     4778 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpRuleRequest.py
+-rw-r--r--  2.0 unx     3295 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/IdpRuleResponse.py
+-rw-r--r--  2.0 unx     2720 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/InfinityManagerSettings.py
+-rw-r--r--  2.0 unx     2975 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ListApiKeysResponse.py
+-rw-r--r--  2.0 unx     2774 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ListRolesResponse.py
+-rw-r--r--  2.0 unx     4307 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ListUserRolesResponse.py
+-rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/MetaData.py
+-rw-r--r--  2.0 unx     4868 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfCluster.py
+-rw-r--r--  2.0 unx     6570 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfGpuUsage.py
+-rw-r--r--  2.0 unx     2013 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfGpuUsageRequest.py
+-rw-r--r--  2.0 unx     3039 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfGpuUsageResponse.py
+-rw-r--r--  2.0 unx     5013 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfOrgResponse.py
+-rw-r--r--  2.0 unx     2013 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/NvcfOrgUpdateRequest.py
+-rw-r--r--  2.0 unx     3446 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgAdminUserCreatedEvent.py
+-rw-r--r--  2.0 unx     4197 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgListResponse.py
+-rw-r--r--  2.0 unx     5428 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgOwner.py
+-rw-r--r--  2.0 unx     3126 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgOwnerUpdateRequest.py
+-rw-r--r--  2.0 unx     4150 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgOwnersResponse.py
+-rw-r--r--  2.0 unx     3459 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgProfileUpdateRequest.py
+-rw-r--r--  2.0 unx      118 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgType.py
+-rw-r--r--  2.0 unx    19528 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/OrgUpdateRequest.py
+-rw-r--r--  2.0 unx    25089 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/Organization.py
+-rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/PaginationInfo.py
+-rw-r--r--  2.0 unx     5273 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ProductEnablement.py
+-rw-r--r--  2.0 unx     7235 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ProductSubscription.py
+-rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/PurchaseOrder.py
+-rw-r--r--  2.0 unx     1872 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RemoveRolesRequest.py
+-rw-r--r--  2.0 unx    11504 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RemovedUser.py
+-rw-r--r--  2.0 unx     4132 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RemovedUserListResponse.py
+-rw-r--r--  2.0 unx     6724 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RepoScanSettings.py
+-rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RequestStatus.py
+-rw-r--r--  2.0 unx     2320 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/Resource.py
+-rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/Response.py
+-rw-r--r--  2.0 unx     3890 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RoleScopes.py
+-rw-r--r--  2.0 unx     2034 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RoleScopesRequest.py
+-rw-r--r--  2.0 unx     3060 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RoleScopesResponse.py
+-rw-r--r--  2.0 unx     1726 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RoleType.py
+-rw-r--r--  2.0 unx     1940 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/RotateApiKeyRequest.py
+-rw-r--r--  2.0 unx     1975 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/SakCallerInfoRequest.py
+-rw-r--r--  2.0 unx     5852 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/SakCallerInfoResponse.py
+-rw-r--r--  2.0 unx     9736 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/SendTemplatedEmailRequest.py
+-rw-r--r--  2.0 unx     3012 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/ServiceAccess.py
+-rw-r--r--  2.0 unx      450 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/StatusCode.py
+-rw-r--r--  2.0 unx     5648 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TargetSystemUserIdentifier.py
+-rw-r--r--  2.0 unx     6353 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/Team.py
+-rw-r--r--  2.0 unx     3756 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamCreateRequest.py
+-rw-r--r--  2.0 unx     2856 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamCreateResponse.py
+-rw-r--r--  2.0 unx     3332 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamCreatedEvent.py
+-rw-r--r--  2.0 unx     4017 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamListResponse.py
+-rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamResponse.py
+-rw-r--r--  2.0 unx     4496 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/TeamUpdateRequest.py
+-rw-r--r--  2.0 unx     3032 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UisOrgInfoResponse.py
+-rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UpdateApiKeyRequest.py
+-rw-r--r--  2.0 unx     4360 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UpdateUisOrgInfoRequest.py
+-rw-r--r--  2.0 unx    33471 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/User.py
+-rw-r--r--  2.0 unx     9435 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserCreateRequest.py
+-rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserCreatedEvent.py
+-rw-r--r--  2.0 unx      136 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserGdprStatus.py
+-rw-r--r--  2.0 unx      164 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserIdentifierType.py
+-rw-r--r--  2.0 unx     9651 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserInvitation.py
+-rw-r--r--  2.0 unx     4231 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserInvitationListResponse.py
+-rw-r--r--  2.0 unx     2988 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserInvitationResponse.py
+-rw-r--r--  2.0 unx     5560 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserKeyResponse.py
+-rw-r--r--  2.0 unx     4058 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserListResponse.py
+-rw-r--r--  2.0 unx     8112 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserMetadata.py
+-rw-r--r--  2.0 unx    11401 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserProfile.py
+-rw-r--r--  2.0 unx     3002 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserProfileGetResponse.py
+-rw-r--r--  2.0 unx     5170 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserProfileOrgInfo.py
+-rw-r--r--  2.0 unx     1982 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserProfileUpdateRequest.py
+-rw-r--r--  2.0 unx     4806 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserResponse.py
+-rw-r--r--  2.0 unx     6556 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserRole.py
+-rw-r--r--  2.0 unx     2808 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserRoleDefinition.py
+-rw-r--r--  2.0 unx     5029 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserRoles.py
+-rw-r--r--  2.0 unx      112 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserStatus.py
+-rw-r--r--  2.0 unx    12800 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserStorageQuota.py
+-rw-r--r--  2.0 unx    22375 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UserUpdateRequest.py
+-rw-r--r--  2.0 unx     1718 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/UsersInfo.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngcbpc/data/uis/__init__.py
 -rw-r--r--  2.0 unx     7202 b- defN 80-Jan-01 00:00 ngcbpc/environ.py
 -rw-r--r--  2.0 unx     4487 b- defN 80-Jan-01 00:00 ngcbpc/errors.py
 -rw-r--r--  2.0 unx     1910 b- defN 80-Jan-01 00:00 ngcbpc/expiring_cache.py
 -rw-r--r--  2.0 unx     1847 b- defN 80-Jan-01 00:00 ngcbpc/logger.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/printer/__init__.py
--rw-r--r--  2.0 unx     1743 b- defN 80-Jan-01 00:00 ngcbpc/printer/config.py
+-rw-r--r--  2.0 unx     1729 b- defN 80-Jan-01 00:00 ngcbpc/printer/config.py
 -rw-r--r--  2.0 unx     7896 b- defN 80-Jan-01 00:00 ngcbpc/printer/formatter.py
 -rw-r--r--  2.0 unx    37160 b- defN 80-Jan-01 00:00 ngcbpc/printer/nvPrettyPrint.py
 -rw-r--r--  2.0 unx     4672 b- defN 80-Jan-01 00:00 ngcbpc/printer/prettytableWrap.py
 -rw-r--r--  2.0 unx    10068 b- defN 80-Jan-01 00:00 ngcbpc/printer/transfer.py
 -rw-r--r--  2.0 unx     1337 b- defN 80-Jan-01 00:00 ngcbpc/printer/utils.py
 -rw-r--r--  2.0 unx     1065 b- defN 80-Jan-01 00:00 ngcbpc/singleton.py
 -rw-r--r--  2.0 unx      920 b- defN 80-Jan-01 00:00 ngcbpc/timer.py
--rw-r--r--  2.0 unx    11890 b- defN 80-Jan-01 00:00 ngcbpc/tracing.py
+-rw-r--r--  2.0 unx    11921 b- defN 80-Jan-01 00:00 ngcbpc/tracing.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/transfer/__init__.py
 -rw-r--r--  2.0 unx    23268 b- defN 80-Jan-01 00:00 ngcbpc/transfer/adapter.py
--rw-r--r--  2.0 unx    38256 b- defN 80-Jan-01 00:00 ngcbpc/transfer/async_download.py
+-rw-r--r--  2.0 unx    38485 b- defN 80-Jan-01 00:00 ngcbpc/transfer/async_download.py
 -rw-r--r--  2.0 unx     7787 b- defN 80-Jan-01 00:00 ngcbpc/transfer/controller.py
 -rw-r--r--  2.0 unx    22885 b- defN 80-Jan-01 00:00 ngcbpc/transfer/download.py
 -rw-r--r--  2.0 unx     3925 b- defN 80-Jan-01 00:00 ngcbpc/transfer/file_cache.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/transfer/grpc/__init__.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/transfer/grpc/proto_py/__init__.py
 -rw-r--r--  2.0 unx    33874 b- defN 80-Jan-01 00:00 ngcbpc/transfer/grpc/proto_py/upload_pb2.py
 -rw-r--r--  2.0 unx     4636 b- defN 80-Jan-01 00:00 ngcbpc/transfer/grpc/proto_py/upload_pb2_grpc.py
@@ -485,981 +833,195 @@
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 ngcbpc/util/__init__.py
 -rw-r--r--  2.0 unx     1261 b- defN 80-Jan-01 00:00 ngcbpc/util/base_utils.py
 -rw-r--r--  2.0 unx     5076 b- defN 80-Jan-01 00:00 ngcbpc/util/datetime_utils.py
 -rw-r--r--  2.0 unx      729 b- defN 80-Jan-01 00:00 ngcbpc/util/db_util.py
 -rw-r--r--  2.0 unx    16838 b- defN 80-Jan-01 00:00 ngcbpc/util/file_utils.py
 -rw-r--r--  2.0 unx     5095 b- defN 80-Jan-01 00:00 ngcbpc/util/io_utils.py
 -rw-r--r--  2.0 unx     5457 b- defN 80-Jan-01 00:00 ngcbpc/util/ssh_utils.py
--rw-r--r--  2.0 unx    18125 b- defN 80-Jan-01 00:00 ngcbpc/util/utils.py
--rw-r--r--  2.0 unx    29186 b- defN 80-Jan-01 00:00 ngccli/data/api/Ace.py
--rw-r--r--  2.0 unx    24775 b- defN 80-Jan-01 00:00 ngccli/data/api/AceCreateRequest.py
--rw-r--r--  2.0 unx     2612 b- defN 80-Jan-01 00:00 ngccli/data/api/AceHealth.py
--rw-r--r--  2.0 unx    30841 b- defN 80-Jan-01 00:00 ngccli/data/api/AceInstance.py
--rw-r--r--  2.0 unx     5090 b- defN 80-Jan-01 00:00 ngccli/data/api/AceInstancePrices.py
--rw-r--r--  2.0 unx     3229 b- defN 80-Jan-01 00:00 ngccli/data/api/AceInstancePricesResponse.py
--rw-r--r--  2.0 unx      108 b- defN 80-Jan-01 00:00 ngccli/data/api/AceInstanceTypeEnum.py
--rw-r--r--  2.0 unx     4010 b- defN 80-Jan-01 00:00 ngccli/data/api/AceListResponse.py
--rw-r--r--  2.0 unx     1979 b- defN 80-Jan-01 00:00 ngccli/data/api/AceNodeRemapRequest.py
--rw-r--r--  2.0 unx      124 b- defN 80-Jan-01 00:00 ngccli/data/api/AceProvider.py
--rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngccli/data/api/AceResponse.py
--rw-r--r--  2.0 unx     3191 b- defN 80-Jan-01 00:00 ngccli/data/api/AceSimplified.py
--rw-r--r--  2.0 unx    10624 b- defN 80-Jan-01 00:00 ngccli/data/api/AceStorageInfo.py
--rw-r--r--  2.0 unx      104 b- defN 80-Jan-01 00:00 ngccli/data/api/AceType.py
--rw-r--r--  2.0 unx    26375 b- defN 80-Jan-01 00:00 ngccli/data/api/AceUpdate.py
--rw-r--r--  2.0 unx      120 b- defN 80-Jan-01 00:00 ngccli/data/api/AlertAggregationType.py
--rw-r--r--  2.0 unx     5118 b- defN 80-Jan-01 00:00 ngccli/data/api/AlertDeliveryMode.py
--rw-r--r--  2.0 unx     3615 b- defN 80-Jan-01 00:00 ngccli/data/api/AlternateContact.py
--rw-r--r--  2.0 unx     4036 b- defN 80-Jan-01 00:00 ngccli/data/api/Analysis.py
--rw-r--r--  2.0 unx     9458 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogs.py
--rw-r--r--  2.0 unx     8488 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogsEventRequest.py
--rw-r--r--  2.0 unx     7632 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogsEventResponse.py
--rw-r--r--  2.0 unx     2955 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogsPresignedUrlResponse.py
--rw-r--r--  2.0 unx     3025 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogsRequest.py
--rw-r--r--  2.0 unx     3108 b- defN 80-Jan-01 00:00 ngccli/data/api/AuditLogsResponse.py
--rw-r--r--  2.0 unx     4895 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEvent.py
--rw-r--r--  2.0 unx     7317 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventCreateRequest.py
--rw-r--r--  2.0 unx    12130 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventCreateResponse.py
--rw-r--r--  2.0 unx     9626 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventIncident.py
--rw-r--r--  2.0 unx     8611 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventIncidentMeta.py
--rw-r--r--  2.0 unx      232 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventIncidentSeverityEnum.py
--rw-r--r--  2.0 unx      247 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventIncidentStatusEnum.py
--rw-r--r--  2.0 unx     3818 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventListResponse.py
--rw-r--r--  2.0 unx     3707 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventResponse.py
--rw-r--r--  2.0 unx      101 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventTypeEnum.py
--rw-r--r--  2.0 unx     6022 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventUpdateRequest.py
--rw-r--r--  2.0 unx    12125 b- defN 80-Jan-01 00:00 ngccli/data/api/BannerEventUpdateResponse.py
--rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 ngccli/data/api/BatchResourceTypeEnum.py
--rw-r--r--  2.0 unx     2483 b- defN 80-Jan-01 00:00 ngccli/data/api/CelestialErrorDetail.py
--rw-r--r--  2.0 unx     1925 b- defN 80-Jan-01 00:00 ngccli/data/api/CelestialFilters.py
--rw-r--r--  2.0 unx     7598 b- defN 80-Jan-01 00:00 ngccli/data/api/ConfigRequest.py
--rw-r--r--  2.0 unx     2996 b- defN 80-Jan-01 00:00 ngccli/data/api/ContainerResources.py
--rw-r--r--  2.0 unx     1755 b- defN 80-Jan-01 00:00 ngccli/data/api/CreditsHistory.py
--rw-r--r--  2.0 unx     3029 b- defN 80-Jan-01 00:00 ngccli/data/api/CreditsHistoryResponse.py
--rw-r--r--  2.0 unx       90 b- defN 80-Jan-01 00:00 ngccli/data/api/CurrencyCode.py
--rw-r--r--  2.0 unx    25858 b- defN 80-Jan-01 00:00 ngccli/data/api/Dataset.py
--rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetAddFilesRequest.py
--rw-r--r--  2.0 unx     8227 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetCreateRequest.py
--rw-r--r--  2.0 unx     6081 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetFile.py
--rw-r--r--  2.0 unx     1986 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetFileBatch.py
--rw-r--r--  2.0 unx     5944 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetFileEventRequest.py
--rw-r--r--  2.0 unx     2496 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetFilePath.py
--rw-r--r--  2.0 unx     5248 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetListResponse.py
--rw-r--r--  2.0 unx     5075 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetResponse.py
--rw-r--r--  2.0 unx    20617 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetSimplified.py
--rw-r--r--  2.0 unx      121 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetStatusEnum.py
--rw-r--r--  2.0 unx     7497 b- defN 80-Jan-01 00:00 ngccli/data/api/DatasetUpdateRequest.py
--rw-r--r--  2.0 unx     3632 b- defN 80-Jan-01 00:00 ngccli/data/api/DeviceLoginRequest.py
--rw-r--r--  2.0 unx     4215 b- defN 80-Jan-01 00:00 ngccli/data/api/DeviceLoginResponse.py
--rw-r--r--  2.0 unx     3313 b- defN 80-Jan-01 00:00 ngccli/data/api/DownloadTokenMetadata.py
--rw-r--r--  2.0 unx     6748 b- defN 80-Jan-01 00:00 ngccli/data/api/EarlyAccessOrgCreateRequest.py
--rw-r--r--  2.0 unx     5681 b- defN 80-Jan-01 00:00 ngccli/data/api/Entitlement.py
--rw-r--r--  2.0 unx     3397 b- defN 80-Jan-01 00:00 ngccli/data/api/EntitlementProduct.py
--rw-r--r--  2.0 unx     2943 b- defN 80-Jan-01 00:00 ngccli/data/api/Env.py
--rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 ngccli/data/api/ErrorResponse.py
--rw-r--r--  2.0 unx     2964 b- defN 80-Jan-01 00:00 ngccli/data/api/Eula.py
--rw-r--r--  2.0 unx     2753 b- defN 80-Jan-01 00:00 ngccli/data/api/EulaSubmitResponse.py
--rw-r--r--  2.0 unx     3846 b- defN 80-Jan-01 00:00 ngccli/data/api/ExpTrackingParams.py
--rw-r--r--  2.0 unx     1892 b- defN 80-Jan-01 00:00 ngccli/data/api/FcOnboardingEventRequest.py
--rw-r--r--  2.0 unx     3753 b- defN 80-Jan-01 00:00 ngccli/data/api/GetRepositoryTagVexResponse.py
--rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngccli/data/api/Health.py
--rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 ngccli/data/api/HealthResponse.py
--rw-r--r--  2.0 unx     2410 b- defN 80-Jan-01 00:00 ngccli/data/api/HttpGet.py
--rw-r--r--  2.0 unx     2323 b- defN 80-Jan-01 00:00 ngccli/data/api/IPAddress.py
--rw-r--r--  2.0 unx     3099 b- defN 80-Jan-01 00:00 ngccli/data/api/InfinityManagerSettings.py
--rw-r--r--  2.0 unx    35355 b- defN 80-Jan-01 00:00 ngccli/data/api/Job.py
--rw-r--r--  2.0 unx      121 b- defN 80-Jan-01 00:00 ngccli/data/api/JobArrayTypeEnum.py
--rw-r--r--  2.0 unx    12900 b- defN 80-Jan-01 00:00 ngccli/data/api/JobContainerProperties.py
--rw-r--r--  2.0 unx     2577 b- defN 80-Jan-01 00:00 ngccli/data/api/JobContainerResources.py
--rw-r--r--  2.0 unx    41050 b- defN 80-Jan-01 00:00 ngccli/data/api/JobCreateRequest.py
--rw-r--r--  2.0 unx     9678 b- defN 80-Jan-01 00:00 ngccli/data/api/JobDataLocation.py
--rw-r--r--  2.0 unx     3490 b- defN 80-Jan-01 00:00 ngccli/data/api/JobDatasetMountInfo.py
--rw-r--r--  2.0 unx    39617 b- defN 80-Jan-01 00:00 ngccli/data/api/JobDefinition.py
--rw-r--r--  2.0 unx       97 b- defN 80-Jan-01 00:00 ngccli/data/api/JobFlowTypeEnum.py
--rw-r--r--  2.0 unx     4617 b- defN 80-Jan-01 00:00 ngccli/data/api/JobHealthCheck.py
--rw-r--r--  2.0 unx    12808 b- defN 80-Jan-01 00:00 ngccli/data/api/JobInitContainer.py
--rw-r--r--  2.0 unx     3556 b- defN 80-Jan-01 00:00 ngccli/data/api/JobLabelDeleteRequest.py
--rw-r--r--  2.0 unx     5211 b- defN 80-Jan-01 00:00 ngccli/data/api/JobLabelResponse.py
--rw-r--r--  2.0 unx     4241 b- defN 80-Jan-01 00:00 ngccli/data/api/JobLabelUpdateRequest.py
--rw-r--r--  2.0 unx     4940 b- defN 80-Jan-01 00:00 ngccli/data/api/JobLabels.py
--rw-r--r--  2.0 unx     5146 b- defN 80-Jan-01 00:00 ngccli/data/api/JobListResponse.py
--rw-r--r--  2.0 unx    11711 b- defN 80-Jan-01 00:00 ngccli/data/api/JobNodeCreateRequest.py
--rw-r--r--  2.0 unx     2948 b- defN 80-Jan-01 00:00 ngccli/data/api/JobNodeDeleteRequest.py
--rw-r--r--  2.0 unx     1907 b- defN 80-Jan-01 00:00 ngccli/data/api/JobNodePreemptRequest.py
--rw-r--r--  2.0 unx     1919 b- defN 80-Jan-01 00:00 ngccli/data/api/JobNodeResumeRequest.py
--rw-r--r--  2.0 unx     6209 b- defN 80-Jan-01 00:00 ngccli/data/api/JobPortMapping.py
--rw-r--r--  2.0 unx      104 b- defN 80-Jan-01 00:00 ngccli/data/api/JobPriorityEnum.py
--rw-r--r--  2.0 unx     4883 b- defN 80-Jan-01 00:00 ngccli/data/api/JobResponse.py
--rw-r--r--  2.0 unx     3890 b- defN 80-Jan-01 00:00 ngccli/data/api/JobResultsetMountInfo.py
--rw-r--r--  2.0 unx     5817 b- defN 80-Jan-01 00:00 ngccli/data/api/JobRunPolicy.py
--rw-r--r--  2.0 unx    16057 b- defN 80-Jan-01 00:00 ngccli/data/api/JobSidecarContainer.py
--rw-r--r--  2.0 unx    19200 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatus.py
--rw-r--r--  2.0 unx     2491 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusChangedEvent.py
--rw-r--r--  2.0 unx     2464 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusCount.py
--rw-r--r--  2.0 unx     3086 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusCountResponse.py
--rw-r--r--  2.0 unx      541 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusEnum.py
--rw-r--r--  2.0 unx     2339 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusSyncRequest.py
--rw-r--r--  2.0 unx     8345 b- defN 80-Jan-01 00:00 ngccli/data/api/JobStatusUpdateRequest.py
--rw-r--r--  2.0 unx     2872 b- defN 80-Jan-01 00:00 ngccli/data/api/JobSubmitResponse.py
--rw-r--r--  2.0 unx     6644 b- defN 80-Jan-01 00:00 ngccli/data/api/JobTemplate.py
--rw-r--r--  2.0 unx     4810 b- defN 80-Jan-01 00:00 ngccli/data/api/JobTemplateCreateRequest.py
--rw-r--r--  2.0 unx     3052 b- defN 80-Jan-01 00:00 ngccli/data/api/JobTemplateResponse.py
--rw-r--r--  2.0 unx     5980 b- defN 80-Jan-01 00:00 ngccli/data/api/JobTemplateUpdateRequest.py
--rw-r--r--  2.0 unx       92 b- defN 80-Jan-01 00:00 ngccli/data/api/JobTypeEnum.py
--rw-r--r--  2.0 unx     1799 b- defN 80-Jan-01 00:00 ngccli/data/api/JobVolume.py
--rw-r--r--  2.0 unx     3837 b- defN 80-Jan-01 00:00 ngccli/data/api/JobVolumeMount.py
--rw-r--r--  2.0 unx     3819 b- defN 80-Jan-01 00:00 ngccli/data/api/JobWorkspaceMountInfo.py
--rw-r--r--  2.0 unx     1696 b- defN 80-Jan-01 00:00 ngccli/data/api/Measurement.py
--rw-r--r--  2.0 unx      140 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAggregationType.py
--rw-r--r--  2.0 unx     9534 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAlert.py
--rw-r--r--  2.0 unx     9069 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAlertCreateRequest.py
--rw-r--r--  2.0 unx     4394 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAlertCriteria.py
--rw-r--r--  2.0 unx     4138 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAlertListResponse.py
--rw-r--r--  2.0 unx     2956 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementAlertResponse.py
--rw-r--r--  2.0 unx     5771 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementQueryParams.py
--rw-r--r--  2.0 unx     2124 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementQueryRequest.py
--rw-r--r--  2.0 unx     2041 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementResult.py
--rw-r--r--  2.0 unx     3151 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementResultListResponse.py
--rw-r--r--  2.0 unx     4566 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementSeries.py
--rw-r--r--  2.0 unx     2557 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementTag.py
--rw-r--r--  2.0 unx     1139 b- defN 80-Jan-01 00:00 ngccli/data/api/MeasurementType.py
--rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngccli/data/api/MetaData.py
--rw-r--r--  2.0 unx     5806 b- defN 80-Jan-01 00:00 ngccli/data/api/MeteringQueryParams.py
--rw-r--r--  2.0 unx     2108 b- defN 80-Jan-01 00:00 ngccli/data/api/MeteringQueryRequest.py
--rw-r--r--  2.0 unx     8876 b- defN 80-Jan-01 00:00 ngccli/data/api/MeteringResourceUtilizationEvent.py
--rw-r--r--  2.0 unx     3145 b- defN 80-Jan-01 00:00 ngccli/data/api/MeteringResultListResponse.py
--rw-r--r--  2.0 unx      464 b- defN 80-Jan-01 00:00 ngccli/data/api/MeteringType.py
--rw-r--r--  2.0 unx     1880 b- defN 80-Jan-01 00:00 ngccli/data/api/MoveNodeRequest.py
--rw-r--r--  2.0 unx      117 b- defN 80-Jan-01 00:00 ngccli/data/api/NetworkProtocolEnum.py
--rw-r--r--  2.0 unx      106 b- defN 80-Jan-01 00:00 ngccli/data/api/NetworkTypeEnum.py
--rw-r--r--  2.0 unx    12102 b- defN 80-Jan-01 00:00 ngccli/data/api/Node.py
--rw-r--r--  2.0 unx     3564 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeCommand.py
--rw-r--r--  2.0 unx     2778 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeCommandRequest.py
--rw-r--r--  2.0 unx     5388 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeCreateResponse.py
--rw-r--r--  2.0 unx     4017 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeListResponse.py
--rw-r--r--  2.0 unx     3755 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeResponse.py
--rw-r--r--  2.0 unx     3336 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeSimplified.py
--rw-r--r--  2.0 unx    28410 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeStatus.py
--rw-r--r--  2.0 unx     1883 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeStatusChangedEvent.py
--rw-r--r--  2.0 unx     4161 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeStatusUpdate.py
--rw-r--r--  2.0 unx      163 b- defN 80-Jan-01 00:00 ngccli/data/api/NodeType.py
--rw-r--r--  2.0 unx     3446 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgAdminUserCreatedEvent.py
--rw-r--r--  2.0 unx    14183 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgCreateRequest.py
--rw-r--r--  2.0 unx     2929 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgCreateResponse.py
--rw-r--r--  2.0 unx     1777 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgCreatedEvent.py
--rw-r--r--  2.0 unx     3450 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgEnablementCreateRequest.py
--rw-r--r--  2.0 unx     3219 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgListEntitlementResponse.py
--rw-r--r--  2.0 unx     4197 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgListResponse.py
--rw-r--r--  2.0 unx     4754 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgOwner.py
--rw-r--r--  2.0 unx     3459 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgProfileUpdateRequest.py
--rw-r--r--  2.0 unx     3041 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgResponse.py
--rw-r--r--  2.0 unx      118 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgType.py
--rw-r--r--  2.0 unx    19529 b- defN 80-Jan-01 00:00 ngccli/data/api/OrgUpdateRequest.py
--rw-r--r--  2.0 unx    22086 b- defN 80-Jan-01 00:00 ngccli/data/api/Organization.py
--rw-r--r--  2.0 unx     2826 b- defN 80-Jan-01 00:00 ngccli/data/api/OrganizationEntitlement.py
--rw-r--r--  2.0 unx     4056 b- defN 80-Jan-01 00:00 ngccli/data/api/PackageVersion.py
--rw-r--r--  2.0 unx     3032 b- defN 80-Jan-01 00:00 ngccli/data/api/PackageVersionListResponse.py
--rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngccli/data/api/PaginationInfo.py
--rw-r--r--  2.0 unx     3629 b- defN 80-Jan-01 00:00 ngccli/data/api/PasswordChangeRequest.py
--rw-r--r--  2.0 unx     5365 b- defN 80-Jan-01 00:00 ngccli/data/api/PhysicalNodeCreateRequest.py
--rw-r--r--  2.0 unx     6106 b- defN 80-Jan-01 00:00 ngccli/data/api/PoolMeasurementQueryParams.py
--rw-r--r--  2.0 unx     2153 b- defN 80-Jan-01 00:00 ngccli/data/api/PoolMeasurementQueryRequest.py
--rw-r--r--  2.0 unx      341 b- defN 80-Jan-01 00:00 ngccli/data/api/PoolMeasurementType.py
--rw-r--r--  2.0 unx     4619 b- defN 80-Jan-01 00:00 ngccli/data/api/PostStorageProvision.py
--rw-r--r--  2.0 unx     4135 b- defN 80-Jan-01 00:00 ngccli/data/api/Price.py
--rw-r--r--  2.0 unx      107 b- defN 80-Jan-01 00:00 ngccli/data/api/PriceType.py
--rw-r--r--  2.0 unx     5355 b- defN 80-Jan-01 00:00 ngccli/data/api/ProductEnablement.py
--rw-r--r--  2.0 unx      196 b- defN 80-Jan-01 00:00 ngccli/data/api/ProductEnablementTypeEnum.py
--rw-r--r--  2.0 unx      637 b- defN 80-Jan-01 00:00 ngccli/data/api/ProductNameEnum.py
--rw-r--r--  2.0 unx     7108 b- defN 80-Jan-01 00:00 ngccli/data/api/ProductSubscription.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/api/PurchaseOrder.py
--rw-r--r--  2.0 unx    11869 b- defN 80-Jan-01 00:00 ngccli/data/api/Replica.py
--rw-r--r--  2.0 unx     4167 b- defN 80-Jan-01 00:00 ngccli/data/api/ReplicaListResponse.py
--rw-r--r--  2.0 unx     4182 b- defN 80-Jan-01 00:00 ngccli/data/api/ReplicaResponse.py
--rw-r--r--  2.0 unx     6724 b- defN 80-Jan-01 00:00 ngccli/data/api/RepoScanSettings.py
--rw-r--r--  2.0 unx     2672 b- defN 80-Jan-01 00:00 ngccli/data/api/RepositoryTagVexByDigest.py
--rw-r--r--  2.0 unx     2528 b- defN 80-Jan-01 00:00 ngccli/data/api/RepositoryTagVexDetail.py
--rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngccli/data/api/RequestStatus.py
--rw-r--r--  2.0 unx     1730 b- defN 80-Jan-01 00:00 ngccli/data/api/ReservedLabels.py
--rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngccli/data/api/Response.py
--rw-r--r--  2.0 unx    11985 b- defN 80-Jan-01 00:00 ngccli/data/api/Resultset.py
--rw-r--r--  2.0 unx     6582 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetFile.py
--rw-r--r--  2.0 unx     2002 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetFileBatch.py
--rw-r--r--  2.0 unx     4130 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetFileEventRequest.py
--rw-r--r--  2.0 unx     5280 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetListResponse.py
--rw-r--r--  2.0 unx     5145 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetResponse.py
--rw-r--r--  2.0 unx     3429 b- defN 80-Jan-01 00:00 ngccli/data/api/ResultsetToDatasetConversionEvent.py
--rw-r--r--  2.0 unx     5182 b- defN 80-Jan-01 00:00 ngccli/data/api/RoleChangeRequest.py
--rw-r--r--  2.0 unx     2623 b- defN 80-Jan-01 00:00 ngccli/data/api/RoleProduct.py
--rw-r--r--  2.0 unx     1810 b- defN 80-Jan-01 00:00 ngccli/data/api/RoleType.py
--rw-r--r--  2.0 unx     1694 b- defN 80-Jan-01 00:00 ngccli/data/api/SCPJobDetails.py
--rw-r--r--  2.0 unx     2413 b- defN 80-Jan-01 00:00 ngccli/data/api/Saml.py
--rw-r--r--  2.0 unx     2747 b- defN 80-Jan-01 00:00 ngccli/data/api/SamlResponse.py
--rw-r--r--  2.0 unx     3983 b- defN 80-Jan-01 00:00 ngccli/data/api/Secret.py
--rw-r--r--  2.0 unx     4504 b- defN 80-Jan-01 00:00 ngccli/data/api/SecretKVEnv.py
--rw-r--r--  2.0 unx     3314 b- defN 80-Jan-01 00:00 ngccli/data/api/SecretKeySpec.py
--rw-r--r--  2.0 unx     4057 b- defN 80-Jan-01 00:00 ngccli/data/api/SecretSpec.py
--rw-r--r--  2.0 unx     3507 b- defN 80-Jan-01 00:00 ngccli/data/api/ServiceAccess.py
--rw-r--r--  2.0 unx      450 b- defN 80-Jan-01 00:00 ngccli/data/api/StatusCode.py
--rw-r--r--  2.0 unx     4320 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageAccessInfo.py
--rw-r--r--  2.0 unx     6019 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageAuthenticationResponse.py
--rw-r--r--  2.0 unx     2688 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageCephInfo.py
--rw-r--r--  2.0 unx    11664 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageClusterCreateRequest.py
--rw-r--r--  2.0 unx     3227 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageClusterListResponse.py
--rw-r--r--  2.0 unx     3140 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageClusterResponse.py
--rw-r--r--  2.0 unx     9783 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageClusterUpdateRequest.py
--rw-r--r--  2.0 unx      129 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageEngineTypeEnum.py
--rw-r--r--  2.0 unx     4059 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageLocation.py
--rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageLocationStorageTypeEnum.py
--rw-r--r--  2.0 unx     1996 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageLustreInfo.py
--rw-r--r--  2.0 unx     1955 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageNfsv3Info.py
--rw-r--r--  2.0 unx     2011 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageProxyfsInfo.py
--rw-r--r--  2.0 unx    17601 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageResource.py
--rw-r--r--  2.0 unx      161 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageResourceStatusEnum.py
--rw-r--r--  2.0 unx     5120 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageServiceConfig.py
--rw-r--r--  2.0 unx    13574 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageServiceConfigDetails.py
--rw-r--r--  2.0 unx     5312 b- defN 80-Jan-01 00:00 ngccli/data/api/StorageYarofsInfo.py
--rw-r--r--  2.0 unx     2722 b- defN 80-Jan-01 00:00 ngccli/data/api/SuggestedNamesResponse.py
--rw-r--r--  2.0 unx     1712 b- defN 80-Jan-01 00:00 ngccli/data/api/SystemLabels.py
--rw-r--r--  2.0 unx     6470 b- defN 80-Jan-01 00:00 ngccli/data/api/TargetSystemUserIdentifier.py
--rw-r--r--  2.0 unx     6353 b- defN 80-Jan-01 00:00 ngccli/data/api/Team.py
--rw-r--r--  2.0 unx     3756 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamCreateRequest.py
--rw-r--r--  2.0 unx     2856 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamCreateResponse.py
--rw-r--r--  2.0 unx     3332 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamCreatedEvent.py
--rw-r--r--  2.0 unx     4017 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamListResponse.py
--rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamResponse.py
--rw-r--r--  2.0 unx     4496 b- defN 80-Jan-01 00:00 ngccli/data/api/TeamUpdateRequest.py
--rw-r--r--  2.0 unx     3608 b- defN 80-Jan-01 00:00 ngccli/data/api/TelemetryClientCreateResponse.py
--rw-r--r--  2.0 unx     2705 b- defN 80-Jan-01 00:00 ngccli/data/api/TokenResponse.py
--rw-r--r--  2.0 unx     1914 b- defN 80-Jan-01 00:00 ngccli/data/api/UpdateAceRequest.py
--rw-r--r--  2.0 unx     2736 b- defN 80-Jan-01 00:00 ngccli/data/api/UpdateNodeRequest.py
--rw-r--r--  2.0 unx    31143 b- defN 80-Jan-01 00:00 ngccli/data/api/User.py
--rw-r--r--  2.0 unx     9435 b- defN 80-Jan-01 00:00 ngccli/data/api/UserCreateRequest.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/api/UserCreatedEvent.py
--rw-r--r--  2.0 unx     9651 b- defN 80-Jan-01 00:00 ngccli/data/api/UserInvitation.py
--rw-r--r--  2.0 unx     4231 b- defN 80-Jan-01 00:00 ngccli/data/api/UserInvitationListResponse.py
--rw-r--r--  2.0 unx     2988 b- defN 80-Jan-01 00:00 ngccli/data/api/UserInvitationResponse.py
--rw-r--r--  2.0 unx     5560 b- defN 80-Jan-01 00:00 ngccli/data/api/UserKeyResponse.py
--rw-r--r--  2.0 unx     1726 b- defN 80-Jan-01 00:00 ngccli/data/api/UserLabels.py
--rw-r--r--  2.0 unx     4058 b- defN 80-Jan-01 00:00 ngccli/data/api/UserListResponse.py
--rw-r--r--  2.0 unx     8112 b- defN 80-Jan-01 00:00 ngccli/data/api/UserMetadata.py
--rw-r--r--  2.0 unx     9791 b- defN 80-Jan-01 00:00 ngccli/data/api/UserOrgRegisterRequest.py
--rw-r--r--  2.0 unx     7022 b- defN 80-Jan-01 00:00 ngccli/data/api/UserRegisterRequest.py
--rw-r--r--  2.0 unx     4806 b- defN 80-Jan-01 00:00 ngccli/data/api/UserResponse.py
--rw-r--r--  2.0 unx     6556 b- defN 80-Jan-01 00:00 ngccli/data/api/UserRole.py
--rw-r--r--  2.0 unx     5464 b- defN 80-Jan-01 00:00 ngccli/data/api/UserRoleDefinition.py
--rw-r--r--  2.0 unx     3085 b- defN 80-Jan-01 00:00 ngccli/data/api/UserRoleDefinitionsResponse.py
--rw-r--r--  2.0 unx     1780 b- defN 80-Jan-01 00:00 ngccli/data/api/UserSession.py
--rw-r--r--  2.0 unx     2986 b- defN 80-Jan-01 00:00 ngccli/data/api/UserSessionResponse.py
--rw-r--r--  2.0 unx     6456 b- defN 80-Jan-01 00:00 ngccli/data/api/UserStorageClusterUpdateRequest.py
--rw-r--r--  2.0 unx    12800 b- defN 80-Jan-01 00:00 ngccli/data/api/UserStorageQuota.py
--rw-r--r--  2.0 unx     5965 b- defN 80-Jan-01 00:00 ngccli/data/api/UserStorageQuotaListResponse.py
--rw-r--r--  2.0 unx     3210 b- defN 80-Jan-01 00:00 ngccli/data/api/UserStorageQuotaResponse.py
--rw-r--r--  2.0 unx     3825 b- defN 80-Jan-01 00:00 ngccli/data/api/UserStorageQuotaUpdateRequest.py
--rw-r--r--  2.0 unx     6239 b- defN 80-Jan-01 00:00 ngccli/data/api/UserTopicEvent.py
--rw-r--r--  2.0 unx    16740 b- defN 80-Jan-01 00:00 ngccli/data/api/UserUpdateRequest.py
--rw-r--r--  2.0 unx     1718 b- defN 80-Jan-01 00:00 ngccli/data/api/UsersInfo.py
--rw-r--r--  2.0 unx     4635 b- defN 80-Jan-01 00:00 ngccli/data/api/ValidateOrgQueryParams.py
--rw-r--r--  2.0 unx     2604 b- defN 80-Jan-01 00:00 ngccli/data/api/VirtualNodeCreateRequest.py
--rw-r--r--  2.0 unx     2873 b- defN 80-Jan-01 00:00 ngccli/data/api/WebSocket.py
--rw-r--r--  2.0 unx     3611 b- defN 80-Jan-01 00:00 ngccli/data/api/WebSocketReceipt.py
--rw-r--r--  2.0 unx     9410 b- defN 80-Jan-01 00:00 ngccli/data/api/Webhook.py
--rw-r--r--  2.0 unx     8997 b- defN 80-Jan-01 00:00 ngccli/data/api/WebhookCreateRequest.py
--rw-r--r--  2.0 unx      127 b- defN 80-Jan-01 00:00 ngccli/data/api/WebhookEventType.py
--rw-r--r--  2.0 unx     4112 b- defN 80-Jan-01 00:00 ngccli/data/api/WebhookListResponse.py
--rw-r--r--  2.0 unx     2860 b- defN 80-Jan-01 00:00 ngccli/data/api/WebhookResponse.py
--rw-r--r--  2.0 unx     5270 b- defN 80-Jan-01 00:00 ngccli/data/api/WorkspaceCreateRequest.py
--rw-r--r--  2.0 unx     5272 b- defN 80-Jan-01 00:00 ngccli/data/api/WorkspaceListResponse.py
--rw-r--r--  2.0 unx     3019 b- defN 80-Jan-01 00:00 ngccli/data/api/WorkspaceResponse.py
--rw-r--r--  2.0 unx     3430 b- defN 80-Jan-01 00:00 ngccli/data/api/WorkspaceUpdateRequest.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/api/__init__.py
--rw-r--r--  2.0 unx     4573 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AdvancedStorage.py
--rw-r--r--  2.0 unx     4833 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AdvancedStorageResponse.py
--rw-r--r--  2.0 unx     5307 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Alert.py
--rw-r--r--  2.0 unx     1874 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApiKeyCreateRequest.py
--rw-r--r--  2.0 unx     2784 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApiKeyResponse.py
--rw-r--r--  2.0 unx     3553 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AppConfigCreateRequest.py
--rw-r--r--  2.0 unx     2930 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AppConfigResponse.py
--rw-r--r--  2.0 unx     1827 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AppConfigUpdateRequest.py
--rw-r--r--  2.0 unx     3775 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AppConfigs.py
--rw-r--r--  2.0 unx     3087 b- defN 80-Jan-01 00:00 ngccli/data/ecm/AppConfigsResponse.py
--rw-r--r--  2.0 unx     9830 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Application.py
--rw-r--r--  2.0 unx     1902 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApplicationRequest.py
--rw-r--r--  2.0 unx     2971 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApplicationResponse.py
--rw-r--r--  2.0 unx     1908 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApplicationUpdateRequest.py
--rw-r--r--  2.0 unx     4230 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ApplicationsResponse.py
--rw-r--r--  2.0 unx     4266 b- defN 80-Jan-01 00:00 ngccli/data/ecm/BuildStatus.py
--rw-r--r--  2.0 unx      120 b- defN 80-Jan-01 00:00 ngccli/data/ecm/BuildStatusEnum.py
--rw-r--r--  2.0 unx     1735 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ComponentResponse.py
--rw-r--r--  2.0 unx     6318 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Console.py
--rw-r--r--  2.0 unx     2816 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ConsoleResponse.py
--rw-r--r--  2.0 unx     2984 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ConsolesResponse.py
--rw-r--r--  2.0 unx     2879 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CreateCustomRootFsRequest.py
--rw-r--r--  2.0 unx    13151 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CreateDeploymentRequest.py
--rw-r--r--  2.0 unx     8959 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CreateLocationRequest.py
--rw-r--r--  2.0 unx     5933 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CreateNodeRequest.py
--rw-r--r--  2.0 unx     9573 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CustomInstaller.py
--rw-r--r--  2.0 unx     3846 b- defN 80-Jan-01 00:00 ngccli/data/ecm/CustomRootFsCreationEvent.py
--rw-r--r--  2.0 unx    20692 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Deployment.py
--rw-r--r--  2.0 unx    18100 b- defN 80-Jan-01 00:00 ngccli/data/ecm/DeploymentLocation.py
--rw-r--r--  2.0 unx     2904 b- defN 80-Jan-01 00:00 ngccli/data/ecm/DeploymentResponse.py
--rw-r--r--  2.0 unx     4134 b- defN 80-Jan-01 00:00 ngccli/data/ecm/DeploymentsResponse.py
--rw-r--r--  2.0 unx     6181 b- defN 80-Jan-01 00:00 ngccli/data/ecm/EmsMetaData.py
--rw-r--r--  2.0 unx     5052 b- defN 80-Jan-01 00:00 ngccli/data/ecm/EmsResponse.py
--rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ErrorResponse.py
--rw-r--r--  2.0 unx     6817 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Git.py
--rw-r--r--  2.0 unx     3435 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitApp.py
--rw-r--r--  2.0 unx     3128 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitRepositoriesResponse.py
--rw-r--r--  2.0 unx     4160 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitRepository.py
--rw-r--r--  2.0 unx     9018 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitRepositoryRequest.py
--rw-r--r--  2.0 unx     3085 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitRepositoryResponse.py
--rw-r--r--  2.0 unx     8283 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GitRepositoryUpdateRequest.py
--rw-r--r--  2.0 unx     7370 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GpuInfo.py
--rw-r--r--  2.0 unx     4393 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GpuLogStorageUsageResponse.py
--rw-r--r--  2.0 unx     6483 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GpuManagement.py
--rw-r--r--  2.0 unx     3140 b- defN 80-Jan-01 00:00 ngccli/data/ecm/GpuManagementResponse.py
--rw-r--r--  2.0 unx     2425 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Installer.py
--rw-r--r--  2.0 unx     3206 b- defN 80-Jan-01 00:00 ngccli/data/ecm/InstallersResponse.py
--rw-r--r--  2.0 unx     1931 b- defN 80-Jan-01 00:00 ngccli/data/ecm/InstallersValidationRequest.py
--rw-r--r--  2.0 unx     4001 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Iso.py
--rw-r--r--  2.0 unx     2293 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Label.py
--rw-r--r--  2.0 unx     4033 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LabelsResponse.py
--rw-r--r--  2.0 unx    21965 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Location.py
--rw-r--r--  2.0 unx      126 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationAvailabilityEnum.py
--rw-r--r--  2.0 unx      178 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationDeploymentStatusEnum.py
--rw-r--r--  2.0 unx      113 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationHealthEnum.py
--rw-r--r--  2.0 unx     2858 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationResponse.py
--rw-r--r--  2.0 unx      137 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationStatusEnum.py
--rw-r--r--  2.0 unx     4143 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LocationsResponse.py
--rw-r--r--  2.0 unx     3653 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Log.py
--rw-r--r--  2.0 unx     4091 b- defN 80-Jan-01 00:00 ngccli/data/ecm/LogsResponse.py
--rw-r--r--  2.0 unx     2370 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ManagedGpus.py
--rw-r--r--  2.0 unx     2296 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MetaData.py
--rw-r--r--  2.0 unx     9696 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MetricQueryResponse.py
--rw-r--r--  2.0 unx     2358 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Metrics.py
--rw-r--r--  2.0 unx     2679 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MetricsBucketsResponse.py
--rw-r--r--  2.0 unx     3697 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MetricsListResponse.py
--rw-r--r--  2.0 unx     2463 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MigProfileInfo.py
--rw-r--r--  2.0 unx      144 b- defN 80-Jan-01 00:00 ngccli/data/ecm/MigStatusEnum.py
--rw-r--r--  2.0 unx     8419 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NetworkInfo.py
--rw-r--r--  2.0 unx     3071 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NetworkInfoResponse.py
--rw-r--r--  2.0 unx     2536 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NetworkInterface.py
--rw-r--r--  2.0 unx    20002 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Node.py
--rw-r--r--  2.0 unx      107 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodeConnectionEnum.py
--rw-r--r--  2.0 unx     5671 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodeGpuInfoResponse.py
--rw-r--r--  2.0 unx      118 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodeHealthEnum.py
--rw-r--r--  2.0 unx     2747 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodeResponse.py
--rw-r--r--  2.0 unx      197 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodeStatusEnum.py
--rw-r--r--  2.0 unx     3983 b- defN 80-Jan-01 00:00 ngccli/data/ecm/NodesResponse.py
--rw-r--r--  2.0 unx     4827 b- defN 80-Jan-01 00:00 ngccli/data/ecm/PaginationInfo.py
--rw-r--r--  2.0 unx     4565 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteApp.py
--rw-r--r--  2.0 unx     6169 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteAppDetail.py
--rw-r--r--  2.0 unx     2923 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteAppResponse.py
--rw-r--r--  2.0 unx     4964 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteAppTunnelResponse.py
--rw-r--r--  2.0 unx     1923 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteConsoleSshRequest.py
--rw-r--r--  2.0 unx     4984 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteConsoleSshResponse.py
--rw-r--r--  2.0 unx      169 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RemoteManagerStatusTypeEnum.py
--rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngccli/data/ecm/RequestStatus.py
--rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngccli/data/ecm/Response.py
--rw-r--r--  2.0 unx      118 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ScanResultsStatusEnum.py
--rw-r--r--  2.0 unx     2626 b- defN 80-Jan-01 00:00 ngccli/data/ecm/SecurityMinimunSupportedVersion.py
--rw-r--r--  2.0 unx    22970 b- defN 80-Jan-01 00:00 ngccli/data/ecm/SettingsResponse.py
--rw-r--r--  2.0 unx     2144 b- defN 80-Jan-01 00:00 ngccli/data/ecm/SignedContainerKeysRequest.py
--rw-r--r--  2.0 unx     2145 b- defN 80-Jan-01 00:00 ngccli/data/ecm/SignedContainerKeysResponse.py
--rw-r--r--  2.0 unx      218 b- defN 80-Jan-01 00:00 ngccli/data/ecm/SortOrderEnum.py
--rw-r--r--  2.0 unx      282 b- defN 80-Jan-01 00:00 ngccli/data/ecm/StatusCode.py
--rw-r--r--  2.0 unx     3164 b- defN 80-Jan-01 00:00 ngccli/data/ecm/TypeVersion.py
--rw-r--r--  2.0 unx     2721 b- defN 80-Jan-01 00:00 ngccli/data/ecm/TypeVersions.py
--rw-r--r--  2.0 unx    10110 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateDeploymentRequest.py
--rw-r--r--  2.0 unx     3333 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateGpuInfo.py
--rw-r--r--  2.0 unx     8527 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateLocationRequest.py
--rw-r--r--  2.0 unx     3012 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateNodeGpuInfoRequest.py
--rw-r--r--  2.0 unx     5183 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateNodeRequest.py
--rw-r--r--  2.0 unx    11447 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateSettingsRequest.py
--rw-r--r--  2.0 unx      215 b- defN 80-Jan-01 00:00 ngccli/data/ecm/UpdateStatusEnum.py
--rw-r--r--  2.0 unx     3920 b- defN 80-Jan-01 00:00 ngccli/data/ecm/ValidationStatus.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/ecm/__init__.py
--rw-r--r--  2.0 unx     7525 b- defN 80-Jan-01 00:00 ngccli/data/model/AIFoundationModel.py
--rw-r--r--  2.0 unx     4299 b- defN 80-Jan-01 00:00 ngccli/data/model/AIPlaygroundCreateRequest.py
--rw-r--r--  2.0 unx     7548 b- defN 80-Jan-01 00:00 ngccli/data/model/AIPlaygroundResponse.py
--rw-r--r--  2.0 unx     3461 b- defN 80-Jan-01 00:00 ngccli/data/model/AIPlaygroundUpdateRequest.py
--rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngccli/data/model/AccessTypeEnum.py
--rw-r--r--  2.0 unx      552 b- defN 80-Jan-01 00:00 ngccli/data/model/ApplicationType.py
--rw-r--r--  2.0 unx    24085 b- defN 80-Jan-01 00:00 ngccli/data/model/Artifact.py
--rw-r--r--  2.0 unx     3124 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactAttribute.py
--rw-r--r--  2.0 unx     3524 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactCatalogFlags.py
--rw-r--r--  2.0 unx    15113 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactCreateRequest.py
--rw-r--r--  2.0 unx     9003 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactDeploymentParameters.py
--rw-r--r--  2.0 unx     3853 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactDownloadAllRequest.py
--rw-r--r--  2.0 unx     5910 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactDownloadAllResponse.py
--rw-r--r--  2.0 unx     4808 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactDownloadRequest.py
--rw-r--r--  2.0 unx     3732 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactDownloadResponse.py
--rw-r--r--  2.0 unx     5414 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactEvent.py
--rw-r--r--  2.0 unx     4148 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactListResponse.py
--rw-r--r--  2.0 unx     4967 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactPublishRequest.py
--rw-r--r--  2.0 unx     2961 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactResponse.py
--rw-r--r--  2.0 unx      146 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactTypeEnum.py
--rw-r--r--  2.0 unx    13199 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactUpdateRequest.py
--rw-r--r--  2.0 unx    10576 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersion.py
--rw-r--r--  2.0 unx     3799 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersionCreateRequest.py
--rw-r--r--  2.0 unx     6261 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersionFileListResponse.py
--rw-r--r--  2.0 unx     5241 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersionListResponse.py
--rw-r--r--  2.0 unx     4083 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersionResponse.py
--rw-r--r--  2.0 unx     3979 b- defN 80-Jan-01 00:00 ngccli/data/model/ArtifactVersionUpdateRequest.py
--rw-r--r--  2.0 unx    19418 b- defN 80-Jan-01 00:00 ngccli/data/model/Asset.py
--rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetCdnProviderTypeEnum.py
--rw-r--r--  2.0 unx     2864 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetResponse.py
--rw-r--r--  2.0 unx     3575 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetSimplified.py
--rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetStatusTypeEnum.py
--rw-r--r--  2.0 unx     4470 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetStorageEvent.py
--rw-r--r--  2.0 unx       97 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetStorageTypeEnum.py
--rw-r--r--  2.0 unx     7178 b- defN 80-Jan-01 00:00 ngccli/data/model/AssetUpdateRequest.py
--rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngccli/data/model/CatalogArtifactMetadata.py
--rw-r--r--  2.0 unx     3994 b- defN 80-Jan-01 00:00 ngccli/data/model/CloneArtifactVersionFilesRequest.py
--rw-r--r--  2.0 unx     3916 b- defN 80-Jan-01 00:00 ngccli/data/model/CloneableArtifact.py
--rw-r--r--  2.0 unx    10280 b- defN 80-Jan-01 00:00 ngccli/data/model/CloudServiceProvider.py
--rw-r--r--  2.0 unx     6963 b- defN 80-Jan-01 00:00 ngccli/data/model/CloudServiceProviderCreateRequest.py
--rw-r--r--  2.0 unx     4414 b- defN 80-Jan-01 00:00 ngccli/data/model/CloudServiceProviderListResponse.py
--rw-r--r--  2.0 unx     6037 b- defN 80-Jan-01 00:00 ngccli/data/model/CloudServiceProviderUpdateRequest.py
--rw-r--r--  2.0 unx    18935 b- defN 80-Jan-01 00:00 ngccli/data/model/Collection.py
--rw-r--r--  2.0 unx      510 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionCategoryType.py
--rw-r--r--  2.0 unx    13636 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionCreateRequest.py
--rw-r--r--  2.0 unx     4192 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionListResponse.py
--rw-r--r--  2.0 unx     3343 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionOperation.py
--rw-r--r--  2.0 unx      131 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionOperationType.py
--rw-r--r--  2.0 unx     2338 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionPatchRequest.py
--rw-r--r--  2.0 unx     4970 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionPublishRequest.py
--rw-r--r--  2.0 unx     3020 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionResponse.py
--rw-r--r--  2.0 unx     3610 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionSimplified.py
--rw-r--r--  2.0 unx    11520 b- defN 80-Jan-01 00:00 ngccli/data/model/CollectionUpdateRequest.py
--rw-r--r--  2.0 unx     3329 b- defN 80-Jan-01 00:00 ngccli/data/model/CountableResource.py
--rw-r--r--  2.0 unx     2799 b- defN 80-Jan-01 00:00 ngccli/data/model/CustomMetric.py
--rw-r--r--  2.0 unx     3003 b- defN 80-Jan-01 00:00 ngccli/data/model/CustomMetricGroup.py
--rw-r--r--  2.0 unx     3803 b- defN 80-Jan-01 00:00 ngccli/data/model/Dataset.py
--rw-r--r--  2.0 unx     6861 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentArtifactParameters.py
--rw-r--r--  2.0 unx     1683 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentCpuParameters.py
--rw-r--r--  2.0 unx     2160 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentCpuParametersMeta.py
--rw-r--r--  2.0 unx     2387 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentGpuParameters.py
--rw-r--r--  2.0 unx     3127 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentGpuParametersMeta.py
--rw-r--r--  2.0 unx     1787 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentMemoryParameters.py
--rw-r--r--  2.0 unx     2288 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentMemoryParametersMeta.py
--rw-r--r--  2.0 unx     8995 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParameters.py
--rw-r--r--  2.0 unx     8305 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersCreateRequest.py
--rw-r--r--  2.0 unx     6237 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersListResponse.py
--rw-r--r--  2.0 unx     6125 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersMeta.py
--rw-r--r--  2.0 unx     5840 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersMetaCreateRequest.py
--rw-r--r--  2.0 unx     5216 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersMetaListResponse.py
--rw-r--r--  2.0 unx     5458 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersMetaUpdateRequest.py
--rw-r--r--  2.0 unx     8308 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentParametersUpdateRequest.py
--rw-r--r--  2.0 unx     1789 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentStorageParameters.py
--rw-r--r--  2.0 unx     2291 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentStorageParametersMeta.py
--rw-r--r--  2.0 unx     8291 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentUrlCreateRequest.py
--rw-r--r--  2.0 unx     4823 b- defN 80-Jan-01 00:00 ngccli/data/model/DeploymentUrlResponse.py
--rw-r--r--  2.0 unx     2941 b- defN 80-Jan-01 00:00 ngccli/data/model/EnumerableResource.py
--rw-r--r--  2.0 unx     3164 b- defN 80-Jan-01 00:00 ngccli/data/model/EnumerableResourceItem.py
--rw-r--r--  2.0 unx     6436 b- defN 80-Jan-01 00:00 ngccli/data/model/File.py
--rw-r--r--  2.0 unx      197 b- defN 80-Jan-01 00:00 ngccli/data/model/FrameworkType.py
--rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngccli/data/model/Health.py
--rw-r--r--  2.0 unx     1989 b- defN 80-Jan-01 00:00 ngccli/data/model/HealthResponse.py
--rw-r--r--  2.0 unx     3845 b- defN 80-Jan-01 00:00 ngccli/data/model/HelmChartDependency.py
--rw-r--r--  2.0 unx     3171 b- defN 80-Jan-01 00:00 ngccli/data/model/HelmChartMaintainer.py
--rw-r--r--  2.0 unx    12667 b- defN 80-Jan-01 00:00 ngccli/data/model/HelmChartVersion.py
--rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngccli/data/model/MetaData.py
--rw-r--r--  2.0 unx    30696 b- defN 80-Jan-01 00:00 ngccli/data/model/Model.py
--rw-r--r--  2.0 unx    22262 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelCreateRequest.py
--rw-r--r--  2.0 unx     2882 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelCreateResponse.py
--rw-r--r--  2.0 unx     5242 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelFile.py
--rw-r--r--  2.0 unx      221 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelFormatType.py
--rw-r--r--  2.0 unx     4063 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelListResponse.py
--rw-r--r--  2.0 unx     2871 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelResponse.py
--rw-r--r--  2.0 unx     3575 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelSimplified.py
--rw-r--r--  2.0 unx    20197 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelUpdateRequest.py
--rw-r--r--  2.0 unx    15426 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersion.py
--rw-r--r--  2.0 unx    13578 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionCreateRequest.py
--rw-r--r--  2.0 unx     3924 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionCreateResponse.py
--rw-r--r--  2.0 unx     6072 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionFileListResponse.py
--rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionListResponse.py
--rw-r--r--  2.0 unx     3923 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionResponse.py
--rw-r--r--  2.0 unx    12069 b- defN 80-Jan-01 00:00 ngccli/data/model/ModelVersionUpdateRequest.py
--rw-r--r--  2.0 unx     5878 b- defN 80-Jan-01 00:00 ngccli/data/model/MultipartUploadAbortRequest.py
--rw-r--r--  2.0 unx     6906 b- defN 80-Jan-01 00:00 ngccli/data/model/MultipartUploadCompleteRequest.py
--rw-r--r--  2.0 unx     7401 b- defN 80-Jan-01 00:00 ngccli/data/model/MultipartUploadCreateRequest.py
--rw-r--r--  2.0 unx     6049 b- defN 80-Jan-01 00:00 ngccli/data/model/MultipartUploadCreateResponse.py
--rw-r--r--  2.0 unx     4827 b- defN 80-Jan-01 00:00 ngccli/data/model/PaginationInfo.py
--rw-r--r--  2.0 unx      130 b- defN 80-Jan-01 00:00 ngccli/data/model/PrecisionType.py
--rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 ngccli/data/model/ProductNamesEnum.py
--rw-r--r--  2.0 unx    27541 b- defN 80-Jan-01 00:00 ngccli/data/model/Recipe.py
--rw-r--r--  2.0 unx    19453 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeCreateRequest.py
--rw-r--r--  2.0 unx     5249 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeFile.py
--rw-r--r--  2.0 unx     4085 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeListResponse.py
--rw-r--r--  2.0 unx     2890 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeResponse.py
--rw-r--r--  2.0 unx    17702 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeUpdateRequest.py
--rw-r--r--  2.0 unx    17930 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersion.py
--rw-r--r--  2.0 unx    15539 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersionCreateRequest.py
--rw-r--r--  2.0 unx     6142 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersionFileListResponse.py
--rw-r--r--  2.0 unx     5130 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersionListResponse.py
--rw-r--r--  2.0 unx     3964 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersionResponse.py
--rw-r--r--  2.0 unx    14027 b- defN 80-Jan-01 00:00 ngccli/data/model/RecipeVersionUpdateRequest.py
--rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 ngccli/data/model/RequestStatus.py
--rw-r--r--  2.0 unx     1976 b- defN 80-Jan-01 00:00 ngccli/data/model/Response.py
--rw-r--r--  2.0 unx      358 b- defN 80-Jan-01 00:00 ngccli/data/model/SortOrderEnum.py
--rw-r--r--  2.0 unx      359 b- defN 80-Jan-01 00:00 ngccli/data/model/StatusCode.py
--rw-r--r--  2.0 unx      121 b- defN 80-Jan-01 00:00 ngccli/data/model/VersionStatusEnum.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/model/__init__.py
--rw-r--r--  2.0 unx     4439 b- defN 80-Jan-01 00:00 ngccli/data/package/Health.py
--rw-r--r--  2.0 unx     2001 b- defN 80-Jan-01 00:00 ngccli/data/package/HealthResponse.py
--rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngccli/data/package/MetaData.py
--rw-r--r--  2.0 unx     5574 b- defN 80-Jan-01 00:00 ngccli/data/package/Package.py
--rw-r--r--  2.0 unx     3999 b- defN 80-Jan-01 00:00 ngccli/data/package/PackageFile.py
--rw-r--r--  2.0 unx     6808 b- defN 80-Jan-01 00:00 ngccli/data/package/PackageVersion.py
--rw-r--r--  2.0 unx     5094 b- defN 80-Jan-01 00:00 ngccli/data/package/PackageVersionListResponse.py
--rw-r--r--  2.0 unx     3945 b- defN 80-Jan-01 00:00 ngccli/data/package/PackageVersionResponse.py
--rw-r--r--  2.0 unx     4827 b- defN 80-Jan-01 00:00 ngccli/data/package/PaginationInfo.py
--rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 ngccli/data/package/RequestStatus.py
--rw-r--r--  2.0 unx     1976 b- defN 80-Jan-01 00:00 ngccli/data/package/Response.py
--rw-r--r--  2.0 unx      359 b- defN 80-Jan-01 00:00 ngccli/data/package/StatusCode.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/package/__init__.py
--rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngccli/data/publishing/AccessTypeEnum.py
--rw-r--r--  2.0 unx     5242 b- defN 80-Jan-01 00:00 ngccli/data/publishing/Artifact.py
--rw-r--r--  2.0 unx     6230 b- defN 80-Jan-01 00:00 ngccli/data/publishing/ArtifactBatch.py
--rw-r--r--  2.0 unx     4473 b- defN 80-Jan-01 00:00 ngccli/data/publishing/ArtifactToCollectionRequest.py
--rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 ngccli/data/publishing/ArtifactType.py
--rw-r--r--  2.0 unx    10846 b- defN 80-Jan-01 00:00 ngccli/data/publishing/BatchPublishingRequest.py
--rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 ngccli/data/publishing/ProductNamesEnum.py
--rw-r--r--  2.0 unx    10067 b- defN 80-Jan-01 00:00 ngccli/data/publishing/PublishingRequest.py
--rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 ngccli/data/publishing/RequestStatus.py
--rw-r--r--  2.0 unx     1976 b- defN 80-Jan-01 00:00 ngccli/data/publishing/Response.py
--rw-r--r--  2.0 unx      415 b- defN 80-Jan-01 00:00 ngccli/data/publishing/StatusCode.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/publishing/__init__.py
--rw-r--r--  2.0 unx     3174 b- defN 80-Jan-01 00:00 ngccli/data/pym/AdditionalOpenPortURLs.py
--rw-r--r--  2.0 unx     3633 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterComponent.py
--rw-r--r--  2.0 unx     6010 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterComponentModifyParams.py
--rw-r--r--  2.0 unx     6742 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterComponentParams.py
--rw-r--r--  2.0 unx     3019 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterCreateRequest.py
--rw-r--r--  2.0 unx     7701 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterInfo.py
--rw-r--r--  2.0 unx     3089 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterInfoResponse.py
--rw-r--r--  2.0 unx     9539 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterInstance.py
--rw-r--r--  2.0 unx     3490 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterInstanceInfo.py
--rw-r--r--  2.0 unx     3365 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterInstanceTypesResponse.py
--rw-r--r--  2.0 unx     3149 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterListResponse.py
--rw-r--r--  2.0 unx    30037 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterModifyParams.py
--rw-r--r--  2.0 unx     3333 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterModifyRequest.py
--rw-r--r--  2.0 unx    30984 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterParams.py
--rw-r--r--  2.0 unx     6221 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterPortMapping.py
--rw-r--r--  2.0 unx    12789 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterRequestStatus.py
--rw-r--r--  2.0 unx      191 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterStatusEnum.py
--rw-r--r--  2.0 unx     3210 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterSuccessResponse.py
--rw-r--r--  2.0 unx     3048 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterTelemetry.py
--rw-r--r--  2.0 unx      102 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterTypeEnum.py
--rw-r--r--  2.0 unx     5293 b- defN 80-Jan-01 00:00 ngccli/data/pym/ClusterURLs.py
--rw-r--r--  2.0 unx     3188 b- defN 80-Jan-01 00:00 ngccli/data/pym/DataInput.py
--rw-r--r--  2.0 unx     2982 b- defN 80-Jan-01 00:00 ngccli/data/pym/Dataset.py
--rw-r--r--  2.0 unx     2943 b- defN 80-Jan-01 00:00 ngccli/data/pym/Env.py
--rw-r--r--  2.0 unx     4484 b- defN 80-Jan-01 00:00 ngccli/data/pym/HealthInfoItem.py
--rw-r--r--  2.0 unx     4004 b- defN 80-Jan-01 00:00 ngccli/data/pym/HealthResponse.py
--rw-r--r--  2.0 unx     5276 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectCreateRequest.py
--rw-r--r--  2.0 unx     7374 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectDetails.py
--rw-r--r--  2.0 unx     4120 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectInfoResponse.py
--rw-r--r--  2.0 unx     3119 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectListResponse.py
--rw-r--r--  2.0 unx     2976 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectModifyParams.py
--rw-r--r--  2.0 unx     3080 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectModifyRequest.py
--rw-r--r--  2.0 unx     3303 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectParams.py
--rw-r--r--  2.0 unx     4714 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectRequestStatus.py
--rw-r--r--  2.0 unx     3210 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectSuccessResponse.py
--rw-r--r--  2.0 unx     3129 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateCreateRequest.py
--rw-r--r--  2.0 unx     5220 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateInfoResponse.py
--rw-r--r--  2.0 unx     8708 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateListParams.py
--rw-r--r--  2.0 unx     3224 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateListResponse.py
--rw-r--r--  2.0 unx     3223 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateModificationRequest.py
--rw-r--r--  2.0 unx     6830 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateModifyParams.py
--rw-r--r--  2.0 unx     7106 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateParams.py
--rw-r--r--  2.0 unx    17506 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateParamsDeprecated.py
--rw-r--r--  2.0 unx     2752 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateRequestStatus.py
--rw-r--r--  2.0 unx     3333 b- defN 80-Jan-01 00:00 ngccli/data/pym/ProjectTemplateSuccessResponse.py
--rw-r--r--  2.0 unx     3314 b- defN 80-Jan-01 00:00 ngccli/data/pym/SecretKeySpec.py
--rw-r--r--  2.0 unx     4057 b- defN 80-Jan-01 00:00 ngccli/data/pym/SecretSpec.py
--rw-r--r--  2.0 unx     4074 b- defN 80-Jan-01 00:00 ngccli/data/pym/Workspace.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/pym/__init__.py
--rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngccli/data/registry/AccessTypeEnum.py
--rw-r--r--  2.0 unx     1719 b- defN 80-Jan-01 00:00 ngccli/data/registry/Actor.py
--rw-r--r--  2.0 unx     4859 b- defN 80-Jan-01 00:00 ngccli/data/registry/Allowlist.py
--rw-r--r--  2.0 unx     3193 b- defN 80-Jan-01 00:00 ngccli/data/registry/AllowlistItem.py
--rw-r--r--  2.0 unx     4036 b- defN 80-Jan-01 00:00 ngccli/data/registry/Analysis.py
--rw-r--r--  2.0 unx      139 b- defN 80-Jan-01 00:00 ngccli/data/registry/AnalysisStatus.py
--rw-r--r--  2.0 unx     2347 b- defN 80-Jan-01 00:00 ngccli/data/registry/AnchoreParameter.py
--rw-r--r--  2.0 unx     9910 b- defN 80-Jan-01 00:00 ngccli/data/registry/AnchorePolicyBundle.py
--rw-r--r--  2.0 unx     6971 b- defN 80-Jan-01 00:00 ngccli/data/registry/AnchorePolicyBundleRecord.py
--rw-r--r--  2.0 unx     5543 b- defN 80-Jan-01 00:00 ngccli/data/registry/BaseImageDetails.py
--rw-r--r--  2.0 unx     1732 b- defN 80-Jan-01 00:00 ngccli/data/registry/BaseImageList.py
--rw-r--r--  2.0 unx     2142 b- defN 80-Jan-01 00:00 ngccli/data/registry/BaseImagesDetailResponse.py
--rw-r--r--  2.0 unx     1666 b- defN 80-Jan-01 00:00 ngccli/data/registry/BlobSum.py
--rw-r--r--  2.0 unx     5084 b- defN 80-Jan-01 00:00 ngccli/data/registry/CatalogArtifactMetadata.py
--rw-r--r--  2.0 unx     2020 b- defN 80-Jan-01 00:00 ngccli/data/registry/Envelope.py
--rw-r--r--  2.0 unx     4956 b- defN 80-Jan-01 00:00 ngccli/data/registry/EventRequest.py
--rw-r--r--  2.0 unx     2664 b- defN 80-Jan-01 00:00 ngccli/data/registry/EventSource.py
--rw-r--r--  2.0 unx     6419 b- defN 80-Jan-01 00:00 ngccli/data/registry/EventTarget.py
--rw-r--r--  2.0 unx     8208 b- defN 80-Jan-01 00:00 ngccli/data/registry/GetManifestByTagResponse.py
--rw-r--r--  2.0 unx     3749 b- defN 80-Jan-01 00:00 ngccli/data/registry/GetRepositoryTagVexResponse.py
--rw-r--r--  2.0 unx     3392 b- defN 80-Jan-01 00:00 ngccli/data/registry/GetTagsResponse.py
--rw-r--r--  2.0 unx     2451 b- defN 80-Jan-01 00:00 ngccli/data/registry/Header.py
--rw-r--r--  2.0 unx     1797 b- defN 80-Jan-01 00:00 ngccli/data/registry/HistoryLayer.py
--rw-r--r--  2.0 unx     8463 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageArchitectureVariant.py
--rw-r--r--  2.0 unx     2972 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageDeleteRequest.py
--rw-r--r--  2.0 unx     8722 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageOwnerDetails.py
--rw-r--r--  2.0 unx     2342 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageRef.py
--rw-r--r--  2.0 unx    10863 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageScanDetails.py
--rw-r--r--  2.0 unx     4699 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageSelectionRule.py
--rw-r--r--  2.0 unx     2557 b- defN 80-Jan-01 00:00 ngccli/data/registry/ImageSignature.py
--rw-r--r--  2.0 unx     4468 b- defN 80-Jan-01 00:00 ngccli/data/registry/Jwk.py
--rw-r--r--  2.0 unx     7637 b- defN 80-Jan-01 00:00 ngccli/data/registry/ManifestByTagV2Response.py
--rw-r--r--  2.0 unx     4764 b- defN 80-Jan-01 00:00 ngccli/data/registry/ManifestListByTagV2Response.py
--rw-r--r--  2.0 unx     3209 b- defN 80-Jan-01 00:00 ngccli/data/registry/ManifestV2Config.py
--rw-r--r--  2.0 unx     3186 b- defN 80-Jan-01 00:00 ngccli/data/registry/ManifestV2Layer.py
--rw-r--r--  2.0 unx     6468 b- defN 80-Jan-01 00:00 ngccli/data/registry/MappingRule.py
--rw-r--r--  2.0 unx    12531 b- defN 80-Jan-01 00:00 ngccli/data/registry/MetaImageDetails.py
--rw-r--r--  2.0 unx     5927 b- defN 80-Jan-01 00:00 ngccli/data/registry/MetaImageDetailsList.py
--rw-r--r--  2.0 unx     3998 b- defN 80-Jan-01 00:00 ngccli/data/registry/OciIndexManifest.py
--rw-r--r--  2.0 unx     4703 b- defN 80-Jan-01 00:00 ngccli/data/registry/OciIndexResponse.py
--rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngccli/data/registry/PaginationInfo.py
--rw-r--r--  2.0 unx     4309 b- defN 80-Jan-01 00:00 ngccli/data/registry/Platform.py
--rw-r--r--  2.0 unx     4840 b- defN 80-Jan-01 00:00 ngccli/data/registry/PlatformManifest.py
--rw-r--r--  2.0 unx     4845 b- defN 80-Jan-01 00:00 ngccli/data/registry/PolicyRule.py
--rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 ngccli/data/registry/ProductNamesEnum.py
--rw-r--r--  2.0 unx     6858 b- defN 80-Jan-01 00:00 ngccli/data/registry/RegistryEvent.py
--rw-r--r--  2.0 unx    27728 b- defN 80-Jan-01 00:00 ngccli/data/registry/Repository.py
--rw-r--r--  2.0 unx    11157 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryCreateRequest.py
--rw-r--r--  2.0 unx    11907 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryImageDetails.py
--rw-r--r--  2.0 unx     4159 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryImageDetailsList.py
--rw-r--r--  2.0 unx     5902 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryImageScanComplete.py
--rw-r--r--  2.0 unx     4440 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryImagesDeletedEvent.py
--rw-r--r--  2.0 unx    16048 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryInfoUpdateRequest.py
--rw-r--r--  2.0 unx     1677 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryLabelsPatchRequest.py
--rw-r--r--  2.0 unx     4182 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryList.py
--rw-r--r--  2.0 unx     2672 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryTagVexByDigest.py
--rw-r--r--  2.0 unx     2528 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryTagVexDetail.py
--rw-r--r--  2.0 unx     2758 b- defN 80-Jan-01 00:00 ngccli/data/registry/RepositoryTagsCountResponse.py
--rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngccli/data/registry/RequestStatus.py
--rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngccli/data/registry/Response.py
--rw-r--r--  2.0 unx     4870 b- defN 80-Jan-01 00:00 ngccli/data/registry/RuleSet.py
--rw-r--r--  2.0 unx     7489 b- defN 80-Jan-01 00:00 ngccli/data/registry/ScanIssue.py
--rw-r--r--  2.0 unx     2486 b- defN 80-Jan-01 00:00 ngccli/data/registry/ScanIssueCount.py
--rw-r--r--  2.0 unx      137 b- defN 80-Jan-01 00:00 ngccli/data/registry/ScanIssueSeverity.py
--rw-r--r--  2.0 unx      138 b- defN 80-Jan-01 00:00 ngccli/data/registry/ScanStatus.py
--rw-r--r--  2.0 unx      102 b- defN 80-Jan-01 00:00 ngccli/data/registry/ScanType.py
--rw-r--r--  2.0 unx     7621 b- defN 80-Jan-01 00:00 ngccli/data/registry/SecurityRatingDescription.py
--rw-r--r--  2.0 unx      119 b- defN 80-Jan-01 00:00 ngccli/data/registry/SecurityRatingType.py
--rw-r--r--  2.0 unx     2081 b- defN 80-Jan-01 00:00 ngccli/data/registry/SecurityRatingsResponse.py
--rw-r--r--  2.0 unx      317 b- defN 80-Jan-01 00:00 ngccli/data/registry/StatusCode.py
--rw-r--r--  2.0 unx     1766 b- defN 80-Jan-01 00:00 ngccli/data/registry/TagUpdateRequest.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/registry/__init__.py
--rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 ngccli/data/search/AccessTypeEnum.py
--rw-r--r--  2.0 unx     3344 b- defN 80-Jan-01 00:00 ngccli/data/search/CountParams.py
--rw-r--r--  2.0 unx     3146 b- defN 80-Jan-01 00:00 ngccli/data/search/CountParamsField.py
--rw-r--r--  2.0 unx     3360 b- defN 80-Jan-01 00:00 ngccli/data/search/CountResponse.py
--rw-r--r--  2.0 unx     4031 b- defN 80-Jan-01 00:00 ngccli/data/search/CountResponseCount.py
--rw-r--r--  2.0 unx     2046 b- defN 80-Jan-01 00:00 ngccli/data/search/CountResponseParams.py
--rw-r--r--  2.0 unx     4468 b- defN 80-Jan-01 00:00 ngccli/data/search/Health.py
--rw-r--r--  2.0 unx     1989 b- defN 80-Jan-01 00:00 ngccli/data/search/HealthResponse.py
--rw-r--r--  2.0 unx     3689 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelGroup.py
--rw-r--r--  2.0 unx     3647 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelGroupValue.py
--rw-r--r--  2.0 unx     2001 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelResponseGlobal.py
--rw-r--r--  2.0 unx     2842 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelResponseOrgTeam.py
--rw-r--r--  2.0 unx     9026 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelSet.py
--rw-r--r--  2.0 unx     5850 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelSetCreateRequest.py
--rw-r--r--  2.0 unx     8710 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelSetResponse.py
--rw-r--r--  2.0 unx     4151 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelSetUpdateRequest.py
--rw-r--r--  2.0 unx     3461 b- defN 80-Jan-01 00:00 ngccli/data/search/LabelValue.py
--rw-r--r--  2.0 unx     2018 b- defN 80-Jan-01 00:00 ngccli/data/search/ListLabelSetsResponse.py
--rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngccli/data/search/MetaData.py
--rw-r--r--  2.0 unx    23861 b- defN 80-Jan-01 00:00 ngccli/data/search/Resource.py
--rw-r--r--  2.0 unx     3140 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourceAttribute.py
--rw-r--r--  2.0 unx      113 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourceEventEnum.py
--rw-r--r--  2.0 unx     2891 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourceLabel.py
--rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourcePopularityTypeEnum.py
--rw-r--r--  2.0 unx     5387 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourcePopularityUpdate.py
--rw-r--r--  2.0 unx      233 b- defN 80-Jan-01 00:00 ngccli/data/search/ResourceTypeEnum.py
--rw-r--r--  2.0 unx     4374 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchFilterCategory.py
--rw-r--r--  2.0 unx     3896 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchFilterValue.py
--rw-r--r--  2.0 unx     3095 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchParamFilter.py
--rw-r--r--  2.0 unx     3197 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchParamOrderBy.py
--rw-r--r--  2.0 unx      109 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchParamOrderByEnum.py
--rw-r--r--  2.0 unx    10137 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchParams.py
--rw-r--r--  2.0 unx     3716 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchPopularityUpdateQueueMsg.py
--rw-r--r--  2.0 unx     3224 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchQueueMsg.py
--rw-r--r--  2.0 unx     5330 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchResponse.py
--rw-r--r--  2.0 unx     4724 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchResponseResult.py
--rw-r--r--  2.0 unx    22530 b- defN 80-Jan-01 00:00 ngccli/data/search/SearchResponseResultResource.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/search/__init__.py
--rw-r--r--  2.0 unx     2905 b- defN 80-Jan-01 00:00 ngccli/data/sms/HealthResponse.py
--rw-r--r--  2.0 unx     3116 b- defN 80-Jan-01 00:00 ngccli/data/sms/KV.py
--rw-r--r--  2.0 unx     8710 b- defN 80-Jan-01 00:00 ngccli/data/sms/Secret.py
--rw-r--r--  2.0 unx     4968 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretCreateRequest.py
--rw-r--r--  2.0 unx     4395 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretDecryptRequest.py
--rw-r--r--  2.0 unx     3253 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretDecryptResponse.py
--rw-r--r--  2.0 unx     3037 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretGetResponse.py
--rw-r--r--  2.0 unx     4583 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretModifyRequest.py
--rw-r--r--  2.0 unx     3123 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretNameKV.py
--rw-r--r--  2.0 unx     3680 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretRequestStatus.py
--rw-r--r--  2.0 unx     3197 b- defN 80-Jan-01 00:00 ngccli/data/sms/SecretSuccessResponse.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/sms/__init__.py
--rw-r--r--  2.0 unx     3043 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Action.py
--rw-r--r--  2.0 unx    16440 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/AzureMarketplaceSubscription.py
--rw-r--r--  2.0 unx    11664 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py
--rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py
--rw-r--r--  2.0 unx     4002 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py
--rw-r--r--  2.0 unx    13228 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/BusinessContact.py
--rw-r--r--  2.0 unx     7569 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Charge.py
--rw-r--r--  2.0 unx     3844 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateOrderRequest.py
--rw-r--r--  2.0 unx     2814 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateOrderResponse.py
--rw-r--r--  2.0 unx     2189 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateProductOfferRequest.py
--rw-r--r--  2.0 unx     3027 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateProductOfferResponse.py
--rw-r--r--  2.0 unx     1837 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateProductRequest.py
--rw-r--r--  2.0 unx     2199 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateSubscriptionsRequest.py
--rw-r--r--  2.0 unx     3121 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/CreateSubscriptionsResponse.py
--rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ErrorResponse.py
--rw-r--r--  2.0 unx     3167 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/GetSubscriptionRequestResponse.py
--rw-r--r--  2.0 unx      165 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/GtsOrderTypeEnum.py
--rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Health.py
--rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/HealthResponse.py
--rw-r--r--  2.0 unx     8838 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/LineItem.py
--rw-r--r--  2.0 unx      116 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/LineItemTypeEnum.py
--rw-r--r--  2.0 unx     3024 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ListProductOffersResponse.py
--rw-r--r--  2.0 unx     4376 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ListSubscriptionRequestsResponse.py
--rw-r--r--  2.0 unx     3146 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ListSubscriptionsResponse.py
--rw-r--r--  2.0 unx     3180 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ListUserSubscriptionsResponse.py
--rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/MetaData.py
--rw-r--r--  2.0 unx     6764 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Order.py
--rw-r--r--  2.0 unx      319 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/OrderActionTypeEnum.py
--rw-r--r--  2.0 unx     5498 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/OrderSummary.py
--rw-r--r--  2.0 unx     3450 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/OrgEnablementCreateRequest.py
--rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PaginationInfo.py
--rw-r--r--  2.0 unx     5380 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PreviewOrder.py
--rw-r--r--  2.0 unx     3848 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PreviewOrderRequest.py
--rw-r--r--  2.0 unx     2991 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PreviewOrderResponse.py
--rw-r--r--  2.0 unx      104 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PriceFormatEnum.py
--rw-r--r--  2.0 unx     7508 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Pricing.py
--rw-r--r--  2.0 unx    19993 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Product.py
--rw-r--r--  2.0 unx     5273 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductEnablement.py
--rw-r--r--  2.0 unx     4859 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductOffer.py
--rw-r--r--  2.0 unx    15339 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductPlan.py
--rw-r--r--  2.0 unx     3120 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductPlansResponse.py
--rw-r--r--  2.0 unx     2851 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductResponse.py
--rw-r--r--  2.0 unx     3026 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ProductsResponse.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/PurchaseOrder.py
--rw-r--r--  2.0 unx     1911 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py
--rw-r--r--  2.0 unx     2964 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py
--rw-r--r--  2.0 unx     2957 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RedeemSubscriptionRequest.py
--rw-r--r--  2.0 unx     2820 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RedeemSubscriptionResponse.py
--rw-r--r--  2.0 unx     6650 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RelatedArtifact.py
--rw-r--r--  2.0 unx     3212 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RelatedArtifactsResponse.py
--rw-r--r--  2.0 unx     2371 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RelatedItem.py
--rw-r--r--  2.0 unx     3001 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RenewSubscriptionResponse.py
--rw-r--r--  2.0 unx     2703 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RequestCreateSubscriptionRequest.py
--rw-r--r--  2.0 unx     3175 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RequestCreateSubscriptionResponse.py
--rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/RequestStatus.py
--rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Response.py
--rw-r--r--  2.0 unx     5119 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/ReviewSubscriptionRequestRequest.py
--rw-r--r--  2.0 unx      450 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/StatusCode.py
--rw-r--r--  2.0 unx    18782 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Subscription.py
--rw-r--r--  2.0 unx    17298 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequest.py
--rw-r--r--  2.0 unx      214 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequestActionEnum.py
--rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py
--rw-r--r--  2.0 unx     8580 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequestHistory.py
--rw-r--r--  2.0 unx      149 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequestStatusEnum.py
--rw-r--r--  2.0 unx      138 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py
--rw-r--r--  2.0 unx     2994 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionResponse.py
--rw-r--r--  2.0 unx      169 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/SubscriptionStatusEnum.py
--rw-r--r--  2.0 unx     2397 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Tab.py
--rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/Tou.py
--rw-r--r--  2.0 unx     3797 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/UpdateAccountStatusGtsRequest.py
--rw-r--r--  2.0 unx     2745 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/UpdateAccountStatusGtsResponse.py
--rw-r--r--  2.0 unx     1837 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/UpdateProductRequest.py
--rw-r--r--  2.0 unx     2416 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/UserSubscriptions.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/subscription_management_service/__init__.py
--rw-r--r--  2.0 unx     9513 b- defN 80-Jan-01 00:00 ngccli/data/uis/AccountInfo.py
--rw-r--r--  2.0 unx     1859 b- defN 80-Jan-01 00:00 ngccli/data/uis/AddRolesRequest.py
--rw-r--r--  2.0 unx     3615 b- defN 80-Jan-01 00:00 ngccli/data/uis/AlternateContact.py
--rw-r--r--  2.0 unx     9270 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKey.py
--rw-r--r--  2.0 unx     5026 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKeyPolicy.py
--rw-r--r--  2.0 unx     4981 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKeyRequest.py
--rw-r--r--  2.0 unx     2848 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKeyResponse.py
--rw-r--r--  2.0 unx      113 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKeyStatusEnum.py
--rw-r--r--  2.0 unx      144 b- defN 80-Jan-01 00:00 ngccli/data/uis/ApiKeyTypeEnum.py
--rw-r--r--  2.0 unx     4899 b- defN 80-Jan-01 00:00 ngccli/data/uis/CreateBillingAccountRequest.py
--rw-r--r--  2.0 unx     3418 b- defN 80-Jan-01 00:00 ngccli/data/uis/CreateBillingAccountResponse.py
--rw-r--r--  2.0 unx     1864 b- defN 80-Jan-01 00:00 ngccli/data/uis/CreateUserRolesRequest.py
--rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 ngccli/data/uis/EmailTemplateDataSourceEnum.py
--rw-r--r--  2.0 unx      305 b- defN 80-Jan-01 00:00 ngccli/data/uis/EmailTemplateTypeEnum.py
--rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 ngccli/data/uis/ErrorResponse.py
--rw-r--r--  2.0 unx     2690 b- defN 80-Jan-01 00:00 ngccli/data/uis/GetUchIdByOrgResponse.py
--rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 ngccli/data/uis/Health.py
--rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 ngccli/data/uis/HealthResponse.py
--rw-r--r--  2.0 unx     7085 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpLock.py
--rw-r--r--  2.0 unx     3320 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpLockResponse.py
--rw-r--r--  2.0 unx    10866 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpRule.py
--rw-r--r--  2.0 unx     4541 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpRuleListResponse.py
--rw-r--r--  2.0 unx     4778 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpRuleRequest.py
--rw-r--r--  2.0 unx     3295 b- defN 80-Jan-01 00:00 ngccli/data/uis/IdpRuleResponse.py
--rw-r--r--  2.0 unx     2720 b- defN 80-Jan-01 00:00 ngccli/data/uis/InfinityManagerSettings.py
--rw-r--r--  2.0 unx     2975 b- defN 80-Jan-01 00:00 ngccli/data/uis/ListApiKeysResponse.py
--rw-r--r--  2.0 unx     2774 b- defN 80-Jan-01 00:00 ngccli/data/uis/ListRolesResponse.py
--rw-r--r--  2.0 unx     4307 b- defN 80-Jan-01 00:00 ngccli/data/uis/ListUserRolesResponse.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/uis/MetaData.py
--rw-r--r--  2.0 unx     4868 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfCluster.py
--rw-r--r--  2.0 unx     6570 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfGpuUsage.py
--rw-r--r--  2.0 unx     2013 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfGpuUsageRequest.py
--rw-r--r--  2.0 unx     3039 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfGpuUsageResponse.py
--rw-r--r--  2.0 unx     5013 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfOrgResponse.py
--rw-r--r--  2.0 unx     2013 b- defN 80-Jan-01 00:00 ngccli/data/uis/NvcfOrgUpdateRequest.py
--rw-r--r--  2.0 unx     3446 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgAdminUserCreatedEvent.py
--rw-r--r--  2.0 unx     4197 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgListResponse.py
--rw-r--r--  2.0 unx     5428 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgOwner.py
--rw-r--r--  2.0 unx     3126 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgOwnerUpdateRequest.py
--rw-r--r--  2.0 unx     4150 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgOwnersResponse.py
--rw-r--r--  2.0 unx     3459 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgProfileUpdateRequest.py
--rw-r--r--  2.0 unx      118 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgType.py
--rw-r--r--  2.0 unx    19528 b- defN 80-Jan-01 00:00 ngccli/data/uis/OrgUpdateRequest.py
--rw-r--r--  2.0 unx    25089 b- defN 80-Jan-01 00:00 ngccli/data/uis/Organization.py
--rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 ngccli/data/uis/PaginationInfo.py
--rw-r--r--  2.0 unx     5273 b- defN 80-Jan-01 00:00 ngccli/data/uis/ProductEnablement.py
--rw-r--r--  2.0 unx     7235 b- defN 80-Jan-01 00:00 ngccli/data/uis/ProductSubscription.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/uis/PurchaseOrder.py
--rw-r--r--  2.0 unx     1872 b- defN 80-Jan-01 00:00 ngccli/data/uis/RemoveRolesRequest.py
--rw-r--r--  2.0 unx    11504 b- defN 80-Jan-01 00:00 ngccli/data/uis/RemovedUser.py
--rw-r--r--  2.0 unx     4132 b- defN 80-Jan-01 00:00 ngccli/data/uis/RemovedUserListResponse.py
--rw-r--r--  2.0 unx     6724 b- defN 80-Jan-01 00:00 ngccli/data/uis/RepoScanSettings.py
--rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 ngccli/data/uis/RequestStatus.py
--rw-r--r--  2.0 unx     2320 b- defN 80-Jan-01 00:00 ngccli/data/uis/Resource.py
--rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 ngccli/data/uis/Response.py
--rw-r--r--  2.0 unx     3890 b- defN 80-Jan-01 00:00 ngccli/data/uis/RoleScopes.py
--rw-r--r--  2.0 unx     2034 b- defN 80-Jan-01 00:00 ngccli/data/uis/RoleScopesRequest.py
--rw-r--r--  2.0 unx     3060 b- defN 80-Jan-01 00:00 ngccli/data/uis/RoleScopesResponse.py
--rw-r--r--  2.0 unx     1726 b- defN 80-Jan-01 00:00 ngccli/data/uis/RoleType.py
--rw-r--r--  2.0 unx     1940 b- defN 80-Jan-01 00:00 ngccli/data/uis/RotateApiKeyRequest.py
--rw-r--r--  2.0 unx     1975 b- defN 80-Jan-01 00:00 ngccli/data/uis/SakCallerInfoRequest.py
--rw-r--r--  2.0 unx     5852 b- defN 80-Jan-01 00:00 ngccli/data/uis/SakCallerInfoResponse.py
--rw-r--r--  2.0 unx     9736 b- defN 80-Jan-01 00:00 ngccli/data/uis/SendTemplatedEmailRequest.py
--rw-r--r--  2.0 unx     3012 b- defN 80-Jan-01 00:00 ngccli/data/uis/ServiceAccess.py
--rw-r--r--  2.0 unx      450 b- defN 80-Jan-01 00:00 ngccli/data/uis/StatusCode.py
--rw-r--r--  2.0 unx     5648 b- defN 80-Jan-01 00:00 ngccli/data/uis/TargetSystemUserIdentifier.py
--rw-r--r--  2.0 unx     6353 b- defN 80-Jan-01 00:00 ngccli/data/uis/Team.py
--rw-r--r--  2.0 unx     3756 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamCreateRequest.py
--rw-r--r--  2.0 unx     2856 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamCreateResponse.py
--rw-r--r--  2.0 unx     3332 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamCreatedEvent.py
--rw-r--r--  2.0 unx     4017 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamListResponse.py
--rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamResponse.py
--rw-r--r--  2.0 unx     4496 b- defN 80-Jan-01 00:00 ngccli/data/uis/TeamUpdateRequest.py
--rw-r--r--  2.0 unx     3032 b- defN 80-Jan-01 00:00 ngccli/data/uis/UisOrgInfoResponse.py
--rw-r--r--  2.0 unx     2811 b- defN 80-Jan-01 00:00 ngccli/data/uis/UpdateApiKeyRequest.py
--rw-r--r--  2.0 unx     4360 b- defN 80-Jan-01 00:00 ngccli/data/uis/UpdateUisOrgInfoRequest.py
--rw-r--r--  2.0 unx    33471 b- defN 80-Jan-01 00:00 ngccli/data/uis/User.py
--rw-r--r--  2.0 unx     9435 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserCreateRequest.py
--rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserCreatedEvent.py
--rw-r--r--  2.0 unx      136 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserGdprStatus.py
--rw-r--r--  2.0 unx      164 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserIdentifierType.py
--rw-r--r--  2.0 unx     9651 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserInvitation.py
--rw-r--r--  2.0 unx     4231 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserInvitationListResponse.py
--rw-r--r--  2.0 unx     2988 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserInvitationResponse.py
--rw-r--r--  2.0 unx     5560 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserKeyResponse.py
--rw-r--r--  2.0 unx     4058 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserListResponse.py
--rw-r--r--  2.0 unx     8112 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserMetadata.py
--rw-r--r--  2.0 unx    11401 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserProfile.py
--rw-r--r--  2.0 unx     3002 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserProfileGetResponse.py
--rw-r--r--  2.0 unx     5170 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserProfileOrgInfo.py
--rw-r--r--  2.0 unx     1982 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserProfileUpdateRequest.py
--rw-r--r--  2.0 unx     4806 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserResponse.py
--rw-r--r--  2.0 unx     6556 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserRole.py
--rw-r--r--  2.0 unx     2808 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserRoleDefinition.py
--rw-r--r--  2.0 unx     5029 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserRoles.py
--rw-r--r--  2.0 unx      112 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserStatus.py
--rw-r--r--  2.0 unx    12800 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserStorageQuota.py
--rw-r--r--  2.0 unx    22375 b- defN 80-Jan-01 00:00 ngccli/data/uis/UserUpdateRequest.py
--rw-r--r--  2.0 unx     1718 b- defN 80-Jan-01 00:00 ngccli/data/uis/UsersInfo.py
--rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 ngccli/data/uis/__init__.py
--rw-r--r--  2.0 unx     4540 b- defN 80-Jan-01 00:00 ngcsdk/__init__.py
+-rw-r--r--  2.0 unx    18177 b- defN 80-Jan-01 00:00 ngcbpc/util/utils.py
+-rw-r--r--  2.0 unx     4777 b- defN 80-Jan-01 00:00 ngcsdk/__init__.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 nvcf/api/__init__.py
 -rw-r--r--  2.0 unx     7605 b- defN 80-Jan-01 00:00 nvcf/api/asset.py
 -rw-r--r--  2.0 unx     9212 b- defN 80-Jan-01 00:00 nvcf/api/deploy.py
 -rw-r--r--  2.0 unx     3901 b- defN 80-Jan-01 00:00 nvcf/api/deployment_spec.py
--rw-r--r--  2.0 unx    20295 b- defN 80-Jan-01 00:00 nvcf/api/function.py
+-rw-r--r--  2.0 unx    21436 b- defN 80-Jan-01 00:00 nvcf/api/function.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 nvcf/api/gdn_nvcf_grpc_client/__init__.py
 -rw-r--r--  2.0 unx    27469 b- defN 80-Jan-01 00:00 nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2.py
 -rw-r--r--  2.0 unx    39051 b- defN 80-Jan-01 00:00 nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2_grpc.py
 -rw-r--r--  2.0 unx    25600 b- defN 80-Jan-01 00:00 nvcf/api/gdn_nvcf_grpc_client/model_config_pb2.py
 -rw-r--r--  2.0 unx     9301 b- defN 80-Jan-01 00:00 nvcf/api/invocation_handler.py
 -rw-r--r--  2.0 unx     1136 b- defN 80-Jan-01 00:00 nvcf/api/nvcf.py
 -rw-r--r--  2.0 unx     1147 b- defN 80-Jan-01 00:00 nvcf/api/utils.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 nvcf/command/__init__.py
 -rw-r--r--  2.0 unx      610 b- defN 80-Jan-01 00:00 nvcf/command/all_commands.py
 -rw-r--r--  2.0 unx     1484 b- defN 80-Jan-01 00:00 nvcf/command/args_validation.py
 -rw-r--r--  2.0 unx     1415 b- defN 80-Jan-01 00:00 nvcf/command/cloud_function.py
 -rw-r--r--  2.0 unx     5797 b- defN 80-Jan-01 00:00 nvcf/command/deploy.py
--rw-r--r--  2.0 unx     9166 b- defN 80-Jan-01 00:00 nvcf/command/function.py
+-rw-r--r--  2.0 unx     9730 b- defN 80-Jan-01 00:00 nvcf/command/function.py
 -rw-r--r--  2.0 unx     3388 b- defN 80-Jan-01 00:00 nvcf/command/utils.py
 -rw-r--r--  2.0 unx      833 b- defN 80-Jan-01 00:00 nvcf/constants.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 nvcf/printer/__init__.py
 -rw-r--r--  2.0 unx     5121 b- defN 80-Jan-01 00:00 nvcf/printer/deploy_printer.py
--rw-r--r--  2.0 unx     3804 b- defN 80-Jan-01 00:00 nvcf/printer/function_printer.py
+-rw-r--r--  2.0 unx     4235 b- defN 80-Jan-01 00:00 nvcf/printer/function_printer.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 organization/__init__.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 organization/api/__init__.py
 -rw-r--r--  2.0 unx     3070 b- defN 80-Jan-01 00:00 organization/api/alert.py
 -rw-r--r--  2.0 unx     5957 b- defN 80-Jan-01 00:00 organization/api/audit.py
 -rw-r--r--  2.0 unx     1738 b- defN 80-Jan-01 00:00 organization/api/organization.py
 -rw-r--r--  2.0 unx     2275 b- defN 80-Jan-01 00:00 organization/api/orgs.py
--rw-r--r--  2.0 unx     9174 b- defN 80-Jan-01 00:00 organization/api/secrets.py
+-rw-r--r--  2.0 unx     9198 b- defN 80-Jan-01 00:00 organization/api/secrets.py
 -rw-r--r--  2.0 unx     1479 b- defN 80-Jan-01 00:00 organization/api/storage.py
--rw-r--r--  2.0 unx     7816 b- defN 80-Jan-01 00:00 organization/api/subscription.py
+-rw-r--r--  2.0 unx     7846 b- defN 80-Jan-01 00:00 organization/api/subscription.py
 -rw-r--r--  2.0 unx     5318 b- defN 80-Jan-01 00:00 organization/api/teams.py
 -rw-r--r--  2.0 unx    22690 b- defN 80-Jan-01 00:00 organization/api/users.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 organization/command/__init__.py
 -rw-r--r--  2.0 unx     7691 b- defN 80-Jan-01 00:00 organization/command/alert.py
 -rw-r--r--  2.0 unx      817 b- defN 80-Jan-01 00:00 organization/command/all_commands.py
 -rw-r--r--  2.0 unx     5334 b- defN 80-Jan-01 00:00 organization/command/audit.py
 -rw-r--r--  2.0 unx    15269 b- defN 80-Jan-01 00:00 organization/command/org.py
 -rw-r--r--  2.0 unx     6548 b- defN 80-Jan-01 00:00 organization/command/secret.py
--rw-r--r--  2.0 unx     8457 b- defN 80-Jan-01 00:00 organization/command/subscription.py
+-rw-r--r--  2.0 unx     8463 b- defN 80-Jan-01 00:00 organization/command/subscription.py
 -rw-r--r--  2.0 unx    19595 b- defN 80-Jan-01 00:00 organization/command/team.py
 -rw-r--r--  2.0 unx     4717 b- defN 80-Jan-01 00:00 organization/command/user.py
+-rw-r--r--  2.0 unx     2905 b- defN 80-Jan-01 00:00 organization/data/sms/HealthResponse.py
+-rw-r--r--  2.0 unx     3116 b- defN 80-Jan-01 00:00 organization/data/sms/KV.py
+-rw-r--r--  2.0 unx     8710 b- defN 80-Jan-01 00:00 organization/data/sms/Secret.py
+-rw-r--r--  2.0 unx     4968 b- defN 80-Jan-01 00:00 organization/data/sms/SecretCreateRequest.py
+-rw-r--r--  2.0 unx     4395 b- defN 80-Jan-01 00:00 organization/data/sms/SecretDecryptRequest.py
+-rw-r--r--  2.0 unx     3253 b- defN 80-Jan-01 00:00 organization/data/sms/SecretDecryptResponse.py
+-rw-r--r--  2.0 unx     3037 b- defN 80-Jan-01 00:00 organization/data/sms/SecretGetResponse.py
+-rw-r--r--  2.0 unx     4583 b- defN 80-Jan-01 00:00 organization/data/sms/SecretModifyRequest.py
+-rw-r--r--  2.0 unx     3123 b- defN 80-Jan-01 00:00 organization/data/sms/SecretNameKV.py
+-rw-r--r--  2.0 unx     3680 b- defN 80-Jan-01 00:00 organization/data/sms/SecretRequestStatus.py
+-rw-r--r--  2.0 unx     3197 b- defN 80-Jan-01 00:00 organization/data/sms/SecretSuccessResponse.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 organization/data/sms/__init__.py
+-rw-r--r--  2.0 unx     3043 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Action.py
+-rw-r--r--  2.0 unx    16440 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/AzureMarketplaceSubscription.py
+-rw-r--r--  2.0 unx    11664 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py
+-rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py
+-rw-r--r--  2.0 unx     4002 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py
+-rw-r--r--  2.0 unx    13228 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/BusinessContact.py
+-rw-r--r--  2.0 unx     7569 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Charge.py
+-rw-r--r--  2.0 unx     3844 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateOrderRequest.py
+-rw-r--r--  2.0 unx     2814 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateOrderResponse.py
+-rw-r--r--  2.0 unx     2189 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateProductOfferRequest.py
+-rw-r--r--  2.0 unx     3027 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateProductOfferResponse.py
+-rw-r--r--  2.0 unx     1837 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateProductRequest.py
+-rw-r--r--  2.0 unx     2199 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateSubscriptionsRequest.py
+-rw-r--r--  2.0 unx     3121 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/CreateSubscriptionsResponse.py
+-rw-r--r--  2.0 unx     1941 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ErrorResponse.py
+-rw-r--r--  2.0 unx     3167 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/GetSubscriptionRequestResponse.py
+-rw-r--r--  2.0 unx      165 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/GtsOrderTypeEnum.py
+-rw-r--r--  2.0 unx     4431 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Health.py
+-rw-r--r--  2.0 unx     3013 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/HealthResponse.py
+-rw-r--r--  2.0 unx     8838 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/LineItem.py
+-rw-r--r--  2.0 unx      116 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/LineItemTypeEnum.py
+-rw-r--r--  2.0 unx     3024 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ListProductOffersResponse.py
+-rw-r--r--  2.0 unx     4376 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ListSubscriptionRequestsResponse.py
+-rw-r--r--  2.0 unx     3146 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ListSubscriptionsResponse.py
+-rw-r--r--  2.0 unx     3180 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ListUserSubscriptionsResponse.py
+-rw-r--r--  2.0 unx     2762 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/MetaData.py
+-rw-r--r--  2.0 unx     6764 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Order.py
+-rw-r--r--  2.0 unx      319 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/OrderActionTypeEnum.py
+-rw-r--r--  2.0 unx     5498 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/OrderSummary.py
+-rw-r--r--  2.0 unx     3450 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/OrgEnablementCreateRequest.py
+-rw-r--r--  2.0 unx     4853 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PaginationInfo.py
+-rw-r--r--  2.0 unx     5380 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PreviewOrder.py
+-rw-r--r--  2.0 unx     3848 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PreviewOrderRequest.py
+-rw-r--r--  2.0 unx     2991 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PreviewOrderResponse.py
+-rw-r--r--  2.0 unx      104 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PriceFormatEnum.py
+-rw-r--r--  2.0 unx     7508 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Pricing.py
+-rw-r--r--  2.0 unx    19993 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Product.py
+-rw-r--r--  2.0 unx     5273 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductEnablement.py
+-rw-r--r--  2.0 unx     4859 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductOffer.py
+-rw-r--r--  2.0 unx    15339 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductPlan.py
+-rw-r--r--  2.0 unx     3120 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductPlansResponse.py
+-rw-r--r--  2.0 unx     2851 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductResponse.py
+-rw-r--r--  2.0 unx     3026 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ProductsResponse.py
+-rw-r--r--  2.0 unx     2525 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/PurchaseOrder.py
+-rw-r--r--  2.0 unx     1911 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py
+-rw-r--r--  2.0 unx     2964 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py
+-rw-r--r--  2.0 unx     2957 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RedeemSubscriptionRequest.py
+-rw-r--r--  2.0 unx     2820 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RedeemSubscriptionResponse.py
+-rw-r--r--  2.0 unx     6650 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RelatedArtifact.py
+-rw-r--r--  2.0 unx     3212 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RelatedArtifactsResponse.py
+-rw-r--r--  2.0 unx     2371 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RelatedItem.py
+-rw-r--r--  2.0 unx     3001 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RenewSubscriptionResponse.py
+-rw-r--r--  2.0 unx     2703 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RequestCreateSubscriptionRequest.py
+-rw-r--r--  2.0 unx     3175 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RequestCreateSubscriptionResponse.py
+-rw-r--r--  2.0 unx     4127 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/RequestStatus.py
+-rw-r--r--  2.0 unx     1936 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Response.py
+-rw-r--r--  2.0 unx     5119 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/ReviewSubscriptionRequestRequest.py
+-rw-r--r--  2.0 unx      450 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/StatusCode.py
+-rw-r--r--  2.0 unx    18782 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Subscription.py
+-rw-r--r--  2.0 unx    17298 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequest.py
+-rw-r--r--  2.0 unx      214 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequestActionEnum.py
+-rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py
+-rw-r--r--  2.0 unx     8580 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequestHistory.py
+-rw-r--r--  2.0 unx      149 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequestStatusEnum.py
+-rw-r--r--  2.0 unx      138 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py
+-rw-r--r--  2.0 unx     2994 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionResponse.py
+-rw-r--r--  2.0 unx      169 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/SubscriptionStatusEnum.py
+-rw-r--r--  2.0 unx     2397 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Tab.py
+-rw-r--r--  2.0 unx     2267 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/Tou.py
+-rw-r--r--  2.0 unx     3797 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/UpdateAccountStatusGtsRequest.py
+-rw-r--r--  2.0 unx     2745 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/UpdateAccountStatusGtsResponse.py
+-rw-r--r--  2.0 unx     1837 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/UpdateProductRequest.py
+-rw-r--r--  2.0 unx     2416 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/UserSubscriptions.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 organization/data/subscription_management_service/__init__.py
 -rw-r--r--  2.0 unx      672 b- defN 80-Jan-01 00:00 organization/environ.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 organization/printer/__init__.py
 -rw-r--r--  2.0 unx     5250 b- defN 80-Jan-01 00:00 organization/printer/alert.py
 -rw-r--r--  2.0 unx     1808 b- defN 80-Jan-01 00:00 organization/printer/audit.py
--rw-r--r--  2.0 unx    18008 b- defN 80-Jan-01 00:00 organization/printer/org_team_user.py
+-rw-r--r--  2.0 unx    18014 b- defN 80-Jan-01 00:00 organization/printer/org_team_user.py
 -rw-r--r--  2.0 unx     2576 b- defN 80-Jan-01 00:00 organization/printer/secret.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 registry/__init__.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 registry/api/__init__.py
--rw-r--r--  2.0 unx    38303 b- defN 80-Jan-01 00:00 registry/api/chart.py
+-rw-r--r--  2.0 unx    38341 b- defN 80-Jan-01 00:00 registry/api/chart.py
 -rw-r--r--  2.0 unx     9315 b- defN 80-Jan-01 00:00 registry/api/collection.py
 -rw-r--r--  2.0 unx     7863 b- defN 80-Jan-01 00:00 registry/api/csp.py
 -rw-r--r--  2.0 unx     5460 b- defN 80-Jan-01 00:00 registry/api/deploy.py
 -rw-r--r--  2.0 unx     7091 b- defN 80-Jan-01 00:00 registry/api/dockerwrappers.py
--rw-r--r--  2.0 unx    41396 b- defN 80-Jan-01 00:00 registry/api/image.py
+-rw-r--r--  2.0 unx    51245 b- defN 80-Jan-01 00:00 registry/api/image.py
 -rw-r--r--  2.0 unx     4619 b- defN 80-Jan-01 00:00 registry/api/label_set.py
 -rw-r--r--  2.0 unx    40508 b- defN 80-Jan-01 00:00 registry/api/models.py
 -rw-r--r--  2.0 unx     4048 b- defN 80-Jan-01 00:00 registry/api/playground.py
--rw-r--r--  2.0 unx     6588 b- defN 80-Jan-01 00:00 registry/api/publish.py
+-rw-r--r--  2.0 unx     8314 b- defN 80-Jan-01 00:00 registry/api/publish.py
 -rw-r--r--  2.0 unx     4693 b- defN 80-Jan-01 00:00 registry/api/registry.py
 -rw-r--r--  2.0 unx    46836 b- defN 80-Jan-01 00:00 registry/api/resources.py
 -rw-r--r--  2.0 unx     5503 b- defN 80-Jan-01 00:00 registry/api/search.py
--rw-r--r--  2.0 unx    21639 b- defN 80-Jan-01 00:00 registry/api/utils.py
+-rw-r--r--  2.0 unx    21828 b- defN 80-Jan-01 00:00 registry/api/utils.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 registry/command/__init__.py
 -rw-r--r--  2.0 unx     1087 b- defN 80-Jan-01 00:00 registry/command/all_commands.py
--rw-r--r--  2.0 unx    24429 b- defN 80-Jan-01 00:00 registry/command/chart.py
+-rw-r--r--  2.0 unx    24374 b- defN 80-Jan-01 00:00 registry/command/chart.py
 -rw-r--r--  2.0 unx    24586 b- defN 80-Jan-01 00:00 registry/command/collection.py
 -rw-r--r--  2.0 unx    18448 b- defN 80-Jan-01 00:00 registry/command/csp.py
--rw-r--r--  2.0 unx    25517 b- defN 80-Jan-01 00:00 registry/command/image.py
+-rw-r--r--  2.0 unx    24220 b- defN 80-Jan-01 00:00 registry/command/image.py
 -rw-r--r--  2.0 unx     9578 b- defN 80-Jan-01 00:00 registry/command/image_deploy.py
 -rw-r--r--  2.0 unx    12015 b- defN 80-Jan-01 00:00 registry/command/label_set.py
 -rw-r--r--  2.0 unx    36120 b- defN 80-Jan-01 00:00 registry/command/model.py
 -rw-r--r--  2.0 unx    11360 b- defN 80-Jan-01 00:00 registry/command/model_deploy.py
 -rw-r--r--  2.0 unx     1834 b- defN 80-Jan-01 00:00 registry/command/model_playground.py
--rw-r--r--  2.0 unx     5545 b- defN 80-Jan-01 00:00 registry/command/publish.py
+-rw-r--r--  2.0 unx     5255 b- defN 80-Jan-01 00:00 registry/command/publish.py
 -rw-r--r--  2.0 unx      789 b- defN 80-Jan-01 00:00 registry/command/registry.py
 -rw-r--r--  2.0 unx    34026 b- defN 80-Jan-01 00:00 registry/command/resource.py
 -rw-r--r--  2.0 unx    11713 b- defN 80-Jan-01 00:00 registry/command/resource_deploy.py
 -rw-r--r--  2.0 unx     1485 b- defN 80-Jan-01 00:00 registry/constants.py
+-rw-r--r--  2.0 unx      114 b- defN 80-Jan-01 00:00 registry/data/publishing/AccessTypeEnum.py
+-rw-r--r--  2.0 unx     5242 b- defN 80-Jan-01 00:00 registry/data/publishing/Artifact.py
+-rw-r--r--  2.0 unx     6230 b- defN 80-Jan-01 00:00 registry/data/publishing/ArtifactBatch.py
+-rw-r--r--  2.0 unx     4473 b- defN 80-Jan-01 00:00 registry/data/publishing/ArtifactToCollectionRequest.py
+-rw-r--r--  2.0 unx      141 b- defN 80-Jan-01 00:00 registry/data/publishing/ArtifactType.py
+-rw-r--r--  2.0 unx    10846 b- defN 80-Jan-01 00:00 registry/data/publishing/BatchPublishingRequest.py
+-rw-r--r--  2.0 unx      390 b- defN 80-Jan-01 00:00 registry/data/publishing/ProductNamesEnum.py
+-rw-r--r--  2.0 unx    10067 b- defN 80-Jan-01 00:00 registry/data/publishing/PublishingRequest.py
+-rw-r--r--  2.0 unx     4213 b- defN 80-Jan-01 00:00 registry/data/publishing/RequestStatus.py
+-rw-r--r--  2.0 unx     1976 b- defN 80-Jan-01 00:00 registry/data/publishing/Response.py
+-rw-r--r--  2.0 unx      415 b- defN 80-Jan-01 00:00 registry/data/publishing/StatusCode.py
+-rw-r--r--  2.0 unx       46 b- defN 80-Jan-01 00:00 registry/data/publishing/__init__.py
 -rw-r--r--  2.0 unx      681 b- defN 80-Jan-01 00:00 registry/environ.py
 -rw-r--r--  2.0 unx     1135 b- defN 80-Jan-01 00:00 registry/errors.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 registry/printer/__init__.py
 -rw-r--r--  2.0 unx     3112 b- defN 80-Jan-01 00:00 registry/printer/artifact_deploy.py
 -rw-r--r--  2.0 unx     9767 b- defN 80-Jan-01 00:00 registry/printer/chart.py
 -rw-r--r--  2.0 unx     9148 b- defN 80-Jan-01 00:00 registry/printer/collection.py
 -rw-r--r--  2.0 unx     5752 b- defN 80-Jan-01 00:00 registry/printer/csp.py
@@ -1470,12 +1032,12 @@
 -rw-r--r--  2.0 unx    15141 b- defN 80-Jan-01 00:00 registry/printer/resource.py
 -rw-r--r--  2.0 unx      476 b- defN 80-Jan-01 00:00 registry/transformer/__init__.py
 -rw-r--r--  2.0 unx     1024 b- defN 80-Jan-01 00:00 registry/transformer/chart.py
 -rw-r--r--  2.0 unx      932 b- defN 80-Jan-01 00:00 registry/transformer/collection.py
 -rw-r--r--  2.0 unx      907 b- defN 80-Jan-01 00:00 registry/transformer/image.py
 -rw-r--r--  2.0 unx      907 b- defN 80-Jan-01 00:00 registry/transformer/model.py
 -rw-r--r--  2.0 unx      951 b- defN 80-Jan-01 00:00 registry/transformer/model_script.py
--rw-r--r--  2.0 unx     1959 b- defN 80-Jan-01 00:00 ngcsdk-3.41.4.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 ngcsdk-3.41.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 ngcsdk-3.41.4.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx   138494 b- defN 16-Jan-01 00:00 ngcsdk-3.41.4.dist-info/RECORD
-1479 files, 8868727 bytes uncompressed, 1877775 bytes compressed:  78.8%
+-rw-r--r--  2.0 unx     5722 b- defN 80-Jan-01 00:00 ngcsdk-3.42.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 ngcsdk-3.42.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 ngcsdk-3.42.0.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx    98530 b- defN 16-Jan-01 00:00 ngcsdk-3.42.0.dist-info/RECORD
+1041 files, 6616586 bytes uncompressed, 1421368 bytes compressed:  78.5%
```

## zipnote {}

```diff
@@ -111,14 +111,161 @@
 
 Filename: basecommand/command/workspace.py
 Comment: 
 
 Filename: basecommand/constants.py
 Comment: 
 
+Filename: basecommand/data/pym/AdditionalOpenPortURLs.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterComponent.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterComponentModifyParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterComponentParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterCreateRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterInfo.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterInfoResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterInstance.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterInstanceInfo.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterInstanceTypesResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterListResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterModifyParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterModifyRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterPortMapping.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterRequestStatus.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterStatusEnum.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterSuccessResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterTelemetry.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterTypeEnum.py
+Comment: 
+
+Filename: basecommand/data/pym/ClusterURLs.py
+Comment: 
+
+Filename: basecommand/data/pym/DataInput.py
+Comment: 
+
+Filename: basecommand/data/pym/Dataset.py
+Comment: 
+
+Filename: basecommand/data/pym/Env.py
+Comment: 
+
+Filename: basecommand/data/pym/HealthInfoItem.py
+Comment: 
+
+Filename: basecommand/data/pym/HealthResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectCreateRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectDetails.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectInfoResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectListResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectModifyParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectModifyRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectRequestStatus.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectSuccessResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateCreateRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateInfoResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateListParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateListResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateModificationRequest.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateModifyParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateParams.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateParamsDeprecated.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateRequestStatus.py
+Comment: 
+
+Filename: basecommand/data/pym/ProjectTemplateSuccessResponse.py
+Comment: 
+
+Filename: basecommand/data/pym/SecretKeySpec.py
+Comment: 
+
+Filename: basecommand/data/pym/SecretSpec.py
+Comment: 
+
+Filename: basecommand/data/pym/Workspace.py
+Comment: 
+
+Filename: basecommand/data/pym/__init__.py
+Comment: 
+
 Filename: basecommand/environ.py
 Comment: 
 
 Filename: basecommand/errors.py
 Comment: 
 
 Filename: basecommand/model/dataset.py
@@ -1239,3024 +1386,1527 @@
 
 Filename: ngcbpc/data/api/WorkspaceUpdateRequest.py
 Comment: 
 
 Filename: ngcbpc/data/api/__init__.py
 Comment: 
 
-Filename: ngcbpc/data/search/AccessTypeEnum.py
-Comment: 
-
-Filename: ngcbpc/data/search/CountParams.py
-Comment: 
-
-Filename: ngcbpc/data/search/CountParamsField.py
-Comment: 
-
-Filename: ngcbpc/data/search/CountResponse.py
-Comment: 
-
-Filename: ngcbpc/data/search/CountResponseCount.py
-Comment: 
-
-Filename: ngcbpc/data/search/CountResponseParams.py
-Comment: 
-
-Filename: ngcbpc/data/search/Health.py
-Comment: 
-
-Filename: ngcbpc/data/search/HealthResponse.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelGroup.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelGroupValue.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelResponseGlobal.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelResponseOrgTeam.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelSet.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelSetCreateRequest.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelSetResponse.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelSetUpdateRequest.py
-Comment: 
-
-Filename: ngcbpc/data/search/LabelValue.py
-Comment: 
-
-Filename: ngcbpc/data/search/ListLabelSetsResponse.py
-Comment: 
-
-Filename: ngcbpc/data/search/MetaData.py
-Comment: 
-
-Filename: ngcbpc/data/search/Resource.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourceAttribute.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourceEventEnum.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourceLabel.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourcePopularityTypeEnum.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourcePopularityUpdate.py
-Comment: 
-
-Filename: ngcbpc/data/search/ResourceTypeEnum.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchFilterCategory.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchFilterValue.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchParamFilter.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchParamOrderBy.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchParamOrderByEnum.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchParams.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchPopularityUpdateQueueMsg.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchQueueMsg.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchResponse.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchResponseResult.py
-Comment: 
-
-Filename: ngcbpc/data/search/SearchResponseResultResource.py
-Comment: 
-
-Filename: ngcbpc/data/search/__init__.py
-Comment: 
-
-Filename: ngcbpc/environ.py
-Comment: 
-
-Filename: ngcbpc/errors.py
-Comment: 
-
-Filename: ngcbpc/expiring_cache.py
-Comment: 
-
-Filename: ngcbpc/logger.py
-Comment: 
-
-Filename: ngcbpc/printer/__init__.py
-Comment: 
-
-Filename: ngcbpc/printer/config.py
-Comment: 
-
-Filename: ngcbpc/printer/formatter.py
-Comment: 
-
-Filename: ngcbpc/printer/nvPrettyPrint.py
-Comment: 
-
-Filename: ngcbpc/printer/prettytableWrap.py
-Comment: 
-
-Filename: ngcbpc/printer/transfer.py
-Comment: 
-
-Filename: ngcbpc/printer/utils.py
-Comment: 
-
-Filename: ngcbpc/singleton.py
-Comment: 
-
-Filename: ngcbpc/timer.py
-Comment: 
-
-Filename: ngcbpc/tracing.py
-Comment: 
-
-Filename: ngcbpc/transfer/__init__.py
-Comment: 
-
-Filename: ngcbpc/transfer/adapter.py
-Comment: 
-
-Filename: ngcbpc/transfer/async_download.py
-Comment: 
-
-Filename: ngcbpc/transfer/controller.py
-Comment: 
-
-Filename: ngcbpc/transfer/download.py
-Comment: 
-
-Filename: ngcbpc/transfer/file_cache.py
-Comment: 
-
-Filename: ngcbpc/transfer/grpc/__init__.py
-Comment: 
-
-Filename: ngcbpc/transfer/grpc/proto_py/__init__.py
-Comment: 
-
-Filename: ngcbpc/transfer/grpc/proto_py/upload_pb2.py
-Comment: 
-
-Filename: ngcbpc/transfer/grpc/proto_py/upload_pb2_grpc.py
-Comment: 
-
-Filename: ngcbpc/transfer/http_uploader.py
-Comment: 
-
-Filename: ngcbpc/transfer/manager.py
-Comment: 
-
-Filename: ngcbpc/transfer/task.py
-Comment: 
-
-Filename: ngcbpc/transfer/upload.py
-Comment: 
-
-Filename: ngcbpc/transfer/utils.py
-Comment: 
-
-Filename: ngcbpc/transformer/__init__.py
-Comment: 
-
-Filename: ngcbpc/util/__init__.py
-Comment: 
-
-Filename: ngcbpc/util/base_utils.py
-Comment: 
-
-Filename: ngcbpc/util/datetime_utils.py
-Comment: 
-
-Filename: ngcbpc/util/db_util.py
-Comment: 
-
-Filename: ngcbpc/util/file_utils.py
-Comment: 
-
-Filename: ngcbpc/util/io_utils.py
-Comment: 
-
-Filename: ngcbpc/util/ssh_utils.py
-Comment: 
-
-Filename: ngcbpc/util/utils.py
-Comment: 
-
-Filename: ngccli/data/api/Ace.py
-Comment: 
-
-Filename: ngccli/data/api/AceCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/AceHealth.py
-Comment: 
-
-Filename: ngccli/data/api/AceInstance.py
-Comment: 
-
-Filename: ngccli/data/api/AceInstancePrices.py
-Comment: 
-
-Filename: ngccli/data/api/AceInstancePricesResponse.py
-Comment: 
-
-Filename: ngccli/data/api/AceInstanceTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/AceListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/AceNodeRemapRequest.py
-Comment: 
-
-Filename: ngccli/data/api/AceProvider.py
-Comment: 
-
-Filename: ngccli/data/api/AceResponse.py
-Comment: 
-
-Filename: ngccli/data/api/AceSimplified.py
-Comment: 
-
-Filename: ngccli/data/api/AceStorageInfo.py
-Comment: 
-
-Filename: ngccli/data/api/AceType.py
-Comment: 
-
-Filename: ngccli/data/api/AceUpdate.py
-Comment: 
-
-Filename: ngccli/data/api/AlertAggregationType.py
-Comment: 
-
-Filename: ngccli/data/api/AlertDeliveryMode.py
-Comment: 
-
-Filename: ngccli/data/api/AlternateContact.py
-Comment: 
-
-Filename: ngccli/data/api/Analysis.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogs.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogsEventRequest.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogsEventResponse.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogsPresignedUrlResponse.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogsRequest.py
-Comment: 
-
-Filename: ngccli/data/api/AuditLogsResponse.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEvent.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventIncident.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventIncidentMeta.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventIncidentSeverityEnum.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventIncidentStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventResponse.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/BannerEventUpdateResponse.py
-Comment: 
-
-Filename: ngccli/data/api/BatchResourceTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/CelestialErrorDetail.py
-Comment: 
-
-Filename: ngccli/data/api/CelestialFilters.py
-Comment: 
-
-Filename: ngccli/data/api/ConfigRequest.py
-Comment: 
-
-Filename: ngccli/data/api/ContainerResources.py
-Comment: 
-
-Filename: ngccli/data/api/CreditsHistory.py
-Comment: 
-
-Filename: ngccli/data/api/CreditsHistoryResponse.py
-Comment: 
-
-Filename: ngccli/data/api/CurrencyCode.py
-Comment: 
-
-Filename: ngccli/data/api/Dataset.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetAddFilesRequest.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetFile.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetFileBatch.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetFileEventRequest.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetFilePath.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetResponse.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetSimplified.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/api/DatasetUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/DeviceLoginRequest.py
-Comment: 
-
-Filename: ngccli/data/api/DeviceLoginResponse.py
-Comment: 
-
-Filename: ngccli/data/api/DownloadTokenMetadata.py
-Comment: 
-
-Filename: ngccli/data/api/EarlyAccessOrgCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/Entitlement.py
-Comment: 
-
-Filename: ngccli/data/api/EntitlementProduct.py
-Comment: 
-
-Filename: ngccli/data/api/Env.py
-Comment: 
-
-Filename: ngccli/data/api/ErrorResponse.py
-Comment: 
-
-Filename: ngccli/data/api/Eula.py
-Comment: 
-
-Filename: ngccli/data/api/EulaSubmitResponse.py
-Comment: 
-
-Filename: ngccli/data/api/ExpTrackingParams.py
-Comment: 
-
-Filename: ngccli/data/api/FcOnboardingEventRequest.py
-Comment: 
-
-Filename: ngccli/data/api/GetRepositoryTagVexResponse.py
-Comment: 
-
-Filename: ngccli/data/api/Health.py
-Comment: 
-
-Filename: ngccli/data/api/HealthResponse.py
-Comment: 
-
-Filename: ngccli/data/api/HttpGet.py
-Comment: 
-
-Filename: ngccli/data/api/IPAddress.py
-Comment: 
-
-Filename: ngccli/data/api/InfinityManagerSettings.py
-Comment: 
-
-Filename: ngccli/data/api/Job.py
-Comment: 
-
-Filename: ngccli/data/api/JobArrayTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/JobContainerProperties.py
-Comment: 
-
-Filename: ngccli/data/api/JobContainerResources.py
-Comment: 
-
-Filename: ngccli/data/api/JobCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobDataLocation.py
-Comment: 
-
-Filename: ngccli/data/api/JobDatasetMountInfo.py
-Comment: 
-
-Filename: ngccli/data/api/JobDefinition.py
-Comment: 
-
-Filename: ngccli/data/api/JobFlowTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/JobHealthCheck.py
-Comment: 
-
-Filename: ngccli/data/api/JobInitContainer.py
-Comment: 
-
-Filename: ngccli/data/api/JobLabelDeleteRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobLabelResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobLabelUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobLabels.py
-Comment: 
-
-Filename: ngccli/data/api/JobListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobNodeCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobNodeDeleteRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobNodePreemptRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobNodeResumeRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobPortMapping.py
-Comment: 
-
-Filename: ngccli/data/api/JobPriorityEnum.py
-Comment: 
-
-Filename: ngccli/data/api/JobResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobResultsetMountInfo.py
-Comment: 
-
-Filename: ngccli/data/api/JobRunPolicy.py
-Comment: 
-
-Filename: ngccli/data/api/JobSidecarContainer.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatus.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusChangedEvent.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusCount.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusCountResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusSyncRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobStatusUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobSubmitResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobTemplate.py
-Comment: 
-
-Filename: ngccli/data/api/JobTemplateCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobTemplateResponse.py
-Comment: 
-
-Filename: ngccli/data/api/JobTemplateUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/JobTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/JobVolume.py
-Comment: 
-
-Filename: ngccli/data/api/JobVolumeMount.py
-Comment: 
-
-Filename: ngccli/data/api/JobWorkspaceMountInfo.py
-Comment: 
-
-Filename: ngccli/data/api/Measurement.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAggregationType.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAlert.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAlertCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAlertCriteria.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAlertListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementAlertResponse.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementQueryParams.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementQueryRequest.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementResult.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementResultListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementSeries.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementTag.py
-Comment: 
-
-Filename: ngccli/data/api/MeasurementType.py
-Comment: 
-
-Filename: ngccli/data/api/MetaData.py
-Comment: 
-
-Filename: ngccli/data/api/MeteringQueryParams.py
-Comment: 
-
-Filename: ngccli/data/api/MeteringQueryRequest.py
-Comment: 
-
-Filename: ngccli/data/api/MeteringResourceUtilizationEvent.py
-Comment: 
-
-Filename: ngccli/data/api/MeteringResultListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/MeteringType.py
-Comment: 
-
-Filename: ngccli/data/api/MoveNodeRequest.py
-Comment: 
-
-Filename: ngccli/data/api/NetworkProtocolEnum.py
-Comment: 
-
-Filename: ngccli/data/api/NetworkTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/api/Node.py
-Comment: 
-
-Filename: ngccli/data/api/NodeCommand.py
-Comment: 
-
-Filename: ngccli/data/api/NodeCommandRequest.py
-Comment: 
-
-Filename: ngccli/data/api/NodeCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/api/NodeListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/NodeResponse.py
-Comment: 
-
-Filename: ngccli/data/api/NodeSimplified.py
-Comment: 
-
-Filename: ngccli/data/api/NodeStatus.py
-Comment: 
-
-Filename: ngccli/data/api/NodeStatusChangedEvent.py
-Comment: 
-
-Filename: ngccli/data/api/NodeStatusUpdate.py
-Comment: 
-
-Filename: ngccli/data/api/NodeType.py
-Comment: 
-
-Filename: ngccli/data/api/OrgAdminUserCreatedEvent.py
-Comment: 
-
-Filename: ngccli/data/api/OrgCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/OrgCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/api/OrgCreatedEvent.py
-Comment: 
-
-Filename: ngccli/data/api/OrgEnablementCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/OrgListEntitlementResponse.py
-Comment: 
-
-Filename: ngccli/data/api/OrgListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/OrgOwner.py
-Comment: 
-
-Filename: ngccli/data/api/OrgProfileUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/OrgResponse.py
-Comment: 
-
-Filename: ngccli/data/api/OrgType.py
-Comment: 
-
-Filename: ngccli/data/api/OrgUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/Organization.py
-Comment: 
-
-Filename: ngccli/data/api/OrganizationEntitlement.py
-Comment: 
-
-Filename: ngccli/data/api/PackageVersion.py
-Comment: 
-
-Filename: ngccli/data/api/PackageVersionListResponse.py
-Comment: 
-
-Filename: ngccli/data/api/PaginationInfo.py
-Comment: 
-
-Filename: ngccli/data/api/PasswordChangeRequest.py
-Comment: 
-
-Filename: ngccli/data/api/PhysicalNodeCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/api/PoolMeasurementQueryParams.py
-Comment: 
-
-Filename: ngccli/data/api/PoolMeasurementQueryRequest.py
-Comment: 
-
-Filename: ngccli/data/api/PoolMeasurementType.py
-Comment: 
-
-Filename: ngccli/data/api/PostStorageProvision.py
-Comment: 
-
-Filename: ngccli/data/api/Price.py
-Comment: 
-
-Filename: ngccli/data/api/PriceType.py
-Comment: 
-
-Filename: ngccli/data/api/ProductEnablement.py
-Comment: 
-
-Filename: ngccli/data/api/ProductEnablementTypeEnum.py
+Filename: ngcbpc/data/model/AIFoundationModel.py
 Comment: 
 
-Filename: ngccli/data/api/ProductNameEnum.py
+Filename: ngcbpc/data/model/AIPlaygroundCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/ProductSubscription.py
+Filename: ngcbpc/data/model/AIPlaygroundResponse.py
 Comment: 
 
-Filename: ngccli/data/api/PurchaseOrder.py
+Filename: ngcbpc/data/model/AIPlaygroundUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/Replica.py
+Filename: ngcbpc/data/model/AccessTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/api/ReplicaListResponse.py
+Filename: ngcbpc/data/model/ApplicationType.py
 Comment: 
 
-Filename: ngccli/data/api/ReplicaResponse.py
+Filename: ngcbpc/data/model/Artifact.py
 Comment: 
 
-Filename: ngccli/data/api/RepoScanSettings.py
+Filename: ngcbpc/data/model/ArtifactAttribute.py
 Comment: 
 
-Filename: ngccli/data/api/RepositoryTagVexByDigest.py
+Filename: ngcbpc/data/model/ArtifactCatalogFlags.py
 Comment: 
 
-Filename: ngccli/data/api/RepositoryTagVexDetail.py
+Filename: ngcbpc/data/model/ArtifactCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/RequestStatus.py
+Filename: ngcbpc/data/model/ArtifactDeploymentParameters.py
 Comment: 
 
-Filename: ngccli/data/api/ReservedLabels.py
+Filename: ngcbpc/data/model/ArtifactDownloadAllRequest.py
 Comment: 
 
-Filename: ngccli/data/api/Response.py
+Filename: ngcbpc/data/model/ArtifactDownloadAllResponse.py
 Comment: 
 
-Filename: ngccli/data/api/Resultset.py
+Filename: ngcbpc/data/model/ArtifactDownloadRequest.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetFile.py
+Filename: ngcbpc/data/model/ArtifactDownloadResponse.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetFileBatch.py
+Filename: ngcbpc/data/model/ArtifactEvent.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetFileEventRequest.py
+Filename: ngcbpc/data/model/ArtifactListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetListResponse.py
+Filename: ngcbpc/data/model/ArtifactPublishRequest.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetResponse.py
+Filename: ngcbpc/data/model/ArtifactResponse.py
 Comment: 
 
-Filename: ngccli/data/api/ResultsetToDatasetConversionEvent.py
+Filename: ngcbpc/data/model/ArtifactTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/api/RoleChangeRequest.py
+Filename: ngcbpc/data/model/ArtifactUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/RoleProduct.py
+Filename: ngcbpc/data/model/ArtifactVersion.py
 Comment: 
 
-Filename: ngccli/data/api/RoleType.py
+Filename: ngcbpc/data/model/ArtifactVersionCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/SCPJobDetails.py
+Filename: ngcbpc/data/model/ArtifactVersionFileListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/Saml.py
+Filename: ngcbpc/data/model/ArtifactVersionListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/SamlResponse.py
+Filename: ngcbpc/data/model/ArtifactVersionResponse.py
 Comment: 
 
-Filename: ngccli/data/api/Secret.py
+Filename: ngcbpc/data/model/ArtifactVersionUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/SecretKVEnv.py
+Filename: ngcbpc/data/model/Asset.py
 Comment: 
 
-Filename: ngccli/data/api/SecretKeySpec.py
+Filename: ngcbpc/data/model/AssetCdnProviderTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/api/SecretSpec.py
+Filename: ngcbpc/data/model/AssetResponse.py
 Comment: 
 
-Filename: ngccli/data/api/ServiceAccess.py
+Filename: ngcbpc/data/model/AssetSimplified.py
 Comment: 
 
-Filename: ngccli/data/api/StatusCode.py
+Filename: ngcbpc/data/model/AssetStatusTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/api/StorageAccessInfo.py
+Filename: ngcbpc/data/model/AssetStorageEvent.py
 Comment: 
 
-Filename: ngccli/data/api/StorageAuthenticationResponse.py
+Filename: ngcbpc/data/model/AssetStorageTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/api/StorageCephInfo.py
+Filename: ngcbpc/data/model/AssetUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageClusterCreateRequest.py
+Filename: ngcbpc/data/model/CatalogArtifactMetadata.py
 Comment: 
 
-Filename: ngccli/data/api/StorageClusterListResponse.py
+Filename: ngcbpc/data/model/CloneArtifactVersionFilesRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageClusterResponse.py
+Filename: ngcbpc/data/model/CloneableArtifact.py
 Comment: 
 
-Filename: ngccli/data/api/StorageClusterUpdateRequest.py
+Filename: ngcbpc/data/model/CloudServiceProvider.py
 Comment: 
 
-Filename: ngccli/data/api/StorageEngineTypeEnum.py
+Filename: ngcbpc/data/model/CloudServiceProviderCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageLocation.py
+Filename: ngcbpc/data/model/CloudServiceProviderListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/StorageLocationStorageTypeEnum.py
+Filename: ngcbpc/data/model/CloudServiceProviderUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageLustreInfo.py
+Filename: ngcbpc/data/model/Collection.py
 Comment: 
 
-Filename: ngccli/data/api/StorageNfsv3Info.py
+Filename: ngcbpc/data/model/CollectionCategoryType.py
 Comment: 
 
-Filename: ngccli/data/api/StorageProxyfsInfo.py
+Filename: ngcbpc/data/model/CollectionCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageResource.py
+Filename: ngcbpc/data/model/CollectionListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/StorageResourceStatusEnum.py
+Filename: ngcbpc/data/model/CollectionOperation.py
 Comment: 
 
-Filename: ngccli/data/api/StorageServiceConfig.py
+Filename: ngcbpc/data/model/CollectionOperationType.py
 Comment: 
 
-Filename: ngccli/data/api/StorageServiceConfigDetails.py
+Filename: ngcbpc/data/model/CollectionPatchRequest.py
 Comment: 
 
-Filename: ngccli/data/api/StorageYarofsInfo.py
+Filename: ngcbpc/data/model/CollectionPublishRequest.py
 Comment: 
 
-Filename: ngccli/data/api/SuggestedNamesResponse.py
+Filename: ngcbpc/data/model/CollectionResponse.py
 Comment: 
 
-Filename: ngccli/data/api/SystemLabels.py
+Filename: ngcbpc/data/model/CollectionSimplified.py
 Comment: 
 
-Filename: ngccli/data/api/TargetSystemUserIdentifier.py
+Filename: ngcbpc/data/model/CollectionUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/Team.py
+Filename: ngcbpc/data/model/CountableResource.py
 Comment: 
 
-Filename: ngccli/data/api/TeamCreateRequest.py
+Filename: ngcbpc/data/model/CustomMetric.py
 Comment: 
 
-Filename: ngccli/data/api/TeamCreateResponse.py
+Filename: ngcbpc/data/model/CustomMetricGroup.py
 Comment: 
 
-Filename: ngccli/data/api/TeamCreatedEvent.py
+Filename: ngcbpc/data/model/Dataset.py
 Comment: 
 
-Filename: ngccli/data/api/TeamListResponse.py
+Filename: ngcbpc/data/model/DeploymentArtifactParameters.py
 Comment: 
 
-Filename: ngccli/data/api/TeamResponse.py
+Filename: ngcbpc/data/model/DeploymentCpuParameters.py
 Comment: 
 
-Filename: ngccli/data/api/TeamUpdateRequest.py
+Filename: ngcbpc/data/model/DeploymentCpuParametersMeta.py
 Comment: 
 
-Filename: ngccli/data/api/TelemetryClientCreateResponse.py
+Filename: ngcbpc/data/model/DeploymentGpuParameters.py
 Comment: 
 
-Filename: ngccli/data/api/TokenResponse.py
+Filename: ngcbpc/data/model/DeploymentGpuParametersMeta.py
 Comment: 
 
-Filename: ngccli/data/api/UpdateAceRequest.py
+Filename: ngcbpc/data/model/DeploymentMemoryParameters.py
 Comment: 
 
-Filename: ngccli/data/api/UpdateNodeRequest.py
+Filename: ngcbpc/data/model/DeploymentMemoryParametersMeta.py
 Comment: 
 
-Filename: ngccli/data/api/User.py
+Filename: ngcbpc/data/model/DeploymentParameters.py
 Comment: 
 
-Filename: ngccli/data/api/UserCreateRequest.py
+Filename: ngcbpc/data/model/DeploymentParametersCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserCreatedEvent.py
+Filename: ngcbpc/data/model/DeploymentParametersListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/UserInvitation.py
+Filename: ngcbpc/data/model/DeploymentParametersMeta.py
 Comment: 
 
-Filename: ngccli/data/api/UserInvitationListResponse.py
+Filename: ngcbpc/data/model/DeploymentParametersMetaCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserInvitationResponse.py
+Filename: ngcbpc/data/model/DeploymentParametersMetaListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/UserKeyResponse.py
+Filename: ngcbpc/data/model/DeploymentParametersMetaUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserLabels.py
+Filename: ngcbpc/data/model/DeploymentParametersUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserListResponse.py
+Filename: ngcbpc/data/model/DeploymentStorageParameters.py
 Comment: 
 
-Filename: ngccli/data/api/UserMetadata.py
+Filename: ngcbpc/data/model/DeploymentStorageParametersMeta.py
 Comment: 
 
-Filename: ngccli/data/api/UserOrgRegisterRequest.py
+Filename: ngcbpc/data/model/DeploymentUrlCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserRegisterRequest.py
+Filename: ngcbpc/data/model/DeploymentUrlResponse.py
 Comment: 
 
-Filename: ngccli/data/api/UserResponse.py
+Filename: ngcbpc/data/model/EnumerableResource.py
 Comment: 
 
-Filename: ngccli/data/api/UserRole.py
+Filename: ngcbpc/data/model/EnumerableResourceItem.py
 Comment: 
 
-Filename: ngccli/data/api/UserRoleDefinition.py
+Filename: ngcbpc/data/model/File.py
 Comment: 
 
-Filename: ngccli/data/api/UserRoleDefinitionsResponse.py
+Filename: ngcbpc/data/model/FrameworkType.py
 Comment: 
 
-Filename: ngccli/data/api/UserSession.py
+Filename: ngcbpc/data/model/Health.py
 Comment: 
 
-Filename: ngccli/data/api/UserSessionResponse.py
+Filename: ngcbpc/data/model/HealthResponse.py
 Comment: 
 
-Filename: ngccli/data/api/UserStorageClusterUpdateRequest.py
+Filename: ngcbpc/data/model/HelmChartDependency.py
 Comment: 
 
-Filename: ngccli/data/api/UserStorageQuota.py
+Filename: ngcbpc/data/model/HelmChartMaintainer.py
 Comment: 
 
-Filename: ngccli/data/api/UserStorageQuotaListResponse.py
+Filename: ngcbpc/data/model/HelmChartVersion.py
 Comment: 
 
-Filename: ngccli/data/api/UserStorageQuotaResponse.py
+Filename: ngcbpc/data/model/MetaData.py
 Comment: 
 
-Filename: ngccli/data/api/UserStorageQuotaUpdateRequest.py
+Filename: ngcbpc/data/model/Model.py
 Comment: 
 
-Filename: ngccli/data/api/UserTopicEvent.py
+Filename: ngcbpc/data/model/ModelCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/UserUpdateRequest.py
+Filename: ngcbpc/data/model/ModelCreateResponse.py
 Comment: 
 
-Filename: ngccli/data/api/UsersInfo.py
+Filename: ngcbpc/data/model/ModelFile.py
 Comment: 
 
-Filename: ngccli/data/api/ValidateOrgQueryParams.py
+Filename: ngcbpc/data/model/ModelFormatType.py
 Comment: 
 
-Filename: ngccli/data/api/VirtualNodeCreateRequest.py
+Filename: ngcbpc/data/model/ModelListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WebSocket.py
+Filename: ngcbpc/data/model/ModelResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WebSocketReceipt.py
+Filename: ngcbpc/data/model/ModelSimplified.py
 Comment: 
 
-Filename: ngccli/data/api/Webhook.py
+Filename: ngcbpc/data/model/ModelUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/WebhookCreateRequest.py
+Filename: ngcbpc/data/model/ModelVersion.py
 Comment: 
 
-Filename: ngccli/data/api/WebhookEventType.py
+Filename: ngcbpc/data/model/ModelVersionCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/WebhookListResponse.py
+Filename: ngcbpc/data/model/ModelVersionCreateResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WebhookResponse.py
+Filename: ngcbpc/data/model/ModelVersionFileListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WorkspaceCreateRequest.py
+Filename: ngcbpc/data/model/ModelVersionListResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WorkspaceListResponse.py
+Filename: ngcbpc/data/model/ModelVersionResponse.py
 Comment: 
 
-Filename: ngccli/data/api/WorkspaceResponse.py
+Filename: ngcbpc/data/model/ModelVersionUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/api/WorkspaceUpdateRequest.py
+Filename: ngcbpc/data/model/MultipartUploadAbortRequest.py
 Comment: 
 
-Filename: ngccli/data/api/__init__.py
+Filename: ngcbpc/data/model/MultipartUploadCompleteRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/AdvancedStorage.py
+Filename: ngcbpc/data/model/MultipartUploadCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/AdvancedStorageResponse.py
+Filename: ngcbpc/data/model/MultipartUploadCreateResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/Alert.py
+Filename: ngcbpc/data/model/PaginationInfo.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApiKeyCreateRequest.py
+Filename: ngcbpc/data/model/PrecisionType.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApiKeyResponse.py
+Filename: ngcbpc/data/model/ProductNamesEnum.py
 Comment: 
 
-Filename: ngccli/data/ecm/AppConfigCreateRequest.py
+Filename: ngcbpc/data/model/Recipe.py
 Comment: 
 
-Filename: ngccli/data/ecm/AppConfigResponse.py
+Filename: ngcbpc/data/model/RecipeCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/AppConfigUpdateRequest.py
+Filename: ngcbpc/data/model/RecipeFile.py
 Comment: 
 
-Filename: ngccli/data/ecm/AppConfigs.py
+Filename: ngcbpc/data/model/RecipeListResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/AppConfigsResponse.py
+Filename: ngcbpc/data/model/RecipeResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/Application.py
+Filename: ngcbpc/data/model/RecipeUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApplicationRequest.py
+Filename: ngcbpc/data/model/RecipeVersion.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApplicationResponse.py
+Filename: ngcbpc/data/model/RecipeVersionCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApplicationUpdateRequest.py
+Filename: ngcbpc/data/model/RecipeVersionFileListResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/ApplicationsResponse.py
+Filename: ngcbpc/data/model/RecipeVersionListResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/BuildStatus.py
+Filename: ngcbpc/data/model/RecipeVersionResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/BuildStatusEnum.py
+Filename: ngcbpc/data/model/RecipeVersionUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/ComponentResponse.py
+Filename: ngcbpc/data/model/RequestStatus.py
 Comment: 
 
-Filename: ngccli/data/ecm/Console.py
+Filename: ngcbpc/data/model/Response.py
 Comment: 
 
-Filename: ngccli/data/ecm/ConsoleResponse.py
+Filename: ngcbpc/data/model/SortOrderEnum.py
 Comment: 
 
-Filename: ngccli/data/ecm/ConsolesResponse.py
+Filename: ngcbpc/data/model/StatusCode.py
 Comment: 
 
-Filename: ngccli/data/ecm/CreateCustomRootFsRequest.py
+Filename: ngcbpc/data/model/VersionStatusEnum.py
 Comment: 
 
-Filename: ngccli/data/ecm/CreateDeploymentRequest.py
+Filename: ngcbpc/data/model/__init__.py
 Comment: 
 
-Filename: ngccli/data/ecm/CreateLocationRequest.py
+Filename: ngcbpc/data/registry/AccessTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/ecm/CreateNodeRequest.py
+Filename: ngcbpc/data/registry/Actor.py
 Comment: 
 
-Filename: ngccli/data/ecm/CustomInstaller.py
+Filename: ngcbpc/data/registry/Allowlist.py
 Comment: 
 
-Filename: ngccli/data/ecm/CustomRootFsCreationEvent.py
+Filename: ngcbpc/data/registry/AllowlistItem.py
 Comment: 
 
-Filename: ngccli/data/ecm/Deployment.py
+Filename: ngcbpc/data/registry/Analysis.py
 Comment: 
 
-Filename: ngccli/data/ecm/DeploymentLocation.py
+Filename: ngcbpc/data/registry/AnalysisStatus.py
 Comment: 
 
-Filename: ngccli/data/ecm/DeploymentResponse.py
+Filename: ngcbpc/data/registry/AnchoreParameter.py
 Comment: 
 
-Filename: ngccli/data/ecm/DeploymentsResponse.py
+Filename: ngcbpc/data/registry/AnchorePolicyBundle.py
 Comment: 
 
-Filename: ngccli/data/ecm/EmsMetaData.py
+Filename: ngcbpc/data/registry/AnchorePolicyBundleRecord.py
 Comment: 
 
-Filename: ngccli/data/ecm/EmsResponse.py
+Filename: ngcbpc/data/registry/BaseImageDetails.py
 Comment: 
 
-Filename: ngccli/data/ecm/ErrorResponse.py
+Filename: ngcbpc/data/registry/BaseImageList.py
 Comment: 
 
-Filename: ngccli/data/ecm/Git.py
+Filename: ngcbpc/data/registry/BaseImagesDetailResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitApp.py
+Filename: ngcbpc/data/registry/BlobSum.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitRepositoriesResponse.py
+Filename: ngcbpc/data/registry/CatalogArtifactMetadata.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitRepository.py
+Filename: ngcbpc/data/registry/Envelope.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitRepositoryRequest.py
+Filename: ngcbpc/data/registry/EventRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitRepositoryResponse.py
+Filename: ngcbpc/data/registry/EventSource.py
 Comment: 
 
-Filename: ngccli/data/ecm/GitRepositoryUpdateRequest.py
+Filename: ngcbpc/data/registry/EventTarget.py
 Comment: 
 
-Filename: ngccli/data/ecm/GpuInfo.py
+Filename: ngcbpc/data/registry/GetManifestByTagResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/GpuLogStorageUsageResponse.py
+Filename: ngcbpc/data/registry/GetRepositoryTagVexResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/GpuManagement.py
+Filename: ngcbpc/data/registry/GetTagsResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/GpuManagementResponse.py
+Filename: ngcbpc/data/registry/Header.py
 Comment: 
 
-Filename: ngccli/data/ecm/Installer.py
+Filename: ngcbpc/data/registry/HistoryLayer.py
 Comment: 
 
-Filename: ngccli/data/ecm/InstallersResponse.py
+Filename: ngcbpc/data/registry/ImageArchitectureVariant.py
 Comment: 
 
-Filename: ngccli/data/ecm/InstallersValidationRequest.py
+Filename: ngcbpc/data/registry/ImageDeleteRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/Iso.py
+Filename: ngcbpc/data/registry/ImageOwnerDetails.py
 Comment: 
 
-Filename: ngccli/data/ecm/Label.py
+Filename: ngcbpc/data/registry/ImageRef.py
 Comment: 
 
-Filename: ngccli/data/ecm/LabelsResponse.py
+Filename: ngcbpc/data/registry/ImageScanDetails.py
 Comment: 
 
-Filename: ngccli/data/ecm/Location.py
+Filename: ngcbpc/data/registry/ImageSelectionRule.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationAvailabilityEnum.py
+Filename: ngcbpc/data/registry/ImageSignature.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationDeploymentStatusEnum.py
+Filename: ngcbpc/data/registry/Jwk.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationHealthEnum.py
+Filename: ngcbpc/data/registry/ManifestByTagV2Response.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationResponse.py
+Filename: ngcbpc/data/registry/ManifestListByTagV2Response.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationStatusEnum.py
+Filename: ngcbpc/data/registry/ManifestV2Config.py
 Comment: 
 
-Filename: ngccli/data/ecm/LocationsResponse.py
+Filename: ngcbpc/data/registry/ManifestV2Layer.py
 Comment: 
 
-Filename: ngccli/data/ecm/Log.py
+Filename: ngcbpc/data/registry/MappingRule.py
 Comment: 
 
-Filename: ngccli/data/ecm/LogsResponse.py
+Filename: ngcbpc/data/registry/MetaImageDetails.py
 Comment: 
 
-Filename: ngccli/data/ecm/ManagedGpus.py
+Filename: ngcbpc/data/registry/MetaImageDetailsList.py
 Comment: 
 
-Filename: ngccli/data/ecm/MetaData.py
+Filename: ngcbpc/data/registry/OciIndexManifest.py
 Comment: 
 
-Filename: ngccli/data/ecm/MetricQueryResponse.py
+Filename: ngcbpc/data/registry/OciIndexResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/Metrics.py
+Filename: ngcbpc/data/registry/PaginationInfo.py
 Comment: 
 
-Filename: ngccli/data/ecm/MetricsBucketsResponse.py
+Filename: ngcbpc/data/registry/Platform.py
 Comment: 
 
-Filename: ngccli/data/ecm/MetricsListResponse.py
+Filename: ngcbpc/data/registry/PlatformManifest.py
 Comment: 
 
-Filename: ngccli/data/ecm/MigProfileInfo.py
+Filename: ngcbpc/data/registry/PolicyRule.py
 Comment: 
 
-Filename: ngccli/data/ecm/MigStatusEnum.py
+Filename: ngcbpc/data/registry/ProductNamesEnum.py
 Comment: 
 
-Filename: ngccli/data/ecm/NetworkInfo.py
+Filename: ngcbpc/data/registry/RegistryEvent.py
 Comment: 
 
-Filename: ngccli/data/ecm/NetworkInfoResponse.py
+Filename: ngcbpc/data/registry/Repository.py
 Comment: 
 
-Filename: ngccli/data/ecm/NetworkInterface.py
+Filename: ngcbpc/data/registry/RepositoryCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/Node.py
+Filename: ngcbpc/data/registry/RepositoryImageDetails.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodeConnectionEnum.py
+Filename: ngcbpc/data/registry/RepositoryImageDetailsList.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodeGpuInfoResponse.py
+Filename: ngcbpc/data/registry/RepositoryImageScanComplete.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodeHealthEnum.py
+Filename: ngcbpc/data/registry/RepositoryImagesDeletedEvent.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodeResponse.py
+Filename: ngcbpc/data/registry/RepositoryInfoUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodeStatusEnum.py
+Filename: ngcbpc/data/registry/RepositoryLabelsPatchRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/NodesResponse.py
+Filename: ngcbpc/data/registry/RepositoryList.py
 Comment: 
 
-Filename: ngccli/data/ecm/PaginationInfo.py
+Filename: ngcbpc/data/registry/RepositoryTagVexByDigest.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteApp.py
+Filename: ngcbpc/data/registry/RepositoryTagVexDetail.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteAppDetail.py
+Filename: ngcbpc/data/registry/RepositoryTagsCountResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteAppResponse.py
+Filename: ngcbpc/data/registry/RequestStatus.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteAppTunnelResponse.py
+Filename: ngcbpc/data/registry/Response.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteConsoleSshRequest.py
+Filename: ngcbpc/data/registry/RuleSet.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteConsoleSshResponse.py
+Filename: ngcbpc/data/registry/ScanIssue.py
 Comment: 
 
-Filename: ngccli/data/ecm/RemoteManagerStatusTypeEnum.py
+Filename: ngcbpc/data/registry/ScanIssueCount.py
 Comment: 
 
-Filename: ngccli/data/ecm/RequestStatus.py
+Filename: ngcbpc/data/registry/ScanIssueSeverity.py
 Comment: 
 
-Filename: ngccli/data/ecm/Response.py
+Filename: ngcbpc/data/registry/ScanStatus.py
 Comment: 
 
-Filename: ngccli/data/ecm/ScanResultsStatusEnum.py
+Filename: ngcbpc/data/registry/ScanType.py
 Comment: 
 
-Filename: ngccli/data/ecm/SecurityMinimunSupportedVersion.py
+Filename: ngcbpc/data/registry/SecurityRatingDescription.py
 Comment: 
 
-Filename: ngccli/data/ecm/SettingsResponse.py
+Filename: ngcbpc/data/registry/SecurityRatingType.py
 Comment: 
 
-Filename: ngccli/data/ecm/SignedContainerKeysRequest.py
+Filename: ngcbpc/data/registry/SecurityRatingsResponse.py
 Comment: 
 
-Filename: ngccli/data/ecm/SignedContainerKeysResponse.py
+Filename: ngcbpc/data/registry/StatusCode.py
 Comment: 
 
-Filename: ngccli/data/ecm/SortOrderEnum.py
+Filename: ngcbpc/data/registry/TagUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/ecm/StatusCode.py
+Filename: ngcbpc/data/registry/__init__.py
 Comment: 
 
-Filename: ngccli/data/ecm/TypeVersion.py
-Comment: 
-
-Filename: ngccli/data/ecm/TypeVersions.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateDeploymentRequest.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateGpuInfo.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateLocationRequest.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateNodeGpuInfoRequest.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateNodeRequest.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateSettingsRequest.py
-Comment: 
-
-Filename: ngccli/data/ecm/UpdateStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/ecm/ValidationStatus.py
-Comment: 
-
-Filename: ngccli/data/ecm/__init__.py
-Comment: 
-
-Filename: ngccli/data/model/AIFoundationModel.py
-Comment: 
-
-Filename: ngccli/data/model/AIPlaygroundCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/AIPlaygroundResponse.py
-Comment: 
-
-Filename: ngccli/data/model/AIPlaygroundUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/AccessTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/model/ApplicationType.py
-Comment: 
-
-Filename: ngccli/data/model/Artifact.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactAttribute.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactCatalogFlags.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactDeploymentParameters.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactDownloadAllRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactDownloadAllResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactDownloadRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactDownloadResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactEvent.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactPublishRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersion.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersionCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersionFileListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersionListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersionResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ArtifactVersionUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/Asset.py
-Comment: 
-
-Filename: ngccli/data/model/AssetCdnProviderTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/model/AssetResponse.py
-Comment: 
-
-Filename: ngccli/data/model/AssetSimplified.py
-Comment: 
-
-Filename: ngccli/data/model/AssetStatusTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/model/AssetStorageEvent.py
-Comment: 
-
-Filename: ngccli/data/model/AssetStorageTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/model/AssetUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CatalogArtifactMetadata.py
-Comment: 
-
-Filename: ngccli/data/model/CloneArtifactVersionFilesRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CloneableArtifact.py
-Comment: 
-
-Filename: ngccli/data/model/CloudServiceProvider.py
-Comment: 
-
-Filename: ngccli/data/model/CloudServiceProviderCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CloudServiceProviderListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/CloudServiceProviderUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/Collection.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionCategoryType.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionOperation.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionOperationType.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionPatchRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionPublishRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionResponse.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionSimplified.py
-Comment: 
-
-Filename: ngccli/data/model/CollectionUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/CountableResource.py
-Comment: 
-
-Filename: ngccli/data/model/CustomMetric.py
-Comment: 
-
-Filename: ngccli/data/model/CustomMetricGroup.py
-Comment: 
-
-Filename: ngccli/data/model/Dataset.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentArtifactParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentCpuParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentCpuParametersMeta.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentGpuParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentGpuParametersMeta.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentMemoryParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentMemoryParametersMeta.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersMeta.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersMetaCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersMetaListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersMetaUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentParametersUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentStorageParameters.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentStorageParametersMeta.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentUrlCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/DeploymentUrlResponse.py
-Comment: 
-
-Filename: ngccli/data/model/EnumerableResource.py
-Comment: 
-
-Filename: ngccli/data/model/EnumerableResourceItem.py
-Comment: 
-
-Filename: ngccli/data/model/File.py
-Comment: 
-
-Filename: ngccli/data/model/FrameworkType.py
-Comment: 
-
-Filename: ngccli/data/model/Health.py
-Comment: 
-
-Filename: ngccli/data/model/HealthResponse.py
-Comment: 
-
-Filename: ngccli/data/model/HelmChartDependency.py
-Comment: 
-
-Filename: ngccli/data/model/HelmChartMaintainer.py
-Comment: 
-
-Filename: ngccli/data/model/HelmChartVersion.py
-Comment: 
-
-Filename: ngccli/data/model/MetaData.py
-Comment: 
-
-Filename: ngccli/data/model/Model.py
-Comment: 
-
-Filename: ngccli/data/model/ModelCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ModelCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelFile.py
-Comment: 
-
-Filename: ngccli/data/model/ModelFormatType.py
-Comment: 
-
-Filename: ngccli/data/model/ModelListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelSimplified.py
-Comment: 
-
-Filename: ngccli/data/model/ModelUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersion.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionFileListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionResponse.py
-Comment: 
-
-Filename: ngccli/data/model/ModelVersionUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/MultipartUploadAbortRequest.py
-Comment: 
-
-Filename: ngccli/data/model/MultipartUploadCompleteRequest.py
-Comment: 
-
-Filename: ngccli/data/model/MultipartUploadCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/MultipartUploadCreateResponse.py
-Comment: 
-
-Filename: ngccli/data/model/PaginationInfo.py
-Comment: 
-
-Filename: ngccli/data/model/PrecisionType.py
-Comment: 
-
-Filename: ngccli/data/model/ProductNamesEnum.py
-Comment: 
-
-Filename: ngccli/data/model/Recipe.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeFile.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeResponse.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersion.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersionCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersionFileListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersionListResponse.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersionResponse.py
-Comment: 
-
-Filename: ngccli/data/model/RecipeVersionUpdateRequest.py
-Comment: 
-
-Filename: ngccli/data/model/RequestStatus.py
-Comment: 
-
-Filename: ngccli/data/model/Response.py
-Comment: 
-
-Filename: ngccli/data/model/SortOrderEnum.py
-Comment: 
-
-Filename: ngccli/data/model/StatusCode.py
-Comment: 
-
-Filename: ngccli/data/model/VersionStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/model/__init__.py
-Comment: 
-
-Filename: ngccli/data/package/Health.py
-Comment: 
-
-Filename: ngccli/data/package/HealthResponse.py
-Comment: 
-
-Filename: ngccli/data/package/MetaData.py
-Comment: 
-
-Filename: ngccli/data/package/Package.py
-Comment: 
-
-Filename: ngccli/data/package/PackageFile.py
-Comment: 
-
-Filename: ngccli/data/package/PackageVersion.py
-Comment: 
-
-Filename: ngccli/data/package/PackageVersionListResponse.py
-Comment: 
-
-Filename: ngccli/data/package/PackageVersionResponse.py
-Comment: 
-
-Filename: ngccli/data/package/PaginationInfo.py
-Comment: 
-
-Filename: ngccli/data/package/RequestStatus.py
-Comment: 
-
-Filename: ngccli/data/package/Response.py
-Comment: 
-
-Filename: ngccli/data/package/StatusCode.py
-Comment: 
-
-Filename: ngccli/data/package/__init__.py
-Comment: 
-
-Filename: ngccli/data/publishing/AccessTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/publishing/Artifact.py
-Comment: 
-
-Filename: ngccli/data/publishing/ArtifactBatch.py
-Comment: 
-
-Filename: ngccli/data/publishing/ArtifactToCollectionRequest.py
-Comment: 
-
-Filename: ngccli/data/publishing/ArtifactType.py
-Comment: 
-
-Filename: ngccli/data/publishing/BatchPublishingRequest.py
-Comment: 
-
-Filename: ngccli/data/publishing/ProductNamesEnum.py
-Comment: 
-
-Filename: ngccli/data/publishing/PublishingRequest.py
-Comment: 
-
-Filename: ngccli/data/publishing/RequestStatus.py
-Comment: 
-
-Filename: ngccli/data/publishing/Response.py
-Comment: 
-
-Filename: ngccli/data/publishing/StatusCode.py
-Comment: 
-
-Filename: ngccli/data/publishing/__init__.py
-Comment: 
-
-Filename: ngccli/data/pym/AdditionalOpenPortURLs.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterComponent.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterComponentModifyParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterComponentParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterInfo.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterInfoResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterInstance.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterInstanceInfo.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterInstanceTypesResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterListResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterModifyParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterModifyRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterPortMapping.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterRequestStatus.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterStatusEnum.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterSuccessResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterTelemetry.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/pym/ClusterURLs.py
-Comment: 
-
-Filename: ngccli/data/pym/DataInput.py
-Comment: 
-
-Filename: ngccli/data/pym/Dataset.py
-Comment: 
-
-Filename: ngccli/data/pym/Env.py
-Comment: 
-
-Filename: ngccli/data/pym/HealthInfoItem.py
-Comment: 
-
-Filename: ngccli/data/pym/HealthResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectDetails.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectInfoResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectListResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectModifyParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectModifyRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectRequestStatus.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectSuccessResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateCreateRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateInfoResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateListParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateListResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateModificationRequest.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateModifyParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateParams.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateParamsDeprecated.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateRequestStatus.py
-Comment: 
-
-Filename: ngccli/data/pym/ProjectTemplateSuccessResponse.py
-Comment: 
-
-Filename: ngccli/data/pym/SecretKeySpec.py
-Comment: 
-
-Filename: ngccli/data/pym/SecretSpec.py
-Comment: 
-
-Filename: ngccli/data/pym/Workspace.py
-Comment: 
-
-Filename: ngccli/data/pym/__init__.py
-Comment: 
-
-Filename: ngccli/data/registry/AccessTypeEnum.py
-Comment: 
-
-Filename: ngccli/data/registry/Actor.py
-Comment: 
-
-Filename: ngccli/data/registry/Allowlist.py
-Comment: 
-
-Filename: ngccli/data/registry/AllowlistItem.py
-Comment: 
-
-Filename: ngccli/data/registry/Analysis.py
-Comment: 
-
-Filename: ngccli/data/registry/AnalysisStatus.py
-Comment: 
-
-Filename: ngccli/data/registry/AnchoreParameter.py
-Comment: 
-
-Filename: ngccli/data/registry/AnchorePolicyBundle.py
-Comment: 
-
-Filename: ngccli/data/registry/AnchorePolicyBundleRecord.py
-Comment: 
-
-Filename: ngccli/data/registry/BaseImageDetails.py
-Comment: 
-
-Filename: ngccli/data/registry/BaseImageList.py
-Comment: 
-
-Filename: ngccli/data/registry/BaseImagesDetailResponse.py
-Comment: 
-
-Filename: ngccli/data/registry/BlobSum.py
-Comment: 
-
-Filename: ngccli/data/registry/CatalogArtifactMetadata.py
-Comment: 
-
-Filename: ngccli/data/registry/Envelope.py
-Comment: 
-
-Filename: ngccli/data/registry/EventRequest.py
-Comment: 
-
-Filename: ngccli/data/registry/EventSource.py
-Comment: 
-
-Filename: ngccli/data/registry/EventTarget.py
-Comment: 
-
-Filename: ngccli/data/registry/GetManifestByTagResponse.py
-Comment: 
-
-Filename: ngccli/data/registry/GetRepositoryTagVexResponse.py
-Comment: 
-
-Filename: ngccli/data/registry/GetTagsResponse.py
-Comment: 
-
-Filename: ngccli/data/registry/Header.py
-Comment: 
-
-Filename: ngccli/data/registry/HistoryLayer.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageArchitectureVariant.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageDeleteRequest.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageOwnerDetails.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageRef.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageScanDetails.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageSelectionRule.py
-Comment: 
-
-Filename: ngccli/data/registry/ImageSignature.py
-Comment: 
-
-Filename: ngccli/data/registry/Jwk.py
-Comment: 
-
-Filename: ngccli/data/registry/ManifestByTagV2Response.py
-Comment: 
-
-Filename: ngccli/data/registry/ManifestListByTagV2Response.py
-Comment: 
-
-Filename: ngccli/data/registry/ManifestV2Config.py
-Comment: 
-
-Filename: ngccli/data/registry/ManifestV2Layer.py
+Filename: ngcbpc/data/search/AccessTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/registry/MappingRule.py
+Filename: ngcbpc/data/search/CountParams.py
 Comment: 
 
-Filename: ngccli/data/registry/MetaImageDetails.py
+Filename: ngcbpc/data/search/CountParamsField.py
 Comment: 
 
-Filename: ngccli/data/registry/MetaImageDetailsList.py
+Filename: ngcbpc/data/search/CountResponse.py
 Comment: 
 
-Filename: ngccli/data/registry/OciIndexManifest.py
+Filename: ngcbpc/data/search/CountResponseCount.py
 Comment: 
 
-Filename: ngccli/data/registry/OciIndexResponse.py
+Filename: ngcbpc/data/search/CountResponseParams.py
 Comment: 
 
-Filename: ngccli/data/registry/PaginationInfo.py
+Filename: ngcbpc/data/search/Health.py
 Comment: 
 
-Filename: ngccli/data/registry/Platform.py
+Filename: ngcbpc/data/search/HealthResponse.py
 Comment: 
 
-Filename: ngccli/data/registry/PlatformManifest.py
+Filename: ngcbpc/data/search/LabelGroup.py
 Comment: 
 
-Filename: ngccli/data/registry/PolicyRule.py
+Filename: ngcbpc/data/search/LabelGroupValue.py
 Comment: 
 
-Filename: ngccli/data/registry/ProductNamesEnum.py
+Filename: ngcbpc/data/search/LabelResponseGlobal.py
 Comment: 
 
-Filename: ngccli/data/registry/RegistryEvent.py
+Filename: ngcbpc/data/search/LabelResponseOrgTeam.py
 Comment: 
 
-Filename: ngccli/data/registry/Repository.py
+Filename: ngcbpc/data/search/LabelSet.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryCreateRequest.py
+Filename: ngcbpc/data/search/LabelSetCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryImageDetails.py
+Filename: ngcbpc/data/search/LabelSetResponse.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryImageDetailsList.py
+Filename: ngcbpc/data/search/LabelSetUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryImageScanComplete.py
+Filename: ngcbpc/data/search/LabelValue.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryImagesDeletedEvent.py
+Filename: ngcbpc/data/search/ListLabelSetsResponse.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryInfoUpdateRequest.py
+Filename: ngcbpc/data/search/MetaData.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryLabelsPatchRequest.py
+Filename: ngcbpc/data/search/Resource.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryList.py
+Filename: ngcbpc/data/search/ResourceAttribute.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryTagVexByDigest.py
+Filename: ngcbpc/data/search/ResourceEventEnum.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryTagVexDetail.py
+Filename: ngcbpc/data/search/ResourceLabel.py
 Comment: 
 
-Filename: ngccli/data/registry/RepositoryTagsCountResponse.py
+Filename: ngcbpc/data/search/ResourcePopularityTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/registry/RequestStatus.py
+Filename: ngcbpc/data/search/ResourcePopularityUpdate.py
 Comment: 
 
-Filename: ngccli/data/registry/Response.py
+Filename: ngcbpc/data/search/ResourceTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/registry/RuleSet.py
+Filename: ngcbpc/data/search/SearchFilterCategory.py
 Comment: 
 
-Filename: ngccli/data/registry/ScanIssue.py
+Filename: ngcbpc/data/search/SearchFilterValue.py
 Comment: 
 
-Filename: ngccli/data/registry/ScanIssueCount.py
+Filename: ngcbpc/data/search/SearchParamFilter.py
 Comment: 
 
-Filename: ngccli/data/registry/ScanIssueSeverity.py
+Filename: ngcbpc/data/search/SearchParamOrderBy.py
 Comment: 
 
-Filename: ngccli/data/registry/ScanStatus.py
+Filename: ngcbpc/data/search/SearchParamOrderByEnum.py
 Comment: 
 
-Filename: ngccli/data/registry/ScanType.py
+Filename: ngcbpc/data/search/SearchParams.py
 Comment: 
 
-Filename: ngccli/data/registry/SecurityRatingDescription.py
+Filename: ngcbpc/data/search/SearchPopularityUpdateQueueMsg.py
 Comment: 
 
-Filename: ngccli/data/registry/SecurityRatingType.py
+Filename: ngcbpc/data/search/SearchQueueMsg.py
 Comment: 
 
-Filename: ngccli/data/registry/SecurityRatingsResponse.py
+Filename: ngcbpc/data/search/SearchResponse.py
 Comment: 
 
-Filename: ngccli/data/registry/StatusCode.py
+Filename: ngcbpc/data/search/SearchResponseResult.py
 Comment: 
 
-Filename: ngccli/data/registry/TagUpdateRequest.py
+Filename: ngcbpc/data/search/SearchResponseResultResource.py
 Comment: 
 
-Filename: ngccli/data/registry/__init__.py
+Filename: ngcbpc/data/search/__init__.py
 Comment: 
 
-Filename: ngccli/data/search/AccessTypeEnum.py
+Filename: ngcbpc/data/uis/AccountInfo.py
 Comment: 
 
-Filename: ngccli/data/search/CountParams.py
+Filename: ngcbpc/data/uis/AddRolesRequest.py
 Comment: 
 
-Filename: ngccli/data/search/CountParamsField.py
+Filename: ngcbpc/data/uis/AlternateContact.py
 Comment: 
 
-Filename: ngccli/data/search/CountResponse.py
+Filename: ngcbpc/data/uis/ApiKey.py
 Comment: 
 
-Filename: ngccli/data/search/CountResponseCount.py
+Filename: ngcbpc/data/uis/ApiKeyPolicy.py
 Comment: 
 
-Filename: ngccli/data/search/CountResponseParams.py
+Filename: ngcbpc/data/uis/ApiKeyRequest.py
 Comment: 
 
-Filename: ngccli/data/search/Health.py
+Filename: ngcbpc/data/uis/ApiKeyResponse.py
 Comment: 
 
-Filename: ngccli/data/search/HealthResponse.py
+Filename: ngcbpc/data/uis/ApiKeyStatusEnum.py
 Comment: 
 
-Filename: ngccli/data/search/LabelGroup.py
+Filename: ngcbpc/data/uis/ApiKeyTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/search/LabelGroupValue.py
+Filename: ngcbpc/data/uis/CreateBillingAccountRequest.py
 Comment: 
 
-Filename: ngccli/data/search/LabelResponseGlobal.py
+Filename: ngcbpc/data/uis/CreateBillingAccountResponse.py
 Comment: 
 
-Filename: ngccli/data/search/LabelResponseOrgTeam.py
+Filename: ngcbpc/data/uis/CreateUserRolesRequest.py
 Comment: 
 
-Filename: ngccli/data/search/LabelSet.py
+Filename: ngcbpc/data/uis/EmailTemplateDataSourceEnum.py
 Comment: 
 
-Filename: ngccli/data/search/LabelSetCreateRequest.py
+Filename: ngcbpc/data/uis/EmailTemplateTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/search/LabelSetResponse.py
+Filename: ngcbpc/data/uis/ErrorResponse.py
 Comment: 
 
-Filename: ngccli/data/search/LabelSetUpdateRequest.py
+Filename: ngcbpc/data/uis/GetUchIdByOrgResponse.py
 Comment: 
 
-Filename: ngccli/data/search/LabelValue.py
+Filename: ngcbpc/data/uis/Health.py
 Comment: 
 
-Filename: ngccli/data/search/ListLabelSetsResponse.py
+Filename: ngcbpc/data/uis/HealthResponse.py
 Comment: 
 
-Filename: ngccli/data/search/MetaData.py
+Filename: ngcbpc/data/uis/IdpLock.py
 Comment: 
 
-Filename: ngccli/data/search/Resource.py
+Filename: ngcbpc/data/uis/IdpLockResponse.py
 Comment: 
 
-Filename: ngccli/data/search/ResourceAttribute.py
+Filename: ngcbpc/data/uis/IdpRule.py
 Comment: 
 
-Filename: ngccli/data/search/ResourceEventEnum.py
+Filename: ngcbpc/data/uis/IdpRuleListResponse.py
 Comment: 
 
-Filename: ngccli/data/search/ResourceLabel.py
+Filename: ngcbpc/data/uis/IdpRuleRequest.py
 Comment: 
 
-Filename: ngccli/data/search/ResourcePopularityTypeEnum.py
+Filename: ngcbpc/data/uis/IdpRuleResponse.py
 Comment: 
 
-Filename: ngccli/data/search/ResourcePopularityUpdate.py
+Filename: ngcbpc/data/uis/InfinityManagerSettings.py
 Comment: 
 
-Filename: ngccli/data/search/ResourceTypeEnum.py
+Filename: ngcbpc/data/uis/ListApiKeysResponse.py
 Comment: 
 
-Filename: ngccli/data/search/SearchFilterCategory.py
+Filename: ngcbpc/data/uis/ListRolesResponse.py
 Comment: 
 
-Filename: ngccli/data/search/SearchFilterValue.py
+Filename: ngcbpc/data/uis/ListUserRolesResponse.py
 Comment: 
 
-Filename: ngccli/data/search/SearchParamFilter.py
+Filename: ngcbpc/data/uis/MetaData.py
 Comment: 
 
-Filename: ngccli/data/search/SearchParamOrderBy.py
+Filename: ngcbpc/data/uis/NvcfCluster.py
 Comment: 
 
-Filename: ngccli/data/search/SearchParamOrderByEnum.py
+Filename: ngcbpc/data/uis/NvcfGpuUsage.py
 Comment: 
 
-Filename: ngccli/data/search/SearchParams.py
+Filename: ngcbpc/data/uis/NvcfGpuUsageRequest.py
 Comment: 
 
-Filename: ngccli/data/search/SearchPopularityUpdateQueueMsg.py
+Filename: ngcbpc/data/uis/NvcfGpuUsageResponse.py
 Comment: 
 
-Filename: ngccli/data/search/SearchQueueMsg.py
+Filename: ngcbpc/data/uis/NvcfOrgResponse.py
 Comment: 
 
-Filename: ngccli/data/search/SearchResponse.py
+Filename: ngcbpc/data/uis/NvcfOrgUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/search/SearchResponseResult.py
+Filename: ngcbpc/data/uis/OrgAdminUserCreatedEvent.py
 Comment: 
 
-Filename: ngccli/data/search/SearchResponseResultResource.py
+Filename: ngcbpc/data/uis/OrgListResponse.py
 Comment: 
 
-Filename: ngccli/data/search/__init__.py
+Filename: ngcbpc/data/uis/OrgOwner.py
 Comment: 
 
-Filename: ngccli/data/sms/HealthResponse.py
+Filename: ngcbpc/data/uis/OrgOwnerUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/sms/KV.py
+Filename: ngcbpc/data/uis/OrgOwnersResponse.py
 Comment: 
 
-Filename: ngccli/data/sms/Secret.py
+Filename: ngcbpc/data/uis/OrgProfileUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretCreateRequest.py
+Filename: ngcbpc/data/uis/OrgType.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretDecryptRequest.py
+Filename: ngcbpc/data/uis/OrgUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretDecryptResponse.py
+Filename: ngcbpc/data/uis/Organization.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretGetResponse.py
+Filename: ngcbpc/data/uis/PaginationInfo.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretModifyRequest.py
+Filename: ngcbpc/data/uis/ProductEnablement.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretNameKV.py
+Filename: ngcbpc/data/uis/ProductSubscription.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretRequestStatus.py
+Filename: ngcbpc/data/uis/PurchaseOrder.py
 Comment: 
 
-Filename: ngccli/data/sms/SecretSuccessResponse.py
+Filename: ngcbpc/data/uis/RemoveRolesRequest.py
 Comment: 
 
-Filename: ngccli/data/sms/__init__.py
+Filename: ngcbpc/data/uis/RemovedUser.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Action.py
+Filename: ngcbpc/data/uis/RemovedUserListResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/AzureMarketplaceSubscription.py
+Filename: ngcbpc/data/uis/RepoScanSettings.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py
+Filename: ngcbpc/data/uis/RequestStatus.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py
+Filename: ngcbpc/data/uis/Resource.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py
+Filename: ngcbpc/data/uis/Response.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/BusinessContact.py
+Filename: ngcbpc/data/uis/RoleScopes.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Charge.py
+Filename: ngcbpc/data/uis/RoleScopesRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateOrderRequest.py
+Filename: ngcbpc/data/uis/RoleScopesResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateOrderResponse.py
+Filename: ngcbpc/data/uis/RoleType.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateProductOfferRequest.py
+Filename: ngcbpc/data/uis/RotateApiKeyRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateProductOfferResponse.py
+Filename: ngcbpc/data/uis/SakCallerInfoRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateProductRequest.py
+Filename: ngcbpc/data/uis/SakCallerInfoResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateSubscriptionsRequest.py
+Filename: ngcbpc/data/uis/SendTemplatedEmailRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/CreateSubscriptionsResponse.py
+Filename: ngcbpc/data/uis/ServiceAccess.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ErrorResponse.py
+Filename: ngcbpc/data/uis/StatusCode.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/GetSubscriptionRequestResponse.py
+Filename: ngcbpc/data/uis/TargetSystemUserIdentifier.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/GtsOrderTypeEnum.py
+Filename: ngcbpc/data/uis/Team.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Health.py
+Filename: ngcbpc/data/uis/TeamCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/HealthResponse.py
+Filename: ngcbpc/data/uis/TeamCreateResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/LineItem.py
+Filename: ngcbpc/data/uis/TeamCreatedEvent.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/LineItemTypeEnum.py
+Filename: ngcbpc/data/uis/TeamListResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ListProductOffersResponse.py
+Filename: ngcbpc/data/uis/TeamResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ListSubscriptionRequestsResponse.py
+Filename: ngcbpc/data/uis/TeamUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ListSubscriptionsResponse.py
+Filename: ngcbpc/data/uis/UisOrgInfoResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ListUserSubscriptionsResponse.py
+Filename: ngcbpc/data/uis/UpdateApiKeyRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/MetaData.py
+Filename: ngcbpc/data/uis/UpdateUisOrgInfoRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Order.py
+Filename: ngcbpc/data/uis/User.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/OrderActionTypeEnum.py
+Filename: ngcbpc/data/uis/UserCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/OrderSummary.py
+Filename: ngcbpc/data/uis/UserCreatedEvent.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/OrgEnablementCreateRequest.py
+Filename: ngcbpc/data/uis/UserGdprStatus.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PaginationInfo.py
+Filename: ngcbpc/data/uis/UserIdentifierType.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PreviewOrder.py
+Filename: ngcbpc/data/uis/UserInvitation.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PreviewOrderRequest.py
+Filename: ngcbpc/data/uis/UserInvitationListResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PreviewOrderResponse.py
+Filename: ngcbpc/data/uis/UserInvitationResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PriceFormatEnum.py
+Filename: ngcbpc/data/uis/UserKeyResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Pricing.py
+Filename: ngcbpc/data/uis/UserListResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Product.py
+Filename: ngcbpc/data/uis/UserMetadata.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductEnablement.py
+Filename: ngcbpc/data/uis/UserProfile.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductOffer.py
+Filename: ngcbpc/data/uis/UserProfileGetResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductPlan.py
+Filename: ngcbpc/data/uis/UserProfileOrgInfo.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductPlansResponse.py
+Filename: ngcbpc/data/uis/UserProfileUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductResponse.py
+Filename: ngcbpc/data/uis/UserResponse.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ProductsResponse.py
+Filename: ngcbpc/data/uis/UserRole.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/PurchaseOrder.py
+Filename: ngcbpc/data/uis/UserRoleDefinition.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py
+Filename: ngcbpc/data/uis/UserRoles.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py
+Filename: ngcbpc/data/uis/UserStatus.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RedeemSubscriptionRequest.py
+Filename: ngcbpc/data/uis/UserStorageQuota.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RedeemSubscriptionResponse.py
+Filename: ngcbpc/data/uis/UserUpdateRequest.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RelatedArtifact.py
+Filename: ngcbpc/data/uis/UsersInfo.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RelatedArtifactsResponse.py
+Filename: ngcbpc/data/uis/__init__.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RelatedItem.py
+Filename: ngcbpc/environ.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RenewSubscriptionResponse.py
+Filename: ngcbpc/errors.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RequestCreateSubscriptionRequest.py
+Filename: ngcbpc/expiring_cache.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RequestCreateSubscriptionResponse.py
+Filename: ngcbpc/logger.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/RequestStatus.py
+Filename: ngcbpc/printer/__init__.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Response.py
+Filename: ngcbpc/printer/config.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/ReviewSubscriptionRequestRequest.py
+Filename: ngcbpc/printer/formatter.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/StatusCode.py
+Filename: ngcbpc/printer/nvPrettyPrint.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Subscription.py
+Filename: ngcbpc/printer/prettytableWrap.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequest.py
+Filename: ngcbpc/printer/transfer.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequestActionEnum.py
+Filename: ngcbpc/printer/utils.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py
+Filename: ngcbpc/singleton.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequestHistory.py
+Filename: ngcbpc/timer.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequestStatusEnum.py
+Filename: ngcbpc/tracing.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py
+Filename: ngcbpc/transfer/__init__.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionResponse.py
+Filename: ngcbpc/transfer/adapter.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/SubscriptionStatusEnum.py
+Filename: ngcbpc/transfer/async_download.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Tab.py
+Filename: ngcbpc/transfer/controller.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/Tou.py
+Filename: ngcbpc/transfer/download.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/UpdateAccountStatusGtsRequest.py
+Filename: ngcbpc/transfer/file_cache.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/UpdateAccountStatusGtsResponse.py
+Filename: ngcbpc/transfer/grpc/__init__.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/UpdateProductRequest.py
+Filename: ngcbpc/transfer/grpc/proto_py/__init__.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/UserSubscriptions.py
+Filename: ngcbpc/transfer/grpc/proto_py/upload_pb2.py
 Comment: 
 
-Filename: ngccli/data/subscription_management_service/__init__.py
+Filename: ngcbpc/transfer/grpc/proto_py/upload_pb2_grpc.py
 Comment: 
 
-Filename: ngccli/data/uis/AccountInfo.py
+Filename: ngcbpc/transfer/http_uploader.py
 Comment: 
 
-Filename: ngccli/data/uis/AddRolesRequest.py
+Filename: ngcbpc/transfer/manager.py
 Comment: 
 
-Filename: ngccli/data/uis/AlternateContact.py
+Filename: ngcbpc/transfer/task.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKey.py
+Filename: ngcbpc/transfer/upload.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKeyPolicy.py
+Filename: ngcbpc/transfer/utils.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKeyRequest.py
+Filename: ngcbpc/transformer/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKeyResponse.py
+Filename: ngcbpc/util/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKeyStatusEnum.py
+Filename: ngcbpc/util/base_utils.py
 Comment: 
 
-Filename: ngccli/data/uis/ApiKeyTypeEnum.py
+Filename: ngcbpc/util/datetime_utils.py
 Comment: 
 
-Filename: ngccli/data/uis/CreateBillingAccountRequest.py
+Filename: ngcbpc/util/db_util.py
 Comment: 
 
-Filename: ngccli/data/uis/CreateBillingAccountResponse.py
+Filename: ngcbpc/util/file_utils.py
 Comment: 
 
-Filename: ngccli/data/uis/CreateUserRolesRequest.py
+Filename: ngcbpc/util/io_utils.py
 Comment: 
 
-Filename: ngccli/data/uis/EmailTemplateDataSourceEnum.py
+Filename: ngcbpc/util/ssh_utils.py
 Comment: 
 
-Filename: ngccli/data/uis/EmailTemplateTypeEnum.py
+Filename: ngcbpc/util/utils.py
 Comment: 
 
-Filename: ngccli/data/uis/ErrorResponse.py
+Filename: ngcsdk/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/GetUchIdByOrgResponse.py
+Filename: nvcf/api/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/Health.py
+Filename: nvcf/api/asset.py
 Comment: 
 
-Filename: ngccli/data/uis/HealthResponse.py
+Filename: nvcf/api/deploy.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpLock.py
+Filename: nvcf/api/deployment_spec.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpLockResponse.py
+Filename: nvcf/api/function.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpRule.py
+Filename: nvcf/api/gdn_nvcf_grpc_client/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpRuleListResponse.py
+Filename: nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpRuleRequest.py
+Filename: nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2_grpc.py
 Comment: 
 
-Filename: ngccli/data/uis/IdpRuleResponse.py
+Filename: nvcf/api/gdn_nvcf_grpc_client/model_config_pb2.py
 Comment: 
 
-Filename: ngccli/data/uis/InfinityManagerSettings.py
+Filename: nvcf/api/invocation_handler.py
 Comment: 
 
-Filename: ngccli/data/uis/ListApiKeysResponse.py
+Filename: nvcf/api/nvcf.py
 Comment: 
 
-Filename: ngccli/data/uis/ListRolesResponse.py
+Filename: nvcf/api/utils.py
 Comment: 
 
-Filename: ngccli/data/uis/ListUserRolesResponse.py
+Filename: nvcf/command/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/MetaData.py
+Filename: nvcf/command/all_commands.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfCluster.py
+Filename: nvcf/command/args_validation.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfGpuUsage.py
+Filename: nvcf/command/cloud_function.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfGpuUsageRequest.py
+Filename: nvcf/command/deploy.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfGpuUsageResponse.py
+Filename: nvcf/command/function.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfOrgResponse.py
+Filename: nvcf/command/utils.py
 Comment: 
 
-Filename: ngccli/data/uis/NvcfOrgUpdateRequest.py
+Filename: nvcf/constants.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgAdminUserCreatedEvent.py
+Filename: nvcf/printer/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgListResponse.py
+Filename: nvcf/printer/deploy_printer.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgOwner.py
+Filename: nvcf/printer/function_printer.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgOwnerUpdateRequest.py
+Filename: organization/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgOwnersResponse.py
+Filename: organization/api/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgProfileUpdateRequest.py
+Filename: organization/api/alert.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgType.py
+Filename: organization/api/audit.py
 Comment: 
 
-Filename: ngccli/data/uis/OrgUpdateRequest.py
+Filename: organization/api/organization.py
 Comment: 
 
-Filename: ngccli/data/uis/Organization.py
+Filename: organization/api/orgs.py
 Comment: 
 
-Filename: ngccli/data/uis/PaginationInfo.py
+Filename: organization/api/secrets.py
 Comment: 
 
-Filename: ngccli/data/uis/ProductEnablement.py
+Filename: organization/api/storage.py
 Comment: 
 
-Filename: ngccli/data/uis/ProductSubscription.py
+Filename: organization/api/subscription.py
 Comment: 
 
-Filename: ngccli/data/uis/PurchaseOrder.py
+Filename: organization/api/teams.py
 Comment: 
 
-Filename: ngccli/data/uis/RemoveRolesRequest.py
+Filename: organization/api/users.py
 Comment: 
 
-Filename: ngccli/data/uis/RemovedUser.py
+Filename: organization/command/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/RemovedUserListResponse.py
+Filename: organization/command/alert.py
 Comment: 
 
-Filename: ngccli/data/uis/RepoScanSettings.py
+Filename: organization/command/all_commands.py
 Comment: 
 
-Filename: ngccli/data/uis/RequestStatus.py
+Filename: organization/command/audit.py
 Comment: 
 
-Filename: ngccli/data/uis/Resource.py
+Filename: organization/command/org.py
 Comment: 
 
-Filename: ngccli/data/uis/Response.py
+Filename: organization/command/secret.py
 Comment: 
 
-Filename: ngccli/data/uis/RoleScopes.py
+Filename: organization/command/subscription.py
 Comment: 
 
-Filename: ngccli/data/uis/RoleScopesRequest.py
+Filename: organization/command/team.py
 Comment: 
 
-Filename: ngccli/data/uis/RoleScopesResponse.py
+Filename: organization/command/user.py
 Comment: 
 
-Filename: ngccli/data/uis/RoleType.py
+Filename: organization/data/sms/HealthResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/RotateApiKeyRequest.py
+Filename: organization/data/sms/KV.py
 Comment: 
 
-Filename: ngccli/data/uis/SakCallerInfoRequest.py
+Filename: organization/data/sms/Secret.py
 Comment: 
 
-Filename: ngccli/data/uis/SakCallerInfoResponse.py
+Filename: organization/data/sms/SecretCreateRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/SendTemplatedEmailRequest.py
+Filename: organization/data/sms/SecretDecryptRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/ServiceAccess.py
+Filename: organization/data/sms/SecretDecryptResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/StatusCode.py
+Filename: organization/data/sms/SecretGetResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/TargetSystemUserIdentifier.py
+Filename: organization/data/sms/SecretModifyRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/Team.py
+Filename: organization/data/sms/SecretNameKV.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamCreateRequest.py
+Filename: organization/data/sms/SecretRequestStatus.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamCreateResponse.py
+Filename: organization/data/sms/SecretSuccessResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamCreatedEvent.py
+Filename: organization/data/sms/__init__.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamListResponse.py
+Filename: organization/data/subscription_management_service/Action.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamResponse.py
+Filename: organization/data/subscription_management_service/AzureMarketplaceSubscription.py
 Comment: 
 
-Filename: ngccli/data/uis/TeamUpdateRequest.py
+Filename: organization/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py
 Comment: 
 
-Filename: ngccli/data/uis/UisOrgInfoResponse.py
+Filename: organization/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py
 Comment: 
 
-Filename: ngccli/data/uis/UpdateApiKeyRequest.py
+Filename: organization/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py
 Comment: 
 
-Filename: ngccli/data/uis/UpdateUisOrgInfoRequest.py
+Filename: organization/data/subscription_management_service/BusinessContact.py
 Comment: 
 
-Filename: ngccli/data/uis/User.py
+Filename: organization/data/subscription_management_service/Charge.py
 Comment: 
 
-Filename: ngccli/data/uis/UserCreateRequest.py
+Filename: organization/data/subscription_management_service/CreateOrderRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/UserCreatedEvent.py
+Filename: organization/data/subscription_management_service/CreateOrderResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserGdprStatus.py
+Filename: organization/data/subscription_management_service/CreateProductOfferRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/UserIdentifierType.py
+Filename: organization/data/subscription_management_service/CreateProductOfferResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserInvitation.py
+Filename: organization/data/subscription_management_service/CreateProductRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/UserInvitationListResponse.py
+Filename: organization/data/subscription_management_service/CreateSubscriptionsRequest.py
 Comment: 
 
-Filename: ngccli/data/uis/UserInvitationResponse.py
+Filename: organization/data/subscription_management_service/CreateSubscriptionsResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserKeyResponse.py
+Filename: organization/data/subscription_management_service/ErrorResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserListResponse.py
+Filename: organization/data/subscription_management_service/GetSubscriptionRequestResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserMetadata.py
+Filename: organization/data/subscription_management_service/GtsOrderTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/uis/UserProfile.py
+Filename: organization/data/subscription_management_service/Health.py
 Comment: 
 
-Filename: ngccli/data/uis/UserProfileGetResponse.py
+Filename: organization/data/subscription_management_service/HealthResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserProfileOrgInfo.py
+Filename: organization/data/subscription_management_service/LineItem.py
 Comment: 
 
-Filename: ngccli/data/uis/UserProfileUpdateRequest.py
+Filename: organization/data/subscription_management_service/LineItemTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/uis/UserResponse.py
+Filename: organization/data/subscription_management_service/ListProductOffersResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserRole.py
+Filename: organization/data/subscription_management_service/ListSubscriptionRequestsResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserRoleDefinition.py
+Filename: organization/data/subscription_management_service/ListSubscriptionsResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserRoles.py
+Filename: organization/data/subscription_management_service/ListUserSubscriptionsResponse.py
 Comment: 
 
-Filename: ngccli/data/uis/UserStatus.py
+Filename: organization/data/subscription_management_service/MetaData.py
 Comment: 
 
-Filename: ngccli/data/uis/UserStorageQuota.py
+Filename: organization/data/subscription_management_service/Order.py
 Comment: 
 
-Filename: ngccli/data/uis/UserUpdateRequest.py
+Filename: organization/data/subscription_management_service/OrderActionTypeEnum.py
 Comment: 
 
-Filename: ngccli/data/uis/UsersInfo.py
+Filename: organization/data/subscription_management_service/OrderSummary.py
 Comment: 
 
-Filename: ngccli/data/uis/__init__.py
+Filename: organization/data/subscription_management_service/OrgEnablementCreateRequest.py
 Comment: 
 
-Filename: ngcsdk/__init__.py
+Filename: organization/data/subscription_management_service/PaginationInfo.py
 Comment: 
 
-Filename: nvcf/api/__init__.py
+Filename: organization/data/subscription_management_service/PreviewOrder.py
 Comment: 
 
-Filename: nvcf/api/asset.py
+Filename: organization/data/subscription_management_service/PreviewOrderRequest.py
 Comment: 
 
-Filename: nvcf/api/deploy.py
+Filename: organization/data/subscription_management_service/PreviewOrderResponse.py
 Comment: 
 
-Filename: nvcf/api/deployment_spec.py
+Filename: organization/data/subscription_management_service/PriceFormatEnum.py
 Comment: 
 
-Filename: nvcf/api/function.py
+Filename: organization/data/subscription_management_service/Pricing.py
 Comment: 
 
-Filename: nvcf/api/gdn_nvcf_grpc_client/__init__.py
+Filename: organization/data/subscription_management_service/Product.py
 Comment: 
 
-Filename: nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2.py
+Filename: organization/data/subscription_management_service/ProductEnablement.py
 Comment: 
 
-Filename: nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2_grpc.py
+Filename: organization/data/subscription_management_service/ProductOffer.py
 Comment: 
 
-Filename: nvcf/api/gdn_nvcf_grpc_client/model_config_pb2.py
+Filename: organization/data/subscription_management_service/ProductPlan.py
 Comment: 
 
-Filename: nvcf/api/invocation_handler.py
+Filename: organization/data/subscription_management_service/ProductPlansResponse.py
 Comment: 
 
-Filename: nvcf/api/nvcf.py
+Filename: organization/data/subscription_management_service/ProductResponse.py
 Comment: 
 
-Filename: nvcf/api/utils.py
+Filename: organization/data/subscription_management_service/ProductsResponse.py
 Comment: 
 
-Filename: nvcf/command/__init__.py
+Filename: organization/data/subscription_management_service/PurchaseOrder.py
 Comment: 
 
-Filename: nvcf/command/all_commands.py
+Filename: organization/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py
 Comment: 
 
-Filename: nvcf/command/args_validation.py
+Filename: organization/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py
 Comment: 
 
-Filename: nvcf/command/cloud_function.py
+Filename: organization/data/subscription_management_service/RedeemSubscriptionRequest.py
 Comment: 
 
-Filename: nvcf/command/deploy.py
+Filename: organization/data/subscription_management_service/RedeemSubscriptionResponse.py
 Comment: 
 
-Filename: nvcf/command/function.py
+Filename: organization/data/subscription_management_service/RelatedArtifact.py
 Comment: 
 
-Filename: nvcf/command/utils.py
+Filename: organization/data/subscription_management_service/RelatedArtifactsResponse.py
 Comment: 
 
-Filename: nvcf/constants.py
+Filename: organization/data/subscription_management_service/RelatedItem.py
 Comment: 
 
-Filename: nvcf/printer/__init__.py
+Filename: organization/data/subscription_management_service/RenewSubscriptionResponse.py
 Comment: 
 
-Filename: nvcf/printer/deploy_printer.py
+Filename: organization/data/subscription_management_service/RequestCreateSubscriptionRequest.py
 Comment: 
 
-Filename: nvcf/printer/function_printer.py
+Filename: organization/data/subscription_management_service/RequestCreateSubscriptionResponse.py
 Comment: 
 
-Filename: organization/__init__.py
+Filename: organization/data/subscription_management_service/RequestStatus.py
 Comment: 
 
-Filename: organization/api/__init__.py
+Filename: organization/data/subscription_management_service/Response.py
 Comment: 
 
-Filename: organization/api/alert.py
+Filename: organization/data/subscription_management_service/ReviewSubscriptionRequestRequest.py
 Comment: 
 
-Filename: organization/api/audit.py
+Filename: organization/data/subscription_management_service/StatusCode.py
 Comment: 
 
-Filename: organization/api/organization.py
+Filename: organization/data/subscription_management_service/Subscription.py
 Comment: 
 
-Filename: organization/api/orgs.py
+Filename: organization/data/subscription_management_service/SubscriptionRequest.py
 Comment: 
 
-Filename: organization/api/secrets.py
+Filename: organization/data/subscription_management_service/SubscriptionRequestActionEnum.py
 Comment: 
 
-Filename: organization/api/storage.py
+Filename: organization/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py
 Comment: 
 
-Filename: organization/api/subscription.py
+Filename: organization/data/subscription_management_service/SubscriptionRequestHistory.py
 Comment: 
 
-Filename: organization/api/teams.py
+Filename: organization/data/subscription_management_service/SubscriptionRequestStatusEnum.py
 Comment: 
 
-Filename: organization/api/users.py
+Filename: organization/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py
 Comment: 
 
-Filename: organization/command/__init__.py
+Filename: organization/data/subscription_management_service/SubscriptionResponse.py
 Comment: 
 
-Filename: organization/command/alert.py
+Filename: organization/data/subscription_management_service/SubscriptionStatusEnum.py
 Comment: 
 
-Filename: organization/command/all_commands.py
+Filename: organization/data/subscription_management_service/Tab.py
 Comment: 
 
-Filename: organization/command/audit.py
+Filename: organization/data/subscription_management_service/Tou.py
 Comment: 
 
-Filename: organization/command/org.py
+Filename: organization/data/subscription_management_service/UpdateAccountStatusGtsRequest.py
 Comment: 
 
-Filename: organization/command/secret.py
+Filename: organization/data/subscription_management_service/UpdateAccountStatusGtsResponse.py
 Comment: 
 
-Filename: organization/command/subscription.py
+Filename: organization/data/subscription_management_service/UpdateProductRequest.py
 Comment: 
 
-Filename: organization/command/team.py
+Filename: organization/data/subscription_management_service/UserSubscriptions.py
 Comment: 
 
-Filename: organization/command/user.py
+Filename: organization/data/subscription_management_service/__init__.py
 Comment: 
 
 Filename: organization/environ.py
 Comment: 
 
 Filename: organization/printer/__init__.py
 Comment: 
@@ -4365,14 +3015,50 @@
 
 Filename: registry/command/resource_deploy.py
 Comment: 
 
 Filename: registry/constants.py
 Comment: 
 
+Filename: registry/data/publishing/AccessTypeEnum.py
+Comment: 
+
+Filename: registry/data/publishing/Artifact.py
+Comment: 
+
+Filename: registry/data/publishing/ArtifactBatch.py
+Comment: 
+
+Filename: registry/data/publishing/ArtifactToCollectionRequest.py
+Comment: 
+
+Filename: registry/data/publishing/ArtifactType.py
+Comment: 
+
+Filename: registry/data/publishing/BatchPublishingRequest.py
+Comment: 
+
+Filename: registry/data/publishing/ProductNamesEnum.py
+Comment: 
+
+Filename: registry/data/publishing/PublishingRequest.py
+Comment: 
+
+Filename: registry/data/publishing/RequestStatus.py
+Comment: 
+
+Filename: registry/data/publishing/Response.py
+Comment: 
+
+Filename: registry/data/publishing/StatusCode.py
+Comment: 
+
+Filename: registry/data/publishing/__init__.py
+Comment: 
+
 Filename: registry/environ.py
 Comment: 
 
 Filename: registry/errors.py
 Comment: 
 
 Filename: registry/printer/__init__.py
@@ -4419,20 +3105,20 @@
 
 Filename: registry/transformer/model.py
 Comment: 
 
 Filename: registry/transformer/model_script.py
 Comment: 
 
-Filename: ngcsdk-3.41.4.dist-info/METADATA
+Filename: ngcsdk-3.42.0.dist-info/METADATA
 Comment: 
 
-Filename: ngcsdk-3.41.4.dist-info/WHEEL
+Filename: ngcsdk-3.42.0.dist-info/WHEEL
 Comment: 
 
-Filename: ngcsdk-3.41.4.dist-info/entry_points.txt
+Filename: ngcsdk-3.42.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: ngcsdk-3.41.4.dist-info/RECORD
+Filename: ngcsdk-3.42.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## basecommand/api/aces.py

```diff
@@ -11,18 +11,18 @@
 
 from itertools import chain
 from typing import Literal, Optional
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import API_VERSION, PAGE_SIZE
+from ngcbpc.data.api.AceListResponse import AceListResponse
+from ngcbpc.data.api.AceResponse import AceResponse
 from ngcbpc.errors import NgcException
 from ngcbpc.util.utils import extra_args, url_encode
-from ngccli.data.api.AceListResponse import AceListResponse
-from ngccli.data.api.AceResponse import AceResponse
 
 _NO_ACE_RESOURCES_FOUND_ERROR_MESSAGE = """\
 This ACE has not been configured, and as a result, no usage information is available.
 
 Please report this issue: https://nvcrm.my.site.com/ESPCommunity/s/create-case"""
```

## basecommand/api/dataset.py

```diff
@@ -32,14 +32,20 @@
 from basecommand.transfer.upload_manager import UploadManager
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import (
     pagination_helper,
     pagination_helper_use_page_reference,
 )
 from ngcbpc.constants import API_VERSION, DEFAULT_UPLOAD_THREADS
+from ngcbpc.data.api.DatasetCreateRequest import DatasetCreateRequest
+from ngcbpc.data.api.DatasetFile import DatasetFile
+from ngcbpc.data.api.DatasetListResponse import DatasetListResponse
+from ngcbpc.data.api.DatasetResponse import DatasetResponse
+from ngcbpc.data.api.DatasetStatusEnum import DatasetStatusEnum
+from ngcbpc.data.api.DatasetUpdateRequest import DatasetUpdateRequest
 from ngcbpc.errors import (
     AccessDeniedException,
     InvalidArgumentError,
     NgcAPIError,
     NgcException,
     ResourceNotFoundException,
 )
@@ -52,20 +58,14 @@
     confirm_remove,
     extra_args,
     has_org_admin_user_role,
     has_team_role,
     partition,
     url_encode,
 )
-from ngccli.data.api.DatasetCreateRequest import DatasetCreateRequest
-from ngccli.data.api.DatasetFile import DatasetFile
-from ngccli.data.api.DatasetListResponse import DatasetListResponse
-from ngccli.data.api.DatasetResponse import DatasetResponse
-from ngccli.data.api.DatasetStatusEnum import DatasetStatusEnum
-from ngccli.data.api.DatasetUpdateRequest import DatasetUpdateRequest
 from organization.api.orgs import OrgAPI
 
 PAGE_SIZE = 1000
 
 logger = logging.getLogger(__name__)
 
 
@@ -597,15 +597,15 @@
              Prompt the user to continue adding to the dataset.
              If yes, use the upload cache to continue the upload and skip the previously uploaded files.
 
            - The dataset is created and we have the ID.
         3. Upload the dataset.
 
         Returns:
-            A dict in the form of `{"id": <integer>, "datasetUuid": <string>}`, identifying the uploaded dataset.
+            A dict in the form of ``{"id": <integer>, "datasetUuid": <string>}``, that identifies the uploaded dataset.
         """
         self.config.validate_configuration()
         org = org or self.config.org_name
         team = team or self.config.team_name
         ace = ace or self.config.ace_name
 
         dataset_service_enabled = is_dataset_service_enabled(org_api=self.org_api, org_name=org)
```

## basecommand/api/jobs.py

```diff
@@ -24,31 +24,31 @@
     parse_job_labels,
     parse_secrets,
 )
 from basecommand.constants import STATES_BEFORE_RUNNING
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import API_VERSION, PAGE_SIZE
+from ngcbpc.data.api.Env import Env
+from ngcbpc.data.api.ExpTrackingParams import ExpTrackingParams
+from ngcbpc.data.api.JobCreateRequest import JobCreateRequest
+from ngcbpc.data.api.JobDatasetMountInfo import JobDatasetMountInfo
+from ngcbpc.data.api.JobLabelResponse import JobLabelResponse
+from ngcbpc.data.api.JobListResponse import JobListResponse
+from ngcbpc.data.api.JobPortMapping import JobPortMapping
+from ngcbpc.data.api.JobResponse import JobResponse
+from ngcbpc.data.api.JobRunPolicy import JobRunPolicy
+from ngcbpc.data.api.JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from ngcbpc.data.api.ReplicaResponse import ReplicaResponse
 from ngcbpc.errors import InvalidArgumentError, NgcException
 from ngcbpc.printer.nvPrettyPrint import NVPrettyPrint
 from ngcbpc.transfer.controller import TransferController
 from ngcbpc.transfer.manager import TransferConfig
 from ngcbpc.util.datetime_utils import calculate_date_range
 from ngcbpc.util.utils import extra_args, parse_key_value_pairs
-from ngccli.data.api.Env import Env
-from ngccli.data.api.ExpTrackingParams import ExpTrackingParams
-from ngccli.data.api.JobCreateRequest import JobCreateRequest
-from ngccli.data.api.JobDatasetMountInfo import JobDatasetMountInfo
-from ngccli.data.api.JobLabelResponse import JobLabelResponse
-from ngccli.data.api.JobListResponse import JobListResponse
-from ngccli.data.api.JobPortMapping import JobPortMapping
-from ngccli.data.api.JobResponse import JobResponse
-from ngccli.data.api.JobRunPolicy import JobRunPolicy
-from ngccli.data.api.JobWorkspaceMountInfo import JobWorkspaceMountInfo
-from ngccli.data.api.ReplicaResponse import ReplicaResponse
 from registry.api.utils import ImageRegistryTarget
 
 REQUEST_TIMEOUT_SECONDS_SUBMIT_JOB = 120
 OBJECT_DATASET_MOUNT_POINT = "no-mount"
 
 
 class JobsAPI:
```

## basecommand/api/measurements.py

```diff
@@ -9,15 +9,15 @@
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 
 from urllib.parse import quote
 
 from basecommand.constants import TELEMETRY_TYPE_ENUM, TELEMETRY_TYPE_ENUM_STG
 from ngcbpc.constants import API_VERSION, BUILD_ENV, CANARY_ENV, PRODUCTION_ENV
-from ngccli.data.api.MeasurementResultListResponse import MeasurementResultListResponse
+from ngcbpc.data.api.MeasurementResultListResponse import MeasurementResultListResponse
 
 
 class MeasurementsAPI:
     def __init__(self, connection):
         self.connection = connection
 
     @staticmethod
```

## basecommand/api/quickstart_cluster.py

```diff
@@ -20,30 +20,32 @@
 from argparse import ArgumentTypeError
 import json
 import re
 from typing import Any, Literal, NamedTuple, Optional, Sequence
 
 from basecommand.api.utils import parse_secrets
 from basecommand.constants import QUICKSTART_API_VERSION
+from basecommand.data.pym.ClusterComponentModifyParams import (
+    ClusterComponentModifyParams,
+)
+from basecommand.data.pym.ClusterComponentParams import ClusterComponentParams
+from basecommand.data.pym.ClusterCreateRequest import ClusterCreateRequest
+from basecommand.data.pym.ClusterListResponse import ClusterListResponse
+from basecommand.data.pym.ClusterModifyParams import ClusterModifyParams
+from basecommand.data.pym.ClusterModifyRequest import ClusterModifyRequest
+from basecommand.data.pym.ClusterParams import ClusterParams
+from basecommand.data.pym.DataInput import DataInput
+from basecommand.data.pym.Dataset import Dataset
+from basecommand.data.pym.Workspace import Workspace
 from basecommand.printer.quickstart_cluster import QuickStartClusterPrinter
 from ngcbpc.api.configuration import Configuration
+from ngcbpc.data.api.NetworkProtocolEnum import NetworkProtocolEnum
 from ngcbpc.errors import InvalidArgumentError, NgcException
 from ngcbpc.util.datetime_utils import dhms_to_isoduration
 from ngcbpc.util.utils import format_org_team
-from ngccli.data.api.NetworkProtocolEnum import NetworkProtocolEnum
-from ngccli.data.pym.ClusterComponentModifyParams import ClusterComponentModifyParams
-from ngccli.data.pym.ClusterComponentParams import ClusterComponentParams
-from ngccli.data.pym.ClusterCreateRequest import ClusterCreateRequest
-from ngccli.data.pym.ClusterListResponse import ClusterListResponse
-from ngccli.data.pym.ClusterModifyParams import ClusterModifyParams
-from ngccli.data.pym.ClusterModifyRequest import ClusterModifyRequest
-from ngccli.data.pym.ClusterParams import ClusterParams
-from ngccli.data.pym.DataInput import DataInput
-from ngccli.data.pym.Dataset import Dataset
-from ngccli.data.pym.Workspace import Workspace
 
 PAGE_SIZE = 1000
 VALID_PROTOCOLS = rf"({'|'.join(NetworkProtocolEnum)})"
 RW_TRUE = ("true", "t", "yes", "y", "rw", "1")
 RW_FALSE = ("false", "f", "no", "n", "ro", "0")
```

## basecommand/api/quickstart_project.py

```diff
@@ -15,37 +15,38 @@
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 
 from typing import Literal, Optional, Sequence
 
-# TODO: extract to a better place?
 from basecommand.api.quickstart_cluster import (
     _get_overridden_values,
     ClusterParamError,
     create_cluster_params,
     create_data_input_obj,
     EmptyClusterUpdateError,
     format_update,
     remove_empty_input_obj_values,
 )
 from basecommand.constants import QUICKSTART_API_VERSION, QUICKSTART_TEMPLATE_TYPE_ENUM
+from basecommand.data.pym.ClusterComponentParams import ClusterComponentParams
+from basecommand.data.pym.ClusterParams import ClusterParams
+from basecommand.data.pym.ProjectRequestStatus import ProjectRequestStatus
+from basecommand.data.pym.ProjectTemplateCreateRequest import (
+    ProjectTemplateCreateRequest,
+)
+from basecommand.data.pym.ProjectTemplateModificationRequest import (
+    ProjectTemplateModificationRequest,
+)
+from basecommand.data.pym.ProjectTemplateModifyParams import ProjectTemplateModifyParams
+from basecommand.data.pym.ProjectTemplateParams import ProjectTemplateParams
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.errors import InvalidArgumentError
 from ngcbpc.util.utils import format_org_team
-from ngccli.data.pym.ClusterComponentParams import ClusterComponentParams
-from ngccli.data.pym.ClusterParams import ClusterParams
-from ngccli.data.pym.ProjectRequestStatus import ProjectRequestStatus
-from ngccli.data.pym.ProjectTemplateCreateRequest import ProjectTemplateCreateRequest
-from ngccli.data.pym.ProjectTemplateModificationRequest import (
-    ProjectTemplateModificationRequest,
-)
-from ngccli.data.pym.ProjectTemplateModifyParams import ProjectTemplateModifyParams
-from ngccli.data.pym.ProjectTemplateParams import ProjectTemplateParams
 
 PAGE_SIZE = 1000
 
 
 class QuickStartProjectAPI:
     def __init__(self, connection):
         self.connection = connection
```

## basecommand/api/resource.py

```diff
@@ -13,17 +13,17 @@
 from datetime import datetime
 from itertools import chain, cycle, islice
 import json
 from typing import List, Optional
 
 from basecommand.api.aces import AceAPI
 from ngcbpc.api.configuration import Configuration
+from ngcbpc.data.api.PoolMeasurementType import PoolMeasurementTypeEnum
 from ngcbpc.errors import InvalidArgumentError, NgcException, ResourceNotFoundException
 from ngcbpc.util.utils import has_org_role, has_team_role
-from ngccli.data.api.PoolMeasurementType import PoolMeasurementTypeEnum
 from organization.api.teams import TeamAPI
 from organization.api.users import UsersAPI
 
 PAGE_SIZE = 100
 
 
 class ResourceAPI:
```

## basecommand/api/resultset.py

```diff
@@ -18,21 +18,21 @@
 
 from basecommand.api.utils import is_dataset_service_enabled
 from basecommand.constants import DATASET_SERVICE_API_VERSION, STATES_BEFORE_RUNNING
 from basecommand.printer.result import ResultPrinter
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper_use_page_reference
 from ngcbpc.constants import API_VERSION
+from ngcbpc.data.api.ResultsetFile import ResultsetFile
+from ngcbpc.data.api.ResultsetResponse import ResultsetResponse
 from ngcbpc.errors import NgcException, ResourceNotFoundException
 from ngcbpc.transfer.async_download import AsyncDownload
 from ngcbpc.transfer.utils import get_download_files_size
 from ngcbpc.util.file_utils import human_size, tree_size_and_count
 from ngcbpc.util.utils import confirm_remove, contains_glob, extra_args
-from ngccli.data.api.ResultsetFile import ResultsetFile
-from ngccli.data.api.ResultsetResponse import ResultsetResponse
 from organization.api.orgs import OrgAPI
 
 PAGE_SIZE = 1000
 
 
 class ResultsetAPI:
     def __init__(self, connection, api_client=None, dataset_service_connection=None):
```

## basecommand/api/search.py

```diff
@@ -10,15 +10,15 @@
 # provided with the software product.
 #
 
 from basecommand.transformer.dataset import DatasetSearchTransformer
 from basecommand.transformer.workspace import WorkspaceSearchTransformer
 from ngcbpc.api.pagination import pagination_helper_search
 from ngcbpc.api.search import QUERY_FIELDS, SEARCH_FIELDS, SearchAPI, wrap_search_params
-from ngccli.data.search.SearchParamOrderBy import SearchParamOrderBy
+from ngcbpc.data.search.SearchParamOrderBy import SearchParamOrderBy
 
 
 # pylint: disable=super-init-not-called
 class BaseCommandSearchAPI(SearchAPI):
     def __init__(self, connection):
         self.connection = connection
```

## basecommand/api/utils.py

```diff
@@ -14,24 +14,24 @@
 import string
 
 from basecommand.constants import (
     DATA_MOVER_SERVICE_URL_MAPPING,
     DATASET_SERVICE_URL_MAPPING,
 )
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
+from ngcbpc.data.api.JobLabelDeleteRequest import JobLabelDeleteRequest
+from ngcbpc.data.api.JobLabels import JobLabels
+from ngcbpc.data.api.JobLabelUpdateRequest import JobLabelUpdateRequest
+from ngcbpc.data.api.ReservedLabels import ReservedLabels
+from ngcbpc.data.api.SecretKeySpec import SecretKeySpec
+from ngcbpc.data.api.SecretSpec import SecretSpec
+from ngcbpc.data.api.SystemLabels import SystemLabels
+from ngcbpc.data.api.UserLabels import UserLabels
 from ngcbpc.errors import InvalidArgumentError, NgcException, ValidationException
 from ngcbpc.util.utils import get_environ_tag, has_org_role
-from ngccli.data.api.JobLabelDeleteRequest import JobLabelDeleteRequest
-from ngccli.data.api.JobLabels import JobLabels
-from ngccli.data.api.JobLabelUpdateRequest import JobLabelUpdateRequest
-from ngccli.data.api.ReservedLabels import ReservedLabels
-from ngccli.data.api.SecretKeySpec import SecretKeySpec
-from ngccli.data.api.SecretSpec import SecretSpec
-from ngccli.data.api.SystemLabels import SystemLabels
-from ngccli.data.api.UserLabels import UserLabels
 from organization.api.orgs import OrgAPI
 
 env_mapping = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}
 
 
 def get_data_mover_service_url():
     """Return the appropriate URL for the data mover service."""
```

## basecommand/api/workspace.py

```diff
@@ -35,15 +35,23 @@
     DATASET_SERVICE_API_VERSION,
     STORAGE_TYPE_OBJECT,
     WORKSPACE_SERVER_PORT,
 )
 from basecommand.transfer.upload_manager import UploadManager
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
-from ngcbpc.constants import API_VERSION, DEFAULT_UPLOAD_THREADS
+from ngcbpc.constants import (
+    API_VERSION,
+    DEFAULT_UPLOAD_THREADS,
+    UMASK_GROUP_OTHERS_READ_EXECUTE,
+)
+from ngcbpc.data.api.WorkspaceCreateRequest import WorkspaceCreateRequest
+from ngcbpc.data.api.WorkspaceListResponse import WorkspaceListResponse
+from ngcbpc.data.api.WorkspaceResponse import WorkspaceResponse
+from ngcbpc.data.api.WorkspaceUpdateRequest import WorkspaceUpdateRequest
 from ngcbpc.errors import (
     InvalidArgumentError,
     MissingConfigFileException,
     NgcAPIError,
     NgcException,
     ResourceNotFoundException,
     UnsupportedPlatformException,
@@ -56,18 +64,14 @@
     Command,
     extra_args,
     has_org_admin_user_role,
     has_team_role,
     MaskGranter,
     url_encode,
 )
-from ngccli.data.api.WorkspaceCreateRequest import WorkspaceCreateRequest
-from ngccli.data.api.WorkspaceListResponse import WorkspaceListResponse
-from ngccli.data.api.WorkspaceResponse import WorkspaceResponse
-from ngccli.data.api.WorkspaceUpdateRequest import WorkspaceUpdateRequest
 from organization.api.orgs import OrgAPI
 
 PAGE_SIZE = 1000
 logger = logging.getLogger(__name__)
 
 
 class WorkspaceAPI:
@@ -324,15 +328,15 @@
         ace_sftp_port=None,
     ):
         """Mount a workspace on users local machine."""
         if force:
             self._run_unmount(local_mount_dir)
 
         if not os.path.isdir(local_mount_dir):
-            with MaskGranter(0o022):
+            with MaskGranter(UMASK_GROUP_OTHERS_READ_EXECUTE):
                 mkdir_path(local_mount_dir)
 
         if os.listdir(local_mount_dir):
             raise NgcException("The mount point is not empty. You can only mount in an empty directory!")
 
         # ensure user has write permissions
         if not os.access(local_mount_dir, os.W_OK):
@@ -366,15 +370,15 @@
             read_only=read_only,
             control_path=control_path,
         )
 
         self._test_sshfs_installation()
 
         # perform the actual mount
-        with MaskGranter(0o022):
+        with MaskGranter(UMASK_GROUP_OTHERS_READ_EXECUTE):
             mount_result = Command(shlex.split(mount_command)).run()
             logger.debug(mount_result)
             mount_result.on_error(
                 error="Permission denied", raise_exception=NgcException(f"{_gen_path_warnings(local_mount_dir)}")
             )
             mount_result.on_error(
                 raise_exception=NgcException(f"Permission denied, check owned or shared, {mount_result.stderr}")
@@ -387,15 +391,15 @@
         umount_command = ""
         os_type = platform.system()
         if os_type == "Linux":
             umount_command = "fusermount -u -z {}".format(abs_mount_dir)
         elif os_type == "Darwin":
             umount_command = "diskutil unmount force {}".format(abs_mount_dir)
 
-        with MaskGranter(0o022):
+        with MaskGranter(UMASK_GROUP_OTHERS_READ_EXECUTE):
             umount_result = Command(shlex.split(umount_command)).run()
             logger.debug(umount_result)
             umount_result.on_error(
                 error="Permission denied", raise_exception=NgcException(f"{_gen_path_warnings(local_mount_dir)}")
             )
         return umount_result
```

## basecommand/command/args_validation.py

```diff
@@ -12,19 +12,19 @@
 
 import argparse
 import json
 import platform
 import re
 
 from basecommand.constants import JOB_RESOURCE_VALUES
+from ngcbpc.data.api.JobCreateRequest import JobCreateRequest
+from ngcbpc.data.api.NetworkProtocolEnum import NetworkProtocolEnum
 from ngcbpc.errors import NgcException
 from ngcbpc.util.datetime_utils import dhms_to_isoduration
 from ngcbpc.util.utils import contains_glob
-from ngccli.data.api.JobCreateRequest import JobCreateRequest
-from ngccli.data.api.NetworkProtocolEnum import NetworkProtocolEnum
 
 
 def check_batch_datasetid(value):
     """Validate the datasetid arg for batch commands.  (dataset_id:mount_point)."""
 
     if not re.match(r"\S+:\S+$", value):
         msg = "Invalid input: '{}'. Valid value is dataset_id:mount_point.".format(value)
```

## basecommand/command/batch.py

```diff
@@ -75,29 +75,29 @@
     CANARY_ENV,
     CONFIG_TYPE,
     EXIT_CODES,
     LONG_MAX_VALUE,
     PRODUCTION_ENV,
     STAGING_ENV,
 )
+from ngcbpc.data.api.JobArrayTypeEnum import JobArrayTypeEnum
+from ngcbpc.data.api.JobFlowTypeEnum import JobFlowTypeEnum
+from ngcbpc.data.api.JobPriorityEnum import JobPriorityEnum
+from ngcbpc.data.api.JobRunPolicy import JobRunPolicy
+from ngcbpc.data.api.JobStatusEnum import JobStatusEnum
+from ngcbpc.data.api.NetworkProtocolEnum import NetworkProtocolEnum
+from ngcbpc.data.api.NetworkTypeEnum import NetworkTypeEnum
 from ngcbpc.errors import InvalidArgumentError, NgcException, ResourceNotFoundException
 from ngcbpc.util.datetime_utils import (
     calculate_date_range,
     dhms_to_isoduration,
     diff_in_minutes,
     human_time,
 )
 from ngcbpc.util.utils import clear, get_columns_help, get_environ_tag
-from ngccli.data.api.JobArrayTypeEnum import JobArrayTypeEnum
-from ngccli.data.api.JobFlowTypeEnum import JobFlowTypeEnum
-from ngccli.data.api.JobPriorityEnum import JobPriorityEnum
-from ngccli.data.api.JobRunPolicy import JobRunPolicy
-from ngccli.data.api.JobStatusEnum import JobStatusEnum
-from ngccli.data.api.NetworkProtocolEnum import NetworkProtocolEnum
-from ngccli.data.api.NetworkTypeEnum import NetworkTypeEnum
 from ngccli.modules.client import Client
 
 logger = logging.getLogger(__name__)
 
 if sys.platform == "win32":
     try:
         from colorama import init
```

## basecommand/command/data.py

```diff
@@ -25,18 +25,18 @@
     CONFIG_TYPE,
     DEFAULT_UPLOAD_THREADS,
     EXIT_CODES,
     LONG_MAX_VALUE,
     MAX_UPLOAD_THREADS,
     STAGING_ENV,
 )
+from ngcbpc.data.api.StorageResourceStatusEnum import StorageResourceStatusEnum
 from ngcbpc.errors import AccessDeniedException, NgcException, ResourceNotFoundException
 from ngcbpc.util.io_utils import question_yes_no
 from ngcbpc.util.utils import get_columns_help, get_environ_tag, share_targets
-from ngccli.data.api.StorageResourceStatusEnum import StorageResourceStatusEnum
 from ngccli.modules.client import Client
 
 DATASET_LIST_PAGE_SIZE = 50
 
 logger = logging.getLogger(__name__)
```

## basecommand/command/datamover/utils.py

```diff
@@ -20,28 +20,28 @@
 from basecommand.api.dataset import DatasetNotFoundHandler
 from basecommand.api.utils import check_existing_workspace_name
 from basecommand.command.workspace import WorkspaceNotFoundHandler
 from basecommand.environ import NGC_CLI_DM_IMAGE, NGC_CLI_DM_LOG_LEVEL
 from basecommand.printer.datamover import DataMoverPrinter
 from ngcbpc.api.authentication import Authentication
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
+from ngcbpc.data.api.DatasetCreateRequest import DatasetCreateRequest
+from ngcbpc.data.api.JobCreateRequest import JobCreateRequest
+from ngcbpc.data.api.JobDatasetMountInfo import JobDatasetMountInfo
+from ngcbpc.data.api.JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from ngcbpc.data.api.SecretSpec import SecretSpec
+from ngcbpc.data.api.WorkspaceCreateRequest import WorkspaceCreateRequest
 from ngcbpc.errors import (
     InvalidArgumentError,
     NgcAPIError,
     NgcException,
     ResourceAlreadyExistsException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.utils import get_environ_tag
-from ngccli.data.api.DatasetCreateRequest import DatasetCreateRequest
-from ngccli.data.api.JobCreateRequest import JobCreateRequest
-from ngccli.data.api.JobDatasetMountInfo import JobDatasetMountInfo
-from ngccli.data.api.JobWorkspaceMountInfo import JobWorkspaceMountInfo
-from ngccli.data.api.SecretSpec import SecretSpec
-from ngccli.data.api.WorkspaceCreateRequest import WorkspaceCreateRequest
 
 DEFAULT_AWS_REGION = "us-east-1"
 
 API_ENDPOINT = {
     PRODUCTION_ENV: "https://api.datamover.ngc.nvidia.com/v1",
     CANARY_ENV: "https://api.can.datamover.ngc.nvidia.com/v1",
     STAGING_ENV: "https://api.stg.datamover.ngc.nvidia.com/v1",
```

## basecommand/command/quickstart_cluster.py

```diff
@@ -23,28 +23,30 @@
     EmptyClusterUpdateError,
     valid_port_mapping,
     VALID_PROTOCOLS,
 )
 from basecommand.command.args_validation import check_secret_pattern
 from basecommand.command.batch import TOPOLOGY_CONSTRAINT_ENUM
 from basecommand.command.quickstart import QuickStartCommand
+from basecommand.data.pym.ClusterInfoResponse import ClusterInfoResponse
+from basecommand.data.pym.ClusterInstanceTypesResponse import (
+    ClusterInstanceTypesResponse,
+)
+from basecommand.data.pym.ClusterRequestStatus import ClusterRequestStatus
 from basecommand.printer.quickstart_cluster import QuickStartClusterPrinter
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.args_validation import (
     check_add_args_columns,
     check_dhms_duration,
     check_key_value_pattern,
     check_valid_columns,
 )
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.errors import ResourceAlreadyExistsException
 from ngcbpc.util.utils import confirm_remove, get_columns_help
-from ngccli.data.pym.ClusterInfoResponse import ClusterInfoResponse
-from ngccli.data.pym.ClusterInstanceTypesResponse import ClusterInstanceTypesResponse
-from ngccli.data.pym.ClusterRequestStatus import ClusterRequestStatus
 from ngccli.modules.client import Client
 
 RW_TRUE = ("true", "t", "yes", "y", "rw", "1")
 RW_FALSE = ("false", "f", "no", "n", "ro", "0")
 
 
 LIST_HELP = "List clusters."
```

## basecommand/command/quickstart_project.py

```diff
@@ -46,14 +46,27 @@
     SYSTEM_PACKAGE_HELP,
     TOPOLOGY_CONSTRAINT_HELP,
     USER_SECRET_HELP,
     WORKER_ENVVAR_HELP,
     WORKSPACE_MOUNT_HELP,
 )
 from basecommand.constants import QUICKSTART_API_VERSION, QUICKSTART_TEMPLATE_TYPE_ENUM
+from basecommand.data.pym.ClusterRequestStatus import ClusterRequestStatus
+from basecommand.data.pym.ProjectCreateRequest import ProjectCreateRequest
+from basecommand.data.pym.ProjectInfoResponse import ProjectInfoResponse
+from basecommand.data.pym.ProjectListResponse import ProjectListResponse
+from basecommand.data.pym.ProjectModifyParams import ProjectModifyParams
+from basecommand.data.pym.ProjectModifyRequest import ProjectModifyRequest
+from basecommand.data.pym.ProjectParams import ProjectParams
+from basecommand.data.pym.ProjectRequestStatus import ProjectRequestStatus
+from basecommand.data.pym.ProjectTemplateInfoResponse import ProjectTemplateInfoResponse
+from basecommand.data.pym.ProjectTemplateListResponse import ProjectTemplateListResponse
+from basecommand.data.pym.ProjectTemplateRequestStatus import (
+    ProjectTemplateRequestStatus,
+)
 from basecommand.printer.quickstart_project import QuickStartProjectPrinter
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.args_validation import (
     check_add_args_columns,
     check_key_value_pattern,
     check_valid_columns,
 )
@@ -61,25 +74,14 @@
 from ngcbpc.errors import (
     NgcAPIError,
     ResourceAlreadyExistsException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.base_utils import get_connection
 from ngcbpc.util.utils import confirm_remove, get_columns_help
-from ngccli.data.pym.ClusterRequestStatus import ClusterRequestStatus
-from ngccli.data.pym.ProjectCreateRequest import ProjectCreateRequest
-from ngccli.data.pym.ProjectInfoResponse import ProjectInfoResponse
-from ngccli.data.pym.ProjectListResponse import ProjectListResponse
-from ngccli.data.pym.ProjectModifyParams import ProjectModifyParams
-from ngccli.data.pym.ProjectModifyRequest import ProjectModifyRequest
-from ngccli.data.pym.ProjectParams import ProjectParams
-from ngccli.data.pym.ProjectRequestStatus import ProjectRequestStatus
-from ngccli.data.pym.ProjectTemplateInfoResponse import ProjectTemplateInfoResponse
-from ngccli.data.pym.ProjectTemplateListResponse import ProjectTemplateListResponse
-from ngccli.data.pym.ProjectTemplateRequestStatus import ProjectTemplateRequestStatus
 from ngccli.modules.client import Client
 from organization.api.users import UsersAPI
 
 
 class QuickStartProjectSubCommand(QuickStartCommand):
     CMD_NAME = "project"
     HELP = "QuickStart Project Commands"
```

## basecommand/command/resource.py

```diff
@@ -32,16 +32,16 @@
     check_add_args_columns,
     check_positive_int_32_bit,
     check_valid_columns,
     check_ymd_hms_datetime,
 )
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CANARY_ENV, CONFIG_TYPE, DISABLE_TYPE
+from ngcbpc.data.api.MeasurementResultListResponse import MeasurementResultListResponse
 from ngcbpc.util.utils import confirm_remove, get_columns_help, get_environ_tag
-from ngccli.data.api.MeasurementResultListResponse import MeasurementResultListResponse
 from ngccli.modules.client import Client
 
 logger = logging.getLogger(__name__)
 
 
 class ResourceCommand(BaseCommand):
```

## basecommand/command/result.py

```diff
@@ -17,16 +17,16 @@
 from basecommand.command.completers import job_id_completer
 from basecommand.constants import STATES_BEFORE_RUNNING
 from basecommand.printer.result import ResultPrinter
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.args_validation import SingleUseAction
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CONFIG_TYPE, LONG_MAX_VALUE, STAGING_ENV
+from ngcbpc.data.api.JobStatusEnum import JobStatusEnum
 from ngcbpc.util.utils import get_environ_tag
-from ngccli.data.api.JobStatusEnum import JobStatusEnum
 from ngccli.modules.client import Client
 
 
 class ResultCommand(BaseCommand, CLICommand):
     CMD_NAME = "result"
     HELP = "Job Result Commands"
     DESC = "Job Result Commands"
```

## basecommand/transfer/upload_manager.py

```diff
@@ -17,14 +17,15 @@
 from basecommand.api.utils import (
     get_storage_resource_owner_id,
     validate_storage_location,
 )
 from basecommand.constants import STORAGE_TYPE_FS, STORAGE_TYPE_OBJECT
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.constants import DEFAULT_UPLOAD_THREADS, GiB, GRPC_SERVER_PORT
+from ngcbpc.data.api.DatasetCreateRequest import DatasetCreateRequest
 from ngcbpc.errors import (
     InsufficientStorageException,
     NgcAPIError,
     NgcException,
     ResourceAlreadyExistsException,
 )
 from ngcbpc.printer.transfer import TransferPrinter
@@ -33,15 +34,14 @@
     generate_file_commit_entries,
     upload_S3_dataset,
     UploadTransferManager,
 )
 from ngcbpc.util.file_utils import human_size, tree_size_and_count
 from ngcbpc.util.io_utils import question_yes_no
 from ngcbpc.util.utils import has_org_role
-from ngccli.data.api.DatasetCreateRequest import DatasetCreateRequest
 
 RESUME_QUESTION = "Do you want to resume previous dataset upload {0}?"
 APPEND_QUESTION = "Do you want to append to dataset {0}?"
 INSUFFICIENT_STORAGE = "You have exceeded the storage quota in given ACE: {0}. Please expand your storage space."
 DATASET_STATE_UNKNOWN = "Dataset: {0} Id: {1} is unknown."
 
 logger = logging.getLogger(__name__)
```

## basecommand/transformer/dataset.py

```diff
@@ -1,15 +1,15 @@
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.api.Dataset import Dataset
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.api.Dataset import Dataset
 
 
 class DatasetSearchTransformer(Dataset, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {
         "aceName": "aceName",
         "uploadStatus": "status",
```

## basecommand/transformer/workspace.py

```diff
@@ -6,16 +6,16 @@
 # product, including all associated intellectual property rights, are and
 # shall remain exclusively with the Company.
 #
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 #
 
+from ngcbpc.data.api.StorageResource import StorageResource
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.api.StorageResource import StorageResource
 
 
 class WorkspaceSearchTransformer(StorageResource, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {"createdByUserName": "creatorUserName", "size": "sizeInBytes"}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {"dateCreated": "createdDate", "dateModified": "updatedDate", "resourceId": "id"}
```

## forge/printer/machine.py

```diff
@@ -61,19 +61,26 @@
             tbl.add_separator_line()
             for mc in output.machineCapabilities:
                 mco = MachineCapabilityOutput(mc)
                 mc_tbl = self.add_sub_table(parent_table=tbl, outline=True, level=1)
                 mc_tbl.set_title("Machine Capability")
                 mc_tbl.add_label_line("Type", mco.type)
                 mc_tbl.add_label_line("Name", mco.name)
-                mc_tbl.add_label_line("Frequency", mco.frequency)
-                mc_tbl.add_label_line("Cores", mco.cores)
-                mc_tbl.add_label_line("Threads", mco.threads)
-                mc_tbl.add_label_line("Capacity", mco.capacity)
-                mc_tbl.add_label_line("Count", mco.count)
+                if mco.frequency:
+                    mc_tbl.add_label_line("Frequency", mco.frequency)
+                if mco.cores:
+                    mc_tbl.add_label_line("Cores", mco.cores)
+                if mco.threads:
+                    mc_tbl.add_label_line("Threads", mco.threads)
+                if mco.capacity:
+                    mc_tbl.add_label_line("Capacity", mco.capacity)
+                if mco.vendor:
+                    mc_tbl.add_label_line("Vendor", mco.vendor)
+                if mco.count:
+                    mc_tbl.add_label_line("Count", mco.count)
                 tbl.add_separator_line()
             for mi in output.machineInterfaces:
                 mio = MachineInterfaceOutput(mi)
                 mi_tbl = self.add_sub_table(parent_table=tbl, outline=True, level=1)
                 mi_tbl.set_title("Machine Interface")
                 mi_tbl.add_label_line("Id", mio.id)
                 mi_tbl.add_label_line("Machine Id", mio.machineId)
@@ -195,14 +202,18 @@
         return self.machine_capability.get("threads", "")
 
     @property
     def capacity(self):
         return self.machine_capability.get("capacity", "")
 
     @property
+    def vendor(self):
+        return self.machine_capability.get("vendor", "")
+
+    @property
     def count(self):
         return self.machine_capability.get("count", "")
 
 
 class MachineInterfaceOutput:
     def __init__(self, machine_interface, config=None):
         self.machine_interface = machine_interface
```

## ngcbpc/api/authentication.py

```diff
@@ -31,30 +31,30 @@
     REQUEST_TIMEOUT_SECONDS,
     SCOPED_KEY_PREFIX,
     SF_DEVICE_ID,
     STAGING_ENV,
 )
 from ngcbpc.data.api.DeviceLoginRequest import DeviceLoginRequest
 from ngcbpc.data.api.DeviceLoginResponse import DeviceLoginResponse
+from ngcbpc.data.uis.SakCallerInfoRequest import SakCallerInfoRequest
+from ngcbpc.data.uis.SakCallerInfoResponse import SakCallerInfoResponse
 from ngcbpc.environ import NGC_CLI_AUTH_URL
 from ngcbpc.errors import (
     AuthenticationException,
     NgcAPIError,
     NgcException,
     PollingTimeoutException,
     ResourceNotFoundException,
 )
 from ngcbpc.expiring_cache import ExpiringCache
 from ngcbpc.tracing import traced_request
 from ngcbpc.util.base_utils import get_nvPrettyPrint
 from ngcbpc.util.file_utils import get_cli_token_file
 from ngcbpc.util.io_utils import mask_string
 from ngcbpc.util.utils import FunctionWrapper, get_environ_tag
-from ngccli.data.uis.SakCallerInfoRequest import SakCallerInfoRequest
-from ngccli.data.uis.SakCallerInfoResponse import SakCallerInfoResponse
 
 TOKEN_EXPIRATION_TIME = 5 * 60
 
 logger = logging.getLogger(__name__)
 
 
 class Authentication:
```

## ngcbpc/constants.py

```diff
@@ -61,14 +61,16 @@
 
 WIN_MAX_PATH_LENGTH = 260
 
 ASYNC_BATCH_SIZE = 500
 SEMAPHORE_VALUE = 16
 RESUME_DOWNLOAD_FILENAME = "files_to_download"
 
+# Should never cache a function when running with pytest.
+LRU_CACHE_SIZE = 0 if "pytest" in sys.modules else 256
 FORMAT_TYPES = ["ascii", "csv", "json"]
 
 # These are non-hidden roles. This is not filtered
 # in help strings to only include whatever roles current user is able to assign.
 # The latest available roles are received when calling `config set`, or when setting new command map.
 # They are then saved onto meta_data file. Those latest roles are used in the help strings for `update-user`
 # and `add-user` subcommands for the Org and Team commands.
@@ -303,15 +305,16 @@
     "sdk": "ngcsdk",
 }
 # Defines mode which code is running under, ex. CLI, SDK
 BUILD_TYPE = "sdk"
 
 # Returns true when running in a frozen executable
 PYINSTALLED = getattr(sys, "frozen", False)
-VERSION_NUM = "f436d5c"
+
+VERSION_NUM = "c960157"
 
 SERVICE_NAME = BUILD_NAME_TO_SERVICE.get(BUILD_TYPE, "ngcdev")
 build_env_string = str(BUILD_ENV)
 if BUILD_ENV == PRODUCTION_ENV:
     build_env_string = ""
 USER_AGENT = f"{SERVICE_NAME}/{VERSION_NUM} {build_env_string} {platform.system().lower()}-{platform.machine()}"
 
@@ -405,7 +408,9 @@
     "met",
     "bionemo-service",
     "iam",
     "nvaie-igx",
     "e2",
     "private-registry",
 ]
+
+UMASK_GROUP_OTHERS_READ_EXECUTE = 0o022
```

## ngcbpc/data/api/Ace.py

 * *Ordering differences only*

```diff
@@ -6,31 +6,31 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .AceStorageInfo import AceStorageInfo
+from .AceHealth import AceHealth
 from .IPAddress import IPAddress
+from .AceType import AceTypeEnum
 from .NetworkTypeEnum import NetworkTypeEnum
-from .AceStorageInfo import AceStorageInfo
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceInstance import AceInstance
+from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceProvider import AceProviderEnum
-from .AceHealth import AceHealth
-from .AceType import AceTypeEnum
 
 # Unused import over optimization prevention
-str(repr(IPAddress))
-str(repr(NetworkTypeEnum))
-str(repr(AceHealth))
-str(repr(AceProviderEnum))
 str(repr(AceTypeEnum))
-str(repr(AceStorageInfo))
 str(repr(AceInstance))
+str(repr(NetworkTypeEnum))
+str(repr(AceStorageInfo))
+str(repr(AceProviderEnum))
+str(repr(IPAddress))
+str(repr(AceHealth))
 str(repr(StorageServiceConfigDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/AceCreateRequest.py

 * *Ordering differences only*

```diff
@@ -7,26 +7,26 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .IPAddress import IPAddress
+from .AceType import AceTypeEnum
 from .NetworkTypeEnum import NetworkTypeEnum
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceInstance import AceInstance
+from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceProvider import AceProviderEnum
-from .AceType import AceTypeEnum
 
 # Unused import over optimization prevention
-str(repr(IPAddress))
-str(repr(NetworkTypeEnum))
-str(repr(AceProviderEnum))
 str(repr(AceTypeEnum))
 str(repr(AceInstance))
+str(repr(NetworkTypeEnum))
+str(repr(AceProviderEnum))
+str(repr(IPAddress))
 str(repr(StorageServiceConfigDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/AceListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .Ace import Ace
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(Ace))
 str(repr(PaginationInfo))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class AceListResponse(object):
```

## ngcbpc/data/api/AceResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Ace import Ace
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Ace))
 str(repr(RequestStatus))
+str(repr(Ace))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class AceResponse(object):
```

## ngcbpc/data/api/AceUpdate.py

 * *Ordering differences only*

```diff
@@ -7,26 +7,26 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .IPAddress import IPAddress
+from .AceType import AceTypeEnum
 from .NetworkTypeEnum import NetworkTypeEnum
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceInstance import AceInstance
+from .StorageServiceConfigDetails import StorageServiceConfigDetails
 from .AceProvider import AceProviderEnum
-from .AceType import AceTypeEnum
 
 # Unused import over optimization prevention
-str(repr(IPAddress))
-str(repr(NetworkTypeEnum))
-str(repr(AceProviderEnum))
 str(repr(AceTypeEnum))
 str(repr(AceInstance))
+str(repr(NetworkTypeEnum))
+str(repr(AceProviderEnum))
+str(repr(IPAddress))
 str(repr(StorageServiceConfigDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/AuditLogsResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .AuditLogs import AuditLogs
 
 # Unused import over optimization prevention
-str(repr(AuditLogs))
 str(repr(RequestStatus))
+str(repr(AuditLogs))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class AuditLogsResponse(object):
```

## ngcbpc/data/api/BannerEvent.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .BannerEventTypeEnum import BannerEventTypeEnum
 from .BannerEventIncident import BannerEventIncident
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
 str(repr(BannerEventIncident))
+str(repr(BannerEventTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEvent(object):
```

## ngcbpc/data/api/BannerEventCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
 from .BannerEventTypeEnum import BannerEventTypeEnum
+from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
 str(repr(BannerEventIncidentSeverityEnum))
+str(repr(BannerEventTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventCreateRequest(object):
```

## ngcbpc/data/api/BannerEventCreateResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .BannerEventTypeEnum import BannerEventTypeEnum
 from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
 from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
-from .BannerEventTypeEnum import BannerEventTypeEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
 str(repr(BannerEventIncidentSeverityEnum))
 str(repr(BannerEventIncidentStatusEnum))
+str(repr(BannerEventTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventCreateResponse(object):
```

## ngcbpc/data/api/BannerEventIncident.py

 * *Ordering differences only*

```diff
@@ -11,17 +11,17 @@
 import re
 from six import string_types
 from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
 from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
 from .BannerEventIncidentMeta import BannerEventIncidentMeta
 
 # Unused import over optimization prevention
-str(repr(BannerEventIncidentMeta))
 str(repr(BannerEventIncidentSeverityEnum))
 str(repr(BannerEventIncidentStatusEnum))
+str(repr(BannerEventIncidentMeta))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventIncident(object):
```

## ngcbpc/data/api/BannerEventListResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .BannerEvent import BannerEvent
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(BannerEvent))
 str(repr(RequestStatus))
+str(repr(BannerEvent))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventListResponse(object):
```

## ngcbpc/data/api/BannerEventResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .BannerEvent import BannerEvent
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(BannerEvent))
 str(repr(RequestStatus))
+str(repr(BannerEvent))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventResponse(object):
```

## ngcbpc/data/api/BannerEventUpdateResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .BannerEventTypeEnum import BannerEventTypeEnum
 from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
 from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
-from .BannerEventTypeEnum import BannerEventTypeEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
 str(repr(BannerEventIncidentSeverityEnum))
 str(repr(BannerEventIncidentStatusEnum))
+str(repr(BannerEventTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BannerEventUpdateResponse(object):
```

## ngcbpc/data/api/Dataset.py

 * *Ordering differences only*

```diff
@@ -6,26 +6,26 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageLocation import StorageLocation
-from .DatasetStatusEnum import DatasetStatusEnum
-from .Team import Team
 from .Organization import Organization
+from .Team import Team
+from .StorageLocation import StorageLocation
 from .DatasetFile import DatasetFile
+from .DatasetStatusEnum import DatasetStatusEnum
 
 # Unused import over optimization prevention
-str(repr(DatasetStatusEnum))
-str(repr(Organization))
 str(repr(StorageLocation))
+str(repr(DatasetStatusEnum))
 str(repr(Team))
 str(repr(DatasetFile))
+str(repr(Organization))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Dataset(object):
```

## ngcbpc/data/api/DatasetListResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .DatasetSimplified import DatasetSimplified
-from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(MetaData))
-str(repr(PaginationInfo))
 str(repr(DatasetSimplified))
+str(repr(MetaData))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DatasetListResponse(object):
```

## ngcbpc/data/api/DatasetResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .Dataset import Dataset
 from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .RequestStatus import RequestStatus
+from .Dataset import Dataset
 
 # Unused import over optimization prevention
+str(repr(Dataset))
 str(repr(MetaData))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
-str(repr(Dataset))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DatasetResponse(object):
```

## ngcbpc/data/api/EarlyAccessOrgCreateRequest.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ProductEnablement import ProductEnablement
 from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
-str(repr(ProductEnablement))
 str(repr(OrgOwner))
+str(repr(ProductEnablement))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class EarlyAccessOrgCreateRequest(object):
```

## ngcbpc/data/api/EulaSubmitResponse.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Eula import Eula
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(Eula))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/GetRepositoryTagVexResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .RepositoryTagVexByDigest import RepositoryTagVexByDigest
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(RepositoryTagVexByDigest))
 str(repr(RequestStatus))
+str(repr(RepositoryTagVexByDigest))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class GetRepositoryTagVexResponse(object):
```

## ngcbpc/data/api/HealthResponse.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Health import Health
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(Health))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/Job.py

 * *Ordering differences only*

```diff
@@ -6,30 +6,30 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .AceProvider import AceProviderEnum
+from .MeasurementSeries import MeasurementSeries
 from .StorageResource import StorageResource
 from .JobPriorityEnum import JobPriorityEnum
-from .MeasurementSeries import MeasurementSeries
 from .JobStatus import JobStatus
-from .AceProvider import AceProviderEnum
 from .JobLabels import JobLabels
 from .JobDefinition import JobDefinition
 
 # Unused import over optimization prevention
 str(repr(JobPriorityEnum))
-str(repr(JobLabels))
+str(repr(StorageResource))
 str(repr(MeasurementSeries))
-str(repr(JobDefinition))
-str(repr(AceProviderEnum))
 str(repr(JobStatus))
-str(repr(StorageResource))
+str(repr(AceProviderEnum))
+str(repr(JobLabels))
+str(repr(JobDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Job(object):
```

## ngcbpc/data/api/JobContainerProperties.py

 * *Ordering differences only*

```diff
@@ -13,18 +13,18 @@
 from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
 from .JobDatasetMountInfo import JobDatasetMountInfo
 from .Env import Env
 from .JobVolumeMount import JobVolumeMount
 from .ContainerResources import ContainerResources
 
 # Unused import over optimization prevention
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
 str(repr(JobDatasetMountInfo))
+str(repr(JobWorkspaceMountInfo))
 str(repr(ContainerResources))
+str(repr(JobVolumeMount))
 str(repr(Env))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/JobCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,52 +6,52 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SecretSpec import SecretSpec
-from .JobInitContainer import JobInitContainer
-from .NetworkTypeEnum import NetworkTypeEnum
+from .ExpTrackingParams import ExpTrackingParams
+from .JobSidecarContainer import JobSidecarContainer
+from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from .JobPortMapping import JobPortMapping
+from .JobRunPolicy import JobRunPolicy
+from .JobResultsetMountInfo import JobResultsetMountInfo
 from .JobPriorityEnum import JobPriorityEnum
+from .SecretSpec import SecretSpec
 from .JobHealthCheck import JobHealthCheck
-from .JobDatasetMountInfo import JobDatasetMountInfo
 from .JobTypeEnum import JobTypeEnum
-from .ExpTrackingParams import ExpTrackingParams
-from .JobVolume import JobVolume
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from .JobDatasetMountInfo import JobDatasetMountInfo
+from .NetworkTypeEnum import NetworkTypeEnum
 from .Env import Env
-from .JobResultsetMountInfo import JobResultsetMountInfo
 from .JobArrayTypeEnum import JobArrayTypeEnum
-from .JobPortMapping import JobPortMapping
-from .JobSidecarContainer import JobSidecarContainer
-from .JobVolumeMount import JobVolumeMount
-from .JobRunPolicy import JobRunPolicy
 from .ContainerResources import ContainerResources
+from .JobVolumeMount import JobVolumeMount
+from .JobVolume import JobVolume
+from .JobInitContainer import JobInitContainer
 
 # Unused import over optimization prevention
-str(repr(JobTypeEnum))
-str(repr(JobVolume))
-str(repr(NetworkTypeEnum))
+str(repr(JobDatasetMountInfo))
+str(repr(ExpTrackingParams))
 str(repr(JobPriorityEnum))
-str(repr(JobPortMapping))
-str(repr(JobVolumeMount))
-str(repr(JobSidecarContainer))
-str(repr(SecretSpec))
+str(repr(JobTypeEnum))
+str(repr(ContainerResources))
 str(repr(JobWorkspaceMountInfo))
-str(repr(JobDatasetMountInfo))
-str(repr(JobResultsetMountInfo))
 str(repr(JobArrayTypeEnum))
+str(repr(JobVolumeMount))
+str(repr(JobRunPolicy))
+str(repr(JobResultsetMountInfo))
+str(repr(NetworkTypeEnum))
+str(repr(Env))
 str(repr(JobHealthCheck))
+str(repr(JobSidecarContainer))
+str(repr(JobVolume))
+str(repr(SecretSpec))
+str(repr(JobPortMapping))
 str(repr(JobInitContainer))
-str(repr(ContainerResources))
-str(repr(Env))
-str(repr(JobRunPolicy))
-str(repr(ExpTrackingParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobCreateRequest(object):
```

## ngcbpc/data/api/JobDefinition.py

 * *Ordering differences only*

```diff
@@ -6,56 +6,56 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Env import Env
-from .JobVolumeMount import JobVolumeMount
-from .JobLabels import JobLabels
-from .ContainerResources import ContainerResources
-from .JobInitContainer import JobInitContainer
-from .NetworkTypeEnum import NetworkTypeEnum
-from .JobDatasetMountInfo import JobDatasetMountInfo
 from .ExpTrackingParams import ExpTrackingParams
-from .JobVolume import JobVolume
-from .JobArrayTypeEnum import JobArrayTypeEnum
-from .JobPortMapping import JobPortMapping
-from .AceInstance import AceInstance
+from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from .JobHealthCheck import JobHealthCheck
+from .JobTypeEnum import JobTypeEnum
+from .NetworkTypeEnum import NetworkTypeEnum
+from .ContainerResources import ContainerResources
+from .JobLabels import JobLabels
 from .JobDataLocation import JobDataLocation
+from .JobSidecarContainer import JobSidecarContainer
+from .JobPortMapping import JobPortMapping
 from .JobPriorityEnum import JobPriorityEnum
-from .JobHealthCheck import JobHealthCheck
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from .JobDatasetMountInfo import JobDatasetMountInfo
+from .JobVolumeMount import JobVolumeMount
+from .AceInstance import AceInstance
 from .JobRunPolicy import JobRunPolicy
 from .SecretSpec import SecretSpec
-from .JobTypeEnum import JobTypeEnum
-from .JobSidecarContainer import JobSidecarContainer
+from .Env import Env
+from .JobArrayTypeEnum import JobArrayTypeEnum
+from .JobVolume import JobVolume
+from .JobInitContainer import JobInitContainer
 
 # Unused import over optimization prevention
-str(repr(JobPriorityEnum))
-str(repr(JobDatasetMountInfo))
-str(repr(JobHealthCheck))
+str(repr(JobWorkspaceMountInfo))
 str(repr(JobSidecarContainer))
-str(repr(JobInitContainer))
 str(repr(JobVolume))
-str(repr(Env))
-str(repr(AceInstance))
-str(repr(JobRunPolicy))
+str(repr(JobInitContainer))
+str(repr(JobDatasetMountInfo))
 str(repr(JobTypeEnum))
-str(repr(NetworkTypeEnum))
-str(repr(JobVolumeMount))
 str(repr(JobArrayTypeEnum))
+str(repr(JobVolumeMount))
 str(repr(JobDataLocation))
 str(repr(JobLabels))
+str(repr(NetworkTypeEnum))
+str(repr(Env))
+str(repr(JobHealthCheck))
 str(repr(JobPortMapping))
-str(repr(SecretSpec))
-str(repr(JobWorkspaceMountInfo))
-str(repr(ContainerResources))
+str(repr(JobPriorityEnum))
 str(repr(ExpTrackingParams))
+str(repr(ContainerResources))
+str(repr(JobRunPolicy))
+str(repr(AceInstance))
+str(repr(SecretSpec))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobDefinition(object):
```

## ngcbpc/data/api/JobInitContainer.py

 * *Ordering differences only*

```diff
@@ -13,18 +13,18 @@
 from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
 from .JobDatasetMountInfo import JobDatasetMountInfo
 from .Env import Env
 from .JobVolumeMount import JobVolumeMount
 from .ContainerResources import ContainerResources
 
 # Unused import over optimization prevention
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
 str(repr(JobDatasetMountInfo))
+str(repr(JobWorkspaceMountInfo))
 str(repr(ContainerResources))
+str(repr(JobVolumeMount))
 str(repr(Env))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/JobLabelResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .JobLabels import JobLabels
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(JobLabels))
 str(repr(RequestStatus))
+str(repr(JobLabels))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobLabelResponse(object):
```

## ngcbpc/data/api/JobLabels.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ReservedLabels import ReservedLabels
-from .UserLabels import UserLabels
 from .SystemLabels import SystemLabels
+from .UserLabels import UserLabels
+from .ReservedLabels import ReservedLabels
 
 # Unused import over optimization prevention
-str(repr(UserLabels))
-str(repr(SystemLabels))
 str(repr(ReservedLabels))
+str(repr(SystemLabels))
+str(repr(UserLabels))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobLabels(object):
```

## ngcbpc/data/api/JobListResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .RequestStatus import RequestStatus
 from .Job import Job
 
 # Unused import over optimization prevention
-str(repr(Job))
 str(repr(MetaData))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(Job))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobListResponse(object):
```

## ngcbpc/data/api/JobNodeCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,26 +6,26 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SCPJobDetails import SCPJobDetails
+from .Secret import Secret
 from .JobPriorityEnum import JobPriorityEnum
 from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
-from .Secret import Secret
 from .JobDefinition import JobDefinition
-from .SCPJobDetails import SCPJobDetails
 
 # Unused import over optimization prevention
 str(repr(JobPriorityEnum))
-str(repr(SCPJobDetails))
-str(repr(JobDefinition))
 str(repr(TargetSystemUserIdentifier))
 str(repr(Secret))
+str(repr(SCPJobDetails))
+str(repr(JobDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobNodeCreateRequest(object):
```

## ngcbpc/data/api/JobResponse.py

 * *Ordering differences only*

```diff
@@ -7,21 +7,21 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .Job import Job
 from .JobStatus import JobStatus
+from .Job import Job
 
 # Unused import over optimization prevention
-str(repr(Job))
 str(repr(JobStatus))
 str(repr(RequestStatus))
+str(repr(Job))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobResponse(object):
```

## ngcbpc/data/api/JobSidecarContainer.py

 * *Ordering differences only*

```diff
@@ -6,30 +6,30 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
+from .JobPortMapping import JobPortMapping
 from .JobHealthCheck import JobHealthCheck
 from .JobDatasetMountInfo import JobDatasetMountInfo
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
 from .Env import Env
-from .JobPortMapping import JobPortMapping
 from .JobVolumeMount import JobVolumeMount
 from .ContainerResources import ContainerResources
 
 # Unused import over optimization prevention
-str(repr(JobPortMapping))
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
 str(repr(JobDatasetMountInfo))
-str(repr(JobHealthCheck))
+str(repr(JobWorkspaceMountInfo))
 str(repr(ContainerResources))
+str(repr(JobVolumeMount))
+str(repr(JobHealthCheck))
 str(repr(Env))
+str(repr(JobPortMapping))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobSidecarContainer(object):
```

## ngcbpc/data/api/JobStatus.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NodeSimplified import NodeSimplified
-from .JobDataLocation import JobDataLocation
 from .JobStatusEnum import JobStatusEnum
+from .NodeSimplified import NodeSimplified
 from .JobPortMapping import JobPortMapping
+from .JobDataLocation import JobDataLocation
 
 # Unused import over optimization prevention
-str(repr(JobDataLocation))
-str(repr(JobStatusEnum))
-str(repr(NodeSimplified))
 str(repr(JobPortMapping))
+str(repr(NodeSimplified))
+str(repr(JobStatusEnum))
+str(repr(JobDataLocation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobStatus(object):
```

## ngcbpc/data/api/JobStatusUpdateRequest.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobPortMapping import JobPortMapping
 from .JobStatus import JobStatus
+from .JobPortMapping import JobPortMapping
 
 # Unused import over optimization prevention
 str(repr(JobStatus))
 str(repr(JobPortMapping))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/JobTemplateResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .JobTemplate import JobTemplate
 
 # Unused import over optimization prevention
-str(repr(JobTemplate))
 str(repr(RequestStatus))
+str(repr(JobTemplate))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobTemplateResponse(object):
```

## ngcbpc/data/api/JobTemplateUpdateRequest.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobDefinition import JobDefinition
 from .JobLabels import JobLabels
+from .JobDefinition import JobDefinition
 
 # Unused import over optimization prevention
-str(repr(JobDefinition))
 str(repr(JobLabels))
+str(repr(JobDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class JobTemplateUpdateRequest(object):
```

## ngcbpc/data/api/MeasurementAlert.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .MeasurementAlertCriteria import MeasurementAlertCriteria
 from .MeasurementType import MeasurementTypeEnum
 from .AlertDeliveryMode import AlertDeliveryMode
-from .MeasurementAlertCriteria import MeasurementAlertCriteria
 
 # Unused import over optimization prevention
 str(repr(MeasurementAlertCriteria))
-str(repr(AlertDeliveryMode))
 str(repr(MeasurementTypeEnum))
+str(repr(AlertDeliveryMode))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementAlert(object):
```

## ngcbpc/data/api/MeasurementAlertCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .MeasurementAlertCriteria import MeasurementAlertCriteria
 from .MeasurementType import MeasurementTypeEnum
 from .AlertDeliveryMode import AlertDeliveryMode
-from .MeasurementAlertCriteria import MeasurementAlertCriteria
 
 # Unused import over optimization prevention
 str(repr(MeasurementAlertCriteria))
-str(repr(AlertDeliveryMode))
 str(repr(MeasurementTypeEnum))
+str(repr(AlertDeliveryMode))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementAlertCreateRequest(object):
```

## ngcbpc/data/api/MeasurementAlertListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .PaginationInfo import PaginationInfo
 from .MeasurementAlert import MeasurementAlert
 from .RequestStatus import RequestStatus
-from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlert))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
+str(repr(MeasurementAlert))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementAlertListResponse(object):
```

## ngcbpc/data/api/MeasurementAlertResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .MeasurementAlert import MeasurementAlert
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlert))
 str(repr(RequestStatus))
+str(repr(MeasurementAlert))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementAlertResponse(object):
```

## ngcbpc/data/api/MeasurementQueryParams.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .MeasurementType import MeasurementTypeEnum
 from .MeasurementAggregationType import MeasurementAggregationTypeEnum
 
 # Unused import over optimization prevention
-str(repr(MeasurementTypeEnum))
 str(repr(MeasurementAggregationTypeEnum))
+str(repr(MeasurementTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementQueryParams(object):
```

## ngcbpc/data/api/MeasurementResultListResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .MeasurementResult import MeasurementResult
 
 # Unused import over optimization prevention
-str(repr(MeasurementResult))
 str(repr(RequestStatus))
+str(repr(MeasurementResult))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementResultListResponse(object):
```

## ngcbpc/data/api/MeasurementSeries.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .MeasurementTag import MeasurementTag
 from .Measurement import Measurement
 
 # Unused import over optimization prevention
-str(repr(MeasurementTag))
 str(repr(Measurement))
+str(repr(MeasurementTag))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeasurementSeries(object):
```

## ngcbpc/data/api/MeteringResultListResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .MeasurementResult import MeasurementResult
 
 # Unused import over optimization prevention
-str(repr(MeasurementResult))
 str(repr(RequestStatus))
+str(repr(MeasurementResult))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class MeteringResultListResponse(object):
```

## ngcbpc/data/api/Node.py

 * *Ordering differences only*

```diff
@@ -11,17 +11,17 @@
 import re
 from six import string_types
 from .WebSocket import WebSocket
 from .NodeType import NodeTypeEnum
 from .NodeStatus import NodeStatus
 
 # Unused import over optimization prevention
-str(repr(WebSocket))
-str(repr(NodeTypeEnum))
 str(repr(NodeStatus))
+str(repr(NodeTypeEnum))
+str(repr(WebSocket))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Node(object):
```

## ngcbpc/data/api/NodeCreateResponse.py

 * *Ordering differences only*

```diff
@@ -11,17 +11,17 @@
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .AceSimplified import AceSimplified
 from .Node import Node
 
 # Unused import over optimization prevention
-str(repr(Node))
 str(repr(RequestStatus))
 str(repr(AceSimplified))
+str(repr(Node))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class NodeCreateResponse(object):
```

## ngcbpc/data/api/NodeListResponse.py

 * *Ordering differences only*

```diff
@@ -6,21 +6,21 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
+from .RequestStatus import RequestStatus
 from .Node import Node
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 str(repr(Node))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/NodeResponse.py

 * *Ordering differences only*

```diff
@@ -11,17 +11,17 @@
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .AceSimplified import AceSimplified
 from .Node import Node
 
 # Unused import over optimization prevention
-str(repr(Node))
 str(repr(RequestStatus))
 str(repr(AceSimplified))
+str(repr(Node))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class NodeResponse(object):
```

## ngcbpc/data/api/OrgCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ProductEnablement import ProductEnablement
 from .ProductSubscription import ProductSubscription
-from .OrgOwner import OrgOwner
 from .OrgType import OrgTypeEnum
+from .ProductEnablement import ProductEnablement
+from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
+str(repr(OrgOwner))
+str(repr(ProductSubscription))
 str(repr(ProductEnablement))
 str(repr(OrgTypeEnum))
-str(repr(ProductSubscription))
-str(repr(OrgOwner))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class OrgCreateRequest(object):
```

## ngcbpc/data/api/OrgCreateResponse.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Organization import Organization
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
 str(repr(Organization))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/OrgListEntitlementResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .OrganizationEntitlement import OrganizationEntitlement
 
 # Unused import over optimization prevention
-str(repr(OrganizationEntitlement))
 str(repr(RequestStatus))
+str(repr(OrganizationEntitlement))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class OrgListEntitlementResponse(object):
```

## ngcbpc/data/api/OrgListResponse.py

 * *Ordering differences only*

```diff
@@ -6,21 +6,21 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .Organization import Organization
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 str(repr(Organization))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/OrgResponse.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Organization import Organization
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
 str(repr(Organization))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/OrgUpdateRequest.py

 * *Ordering differences only*

```diff
@@ -6,30 +6,30 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RepoScanSettings import RepoScanSettings
-from .ProductEnablement import ProductEnablement
 from .OrgType import OrgTypeEnum
-from .ProductSubscription import ProductSubscription
 from .InfinityManagerSettings import InfinityManagerSettings
+from .ProductEnablement import ProductEnablement
 from .AlternateContact import AlternateContact
+from .ProductSubscription import ProductSubscription
+from .RepoScanSettings import RepoScanSettings
 from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
+str(repr(InfinityManagerSettings))
 str(repr(ProductSubscription))
-str(repr(OrgTypeEnum))
 str(repr(ProductEnablement))
-str(repr(RepoScanSettings))
 str(repr(AlternateContact))
+str(repr(RepoScanSettings))
 str(repr(OrgOwner))
-str(repr(InfinityManagerSettings))
+str(repr(OrgTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class OrgUpdateRequest(object):
```

## ngcbpc/data/api/Organization.py

 * *Ordering differences only*

```diff
@@ -6,32 +6,32 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RepoScanSettings import RepoScanSettings
-from .ProductEnablement import ProductEnablement
 from .OrgType import OrgTypeEnum
-from .ProductSubscription import ProductSubscription
 from .InfinityManagerSettings import InfinityManagerSettings
+from .ProductEnablement import ProductEnablement
 from .AlternateContact import AlternateContact
+from .ProductSubscription import ProductSubscription
+from .RepoScanSettings import RepoScanSettings
 from .UsersInfo import UsersInfo
 from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
+str(repr(InfinityManagerSettings))
 str(repr(ProductSubscription))
-str(repr(OrgTypeEnum))
 str(repr(ProductEnablement))
-str(repr(RepoScanSettings))
 str(repr(AlternateContact))
-str(repr(OrgOwner))
-str(repr(InfinityManagerSettings))
+str(repr(RepoScanSettings))
 str(repr(UsersInfo))
+str(repr(OrgOwner))
+str(repr(OrgTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Organization(object):
```

## ngcbpc/data/api/PackageVersionListResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .PackageVersion import PackageVersion
 
 # Unused import over optimization prevention
-str(repr(PackageVersion))
 str(repr(RequestStatus))
+str(repr(PackageVersion))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class PackageVersionListResponse(object):
```

## ngcbpc/data/api/PoolMeasurementQueryParams.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .MeasurementAggregationType import MeasurementAggregationTypeEnum
 from .PoolMeasurementType import PoolMeasurementTypeEnum
 
 # Unused import over optimization prevention
-str(repr(PoolMeasurementTypeEnum))
 str(repr(MeasurementAggregationTypeEnum))
+str(repr(PoolMeasurementTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class PoolMeasurementQueryParams(object):
```

## ngcbpc/data/api/Price.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PriceType import PriceTypeEnum
 from .CurrencyCode import CurrencyCodeEnum
+from .PriceType import PriceTypeEnum
 
 # Unused import over optimization prevention
 str(repr(CurrencyCodeEnum))
 str(repr(PriceTypeEnum))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/ProductEnablement.py

 * *Ordering differences only*

```diff
@@ -6,21 +6,21 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ProductNameEnum import ProductNameEnum
 from .ProductEnablementTypeEnum import ProductEnablementTypeEnum
 from .PurchaseOrder import PurchaseOrder
+from .ProductNameEnum import ProductNameEnum
 
 # Unused import over optimization prevention
-str(repr(ProductEnablementTypeEnum))
 str(repr(ProductNameEnum))
+str(repr(ProductEnablementTypeEnum))
 str(repr(PurchaseOrder))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/ReplicaListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .Replica import Replica
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(PaginationInfo))
 str(repr(Replica))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ReplicaListResponse(object):
```

## ngcbpc/data/api/ReplicaResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .JobStatus import JobStatus
 from .Replica import Replica
+from .JobStatus import JobStatus
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(JobStatus))
-str(repr(Replica))
 str(repr(RequestStatus))
+str(repr(Replica))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ReplicaResponse(object):
```

## ngcbpc/data/api/Resultset.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageLocation import StorageLocation
 from .ResultsetFile import ResultsetFile
+from .StorageLocation import StorageLocation
 
 # Unused import over optimization prevention
-str(repr(ResultsetFile))
 str(repr(StorageLocation))
+str(repr(ResultsetFile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Resultset(object):
```

## ngcbpc/data/api/ResultsetListResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .Resultset import Resultset
 from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .Resultset import Resultset
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(MetaData))
 str(repr(Resultset))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ResultsetListResponse(object):
```

## ngcbpc/data/api/ResultsetResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .Resultset import Resultset
 from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .Resultset import Resultset
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(MetaData))
 str(repr(Resultset))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ResultsetResponse(object):
```

## ngcbpc/data/api/SamlResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .Saml import Saml
 
 # Unused import over optimization prevention
-str(repr(Saml))
 str(repr(RequestStatus))
+str(repr(Saml))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class SamlResponse(object):
```

## ngcbpc/data/api/StorageClusterListResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .StorageServiceConfigDetails import StorageServiceConfigDetails
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
 str(repr(RequestStatus))
+str(repr(StorageServiceConfigDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class StorageClusterListResponse(object):
```

## ngcbpc/data/api/StorageClusterResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .StorageServiceConfigDetails import StorageServiceConfigDetails
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
 str(repr(RequestStatus))
+str(repr(StorageServiceConfigDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class StorageClusterResponse(object):
```

## ngcbpc/data/api/Team.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RepoScanSettings import RepoScanSettings
 from .InfinityManagerSettings import InfinityManagerSettings
 
 # Unused import over optimization prevention
-str(repr(RepoScanSettings))
 str(repr(InfinityManagerSettings))
+str(repr(RepoScanSettings))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class Team(object):
```

## ngcbpc/data/api/TeamCreateResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Team import Team
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Team))
 str(repr(RequestStatus))
+str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class TeamCreateResponse(object):
```

## ngcbpc/data/api/TeamListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .Team import Team
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
-str(repr(Team))
 str(repr(RequestStatus))
+str(repr(Team))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class TeamListResponse(object):
```

## ngcbpc/data/api/TeamResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Team import Team
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Team))
 str(repr(RequestStatus))
+str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class TeamResponse(object):
```

## ngcbpc/data/api/TeamUpdateRequest.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RepoScanSettings import RepoScanSettings
 from .InfinityManagerSettings import InfinityManagerSettings
 
 # Unused import over optimization prevention
-str(repr(RepoScanSettings))
 str(repr(InfinityManagerSettings))
+str(repr(RepoScanSettings))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class TeamUpdateRequest(object):
```

## ngcbpc/data/api/User.py

 * *Ordering differences only*

```diff
@@ -7,16 +7,16 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .UserStorageQuota import UserStorageQuota
-from .UserRole import UserRole
 from .UserMetadata import UserMetadata
+from .UserRole import UserRole
 
 # Unused import over optimization prevention
 str(repr(UserStorageQuota))
 str(repr(UserRole))
 str(repr(UserMetadata))
```

## ngcbpc/data/api/UserCreateRequest.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RoleType import RoleTypeEnum
 from .UserMetadata import UserMetadata
+from .RoleType import RoleTypeEnum
 
 # Unused import over optimization prevention
 str(repr(RoleTypeEnum))
 str(repr(UserMetadata))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/api/UserInvitationListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .UserInvitation import UserInvitation
+from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(UserInvitation))
 str(repr(PaginationInfo))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserInvitationListResponse(object):
```

## ngcbpc/data/api/UserInvitationResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .UserInvitation import UserInvitation
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(UserInvitation))
 str(repr(RequestStatus))
+str(repr(UserInvitation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserInvitationResponse(object):
```

## ngcbpc/data/api/UserListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .User import User
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(PaginationInfo))
 str(repr(User))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserListResponse(object):
```

## ngcbpc/data/api/UserResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .UserRole import UserRole
 from .User import User
+from .UserRole import UserRole
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(UserRole))
 str(repr(User))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserResponse(object):
```

## ngcbpc/data/api/UserRole.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
-from .Team import Team
-from .RoleType import RoleTypeEnum
 from .Organization import Organization
+from .RoleType import RoleTypeEnum
+from .Team import Team
+from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
 
 # Unused import over optimization prevention
-str(repr(TargetSystemUserIdentifier))
 str(repr(RoleTypeEnum))
+str(repr(TargetSystemUserIdentifier))
 str(repr(Team))
 str(repr(Organization))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/api/UserRoleDefinitionsResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .UserRoleDefinition import UserRoleDefinition
 
 # Unused import over optimization prevention
-str(repr(UserRoleDefinition))
 str(repr(RequestStatus))
+str(repr(UserRoleDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserRoleDefinitionsResponse(object):
```

## ngcbpc/data/api/UserStorageQuotaListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .PaginationInfo import PaginationInfo
 from .UserStorageQuota import UserStorageQuota
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(UserStorageQuota))
 str(repr(PaginationInfo))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserStorageQuotaListResponse(object):
```

## ngcbpc/data/api/UserStorageQuotaResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .UserStorageQuota import UserStorageQuota
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(UserStorageQuota))
 str(repr(RequestStatus))
+str(repr(UserStorageQuota))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserStorageQuotaResponse(object):
```

## ngcbpc/data/api/ValidateOrgQueryParams.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ProductSubscription import ProductSubscription
 from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
-str(repr(ProductSubscription))
 str(repr(OrgOwner))
+str(repr(ProductSubscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ValidateOrgQueryParams(object):
```

## ngcbpc/data/api/WebhookListResponse.py

 * *Ordering differences only*

```diff
@@ -6,22 +6,22 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .Webhook import Webhook
 from .PaginationInfo import PaginationInfo
+from .Webhook import Webhook
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RequestStatus))
 str(repr(Webhook))
 str(repr(PaginationInfo))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class WebhookListResponse(object):
```

## ngcbpc/data/api/WebhookResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Webhook import Webhook
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Webhook))
 str(repr(RequestStatus))
+str(repr(Webhook))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class WebhookResponse(object):
```

## ngcbpc/data/api/WorkspaceListResponse.py

 * *Ordering differences only*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .StorageResource import StorageResource
 from .PaginationInfo import PaginationInfo
 from .MetaData import MetaData
+from .RequestStatus import RequestStatus
+from .StorageResource import StorageResource
 
 # Unused import over optimization prevention
 str(repr(MetaData))
 str(repr(StorageResource))
-str(repr(PaginationInfo))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class WorkspaceListResponse(object):
```

## ngcbpc/data/api/WorkspaceResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
 from .StorageResource import StorageResource
 
 # Unused import over optimization prevention
-str(repr(StorageResource))
 str(repr(RequestStatus))
+str(repr(StorageResource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class WorkspaceResponse(object):
```

## ngcbpc/data/search/CountParams.py

 * *Ordering differences only*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CountParamsField import CountParamsField
 from .SearchParamFilter import SearchParamFilter
+from .CountParamsField import CountParamsField
 
 # Unused import over optimization prevention
 str(repr(CountParamsField))
 str(repr(SearchParamFilter))
 
 
 if sys.version_info > (3,):
```

## ngcbpc/data/search/LabelSet.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ResourceTypeEnum import ResourceTypeEnum
 from .LabelValue import LabelValue
 
 # Unused import over optimization prevention
-str(repr(ResourceTypeEnum))
 str(repr(LabelValue))
+str(repr(ResourceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class LabelSet(object):
```

## ngcbpc/data/search/LabelSetCreateRequest.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ResourceTypeEnum import ResourceTypeEnum
 from .LabelValue import LabelValue
 
 # Unused import over optimization prevention
-str(repr(ResourceTypeEnum))
 str(repr(LabelValue))
+str(repr(ResourceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class LabelSetCreateRequest(object):
```

## ngcbpc/data/search/LabelSetResponse.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ResourceTypeEnum import ResourceTypeEnum
 from .LabelValue import LabelValue
 
 # Unused import over optimization prevention
-str(repr(ResourceTypeEnum))
 str(repr(LabelValue))
+str(repr(ResourceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class LabelSetResponse(object):
```

## ngcbpc/data/search/LabelSetUpdateRequest.py

 * *Ordering differences only*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .ResourceTypeEnum import ResourceTypeEnum
 from .LabelValue import LabelValue
 
 # Unused import over optimization prevention
-str(repr(ResourceTypeEnum))
 str(repr(LabelValue))
+str(repr(ResourceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class LabelSetUpdateRequest(object):
```

## ngcbpc/data/search/Resource.py

 * *Ordering differences only*

```diff
@@ -6,23 +6,23 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ResourceAttribute import ResourceAttribute
 from .ResourceTypeEnum import ResourceTypeEnum
 from .AccessTypeEnum import AccessTypeEnum
-from .ResourceAttribute import ResourceAttribute
 from .ResourceLabel import ResourceLabel
 
 # Unused import over optimization prevention
 str(repr(ResourceTypeEnum))
-str(repr(ResourceLabel))
 str(repr(ResourceAttribute))
+str(repr(ResourceLabel))
 str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/data/search/SearchResponse.py

 * *Ordering differences only*

```diff
@@ -6,20 +6,20 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SearchResponseResult import SearchResponseResult
 from .SearchParams import SearchParams
+from .SearchResponseResult import SearchResponseResult
 
 # Unused import over optimization prevention
-str(repr(SearchParams))
 str(repr(SearchResponseResult))
+str(repr(SearchParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class SearchResponse(object):
```

## ngcbpc/data/search/SearchResponseResultResource.py

 * *Ordering differences only*

```diff
@@ -6,23 +6,23 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ResourceAttribute import ResourceAttribute
 from .ResourceTypeEnum import ResourceTypeEnum
 from .AccessTypeEnum import AccessTypeEnum
-from .ResourceAttribute import ResourceAttribute
 from .ResourceLabel import ResourceLabel
 
 # Unused import over optimization prevention
 str(repr(ResourceTypeEnum))
-str(repr(ResourceLabel))
 str(repr(ResourceAttribute))
+str(repr(ResourceLabel))
 str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## ngcbpc/printer/config.py

```diff
@@ -3,16 +3,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
-from ngcbpc.ngcbpc.printer.nvPrettyPrint import GeneralWrapper, NVPrettyPrint
-from ngcbpc.ngcbpc.util.io_utils import mask_string
+from ngcbpc.printer.nvPrettyPrint import GeneralWrapper, NVPrettyPrint
+from ngcbpc.util.io_utils import mask_string
 
 
 class ConfigPrinter(NVPrettyPrint):
     """The printer is responsible for printing config ouput."""
 
     def print_config(self, cfg_list):
         out = []
```

## ngcbpc/tracing.py

```diff
@@ -7,15 +7,14 @@
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 from argparse import Namespace
 import ctypes
 import functools
 import logging
 import re
-import sys
 from urllib.parse import parse_qs, unquote, urlparse
 
 from opentelemetry import propagate, trace
 from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
 from opentelemetry.sdk.resources import Resource, SERVICE_NAME
 from opentelemetry.sdk.trace import TracerProvider
 from opentelemetry.sdk.trace.export import BatchSpanProcessor
@@ -24,14 +23,15 @@
 # pylint: disable=requests-import
 import requests
 
 import ngcbpc.api.configuration
 from ngcbpc.constants import (
     BUILD_TYPE,
     CANARY_ENV,
+    LRU_CACHE_SIZE,
     OPENTELEMETRY_COLLECTOR_HOST_MAPPING,
     OPENTELEMETRY_COLLECTOR_PORT,
     OPENTELEMETRY_COMPONENT_NAME,
     OPENTELEMETRY_PRIVATE_TAGS,
     PRODUCTION_ENV,
 )
 from ngcbpc.environ import NGC_CLI_TRACE_DISABLE
@@ -41,27 +41,28 @@
 from ngcbpc.util.utils import get_dll_path, get_environ_tag, get_system_info
 
 logger = logging.getLogger(__name__)
 ENVIRON = get_environ_tag()
 PROPAGATOR = propagate.get_global_textmap()
 
 
-@functools.lru_cache(maxsize=0 if "pytest" in sys.modules else 256)
+@functools.lru_cache(maxsize=LRU_CACHE_SIZE)
 def get_opentelemetry_token() -> str:
     # should never get here, but just in case.
     if BUILD_TYPE == "sdk":
         return ""
     env = "prod" if ENVIRON in (PRODUCTION_ENV, CANARY_ENV) else "stg"
     ex_lib = ctypes.CDLL(get_dll_path())
     fnc = getattr(ex_lib, env)
     setattr(fnc, "restype", ctypes.c_char_p)
     token = fnc().decode("utf-8")
     return token
 
 
+@functools.lru_cache(maxsize=LRU_CACHE_SIZE)
 def get_opentelemetry_host():
     if ENVIRON in (PRODUCTION_ENV, CANARY_ENV):
         return OPENTELEMETRY_COLLECTOR_HOST_MAPPING["prod"]
     return OPENTELEMETRY_COLLECTOR_HOST_MAPPING["stg"]
 
 
 def is_enabled():
```

## ngcbpc/transfer/async_download.py

```diff
@@ -32,14 +32,15 @@
 from ngcbpc.api.authentication import Authentication
 from ngcbpc.constants import (
     ASYNC_BATCH_SIZE,
     KiB,
     MiB,
     RESUME_DOWNLOAD_FILENAME,
     SEMAPHORE_VALUE,
+    UMASK_GROUP_OTHERS_READ_EXECUTE,
 )
 from ngcbpc.environ import NGC_CLI_DOWNLOAD_RETRIES
 from ngcbpc.errors import (
     DownloadFileSizeMismatch,
     NgcException,
     ResourceNotFoundException,
 )
@@ -48,14 +49,15 @@
 from ngcbpc.transfer import utils as xfer_utils
 from ngcbpc.util.datetime_utils import human_time
 from ngcbpc.util.file_utils import (
     get_incremented_filename,
     mkdir_path,
     TemporaryFileCreator,
 )
+from ngcbpc.util.utils import MaskGranter
 
 ASYNC_CLIENT_ERRORS = (
     aiohttp.ClientResponseError,
     aiohttp.client_exceptions.ClientResponseError,
 )
 ASYNC_DOWNLOAD_ERRORS = ASYNC_CLIENT_ERRORS + (
     aiohttp.ClientConnectionError,
@@ -791,15 +793,16 @@
         elif status >= 300:
             file_size = files_with_size.get(filename, UNKNOWN_FILE_SIZE)
             _update_stats(filename, file_size, False, status)
             return
         direct_url_dict = await dl_url_resp.json()
     direct_url = direct_url_dict["urls"][0]
     logger.debug("File direct URL for file '%s': %s", filename, direct_url)
-    await _direct_download_get_write_file(direct_url, filename, download_dir)
+    with MaskGranter(UMASK_GROUP_OTHERS_READ_EXECUTE):
+        await _direct_download_get_write_file(direct_url, filename, download_dir)
 
 
 async def _direct_download_paginated_files(
     dl_type, name, version, url, download_dir, headers, auth_org=None, auth_team=None
 ):
     trace_config = aiohttp.TraceConfig()
     trace_config.on_request_start.append(on_request_start)
@@ -836,21 +839,22 @@
             urls = resp_dict["urls"]
             logger.debug("\nNumber of URLs for page %s: %s", page_num, len(urls))
             logger.debug("\n\n\n\n")
             logger.debug("Pagination Info: %s", page_info)
             logger.debug("\n\n\n\n")
             filenames = resp_dict["filepath"]
             file_urls = zip(filenames, urls)
-            await xfer_utils.gather(
-                [
-                    _direct_download_get_write_file(file_url, file_name, download_dir)
-                    for file_name, file_url in file_urls
-                ],
-                count=20,
-            )
+            with MaskGranter(UMASK_GROUP_OTHERS_READ_EXECUTE):
+                await xfer_utils.gather(
+                    [
+                        _direct_download_get_write_file(file_url, file_name, download_dir)
+                        for file_name, file_url in file_urls
+                    ],
+                    count=20,
+                )
             page_num += 1
         logger.debug("\nLast page complete")
 
 
 async def _direct_download_files(
     dl_type,
     name,
```

## ngcbpc/util/utils.py

```diff
@@ -26,30 +26,32 @@
 from ngcbpc.api.utils import remove_scheme
 from ngcbpc.constants import (
     BUILD_ENV,
     CANARY_ENV,
     CAS_URL_MAPPING,
     EGX_TO_FLEET_COMMAND_ROLE_MAPPING,
     EXTERNAL_IP_URLS,
+    LRU_CACHE_SIZE,
     PRODUCTION_ENV,
     PYINSTALLED,
     STAGING_ENV,
+    UMASK_GROUP_OTHERS_READ_EXECUTE,
     VERSION_NUM,
 )
 from ngcbpc.environ import get_debug_mapping, NGC_CLI_API_URL
 from ngcbpc.errors import InvalidArgumentError, NgcException
 from ngcbpc.util.io_utils import question_yes_no
 
 BUFFER_SIZE = 65536
 
 logger = logging.getLogger(__name__)
 
 
 # avoid parallel tests hitting cache, breaking tests.
-@lru_cache(maxsize=0 if "pytest" in sys.modules else 256)
+@lru_cache(LRU_CACHE_SIZE)
 def get_dll_path() -> str:
     """There are separate share libraries for each platform/architecture combo.
 
     This function determines the name based on the current system it is running on.
     """
     plat_system = platform.system()
     plat_machine = platform.machine()
@@ -233,15 +235,15 @@
         return self._fn(*self._args, **self._kwargs)
 
     def __repr__(self):
         return "{}(args={}, kwargs={})".format(self._fn, self._args, self._kwargs)
 
 
 class MaskGranter:
-    def __init__(self, new_mask=0o022):
+    def __init__(self, new_mask=UMASK_GROUP_OTHERS_READ_EXECUTE):
         self._new_mask = new_mask
         self._old_mask = None
 
     def __enter__(self):
         self._old_mask = os.umask(self._new_mask)
 
     def __exit__(self, _exc_type, _exc_val, _exc_tb):
```

## ngcsdk/__init__.py

```diff
@@ -27,38 +27,45 @@
     def __init__(self, base_url=None, api_key=None):
         self.api_key = api_key
         self.base_url = base_url
         self.connection = Connection(base_url=base_url)
 
     @property
     def storage(self):
+        """Storage"""
         return StorageAPI(connection=self.connection)
 
     @property
     def users(self):
+        """Users"""
         return UsersAPI(connection=self.connection, api_client=self)
 
     @property
     def basecommand(self):
+        """BaseCommand"""
         return BasecommandAPI(connection=self.connection, api_client=self)
 
     @property
     def organization(self):
+        """Organization"""
         return API(connection=self.connection, api_client=self)
 
     @property
     def registry(self):
+        """Registry"""
         return RegistryAPI(connection=self.connection, api_client=self)
 
     @property
     def cloud_function(self):
+        """Cloud Function"""
         return CloudFunctionAPI(connection=self.connection, api_client=self)
     
     @property
     def forge(self):
+        """Forge"""
         return ForgeAPI(connection=self.connection, api_client=self)
 
 
 class Client(APIClient):
     def __init__(self, api_key=None):
         self.config = Configuration()
         self.config._sdk_configuration.db = True
@@ -103,13 +110,15 @@
 
     def current_config(self):
         """Returns a list of the current configuration. Each item in the returned list is a dictionary with the keys "Key" (name of config attributes),
         "Value" (value of the config attribute), and "Source" (how the config attribute was set: environment variable, globally,)."""
         return self.config.get_current_config_list()
 
     def clear_config(self):
+        """Clear the config."""
         self.config._reset_db_configs()
         self.config.format_type = "json"
         self.config._reset_authentication_tokens_cache()
 
     def clear_cache(self):
+        """Clear the config cache."""
         self.config._reset_authentication_tokens_cache()
```

## nvcf/api/function.py

```diff
@@ -10,15 +10,15 @@
 # provided with the software product.
 #
 from __future__ import annotations
 
 from fnmatch import fnmatch
 import http
 import json
-from typing import Any, Callable, Generator, Optional
+from typing import Any, Callable, Generator, Optional, TYPE_CHECKING, Union
 
 from nvcf.api.gdn_nvcf_grpc_client.grpc_service_pb2 import (  # pylint: disable = no-name-in-module
     ModelInferRequest,
     ModelInferResponse,
     ModelStreamInferResponse,
 )
 from nvcf.api.invocation_handler import (
@@ -34,22 +34,30 @@
     InvalidArgumentError,
     NgcAPIError,
     NgcException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.utils import extra_args, parse_key_value_pairs
 from registry.api.utils import (
-    get_image_service_no_protocol,
+    ChartRegistryTarget,
+    get_nvcr_relative_url,
     ImageRegistryTarget,
     ModelRegistryTarget,
 )
 
+if TYPE_CHECKING:
+    import ngcsdk
+
+    import ngccli.api.apiclient
+
+    Client = Union[ngccli.api.apiclient.APIClient, ngcsdk.APIClient]
+
 
 class FunctionAPI:
-    def __init__(self, connection: Connection = None, api_client=None) -> None:
+    def __init__(self, connection: Connection = None, api_client: Client = None) -> None:
         self.connection = connection
         self.config = Configuration()
         self.client = api_client
 
     @staticmethod
     def _construct_function_ep(
         org_name: str,
@@ -159,73 +167,82 @@
     @extra_args
     def create(
         self,
         name: str,
         inference_url: str,
         health_uri: Optional[str] = None,
         container_image: Optional[str] = None,
+        helm_chart: Optional[str] = None,
+        helm_chart_service: Optional[str] = None,
         models: Optional[list[dict[str, str]]] = None,
         function_id: Optional[str] = None,
         inference_port: Optional[int] = None,
         container_args: Optional[str] = None,
         api_body_format: Optional[str] = None,
-        container_environment_variables: Optional[list[dict[str, str]]] = None,
+        container_environment_variables: Optional[list[str]] = None,
     ) -> dict:
         """Create a function with the input specification provided by input.
 
         Args:
             name: Display name of the function.
 
             inference_url: Endpoint you wish to use to do invocations.
 
             health_uri: Health endpoint for inferencing
 
             container_image: Container Image.
 
-            models: Triton compatible  models.
+            models: Triton compatible models.
+
+            helm_chart: Helm Chart URL.
+
+            helm_chart_service: Only necessary when helm chart is specified.
 
             function_id: If provided, generate another version of the same function.
 
             inference_port: Optional port override which inference is forwarded to.
 
             container_args: Optional list of arguments to provide to container.
 
             api_body_format: Optional body format to use.
 
             container_environment_variables: List of key pair values to pass as variables to container.
-            In form ["key1:value1", "key2:value2"]
+                In form ["key1:value1", "key2:value2"]
 
         Raises:
-            InvalidArgumentError: If neither container image or models is provided, this is thrown.
-            ResourceNotFoundException: If the image or model cannot be found.
+            InvalidArgumentError: If neither container image, models, or helm chart is provided, this is thrown.
+            ResourceNotFoundException: If the image or model or helm chart cannot be found.
 
         Returns:
             dict: Function Response provided by NVCF
         """
         self.config.validate_configuration()
         org_name: str = self.config.org_name
         team_name: Optional[str] = self.config.team_name
         url = self._construct_function_ep(org_name, team_name, function_id)
 
-        if not models and not container_image:
-            raise InvalidArgumentError("Must include either models and/or a container image")
+        if helm_chart and container_image or models:
+            raise InvalidArgumentError("Can not include helm chart with models or image")
+
+        if not models and not container_image and not helm_chart:
+            raise InvalidArgumentError("Must include either models and/or a container image or helm chart")
 
         # validate URL and get the NVCR URL
         if container_image:
             try:
                 self.client.registry.image.info(container_image)
                 ImageRegistryTarget(container_image, org_required=True, tag_required=True)
             except ResourceNotFoundException as e:
                 raise ResourceNotFoundException(
                     f"Container Image {container_image} not found in nvcr, use ngc registry image info"
                     f" {container_image} to validate image information"
                 ) from e
             # Prepend NVCR.io if not included
             if "nvcr.io/" not in container_image:
-                image_repo_url = get_image_service_no_protocol()
+                image_repo_url = get_nvcr_relative_url()
                 container_image = f"{image_repo_url}/{container_image}"
 
         # Validate Models
         function_models = []
         for model in models or []:
             mrt = ModelRegistryTarget(model, version_required=True)
             self.client.registry.model.info(model)
@@ -236,24 +253,35 @@
             function_models.append({"name": mrt.name, "version": mrt.version, "uri": model_uri})
 
         if container_environment_variables:
             container_environment_variables = [
                 {"key": k, "value": v} for k, v in parse_key_value_pairs(container_environment_variables).items()
             ]
 
+        if helm_chart:
+            if not helm_chart_service:
+                raise InvalidArgumentError("Must include a helm chart service name if helm chart is included")
+            # Validate the helm chart existence
+            ChartRegistryTarget(helm_chart, version_required=True)
+            self.client.registry.chart.info_chart_version(helm_chart)
+            chart_url = get_nvcr_relative_url()
+            helm_chart = f"{chart_url}/{helm_chart}"
+
         payload: dict[str, Any] = {
             "name": name,
             "healthUri": health_uri,
             "inferenceUrl": inference_url,
             "inferencePort": inference_port,
             "containerArgs": container_args,
             "containerEnvironment": container_environment_variables,
             "models": function_models,
             "containerImage": container_image,
             "apiBodyFormat": api_body_format,
+            "helmChart": helm_chart,
+            "helmChartServiceName": helm_chart_service,
         }
         payload = {key: val for key, val in payload.items() if val}
 
         response = self.connection.make_api_request(
             "POST",
             url,
             payload=json.dumps(payload),
```

## nvcf/command/function.py

```diff
@@ -118,14 +118,26 @@
             " hyphen, and underscore characters"
         ),
         type=check_function_name,
         required=True,
         default=None,
     )
     @CLICommand.arguments(
+        "--helm-chart",
+        metavar="<org>/[<team>/]<helm-chart>:<tag>",
+        help="Helm Chart in NGC used for deployment.",
+        default=None,
+    )
+    @CLICommand.arguments(
+        "--helm-chart-service",
+        metavar="<helm-chart-service-name>",
+        help="Must be provided if a helm chart function.",
+        default=None,
+    )
+    @CLICommand.arguments(
         "--inference-url",
         metavar="<inference-url>",
         help="Serves as entrypoint for Triton to Custom container",
         type=str,
         required=True,
         default=None,
     )
@@ -186,14 +198,15 @@
     @CLICommand.arguments(
         "target", metavar=FUNCTION_ID_METAVAR, help=FUNCTION_ID_HELP, type=str, default=None, nargs="?"
     )
     @CLICommand.command(
         help="Create a new function or function version if an id is specified",
         description="Create a new function description",
     )
+    @CLICommand.mutex(["container_image", "model"], ["helm_chart", "helm_chart_service"])
     def create(self, args):
         ft: FunctionTarget = FunctionTarget(
             args.target, id_required=False, version_required=False, version_allowed=False
         )
         response = self.client.cloud_function.functions.create(
             function_id=ft.id,
             name=args.name,
@@ -201,14 +214,16 @@
             health_uri=args.health_uri,
             inference_port=args.inference_port,
             container_args=args.container_args,
             container_environment_variables=args.container_environment_variable,
             models=args.model,
             container_image=args.container_image,
             api_body_format=args.api_body_format,
+            helm_chart=args.helm_chart,
+            helm_chart_service=args.helm_chart_service,
         )
         self.printer.print_info(response.get("function", {}))
 
     @CLICommand.arguments(
         "-f",
         "--file",
         metavar="<file>",
```

## nvcf/printer/function_printer.py

```diff
@@ -28,15 +28,15 @@
             output = function_list
         else:
             columns = [
                 ("name", "Name"),
                 ("id", "Id"),
                 ("version", "Version"),
                 ("containerImage", "Container"),
-                ("inferenceUrl", "Inference Path"),
+                ("helmChart", "Helm Chart"),
                 ("status", "Status"),
             ]
             cols, disp = zip(*columns)
             output = [list(disp)]
             for function in function_list:
                 out = FunctionOutput(function)
                 output.append([getattr(out, col, "") for col in cols])
@@ -52,18 +52,25 @@
             tbl.add_separator_line()
             tbl.set_title("Function Information")
             tbl.add_label_line("Name", output.name)
             tbl.add_label_line("Version", output.version)
             tbl.add_label_line("ID", output.id)
             tbl.add_label_line("Status", output.status)
             tbl.add_label_line("Inference URL", output.inferenceUrl)
-            tbl.add_label_line("Container Image", output.containerImage)
+
+            if output.helmChart:
+                tbl.add_label_line("Helm Chart", output.helmChart)
+                tbl.add_label_line("Helm Chart Service Name", output.helmChartServiceName)
+
+            if output.containerImage:
+                tbl.add_label_line("Container Image", output.containerImage)
             if output.models:
                 model_output = ", ".join([f"{model.get('name')}/{model.get('version')}" for model in output.models])
                 tbl.add_label_line("Models", model_output)
+
             tbl.add_separator_line()
             tbl.print()
 
 
 class FunctionOutput:
     def __init__(self, function):
         self.function = function
@@ -73,14 +80,22 @@
         return self.function.get("activeInstances", None)
 
     @property
     def containerImage(self):
         return self.function.get("containerImage", "")
 
     @property
+    def helmChart(self):
+        return self.function.get("helmChart", "")
+
+    @property
+    def helmChartServiceName(self):
+        return self.function.get("helmChartServiceName", "")
+
+    @property
     def gpus(self):
         return self.function.get("gpus", "")
 
     @property
     def id(self):
         return self.function.get("id", "")
```

## organization/api/alert.py

```diff
@@ -14,16 +14,16 @@
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 import posixpath
 
-from ngccli.data.api.BannerEventListResponse import BannerEventListResponse
-from ngccli.data.api.BannerEventResponse import BannerEventResponse
+from ngcbpc.data.api.BannerEventListResponse import BannerEventListResponse
+from ngcbpc.data.api.BannerEventResponse import BannerEventResponse
 
 
 class AlertAPI:
     def __init__(self, connection, alert_connection=None):
         self.connection = connection
         self.alert_connection = alert_connection
```

## organization/api/audit.py

```diff
@@ -21,19 +21,19 @@
     TimeElapsedColumn,
     TransferSpeedColumn,
 )
 from rich.style import Style
 from rich.table import Column
 
 from ngcbpc.constants import API_VERSION, REQUEST_TIMEOUT_SECONDS
+from ngcbpc.data.api.AuditLogsPresignedUrlResponse import AuditLogsPresignedUrlResponse
+from ngcbpc.data.api.AuditLogsRequest import AuditLogsRequest
+from ngcbpc.data.api.AuditLogsResponse import AuditLogsResponse
 from ngcbpc.errors import NgcException
 from ngcbpc.util.datetime_utils import calculate_date_range
-from ngccli.data.api.AuditLogsPresignedUrlResponse import AuditLogsPresignedUrlResponse
-from ngccli.data.api.AuditLogsRequest import AuditLogsRequest
-from ngccli.data.api.AuditLogsResponse import AuditLogsResponse
 
 
 class AuditAPI:
     """Audit Logs API"""
 
     def __init__(self, connection):
         self.connection = connection
```

## organization/api/orgs.py

```diff
@@ -9,17 +9,17 @@
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 
 from typing import Optional
 
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import API_VERSION, PAGE_SIZE
+from ngcbpc.data.uis.Organization import Organization
+from ngcbpc.data.uis.OrgListResponse import OrgListResponse
 from ngcbpc.util.utils import extra_args
-from ngccli.data.uis.Organization import Organization
-from ngccli.data.uis.OrgListResponse import OrgListResponse
 
 
 class OrgAPI:
     def __init__(self, connection):
         self.connection = connection
 
     def get_org_list(self):
```

## organization/api/secrets.py

```diff
@@ -20,18 +20,18 @@
 
 from ngcbpc.command.args_validation import (
     check_key_value_pattern,
     check_secret_name_pattern,
 )
 from ngcbpc.constants import SECRET_API_VERSION
 from ngcbpc.util.utils import extra_args, parse_key_value_pairs
-from ngccli.data.sms.SecretCreateRequest import KV, SecretCreateRequest
-from ngccli.data.sms.SecretGetResponse import SecretGetResponse
-from ngccli.data.sms.SecretModifyRequest import SecretModifyRequest
-from ngccli.data.sms.SecretSuccessResponse import SecretSuccessResponse
+from organization.data.sms.SecretCreateRequest import KV, SecretCreateRequest
+from organization.data.sms.SecretGetResponse import SecretGetResponse
+from organization.data.sms.SecretModifyRequest import SecretModifyRequest
+from organization.data.sms.SecretSuccessResponse import SecretSuccessResponse
 
 
 class SecretsAPI:
     def __init__(self, connection):
         self.connection = connection
 
     @staticmethod
```

## organization/api/subscription.py

```diff
@@ -18,27 +18,27 @@
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 import json
 import logging
 import posixpath
 from typing import Optional
 
 from ngcbpc.util.utils import extra_args
-from ngccli.data.subscription_management_service.CreateOrderResponse import (
+from organization.data.subscription_management_service.CreateOrderResponse import (
     CreateOrderResponse,
 )
-from ngccli.data.subscription_management_service.ListSubscriptionsResponse import (
+from organization.data.subscription_management_service.ListSubscriptionsResponse import (
     ListSubscriptionsResponse,
 )
-from ngccli.data.subscription_management_service.PreviewOrderResponse import (
+from organization.data.subscription_management_service.PreviewOrderResponse import (
     PreviewOrderResponse,
 )
-from ngccli.data.subscription_management_service.RenewSubscriptionResponse import (
+from organization.data.subscription_management_service.RenewSubscriptionResponse import (
     RenewSubscriptionResponse,
 )
-from ngccli.data.subscription_management_service.SubscriptionResponse import (
+from organization.data.subscription_management_service.SubscriptionResponse import (
     SubscriptionResponse,
 )
 from organization.printer.org_team_user import OrgTeamUserPrinter
 
 logger = logging.getLogger(__name__)
```

## organization/api/teams.py

```diff
@@ -9,20 +9,20 @@
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 
 from typing import Optional
 
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import API_VERSION, PAGE_SIZE
+from ngcbpc.data.api.TeamCreateRequest import TeamCreateRequest
+from ngcbpc.data.api.TeamCreateResponse import TeamCreateResponse
+from ngcbpc.data.api.TeamListResponse import TeamListResponse
+from ngcbpc.data.api.TeamResponse import TeamResponse
+from ngcbpc.data.api.TeamUpdateRequest import TeamUpdateRequest
 from ngcbpc.util.utils import extra_args
-from ngccli.data.api.TeamCreateRequest import TeamCreateRequest
-from ngccli.data.api.TeamCreateResponse import TeamCreateResponse
-from ngccli.data.api.TeamListResponse import TeamListResponse
-from ngccli.data.api.TeamResponse import TeamResponse
-from ngccli.data.api.TeamUpdateRequest import TeamUpdateRequest
 
 
 class TeamAPI:
     def __init__(self, connection):
         self.connection = connection
 
     def get_teams(self, org_name: str):
```

## organization/api/users.py

```diff
@@ -13,28 +13,28 @@
 import logging
 from typing import List, Optional
 from urllib.parse import quote
 
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.command.args_validation import check_if_email_used, email_id_used
 from ngcbpc.constants import API_VERSION, SCOPED_KEY_PREFIX
+from ngcbpc.data.api.UserCreateRequest import UserCreateRequest
+from ngcbpc.data.api.UserInvitationListResponse import UserInvitationListResponse
+from ngcbpc.data.api.UserListResponse import UserListResponse
+from ngcbpc.data.api.UserResponse import UserResponse
+from ngcbpc.data.api.UserStorageQuotaListResponse import UserStorageQuotaListResponse
+from ngcbpc.data.api.UserStorageQuotaResponse import UserStorageQuotaResponse
+from ngcbpc.data.api.UserUpdateRequest import UserUpdateRequest
 from ngcbpc.errors import (
     InvalidArgumentError,
     NgcAPIError,
     NgcException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.utils import extra_args
-from ngccli.data.api.UserCreateRequest import UserCreateRequest
-from ngccli.data.api.UserInvitationListResponse import UserInvitationListResponse
-from ngccli.data.api.UserListResponse import UserListResponse
-from ngccli.data.api.UserResponse import UserResponse
-from ngccli.data.api.UserStorageQuotaListResponse import UserStorageQuotaListResponse
-from ngccli.data.api.UserStorageQuotaResponse import UserStorageQuotaResponse
-from ngccli.data.api.UserUpdateRequest import UserUpdateRequest
 
 PAGE_SIZE = 100
 logger = logging.getLogger(__name__)
 
 
 class UsersAPI:
     def __init__(self, connection, api_client=None):
```

## organization/command/alert.py

```diff
@@ -20,21 +20,21 @@
 from ngcbpc.command.args_validation import (
     check_add_args_columns,
     check_valid_columns,
     check_ymd_hms_datetime,
 )
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CONFIG_TYPE, DISABLE_TYPE, STAGING_ENV
+from ngcbpc.data.api.BannerEventIncidentSeverityEnum import (
+    BannerEventIncidentSeverityEnum,
+)
+from ngcbpc.data.api.BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
 from ngcbpc.errors import NgcException, ResourceNotFoundException
 from ngcbpc.util.datetime_utils import calculate_date_range
 from ngcbpc.util.utils import get_columns_help, get_environ_tag
-from ngccli.data.api.BannerEventIncidentSeverityEnum import (
-    BannerEventIncidentSeverityEnum,
-)
-from ngccli.data.api.BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
 from ngccli.modules.client import Client
 from organization.environ import NGC_CLI_ALERT_ENABLE
 from organization.printer.alert import AlertPrinter
 
 ALERT_TYPE = CONFIG_TYPE if (get_environ_tag() <= STAGING_ENV and NGC_CLI_ALERT_ENABLE) else DISABLE_TYPE
 
 SEVERITY_METAVAR = "<severity>"
```

## organization/command/subscription.py

```diff
@@ -20,19 +20,19 @@
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.args_validation import check_valid_columns
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CONFIG_TYPE, DISABLE_TYPE, ENABLE_TYPE, STAGING_ENV
 from ngcbpc.errors import ResourceNotFoundException
 from ngcbpc.util.io_utils import question_yes_no
 from ngcbpc.util.utils import get_columns_help, get_environ_tag
-from ngccli.data.subscription_management_service.SubscriptionStatusEnum import (
-    SubscriptionStatusEnum,
-)
 from ngccli.modules.client import Client
 from organization.command.org import OrgCommand
+from organization.data.subscription_management_service.SubscriptionStatusEnum import (
+    SubscriptionStatusEnum,
+)
 from organization.printer.org_team_user import OrgTeamUserPrinter
 
 UCP_DEPENDENT = DISABLE_TYPE if get_environ_tag() >= STAGING_ENV else CONFIG_TYPE
 
 
 class SubscriptionCommand(OrgCommand):
     CMD_NAME = "subscription"
```

## organization/printer/org_team_user.py

```diff
@@ -24,15 +24,15 @@
 from ngcbpc.printer.nvPrettyPrint import (
     format_date,
     generate_columns_list,
     NVPrettyPrint,
 )
 from ngcbpc.util.file_utils import human_size
 from ngcbpc.util.utils import convert_EGX_roles
-from ngccli.data.subscription_management_service.LineItem import LineItem
+from organization.data.subscription_management_service.LineItem import LineItem
 
 
 def format_items(target):
     """Custom dict items format to ["key [value]",]"""
     return ["{} [{}]".format(k, v) for (k, v) in target]
```

## registry/api/chart.py

```diff
@@ -14,38 +14,38 @@
 import posixpath
 import tarfile
 from typing import ByteString, List, Optional, Union
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.connection import Connection
 from ngcbpc.api.pagination import pagination_helper_use_page_reference
+from ngcbpc.data.model.Artifact import Artifact
+from ngcbpc.data.model.ArtifactCreateRequest import ArtifactCreateRequest
+from ngcbpc.data.model.ArtifactResponse import ArtifactResponse
+from ngcbpc.data.model.ArtifactUpdateRequest import ArtifactUpdateRequest
+from ngcbpc.data.model.ArtifactVersion import ArtifactVersion
+from ngcbpc.data.model.ArtifactVersionFileListResponse import (
+    ArtifactVersionFileListResponse,
+)
+from ngcbpc.data.model.ArtifactVersionListResponse import ArtifactVersionListResponse
+from ngcbpc.data.model.ArtifactVersionResponse import ArtifactVersionResponse
+from ngcbpc.data.model.File import File
 from ngcbpc.errors import (
     AuthenticationException,
     NgcException,
     ResourceAlreadyExistsException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.file_utils import (
     get_file_contents,
     get_incremented_filename,
     helm_format,
     human_size,
 )
 from ngcbpc.util.utils import extra_args
-from ngccli.data.model.Artifact import Artifact
-from ngccli.data.model.ArtifactCreateRequest import ArtifactCreateRequest
-from ngccli.data.model.ArtifactResponse import ArtifactResponse
-from ngccli.data.model.ArtifactUpdateRequest import ArtifactUpdateRequest
-from ngccli.data.model.ArtifactVersion import ArtifactVersion
-from ngccli.data.model.ArtifactVersionFileListResponse import (
-    ArtifactVersionFileListResponse,
-)
-from ngccli.data.model.ArtifactVersionListResponse import ArtifactVersionListResponse
-from ngccli.data.model.ArtifactVersionResponse import ArtifactVersionResponse
-from ngccli.data.model.File import File
 from registry.api.utils import ChartRegistryTarget, get_label_set_labels
 from registry.errors import ChartAlreadyExistsException, ChartNotFoundException
 from registry.transformer.chart import ChartSearchTransformer
 
 PAGE_SIZE = 1000
 
 
@@ -525,15 +525,15 @@
                 raise NgcException(f"The path: '{abs_path}' does not exist.")
 
         chart_create_request = ArtifactCreateRequest(
             {
                 # should we limit overview_file size or reach up to size?
                 "description": get_file_contents(overview_filepath, "overview_file"),
                 "displayName": display_name,
-                "labelsV2": get_label_set_labels(self.api_client, "HELM_CHART", label_sets, labels),
+                "labelsV2": get_label_set_labels(self.api_client.registry.label_set, "HELM_CHART", label_sets, labels),
                 "logo": logo,
                 "name": crt.name,
                 "publisher": publisher,
                 "builtBy": built_by,
                 "shortDescription": short_description,
             }
         )
@@ -591,15 +591,15 @@
             raise ArgumentTypeError("No arguments provided for chart update; there is nothing to do.")
 
         chart_update_request = ArtifactUpdateRequest(
             {
                 # should we limit overview_file size or reach up to size?
                 "description": get_file_contents(overview_filepath, "overview_file"),
                 "displayName": display_name,
-                "labelsV2": get_label_set_labels(self.api_client, "HELM_CHART", label_sets, labels),
+                "labelsV2": get_label_set_labels(self.api_client.registry.label_set, "HELM_CHART", label_sets, labels),
                 "logo": logo,
                 "name": crt.name,
                 "publisher": publisher,
                 "builtBy": built_by,
                 "shortDescription": short_description,
             }
         )
```

## registry/api/collection.py

```diff
@@ -10,17 +10,17 @@
 """API interface for Collections"""
 import asyncio
 import sys
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
+from ngcbpc.data.model.RequestStatus import RequestStatus
 from ngcbpc.errors import NgcAPIError
 from ngcbpc.transfer import utils as xfer_utils
-from ngccli.data.model.RequestStatus import RequestStatus
 from registry.api.utils import get_environ_tag
 from registry.constants import CollectionArtifacts, MODEL_SERVICE_URL_MAPPING
 
 environ_tag = get_environ_tag()
 env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(environ_tag)
 ENDPOINT_VERSION = "v1" if Configuration().base_url == MODEL_SERVICE_URL_MAPPING[env] else "v2"
```

## registry/api/csp.py

```diff
@@ -12,22 +12,22 @@
 
 #
 import json
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
-from ngcbpc.errors import ResourceNotFoundException
-from ngccli.data.model.CloudServiceProvider import CloudServiceProvider
-from ngccli.data.model.CloudServiceProviderListResponse import (
+from ngcbpc.data.model.CloudServiceProvider import CloudServiceProvider
+from ngcbpc.data.model.CloudServiceProviderListResponse import (
     CloudServiceProviderListResponse,
 )
-from ngccli.data.model.DeploymentParameters import DeploymentParameters
-from ngccli.data.model.DeploymentParametersMeta import DeploymentParametersMeta
-from ngccli.data.model.Response import Response
+from ngcbpc.data.model.DeploymentParameters import DeploymentParameters
+from ngcbpc.data.model.DeploymentParametersMeta import DeploymentParametersMeta
+from ngcbpc.data.model.Response import Response
+from ngcbpc.errors import ResourceNotFoundException
 from registry.api.utils import get_environ_tag
 from registry.constants import MODEL_SERVICE_URL_MAPPING
 from registry.errors import CSPNotFoundException
 
 environ_tag = get_environ_tag()
 env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(environ_tag)
 ENDPOINT_VERSION = "v1" if Configuration().base_url == MODEL_SERVICE_URL_MAPPING[env] else "v2"
```

## registry/api/deploy.py

```diff
@@ -10,20 +10,20 @@
 # provided with the software product.
 #
 
 #
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.pagination import pagination_helper
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
-from ngccli.data.model.DeploymentParameters import DeploymentParameters
-from ngccli.data.model.DeploymentParametersListResponse import (
+from ngcbpc.data.model.DeploymentParameters import DeploymentParameters
+from ngcbpc.data.model.DeploymentParametersListResponse import (
     DeploymentParametersListResponse,
 )
-from ngccli.data.model.DeploymentUrlResponse import DeploymentUrlResponse
-from ngccli.data.model.Response import Response
+from ngcbpc.data.model.DeploymentUrlResponse import DeploymentUrlResponse
+from ngcbpc.data.model.Response import Response
 from registry.api.utils import get_environ_tag
 from registry.constants import MODEL_SERVICE_URL_MAPPING
 
 environ_tag = get_environ_tag()
 env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(environ_tag)
 ENDPOINT_VERSION = "v1" if Configuration().base_url == MODEL_SERVICE_URL_MAPPING[env] else "v2"
```

## registry/api/image.py

```diff
@@ -16,41 +16,43 @@
 
 import docker
 from docker.errors import APIError, ImageNotFound, NotFound
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.connection import Connection
 from ngcbpc.api.pagination import pagination_helper
+from ngcbpc.data.registry.GetManifestByTagResponse import GetManifestByTagResponse
+from ngcbpc.data.registry.ImageArchitectureVariant import ImageArchitectureVariant
+from ngcbpc.data.registry.ImageScanDetails import ImageScanDetails
+from ngcbpc.data.registry.Repository import Repository
+from ngcbpc.data.registry.RepositoryCreateRequest import RepositoryCreateRequest
+from ngcbpc.data.registry.RepositoryImageDetailsList import RepositoryImageDetailsList
+from ngcbpc.data.registry.RepositoryInfoUpdateRequest import RepositoryInfoUpdateRequest
+from ngcbpc.data.registry.ScanIssue import ScanIssue
 from ngcbpc.errors import (
     AccessDeniedException,
     AuthenticationException,
+    InvalidArgumentError,
     NgcAPIError,
     NgcException,
     ResourceAlreadyExistsException,
     ResourceNotFoundException,
 )
 from ngcbpc.util.io_utils import question_yes_no
 from ngcbpc.util.utils import contains_glob, extra_args, format_org_team
-from ngccli.data.publishing.PublishingRequest import PublishingRequest
-from ngccli.data.publishing.Response import Response
-from ngccli.data.registry.GetManifestByTagResponse import GetManifestByTagResponse
-from ngccli.data.registry.ImageArchitectureVariant import ImageArchitectureVariant
-from ngccli.data.registry.ImageScanDetails import ImageScanDetails
-from ngccli.data.registry.Repository import Repository
-from ngccli.data.registry.RepositoryCreateRequest import RepositoryCreateRequest
-from ngccli.data.registry.RepositoryImageDetailsList import RepositoryImageDetailsList
-from ngccli.data.registry.RepositoryInfoUpdateRequest import RepositoryInfoUpdateRequest
-from ngccli.data.registry.ScanIssue import ScanIssue
 from registry.api.dockerwrappers import RegistryWrapper
 from registry.api.search import RepositorySearchTransformer
 from registry.api.utils import (
     get_label_set_labels,
     get_registry_url,
     ImageRegistryTarget,
 )
+from registry.data.publishing.Artifact import Artifact
+from registry.data.publishing.PublishingRequest import PublishingRequest
+from registry.data.publishing.Response import Response
 from registry.errors import ImageTagNotFound
 from registry.printer.image import ImagePrinter
 
 IMAGE_METAVAR_TAGS = "<org>/[<team>/]<image>[:<tags>]"
 
 
 logger = logging.getLogger(__name__)
@@ -507,14 +509,210 @@
             raise NgcAPIError(err.explanation or str(err)) from None
         except NgcException:
             raise
         except Exception as exc:
             raise NgcException(exc) from None
         return None
 
+    def copy_metadata(self, target, source, output=False) -> None:
+        self.config.validate_configuration(guest_mode_allowed=False)
+        request = PublishingRequest()
+        request.artifactType = self.resource_type
+        request.sourceArtifact = self._create_publish_request_artifact(source, include_version=False, output=output)
+        request.targetArtifact = self._create_publish_request_artifact(target, include_version=False, output=output)
+
+        return self.api_client.registry.publish.copy_metadata_artifact(
+            request, "containers", self.config.org_name, self.config.team_name
+        )
+
+    def copy_version(self, target, source, output=False) -> None:
+        self.config.validate_configuration(guest_mode_allowed=False)
+        request = PublishingRequest()
+        request.artifactType = self.resource_type
+        request.sourceArtifact = self._create_publish_request_artifact(source, output=output)
+        request.targetArtifact = self._create_publish_request_artifact(
+            target, implied_version=request.sourceArtifact.version, output=output
+        )
+
+        return self.api_client.registry.publish.copy_container_version_artifact(
+            request, self.config.org_name, self.config.team_name
+        )
+
+    def update_visibility(self, target, allow_guest, discoverable, public, output=False) -> None:
+        self.config.validate_configuration(guest_mode_allowed=False)
+
+        request = PublishingRequest()
+        request.artifactType = self.resource_type
+        request.targetArtifact = self._create_publish_request_artifact(target, output=output)
+
+        request.publishToPublic = public
+        request.publishWithGuestAccess = allow_guest
+        request.publishAsListedToPublic = discoverable
+
+        return self.api_client.registry.publish.update_visibility(
+            request, "containers", self.config.org_name, self.config.team_name
+        )
+
+    def publish_artifact(
+        self,
+        target,
+        source,
+        allow_guest,
+        discoverable,
+        public,
+        sign,
+        access_type=None,
+        product_names=None,
+        output=False,
+    ):
+        self.config.validate_configuration(guest_mode_allowed=False)
+
+        request = PublishingRequest()
+        request.artifactType = self.resource_type
+
+        # visibilities
+        request.publishToPublic = public
+        request.publishWithGuestAccess = allow_guest
+        request.publishAsListedToPublic = discoverable
+
+        # under product
+        request.accessType = access_type
+        request.productNames = product_names
+
+        # signing
+        request.sign = sign
+
+        # versions, image source and target must contain versions
+        # user source version(implied) if target version not specified
+        version = None
+        if source:
+            request.sourceArtifact = self._create_publish_request_artifact(source, output=output)
+            version = request.sourceArtifact.version
+        request.targetArtifact = self._create_publish_request_artifact(target, implied_version=version, output=output)
+
+        self.api_client.registry.publish.publish_artifact(
+            request, "containers", self.config.org_name, self.config.team_name
+        )
+
+    def _validate_publish_arguments(
+        self,
+        target,
+        source,
+        metadata_only=False,
+        version_only=False,
+        visibility_only=False,
+        allow_guest: Optional[bool] = False,
+        discoverable: Optional[bool] = False,
+        public: Optional[bool] = False,
+        sign: Optional[bool] = False,  # pylint: disable=unused-argument
+        access_type: Optional[str] = None,
+        product_names: Optional[List[str]] = None,
+    ):
+        self.api_client.registry.publish.validate_args(
+            target,
+            source,
+            metadata_only,
+            version_only,
+            visibility_only,
+            allow_guest,
+            discoverable,
+            public,
+            sign,
+            access_type,
+            product_names,
+        )
+        # below requires source
+        # publish to public(legacy publish, no accesstype or productnames)
+        if (
+            not (access_type and product_names)  # non unified catalog
+            and not (visibility_only or metadata_only or version_only)  # intention is to publish
+            and not (source and target)
+        ):
+            raise InvalidArgumentError(
+                "You must specify `source` and `target` argument when making a publishing request"
+            )
+
+    @extra_args
+    def publish(
+        self,
+        target,
+        source: Optional[str] = None,
+        metadata_only=False,
+        version_only=False,
+        visibility_only=False,
+        allow_guest: Optional[bool] = False,
+        discoverable: Optional[bool] = False,
+        public: Optional[bool] = False,
+        sign: Optional[bool] = False,
+        access_type: Optional[str] = None,
+        product_names: Optional[List[str]] = None,
+        output=False,
+    ):
+        """Publishes a docker image with various options for metadata, versioning, and visibility.
+
+        This method manages the publication of docker images to a repository, handling
+        different aspects of the publication such as metadata only, version only, and
+        visibility adjustments. It validates the combination of arguments provided
+        and processes the publication accordingly.
+
+        Args:
+            target: The target repository for the docker image.
+            source: The identifier of the source docker image.
+            metadata_only: If True, only the metadata of the source will be copied to the target.
+            version_only: If True, only the version of the source will be copied to the target.
+            visibility_only: If True, updates the visibility settings of the target.
+            allow_guest: If True, allows guest access to the target.
+            discoverable: If True, makes the target discoverable.
+            public: If True, makes the target publicly available.
+            sign: If True, signs the target.
+            access_type: Specifies the type of access for the target.
+            product_names: List of product names associated with the target.
+            output: If True, output details of the operation.
+
+        Returns:
+            None
+
+        Raises:
+            InvalidArgumentError: If the arguments provided are invalid or insufficient
+            for the requested operation. Specific conditions that raise this error include:
+                - Specifying one of 'product-name' or 'access-type' without the other.
+                - Specifying more than one of 'metadata_only', 'version_only', or 'visibility_only'.
+                - Specifying 'source' and 'visibility_only' together.
+                - Omitting 'source' when required by 'metadata_only', 'version_only', or general publication.
+                - Attempting to set 'discoverable' without 'public' or 'allow_guest' being True.
+        """
+
+        self._validate_publish_arguments(
+            target,
+            source,
+            metadata_only,
+            version_only,
+            visibility_only,
+            allow_guest,
+            discoverable,
+            public,
+            sign,
+            access_type,
+            product_names,
+        )
+
+        if metadata_only:
+            self.copy_metadata(target, source, output=output)
+        elif version_only:
+            self.copy_version(target, source, output=output)
+        elif visibility_only:
+            self.update_visibility(target, allow_guest, discoverable, public, output=output)
+        else:
+            self.publish_artifact(
+                target, source, allow_guest, discoverable, public, sign, access_type, product_names, output=output
+            )
+        if output:
+            self.printer.print_ok(f"Successfully published {target}")
+        logger.debug("Successfully published %s", target)
+
     # End of Public SDK Functions
     def _digest_for_tag(self, org, team, name, tag):
         """Returns a dict in the format of {architecture: sha256_digest}"""
         try:
             tag_digests = self.get_digest_for_tag(org, team, name, tag)
         except ImageTagNotFound:
             self.printer.print_error(f"The tag '{tag}' was not found.")
@@ -957,14 +1155,47 @@
         return images
 
     @staticmethod
     def _get_image_signing_url():
         """Endpoint for signing an image"""
         return "v2/catalog/containers/signature"
 
+    def _create_publish_request_artifact(
+        self, _target, include_version=True, implied_version=None, output=False
+    ) -> Artifact:
+        # Need a tag to publish; try getting the latest tag. If there is no tag available for the source, the
+        # `_get_latest_tag()` method will raise an exception.
+        _target_artifact = Artifact()
+        _target_obj = ImageRegistryTarget(_target)
+        # if include_version
+        #                versioned      |    not versioned
+        # source       do nothing       |   get latest version on source
+        # target       do nothing       |   use source version, fallback to get latest version on target
+        # if not include_version, omit version in request
+        if include_version:
+            if _target_obj.tag:
+                _target_artifact.version = _target_obj.tag
+            elif implied_version:
+                _target_artifact.version = implied_version
+                if output:
+                    self.printer.print_ok(f"No tag specified for {_target}; using implied tag: {implied_version}.")
+                logger.debug("No tag specified for %s; using implied tag: %s.", _target, implied_version)
+            else:
+                _target_artifact.version = self.get_repo_details(_target_obj.org, _target_obj.team, _target).latestTag
+                if output:
+                    self.printer.print_ok(
+                        f"No tag specified for {_target}; using latest tag: {_target_artifact.version}."
+                    )
+                logger.debug("No tag specified for %s; using latest tag: %s.", _target, _target_artifact.version)
+
+        _target_artifact.org = _target_obj.org
+        _target_artifact.team = _target_obj.team
+        _target_artifact.name = _target_obj.image
+        return _target_artifact
+
 
 class GuestImageAPI(ImageAPI):
     def _get_repo_url(self, org=None, team=None, repo=None, page_size=None):
         """we need to create the url for public repos
         `/v2/repos/{org-name}/{team-name}/{repo-name}`"""
         ep = "v2/repos"
         if org:
```

## registry/api/label_set.py

```diff
@@ -5,16 +5,16 @@
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 import json
 import posixpath
 
-from ngccli.data.search.LabelSetResponse import LabelSetResponse
-from ngccli.data.search.ListLabelSetsResponse import ListLabelSetsResponse
+from ngcbpc.data.search.LabelSetResponse import LabelSetResponse
+from ngcbpc.data.search.ListLabelSetsResponse import ListLabelSetsResponse
 
 
 class LabelSetAPI:
     def __init__(self, connection, label_set_connection=None):
         self.connection = connection
         self.label_set_connection = label_set_connection
```

## registry/api/models.py

```diff
@@ -18,36 +18,36 @@
 from typing import List, Optional, Union
 
 from ngcbpc.api.authentication import Authentication
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.connection import Connection
 from ngcbpc.api.pagination import pagination_helper_use_page_reference
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV, TRANSFER_STATES
+from ngcbpc.data.model.ArtifactAttribute import ArtifactAttribute
+from ngcbpc.data.model.Model import Model
+from ngcbpc.data.model.ModelCreateRequest import ModelCreateRequest
+from ngcbpc.data.model.ModelResponse import ModelResponse
+from ngcbpc.data.model.ModelUpdateRequest import ModelUpdateRequest
+from ngcbpc.data.model.ModelVersion import ModelVersion
+from ngcbpc.data.model.ModelVersionCreateRequest import ModelVersionCreateRequest
+from ngcbpc.data.model.ModelVersionFileListResponse import ModelVersionFileListResponse
+from ngcbpc.data.model.ModelVersionListResponse import ModelVersionListResponse
+from ngcbpc.data.model.ModelVersionResponse import ModelVersionResponse
+from ngcbpc.data.model.ModelVersionUpdateRequest import ModelVersionUpdateRequest
 from ngcbpc.errors import (
     InvalidArgumentError,
     NgcException,
     ResourceAlreadyExistsException,
     ResourceNotFoundException,
 )
 from ngcbpc.printer.transfer import TransferPrinter
 from ngcbpc.transfer import async_download, http_uploader
 from ngcbpc.transfer.utils import get_download_files
 from ngcbpc.util.file_utils import get_file_contents, tree_size_and_count
 from ngcbpc.util.utils import confirm_remove, extra_args, format_org_team
-from ngccli.data.model.ArtifactAttribute import ArtifactAttribute
-from ngccli.data.model.Model import Model
-from ngccli.data.model.ModelCreateRequest import ModelCreateRequest
-from ngccli.data.model.ModelResponse import ModelResponse
-from ngccli.data.model.ModelUpdateRequest import ModelUpdateRequest
-from ngccli.data.model.ModelVersion import ModelVersion
-from ngccli.data.model.ModelVersionCreateRequest import ModelVersionCreateRequest
-from ngccli.data.model.ModelVersionFileListResponse import ModelVersionFileListResponse
-from ngccli.data.model.ModelVersionListResponse import ModelVersionListResponse
-from ngccli.data.model.ModelVersionResponse import ModelVersionResponse
-from ngccli.data.model.ModelVersionUpdateRequest import ModelVersionUpdateRequest
 from registry.api.utils import (
     add_credentials_to_request,
     filter_version_list,
     get_environ_tag,
     get_label_set_labels,
     handle_public_dataset_no_args,
     ModelRegistryTarget,
```

## registry/api/playground.py

```diff
@@ -9,17 +9,17 @@
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
 
 import logging
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.connection import Connection
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
+from ngcbpc.data.model.AIPlaygroundResponse import AIPlaygroundResponse
 from ngcbpc.errors import ResourceNotFoundException
 from ngcbpc.util.utils import extra_args, format_org_team
-from ngccli.data.model.AIPlaygroundResponse import AIPlaygroundResponse
 from registry.api.utils import get_environ_tag, ModelRegistryTarget
 from registry.constants import MODEL_SERVICE_URL_MAPPING
 
 logger = logging.getLogger(__name__)
 
 environ_tag = get_environ_tag()
 env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(environ_tag)
```

## registry/api/publish.py

```diff
@@ -2,23 +2,72 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from typing import List, Optional
+
+from ngcbpc.errors import InvalidArgumentError
 
 
 class PublishAPI:
     PAGE_SIZE = 1000
 
     def __init__(self, connection):
         self.connection = connection
 
     @staticmethod
+    def validate_args(
+        target,
+        source,
+        metadata_only=False,
+        version_only=False,
+        visibility_only=False,
+        allow_guest: Optional[bool] = False,
+        discoverable: Optional[bool] = False,
+        public: Optional[bool] = False,
+        sign: Optional[bool] = False,  # pylint: disable=unused-argument
+        access_type: Optional[str] = None,
+        product_names: Optional[List[str]] = None,
+    ):
+        """This is common validation for all artifact types,
+        each artifact type should impose artifact specific validations"""
+        if bool(product_names) ^ bool(access_type):
+            raise InvalidArgumentError(
+                "If specify one of 'product-name' or 'access-type', you must specify the other."
+            ) from None
+        if sum([metadata_only, version_only, visibility_only]) > 1:
+            raise InvalidArgumentError(
+                "You can only specify at most one in the argument list: [`metadata_only`,`version_only`,"
+                " `visibility_only`]."
+            )
+        if source and visibility_only:
+            raise InvalidArgumentError(
+                "You cannot specify a `source` argument when making a `visibility_only` publishing request"
+            )
+        # copy metadata
+        if metadata_only and not (source and target):
+            raise InvalidArgumentError(
+                "You must specify `source` and `target` argument when making a `metadata_only` publishing request"
+            )
+        # copy version
+        if version_only and not (source and target):
+            raise InvalidArgumentError(
+                "You must specify `source` and `target` argument when making a `version_only` publishing request"
+            )
+        # visibility
+        if discoverable and not (allow_guest or public):
+            raise InvalidArgumentError(
+                "discoverable",
+                "An item cannot be published as 'discoverable' unless either 'public' or 'allow_guest' is True",
+            )
+
+    @staticmethod
     def get_base_url(artifact_type):
         """Return the base URL.  Most endpoints should be built off of this."""
         return f"v2/catalog/{artifact_type}"
 
     @staticmethod
     def get_product_base_url(artifact_type):
         """
@@ -26,27 +75,30 @@
         For models, resources, helm-charts, and images. To publish a collection under a Product,
         use the `get_base_url`.
         """
         return f"v2/catalog/{artifact_type}/product"
 
     def publish_artifact(self, publish_request, artifact_type, org=None, team=None):
         """Publish an artifact: Model, Resource, Helm-Chart"""
-        if publish_request.toDict().get("productNames", None) and publish_request.toDict().get("accessType", None):
+        is_unified_catalog = publish_request.toDict().get("productNames", None) and publish_request.toDict().get(
+            "accessType", None
+        )
+        if is_unified_catalog:
             url = self.get_product_base_url(artifact_type)
         else:
             url = f"{self.get_base_url(artifact_type)}/publish"
         return self.connection.make_api_request(
             "POST",
             url,
             payload=publish_request.toJSON(),
             auth_org=org,
             auth_team=team,
             extra_scopes=["artifact"],
             renew_token=True,
-            operation_name="post artifact",
+            operation_name=f"post {artifact_type} publish",
         )
 
     # pylint: disable=unused-argument
     def publish_collection(self, publish_request, artifact_type, org=None, team=None):
         """Publish a collection by copying collection items and publishing collection metadata."""
         url = self.get_base_url("collections")
         ops_urls = []
@@ -82,33 +134,38 @@
             auth_org=org,
             auth_team=team,
             extra_scopes=["artifact"],
             renew_token=True,
             operation_name=f"post {artifact_type} metadata copy",
         )
 
+    def copy_container_version_artifact(self, publish_request, org=None, team=None):
+        """Copy the specified version of a container with no metadata changes to the main artifact."""
+
+        for key in ("publishToPublic", "publishAsListedToPublic", "publishWithGuestAccess"):
+            setattr(publish_request, key, None)
+
+        file_url = self.get_base_url("containers") + "/images/copy"
+        return self.connection.make_api_request(
+            "POST",
+            file_url,
+            payload=publish_request.toJSON(),
+            auth_org=org,
+            auth_team=team,
+            extra_scopes=["artifact"],
+            renew_token=True,
+            operation_name="post containers version files copy",
+        )
+
     def copy_version_artifact(self, publish_request, artifact_type, org=None, team=None):
         """Copy the specified version of an artifact with no metadata changes to the main artifact."""
 
         for key in ("publishToPublic", "publishAsListedToPublic", "publishWithGuestAccess"):
             setattr(publish_request, key, None)
 
-        if artifact_type == "containers":
-            file_url = f"{self.get_base_url(artifact_type)}/images/copy"
-            return self.connection.make_api_request(
-                "POST",
-                file_url,
-                payload=publish_request.toJSON(),
-                auth_org=org,
-                auth_team=team,
-                extra_scopes=["artifact"],
-                renew_token=True,
-                operation_name=f"post {artifact_type} version files copy",
-            )
-
         meta_url = f"{self.get_base_url(artifact_type)}/versions/metadata/copy"
         file_url = f"{self.get_base_url(artifact_type)}/versions/files/copy"
 
         # First, copy the version metadata
         self.connection.make_api_request(
             "POST",
             meta_url,
@@ -143,25 +200,7 @@
             payload=publish_request.toJSON(),
             auth_org=org,
             auth_team=team,
             extra_scopes=["artifact"],
             renew_token=True,
             operation_name=f"post {artifact_type} update visibility",
         )
-
-    # pylint: disable=unused-argument
-    def publish_image(self, publish_request, artifact_type, org=None, team=None, sign=False):
-        """Publish an image."""
-        if publish_request.toDict().get("productNames", None) and publish_request.toDict().get("accessType", None):
-            url = self.get_product_base_url(artifact_type)
-        else:
-            url = f"{self.get_base_url('containers')}/publish"
-        return self.connection.make_api_request(
-            "POST",
-            url,
-            payload=publish_request.toJSON(),
-            auth_org=org,
-            auth_team=team,
-            extra_scopes=["artifact"],
-            renew_token=True,
-            operation_name="post image publish",
-        )
```

## registry/api/resources.py

```diff
@@ -17,14 +17,29 @@
 from typing import List, Optional, Union
 
 from ngcbpc.api.authentication import Authentication
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.api.connection import Connection
 from ngcbpc.api.pagination import pagination_helper_use_page_reference
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV, TRANSFER_STATES
+from ngcbpc.data.model.ApplicationType import ApplicationTypeEnum
+from ngcbpc.data.model.FrameworkType import FrameworkTypeEnum
+from ngcbpc.data.model.PrecisionType import PrecisionTypeEnum
+from ngcbpc.data.model.RecipeCreateRequest import RecipeCreateRequest
+from ngcbpc.data.model.RecipeListResponse import RecipeListResponse
+from ngcbpc.data.model.RecipeResponse import RecipeResponse
+from ngcbpc.data.model.RecipeUpdateRequest import RecipeUpdateRequest
+from ngcbpc.data.model.RecipeVersion import RecipeVersion
+from ngcbpc.data.model.RecipeVersionCreateRequest import RecipeVersionCreateRequest
+from ngcbpc.data.model.RecipeVersionFileListResponse import (
+    RecipeVersionFileListResponse,
+)
+from ngcbpc.data.model.RecipeVersionListResponse import RecipeVersionListResponse
+from ngcbpc.data.model.RecipeVersionResponse import RecipeVersionResponse
+from ngcbpc.data.model.RecipeVersionUpdateRequest import RecipeVersionUpdateRequest
 from ngcbpc.errors import (
     NgcException,
     ResourceAlreadyExistsException,
     ResourceFilesNotFoundException,
     ResourceNotFoundException,
 )
 from ngcbpc.printer.transfer import TransferPrinter
@@ -37,29 +52,14 @@
 )
 from ngcbpc.util.utils import (
     confirm_remove,
     extra_args,
     find_case_insensitive,
     format_org_team,
 )
-from ngccli.data.model.ApplicationType import ApplicationTypeEnum
-from ngccli.data.model.FrameworkType import FrameworkTypeEnum
-from ngccli.data.model.PrecisionType import PrecisionTypeEnum
-from ngccli.data.model.RecipeCreateRequest import RecipeCreateRequest
-from ngccli.data.model.RecipeListResponse import RecipeListResponse
-from ngccli.data.model.RecipeResponse import RecipeResponse
-from ngccli.data.model.RecipeUpdateRequest import RecipeUpdateRequest
-from ngccli.data.model.RecipeVersion import RecipeVersion
-from ngccli.data.model.RecipeVersionCreateRequest import RecipeVersionCreateRequest
-from ngccli.data.model.RecipeVersionFileListResponse import (
-    RecipeVersionFileListResponse,
-)
-from ngccli.data.model.RecipeVersionListResponse import RecipeVersionListResponse
-from ngccli.data.model.RecipeVersionResponse import RecipeVersionResponse
-from ngccli.data.model.RecipeVersionUpdateRequest import RecipeVersionUpdateRequest
 from registry.api.utils import (
     filter_version_list,
     get_environ_tag,
     get_label_set_labels,
     handle_public_dataset_no_args,
     ModelRegistryTarget,
 )
```

## registry/api/search.py

```diff
@@ -10,15 +10,15 @@
 # provided with the software product.
 #
 
 #
 import itertools
 
 from ngcbpc.api.search import SearchAPI
-from ngccli.data.search.SearchParamFilter import SearchParamFilter
+from ngcbpc.data.search.SearchParamFilter import SearchParamFilter
 from registry.transformer.chart import ChartSearchTransformer
 from registry.transformer.collection import CollectionSearchTransformer
 from registry.transformer.image import RepositorySearchTransformer
 from registry.transformer.model import ModelSearchTransformer
 from registry.transformer.model_script import ModelScriptSearchTransformer
```

## registry/api/utils.py

```diff
@@ -12,26 +12,32 @@
 from fnmatch import fnmatch
 import json
 import re
 
 from ngcbpc.api.utils import add_scheme, remove_scheme
 from ngcbpc.command.args_validation import validate_credentials_json
 from ngcbpc.constants import CANARY_ENV, PRODUCTION_ENV, STAGING_ENV
+from ngcbpc.data.model.CustomMetricGroup import CustomMetricGroup
+from ngcbpc.data.model.Dataset import Dataset
 from ngcbpc.errors import NgcException, ResourceNotFoundException
 from ngcbpc.util.utils import contains_glob, find_case_insensitive, get_environ_tag
-from ngccli.data.model.CustomMetricGroup import CustomMetricGroup
-from ngccli.data.model.Dataset import Dataset
 from registry.constants import (
     HELM_URL_MAPPING,
     LABEL_SET_URL_MAPPING,
     REGISTRY_URL_MAPPING,
 )
 from registry.environ import NGC_CLI_REGISTRY_SERVICE_URL
 
 
+def get_nvcr_relative_url() -> str:
+    tag = get_environ_tag()
+    env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(tag)
+    return REGISTRY_URL_MAPPING[env]
+
+
 def get_registry_url():
     if NGC_CLI_REGISTRY_SERVICE_URL:
         return NGC_CLI_REGISTRY_SERVICE_URL
     tag = get_environ_tag()
     env = {PRODUCTION_ENV: "prod", CANARY_ENV: "canary", STAGING_ENV: "stg"}.get(tag)
     return add_scheme(REGISTRY_URL_MAPPING[env])
```

## registry/command/chart.py

```diff
@@ -21,17 +21,17 @@
 from ngcbpc.constants import (
     CANARY_ENV,
     CONFIG_TYPE,
     DISABLE_TYPE,
     ENABLE_TYPE,
     PRODUCT_NAMES,
 )
+from ngcbpc.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngcbpc.errors import InvalidArgumentError, NgcException, ResourceNotFoundException
 from ngcbpc.util.utils import confirm_remove, get_columns_help, get_environ_tag
-from ngccli.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngccli.modules.client import Client
 from registry.api.utils import ChartRegistryTarget
 from registry.command.publish import (
     ACCESS_TYPE_HELP,
     ALLOW_GUEST_HELP,
     DISCOVERABLE_HELP,
     METADATA_HELP,
@@ -60,15 +60,14 @@
         super().__init__(parser)
         self.parser = parser
         self.config = Configuration()
         api_key = self.config.app_key
         base_url = self.config.base_url
         client = Client(api_key=api_key, base_url=base_url)
         self.api = client.registry.chart
-        self.label_set_api = client.registry.label_set
         self.resource_type = "HELM_CHART"
         self.publish_api = client.registry.publish
         self.printer = ChartPrinter()
 
     if bool(Configuration().product_names):
         product_names = Configuration().product_names
     else:
```

## registry/command/collection.py

```diff
@@ -14,23 +14,23 @@
     check_add_args_columns,
     check_valid_columns,
     ReadFile,
     SingleUseAction,
 )
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CANARY_ENV, CONFIG_TYPE, DISABLE_TYPE, ENABLE_TYPE
+from ngcbpc.data.model.ArtifactListResponse import ArtifactListResponse
+from ngcbpc.data.model.Collection import Collection
+from ngcbpc.data.model.CollectionCategoryType import CollectionCategoryTypeEnum
+from ngcbpc.data.model.CollectionCreateRequest import CollectionCreateRequest
+from ngcbpc.data.model.CollectionListResponse import CollectionListResponse
+from ngcbpc.data.model.CollectionResponse import CollectionResponse
+from ngcbpc.data.model.CollectionUpdateRequest import CollectionUpdateRequest
 from ngcbpc.errors import InvalidArgumentError, NgcAPIError
 from ngcbpc.util.utils import confirm_remove, get_columns_help, get_environ_tag
-from ngccli.data.model.ArtifactListResponse import ArtifactListResponse
-from ngccli.data.model.Collection import Collection
-from ngccli.data.model.CollectionCategoryType import CollectionCategoryTypeEnum
-from ngccli.data.model.CollectionCreateRequest import CollectionCreateRequest
-from ngccli.data.model.CollectionListResponse import CollectionListResponse
-from ngccli.data.model.CollectionResponse import CollectionResponse
-from ngccli.data.model.CollectionUpdateRequest import CollectionUpdateRequest
 from ngccli.modules.client import Client
 from registry.api.utils import get_label_set_labels, SimpleRegistryTarget
 from registry.command.publish import (
     ALLOW_GUEST_HELP,
     DISCOVERABLE_HELP,
     METADATA_HELP,
     PUBLIC_HELP,
```

## registry/command/csp.py

```diff
@@ -9,28 +9,28 @@
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 #
 
 #
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.clicommand import CLICommand
-from ngcbpc.errors import InvalidArgumentError, ResourceNotFoundException
-from ngcbpc.util.utils import confirm_remove
-from ngccli.data.model.CloudServiceProviderCreateRequest import (
+from ngcbpc.data.model.CloudServiceProviderCreateRequest import (
     CloudServiceProviderCreateRequest,
 )
-from ngccli.data.model.CloudServiceProviderUpdateRequest import (
+from ngcbpc.data.model.CloudServiceProviderUpdateRequest import (
     CloudServiceProviderUpdateRequest,
 )
-from ngccli.data.model.DeploymentParametersCreateRequest import (
+from ngcbpc.data.model.DeploymentParametersCreateRequest import (
     DeploymentParametersCreateRequest,
 )
-from ngccli.data.model.DeploymentParametersMetaCreateRequest import (
+from ngcbpc.data.model.DeploymentParametersMetaCreateRequest import (
     DeploymentParametersMetaCreateRequest,
 )
+from ngcbpc.errors import InvalidArgumentError, ResourceNotFoundException
+from ngcbpc.util.utils import confirm_remove
 from ngccli.modules.client import Client
 from registry.command.registry import RegistryCommand
 from registry.errors import CSPNotFoundException
 from registry.printer.csp import CspPrinter
 
 
 def _validate_default_item(collection, item):
```

## registry/command/image.py

```diff
@@ -24,28 +24,27 @@
 from ngcbpc.constants import (
     CANARY_ENV,
     CONFIG_TYPE,
     DISABLE_TYPE,
     ENABLE_TYPE,
     PRODUCT_NAMES,
 )
-from ngcbpc.errors import InvalidArgumentError, NgcException, ResourceNotFoundException
+from ngcbpc.data.registry.AccessTypeEnum import AccessTypeEnum
+from ngcbpc.data.registry.RepositoryImageDetailsList import RepositoryImageDetailsList
+from ngcbpc.errors import NgcException, ResourceNotFoundException
 from ngcbpc.util.utils import contains_glob, get_columns_help, get_environ_tag
-from ngccli.data.registry.AccessTypeEnum import AccessTypeEnum
-from ngccli.data.registry.RepositoryImageDetailsList import RepositoryImageDetailsList
 from ngccli.modules.client import Client
 from registry.api.utils import ImageRegistryTarget
 from registry.command.publish import (
     ACCESS_TYPE_HELP,
     ALLOW_GUEST_HELP,
     DISCOVERABLE_HELP,
     METADATA_HELP,
     PRODUCT_HELP,
     PUBLIC_HELP,
-    Publisher,
     VERSION_ONLY_HELP,
     VISIBILITY_HELP,
 )
 from registry.command.registry import RegistryCommand
 from registry.errors import ImageTagNotFound
 from registry.printer.image import ImagePrinter
 
@@ -481,49 +480,35 @@
         help=product_help,
         action="append",
         default=None,
     )
     @CLICommand.arguments(
         "--access-type", metavar="<access_type>", help=ACCESS_TYPE_HELP, type=str, default=None, choices=AccessTypeEnum
     )
-    @CLICommand.mutex(["metadata_only"], ["version_only"], ["visibility_only"])
     @CLICommand.mutex(["access_type", "product_name"], ["allow_guest", "discoverable", "public"])
     def publish(self, args):
-        self.config.validate_configuration(guest_mode_allowed=False)
-        if (args.product_name and not args.access_type) or (args.access_type and not args.product_name):
-            raise InvalidArgumentError(
-                "If specify one of '--product-name' or '--access-type', you must specify the other."
-            ) from None
-        if args.visibility_only:
-            if args.source:
-                raise InvalidArgumentError(
-                    "You cannot specify a `--source` argument when making a `visibility_only` publishing request"
-                )
-            source = None
-            # Use the target value as the source. They aren't used, but are needed for the Publishing object.
-            source = ImageRegistryTarget(args.target)
-        else:
-            if not args.source:
-                raise InvalidArgumentError("You must specify a `--source` argument")
-            source = ImageRegistryTarget(args.source)
-            if not source.tag:
-                # Need a tag to publish; try getting the latest tag. If there is no tag available for the source, the
-                # `_get_latest_tag()` method will raise an exception.
-                source.tag = self._get_latest_tag(source, args.source)
-                self.image_printer.print_ok(f"No tag specified; using latest tag: {source.tag}.")
-        target = ImageRegistryTarget(args.target)
-        if not target.tag:
-            target.tag = source.tag
+
         try:
-            publisher = Publisher(source, target, self.publish_api, "containers", args)
-        except InvalidArgumentError as e:
+            self.client.image.publish(
+                args.target,
+                args.source,
+                args.metadata_only,
+                args.version_only,
+                args.visibility_only,
+                args.allow_guest,
+                args.discoverable,
+                args.public,
+                args.sign,
+                args.access_type,
+                args.product_name,
+                output=True,
+            )
+        except Exception as e:  # pylint: disable=broad-except
             self.image_printer.print_error(e)
             return
-        publisher.publish()
-        self.image_printer.print_ok(f"Successfully published {args.target}")
 
     image_metavar = "org/[team/]image_name[:version]"
     SIGN_HELP = "Have the image cryptographically signed by NVIDIA."
 
     @CLICommand.command(help=SIGN_HELP, description=SIGN_HELP, feature_tag=CONFIG_TYPE)
     @CLICommand.arguments("image", metavar=IMAGE_METAVAR_TAGS, help=IMAGE_ARG_HELP, type=str)
     def sign(self, args):
```

## registry/command/image_deploy.py

```diff
@@ -11,22 +11,22 @@
 #
 
 #
 from collections import defaultdict
 import webbrowser
 
 from ngcbpc.command.clicommand import CLICommand
-from ngcbpc.util.utils import confirm_remove
-from ngccli.data.model.DeploymentParametersCreateRequest import (
+from ngcbpc.data.model.DeploymentParametersCreateRequest import (
     DeploymentParametersCreateRequest,
 )
-from ngccli.data.model.DeploymentParametersUpdateRequest import (
+from ngcbpc.data.model.DeploymentParametersUpdateRequest import (
     DeploymentParametersUpdateRequest,
 )
-from ngccli.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.util.utils import confirm_remove
 from registry.api.utils import ImageRegistryTarget
 from registry.command.image import IMAGE_CREATE_METAVAR, ImageCommand
 from registry.printer.artifact_deploy import ArtifactDeployPrinter
 
 
 class ImageDeployCommand(ImageCommand):
```

## registry/command/label_set.py

```diff
@@ -13,19 +13,19 @@
     check_add_args_columns,
     check_valid_columns,
     check_valid_labels,
     SingleUseAction,
 )
 from ngcbpc.command.clicommand import CLICommand
 from ngcbpc.constants import CONFIG_TYPE, ENABLE_TYPE
+from ngcbpc.data.search.LabelSetCreateRequest import LabelSetCreateRequest
+from ngcbpc.data.search.LabelSetUpdateRequest import LabelSetUpdateRequest
+from ngcbpc.data.search.ResourceTypeEnum import ResourceTypeEnum
 from ngcbpc.errors import ResourceAlreadyExistsException, ResourceNotFoundException
 from ngcbpc.util.utils import confirm_remove, convert_string, get_columns_help
-from ngccli.data.search.LabelSetCreateRequest import LabelSetCreateRequest
-from ngccli.data.search.LabelSetUpdateRequest import LabelSetUpdateRequest
-from ngccli.data.search.ResourceTypeEnum import ResourceTypeEnum
 from ngccli.modules.client import Client
 from registry.api.utils import SimpleRegistryTarget
 from registry.command.registry import RegistryCommand
 from registry.printer.label_set import LabelSetPrinter
 
 
 def convert_to_display(rtype):
```

## registry/command/model.py

```diff
@@ -20,19 +20,19 @@
 from ngcbpc.constants import (
     CANARY_ENV,
     CONFIG_TYPE,
     DISABLE_TYPE,
     ENABLE_TYPE,
     PRODUCT_NAMES,
 )
+from ngcbpc.data.model.SortOrderEnum import SortOrderEnum
+from ngcbpc.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngcbpc.errors import InvalidArgumentError, NgcException, ResourceNotFoundException
 from ngcbpc.printer.transfer import TransferPrinter
 from ngcbpc.util.utils import find_case_insensitive, get_columns_help, get_environ_tag
-from ngccli.data.model.SortOrderEnum import SortOrderEnum
-from ngccli.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngccli.modules.client import Client
 from registry.api.utils import ModelRegistryTarget
 from registry.command.publish import (
     ACCESS_TYPE_HELP,
     ALLOW_GUEST_HELP,
     DISCOVERABLE_HELP,
     METADATA_HELP,
```

## registry/command/model_deploy.py

```diff
@@ -11,22 +11,22 @@
 #
 
 #
 from collections import defaultdict
 import webbrowser
 
 from ngcbpc.command.clicommand import CLICommand
-from ngcbpc.util.utils import confirm_remove
-from ngccli.data.model.DeploymentParametersCreateRequest import (
+from ngcbpc.data.model.DeploymentParametersCreateRequest import (
     DeploymentParametersCreateRequest,
 )
-from ngccli.data.model.DeploymentParametersUpdateRequest import (
+from ngcbpc.data.model.DeploymentParametersUpdateRequest import (
     DeploymentParametersUpdateRequest,
 )
-from ngccli.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.util.utils import confirm_remove
 from registry.api.utils import (
     get_container_json,
     ImageRegistryTarget,
     ModelRegistryTarget,
 )
 from registry.command.image import IMAGE_METAVAR_REQ_TAG
 from registry.command.model import ModelSubCommand
```

## registry/command/publish.py

```diff
@@ -3,31 +3,29 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngcbpc.errors import InvalidArgumentError
-from ngccli.data.publishing.Artifact import Artifact
-from ngccli.data.publishing.PublishingRequest import PublishingRequest
-from ngccli.data.registry.AccessTypeEnum import AccessTypeEnum
-from registry.api.utils import ImageRegistryTarget
+from registry.data.publishing.Artifact import Artifact
+from registry.data.publishing.PublishingRequest import PublishingRequest
 
 METADATA_HELP = "Only perform a shallow copy of the metadata instead of a deep copy of the objects referenced"
 VERSION_ONLY_HELP = "Only copy the specified version of the object without copying any metadata"
 ALLOW_GUEST_HELP = "Allow anonymous users to download the published object"
 DISCOVERABLE_HELP = "Allow the published object to be discoverable in searches"
 PUBLIC_HELP = "Allow access to the published object by everyone instead of just those with specific roles"
 PRODUCT_HELP = "Publish the object under a Product. Choose from: "
 ACCESS_TYPE_HELP = f"Publish the object with a specific access type. Choose from: {', '.join(AccessTypeEnum)}"
 PUBTYPE_MAPPING = {
     "models": "MODEL",
     "helm-charts": "HELM_CHART",
-    "containers": "CONTAINER",
     "resources": "RESOURCE",
     "collections": "COLLECTION",
 }
 VISIBILITY_HELP = "Only change the visibility qualities of the target. Metadata and version files are not affected."
 
 
 class Publisher:
@@ -66,44 +64,42 @@
         if self.version_only and self.artifact_type == "collections":
             raise NotImplementedError("version_only option for collections is not yet implemented.")
 
     def publish(self):
         request = PublishingRequest()
         request.isNew = False
         request.artifactType = PUBTYPE_MAPPING.get(self.artifact_type, "")
-        version_name = "tag" if self.artifact_type == "containers" else "version"
+        version_name = "version"
         request.publishToPublic = self.public
         request.publishWithGuestAccess = self.allow_guest
         request.publishAsListedToPublic = self.discoverable
         request.sign = self.sign
         if self.product_name and self.access_type:
             request.accessType = self.access_type
             request.productNames = self.product_name
 
         rsa = request.sourceArtifact = Artifact()
         srt = self.source_registry_target
         rsa.org = srt.org
         rsa.team = srt.team
-        rsa.name = srt.image if isinstance(srt, ImageRegistryTarget) else srt.name
+        rsa.name = srt.name
         if hasattr(srt, version_name):
             rsa.version = getattr(srt, version_name)
 
         rta = request.targetArtifact = Artifact()
         trt = self.target_registry_target
         rta.org = trt.org
         rta.team = trt.team
-        rta.name = trt.image if isinstance(trt, ImageRegistryTarget) else trt.name
+        rta.name = trt.name
         if hasattr(trt, version_name):
             rta.version = getattr(trt, version_name)
 
         # Collections and images have their own methods; the rest use the artifact method.
         if self.metadata_only:
             return self.publish_api.copy_metadata_artifact(request, self.artifact_type)
         if self.version_only:
             return self.publish_api.copy_version_artifact(request, self.artifact_type)
         if self.visibility_only:
             return self.publish_api.update_visibility(request, self.artifact_type)
-        mthd_name = {"collections": "publish_collection", "containers": "publish_image"}.get(
-            self.artifact_type, "publish_artifact"
-        )
+        mthd_name = {"collections": "publish_collection"}.get(self.artifact_type, "publish_artifact")
         mthd = getattr(self.publish_api, mthd_name)
         return mthd(request, self.artifact_type)
```

## registry/command/resource.py

```diff
@@ -20,28 +20,28 @@
 from ngcbpc.constants import (
     CANARY_ENV,
     CONFIG_TYPE,
     DISABLE_TYPE,
     ENABLE_TYPE,
     PRODUCT_NAMES,
 )
+from ngcbpc.data.model.ApplicationType import ApplicationTypeEnum
+from ngcbpc.data.model.FrameworkType import FrameworkTypeEnum
+from ngcbpc.data.model.PrecisionType import PrecisionTypeEnum
+from ngcbpc.data.model.RecipeResponse import RecipeResponse
+from ngcbpc.data.model.RecipeVersionResponse import RecipeVersionResponse
+from ngcbpc.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngcbpc.errors import (
     InvalidArgumentError,
     NgcException,
     ResourceFilesNotFoundException,
     ResourceNotFoundException,
 )
 from ngcbpc.printer.transfer import TransferPrinter
 from ngcbpc.util.utils import get_columns_help, get_environ_tag
-from ngccli.data.model.ApplicationType import ApplicationTypeEnum
-from ngccli.data.model.FrameworkType import FrameworkTypeEnum
-from ngccli.data.model.PrecisionType import PrecisionTypeEnum
-from ngccli.data.model.RecipeResponse import RecipeResponse
-from ngccli.data.model.RecipeVersionResponse import RecipeVersionResponse
-from ngccli.data.registry.AccessTypeEnum import AccessTypeEnum
 from ngccli.modules.client import Client
 from registry.api.resources import ResourceAPI
 from registry.api.utils import ModelRegistryTarget
 from registry.command.publish import (
     ACCESS_TYPE_HELP,
     ALLOW_GUEST_HELP,
     DISCOVERABLE_HELP,
```

## registry/command/resource_deploy.py

```diff
@@ -12,22 +12,22 @@
 
 #
 from collections import defaultdict
 import webbrowser
 
 from ngcbpc.api.configuration import Configuration
 from ngcbpc.command.clicommand import CLICommand
-from ngcbpc.util.utils import confirm_remove
-from ngccli.data.model.DeploymentParametersCreateRequest import (
+from ngcbpc.data.model.DeploymentParametersCreateRequest import (
     DeploymentParametersCreateRequest,
 )
-from ngccli.data.model.DeploymentParametersUpdateRequest import (
+from ngcbpc.data.model.DeploymentParametersUpdateRequest import (
     DeploymentParametersUpdateRequest,
 )
-from ngccli.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.data.model.DeploymentUrlCreateRequest import DeploymentUrlCreateRequest
+from ngcbpc.util.utils import confirm_remove
 from ngccli.modules.client import Client
 from registry.api.utils import (
     get_container_json,
     ImageRegistryTarget,
     ModelRegistryTarget,
 )
 from registry.command.image import IMAGE_METAVAR_REQ_TAG
```

## registry/printer/csp.py

```diff
@@ -5,18 +5,18 @@
 # (the "Company") and all right, title, and interest in and to the software
 # product, including all associated intellectual property rights, are and
 # shall remain exclusively with the Company.
 #
 # This software product is governed by the End User License Agreement
 # provided with the software product.
 #
+from ngcbpc.data.model.DeploymentParameters import DeploymentParameters
+from ngcbpc.data.model.DeploymentParametersMeta import DeploymentParametersMeta
 from ngcbpc.printer.nvPrettyPrint import NVPrettyPrint, str_
 from ngcbpc.printer.utils import format_list_view_date
-from ngccli.data.model.DeploymentParameters import DeploymentParameters
-from ngccli.data.model.DeploymentParametersMeta import DeploymentParametersMeta
 
 
 class CspPrinter(NVPrettyPrint):
     """Printer class for the CSP module."""
 
     def _get_csp_lines(self, tbl, csp):
         """Helper function for printing CSP tables in a standardized way."""
```

## registry/transformer/chart.py

```diff
@@ -2,16 +2,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.registry.Repository import Repository
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.registry.Repository import Repository
 
 
 class ChartSearchTransformer(Repository, BaseSearchTransformer):
     SEARCH_RESOURCE_KEY_MAPPING = {}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {
         "canGuestPull": "canGuestDownload",
         "dateCreated": "createdDate",
```

## registry/transformer/collection.py

```diff
@@ -2,16 +2,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.model.Collection import Collection
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.model.Collection import Collection
 
 
 class CollectionSearchTransformer(Collection, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {"format": "modelFormat"}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {"dateModified": "updatedDate", "dateCreated": "createdDate"}
```

## registry/transformer/image.py

```diff
@@ -2,16 +2,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.registry.Repository import Repository
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.registry.Repository import Repository
 
 
 class RepositorySearchTransformer(Repository, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {"size": "latestImageSize"}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {"dateModified": "updatedDate"}
```

## registry/transformer/model.py

```diff
@@ -2,16 +2,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.model.Model import Model
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.model.Model import Model
 
 
 class ModelSearchTransformer(Model, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {"format": "modelFormat"}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {"dateModified": "updatedDate", "dateCreated": "createdDate"}
```

## registry/transformer/model_script.py

```diff
@@ -2,16 +2,16 @@
 # Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 #
 # NVIDIA CORPORATION and its licensors retain all intellectual property
 # and proprietary rights in and to this software, related documentation
 # and any modifications thereto.  Any use, reproduction, disclosure or
 # distribution of this software and related documentation without an express
 # license agreement from NVIDIA CORPORATION is strictly prohibited.
+from ngcbpc.data.model.Recipe import Recipe
 from ngcbpc.transformer import BaseSearchTransformer
-from ngccli.data.model.Recipe import Recipe
 
 
 class ModelScriptSearchTransformer(Recipe, BaseSearchTransformer):
 
     SEARCH_RESOURCE_KEY_MAPPING = {"format": "modelFormat", "framework": "trainingFramework"}
     SEARCH_RESOURCE_TOP_KEY_MAPPING = {"dateModified": "updatedDate", "dateCreated": "createdDate"}
```

## Comparing `ngccli/data/api/Ace.py` & `basecommand/data/pym/ClusterModifyParams.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,835 +6,840 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AceHealth import AceHealth
-from .AceStorageInfo import AceStorageInfo
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
-from .AceInstance import AceInstance
-from .AceProvider import AceProviderEnum
-from .NetworkTypeEnum import NetworkTypeEnum
-from .IPAddress import IPAddress
-from .AceType import AceTypeEnum
+from .Env import Env
+from .ClusterComponentModifyParams import ClusterComponentModifyParams
+from .SecretSpec import SecretSpec
+from .DataInput import DataInput
+from .ClusterPortMapping import ClusterPortMapping
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
-str(repr(NetworkTypeEnum))
-str(repr(AceProviderEnum))
-str(repr(AceStorageInfo))
-str(repr(AceHealth))
-str(repr(AceTypeEnum))
-str(repr(AceInstance))
-str(repr(IPAddress))
+str(repr(SecretSpec))
+str(repr(DataInput))
+str(repr(ClusterPortMapping))
+str(repr(Env))
+str(repr(ClusterComponentModifyParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Ace(object):
-    """ACE is a collection of nodes that can run jobs"""
+class ClusterModifyParams(object):
+    """Cluster modification params"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowExposedPort = (
+        self.ace = (
             None if not fromDict or propDict.get(
-                "allowExposedPort"
+                "ace"
             ) is None
-            else propDict["allowExposedPort"])
-        self.clusterFederatorUrl = (
+            else propDict["ace"])
+        self.additionalOpenPorts = (
             None if not fromDict or propDict.get(
-                "clusterFederatorUrl"
+                "additionalOpenPorts"
             ) is None
-            else propDict["clusterFederatorUrl"])
-        self.createdBy = (
+            else propDict["additionalOpenPorts"])
+        self.additionalPortMappings = (
             None if not fromDict or propDict.get(
-                "createdBy"
+                "additionalPortMappings"
             ) is None
-            else propDict["createdBy"])
-        self.createdDate = (
+            else [ ClusterPortMapping(i)
+            for i in propDict["additionalPortMappings"] ])
+        self.clusterLifetime = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "clusterLifetime"
             ) is None
-            else propDict["createdDate"])
-        self.dataPlatformEnabled = (
+            else propDict["clusterLifetime"])
+        self.condaPackages = (
             None if not fromDict or propDict.get(
-                "dataPlatformEnabled"
+                "condaPackages"
             ) is None
-            else propDict["dataPlatformEnabled"])
-        self.description = (
+            else propDict["condaPackages"])
+        self.containerImage = (
             None if not fromDict or propDict.get(
-                "description"
+                "containerImage"
             ) is None
-            else propDict["description"])
-        self.egressIps = (
+            else propDict["containerImage"])
+        self.dataInput = (
             None if not fromDict or propDict.get(
-                "egressIps"
+                "dataInput"
             ) is None
-            else [ IPAddress(i)
-            for i in propDict["egressIps"] ])
-        self.grpcEnabled = (
+            else propDict["dataInput"])
+        self.dataOutputMountPoint = (
             None if not fromDict or propDict.get(
-                "grpcEnabled"
+                "dataOutputMountPoint"
             ) is None
-            else propDict["grpcEnabled"])
-        self.health = (
+            else propDict["dataOutputMountPoint"])
+        self.expiryDuration = (
             None if not fromDict or propDict.get(
-                "health"
+                "expiryDuration"
             ) is None
-            else propDict["health"])
-        self.id = (
+            else propDict["expiryDuration"])
+        self.isLabelLocked = (
             None if not fromDict or propDict.get(
-                "id"
+                "isLabelLocked"
             ) is None
-            else propDict["id"])
-        self.infinityManagerEnabled = (
+            else propDict["isLabelLocked"])
+        self.isMultiNode = (
             None if not fromDict or propDict.get(
-                "infinityManagerEnabled"
+                "isMultiNode"
             ) is None
-            else propDict["infinityManagerEnabled"])
-        self.instances = (
+            else propDict["isMultiNode"])
+        self.jobOrder = (
             None if not fromDict or propDict.get(
-                "instances"
+                "jobOrder"
             ) is None
-            else [ AceInstance(i)
-            for i in propDict["instances"] ])
-        self.isAutoConfigurationEnabled = (
+            else propDict["jobOrder"])
+        self.jobPriority = (
             None if not fromDict or propDict.get(
-                "isAutoConfigurationEnabled"
+                "jobPriority"
             ) is None
-            else propDict["isAutoConfigurationEnabled"])
-        self.isDeleted = (
+            else propDict["jobPriority"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "isDeleted"
+                "labels"
             ) is None
-            else propDict["isDeleted"])
-        self.maxActiveJobsPerUser = (
+            else propDict["labels"])
+        self.minAvailability = (
             None if not fromDict or propDict.get(
-                "maxActiveJobsPerUser"
+                "minAvailability"
             ) is None
-            else propDict["maxActiveJobsPerUser"])
-        self.maxAllowedReplicas = (
+            else propDict["minAvailability"])
+        self.minTimesliceSeconds = (
             None if not fromDict or propDict.get(
-                "maxAllowedReplicas"
+                "minTimesliceSeconds"
             ) is None
-            else propDict["maxAllowedReplicas"])
-        self.maxRuntimeSeconds = (
-            None if not fromDict or propDict.get(
-                "maxRuntimeSeconds"
-            ) is None
-            else propDict["maxRuntimeSeconds"])
+            else propDict["minTimesliceSeconds"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.networkTypes = (
-            None if not fromDict or propDict.get(
-                "networkTypes"
-            ) is None
-            else propDict["networkTypes"])
-        self.nodes = (
-            None if not fromDict or propDict.get(
-                "nodes"
-            ) is None
-            else propDict["nodes"])
-        self.orgName = (
+        self.nworkers = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "nworkers"
             ) is None
-            else propDict["orgName"])
-        self.provider = (
+            else propDict["nworkers"])
+        self.options = (
             None if not fromDict or propDict.get(
-                "provider"
+                "options"
             ) is None
-            else propDict["provider"])
-        self.proxyServiceUrl = (
+            else [ Env(i)
+            for i in propDict["options"] ])
+        self.pipPackages = (
             None if not fromDict or propDict.get(
-                "proxyServiceUrl"
+                "pipPackages"
             ) is None
-            else propDict["proxyServiceUrl"])
-        self.storageInfo = (
+            else propDict["pipPackages"])
+        self.preemptClass = (
             None if not fromDict or propDict.get(
-                "storageInfo"
+                "preemptClass"
             ) is None
-            else [ AceStorageInfo(i)
-            for i in propDict["storageInfo"] ])
-        self.storageServiceConfig = (
+            else propDict["preemptClass"])
+        self.scheduler = (
             None if not fromDict or propDict.get(
-                "storageServiceConfig"
+                "scheduler"
             ) is None
-            else [ StorageServiceConfigDetails(i)
-            for i in propDict["storageServiceConfig"] ])
-        self.storageServiceUrl = (
+            else propDict["scheduler"])
+        self.schedulerPort = (
             None if not fromDict or propDict.get(
-                "storageServiceUrl"
+                "schedulerPort"
             ) is None
-            else propDict["storageServiceUrl"])
-        self.terminationGracePeriodSeconds = (
+            else propDict["schedulerPort"])
+        self.systemPackages = (
             None if not fromDict or propDict.get(
-                "terminationGracePeriodSeconds"
+                "systemPackages"
             ) is None
-            else propDict["terminationGracePeriodSeconds"])
-        self.topologyTypes = (
+            else propDict["systemPackages"])
+        self.topologyConstraint = (
             None if not fromDict or propDict.get(
-                "topologyTypes"
+                "topologyConstraint"
             ) is None
-            else propDict["topologyTypes"])
-        self.type = (
+            else propDict["topologyConstraint"])
+        self.userSecretsSpec = (
             None if not fromDict or propDict.get(
-                "type"
+                "userSecretsSpec"
             ) is None
-            else propDict["type"])
-        self.updatedDate = (
+            else [ SecretSpec(i)
+            for i in propDict["userSecretsSpec"] ])
+        self.worker = (
             None if not fromDict or propDict.get(
-                "updatedDate"
+                "worker"
             ) is None
-            else propDict["updatedDate"])
+            else propDict["worker"])
 
     @property
-    def allowExposedPort(self):
-        """bool: Feature toggle for cli/FE to allow --ports feature"""
-        return self._allowExposedPort
+    def ace(self):
+        """str: ACE instance"""
+        return self._ace
 
-    @allowExposedPort.setter
-    def allowExposedPort(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowExposedPort = value
+    @ace.setter
+    def ace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ace = value
         else:
             raise TypeError(
-                'Property "allowExposedPort" of type "list<bool>" set to wron'
-                'g type'
+                'Property "ace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def clusterFederatorUrl(self):
-        """str: URL for cluster federation service hosted inside this ACE"""
-        return self._clusterFederatorUrl
+    def additionalOpenPorts(self):
+        """list: (Deprecated) Additional Ports"""
+        return self._additionalOpenPorts
 
-    @clusterFederatorUrl.setter
-    def clusterFederatorUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._clusterFederatorUrl = value
+    @additionalOpenPorts.setter
+    def additionalOpenPorts(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._additionalOpenPorts = value
         else:
             raise TypeError(
-                'Property "clusterFederatorUrl" of type "list<str>" set to wr'
+                'Property "additionalOpenPorts" of type "list<int>" set to wr'
                 'ong type'
             )
 
     @property
-    def createdBy(self):
-        """ """
-        return self._createdBy
+    def additionalPortMappings(self):
+        """list: Additional port mappings used for the cluster"""
+        return self._additionalPortMappings
 
-    @createdBy.setter
-    def createdBy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdBy = value
+    @additionalPortMappings.setter
+    def additionalPortMappings(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._additionalPortMappings = value
         else:
             raise TypeError(
-                'Property "createdBy" of type "list<str>" set to wrong type'
+                'Property "additionalPortMappings" of type "list<ClusterPortM'
+                'apping>" set to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """ """
-        return self._createdDate
+    def clusterLifetime(self):
+        """str: Cluster lifetime"""
+        return self._clusterLifetime
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @clusterLifetime.setter
+    def clusterLifetime(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._clusterLifetime = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "clusterLifetime" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def dataPlatformEnabled(self):
-        """bool: Enable flag for Data Platform. Used along Dataset Service in 
-        Create Job"""
-        return self._dataPlatformEnabled
+    def condaPackages(self):
+        """list: List of all custom packages to install in the container image
+         via conda install command"""
+        return self._condaPackages
 
-    @dataPlatformEnabled.setter
-    def dataPlatformEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._dataPlatformEnabled = value
+    @condaPackages.setter
+    def condaPackages(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._condaPackages = value
         else:
             raise TypeError(
-                'Property "dataPlatformEnabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "condaPackages" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def description(self):
-        """str: description of the ACE"""
-        return self._description
+    def containerImage(self):
+        """str: Container image"""
+        return self._containerImage
 
-    @description.setter
-    def description(self, value):
+    @containerImage.setter
+    def containerImage(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._containerImage = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "containerImage" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def egressIps(self):
-        """list: List of trusted Egress IPs from which the outgoing node traff
-        ic will flow. If provided, cloud will accept network traffic f
-        rom nodes only if it originates from one of the IP in this list."""
-        return self._egressIps
+    def dataInput(self):
+        """DataInput: Data Input"""
+        return self._dataInput
 
-    @egressIps.setter
-    def egressIps(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._egressIps = value
+    @dataInput.setter
+    def dataInput(self, value):
+        if value is not None and not isinstance(value, DataInput):
+            value = DataInput(value)
+        if (value is None) or isinstance(value, DataInput):
+            self._dataInput = value
         else:
             raise TypeError(
-                'Property "egressIps" of type "list<IPAddress>" set to wrong '
+                'Property "dataInput" of type "list<DataInput>" set to wrong '
                 'type'
             )
 
     @property
-    def grpcEnabled(self):
-        """bool: Determines whether GRPC Protocol can be used in JobPortMappin
-        g for jobs scheduled on this ACE."""
-        return self._grpcEnabled
+    def dataOutputMountPoint(self):
+        """str: Data output results mount point"""
+        return self._dataOutputMountPoint
 
-    @grpcEnabled.setter
-    def grpcEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._grpcEnabled = value
-        else:
-            raise TypeError(
-                'Property "grpcEnabled" of type "list<bool>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def health(self):
-        """AceHealth: Describes the health of the ACE"""
-        return self._health
-
-    @health.setter
-    def health(self, value):
-        if value is not None and not isinstance(value, AceHealth):
-            value = AceHealth(value)
-        if (value is None) or isinstance(value, AceHealth):
-            self._health = value
+    @dataOutputMountPoint.setter
+    def dataOutputMountPoint(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._dataOutputMountPoint = value
         else:
             raise TypeError(
-                'Property "health" of type "list<AceHealth>" set to wrong typ'
-                'e'
+                'Property "dataOutputMountPoint" of type "list<str>" set to w'
+                'rong type'
             )
 
     @property
-    def id(self):
-        """long: id of the ACE"""
-        return self._id
+    def expiryDuration(self):
+        """str: Maximum duration from submission time during which the job wil
+        l be allowed to run. If not specified, or is 0, then ACE limit
+         will be applied."""
+        return self._expiryDuration
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @expiryDuration.setter
+    def expiryDuration(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._expiryDuration = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "expiryDuration" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def infinityManagerEnabled(self):
-        """bool: Enable flag of Infinity Manager for this ace"""
-        return self._infinityManagerEnabled
+    def isLabelLocked(self):
+        """bool: Indicates whether the labels will be locked or not, default a
+        s false"""
+        return self._isLabelLocked
 
-    @infinityManagerEnabled.setter
-    def infinityManagerEnabled(self, value):
+    @isLabelLocked.setter
+    def isLabelLocked(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._infinityManagerEnabled = value
+            self._isLabelLocked = value
         else:
             raise TypeError(
-                'Property "infinityManagerEnabled" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "isLabelLocked" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def instances(self):
-        """list: array of availiable ace instances"""
-        return self._instances
+    def isMultiNode(self):
+        """bool: Indicates whether this is multi node cluster"""
+        return self._isMultiNode
 
-    @instances.setter
-    def instances(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._instances = value
+    @isMultiNode.setter
+    def isMultiNode(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isMultiNode = value
         else:
             raise TypeError(
-                'Property "instances" of type "list<AceInstance>" set to wron'
-                'g type'
+                'Property "isMultiNode" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def isAutoConfigurationEnabled(self):
-        """bool: Indicates if auto configuration is enabled for this cluster.
-        """
-        return self._isAutoConfigurationEnabled
+    def jobOrder(self):
+        """int: The order of job. Job order is from 1 to 99. Default value is 
+        50"""
+        return self._jobOrder
 
-    @isAutoConfigurationEnabled.setter
-    def isAutoConfigurationEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isAutoConfigurationEnabled = value
+    @jobOrder.setter
+    def jobOrder(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._jobOrder = value
         else:
             raise TypeError(
-                'Property "isAutoConfigurationEnabled" of type "list<bool>" s'
-                'et to wrong type'
+                'Property "jobOrder" of type "list<int>" set to wrong type'
             )
 
     @property
-    def isDeleted(self):
-        """bool: Indicates if ACE was deleted from the system."""
-        return self._isDeleted
+    def jobPriority(self):
+        """str: The priority of job. Default value is NORMAL"""
+        return self._jobPriority
 
-    @isDeleted.setter
-    def isDeleted(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDeleted = value
+    @jobPriority.setter
+    def jobPriority(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._jobPriority = value
         else:
             raise TypeError(
-                'Property "isDeleted" of type "list<bool>" set to wrong type'
+                'Property "jobPriority" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxActiveJobsPerUser(self):
-        """int: Maximum number of jobs a user can have QUEUED or RUNNING at an
-        y given point in time on this ACE. Users are allowed to submit
-         as many jobs as they want, but they will not be sent to the scheduler
-        . Default (0) means no restrictions."""
-        return self._maxActiveJobsPerUser
+    def labels(self):
+        """list: An array of labels that describe this job"""
+        return self._labels
 
-    @maxActiveJobsPerUser.setter
-    def maxActiveJobsPerUser(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._maxActiveJobsPerUser = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "maxActiveJobsPerUser" of type "list<int>" set to w'
-                'rong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxAllowedReplicas(self):
-        """int: Maximum number of replicas/tasks that are allowed for multinod
-        e job submission to the ACE"""
-        return self._maxAllowedReplicas
+    def minAvailability(self):
+        """int: Option to indicate whether n workers are needed to be schedule
+        d."""
+        return self._minAvailability
 
-    @maxAllowedReplicas.setter
-    def maxAllowedReplicas(self, value):
+    @minAvailability.setter
+    def minAvailability(self, value):
         if value is not None and not isinstance(value, int):
             value = int(value)
         if (value is None) or isinstance(value, int):
-            self._maxAllowedReplicas = value
+            self._minAvailability = value
         else:
             raise TypeError(
-                'Property "maxAllowedReplicas" of type "list<int>" set to wro'
-                'ng type'
+                'Property "minAvailability" of type "list<int>" set to wrong '
+                'type'
             )
 
     @property
-    def maxRuntimeSeconds(self):
-        """long: The maximum runtime, in seconds, that any jobs can have on th
-        e ACE."""
-        return self._maxRuntimeSeconds
+    def minTimesliceSeconds(self):
+        """long: Minimum time in seconds job is expected (not guaranteed) to b
+        e in the RUNNING state once scheduled to assure forward progre
+        ss."""
+        return self._minTimesliceSeconds
 
-    @maxRuntimeSeconds.setter
-    def maxRuntimeSeconds(self, value):
+    @minTimesliceSeconds.setter
+    def minTimesliceSeconds(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._maxRuntimeSeconds = value
+            self._minTimesliceSeconds = value
         else:
             raise TypeError(
-                'Property "maxRuntimeSeconds" of type "list<long>" set to wro'
-                'ng type'
+                'Property "minTimesliceSeconds" of type "list<long>" set to w'
+                'rong type'
             )
 
     @property
     def name(self):
-        """str: name for the ACE, must be unique within the team, max 128 char
-        acters"""
+        """str: Cluster name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def networkTypes(self):
-        """list: network types allowed on the instances, used to specify the t
-        ype of system network. ex) [infiniband, ethernet/RoCE,..]"""
-        return self._networkTypes
+    def nworkers(self):
+        """int: Number of workers"""
+        return self._nworkers
 
-    @networkTypes.setter
-    def networkTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._networkTypes = value
+    @nworkers.setter
+    def nworkers(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._nworkers = value
         else:
             raise TypeError(
-                'Property "networkTypes" of type "list<NetworkTypeEnum>" set '
-                'to wrong type'
+                'Property "nworkers" of type "list<int>" set to wrong type'
             )
 
     @property
-    def nodes(self):
-        """list: array of node names"""
-        return self._nodes
+    def options(self):
+        """list: List of env variable format options"""
+        return self._options
 
-    @nodes.setter
-    def nodes(self, value):
+    @options.setter
+    def options(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._nodes = value
+            self._options = value
         else:
             raise TypeError(
-                'Property "nodes" of type "list<str>" set to wrong type'
+                'Property "options" of type "list<Env>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: The org name of this ACE belongs to"""
-        return self._orgName
+    def pipPackages(self):
+        """list: List of all custom packages to install in the container image
+         via pip install command"""
+        return self._pipPackages
 
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    @pipPackages.setter
+    def pipPackages(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._pipPackages = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "pipPackages" of type "list<str>" set to wrong type'
             )
 
     @property
-    def provider(self):
-        """ """
-        return self._provider
+    def preemptClass(self):
+        """str: Describes the job class for preemption and scheduling behavior
+        . One of RESUMABLE, RESTARTABLE, or RUNONCE (default)."""
+        return self._preemptClass
 
-    @provider.setter
-    def provider(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._provider = value
+    @preemptClass.setter
+    def preemptClass(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._preemptClass = value
         else:
             raise TypeError(
-                'Property "provider" of type "list<AceProviderEnum>" set to w'
-                'rong type'
+                'Property "preemptClass" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def proxyServiceUrl(self):
-        """str: url that exposes proxy for this ACE"""
-        return self._proxyServiceUrl
+    def scheduler(self):
+        """ClusterComponentModifyParams: Common modification parameters for sc
+        heduler and worker"""
+        return self._scheduler
 
-    @proxyServiceUrl.setter
-    def proxyServiceUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._proxyServiceUrl = value
+    @scheduler.setter
+    def scheduler(self, value):
+        if value is not None and not isinstance(value, ClusterComponentModifyParams):
+            value = ClusterComponentModifyParams(value)
+        if (value is None) or isinstance(value, ClusterComponentModifyParams):
+            self._scheduler = value
         else:
             raise TypeError(
-                'Property "proxyServiceUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "scheduler" of type "list<ClusterComponentModifyPar'
+                'ams>" set to wrong type'
             )
 
     @property
-    def storageInfo(self):
-        """list: Array of storage information related to this ACE"""
-        return self._storageInfo
+    def schedulerPort(self):
+        """int: Scheduler port"""
+        return self._schedulerPort
 
-    @storageInfo.setter
-    def storageInfo(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageInfo = value
+    @schedulerPort.setter
+    def schedulerPort(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schedulerPort = value
         else:
             raise TypeError(
-                'Property "storageInfo" of type "list<AceStorageInfo>" set to'
-                ' wrong type'
+                'Property "schedulerPort" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def storageServiceConfig(self):
-        """list: Used to indicate the provider of the ACE"""
-        return self._storageServiceConfig
+    def systemPackages(self):
+        """list: List of all custom packages to install in the container image
+         via system package install command (apt or yum install comman
+        d)"""
+        return self._systemPackages
 
-    @storageServiceConfig.setter
-    def storageServiceConfig(self, value):
+    @systemPackages.setter
+    def systemPackages(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._storageServiceConfig = value
+            self._systemPackages = value
         else:
             raise TypeError(
-                'Property "storageServiceConfig" of type "list<StorageService'
-                'ConfigDetails>" set to wrong type'
+                'Property "systemPackages" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def storageServiceUrl(self):
-        """str: Deprecated: storage service for the ACE can be accessed at thi
-        s URL, for example: https://css.ngc.nvidia.com"""
-        return self._storageServiceUrl
+    def topologyConstraint(self):
+        """str: Constraints to set the topology for the array job"""
+        return self._topologyConstraint
 
-    @storageServiceUrl.setter
-    def storageServiceUrl(self, value):
+    @topologyConstraint.setter
+    def topologyConstraint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageServiceUrl = value
+            self._topologyConstraint = value
         else:
             raise TypeError(
-                'Property "storageServiceUrl" of type "list<str>" set to wron'
-                'g type'
-            )
-
-    @property
-    def terminationGracePeriodSeconds(self):
-        """long: The grace period, in seconds, allowed for containers to shut 
-        down gracefully. If the shutdown exceeds the grace period, the
-        n the container will be forcefully shutdown."""
-        return self._terminationGracePeriodSeconds
-
-    @terminationGracePeriodSeconds.setter
-    def terminationGracePeriodSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._terminationGracePeriodSeconds = value
-        else:
-            raise TypeError(
-                'Property "terminationGracePeriodSeconds" of type "list<long>'
-                '" set to wrong type'
+                'Property "topologyConstraint" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def topologyTypes(self):
-        """list: topology type allowed on the instances, used to specify the s
-        ystem proxomity. ex) [pack, rackName, podName, rack, megapod]"""
-        return self._topologyTypes
+    def userSecretsSpec(self):
+        """list: Specification of list of user secrets to associate to the job
+        """
+        return self._userSecretsSpec
 
-    @topologyTypes.setter
-    def topologyTypes(self, value):
+    @userSecretsSpec.setter
+    def userSecretsSpec(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._topologyTypes = value
+            self._userSecretsSpec = value
         else:
             raise TypeError(
-                'Property "topologyTypes" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "userSecretsSpec" of type "list<SecretSpec>" set to'
+                ' wrong type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    def worker(self):
+        """ClusterComponentModifyParams: Common modification parameters for sc
+        heduler and worker"""
+        return self._worker
+
+    @worker.setter
+    def worker(self, value):
+        if value is not None and not isinstance(value, ClusterComponentModifyParams):
+            value = ClusterComponentModifyParams(value)
+        if (value is None) or isinstance(value, ClusterComponentModifyParams):
+            self._worker = value
         else:
             raise TypeError(
-                'Property "type" of type "list<AceTypeEnum>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def updatedDate(self):
-        """ """
-        return self._updatedDate
-
-    @updatedDate.setter
-    def updatedDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
-        else:
-            raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "worker" of type "list<ClusterComponentModifyParams'
+                '>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowExposedPort is not None:
-            result["allowExposedPort"] = \
-                self._allowExposedPort
-        if self._clusterFederatorUrl is not None:
-            result["clusterFederatorUrl"] = \
-                self._clusterFederatorUrl
-        if self._createdBy is not None:
-            result["createdBy"] = \
-                self._createdBy
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._dataPlatformEnabled is not None:
-            result["dataPlatformEnabled"] = \
-                self._dataPlatformEnabled
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._egressIps:
-            result["egressIps"] = [
-                i.toDict() for i in self._egressIps 
-            ] if self._egressIps else []
-        if self._grpcEnabled is not None:
-            result["grpcEnabled"] = \
-                self._grpcEnabled
-        if self._health:
-            result["health"] = \
-                self._health.toDict() if self._health is not None else None
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._infinityManagerEnabled is not None:
-            result["infinityManagerEnabled"] = \
-                self._infinityManagerEnabled
-        if self._instances:
-            result["instances"] = [
-                i.toDict() for i in self._instances 
-            ] if self._instances else []
-        if self._isAutoConfigurationEnabled is not None:
-            result["isAutoConfigurationEnabled"] = \
-                self._isAutoConfigurationEnabled
-        if self._isDeleted is not None:
-            result["isDeleted"] = \
-                self._isDeleted
-        if self._maxActiveJobsPerUser is not None:
-            result["maxActiveJobsPerUser"] = \
-                self._maxActiveJobsPerUser
-        if self._maxAllowedReplicas is not None:
-            result["maxAllowedReplicas"] = \
-                self._maxAllowedReplicas
-        if self._maxRuntimeSeconds is not None:
-            result["maxRuntimeSeconds"] = \
-                self._maxRuntimeSeconds
+        if self._ace is not None:
+            result["ace"] = \
+                self._ace
+        if self._additionalOpenPorts is not None:
+            result["additionalOpenPorts"] = \
+                self._additionalOpenPorts
+        if self._additionalPortMappings:
+            result["additionalPortMappings"] = [
+                i.toDict() for i in self._additionalPortMappings 
+            ] if self._additionalPortMappings else []
+        if self._clusterLifetime is not None:
+            result["clusterLifetime"] = \
+                self._clusterLifetime
+        if self._condaPackages is not None:
+            result["condaPackages"] = \
+                self._condaPackages
+        if self._containerImage is not None:
+            result["containerImage"] = \
+                self._containerImage
+        if self._dataInput:
+            result["dataInput"] = \
+                self._dataInput.toDict() if self._dataInput is not None else None
+        if self._dataOutputMountPoint is not None:
+            result["dataOutputMountPoint"] = \
+                self._dataOutputMountPoint
+        if self._expiryDuration is not None:
+            result["expiryDuration"] = \
+                self._expiryDuration
+        if self._isLabelLocked is not None:
+            result["isLabelLocked"] = \
+                self._isLabelLocked
+        if self._isMultiNode is not None:
+            result["isMultiNode"] = \
+                self._isMultiNode
+        if self._jobOrder is not None:
+            result["jobOrder"] = \
+                self._jobOrder
+        if self._jobPriority is not None:
+            result["jobPriority"] = \
+                self._jobPriority
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._minAvailability is not None:
+            result["minAvailability"] = \
+                self._minAvailability
+        if self._minTimesliceSeconds is not None:
+            result["minTimesliceSeconds"] = \
+                self._minTimesliceSeconds
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._networkTypes is not None:
-            result["networkTypes"] = \
-                self._networkTypes
-        if self._nodes is not None:
-            result["nodes"] = \
-                self._nodes
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._provider is not None:
-            result["provider"] = \
-                self._provider
-        if self._proxyServiceUrl is not None:
-            result["proxyServiceUrl"] = \
-                self._proxyServiceUrl
-        if self._storageInfo:
-            result["storageInfo"] = [
-                i.toDict() for i in self._storageInfo 
-            ] if self._storageInfo else []
-        if self._storageServiceConfig:
-            result["storageServiceConfig"] = [
-                i.toDict() for i in self._storageServiceConfig 
-            ] if self._storageServiceConfig else []
-        if self._storageServiceUrl is not None:
-            result["storageServiceUrl"] = \
-                self._storageServiceUrl
-        if self._terminationGracePeriodSeconds is not None:
-            result["terminationGracePeriodSeconds"] = \
-                self._terminationGracePeriodSeconds
-        if self._topologyTypes is not None:
-            result["topologyTypes"] = \
-                self._topologyTypes
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
+        if self._nworkers is not None:
+            result["nworkers"] = \
+                self._nworkers
+        if self._options:
+            result["options"] = [
+                i.toDict() for i in self._options 
+            ] if self._options else []
+        if self._pipPackages is not None:
+            result["pipPackages"] = \
+                self._pipPackages
+        if self._preemptClass is not None:
+            result["preemptClass"] = \
+                self._preemptClass
+        if self._scheduler:
+            result["scheduler"] = \
+                self._scheduler.toDict() if self._scheduler is not None else None
+        if self._schedulerPort is not None:
+            result["schedulerPort"] = \
+                self._schedulerPort
+        if self._systemPackages is not None:
+            result["systemPackages"] = \
+                self._systemPackages
+        if self._topologyConstraint is not None:
+            result["topologyConstraint"] = \
+                self._topologyConstraint
+        if self._userSecretsSpec:
+            result["userSecretsSpec"] = [
+                i.toDict() for i in self._userSecretsSpec 
+            ] if self._userSecretsSpec else []
+        if self._worker:
+            result["worker"] = \
+                self._worker.toDict() if self._worker is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._storageServiceConfig is None:
+        if (self._ace is not None
+            and
+            len(self._ace) < 1):
             raise ValueError(
-                "Ace.storageServiceConfig doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._maxActiveJobsPerUser is not None
+                "ClusterModifyParams.ace: " + str(self._ace) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._schedulerPort is not None
+            and
+            self._schedulerPort < 1):
+            raise ValueError(
+                "ClusterModifyParams.schedulerPort: " + str(self._schedulerPort) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._schedulerPort is not None
+            and
+            self._schedulerPort > 65535):
+            raise ValueError(
+                "ClusterModifyParams.schedulerPort: " + str(self._schedulerPort) + 
+                " doesnt match requirement: maximum: 65535")
+        if (self._nworkers is not None
+            and
+            self._nworkers < 1):
+            raise ValueError(
+                "ClusterModifyParams.nworkers: " + str(self._nworkers) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._containerImage is not None
             and
-            self._maxActiveJobsPerUser < 0):
+            len(self._containerImage) < 1):
             raise ValueError(
-                "Ace.maxActiveJobsPerUser: " + str(self._maxActiveJobsPerUser) + 
+                "ClusterModifyParams.containerImage: " + str(self._containerImage) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._containerImage is not None
+            and
+            not re.match(
+                r"[\x20-\x7E]*",
+                 self._containerImage)):
+            raise ValueError(
+                "ClusterModifyParams.containerImage: " + str(self._containerImage) + 
+                " doesnt match requirement: pattern: [\x20-\x7E]*")
+        if (self._dataOutputMountPoint is not None
+            and
+            len(self._dataOutputMountPoint) < 1):
+            raise ValueError(
+                "ClusterModifyParams.dataOutputMountPoint: " + str(self._dataOutputMountPoint) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._clusterLifetime is not None
+            and
+            not re.match(
+                r"[0-9]+[DdHhMmSs]",
+                 self._clusterLifetime)):
+            raise ValueError(
+                "ClusterModifyParams.clusterLifetime: " + str(self._clusterLifetime) + 
+                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
+        if (self._expiryDuration is not None
+            and
+            not re.match(
+                r"[0-9]+[DdHhMmSs]",
+                 self._expiryDuration)):
+            raise ValueError(
+                "ClusterModifyParams.expiryDuration: " + str(self._expiryDuration) + 
+                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
+        if (self._minTimesliceSeconds is not None
+            and
+            self._minTimesliceSeconds < 0):
+            raise ValueError(
+                "ClusterModifyParams.minTimesliceSeconds: " + str(self._minTimesliceSeconds) + 
                 " doesnt match requirement: minimum: 0")
-        if (self._health is not None): self._health.isValid()
-        if (self._instances is not None):
-            for obj in self._instances:
-                if (obj is not None): obj.isValid()
-        if (self._storageServiceConfig is not None):
-            for obj in self._storageServiceConfig:
+        if (self._preemptClass is not None
+            and
+            len(self._preemptClass) < 1):
+            raise ValueError(
+                "ClusterModifyParams.preemptClass: " + str(self._preemptClass) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._jobOrder is not None
+            and
+            self._jobOrder < 1):
+            raise ValueError(
+                "ClusterModifyParams.jobOrder: " + str(self._jobOrder) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._jobOrder is not None
+            and
+            self._jobOrder > 99):
+            raise ValueError(
+                "ClusterModifyParams.jobOrder: " + str(self._jobOrder) + 
+                " doesnt match requirement: maximum: 99")
+        if (self._jobPriority is not None
+            and
+            len(self._jobPriority) < 1):
+            raise ValueError(
+                "ClusterModifyParams.jobPriority: " + str(self._jobPriority) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._topologyConstraint is not None
+            and
+            len(self._topologyConstraint) < 1):
+            raise ValueError(
+                "ClusterModifyParams.topologyConstraint: " + str(self._topologyConstraint) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._scheduler is not None): self._scheduler.isValid()
+        if (self._worker is not None): self._worker.isValid()
+        if (self._additionalPortMappings is not None):
+            for obj in self._additionalPortMappings:
                 if (obj is not None): obj.isValid()
-        if (self._egressIps is not None):
-            for obj in self._egressIps:
+        if (self._dataInput is not None): self._dataInput.isValid()
+        if (self._userSecretsSpec is not None):
+            for obj in self._userSecretsSpec:
                 if (obj is not None): obj.isValid()
-        if (self._storageInfo is not None):
-            for obj in self._storageInfo:
+        if (self._options is not None):
+            for obj in self._options:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AceCreateRequest.py` & `ngcbpc/data/model/ModelCreateRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,676 +6,648 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
-from .AceInstance import AceInstance
-from .AceProvider import AceProviderEnum
-from .NetworkTypeEnum import NetworkTypeEnum
-from .IPAddress import IPAddress
-from .AceType import AceTypeEnum
+from .Dataset import Dataset
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
-str(repr(NetworkTypeEnum))
-str(repr(AceProviderEnum))
-str(repr(AceTypeEnum))
-str(repr(AceInstance))
-str(repr(IPAddress))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceCreateRequest(object):
+class ModelCreateRequest(object):
+    """Request to create a new model"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowExposedPort = (
+        self.application = (
             None if not fromDict or propDict.get(
-                "allowExposedPort"
+                "application"
             ) is None
-            else propDict["allowExposedPort"])
-        self.clusterFederatorUrl = (
+            else propDict["application"])
+        self.bias = (
             None if not fromDict or propDict.get(
-                "clusterFederatorUrl"
+                "bias"
             ) is None
-            else propDict["clusterFederatorUrl"])
-        self.dataPlatformEnabled = (
+            else propDict["bias"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "dataPlatformEnabled"
+                "builtBy"
             ) is None
-            else propDict["dataPlatformEnabled"])
+            else propDict["builtBy"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.egressIps = (
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "egressIps"
+                "displayName"
             ) is None
-            else [ IPAddress(i)
-            for i in propDict["egressIps"] ])
-        self.grpcEnabled = (
+            else propDict["displayName"])
+        self.explainability = (
             None if not fromDict or propDict.get(
-                "grpcEnabled"
+                "explainability"
             ) is None
-            else propDict["grpcEnabled"])
-        self.infinityManagerEnabled = (
+            else propDict["explainability"])
+        self.framework = (
             None if not fromDict or propDict.get(
-                "infinityManagerEnabled"
+                "framework"
             ) is None
-            else propDict["infinityManagerEnabled"])
-        self.instances = (
+            else propDict["framework"])
+        self.hasPlayground = (
             None if not fromDict or propDict.get(
-                "instances"
+                "hasPlayground"
             ) is None
-            else [ AceInstance(i)
-            for i in propDict["instances"] ])
-        self.isAutoConfigurationEnabled = (
+            else propDict["hasPlayground"])
+        self.isPlaygroundEnabled = (
             None if not fromDict or propDict.get(
-                "isAutoConfigurationEnabled"
+                "isPlaygroundEnabled"
             ) is None
-            else propDict["isAutoConfigurationEnabled"])
-        self.maxActiveJobsPerUser = (
+            else propDict["isPlaygroundEnabled"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "maxActiveJobsPerUser"
+                "labels"
             ) is None
-            else propDict["maxActiveJobsPerUser"])
-        self.maxAllowedReplicas = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "maxAllowedReplicas"
+                "labelsV2"
             ) is None
-            else propDict["maxAllowedReplicas"])
-        self.maxRuntimeSeconds = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "maxRuntimeSeconds"
+                "logo"
             ) is None
-            else propDict["maxRuntimeSeconds"])
+            else propDict["logo"])
+        self.modelFormat = (
+            None if not fromDict or propDict.get(
+                "modelFormat"
+            ) is None
+            else propDict["modelFormat"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.networkTypes = (
-            None if not fromDict or propDict.get(
-                "networkTypes"
-            ) is None
-            else propDict["networkTypes"])
-        self.provider = (
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "provider"
+                "ownerName"
             ) is None
-            else propDict["provider"])
-        self.proxyServiceUrl = (
+            else propDict["ownerName"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "proxyServiceUrl"
+                "precision"
             ) is None
-            else propDict["proxyServiceUrl"])
-        self.storageServiceConfig = (
+            else propDict["precision"])
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "storageServiceConfig"
+                "privacy"
             ) is None
-            else [ StorageServiceConfigDetails(i)
-            for i in propDict["storageServiceConfig"] ])
-        self.storageServiceUrl = (
+            else propDict["privacy"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "storageServiceUrl"
+                "publicDatasetUsed"
             ) is None
-            else propDict["storageServiceUrl"])
-        self.terminationGracePeriodSeconds = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "terminationGracePeriodSeconds"
+                "publisher"
             ) is None
-            else propDict["terminationGracePeriodSeconds"])
-        self.topologyTypes = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "topologyTypes"
+                "safetyAndSecurity"
             ) is None
-            else propDict["topologyTypes"])
-        self.type = (
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "type"
+                "shortDescription"
             ) is None
-            else propDict["type"])
+            else propDict["shortDescription"])
 
     @property
-    def allowExposedPort(self):
-        """bool: Feature toggle for cli/FE to allow --ports feature"""
-        return self._allowExposedPort
+    def application(self):
+        """str: Application of the model"""
+        return self._application
 
-    @allowExposedPort.setter
-    def allowExposedPort(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowExposedPort = value
+    @application.setter
+    def application(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._application = value
         else:
             raise TypeError(
-                'Property "allowExposedPort" of type "list<bool>" set to wron'
-                'g type'
+                'Property "application" of type "list<str>" set to wrong type'
             )
 
     @property
-    def clusterFederatorUrl(self):
-        """str: URL for cluster federation service hosted inside this ACE"""
-        return self._clusterFederatorUrl
+    def bias(self):
+        """str: Text describing bias in the model"""
+        return self._bias
 
-    @clusterFederatorUrl.setter
-    def clusterFederatorUrl(self, value):
+    @bias.setter
+    def bias(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._clusterFederatorUrl = value
+            self._bias = value
         else:
             raise TypeError(
-                'Property "clusterFederatorUrl" of type "list<str>" set to wr'
-                'ong type'
+                'Property "bias" of type "list<str>" set to wrong type'
             )
 
     @property
-    def dataPlatformEnabled(self):
-        """bool: Enable flag for Data Platform. Used along Dataset Service in 
-        Create Job"""
-        return self._dataPlatformEnabled
+    def builtBy(self):
+        """str: organization that built the repository"""
+        return self._builtBy
 
-    @dataPlatformEnabled.setter
-    def dataPlatformEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._dataPlatformEnabled = value
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "dataPlatformEnabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: description of the ACE"""
+        """str: Description of the model"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def egressIps(self):
-        """list: List of trusted Egress IPs from which the outgoing node traff
-        ic will flow. If provided, cloud will accept network traffic f
-        rom nodes only if it originates from one of the IP in this list."""
-        return self._egressIps
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @egressIps.setter
-    def egressIps(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._egressIps = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "egressIps" of type "list<IPAddress>" set to wrong '
-                'type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def grpcEnabled(self):
-        """bool: Determines whether GRPC Protocol can be used in JobPortMappin
-        g for jobs scheduled on this ACE."""
-        return self._grpcEnabled
+    def explainability(self):
+        """str: Text describing explainability for this model"""
+        return self._explainability
 
-    @grpcEnabled.setter
-    def grpcEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._grpcEnabled = value
+    @explainability.setter
+    def explainability(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._explainability = value
         else:
             raise TypeError(
-                'Property "grpcEnabled" of type "list<bool>" set to wrong typ'
-                'e'
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def infinityManagerEnabled(self):
-        """bool: Enable flag of Infinity Manager for this ace"""
-        return self._infinityManagerEnabled
+    def framework(self):
+        """str: Framework used to train this model"""
+        return self._framework
 
-    @infinityManagerEnabled.setter
-    def infinityManagerEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._infinityManagerEnabled = value
+    @framework.setter
+    def framework(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._framework = value
         else:
             raise TypeError(
-                'Property "infinityManagerEnabled" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "framework" of type "list<str>" set to wrong type'
             )
 
     @property
-    def instances(self):
-        """list: Used to indicate the collection of pre-determined resources a
-        vailible for use on the ACE"""
-        return self._instances
+    def hasPlayground(self):
+        """bool: indicate if the Model has AI Playground configured"""
+        return self._hasPlayground
 
-    @instances.setter
-    def instances(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._instances = value
+    @hasPlayground.setter
+    def hasPlayground(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._hasPlayground = value
         else:
             raise TypeError(
-                'Property "instances" of type "list<AceInstance>" set to wron'
-                'g type'
+                'Property "hasPlayground" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def isAutoConfigurationEnabled(self):
-        """bool: Automatic configuration state (master selection) for this clu
-        ster. Default is true."""
-        return self._isAutoConfigurationEnabled
+    def isPlaygroundEnabled(self):
+        """bool: indicate if AI Playground is enabled in the catalog"""
+        return self._isPlaygroundEnabled
 
-    @isAutoConfigurationEnabled.setter
-    def isAutoConfigurationEnabled(self, value):
+    @isPlaygroundEnabled.setter
+    def isPlaygroundEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isAutoConfigurationEnabled = value
+            self._isPlaygroundEnabled = value
         else:
             raise TypeError(
-                'Property "isAutoConfigurationEnabled" of type "list<bool>" s'
-                'et to wrong type'
+                'Property "isPlaygroundEnabled" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def maxActiveJobsPerUser(self):
-        """int: Maximum number of jobs a user can have QUEUED or RUNNING at an
-        y given point in time on this ACE. Users are allowed to submit
-         as many jobs as they want, but they will not be sent to the scheduler
-        . Default (0) means no restrictions."""
-        return self._maxActiveJobsPerUser
+    def labels(self):
+        """ """
+        return self._labels
 
-    @maxActiveJobsPerUser.setter
-    def maxActiveJobsPerUser(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._maxActiveJobsPerUser = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "maxActiveJobsPerUser" of type "list<int>" set to w'
-                'rong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxAllowedReplicas(self):
-        """int: Maximum number of replicas/tasks that are allowed for multinod
-        e job submission to the ACE"""
-        return self._maxAllowedReplicas
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @maxAllowedReplicas.setter
-    def maxAllowedReplicas(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._maxAllowedReplicas = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "maxAllowedReplicas" of type "list<int>" set to wro'
-                'ng type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxRuntimeSeconds(self):
-        """long: The maximum runtime, in seconds, that any jobs can have on th
-        e ACE."""
-        return self._maxRuntimeSeconds
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @maxRuntimeSeconds.setter
-    def maxRuntimeSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._maxRuntimeSeconds = value
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
         else:
             raise TypeError(
-                'Property "maxRuntimeSeconds" of type "list<long>" set to wro'
-                'ng type'
+                'Property "logo" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def modelFormat(self):
+        """str: Format of the model"""
+        return self._modelFormat
+
+    @modelFormat.setter
+    def modelFormat(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._modelFormat = value
+        else:
+            raise TypeError(
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: name for the ACE, must be uniq within the team, max 32 charact
-        ers"""
+        """str: Unique name of the model"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def networkTypes(self):
-        """list: network types allowed on the instances, used to specify the t
-        ype of system network. ex) [infiniband, ethernet/RoCE,..]"""
-        return self._networkTypes
+    def ownerName(self):
+        """str: Name of the user who owns this model"""
+        return self._ownerName
 
-    @networkTypes.setter
-    def networkTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._networkTypes = value
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "networkTypes" of type "list<NetworkTypeEnum>" set '
-                'to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def provider(self):
-        """ """
-        return self._provider
+    def precision(self):
+        """str: Precision this model was trained with"""
+        return self._precision
 
-    @provider.setter
-    def provider(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._provider = value
+    @precision.setter
+    def precision(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._precision = value
         else:
             raise TypeError(
-                'Property "provider" of type "list<AceProviderEnum>" set to w'
-                'rong type'
+                'Property "precision" of type "list<str>" set to wrong type'
             )
 
     @property
-    def proxyServiceUrl(self):
-        """str: url that exposes proxy for this ACE"""
-        return self._proxyServiceUrl
+    def privacy(self):
+        """str: Text describing the privacy for this model"""
+        return self._privacy
 
-    @proxyServiceUrl.setter
-    def proxyServiceUrl(self, value):
+    @privacy.setter
+    def privacy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._proxyServiceUrl = value
+            self._privacy = value
         else:
             raise TypeError(
-                'Property "proxyServiceUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "privacy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageServiceConfig(self):
-        """list: Used to indicate the provider of the ACE"""
-        return self._storageServiceConfig
+    def publicDatasetUsed(self):
+        """ """
+        return self._publicDatasetUsed
 
-    @storageServiceConfig.setter
-    def storageServiceConfig(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageServiceConfig = value
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "storageServiceConfig" of type "list<StorageService'
-                'ConfigDetails>" set to wrong type'
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
+                'wrong type'
             )
 
     @property
-    def storageServiceUrl(self):
-        """str: DEPRECATED storage service for the ACE can be accessed at this
-         URL, for example: https://css.ngc.nvidia.com"""
-        return self._storageServiceUrl
+    def publisher(self):
+        """str: organization that published the repository"""
+        return self._publisher
 
-    @storageServiceUrl.setter
-    def storageServiceUrl(self, value):
+    @publisher.setter
+    def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageServiceUrl = value
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "storageServiceUrl" of type "list<str>" set to wron'
-                'g type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def terminationGracePeriodSeconds(self):
-        """long: The grace period, in seconds, allowed for containers to shut 
-        down gracefully. If the shutdown exceeds the grace period, the
-        n the container will be forcefully shutdown."""
-        return self._terminationGracePeriodSeconds
-
-    @terminationGracePeriodSeconds.setter
-    def terminationGracePeriodSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._terminationGracePeriodSeconds = value
-        else:
-            raise TypeError(
-                'Property "terminationGracePeriodSeconds" of type "list<long>'
-                '" set to wrong type'
-            )
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the model"""
+        return self._safetyAndSecurity
 
-    @property
-    def topologyTypes(self):
-        """list: topology type allowed on the instances, used to specify the s
-        ystem proxomity. ex) [pack, rackName, podName, rack, megapod]"""
-        return self._topologyTypes
-
-    @topologyTypes.setter
-    def topologyTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._topologyTypes = value
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "topologyTypes" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def shortDescription(self):
+        """str: Short description of the model"""
+        return self._shortDescription
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "type" of type "list<AceTypeEnum>" set to wrong typ'
-                'e'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowExposedPort is not None:
-            result["allowExposedPort"] = \
-                self._allowExposedPort
-        if self._clusterFederatorUrl is not None:
-            result["clusterFederatorUrl"] = \
-                self._clusterFederatorUrl
-        if self._dataPlatformEnabled is not None:
-            result["dataPlatformEnabled"] = \
-                self._dataPlatformEnabled
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._egressIps:
-            result["egressIps"] = [
-                i.toDict() for i in self._egressIps 
-            ] if self._egressIps else []
-        if self._grpcEnabled is not None:
-            result["grpcEnabled"] = \
-                self._grpcEnabled
-        if self._infinityManagerEnabled is not None:
-            result["infinityManagerEnabled"] = \
-                self._infinityManagerEnabled
-        if self._instances:
-            result["instances"] = [
-                i.toDict() for i in self._instances 
-            ] if self._instances else []
-        if self._isAutoConfigurationEnabled is not None:
-            result["isAutoConfigurationEnabled"] = \
-                self._isAutoConfigurationEnabled
-        if self._maxActiveJobsPerUser is not None:
-            result["maxActiveJobsPerUser"] = \
-                self._maxActiveJobsPerUser
-        if self._maxAllowedReplicas is not None:
-            result["maxAllowedReplicas"] = \
-                self._maxAllowedReplicas
-        if self._maxRuntimeSeconds is not None:
-            result["maxRuntimeSeconds"] = \
-                self._maxRuntimeSeconds
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._framework is not None:
+            result["framework"] = \
+                self._framework
+        if self._hasPlayground is not None:
+            result["hasPlayground"] = \
+                self._hasPlayground
+        if self._isPlaygroundEnabled is not None:
+            result["isPlaygroundEnabled"] = \
+                self._isPlaygroundEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._networkTypes is not None:
-            result["networkTypes"] = \
-                self._networkTypes
-        if self._provider is not None:
-            result["provider"] = \
-                self._provider
-        if self._proxyServiceUrl is not None:
-            result["proxyServiceUrl"] = \
-                self._proxyServiceUrl
-        if self._storageServiceConfig:
-            result["storageServiceConfig"] = [
-                i.toDict() for i in self._storageServiceConfig 
-            ] if self._storageServiceConfig else []
-        if self._storageServiceUrl is not None:
-            result["storageServiceUrl"] = \
-                self._storageServiceUrl
-        if self._terminationGracePeriodSeconds is not None:
-            result["terminationGracePeriodSeconds"] = \
-                self._terminationGracePeriodSeconds
-        if self._topologyTypes is not None:
-            result["topologyTypes"] = \
-                self._topologyTypes
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "AceCreateRequest.name doesnt match requirement:" 
+                "ModelCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
         if (self._name is not None
             and
-            len(self._name) < 2):
+            len(self._name) < 1):
             raise ValueError(
-                "AceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
+                "ModelCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
         if (self._name is not None
             and
-            len(self._name) > 32):
+            len(self._name) > 64):
             raise ValueError(
-                "AceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 32")
+                "ModelCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
         if (self._name is not None
             and
             not re.match(
-                r"^[a-zA-Z\d_-]*$",
+                r"^[a-z][a-z\d_-]*$",
                  self._name)):
             raise ValueError(
-                "AceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d_-]*$")
-        if (self._description is not None
+                "ModelCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: ^[a-z][a-z\d_-]*$")
+        if (self._ownerName is not None
             and
-            len(self._description) > 255):
+            len(self._ownerName) > 255):
             raise ValueError(
-                "AceCreateRequest.description: " + str(self._description) + 
+                "ModelCreateRequest.ownerName: " + str(self._ownerName) + 
                 " doesnt match requirement: maxLength: 255")
-        if self._storageServiceConfig is None:
+        if self._framework is None:
             raise ValueError(
-                "AceCreateRequest.storageServiceConfig doesnt match requirement:" 
+                "ModelCreateRequest.framework doesnt match requirement:" 
                 "required: True"
             )
-        if self._type is None:
+        if (self._framework is not None
+            and
+            len(self._framework) > 255):
             raise ValueError(
-                "AceCreateRequest.type doesnt match requirement:" 
-                "required: True"
-            )
-        if self._provider is None:
+                "ModelCreateRequest.framework: " + str(self._framework) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._modelFormat is not None
+            and
+            len(self._modelFormat) > 255):
             raise ValueError(
-                "AceCreateRequest.provider doesnt match requirement:" 
-                "required: True"
-            )
-        if self._instances is None:
+                "ModelCreateRequest.modelFormat: " + str(self._modelFormat) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._shortDescription is not None
+            and
+            len(self._shortDescription) > 255):
             raise ValueError(
-                "AceCreateRequest.instances doesnt match requirement:" 
+                "ModelCreateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
+            and
+            len(self._displayName) < 2):
+            raise ValueError(
+                "ModelCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "ModelCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if self._precision is None:
+            raise ValueError(
+                "ModelCreateRequest.precision doesnt match requirement:" 
                 "required: True"
             )
-        if (self._instances is not None
+        if (self._precision is not None
             and
-            len(self._instances) < 1):
+            len(self._precision) > 255):
             raise ValueError(
-                "AceCreateRequest.instances: " + str(self._instances) + 
-                " doesnt match requirement: minItems: 1")
-        if (self._maxRuntimeSeconds is not None
+                "ModelCreateRequest.precision: " + str(self._precision) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._application is not None
             and
-            self._maxRuntimeSeconds < 0):
+            len(self._application) > 255):
             raise ValueError(
-                "AceCreateRequest.maxRuntimeSeconds: " + str(self._maxRuntimeSeconds) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._terminationGracePeriodSeconds is not None
+                "ModelCreateRequest.application: " + str(self._application) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._logo is not None
             and
-            self._terminationGracePeriodSeconds < 0):
+            len(self._logo) > 255):
             raise ValueError(
-                "AceCreateRequest.terminationGracePeriodSeconds: " + str(self._terminationGracePeriodSeconds) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._maxActiveJobsPerUser is not None
+                "ModelCreateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._builtBy is not None
             and
-            self._maxActiveJobsPerUser < 0):
+            len(self._builtBy) > 255):
             raise ValueError(
-                "AceCreateRequest.maxActiveJobsPerUser: " + str(self._maxActiveJobsPerUser) + 
-                " doesnt match requirement: minimum: 0")
-        if self._maxAllowedReplicas is None:
+                "ModelCreateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
+            and
+            len(self._publisher) > 255):
             raise ValueError(
-                "AceCreateRequest.maxAllowedReplicas doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._storageServiceConfig is not None):
-            for obj in self._storageServiceConfig:
-                if (obj is not None): obj.isValid()
-        if (self._egressIps is not None):
-            for obj in self._egressIps:
-                if (obj is not None): obj.isValid()
-        if (self._instances is not None):
-            for obj in self._instances:
-                if (obj is not None): obj.isValid()
+                "ModelCreateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
         return True
```

## Comparing `ngccli/data/api/AceHealth.py` & `organization/data/sms/SecretNameKV.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,85 +6,105 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .KV import KV
 
 # Unused import over optimization prevention
+str(repr(KV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceHealth(object):
-    """Describes the health of the ACE"""
+class SecretNameKV(object):
+    """Definition of a secret name and KV pairs"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.percentage = (
+        self.kv = (
             None if not fromDict or propDict.get(
-                "percentage"
+                "kv"
             ) is None
-            else propDict["percentage"])
-        self.status = (
+            else [ KV(i)
+            for i in propDict["kv"] ])
+        self.name = (
             None if not fromDict or propDict.get(
-                "status"
+                "name"
             ) is None
-            else propDict["status"])
+            else propDict["name"])
 
     @property
-    def percentage(self):
-        """float: The percentage of healthy node(s) in the ACE"""
-        return self._percentage
-
-    @percentage.setter
-    def percentage(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._percentage = value
+    def kv(self):
+        """ """
+        return self._kv
+
+    @kv.setter
+    def kv(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._kv = value
         else:
             raise TypeError(
-                'Property "percentage" of type "list<float>" set to wrong typ'
-                'e'
+                'Property "kv" of type "list<KV>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """StatusEnum: Used to represent overall health status of the ACE"""
-        return self._status
-
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    def name(self):
+        """str: Secret name"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "status" of type "list<StatusEnum>" set to wrong ty'
-                'pe'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
-    StatusEnum=["UNKNOWN","OK","WARNING","ERROR",]
-    str(repr(StatusEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._percentage is not None:
-            result["percentage"] = \
-                self._percentage
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._kv:
+            result["kv"] = [
+                i.toDict() for i in self._kv 
+            ] if self._kv else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "SecretNameKV.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "SecretNameKV.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._kv is None:
+            raise ValueError(
+                "SecretNameKV.kv doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._kv is not None):
+            for obj in self._kv:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AceInstance.py` & `ngcbpc/data/registry/Repository.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,855 +6,834 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobArrayTypeEnum import JobArrayTypeEnum
-from .AceInstanceTypeEnum import AceInstanceTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
+from .AccessTypeEnum import AccessTypeEnum
+from .ImageArchitectureVariant import ImageArchitectureVariant
 
 # Unused import over optimization prevention
-str(repr(JobArrayTypeEnum))
-str(repr(AceInstanceTypeEnum))
+str(repr(ImageArchitectureVariant))
+str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceInstance(object):
-    """ACE instance is a collection of pre-determined resources"""
+class Repository(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.GPUType = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "GPUType"
+                "accessType"
             ) is None
-            else propDict["GPUType"])
-        self.allowMultinode = (
+            else propDict["accessType"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "allowMultinode"
+                "builtBy"
             ) is None
-            else propDict["allowMultinode"])
-        self.allowMultinodePreemptable = (
+            else propDict["builtBy"])
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "allowMultinodePreemptable"
+                "canGuestPull"
             ) is None
-            else propDict["allowMultinodePreemptable"])
-        self.architecture = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "architecture"
+                "canPublicList"
             ) is None
-            else propDict["architecture"])
-        self.cpuCores = (
+            else propDict["canPublicList"])
+        self.categories = (
             None if not fromDict or propDict.get(
-                "cpuCores"
+                "categories"
             ) is None
-            else propDict["cpuCores"])
+            else propDict["categories"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.gpuMemory = (
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "gpuMemory"
+                "displayName"
             ) is None
-            else propDict["gpuMemory"])
-        self.gpus = (
+            else propDict["displayName"])
+        self.hasSignedTag = (
             None if not fromDict or propDict.get(
-                "gpus"
+                "hasSignedTag"
             ) is None
-            else propDict["gpus"])
-        self.infinityManagerResourceType = (
+            else propDict["hasSignedTag"])
+        self.isFavourite = (
             None if not fromDict or propDict.get(
-                "infinityManagerResourceType"
+                "isFavourite"
             ) is None
-            else propDict["infinityManagerResourceType"])
-        self.isLegacy = (
+            else propDict["isFavourite"])
+        self.isMultiArchitecture = (
             None if not fromDict or propDict.get(
-                "isLegacy"
+                "isMultiArchitecture"
             ) is None
-            else propDict["isLegacy"])
-        self.maxGPUMemBandWidth = (
+            else propDict["isMultiArchitecture"])
+        self.isMultinodeEnabled = (
             None if not fromDict or propDict.get(
-                "maxGPUMemBandWidth"
+                "isMultinodeEnabled"
             ) is None
-            else propDict["maxGPUMemBandWidth"])
-        self.maxNvlinkBandWidth = (
+            else propDict["isMultinodeEnabled"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "maxNvlinkBandWidth"
+                "isPublic"
             ) is None
-            else propDict["maxNvlinkBandWidth"])
-        self.maxPcieReadBandWidth = (
+            else propDict["isPublic"])
+        self.isReadOnly = (
             None if not fromDict or propDict.get(
-                "maxPcieReadBandWidth"
+                "isReadOnly"
             ) is None
-            else propDict["maxPcieReadBandWidth"])
-        self.maxPcieWriteBandWidth = (
+            else propDict["isReadOnly"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "maxPcieWriteBandWidth"
+                "labels"
             ) is None
-            else propDict["maxPcieWriteBandWidth"])
-        self.maxPowerLimit = (
+            else propDict["labels"])
+        self.latestArchitectureVariants = (
             None if not fromDict or propDict.get(
-                "maxPowerLimit"
+                "latestArchitectureVariants"
             ) is None
-            else propDict["maxPowerLimit"])
-        self.migSlice = (
+            else [ ImageArchitectureVariant(i)
+            for i in propDict["latestArchitectureVariants"] ])
+        self.latestImageSize = (
             None if not fromDict or propDict.get(
-                "migSlice"
+                "latestImageSize"
             ) is None
-            else propDict["migSlice"])
-        self.migTotalSlice = (
+            else propDict["latestImageSize"])
+        self.latestTag = (
             None if not fromDict or propDict.get(
-                "migTotalSlice"
+                "latestTag"
             ) is None
-            else propDict["migTotalSlice"])
-        self.multiNodeSupportedArrayTypes = (
+            else propDict["latestTag"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "multiNodeSupportedArrayTypes"
+                "logo"
             ) is None
-            else propDict["multiNodeSupportedArrayTypes"])
-        self.multiNodeSupportedDefaultArrayType = (
+            else propDict["logo"])
+        self.manualScanEnabled = (
             None if not fromDict or propDict.get(
-                "multiNodeSupportedDefaultArrayType"
+                "manualScanEnabled"
             ) is None
-            else propDict["multiNodeSupportedDefaultArrayType"])
+            else propDict["manualScanEnabled"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.os = (
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "os"
+                "namespace"
             ) is None
-            else propDict["os"])
-        self.raidFileSystemGB = (
+            else propDict["namespace"])
+        self.productNames = (
             None if not fromDict or propDict.get(
-                "raidFileSystemGB"
+                "productNames"
             ) is None
-            else propDict["raidFileSystemGB"])
-        self.rootFileSystemGB = (
+            else propDict["productNames"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "rootFileSystemGB"
+                "publisher"
             ) is None
-            else propDict["rootFileSystemGB"])
-        self.systemMemory = (
+            else propDict["publisher"])
+        self.scanEnabled = (
             None if not fromDict or propDict.get(
-                "systemMemory"
+                "scanEnabled"
             ) is None
-            else propDict["systemMemory"])
-        self.type = (
+            else propDict["scanEnabled"])
+        self.sharedWithOrgs = (
             None if not fromDict or propDict.get(
-                "type"
+                "sharedWithOrgs"
             ) is None
-            else propDict["type"])
-        self.variant = (
+            else propDict["sharedWithOrgs"])
+        self.sharedWithTeams = (
             None if not fromDict or propDict.get(
-                "variant"
+                "sharedWithTeams"
             ) is None
-            else propDict["variant"])
+            else propDict["sharedWithTeams"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
+        self.showScanResults = (
+            None if not fromDict or propDict.get(
+                "showScanResults"
+            ) is None
+            else propDict["showScanResults"])
+        self.systemLabels = (
+            None if not fromDict or propDict.get(
+                "systemLabels"
+            ) is None
+            else propDict["systemLabels"])
+        self.tags = (
+            None if not fromDict or propDict.get(
+                "tags"
+            ) is None
+            else propDict["tags"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
 
     @property
-    def GPUType(self):
-        """GPUTypeEnum: Type of GPU architecture"""
-        return self._GPUType
+    def accessType(self):
+        """ """
+        return self._accessType
 
-    @GPUType.setter
-    def GPUType(self, value):
+    @accessType.setter
+    def accessType(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._GPUType = value
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "GPUType" of type "list<GPUTypeEnum>" set to wrong '
-                'type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
-    GPUTypeEnum=["PASCAL","VOLTA",]
-    str(repr(GPUTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def allowMultinode(self):
-        """bool: indicates if the instance can be used to start a multinode jo
-        b. Default is false"""
-        return self._allowMultinode
+    def builtBy(self):
+        """str: organization that built the repository"""
+        return self._builtBy
 
-    @allowMultinode.setter
-    def allowMultinode(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowMultinode = value
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "allowMultinode" of type "list<bool>" set to wrong '
-                'type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowMultinodePreemptable(self):
-        """bool: indicates if the instance can be used to start a preemptable 
-        multinode job. Default is false"""
-        return self._allowMultinodePreemptable
+    def canGuestPull(self):
+        """ """
+        return self._canGuestPull
 
-    @allowMultinodePreemptable.setter
-    def allowMultinodePreemptable(self, value):
+    @canGuestPull.setter
+    def canGuestPull(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowMultinodePreemptable = value
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "allowMultinodePreemptable" of type "list<bool>" se'
-                't to wrong type'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def architecture(self):
-        """str: The architecture field specifies the CPU architecture, for exa
-        mple amd64 or ppc64le."""
-        return self._architecture
+    def canPublicList(self):
+        """ """
+        return self._canPublicList
 
-    @architecture.setter
-    def architecture(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._architecture = value
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "architecture" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def cpuCores(self):
-        """float: Number of CPU cores for a job, user can specify 1.5 cores he
-        re"""
-        return self._cpuCores
-
-    @cpuCores.setter
-    def cpuCores(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._cpuCores = value
+    def categories(self):
+        """list: list of categories the repository belongs to"""
+        return self._categories
+
+    @categories.setter
+    def categories(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._categories = value
         else:
             raise TypeError(
-                'Property "cpuCores" of type "list<float>" set to wrong type'
+                'Property "categories" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Human Readable description of the ACE Instance"""
+        """str: description of the repo"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpuMemory(self):
-        """float: gpu memory in MB"""
-        return self._gpuMemory
+    def displayName(self):
+        """ """
+        return self._displayName
 
-    @gpuMemory.setter
-    def gpuMemory(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._gpuMemory = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "gpuMemory" of type "list<float>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpus(self):
-        """int: number of GPUs for a job"""
-        return self._gpus
+    def hasSignedTag(self):
+        """bool: whether the container has any signed tags"""
+        return self._hasSignedTag
 
-    @gpus.setter
-    def gpus(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._gpus = value
+    @hasSignedTag.setter
+    def hasSignedTag(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._hasSignedTag = value
         else:
             raise TypeError(
-                'Property "gpus" of type "list<int>" set to wrong type'
+                'Property "hasSignedTag" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def infinityManagerResourceType(self):
-        """str: resource type managed by infinity manager, which is mapped fro
-        m name field, namely ace instance name, in this object"""
-        return self._infinityManagerResourceType
+    def isFavourite(self):
+        """ """
+        return self._isFavourite
 
-    @infinityManagerResourceType.setter
-    def infinityManagerResourceType(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._infinityManagerResourceType = value
+    @isFavourite.setter
+    def isFavourite(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isFavourite = value
         else:
             raise TypeError(
-                'Property "infinityManagerResourceType" of type "list<str>" s'
-                'et to wrong type'
+                'Property "isFavourite" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def isLegacy(self):
-        """bool: mark if this instance is an legacy instance or not. Legacy in
-        stance are supported for backward compability purposes."""
-        return self._isLegacy
+    def isMultiArchitecture(self):
+        """ """
+        return self._isMultiArchitecture
 
-    @isLegacy.setter
-    def isLegacy(self, value):
+    @isMultiArchitecture.setter
+    def isMultiArchitecture(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isLegacy = value
+            self._isMultiArchitecture = value
         else:
             raise TypeError(
-                'Property "isLegacy" of type "list<bool>" set to wrong type'
+                'Property "isMultiArchitecture" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def maxGPUMemBandWidth(self):
-        """float: Max GPU memory bandwidth"""
-        return self._maxGPUMemBandWidth
+    def isMultinodeEnabled(self):
+        """ """
+        return self._isMultinodeEnabled
 
-    @maxGPUMemBandWidth.setter
-    def maxGPUMemBandWidth(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._maxGPUMemBandWidth = value
+    @isMultinodeEnabled.setter
+    def isMultinodeEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isMultinodeEnabled = value
         else:
             raise TypeError(
-                'Property "maxGPUMemBandWidth" of type "list<float>" set to w'
-                'rong type'
+                'Property "isMultinodeEnabled" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def maxNvlinkBandWidth(self):
-        """float: Max NVLink bandwidth in GB/s"""
-        return self._maxNvlinkBandWidth
-
-    @maxNvlinkBandWidth.setter
-    def maxNvlinkBandWidth(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._maxNvlinkBandWidth = value
+    def isPublic(self):
+        """ """
+        return self._isPublic
+
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
         else:
             raise TypeError(
-                'Property "maxNvlinkBandWidth" of type "list<float>" set to w'
-                'rong type'
+                'Property "isPublic" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def maxPcieReadBandWidth(self):
-        """float: Max PCIE Read bandwidth in GB/s"""
-        return self._maxPcieReadBandWidth
+    def isReadOnly(self):
+        """ """
+        return self._isReadOnly
 
-    @maxPcieReadBandWidth.setter
-    def maxPcieReadBandWidth(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._maxPcieReadBandWidth = value
+    @isReadOnly.setter
+    def isReadOnly(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isReadOnly = value
         else:
             raise TypeError(
-                'Property "maxPcieReadBandWidth" of type "list<float>" set to'
-                ' wrong type'
+                'Property "isReadOnly" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def maxPcieWriteBandWidth(self):
-        """float: Max PCIE Write bandwidth in GB/s"""
-        return self._maxPcieWriteBandWidth
+    def labels(self):
+        """list: list of user defined labels on the repository"""
+        return self._labels
 
-    @maxPcieWriteBandWidth.setter
-    def maxPcieWriteBandWidth(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._maxPcieWriteBandWidth = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "maxPcieWriteBandWidth" of type "list<float>" set t'
-                'o wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxPowerLimit(self):
-        """float: Max Power in Watts"""
-        return self._maxPowerLimit
+    def latestArchitectureVariants(self):
+        """list: list of latest tag arch variants which include their specific
+         metadata"""
+        return self._latestArchitectureVariants
 
-    @maxPowerLimit.setter
-    def maxPowerLimit(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._maxPowerLimit = value
+    @latestArchitectureVariants.setter
+    def latestArchitectureVariants(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._latestArchitectureVariants = value
         else:
             raise TypeError(
-                'Property "maxPowerLimit" of type "list<float>" set to wrong '
-                'type'
+                'Property "latestArchitectureVariants" of type "list<ImageArc'
+                'hitectureVariant>" set to wrong type'
             )
 
     @property
-    def migSlice(self):
-        """int: MIG Slice that'll be used in this ACE Instance"""
-        return self._migSlice
+    def latestImageSize(self):
+        """long: size of the latest image, in bytes"""
+        return self._latestImageSize
 
-    @migSlice.setter
-    def migSlice(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._migSlice = value
+    @latestImageSize.setter
+    def latestImageSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._latestImageSize = value
         else:
             raise TypeError(
-                'Property "migSlice" of type "list<int>" set to wrong type'
+                'Property "latestImageSize" of type "list<long>" set to wrong'
+                ' type'
             )
 
     @property
-    def migTotalSlice(self):
-        """int: Total MIG Slice. Default is 7"""
-        return self._migTotalSlice
+    def latestTag(self):
+        """str: latest tag"""
+        return self._latestTag
 
-    @migTotalSlice.setter
-    def migTotalSlice(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._migTotalSlice = value
+    @latestTag.setter
+    def latestTag(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._latestTag = value
         else:
             raise TypeError(
-                'Property "migTotalSlice" of type "list<int>" set to wrong ty'
-                'pe'
+                'Property "latestTag" of type "list<str>" set to wrong type'
             )
 
     @property
-    def multiNodeSupportedArrayTypes(self):
-        """list: array types of multi node job allowed on the instances, used 
-        to specify the array type of multi node job. ex) [MPI, PARALLE
-        L, PYTORCH, HOROVOD]"""
-        return self._multiNodeSupportedArrayTypes
+    def logo(self):
+        """ """
+        return self._logo
 
-    @multiNodeSupportedArrayTypes.setter
-    def multiNodeSupportedArrayTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._multiNodeSupportedArrayTypes = value
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
         else:
             raise TypeError(
-                'Property "multiNodeSupportedArrayTypes" of type "list<JobArr'
-                'ayTypeEnum>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def multiNodeSupportedDefaultArrayType(self):
-        """JobArrayTypeEnum: Type of array job."""
-        return self._multiNodeSupportedDefaultArrayType
+    def manualScanEnabled(self):
+        """bool: depending on settings, to allow manual trigger of scan from U
+        I"""
+        return self._manualScanEnabled
 
-    @multiNodeSupportedDefaultArrayType.setter
-    def multiNodeSupportedDefaultArrayType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._multiNodeSupportedDefaultArrayType = value
+    @manualScanEnabled.setter
+    def manualScanEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._manualScanEnabled = value
         else:
             raise TypeError(
-                'Property "multiNodeSupportedDefaultArrayType" of type "list<'
-                'JobArrayTypeEnum>" set to wrong type'
+                'Property "manualScanEnabled" of type "list<bool>" set to wro'
+                'ng type'
             )
 
     @property
     def name(self):
-        """str: name of ace instance, must be unique within the ACE"""
+        """ """
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def os(self):
-        """str: The os field specifies the operating system, for example linux
-         or windows."""
-        return self._os
+    def namespace(self):
+        """ """
+        return self._namespace
 
-    @os.setter
-    def os(self, value):
+    @namespace.setter
+    def namespace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._os = value
+            self._namespace = value
+        else:
+            raise TypeError(
+                'Property "namespace" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
+
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
+        else:
+            raise TypeError(
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
+            )
+
+    @property
+    def publisher(self):
+        """str: organization that published the repository"""
+        return self._publisher
+
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
+        else:
+            raise TypeError(
+                'Property "publisher" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def scanEnabled(self):
+        """bool: whether images in this repository should be scanned"""
+        return self._scanEnabled
+
+    @scanEnabled.setter
+    def scanEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._scanEnabled = value
+        else:
+            raise TypeError(
+                'Property "scanEnabled" of type "list<bool>" set to wrong typ'
+                'e'
+            )
+
+    @property
+    def sharedWithOrgs(self):
+        """list: list org names with which this repository is shared"""
+        return self._sharedWithOrgs
+
+    @sharedWithOrgs.setter
+    def sharedWithOrgs(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._sharedWithOrgs = value
+        else:
+            raise TypeError(
+                'Property "sharedWithOrgs" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def sharedWithTeams(self):
+        """list: list teams (in format 'org/team') with which this repository 
+        is shared"""
+        return self._sharedWithTeams
+
+    @sharedWithTeams.setter
+    def sharedWithTeams(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._sharedWithTeams = value
         else:
             raise TypeError(
-                'Property "os" of type "list<str>" set to wrong type'
+                'Property "sharedWithTeams" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def raidFileSystemGB(self):
-        """int: Total GB allocated for RAID filesystem (/raid)"""
-        return self._raidFileSystemGB
+    def shortDescription(self):
+        """str: description of the repo"""
+        return self._shortDescription
 
-    @raidFileSystemGB.setter
-    def raidFileSystemGB(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._raidFileSystemGB = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "raidFileSystemGB" of type "list<int>" set to wrong'
+                'Property "shortDescription" of type "list<str>" set to wrong'
                 ' type'
             )
 
     @property
-    def rootFileSystemGB(self):
-        """int: Total GB allocated for Root filesystem (/)"""
-        return self._rootFileSystemGB
-
-    @rootFileSystemGB.setter
-    def rootFileSystemGB(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._rootFileSystemGB = value
+    def showScanResults(self):
+        """bool: depending on settings, to allow UI to show Security Scan Resu
+        lts or not"""
+        return self._showScanResults
+
+    @showScanResults.setter
+    def showScanResults(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._showScanResults = value
         else:
             raise TypeError(
-                'Property "rootFileSystemGB" of type "list<int>" set to wrong'
+                'Property "showScanResults" of type "list<bool>" set to wrong'
                 ' type'
             )
 
     @property
-    def systemMemory(self):
-        """float: system memory in MB"""
-        return self._systemMemory
-
-    @systemMemory.setter
-    def systemMemory(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._systemMemory = value
+    def systemLabels(self):
+        """list: list of system defined labels on the repository, can not be e
+        dited"""
+        return self._systemLabels
+
+    @systemLabels.setter
+    def systemLabels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._systemLabels = value
         else:
             raise TypeError(
-                'Property "systemMemory" of type "list<float>" set to wrong t'
-                'ype'
+                'Property "systemLabels" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def type(self):
-        """AceInstanceTypeEnum: The type of ACE Instance."""
-        return self._type
+    def tags(self):
+        """list: list of image tags in the repository"""
+        return self._tags
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @tags.setter
+    def tags(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._tags = value
         else:
             raise TypeError(
-                'Property "type" of type "list<AceInstanceTypeEnum>" set to w'
-                'rong type'
+                'Property "tags" of type "list<str>" set to wrong type'
             )
 
     @property
-    def variant(self):
-        """str: The optional variant field specifies a variant of the CPU, for
-         example armv6l to specify a particular CPU variant of the ARM
-         CPU."""
-        return self._variant
+    def updatedDate(self):
+        """str: ISO-8601 format date when the repository was last updated"""
+        return self._updatedDate
 
-    @variant.setter
-    def variant(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._variant = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "variant" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._GPUType is not None:
-            result["GPUType"] = \
-                self._GPUType
-        if self._allowMultinode is not None:
-            result["allowMultinode"] = \
-                self._allowMultinode
-        if self._allowMultinodePreemptable is not None:
-            result["allowMultinodePreemptable"] = \
-                self._allowMultinodePreemptable
-        if self._architecture is not None:
-            result["architecture"] = \
-                self._architecture
-        if self._cpuCores is not None:
-            result["cpuCores"] = \
-                self._cpuCores
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._categories is not None:
+            result["categories"] = \
+                self._categories
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._gpuMemory is not None:
-            result["gpuMemory"] = \
-                self._gpuMemory
-        if self._gpus is not None:
-            result["gpus"] = \
-                self._gpus
-        if self._infinityManagerResourceType is not None:
-            result["infinityManagerResourceType"] = \
-                self._infinityManagerResourceType
-        if self._isLegacy is not None:
-            result["isLegacy"] = \
-                self._isLegacy
-        if self._maxGPUMemBandWidth is not None:
-            result["maxGPUMemBandWidth"] = \
-                self._maxGPUMemBandWidth
-        if self._maxNvlinkBandWidth is not None:
-            result["maxNvlinkBandWidth"] = \
-                self._maxNvlinkBandWidth
-        if self._maxPcieReadBandWidth is not None:
-            result["maxPcieReadBandWidth"] = \
-                self._maxPcieReadBandWidth
-        if self._maxPcieWriteBandWidth is not None:
-            result["maxPcieWriteBandWidth"] = \
-                self._maxPcieWriteBandWidth
-        if self._maxPowerLimit is not None:
-            result["maxPowerLimit"] = \
-                self._maxPowerLimit
-        if self._migSlice is not None:
-            result["migSlice"] = \
-                self._migSlice
-        if self._migTotalSlice is not None:
-            result["migTotalSlice"] = \
-                self._migTotalSlice
-        if self._multiNodeSupportedArrayTypes is not None:
-            result["multiNodeSupportedArrayTypes"] = \
-                self._multiNodeSupportedArrayTypes
-        if self._multiNodeSupportedDefaultArrayType is not None:
-            result["multiNodeSupportedDefaultArrayType"] = \
-                self._multiNodeSupportedDefaultArrayType
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._hasSignedTag is not None:
+            result["hasSignedTag"] = \
+                self._hasSignedTag
+        if self._isFavourite is not None:
+            result["isFavourite"] = \
+                self._isFavourite
+        if self._isMultiArchitecture is not None:
+            result["isMultiArchitecture"] = \
+                self._isMultiArchitecture
+        if self._isMultinodeEnabled is not None:
+            result["isMultinodeEnabled"] = \
+                self._isMultinodeEnabled
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._isReadOnly is not None:
+            result["isReadOnly"] = \
+                self._isReadOnly
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._latestArchitectureVariants:
+            result["latestArchitectureVariants"] = [
+                i.toDict() for i in self._latestArchitectureVariants 
+            ] if self._latestArchitectureVariants else []
+        if self._latestImageSize is not None:
+            result["latestImageSize"] = \
+                self._latestImageSize
+        if self._latestTag is not None:
+            result["latestTag"] = \
+                self._latestTag
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._manualScanEnabled is not None:
+            result["manualScanEnabled"] = \
+                self._manualScanEnabled
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._os is not None:
-            result["os"] = \
-                self._os
-        if self._raidFileSystemGB is not None:
-            result["raidFileSystemGB"] = \
-                self._raidFileSystemGB
-        if self._rootFileSystemGB is not None:
-            result["rootFileSystemGB"] = \
-                self._rootFileSystemGB
-        if self._systemMemory is not None:
-            result["systemMemory"] = \
-                self._systemMemory
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._variant is not None:
-            result["variant"] = \
-                self._variant
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._scanEnabled is not None:
+            result["scanEnabled"] = \
+                self._scanEnabled
+        if self._sharedWithOrgs is not None:
+            result["sharedWithOrgs"] = \
+                self._sharedWithOrgs
+        if self._sharedWithTeams is not None:
+            result["sharedWithTeams"] = \
+                self._sharedWithTeams
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._showScanResults is not None:
+            result["showScanResults"] = \
+                self._showScanResults
+        if self._systemLabels is not None:
+            result["systemLabels"] = \
+                self._systemLabels
+        if self._tags is not None:
+            result["tags"] = \
+                self._tags
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "AceInstance.name doesnt match requirement:" 
-                "required: True"
-            )
         if (self._name is not None
             and
-            len(self._name) < 4):
+            len(self._name) < 2):
             raise ValueError(
-                "AceInstance.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 4")
+                "Repository.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 2")
         if (self._name is not None
             and
-            len(self._name) > 128):
+            len(self._name) > 64):
             raise ValueError(
-                "AceInstance.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 128")
+                "Repository.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
         if (self._name is not None
             and
             not re.match(
-                r"(^[a-zA-Z0-9_.]+$)",
+                r"^[a-zA-Z\d_-]*$",
                  self._name)):
             raise ValueError(
-                "AceInstance.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.]+$)")
-        if (self._description is not None
-            and
-            len(self._description) > 255):
-            raise ValueError(
-                "AceInstance.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._cpuCores is None:
-            raise ValueError(
-                "AceInstance.cpuCores doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._cpuCores is not None
-            and
-            self._cpuCores < 1):
-            raise ValueError(
-                "AceInstance.cpuCores: " + str(self._cpuCores) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._cpuCores is not None
-            and
-            self._cpuCores > 240):
-            raise ValueError(
-                "AceInstance.cpuCores: " + str(self._cpuCores) + 
-                " doesnt match requirement: maximum: 240")
-        if self._gpus is None:
-            raise ValueError(
-                "AceInstance.gpus doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._gpus is not None
-            and
-            self._gpus < 0):
-            raise ValueError(
-                "AceInstance.gpus: " + str(self._gpus) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._gpus is not None
-            and
-            self._gpus > 16):
-            raise ValueError(
-                "AceInstance.gpus: " + str(self._gpus) + 
-                " doesnt match requirement: maximum: 16")
-        if self._gpuMemory is None:
-            raise ValueError(
-                "AceInstance.gpuMemory doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._gpuMemory is not None
-            and
-            self._gpuMemory < 0):
-            raise ValueError(
-                "AceInstance.gpuMemory: " + str(self._gpuMemory) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._gpuMemory is not None
-            and
-            self._gpuMemory > 1474560):
-            raise ValueError(
-                "AceInstance.gpuMemory: " + str(self._gpuMemory) + 
-                " doesnt match requirement: maximum: 1474560")
-        if self._systemMemory is None:
-            raise ValueError(
-                "AceInstance.systemMemory doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._systemMemory is not None
-            and
-            self._systemMemory < 1024):
-            raise ValueError(
-                "AceInstance.systemMemory: " + str(self._systemMemory) + 
-                " doesnt match requirement: minimum: 1024")
-        if (self._systemMemory is not None
-            and
-            self._systemMemory > 1998848):
-            raise ValueError(
-                "AceInstance.systemMemory: " + str(self._systemMemory) + 
-                " doesnt match requirement: maximum: 1998848")
-        if self._maxPowerLimit is None:
-            raise ValueError(
-                "AceInstance.maxPowerLimit doesnt match requirement:" 
-                "required: True"
-            )
-        if self._maxGPUMemBandWidth is None:
-            raise ValueError(
-                "AceInstance.maxGPUMemBandWidth doesnt match requirement:" 
-                "required: True"
-            )
-        if self._maxPcieReadBandWidth is None:
-            raise ValueError(
-                "AceInstance.maxPcieReadBandWidth doesnt match requirement:" 
-                "required: True"
-            )
-        if self._maxPcieWriteBandWidth is None:
-            raise ValueError(
-                "AceInstance.maxPcieWriteBandWidth doesnt match requirement:" 
-                "required: True"
-            )
-        if self._maxNvlinkBandWidth is None:
-            raise ValueError(
-                "AceInstance.maxNvlinkBandWidth doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._rootFileSystemGB is not None
-            and
-            self._rootFileSystemGB < 1):
-            raise ValueError(
-                "AceInstance.rootFileSystemGB: " + str(self._rootFileSystemGB) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._raidFileSystemGB is not None
-            and
-            self._raidFileSystemGB < 1):
-            raise ValueError(
-                "AceInstance.raidFileSystemGB: " + str(self._raidFileSystemGB) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._migSlice is not None
-            and
-            self._migSlice < 1):
-            raise ValueError(
-                "AceInstance.migSlice: " + str(self._migSlice) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._migTotalSlice is not None
-            and
-            self._migTotalSlice < 1):
-            raise ValueError(
-                "AceInstance.migTotalSlice: " + str(self._migTotalSlice) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._infinityManagerResourceType is not None
-            and
-            len(self._infinityManagerResourceType) < 4):
-            raise ValueError(
-                "AceInstance.infinityManagerResourceType: " + str(self._infinityManagerResourceType) + 
-                " doesnt match requirement: minLength: 4")
-        if (self._infinityManagerResourceType is not None
-            and
-            len(self._infinityManagerResourceType) > 100):
-            raise ValueError(
-                "AceInstance.infinityManagerResourceType: " + str(self._infinityManagerResourceType) + 
-                " doesnt match requirement: maxLength: 100")
-        if (self._infinityManagerResourceType is not None
-            and
-            not re.match(
-                r"(^[a-zA-Z0-9_.]+$)",
-                 self._infinityManagerResourceType)):
-            raise ValueError(
-                "AceInstance.infinityManagerResourceType: " + str(self._infinityManagerResourceType) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.]+$)")
+                "Repository.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: ^[a-zA-Z\d_-]*$")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "Repository.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._latestArchitectureVariants is not None):
+            for obj in self._latestArchitectureVariants:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AceInstancePrices.py` & `ngcbpc/data/registry/RepositoryImageScanComplete.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,162 +6,183 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Price import Price
+from .ImageScanDetails import ImageScanDetails
+from .ScanStatus import ScanStatusEnum
 
 # Unused import over optimization prevention
-str(repr(Price))
+str(repr(ImageScanDetails))
+str(repr(ScanStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceInstancePrices(object):
-    """Container for ACE instance info and list of localized prices"""
+class RepositoryImageScanComplete(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.clientId = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "clientId"
             ) is None
-            else propDict["aceId"])
-        self.aceInstanceName = (
+            else propDict["clientId"])
+        self.digest = (
             None if not fromDict or propDict.get(
-                "aceInstanceName"
+                "digest"
             ) is None
-            else propDict["aceInstanceName"])
-        self.aceName = (
+            else propDict["digest"])
+        self.image = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "image"
             ) is None
-            else propDict["aceName"])
-        self.chargeId = (
+            else propDict["image"])
+        self.scanDate = (
             None if not fromDict or propDict.get(
-                "chargeId"
+                "scanDate"
             ) is None
-            else propDict["chargeId"])
-        self.prices = (
+            else propDict["scanDate"])
+        self.scanDetails = (
             None if not fromDict or propDict.get(
-                "prices"
+                "scanDetails"
             ) is None
-            else [ Price(i)
-            for i in propDict["prices"] ])
+            else propDict["scanDetails"])
+        self.scanStatus = (
+            None if not fromDict or propDict.get(
+                "scanStatus"
+            ) is None
+            else propDict["scanStatus"])
 
     @property
-    def aceId(self):
-        """long: ACE ID"""
-        return self._aceId
+    def clientId(self):
+        """str: Client id of the person who pushed the image"""
+        return self._clientId
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @clientId.setter
+    def clientId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._clientId = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "clientId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceInstanceName(self):
-        """str: ACE instance name, unique within the ACE"""
-        return self._aceInstanceName
+    def digest(self):
+        """str: Image digest: sha256:dae203fe11646a86937bf04db0079adef295f426d
+        a68a92b40e3b181f337daa7"""
+        return self._digest
 
-    @aceInstanceName.setter
-    def aceInstanceName(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceInstanceName = value
+            self._digest = value
         else:
             raise TypeError(
-                'Property "aceInstanceName" of type "list<str>" set to wrong '
-                'type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceName(self):
-        """str: ACE name"""
-        return self._aceName
+    def image(self):
+        """str: Full image name with tag, ie vulnerables/web-dvwa:latest"""
+        return self._image
 
-    @aceName.setter
-    def aceName(self, value):
+    @image.setter
+    def image(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._image = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "image" of type "list<str>" set to wrong type'
             )
 
     @property
-    def chargeId(self):
-        """str: Pricing charge ID unique for the ACE instance"""
-        return self._chargeId
+    def scanDate(self):
+        """str: Image scan date in ISO-8601 format"""
+        return self._scanDate
 
-    @chargeId.setter
-    def chargeId(self, value):
+    @scanDate.setter
+    def scanDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._chargeId = value
+            self._scanDate = value
         else:
             raise TypeError(
-                'Property "chargeId" of type "list<str>" set to wrong type'
+                'Property "scanDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def prices(self):
-        """list: List of localized prices"""
-        return self._prices
+    def scanDetails(self):
+        """ """
+        return self._scanDetails
+
+    @scanDetails.setter
+    def scanDetails(self, value):
+        if value is not None and not isinstance(value, ImageScanDetails):
+            value = ImageScanDetails(value)
+        if (value is None) or isinstance(value, ImageScanDetails):
+            self._scanDetails = value
+        else:
+            raise TypeError(
+                'Property "scanDetails" of type "list<ImageScanDetails>" set '
+                'to wrong type'
+            )
 
-    @prices.setter
-    def prices(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._prices = value
+    @property
+    def scanStatus(self):
+        """ScanStatusEnum: Image scan statuses"""
+        return self._scanStatus
+
+    @scanStatus.setter
+    def scanStatus(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._scanStatus = value
         else:
             raise TypeError(
-                'Property "prices" of type "list<Price>" set to wrong type'
+                'Property "scanStatus" of type "list<ScanStatusEnum>" set to '
+                'wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceInstanceName is not None:
-            result["aceInstanceName"] = \
-                self._aceInstanceName
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._chargeId is not None:
-            result["chargeId"] = \
-                self._chargeId
-        if self._prices:
-            result["prices"] = [
-                i.toDict() for i in self._prices 
-            ] if self._prices else []
+        if self._clientId is not None:
+            result["clientId"] = \
+                self._clientId
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._image is not None:
+            result["image"] = \
+                self._image
+        if self._scanDate is not None:
+            result["scanDate"] = \
+                self._scanDate
+        if self._scanDetails:
+            result["scanDetails"] = \
+                self._scanDetails.toDict() if self._scanDetails is not None else None
+        if self._scanStatus is not None:
+            result["scanStatus"] = \
+                self._scanStatus
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._prices is not None):
-            for obj in self._prices:
-                if (obj is not None): obj.isValid()
+        if (self._scanDetails is not None): self._scanDetails.isValid()
         return True
```

## Comparing `ngccli/data/api/AceInstancePricesResponse.py` & `organization/data/subscription_management_service/ProductsResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,57 +6,57 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AceInstancePrices import AceInstancePrices
+from .Product import Product
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(AceInstancePrices))
+str(repr(Product))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceInstancePricesResponse(object):
-    """Response to show ACE instance prices"""
+class ProductsResponse(object):
+    """Response for list products API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceInstancePrices = (
+        self.products = (
             None if not fromDict or propDict.get(
-                "aceInstancePrices"
+                "products"
             ) is None
-            else [ AceInstancePrices(i)
-            for i in propDict["aceInstancePrices"] ])
+            else [ Product(i)
+            for i in propDict["products"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def aceInstancePrices(self):
-        """list: List of ACE instance prices"""
-        return self._aceInstancePrices
+    def products(self):
+        """list: array of product objects"""
+        return self._products
 
-    @aceInstancePrices.setter
-    def aceInstancePrices(self, value):
+    @products.setter
+    def products(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._aceInstancePrices = value
+            self._products = value
         else:
             raise TypeError(
-                'Property "aceInstancePrices" of type "list<AceInstancePrices'
-                '>" set to wrong type'
+                'Property "products" of type "list<Product>" set to wrong typ'
+                'e'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,30 +70,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceInstancePrices:
-            result["aceInstancePrices"] = [
-                i.toDict() for i in self._aceInstancePrices 
-            ] if self._aceInstancePrices else []
+        if self._products:
+            result["products"] = [
+                i.toDict() for i in self._products 
+            ] if self._products else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._aceInstancePrices is not None):
-            for obj in self._aceInstancePrices:
+        if (self._products is not None):
+            for obj in self._products:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/AceListResponse.py` & `ngcbpc/data/uis/TeamListResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,63 +7,47 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .Ace import Ace
+from .Team import Team
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Ace))
 str(repr(PaginationInfo))
+str(repr(Team))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceListResponse(object):
-    """listing of all ACEs under one team"""
+class TeamListResponse(object):
+    """listing of all teams"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aces = (
-            None if not fromDict or propDict.get(
-                "aces"
-            ) is None
-            else [ Ace(i)
-            for i in propDict["aces"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def aces(self):
-        """ """
-        return self._aces
-
-    @aces.setter
-    def aces(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._aces = value
-        else:
-            raise TypeError(
-                'Property "aces" of type "list<Ace>" set to wrong type'
-            )
+        self.teams = (
+            None if not fromDict or propDict.get(
+                "teams"
+            ) is None
+            else [ Team(i)
+            for i in propDict["teams"] ])
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
@@ -91,36 +75,52 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def teams(self):
+        """ """
+        return self._teams
+
+    @teams.setter
+    def teams(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._teams = value
+        else:
+            raise TypeError(
+                'Property "teams" of type "list<Team>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._aces:
-            result["aces"] = [
-                i.toDict() for i in self._aces 
-            ] if self._aces else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._teams:
+            result["teams"] = [
+                i.toDict() for i in self._teams 
+            ] if self._teams else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._aces is not None):
-            for obj in self._aces:
+        if (self._teams is not None):
+            for obj in self._teams:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/AceNodeRemapRequest.py` & `organization/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,56 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceNodeRemapRequest(object):
-    """Object used to remap nodes from one ACE to another"""
+class RedeemPreviewSubscriptionRequest(object):
+    """Redeem preview subscription request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodes = (
+        self.codes = (
             None if not fromDict or propDict.get(
-                "nodes"
+                "codes"
             ) is None
-            else propDict["nodes"])
+            else propDict["codes"])
 
     @property
-    def nodes(self):
-        """list: Array of node serial IDs which need to be added to target ACE
-        . Target ACE ID should be provided as path parameter"""
-        return self._nodes
+    def codes(self):
+        """list: codes/serial numbers to redeem offer"""
+        return self._codes
 
-    @nodes.setter
-    def nodes(self, value):
+    @codes.setter
+    def codes(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._nodes = value
+            self._codes = value
         else:
             raise TypeError(
-                'Property "nodes" of type "list<str>" set to wrong type'
+                'Property "codes" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._nodes is not None:
-            result["nodes"] = \
-                self._nodes
+        if self._codes is not None:
+            result["codes"] = \
+                self._codes
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._nodes is None:
+        if self._codes is None:
             raise ValueError(
-                "AceNodeRemapRequest.nodes doesnt match requirement:" 
+                "RedeemPreviewSubscriptionRequest.codes doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/AceResponse.py` & `ngcbpc/data/uis/ApiKeyResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,55 +6,55 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Ace import Ace
 from .RequestStatus import RequestStatus
+from .ApiKey import ApiKey
 
 # Unused import over optimization prevention
-str(repr(Ace))
 str(repr(RequestStatus))
+str(repr(ApiKey))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceResponse(object):
-    """showing details of the ACE"""
+class ApiKeyResponse(object):
+    """Create or get api key response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ace = (
+        self.apiKey = (
             None if not fromDict or propDict.get(
-                "ace"
+                "apiKey"
             ) is None
-            else propDict["ace"])
+            else propDict["apiKey"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def ace(self):
-        """Ace: ACE is a collection of nodes that can run jobs"""
-        return self._ace
-
-    @ace.setter
-    def ace(self, value):
-        if value is not None and not isinstance(value, Ace):
-            value = Ace(value)
-        if (value is None) or isinstance(value, Ace):
-            self._ace = value
+    def apiKey(self):
+        """ApiKey: Api Key"""
+        return self._apiKey
+
+    @apiKey.setter
+    def apiKey(self, value):
+        if value is not None and not isinstance(value, ApiKey):
+            value = ApiKey(value)
+        if (value is None) or isinstance(value, ApiKey):
+            self._apiKey = value
         else:
             raise TypeError(
-                'Property "ace" of type "list<Ace>" set to wrong type'
+                'Property "apiKey" of type "list<ApiKey>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -68,27 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._ace:
-            result["ace"] = \
-                self._ace.toDict() if self._ace is not None else None
+        if self._apiKey:
+            result["apiKey"] = \
+                self._apiKey.toDict() if self._apiKey is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._ace is not None): self._ace.isValid()
+        if (self._apiKey is not None): self._apiKey.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/AceSimplified.py` & `ngcbpc/data/model/CollectionSimplified.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,98 +14,108 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceSimplified(object):
-    """ACE is a collection of nodes that can run jobs"""
+class CollectionSimplified(object):
+    """Collection object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.description = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "description"
+                "name"
             ) is None
-            else propDict["description"])
-        self.id = (
+            else propDict["name"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "id"
+                "orgName"
             ) is None
-            else propDict["id"])
-        self.name = (
+            else propDict["orgName"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "name"
+                "teamName"
             ) is None
-            else propDict["name"])
+            else propDict["teamName"])
 
     @property
-    def description(self):
-        """str: description of the ACE"""
-        return self._description
+    def name(self):
+        """str: Unique name of the collection"""
+        return self._name
 
-    @description.setter
-    def description(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: id of the ACE"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    def orgName(self):
+        """str: Name of the org that the collection belongs to"""
+        return self._orgName
+
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: name for the ACE, must be unique within the team"""
-        return self._name
+    def teamName(self):
+        """str: Name of the team that the collection belongs to"""
+        return self._teamName
 
-    @name.setter
-    def name(self, value):
+    @teamName.setter
+    def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._id is not None:
-            result["id"] = \
-                self._id
         if self._name is not None:
             result["name"] = \
                 self._name
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "CollectionSimplified.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._orgName is None:
+            raise ValueError(
+                "CollectionSimplified.orgName doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/AceStorageInfo.py` & `ngcbpc/data/model/CloudServiceProvider.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,305 +6,307 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageEngineTypeEnum import StorageEngineTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(StorageEngineTypeEnum))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceStorageInfo(object):
-    """ACE storage related information"""
+class CloudServiceProvider(object):
+    """Cloud Service Provider object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.bytesDatasetsUsage = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "bytesDatasetsUsage"
+                "attributes"
             ) is None
-            else propDict["bytesDatasetsUsage"])
-        self.bytesResultsetsUsage = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "bytesResultsetsUsage"
+                "createdDate"
             ) is None
-            else propDict["bytesResultsetsUsage"])
-        self.bytesTotalCapacity = (
+            else propDict["createdDate"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "bytesTotalCapacity"
+                "description"
             ) is None
-            else propDict["bytesTotalCapacity"])
-        self.bytesUsed = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "bytesUsed"
+                "displayName"
             ) is None
-            else propDict["bytesUsed"])
-        self.bytesWorkspacesUsage = (
+            else propDict["displayName"])
+        self.isDeployable = (
             None if not fromDict or propDict.get(
-                "bytesWorkspacesUsage"
+                "isDeployable"
             ) is None
-            else propDict["bytesWorkspacesUsage"])
-        self.datasetsCount = (
+            else propDict["isDeployable"])
+        self.isEnabled = (
             None if not fromDict or propDict.get(
-                "datasetsCount"
+                "isEnabled"
             ) is None
-            else propDict["datasetsCount"])
-        self.resultsetsCount = (
+            else propDict["isEnabled"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "resultsetsCount"
+                "labels"
             ) is None
-            else propDict["resultsetsCount"])
-        self.storageServiceDest = (
+            else propDict["labels"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "storageServiceDest"
+                "logo"
             ) is None
-            else propDict["storageServiceDest"])
-        self.storageType = (
+            else propDict["logo"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "storageType"
+                "name"
             ) is None
-            else propDict["storageType"])
-        self.workspacesCount = (
+            else propDict["name"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "workspacesCount"
+                "updatedDate"
             ) is None
-            else propDict["workspacesCount"])
+            else propDict["updatedDate"])
 
     @property
-    def bytesDatasetsUsage(self):
-        """long: Space used by datasets in bytes"""
-        return self._bytesDatasetsUsage
-
-    @bytesDatasetsUsage.setter
-    def bytesDatasetsUsage(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._bytesDatasetsUsage = value
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "bytesDatasetsUsage" of type "list<long>" set to wr'
-                'ong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def bytesResultsetsUsage(self):
-        """long: Space used by resultsets in bytes"""
-        return self._bytesResultsetsUsage
-
-    @bytesResultsetsUsage.setter
-    def bytesResultsetsUsage(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._bytesResultsetsUsage = value
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
+
+    @createdDate.setter
+    def createdDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "bytesResultsetsUsage" of type "list<long>" set to '
-                'wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bytesTotalCapacity(self):
-        """long: Total size of the storage engine in bytes"""
-        return self._bytesTotalCapacity
-
-    @bytesTotalCapacity.setter
-    def bytesTotalCapacity(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._bytesTotalCapacity = value
+    def description(self):
+        """str: Description of the Cloud Service Provider"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "bytesTotalCapacity" of type "list<long>" set to wr'
-                'ong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bytesUsed(self):
-        """long: Total space used in bytes"""
-        return self._bytesUsed
-
-    @bytesUsed.setter
-    def bytesUsed(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._bytesUsed = value
+    def displayName(self):
+        """str: Display name of the Cloud Service Provider"""
+        return self._displayName
+
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "bytesUsed" of type "list<long>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bytesWorkspacesUsage(self):
-        """long: Space used by workspaces in bytes"""
-        return self._bytesWorkspacesUsage
-
-    @bytesWorkspacesUsage.setter
-    def bytesWorkspacesUsage(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._bytesWorkspacesUsage = value
+    def isDeployable(self):
+        """bool: Determines if this Cloud Service Provider can be used to depl
+        oy artifacts"""
+        return self._isDeployable
+
+    @isDeployable.setter
+    def isDeployable(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isDeployable = value
         else:
             raise TypeError(
-                'Property "bytesWorkspacesUsage" of type "list<long>" set to '
-                'wrong type'
+                'Property "isDeployable" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def datasetsCount(self):
-        """long: Number of datasets that are a part of user's used storage"""
-        return self._datasetsCount
-
-    @datasetsCount.setter
-    def datasetsCount(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._datasetsCount = value
+    def isEnabled(self):
+        """bool: Determines if this Cloud Service Provider is enabled"""
+        return self._isEnabled
+
+    @isEnabled.setter
+    def isEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isEnabled = value
         else:
             raise TypeError(
-                'Property "datasetsCount" of type "list<long>" set to wrong t'
-                'ype'
+                'Property "isEnabled" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def resultsetsCount(self):
-        """long: Number of resultsets that are a part of user's used storage
-        """
-        return self._resultsetsCount
-
-    @resultsetsCount.setter
-    def resultsetsCount(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resultsetsCount = value
+    def labels(self):
+        """list: Labels that are associated with the Cloud Service Provider"""
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "resultsetsCount" of type "list<long>" set to wrong'
-                ' type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageServiceDest(self):
-        """str: The url of the storage service"""
-        return self._storageServiceDest
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @storageServiceDest.setter
-    def storageServiceDest(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageServiceDest = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "storageServiceDest" of type "list<str>" set to wro'
-                'ng type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageType(self):
-        """StorageEngineTypeEnum: All possible storage engine type enums"""
-        return self._storageType
-
-    @storageType.setter
-    def storageType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._storageType = value
+    def name(self):
+        """str: Unique name of the Cloud Service Provider"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "storageType" of type "list<StorageEngineTypeEnum>"'
-                ' set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def workspacesCount(self):
-        """long: Number of workspaces that are a part of user's used storage
-        """
-        return self._workspacesCount
-
-    @workspacesCount.setter
-    def workspacesCount(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._workspacesCount = value
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "workspacesCount" of type "list<long>" set to wrong'
-                ' type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._bytesDatasetsUsage is not None:
-            result["bytesDatasetsUsage"] = \
-                self._bytesDatasetsUsage
-        if self._bytesResultsetsUsage is not None:
-            result["bytesResultsetsUsage"] = \
-                self._bytesResultsetsUsage
-        if self._bytesTotalCapacity is not None:
-            result["bytesTotalCapacity"] = \
-                self._bytesTotalCapacity
-        if self._bytesUsed is not None:
-            result["bytesUsed"] = \
-                self._bytesUsed
-        if self._bytesWorkspacesUsage is not None:
-            result["bytesWorkspacesUsage"] = \
-                self._bytesWorkspacesUsage
-        if self._datasetsCount is not None:
-            result["datasetsCount"] = \
-                self._datasetsCount
-        if self._resultsetsCount is not None:
-            result["resultsetsCount"] = \
-                self._resultsetsCount
-        if self._storageServiceDest is not None:
-            result["storageServiceDest"] = \
-                self._storageServiceDest
-        if self._storageType is not None:
-            result["storageType"] = \
-                self._storageType
-        if self._workspacesCount is not None:
-            result["workspacesCount"] = \
-                self._workspacesCount
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._isDeployable is not None:
+            result["isDeployable"] = \
+                self._isDeployable
+        if self._isEnabled is not None:
+            result["isEnabled"] = \
+                self._isEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._storageType is None:
+        if self._name is None:
             raise ValueError(
-                "AceStorageInfo.storageType doesnt match requirement:" 
+                "CloudServiceProvider.name doesnt match requirement:" 
                 "required: True"
             )
-        if self._storageServiceDest is None:
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "AceStorageInfo.storageServiceDest doesnt match requirement:" 
-                "required: True"
-            )
-        if self._bytesUsed is None:
-            raise ValueError(
-                "AceStorageInfo.bytesUsed doesnt match requirement:" 
-                "required: True"
-            )
-        if self._bytesTotalCapacity is None:
+                "CloudServiceProvider.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
             raise ValueError(
-                "AceStorageInfo.bytesTotalCapacity doesnt match requirement:" 
-                "required: True"
-            )
+                "CloudServiceProvider.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AceUpdate.py` & `basecommand/data/pym/ClusterParams.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,725 +6,870 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
-from .AceInstance import AceInstance
-from .AceProvider import AceProviderEnum
-from .NetworkTypeEnum import NetworkTypeEnum
-from .IPAddress import IPAddress
-from .AceType import AceTypeEnum
+from .Env import Env
+from .ClusterComponentParams import ClusterComponentParams
+from .SecretSpec import SecretSpec
+from .DataInput import DataInput
+from .ClusterPortMapping import ClusterPortMapping
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
-str(repr(NetworkTypeEnum))
-str(repr(AceProviderEnum))
-str(repr(AceTypeEnum))
-str(repr(AceInstance))
-str(repr(IPAddress))
+str(repr(SecretSpec))
+str(repr(ClusterComponentParams))
+str(repr(DataInput))
+str(repr(ClusterPortMapping))
+str(repr(Env))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AceUpdate(object):
+class ClusterParams(object):
+    """Cluster params"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowExposedPort = (
+        self.ace = (
             None if not fromDict or propDict.get(
-                "allowExposedPort"
+                "ace"
             ) is None
-            else propDict["allowExposedPort"])
-        self.clusterFederatorUrl = (
+            else propDict["ace"])
+        self.additionalOpenPorts = (
             None if not fromDict or propDict.get(
-                "clusterFederatorUrl"
+                "additionalOpenPorts"
             ) is None
-            else propDict["clusterFederatorUrl"])
-        self.dataPlatformEnabled = (
+            else propDict["additionalOpenPorts"])
+        self.additionalPortMappings = (
             None if not fromDict or propDict.get(
-                "dataPlatformEnabled"
+                "additionalPortMappings"
             ) is None
-            else propDict["dataPlatformEnabled"])
-        self.description = (
+            else [ ClusterPortMapping(i)
+            for i in propDict["additionalPortMappings"] ])
+        self.clusterLifetime = (
             None if not fromDict or propDict.get(
-                "description"
+                "clusterLifetime"
             ) is None
-            else propDict["description"])
-        self.egressIps = (
+            else propDict["clusterLifetime"])
+        self.condaPackages = (
             None if not fromDict or propDict.get(
-                "egressIps"
+                "condaPackages"
             ) is None
-            else [ IPAddress(i)
-            for i in propDict["egressIps"] ])
-        self.grpcEnabled = (
+            else propDict["condaPackages"])
+        self.containerImage = (
             None if not fromDict or propDict.get(
-                "grpcEnabled"
+                "containerImage"
             ) is None
-            else propDict["grpcEnabled"])
-        self.infinityManagerEnabled = (
+            else propDict["containerImage"])
+        self.dataInput = (
             None if not fromDict or propDict.get(
-                "infinityManagerEnabled"
+                "dataInput"
             ) is None
-            else propDict["infinityManagerEnabled"])
-        self.instances = (
+            else propDict["dataInput"])
+        self.dataOutputMountPoint = (
             None if not fromDict or propDict.get(
-                "instances"
+                "dataOutputMountPoint"
             ) is None
-            else [ AceInstance(i)
-            for i in propDict["instances"] ])
-        self.isUnavailable = (
+            else propDict["dataOutputMountPoint"])
+        self.expiryDuration = (
             None if not fromDict or propDict.get(
-                "isUnavailable"
+                "expiryDuration"
             ) is None
-            else propDict["isUnavailable"])
-        self.maxActiveJobsPerUser = (
+            else propDict["expiryDuration"])
+        self.isLabelLocked = (
             None if not fromDict or propDict.get(
-                "maxActiveJobsPerUser"
+                "isLabelLocked"
             ) is None
-            else propDict["maxActiveJobsPerUser"])
-        self.maxAllowedReplicas = (
+            else propDict["isLabelLocked"])
+        self.isMultiNode = (
             None if not fromDict or propDict.get(
-                "maxAllowedReplicas"
+                "isMultiNode"
             ) is None
-            else propDict["maxAllowedReplicas"])
-        self.maxRuntimeSeconds = (
+            else propDict["isMultiNode"])
+        self.jobOrder = (
             None if not fromDict or propDict.get(
-                "maxRuntimeSeconds"
+                "jobOrder"
             ) is None
-            else propDict["maxRuntimeSeconds"])
+            else propDict["jobOrder"])
+        self.jobPriority = (
+            None if not fromDict or propDict.get(
+                "jobPriority"
+            ) is None
+            else propDict["jobPriority"])
+        self.labels = (
+            None if not fromDict or propDict.get(
+                "labels"
+            ) is None
+            else propDict["labels"])
+        self.minAvailability = (
+            None if not fromDict or propDict.get(
+                "minAvailability"
+            ) is None
+            else propDict["minAvailability"])
+        self.minTimesliceSeconds = (
+            None if not fromDict or propDict.get(
+                "minTimesliceSeconds"
+            ) is None
+            else propDict["minTimesliceSeconds"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.networkTypes = (
+        self.nworkers = (
             None if not fromDict or propDict.get(
-                "networkTypes"
+                "nworkers"
             ) is None
-            else propDict["networkTypes"])
-        self.orgName = (
+            else propDict["nworkers"])
+        self.options = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "options"
             ) is None
-            else propDict["orgName"])
-        self.provider = (
+            else [ Env(i)
+            for i in propDict["options"] ])
+        self.pipPackages = (
             None if not fromDict or propDict.get(
-                "provider"
+                "pipPackages"
             ) is None
-            else propDict["provider"])
-        self.proxyServiceUrl = (
+            else propDict["pipPackages"])
+        self.preemptClass = (
             None if not fromDict or propDict.get(
-                "proxyServiceUrl"
+                "preemptClass"
             ) is None
-            else propDict["proxyServiceUrl"])
-        self.storageServiceConfig = (
+            else propDict["preemptClass"])
+        self.scheduler = (
             None if not fromDict or propDict.get(
-                "storageServiceConfig"
+                "scheduler"
             ) is None
-            else [ StorageServiceConfigDetails(i)
-            for i in propDict["storageServiceConfig"] ])
-        self.storageServiceUrl = (
+            else propDict["scheduler"])
+        self.schedulerPort = (
             None if not fromDict or propDict.get(
-                "storageServiceUrl"
+                "schedulerPort"
             ) is None
-            else propDict["storageServiceUrl"])
-        self.terminationGracePeriodSeconds = (
+            else propDict["schedulerPort"])
+        self.systemPackages = (
             None if not fromDict or propDict.get(
-                "terminationGracePeriodSeconds"
+                "systemPackages"
             ) is None
-            else propDict["terminationGracePeriodSeconds"])
-        self.topologyTypes = (
+            else propDict["systemPackages"])
+        self.topologyConstraint = (
             None if not fromDict or propDict.get(
-                "topologyTypes"
+                "topologyConstraint"
             ) is None
-            else propDict["topologyTypes"])
-        self.type = (
+            else propDict["topologyConstraint"])
+        self.userSecretsSpec = (
             None if not fromDict or propDict.get(
-                "type"
+                "userSecretsSpec"
             ) is None
-            else propDict["type"])
-        self.unavailableUntil = (
+            else [ SecretSpec(i)
+            for i in propDict["userSecretsSpec"] ])
+        self.worker = (
             None if not fromDict or propDict.get(
-                "unavailableUntil"
+                "worker"
             ) is None
-            else propDict["unavailableUntil"])
+            else propDict["worker"])
 
     @property
-    def allowExposedPort(self):
-        """bool: Feature toggle for cli/FE to allow --ports feature"""
-        return self._allowExposedPort
+    def ace(self):
+        """str: ACE instance"""
+        return self._ace
 
-    @allowExposedPort.setter
-    def allowExposedPort(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowExposedPort = value
+    @ace.setter
+    def ace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ace = value
         else:
             raise TypeError(
-                'Property "allowExposedPort" of type "list<bool>" set to wron'
-                'g type'
+                'Property "ace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def clusterFederatorUrl(self):
-        """str: URL for cluster federation service hosted inside this ACE"""
-        return self._clusterFederatorUrl
+    def additionalOpenPorts(self):
+        """list: (Deprecated) Additional Ports"""
+        return self._additionalOpenPorts
 
-    @clusterFederatorUrl.setter
-    def clusterFederatorUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._clusterFederatorUrl = value
+    @additionalOpenPorts.setter
+    def additionalOpenPorts(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._additionalOpenPorts = value
         else:
             raise TypeError(
-                'Property "clusterFederatorUrl" of type "list<str>" set to wr'
+                'Property "additionalOpenPorts" of type "list<int>" set to wr'
                 'ong type'
             )
 
     @property
-    def dataPlatformEnabled(self):
-        """bool: Enable flag for Data Platform. Used along Dataset Service in 
-        Create Job"""
-        return self._dataPlatformEnabled
+    def additionalPortMappings(self):
+        """list: Additional port mappings used for the cluster"""
+        return self._additionalPortMappings
 
-    @dataPlatformEnabled.setter
-    def dataPlatformEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._dataPlatformEnabled = value
+    @additionalPortMappings.setter
+    def additionalPortMappings(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._additionalPortMappings = value
         else:
             raise TypeError(
-                'Property "dataPlatformEnabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "additionalPortMappings" of type "list<ClusterPortM'
+                'apping>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: description of the ACE"""
-        return self._description
+    def clusterLifetime(self):
+        """str: Cluster lifetime"""
+        return self._clusterLifetime
 
-    @description.setter
-    def description(self, value):
+    @clusterLifetime.setter
+    def clusterLifetime(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._clusterLifetime = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "clusterLifetime" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def egressIps(self):
-        """list: List of trusted Egress IPs from which the outgoing node traff
-        ic will flow. If provided, cloud will accept network traffic f
-        rom nodes only if it originates from one of the IP in this list."""
-        return self._egressIps
+    def condaPackages(self):
+        """list: List of custom packages to install in the container image via
+         conda install command"""
+        return self._condaPackages
 
-    @egressIps.setter
-    def egressIps(self, value):
+    @condaPackages.setter
+    def condaPackages(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._egressIps = value
+            self._condaPackages = value
         else:
             raise TypeError(
-                'Property "egressIps" of type "list<IPAddress>" set to wrong '
-                'type'
+                'Property "condaPackages" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def grpcEnabled(self):
-        """bool: Determines whether GRPC Protocol can be used in JobPortMappin
-        g for jobs scheduled on this ACE."""
-        return self._grpcEnabled
+    def containerImage(self):
+        """str: Container image"""
+        return self._containerImage
 
-    @grpcEnabled.setter
-    def grpcEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._grpcEnabled = value
+    @containerImage.setter
+    def containerImage(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._containerImage = value
         else:
             raise TypeError(
-                'Property "grpcEnabled" of type "list<bool>" set to wrong typ'
-                'e'
+                'Property "containerImage" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def dataInput(self):
+        """DataInput: Data Input"""
+        return self._dataInput
+
+    @dataInput.setter
+    def dataInput(self, value):
+        if value is not None and not isinstance(value, DataInput):
+            value = DataInput(value)
+        if (value is None) or isinstance(value, DataInput):
+            self._dataInput = value
+        else:
+            raise TypeError(
+                'Property "dataInput" of type "list<DataInput>" set to wrong '
+                'type'
             )
 
     @property
-    def infinityManagerEnabled(self):
-        """bool: Enable flag of Infinity Manager for this ace"""
-        return self._infinityManagerEnabled
+    def dataOutputMountPoint(self):
+        """str: Data output results mount point"""
+        return self._dataOutputMountPoint
 
-    @infinityManagerEnabled.setter
-    def infinityManagerEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._infinityManagerEnabled = value
+    @dataOutputMountPoint.setter
+    def dataOutputMountPoint(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._dataOutputMountPoint = value
         else:
             raise TypeError(
-                'Property "infinityManagerEnabled" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "dataOutputMountPoint" of type "list<str>" set to w'
+                'rong type'
             )
 
     @property
-    def instances(self):
-        """list: Used to indicate the collection of pre-determined resources a
-        vailible for use on the ACE, this overwrites existing collecti
-        on"""
-        return self._instances
+    def expiryDuration(self):
+        """str: Maximum duration from submission time during which the job wil
+        l be allowed to run. If not specified, or is 0, then ACE limit
+         will be applied."""
+        return self._expiryDuration
 
-    @instances.setter
-    def instances(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._instances = value
+    @expiryDuration.setter
+    def expiryDuration(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._expiryDuration = value
         else:
             raise TypeError(
-                'Property "instances" of type "list<AceInstance>" set to wron'
-                'g type'
+                'Property "expiryDuration" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def isUnavailable(self):
-        """bool: Indicates if ACE is unavailable (e.g. downtime)."""
-        return self._isUnavailable
+    def isLabelLocked(self):
+        """bool: Indicates whether the labels will be locked or not, default a
+        s false"""
+        return self._isLabelLocked
 
-    @isUnavailable.setter
-    def isUnavailable(self, value):
+    @isLabelLocked.setter
+    def isLabelLocked(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isUnavailable = value
+            self._isLabelLocked = value
         else:
             raise TypeError(
-                'Property "isUnavailable" of type "list<bool>" set to wrong t'
+                'Property "isLabelLocked" of type "list<bool>" set to wrong t'
                 'ype'
             )
 
     @property
-    def maxActiveJobsPerUser(self):
-        """int: Maximum number of jobs a user can have QUEUED or RUNNING at an
-        y given point in time on this ACE. Users are allowed to submit
-         as many jobs as they want, but they will not be sent to the scheduler
-        . Default (0) means no restrictions."""
-        return self._maxActiveJobsPerUser
+    def isMultiNode(self):
+        """bool: Indicates whether this is multi node cluster"""
+        return self._isMultiNode
+
+    @isMultiNode.setter
+    def isMultiNode(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isMultiNode = value
+        else:
+            raise TypeError(
+                'Property "isMultiNode" of type "list<bool>" set to wrong typ'
+                'e'
+            )
+
+    @property
+    def jobOrder(self):
+        """int: The order of job. Job order is from 1 to 99. Default value is 
+        50"""
+        return self._jobOrder
 
-    @maxActiveJobsPerUser.setter
-    def maxActiveJobsPerUser(self, value):
+    @jobOrder.setter
+    def jobOrder(self, value):
         if value is not None and not isinstance(value, int):
             value = int(value)
         if (value is None) or isinstance(value, int):
-            self._maxActiveJobsPerUser = value
+            self._jobOrder = value
         else:
             raise TypeError(
-                'Property "maxActiveJobsPerUser" of type "list<int>" set to w'
-                'rong type'
+                'Property "jobOrder" of type "list<int>" set to wrong type'
             )
 
     @property
-    def maxAllowedReplicas(self):
-        """int: Maximum number of replicas/tasks that are allowed for multinod
-        e job submission to the ACE"""
-        return self._maxAllowedReplicas
+    def jobPriority(self):
+        """str: The priority of job. Default value is NORMAL"""
+        return self._jobPriority
 
-    @maxAllowedReplicas.setter
-    def maxAllowedReplicas(self, value):
+    @jobPriority.setter
+    def jobPriority(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._jobPriority = value
+        else:
+            raise TypeError(
+                'Property "jobPriority" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def labels(self):
+        """list: An array of user/reserved/system labels that describe this jo
+        b"""
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
+        else:
+            raise TypeError(
+                'Property "labels" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def minAvailability(self):
+        """int: Option to indicate whether n tasks are needed to be scheduled 
+        at the same time for array job."""
+        return self._minAvailability
+
+    @minAvailability.setter
+    def minAvailability(self, value):
         if value is not None and not isinstance(value, int):
             value = int(value)
         if (value is None) or isinstance(value, int):
-            self._maxAllowedReplicas = value
+            self._minAvailability = value
         else:
             raise TypeError(
-                'Property "maxAllowedReplicas" of type "list<int>" set to wro'
-                'ng type'
+                'Property "minAvailability" of type "list<int>" set to wrong '
+                'type'
             )
 
     @property
-    def maxRuntimeSeconds(self):
-        """long: The maximum runtime, in seconds, that any jobs can have on th
-        e ACE."""
-        return self._maxRuntimeSeconds
+    def minTimesliceSeconds(self):
+        """long: Minimum time in seconds job is expected (not guaranteed) to b
+        e in the RUNNING state once scheduled to assure forward progre
+        ss."""
+        return self._minTimesliceSeconds
 
-    @maxRuntimeSeconds.setter
-    def maxRuntimeSeconds(self, value):
+    @minTimesliceSeconds.setter
+    def minTimesliceSeconds(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._maxRuntimeSeconds = value
+            self._minTimesliceSeconds = value
         else:
             raise TypeError(
-                'Property "maxRuntimeSeconds" of type "list<long>" set to wro'
-                'ng type'
+                'Property "minTimesliceSeconds" of type "list<long>" set to w'
+                'rong type'
             )
 
     @property
     def name(self):
-        """str: name for the ACE, must be uniq within the team, max 32 charact
-        ers"""
+        """str: Cluster name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def networkTypes(self):
-        """list: network types allowed on the instances, used to specify the t
-        ype of system network. ex) [infiniband, ethernet/RoCE,..]"""
-        return self._networkTypes
+    def nworkers(self):
+        """int: Number of workers"""
+        return self._nworkers
 
-    @networkTypes.setter
-    def networkTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._networkTypes = value
+    @nworkers.setter
+    def nworkers(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._nworkers = value
         else:
             raise TypeError(
-                'Property "networkTypes" of type "list<NetworkTypeEnum>" set '
-                'to wrong type'
+                'Property "nworkers" of type "list<int>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Organization name that ACE will be reattached to"""
-        return self._orgName
+    def options(self):
+        """list: List of env variable format options"""
+        return self._options
 
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    @options.setter
+    def options(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._options = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "options" of type "list<Env>" set to wrong type'
             )
 
     @property
-    def provider(self):
-        """ """
-        return self._provider
+    def pipPackages(self):
+        """list: List of custom packages to install in the container image via
+         pip install command"""
+        return self._pipPackages
 
-    @provider.setter
-    def provider(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._provider = value
+    @pipPackages.setter
+    def pipPackages(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._pipPackages = value
         else:
             raise TypeError(
-                'Property "provider" of type "list<AceProviderEnum>" set to w'
-                'rong type'
+                'Property "pipPackages" of type "list<str>" set to wrong type'
             )
 
     @property
-    def proxyServiceUrl(self):
-        """str: url that exposes proxy for this ACE"""
-        return self._proxyServiceUrl
+    def preemptClass(self):
+        """str: Describes the job class for preemption and scheduling behavior
+        . One of RESUMABLE, RESTARTABLE, or RUNONCE (default)."""
+        return self._preemptClass
 
-    @proxyServiceUrl.setter
-    def proxyServiceUrl(self, value):
+    @preemptClass.setter
+    def preemptClass(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._proxyServiceUrl = value
+            self._preemptClass = value
         else:
             raise TypeError(
-                'Property "proxyServiceUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "preemptClass" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def storageServiceConfig(self):
-        """list: Used to indicate the provider of the ACE"""
-        return self._storageServiceConfig
+    def scheduler(self):
+        """ClusterComponentParams: Common parameters for scheduler and worker
+        """
+        return self._scheduler
 
-    @storageServiceConfig.setter
-    def storageServiceConfig(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageServiceConfig = value
+    @scheduler.setter
+    def scheduler(self, value):
+        if value is not None and not isinstance(value, ClusterComponentParams):
+            value = ClusterComponentParams(value)
+        if (value is None) or isinstance(value, ClusterComponentParams):
+            self._scheduler = value
         else:
             raise TypeError(
-                'Property "storageServiceConfig" of type "list<StorageService'
-                'ConfigDetails>" set to wrong type'
+                'Property "scheduler" of type "list<ClusterComponentParams>" '
+                'set to wrong type'
             )
 
     @property
-    def storageServiceUrl(self):
-        """str: DEPRECATED storage service for the ACE can be accessed at this
-         URL, for example: https://css.ngc.nvidia.com"""
-        return self._storageServiceUrl
+    def schedulerPort(self):
+        """int: Scheduler port"""
+        return self._schedulerPort
 
-    @storageServiceUrl.setter
-    def storageServiceUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._storageServiceUrl = value
+    @schedulerPort.setter
+    def schedulerPort(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schedulerPort = value
         else:
             raise TypeError(
-                'Property "storageServiceUrl" of type "list<str>" set to wron'
-                'g type'
+                'Property "schedulerPort" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def terminationGracePeriodSeconds(self):
-        """long: The grace period, in seconds, allowed for containers to shut 
-        down gracefully. If the shutdown exceeds the grace period, the
-        n the container will be forcefully shutdown."""
-        return self._terminationGracePeriodSeconds
+    def systemPackages(self):
+        """list: List of custom packages to install in the container image via
+         system package install command (apt or yum install command)"""
+        return self._systemPackages
 
-    @terminationGracePeriodSeconds.setter
-    def terminationGracePeriodSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._terminationGracePeriodSeconds = value
+    @systemPackages.setter
+    def systemPackages(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._systemPackages = value
         else:
             raise TypeError(
-                'Property "terminationGracePeriodSeconds" of type "list<long>'
-                '" set to wrong type'
+                'Property "systemPackages" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def topologyTypes(self):
-        """list: topology type allowed on the instances, used to specify the s
-        ystem proxomity. ex) [pack, rackName, podName, rack, megapod]"""
-        return self._topologyTypes
+    def topologyConstraint(self):
+        """str: Constraints to set the topology for the array job"""
+        return self._topologyConstraint
 
-    @topologyTypes.setter
-    def topologyTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._topologyTypes = value
+    @topologyConstraint.setter
+    def topologyConstraint(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._topologyConstraint = value
         else:
             raise TypeError(
-                'Property "topologyTypes" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "topologyConstraint" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def userSecretsSpec(self):
+        """list: Specification of list of user secrets to associate to the job
+        """
+        return self._userSecretsSpec
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @userSecretsSpec.setter
+    def userSecretsSpec(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._userSecretsSpec = value
         else:
             raise TypeError(
-                'Property "type" of type "list<AceTypeEnum>" set to wrong typ'
-                'e'
+                'Property "userSecretsSpec" of type "list<SecretSpec>" set to'
+                ' wrong type'
             )
 
     @property
-    def unavailableUntil(self):
-        """str: Estimated time after which ace is available. ISO-8601 format
+    def worker(self):
+        """ClusterComponentParams: Common parameters for scheduler and worker
         """
-        return self._unavailableUntil
+        return self._worker
 
-    @unavailableUntil.setter
-    def unavailableUntil(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._unavailableUntil = value
+    @worker.setter
+    def worker(self, value):
+        if value is not None and not isinstance(value, ClusterComponentParams):
+            value = ClusterComponentParams(value)
+        if (value is None) or isinstance(value, ClusterComponentParams):
+            self._worker = value
         else:
             raise TypeError(
-                'Property "unavailableUntil" of type "list<str>" set to wrong'
-                ' type'
+                'Property "worker" of type "list<ClusterComponentParams>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowExposedPort is not None:
-            result["allowExposedPort"] = \
-                self._allowExposedPort
-        if self._clusterFederatorUrl is not None:
-            result["clusterFederatorUrl"] = \
-                self._clusterFederatorUrl
-        if self._dataPlatformEnabled is not None:
-            result["dataPlatformEnabled"] = \
-                self._dataPlatformEnabled
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._egressIps:
-            result["egressIps"] = [
-                i.toDict() for i in self._egressIps 
-            ] if self._egressIps else []
-        if self._grpcEnabled is not None:
-            result["grpcEnabled"] = \
-                self._grpcEnabled
-        if self._infinityManagerEnabled is not None:
-            result["infinityManagerEnabled"] = \
-                self._infinityManagerEnabled
-        if self._instances:
-            result["instances"] = [
-                i.toDict() for i in self._instances 
-            ] if self._instances else []
-        if self._isUnavailable is not None:
-            result["isUnavailable"] = \
-                self._isUnavailable
-        if self._maxActiveJobsPerUser is not None:
-            result["maxActiveJobsPerUser"] = \
-                self._maxActiveJobsPerUser
-        if self._maxAllowedReplicas is not None:
-            result["maxAllowedReplicas"] = \
-                self._maxAllowedReplicas
-        if self._maxRuntimeSeconds is not None:
-            result["maxRuntimeSeconds"] = \
-                self._maxRuntimeSeconds
+        if self._ace is not None:
+            result["ace"] = \
+                self._ace
+        if self._additionalOpenPorts is not None:
+            result["additionalOpenPorts"] = \
+                self._additionalOpenPorts
+        if self._additionalPortMappings:
+            result["additionalPortMappings"] = [
+                i.toDict() for i in self._additionalPortMappings 
+            ] if self._additionalPortMappings else []
+        if self._clusterLifetime is not None:
+            result["clusterLifetime"] = \
+                self._clusterLifetime
+        if self._condaPackages is not None:
+            result["condaPackages"] = \
+                self._condaPackages
+        if self._containerImage is not None:
+            result["containerImage"] = \
+                self._containerImage
+        if self._dataInput:
+            result["dataInput"] = \
+                self._dataInput.toDict() if self._dataInput is not None else None
+        if self._dataOutputMountPoint is not None:
+            result["dataOutputMountPoint"] = \
+                self._dataOutputMountPoint
+        if self._expiryDuration is not None:
+            result["expiryDuration"] = \
+                self._expiryDuration
+        if self._isLabelLocked is not None:
+            result["isLabelLocked"] = \
+                self._isLabelLocked
+        if self._isMultiNode is not None:
+            result["isMultiNode"] = \
+                self._isMultiNode
+        if self._jobOrder is not None:
+            result["jobOrder"] = \
+                self._jobOrder
+        if self._jobPriority is not None:
+            result["jobPriority"] = \
+                self._jobPriority
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._minAvailability is not None:
+            result["minAvailability"] = \
+                self._minAvailability
+        if self._minTimesliceSeconds is not None:
+            result["minTimesliceSeconds"] = \
+                self._minTimesliceSeconds
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._networkTypes is not None:
-            result["networkTypes"] = \
-                self._networkTypes
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._provider is not None:
-            result["provider"] = \
-                self._provider
-        if self._proxyServiceUrl is not None:
-            result["proxyServiceUrl"] = \
-                self._proxyServiceUrl
-        if self._storageServiceConfig:
-            result["storageServiceConfig"] = [
-                i.toDict() for i in self._storageServiceConfig 
-            ] if self._storageServiceConfig else []
-        if self._storageServiceUrl is not None:
-            result["storageServiceUrl"] = \
-                self._storageServiceUrl
-        if self._terminationGracePeriodSeconds is not None:
-            result["terminationGracePeriodSeconds"] = \
-                self._terminationGracePeriodSeconds
-        if self._topologyTypes is not None:
-            result["topologyTypes"] = \
-                self._topologyTypes
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._unavailableUntil is not None:
-            result["unavailableUntil"] = \
-                self._unavailableUntil
+        if self._nworkers is not None:
+            result["nworkers"] = \
+                self._nworkers
+        if self._options:
+            result["options"] = [
+                i.toDict() for i in self._options 
+            ] if self._options else []
+        if self._pipPackages is not None:
+            result["pipPackages"] = \
+                self._pipPackages
+        if self._preemptClass is not None:
+            result["preemptClass"] = \
+                self._preemptClass
+        if self._scheduler:
+            result["scheduler"] = \
+                self._scheduler.toDict() if self._scheduler is not None else None
+        if self._schedulerPort is not None:
+            result["schedulerPort"] = \
+                self._schedulerPort
+        if self._systemPackages is not None:
+            result["systemPackages"] = \
+                self._systemPackages
+        if self._topologyConstraint is not None:
+            result["topologyConstraint"] = \
+                self._topologyConstraint
+        if self._userSecretsSpec:
+            result["userSecretsSpec"] = [
+                i.toDict() for i in self._userSecretsSpec 
+            ] if self._userSecretsSpec else []
+        if self._worker:
+            result["worker"] = \
+                self._worker.toDict() if self._worker is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
+        if self._ace is None:
+            raise ValueError(
+                "ClusterParams.ace doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._ace is not None
             and
-            len(self._name) < 2):
+            len(self._ace) < 1):
             raise ValueError(
-                "AceUpdate.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
+                "ClusterParams.ace: " + str(self._ace) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._schedulerPort is not None
             and
-            len(self._name) > 32):
+            self._schedulerPort < 1):
             raise ValueError(
-                "AceUpdate.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 32")
-        if (self._name is not None
+                "ClusterParams.schedulerPort: " + str(self._schedulerPort) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._schedulerPort is not None
+            and
+            self._schedulerPort > 65535):
+            raise ValueError(
+                "ClusterParams.schedulerPort: " + str(self._schedulerPort) + 
+                " doesnt match requirement: maximum: 65535")
+        if self._scheduler is None:
+            raise ValueError(
+                "ClusterParams.scheduler doesnt match requirement:" 
+                "required: True"
+            )
+        if self._nworkers is None:
+            raise ValueError(
+                "ClusterParams.nworkers doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._nworkers is not None
+            and
+            self._nworkers < 1):
+            raise ValueError(
+                "ClusterParams.nworkers: " + str(self._nworkers) + 
+                " doesnt match requirement: minimum: 1")
+        if self._containerImage is None:
+            raise ValueError(
+                "ClusterParams.containerImage doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._containerImage is not None
+            and
+            len(self._containerImage) < 1):
+            raise ValueError(
+                "ClusterParams.containerImage: " + str(self._containerImage) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._containerImage is not None
             and
             not re.match(
-                r"^[a-zA-Z\d_-]*$",
-                 self._name)):
+                r"[\x20-\x7E]*",
+                 self._containerImage)):
             raise ValueError(
-                "AceUpdate.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d_-]*$")
-        if (self._description is not None
+                "ClusterParams.containerImage: " + str(self._containerImage) + 
+                " doesnt match requirement: pattern: [\x20-\x7E]*")
+        if self._dataOutputMountPoint is None:
+            raise ValueError(
+                "ClusterParams.dataOutputMountPoint doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._dataOutputMountPoint is not None
             and
-            len(self._description) > 255):
+            len(self._dataOutputMountPoint) < 1):
+            raise ValueError(
+                "ClusterParams.dataOutputMountPoint: " + str(self._dataOutputMountPoint) + 
+                " doesnt match requirement: minLength: 1")
+        if self._clusterLifetime is None:
             raise ValueError(
-                "AceUpdate.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._instances is not None
+                "ClusterParams.clusterLifetime doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusterLifetime is not None
             and
-            len(self._instances) < 1):
+            not re.match(
+                r"[0-9]+[DdHhMmSs]",
+                 self._clusterLifetime)):
             raise ValueError(
-                "AceUpdate.instances: " + str(self._instances) + 
-                " doesnt match requirement: minItems: 1")
-        if (self._maxRuntimeSeconds is not None
+                "ClusterParams.clusterLifetime: " + str(self._clusterLifetime) + 
+                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
+        if (self._expiryDuration is not None
             and
-            self._maxRuntimeSeconds < 0):
+            not re.match(
+                r"[0-9]+[DdHhMmSs]",
+                 self._expiryDuration)):
             raise ValueError(
-                "AceUpdate.maxRuntimeSeconds: " + str(self._maxRuntimeSeconds) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._terminationGracePeriodSeconds is not None
+                "ClusterParams.expiryDuration: " + str(self._expiryDuration) + 
+                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
+        if (self._minTimesliceSeconds is not None
             and
-            self._terminationGracePeriodSeconds < 0):
+            self._minTimesliceSeconds < 0):
             raise ValueError(
-                "AceUpdate.terminationGracePeriodSeconds: " + str(self._terminationGracePeriodSeconds) + 
+                "ClusterParams.minTimesliceSeconds: " + str(self._minTimesliceSeconds) + 
                 " doesnt match requirement: minimum: 0")
-        if (self._maxActiveJobsPerUser is not None
+        if (self._preemptClass is not None
             and
-            self._maxActiveJobsPerUser < 0):
+            len(self._preemptClass) < 1):
             raise ValueError(
-                "AceUpdate.maxActiveJobsPerUser: " + str(self._maxActiveJobsPerUser) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._unavailableUntil is not None
+                "ClusterParams.preemptClass: " + str(self._preemptClass) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._jobOrder is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._unavailableUntil)):
+            self._jobOrder < 1):
             raise ValueError(
-                "AceUpdate.unavailableUntil: " + str(self._unavailableUntil) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._orgName is not None
+                "ClusterParams.jobOrder: " + str(self._jobOrder) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._jobOrder is not None
             and
-            len(self._orgName) < 2):
+            self._jobOrder > 99):
             raise ValueError(
-                "AceUpdate.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._orgName is not None
+                "ClusterParams.jobOrder: " + str(self._jobOrder) + 
+                " doesnt match requirement: maximum: 99")
+        if (self._jobPriority is not None
             and
-            len(self._orgName) > 64):
+            len(self._jobPriority) < 1):
             raise ValueError(
-                "AceUpdate.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._orgName is not None
+                "ClusterParams.jobPriority: " + str(self._jobPriority) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._topologyConstraint is not None
             and
-            not re.match(
-                r"[a-z][a-z\d_-]+",
-                 self._orgName)):
+            len(self._topologyConstraint) < 1):
             raise ValueError(
-                "AceUpdate.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: pattern: [a-z][a-z\d_-]+")
-        if (self._storageServiceConfig is not None):
-            for obj in self._storageServiceConfig:
+                "ClusterParams.topologyConstraint: " + str(self._topologyConstraint) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._scheduler is not None): self._scheduler.isValid()
+        if (self._worker is not None): self._worker.isValid()
+        if (self._additionalPortMappings is not None):
+            for obj in self._additionalPortMappings:
                 if (obj is not None): obj.isValid()
-        if (self._instances is not None):
-            for obj in self._instances:
+        if (self._dataInput is not None): self._dataInput.isValid()
+        if (self._userSecretsSpec is not None):
+            for obj in self._userSecretsSpec:
                 if (obj is not None): obj.isValid()
-        if (self._egressIps is not None):
-            for obj in self._egressIps:
+        if (self._options is not None):
+            for obj in self._options:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AlertDeliveryMode.py` & `ngcbpc/data/uis/ProductEnablement.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,145 +6,159 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .PurchaseOrder import PurchaseOrder
 
 # Unused import over optimization prevention
+str(repr(PurchaseOrder))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AlertDeliveryMode(object):
-    """Alert delivery mode"""
+class ProductEnablement(object):
+    """Product Enablement"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deliveryMode = (
+        self.expirationDate = (
             None if not fromDict or propDict.get(
-                "deliveryMode"
+                "expirationDate"
             ) is None
-            else propDict["deliveryMode"])
-        self.deliveryModePoints = (
+            else propDict["expirationDate"])
+        self.poDetails = (
             None if not fromDict or propDict.get(
-                "deliveryModePoints"
+                "poDetails"
             ) is None
-            else propDict["deliveryModePoints"])
-        self.secret = (
+            else [ PurchaseOrder(i)
+            for i in propDict["poDetails"] ])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "secret"
+                "productName"
             ) is None
-            else propDict["secret"])
+            else propDict["productName"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
 
     @property
-    def deliveryMode(self):
-        """DeliveryModeEnum: Mode of delivery"""
-        return self._deliveryMode
-
-    @deliveryMode.setter
-    def deliveryMode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._deliveryMode = value
+    def expirationDate(self):
+        """str: Date on which the subscription expires. The subscription is in
+        valid after this date. (yyyy-MM-dd)"""
+        return self._expirationDate
+
+    @expirationDate.setter
+    def expirationDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._expirationDate = value
         else:
             raise TypeError(
-                'Property "deliveryMode" of type "list<DeliveryModeEnum>" set'
-                ' to wrong type'
+                'Property "expirationDate" of type "list<str>" set to wrong t'
+                'ype'
             )
 
-    DeliveryModeEnum=["EMAIL","POST",]
-    str(repr(DeliveryModeEnum))  # Prevent optimizer removing enum
-
     @property
-    def deliveryModePoints(self):
-        """list: Point of delivery, list of email addresses or URLs to post th
-        e alert to"""
-        return self._deliveryModePoints
+    def poDetails(self):
+        """ """
+        return self._poDetails
 
-    @deliveryModePoints.setter
-    def deliveryModePoints(self, value):
+    @poDetails.setter
+    def poDetails(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._deliveryModePoints = value
+            self._poDetails = value
         else:
             raise TypeError(
-                'Property "deliveryModePoints" of type "list<str>" set to wro'
-                'ng type'
+                'Property "poDetails" of type "list<PurchaseOrder>" set to wr'
+                'ong type'
             )
 
     @property
-    def secret(self):
-        """str: User defined secret value, will be present in the post header 
-        for key X-Dgx-Secret"""
-        return self._secret
+    def productName(self):
+        """str: Product Name (NVAIE, BASE_COMMAND, REGISTRY, etc)"""
+        return self._productName
 
-    @secret.setter
-    def secret(self, value):
+    @productName.setter
+    def productName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._secret = value
+            self._productName = value
         else:
             raise TypeError(
-                'Property "secret" of type "list<str>" set to wrong type'
+                'Property "productName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def type(self):
+        """str: Product Enablement Types (NGC_ADMIN_EVAL, EMS_EVAL, EMS_NFR, e
+        tc)."""
+        return self._type
+
+    @type.setter
+    def type(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._type = value
+        else:
+            raise TypeError(
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deliveryMode is not None:
-            result["deliveryMode"] = \
-                self._deliveryMode
-        if self._deliveryModePoints is not None:
-            result["deliveryModePoints"] = \
-                self._deliveryModePoints
-        if self._secret is not None:
-            result["secret"] = \
-                self._secret
+        if self._expirationDate is not None:
+            result["expirationDate"] = \
+                self._expirationDate
+        if self._poDetails:
+            result["poDetails"] = [
+                i.toDict() for i in self._poDetails 
+            ] if self._poDetails else []
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._deliveryMode is None:
+        if self._type is None:
             raise ValueError(
-                "AlertDeliveryMode.deliveryMode doesnt match requirement:" 
+                "ProductEnablement.type doesnt match requirement:" 
                 "required: True"
             )
-        if self._deliveryModePoints is None:
+        if self._productName is None:
             raise ValueError(
-                "AlertDeliveryMode.deliveryModePoints doesnt match requirement:" 
+                "ProductEnablement.productName doesnt match requirement:" 
                 "required: True"
             )
-        if (self._deliveryModePoints is not None
-            and
-            len(self._deliveryModePoints) < 6):
-            raise ValueError(
-                "AlertDeliveryMode.deliveryModePoints: " + str(self._deliveryModePoints) + 
-                " doesnt match requirement: minLength: 6")
-        if (self._deliveryModePoints is not None
+        if (self._expirationDate is not None
             and
-            len(self._deliveryModePoints) > 255):
-            raise ValueError(
-                "AlertDeliveryMode.deliveryModePoints: " + str(self._deliveryModePoints) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._deliveryModePoints is not None
-            and
-            len(self._deliveryModePoints) < 1):
-            raise ValueError(
-                "AlertDeliveryMode.deliveryModePoints: " + str(self._deliveryModePoints) + 
-                " doesnt match requirement: minItems: 1")
-        if (self._secret is not None
-            and
-            len(self._secret) > 64):
-            raise ValueError(
-                "AlertDeliveryMode.secret: " + str(self._secret) + 
-                " doesnt match requirement: maxLength: 64")
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\d",
+                 self._expirationDate)):
+            raise ValueError(
+                "ProductEnablement.expirationDate: " + str(self._expirationDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\d")
+        if (self._poDetails is not None):
+            for obj in self._poDetails:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/AlternateContact.py` & `ngcbpc/data/uis/AlternateContact.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/Analysis.py` & `ngcbpc/data/registry/Analysis.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/AuditLogs.py` & `ngcbpc/data/uis/AccountInfo.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,268 +14,289 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogs(object):
-    """Object of audit logs"""
+class AccountInfo(object):
+    """information about the account"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.auditLogsFrom = (
+        self.addressLineOne = (
             None if not fromDict or propDict.get(
-                "auditLogsFrom"
+                "addressLineOne"
             ) is None
-            else propDict["auditLogsFrom"])
-        self.auditLogsId = (
+            else propDict["addressLineOne"])
+        self.addressLineTwo = (
             None if not fromDict or propDict.get(
-                "auditLogsId"
+                "addressLineTwo"
             ) is None
-            else propDict["auditLogsId"])
-        self.auditLogsStatus = (
+            else propDict["addressLineTwo"])
+        self.city = (
             None if not fromDict or propDict.get(
-                "auditLogsStatus"
+                "city"
             ) is None
-            else propDict["auditLogsStatus"])
-        self.auditLogsTo = (
+            else propDict["city"])
+        self.country = (
             None if not fromDict or propDict.get(
-                "auditLogsTo"
+                "country"
             ) is None
-            else propDict["auditLogsTo"])
-        self.requestedDate = (
+            else propDict["country"])
+        self.email = (
             None if not fromDict or propDict.get(
-                "requestedDate"
+                "email"
             ) is None
-            else propDict["requestedDate"])
-        self.requesterEmail = (
+            else propDict["email"])
+        self.firstName = (
             None if not fromDict or propDict.get(
-                "requesterEmail"
+                "firstName"
             ) is None
-            else propDict["requesterEmail"])
-        self.requesterName = (
+            else propDict["firstName"])
+        self.lastName = (
             None if not fromDict or propDict.get(
-                "requesterName"
+                "lastName"
             ) is None
-            else propDict["requesterName"])
-        self.requsterEmail = (
+            else propDict["lastName"])
+        self.phoneNumber = (
             None if not fromDict or propDict.get(
-                "requsterEmail"
+                "phoneNumber"
             ) is None
-            else propDict["requsterEmail"])
-        self.requsterName = (
+            else propDict["phoneNumber"])
+        self.state = (
             None if not fromDict or propDict.get(
-                "requsterName"
+                "state"
             ) is None
-            else propDict["requsterName"])
+            else propDict["state"])
+        self.zipCode = (
+            None if not fromDict or propDict.get(
+                "zipCode"
+            ) is None
+            else propDict["zipCode"])
 
     @property
-    def auditLogsFrom(self):
-        """str: Audit logs from date"""
-        return self._auditLogsFrom
+    def addressLineOne(self):
+        """str: Address line one"""
+        return self._addressLineOne
 
-    @auditLogsFrom.setter
-    def auditLogsFrom(self, value):
+    @addressLineOne.setter
+    def addressLineOne(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._auditLogsFrom = value
+            self._addressLineOne = value
         else:
             raise TypeError(
-                'Property "auditLogsFrom" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "addressLineOne" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def auditLogsId(self):
-        """str: Unique Id of audit logs"""
-        return self._auditLogsId
+    def addressLineTwo(self):
+        """str: Address line two"""
+        return self._addressLineTwo
 
-    @auditLogsId.setter
-    def auditLogsId(self, value):
+    @addressLineTwo.setter
+    def addressLineTwo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._auditLogsId = value
+            self._addressLineTwo = value
         else:
             raise TypeError(
-                'Property "auditLogsId" of type "list<str>" set to wrong type'
+                'Property "addressLineTwo" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def auditLogsStatus(self):
-        """AuditLogsStatusEnum: Status of audit logs"""
-        return self._auditLogsStatus
-
-    @auditLogsStatus.setter
-    def auditLogsStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._auditLogsStatus = value
+    def city(self):
+        """str: city"""
+        return self._city
+
+    @city.setter
+    def city(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._city = value
         else:
             raise TypeError(
-                'Property "auditLogsStatus" of type "list<AuditLogsStatusEnum'
-                '>" set to wrong type'
+                'Property "city" of type "list<str>" set to wrong type'
             )
 
-    AuditLogsStatusEnum=["UNKNOWN","REQUESTED","READY",]
-    str(repr(AuditLogsStatusEnum))  # Prevent optimizer removing enum
+    @property
+    def country(self):
+        """str: ISO-3166-1 alpha-2 country code"""
+        return self._country
+
+    @country.setter
+    def country(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._country = value
+        else:
+            raise TypeError(
+                'Property "country" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def auditLogsTo(self):
-        """str: Audit logs to date"""
-        return self._auditLogsTo
+    def email(self):
+        """str: Email address of the user. This should be unique."""
+        return self._email
 
-    @auditLogsTo.setter
-    def auditLogsTo(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._auditLogsTo = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "auditLogsTo" of type "list<str>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestedDate(self):
-        """str: Audit logs requested date"""
-        return self._requestedDate
+    def firstName(self):
+        """str: First name"""
+        return self._firstName
 
-    @requestedDate.setter
-    def requestedDate(self, value):
+    @firstName.setter
+    def firstName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requestedDate = value
+            self._firstName = value
         else:
             raise TypeError(
-                'Property "requestedDate" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "firstName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requesterEmail(self):
-        """str: Audit logs requester email"""
-        return self._requesterEmail
+    def lastName(self):
+        """str: Last name"""
+        return self._lastName
 
-    @requesterEmail.setter
-    def requesterEmail(self, value):
+    @lastName.setter
+    def lastName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requesterEmail = value
+            self._lastName = value
         else:
             raise TypeError(
-                'Property "requesterEmail" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "lastName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requesterName(self):
-        """str: Audit logs requester name"""
-        return self._requesterName
+    def phoneNumber(self):
+        """str: Phone number"""
+        return self._phoneNumber
 
-    @requesterName.setter
-    def requesterName(self, value):
+    @phoneNumber.setter
+    def phoneNumber(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requesterName = value
+            self._phoneNumber = value
         else:
             raise TypeError(
-                'Property "requesterName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "phoneNumber" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requsterEmail(self):
-        """str: [DEPRECATED] Audit logs requester email"""
-        return self._requsterEmail
+    def state(self):
+        """str: state"""
+        return self._state
 
-    @requsterEmail.setter
-    def requsterEmail(self, value):
+    @state.setter
+    def state(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requsterEmail = value
+            self._state = value
         else:
             raise TypeError(
-                'Property "requsterEmail" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "state" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requsterName(self):
-        """str: [DEPRECATED] Audit logs requester name"""
-        return self._requsterName
+    def zipCode(self):
+        """str: Zip code"""
+        return self._zipCode
 
-    @requsterName.setter
-    def requsterName(self, value):
+    @zipCode.setter
+    def zipCode(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requsterName = value
+            self._zipCode = value
         else:
             raise TypeError(
-                'Property "requsterName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "zipCode" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._auditLogsFrom is not None:
-            result["auditLogsFrom"] = \
-                self._auditLogsFrom
-        if self._auditLogsId is not None:
-            result["auditLogsId"] = \
-                self._auditLogsId
-        if self._auditLogsStatus is not None:
-            result["auditLogsStatus"] = \
-                self._auditLogsStatus
-        if self._auditLogsTo is not None:
-            result["auditLogsTo"] = \
-                self._auditLogsTo
-        if self._requestedDate is not None:
-            result["requestedDate"] = \
-                self._requestedDate
-        if self._requesterEmail is not None:
-            result["requesterEmail"] = \
-                self._requesterEmail
-        if self._requesterName is not None:
-            result["requesterName"] = \
-                self._requesterName
-        if self._requsterEmail is not None:
-            result["requsterEmail"] = \
-                self._requsterEmail
-        if self._requsterName is not None:
-            result["requsterName"] = \
-                self._requsterName
+        if self._addressLineOne is not None:
+            result["addressLineOne"] = \
+                self._addressLineOne
+        if self._addressLineTwo is not None:
+            result["addressLineTwo"] = \
+                self._addressLineTwo
+        if self._city is not None:
+            result["city"] = \
+                self._city
+        if self._country is not None:
+            result["country"] = \
+                self._country
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._firstName is not None:
+            result["firstName"] = \
+                self._firstName
+        if self._lastName is not None:
+            result["lastName"] = \
+                self._lastName
+        if self._phoneNumber is not None:
+            result["phoneNumber"] = \
+                self._phoneNumber
+        if self._state is not None:
+            result["state"] = \
+                self._state
+        if self._zipCode is not None:
+            result["zipCode"] = \
+                self._zipCode
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requsterEmail is not None
+        if (self._email is not None
             and
-            not re.match(
-                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
-                 self._requsterEmail)):
+            len(self._email) < 7):
             raise ValueError(
-                "AuditLogs.requsterEmail: " + str(self._requsterEmail) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
-                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
-        if (self._requesterEmail is not None
+                "AccountInfo.email: " + str(self._email) + 
+                " doesnt match requirement: minLength: 7")
+        if (self._email is not None
+            and
+            len(self._email) > 128):
+            raise ValueError(
+                "AccountInfo.email: " + str(self._email) + 
+                " doesnt match requirement: maxLength: 128")
+        if (self._email is not None
             and
             not re.match(
                 r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
-                 self._requesterEmail)):
+                 self._email)):
             raise ValueError(
-                "AuditLogs.requesterEmail: " + str(self._requesterEmail) + 
+                "AccountInfo.email: " + str(self._email) + 
                 " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
                 "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
         return True
```

## Comparing `ngccli/data/api/AuditLogsEventRequest.py` & `ngcbpc/data/registry/ImageOwnerDetails.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,257 +6,257 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CelestialFilters import CelestialFilters
 
 # Unused import over optimization prevention
-str(repr(CelestialFilters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogsEventRequest(object):
+class ImageOwnerDetails(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.authToken = (
+        self.isSigned = (
             None if not fromDict or propDict.get(
-                "authToken"
+                "isSigned"
             ) is None
-            else propDict["authToken"])
-        self.filters = (
+            else propDict["isSigned"])
+        self.orgAlternateContact = (
             None if not fromDict or propDict.get(
-                "filters"
+                "orgAlternateContact"
             ) is None
-            else propDict["filters"])
-        self.fromDate = (
+            else propDict["orgAlternateContact"])
+        self.orgOwnersEmails = (
             None if not fromDict or propDict.get(
-                "fromDate"
+                "orgOwnersEmails"
             ) is None
-            else propDict["fromDate"])
-        self.inputId = (
+            else propDict["orgOwnersEmails"])
+        self.pushedByUserEmail = (
             None if not fromDict or propDict.get(
-                "inputId"
+                "pushedByUserEmail"
             ) is None
-            else propDict["inputId"])
-        self.logType = (
+            else propDict["pushedByUserEmail"])
+        self.pushedDate = (
             None if not fromDict or propDict.get(
-                "logType"
+                "pushedDate"
             ) is None
-            else propDict["logType"])
-        self.requestId = (
+            else propDict["pushedDate"])
+        self.repositoryCreatorUserEmail = (
             None if not fromDict or propDict.get(
-                "requestId"
+                "repositoryCreatorUserEmail"
             ) is None
-            else propDict["requestId"])
-        self.requesterClientId = (
+            else propDict["repositoryCreatorUserEmail"])
+        self.repositoryName = (
             None if not fromDict or propDict.get(
-                "requesterClientId"
+                "repositoryName"
             ) is None
-            else propDict["requesterClientId"])
-        self.toDate = (
+            else propDict["repositoryName"])
+        self.tag = (
             None if not fromDict or propDict.get(
-                "toDate"
+                "tag"
             ) is None
-            else propDict["toDate"])
+            else propDict["tag"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
+
+    @property
+    def isSigned(self):
+        """bool: Whether the tag is signed"""
+        return self._isSigned
+
+    @isSigned.setter
+    def isSigned(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isSigned = value
+        else:
+            raise TypeError(
+                'Property "isSigned" of type "list<bool>" set to wrong type'
+            )
 
     @property
-    def authToken(self):
-        """str: Authentication token"""
-        return self._authToken
+    def orgAlternateContact(self):
+        """str: Email address of alternate contact for organization the image 
+        was pushed to"""
+        return self._orgAlternateContact
 
-    @authToken.setter
-    def authToken(self, value):
+    @orgAlternateContact.setter
+    def orgAlternateContact(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authToken = value
+            self._orgAlternateContact = value
         else:
             raise TypeError(
-                'Property "authToken" of type "list<str>" set to wrong type'
+                'Property "orgAlternateContact" of type "list<str>" set to wr'
+                'ong type'
             )
 
     @property
-    def filters(self):
-        """CelestialFilters: Celestial service filters for Kafka request messa
-        ge"""
-        return self._filters
-
-    @filters.setter
-    def filters(self, value):
-        if value is not None and not isinstance(value, CelestialFilters):
-            value = CelestialFilters(value)
-        if (value is None) or isinstance(value, CelestialFilters):
-            self._filters = value
+    def orgOwnersEmails(self):
+        """list: Email addresses of all owners of organization the image was p
+        ushed to"""
+        return self._orgOwnersEmails
+
+    @orgOwnersEmails.setter
+    def orgOwnersEmails(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._orgOwnersEmails = value
         else:
             raise TypeError(
-                'Property "filters" of type "list<CelestialFilters>" set to w'
-                'rong type'
+                'Property "orgOwnersEmails" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def fromDate(self):
-        """str: Audit logs from date in ISO-8601 format"""
-        return self._fromDate
+    def pushedByUserEmail(self):
+        """str: Email address of account used to push the image"""
+        return self._pushedByUserEmail
 
-    @fromDate.setter
-    def fromDate(self, value):
+    @pushedByUserEmail.setter
+    def pushedByUserEmail(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fromDate = value
+            self._pushedByUserEmail = value
         else:
             raise TypeError(
-                'Property "fromDate" of type "list<str>" set to wrong type'
+                'Property "pushedByUserEmail" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def inputId(self):
-        """str: ID of the input created when onboarded to Heimdall through Sec
-        urity Portal"""
-        return self._inputId
+    def pushedDate(self):
+        """str: Image pushed date in ISO-8601 format"""
+        return self._pushedDate
 
-    @inputId.setter
-    def inputId(self, value):
+    @pushedDate.setter
+    def pushedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._inputId = value
+            self._pushedDate = value
         else:
             raise TypeError(
-                'Property "inputId" of type "list<str>" set to wrong type'
+                'Property "pushedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logType(self):
-        """str: Type of logs"""
-        return self._logType
+    def repositoryCreatorUserEmail(self):
+        """str: Email address of account used to create the repository the ima
+        ge is in"""
+        return self._repositoryCreatorUserEmail
 
-    @logType.setter
-    def logType(self, value):
+    @repositoryCreatorUserEmail.setter
+    def repositoryCreatorUserEmail(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logType = value
+            self._repositoryCreatorUserEmail = value
         else:
             raise TypeError(
-                'Property "logType" of type "list<str>" set to wrong type'
+                'Property "repositoryCreatorUserEmail" of type "list<str>" se'
+                't to wrong type'
             )
 
     @property
-    def requestId(self):
-        """str: The unique identifier of audit logs event"""
-        return self._requestId
+    def repositoryName(self):
+        """str: The repository name of this image"""
+        return self._repositoryName
 
-    @requestId.setter
-    def requestId(self, value):
+    @repositoryName.setter
+    def repositoryName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requestId = value
+            self._repositoryName = value
         else:
             raise TypeError(
-                'Property "requestId" of type "list<str>" set to wrong type'
+                'Property "repositoryName" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def requesterClientId(self):
-        """str: which clientId requests audit logs"""
-        return self._requesterClientId
+    def tag(self):
+        """str: Image tag"""
+        return self._tag
 
-    @requesterClientId.setter
-    def requesterClientId(self, value):
+    @tag.setter
+    def tag(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requesterClientId = value
+            self._tag = value
         else:
             raise TypeError(
-                'Property "requesterClientId" of type "list<str>" set to wron'
-                'g type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     @property
-    def toDate(self):
-        """str: Audit logs to date in ISO-8601 format"""
-        return self._toDate
+    def updatedDate(self):
+        """str: Image update date in ISO-8601 format"""
+        return self._updatedDate
 
-    @toDate.setter
-    def toDate(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._toDate = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "toDate" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._authToken is not None:
-            result["authToken"] = \
-                self._authToken
-        if self._filters:
-            result["filters"] = \
-                self._filters.toDict() if self._filters is not None else None
-        if self._fromDate is not None:
-            result["fromDate"] = \
-                self._fromDate
-        if self._inputId is not None:
-            result["inputId"] = \
-                self._inputId
-        if self._logType is not None:
-            result["logType"] = \
-                self._logType
-        if self._requestId is not None:
-            result["requestId"] = \
-                self._requestId
-        if self._requesterClientId is not None:
-            result["requesterClientId"] = \
-                self._requesterClientId
-        if self._toDate is not None:
-            result["toDate"] = \
-                self._toDate
+        if self._isSigned is not None:
+            result["isSigned"] = \
+                self._isSigned
+        if self._orgAlternateContact is not None:
+            result["orgAlternateContact"] = \
+                self._orgAlternateContact
+        if self._orgOwnersEmails is not None:
+            result["orgOwnersEmails"] = \
+                self._orgOwnersEmails
+        if self._pushedByUserEmail is not None:
+            result["pushedByUserEmail"] = \
+                self._pushedByUserEmail
+        if self._pushedDate is not None:
+            result["pushedDate"] = \
+                self._pushedDate
+        if self._repositoryCreatorUserEmail is not None:
+            result["repositoryCreatorUserEmail"] = \
+                self._repositoryCreatorUserEmail
+        if self._repositoryName is not None:
+            result["repositoryName"] = \
+                self._repositoryName
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._fromDate is None:
-            raise ValueError(
-                "AuditLogsEventRequest.fromDate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._toDate is None:
-            raise ValueError(
-                "AuditLogsEventRequest.toDate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._requesterClientId is None:
-            raise ValueError(
-                "AuditLogsEventRequest.requesterClientId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._requestId is None:
-            raise ValueError(
-                "AuditLogsEventRequest.requestId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._logType is None:
-            raise ValueError(
-                "AuditLogsEventRequest.logType doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._filters is not None): self._filters.isValid()
         return True
```

## Comparing `ngccli/data/api/AuditLogsEventResponse.py` & `ngcbpc/data/model/AIPlaygroundResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,224 +6,222 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CelestialErrorDetail import CelestialErrorDetail
 
 # Unused import over optimization prevention
-str(repr(CelestialErrorDetail))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogsEventResponse(object):
+class AIPlaygroundResponse(object):
+    """Request to fetch an AI Playground config"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.errorDetails = (
+        self.artifactName = (
             None if not fromDict or propDict.get(
-                "errorDetails"
+                "artifactName"
             ) is None
-            else propDict["errorDetails"])
-        self.expiration = (
+            else propDict["artifactName"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "expiration"
+                "attributes"
             ) is None
-            else propDict["expiration"])
-        self.logUrl = (
+            else propDict["attributes"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "logUrl"
+                "createdDate"
             ) is None
-            else propDict["logUrl"])
-        self.outputFormat = (
+            else propDict["createdDate"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "outputFormat"
+                "namespace"
             ) is None
-            else propDict["outputFormat"])
-        self.requestId = (
+            else propDict["namespace"])
+        self.nvcfFunctionId = (
             None if not fromDict or propDict.get(
-                "requestId"
+                "nvcfFunctionId"
             ) is None
-            else propDict["requestId"])
-        self.requesterClientId = (
+            else propDict["nvcfFunctionId"])
+        self.openAPISpec = (
             None if not fromDict or propDict.get(
-                "requesterClientId"
+                "openAPISpec"
             ) is None
-            else propDict["requesterClientId"])
-        self.status = (
+            else propDict["openAPISpec"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "status"
+                "updatedDate"
             ) is None
-            else propDict["status"])
+            else propDict["updatedDate"])
 
     @property
-    def errorDetails(self):
-        """CelestialErrorDetail: ACE is a collection of nodes that can run job
-        s"""
-        return self._errorDetails
+    def artifactName(self):
+        """str: Unique name of the model"""
+        return self._artifactName
 
-    @errorDetails.setter
-    def errorDetails(self, value):
-        if value is not None and not isinstance(value, CelestialErrorDetail):
-            value = CelestialErrorDetail(value)
-        if (value is None) or isinstance(value, CelestialErrorDetail):
-            self._errorDetails = value
+    @artifactName.setter
+    def artifactName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactName = value
         else:
             raise TypeError(
-                'Property "errorDetails" of type "list<CelestialErrorDetail>"'
-                ' set to wrong type'
+                'Property "artifactName" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def expiration(self):
-        """long: Expiration for S3 presigned URL from Celestial service. Unix 
-        timestamp in milliseconds long type"""
-        return self._expiration
+    def attributes(self):
+        """str: Metadata json string"""
+        return self._attributes
 
-    @expiration.setter
-    def expiration(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._expiration = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "expiration" of type "list<long>" set to wrong type'
+                'Property "attributes" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logUrl(self):
-        """str: A S3 presigned URL from Celestial service"""
-        return self._logUrl
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @logUrl.setter
-    def logUrl(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logUrl = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "logUrl" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def outputFormat(self):
-        """OutputFormatEnum: Compression format of the output file. Either GZ/
-        Parquet. From Pradeep: we can take it as null value as the dat
-        a will be in gzip format"""
-        return self._outputFormat
+    def namespace(self):
+        """str: org/team of the model"""
+        return self._namespace
 
-    @outputFormat.setter
-    def outputFormat(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._outputFormat = value
+    @namespace.setter
+    def namespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "outputFormat" of type "list<OutputFormatEnum>" set'
-                ' to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
-    OutputFormatEnum=["PARQUET","GZ",]
-    str(repr(OutputFormatEnum))  # Prevent optimizer removing enum
-
     @property
-    def requestId(self):
-        """str: The unique identifier of audit logs event sent by client"""
-        return self._requestId
+    def nvcfFunctionId(self):
+        """str: NVCF function id for the model playground"""
+        return self._nvcfFunctionId
 
-    @requestId.setter
-    def requestId(self, value):
+    @nvcfFunctionId.setter
+    def nvcfFunctionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requestId = value
+            self._nvcfFunctionId = value
         else:
             raise TypeError(
-                'Property "requestId" of type "list<str>" set to wrong type'
+                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def requesterClientId(self):
-        """str: which clientId requests audit logs"""
-        return self._requesterClientId
+    def openAPISpec(self):
+        """str: OpenAPI specification for this model"""
+        return self._openAPISpec
 
-    @requesterClientId.setter
-    def requesterClientId(self, value):
+    @openAPISpec.setter
+    def openAPISpec(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requesterClientId = value
+            self._openAPISpec = value
         else:
             raise TypeError(
-                'Property "requesterClientId" of type "list<str>" set to wron'
-                'g type'
+                'Property "openAPISpec" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """StatusEnum: Status from backend processing"""
-        return self._status
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "status" of type "list<StatusEnum>" set to wrong ty'
-                'pe'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
-    StatusEnum=["SUCCEEDED","FAILED","ERROR","TIMEOUT",]
-    str(repr(StatusEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._errorDetails:
-            result["errorDetails"] = \
-                self._errorDetails.toDict() if self._errorDetails is not None else None
-        if self._expiration is not None:
-            result["expiration"] = \
-                self._expiration
-        if self._logUrl is not None:
-            result["logUrl"] = \
-                self._logUrl
-        if self._outputFormat is not None:
-            result["outputFormat"] = \
-                self._outputFormat
-        if self._requestId is not None:
-            result["requestId"] = \
-                self._requestId
-        if self._requesterClientId is not None:
-            result["requesterClientId"] = \
-                self._requesterClientId
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._artifactName is not None:
+            result["artifactName"] = \
+                self._artifactName
+        if self._attributes is not None:
+            result["attributes"] = \
+                self._attributes
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._nvcfFunctionId is not None:
+            result["nvcfFunctionId"] = \
+                self._nvcfFunctionId
+        if self._openAPISpec is not None:
+            result["openAPISpec"] = \
+                self._openAPISpec
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._requestId is None:
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "AuditLogsEventResponse.requestId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._requesterClientId is None:
+                "AIPlaygroundResponse.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
             raise ValueError(
-                "AuditLogsEventResponse.requesterClientId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._errorDetails is not None): self._errorDetails.isValid()
+                "AIPlaygroundResponse.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/api/AuditLogsPresignedUrlResponse.py` & `ngcbpc/data/uis/UserInvitationResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,52 +7,53 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
+from .UserInvitation import UserInvitation
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
+str(repr(UserInvitation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogsPresignedUrlResponse(object):
-    """List of audit logs object"""
+class UserInvitationResponse(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.auditLogsPresignedUrl = (
+        self.invitation = (
             None if not fromDict or propDict.get(
-                "auditLogsPresignedUrl"
+                "invitation"
             ) is None
-            else propDict["auditLogsPresignedUrl"])
+            else propDict["invitation"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def auditLogsPresignedUrl(self):
-        """str: Presign url for user to download audit logs"""
-        return self._auditLogsPresignedUrl
-
-    @auditLogsPresignedUrl.setter
-    def auditLogsPresignedUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._auditLogsPresignedUrl = value
+    def invitation(self):
+        """UserInvitation: User invitation to an NGC org or team"""
+        return self._invitation
+
+    @invitation.setter
+    def invitation(self, value):
+        if value is not None and not isinstance(value, UserInvitation):
+            value = UserInvitation(value)
+        if (value is None) or isinstance(value, UserInvitation):
+            self._invitation = value
         else:
             raise TypeError(
-                'Property "auditLogsPresignedUrl" of type "list<str>" set to '
+                'Property "invitation" of type "list<UserInvitation>" set to '
                 'wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
@@ -67,26 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._auditLogsPresignedUrl is not None:
-            result["auditLogsPresignedUrl"] = \
-                self._auditLogsPresignedUrl
+        if self._invitation:
+            result["invitation"] = \
+                self._invitation.toDict() if self._invitation is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._invitation is not None): self._invitation.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/AuditLogsRequest.py` & `ngcbpc/data/model/HelmChartMaintainer.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,85 +14,97 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogsRequest(object):
-    """object used to request audit logs"""
+class HelmChartMaintainer(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.auditLogsFrom = (
+        self.email = (
             None if not fromDict or propDict.get(
-                "auditLogsFrom"
+                "email"
             ) is None
-            else propDict["auditLogsFrom"])
-        self.auditLogsTo = (
+            else propDict["email"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "auditLogsTo"
+                "name"
             ) is None
-            else propDict["auditLogsTo"])
+            else propDict["name"])
+        self.url = (
+            None if not fromDict or propDict.get(
+                "url"
+            ) is None
+            else propDict["url"])
 
     @property
-    def auditLogsFrom(self):
-        """str: Audit logs from date in ISO-8601 format"""
-        return self._auditLogsFrom
+    def email(self):
+        """str: The maintainer's email (optional for each maintainer)"""
+        return self._email
 
-    @auditLogsFrom.setter
-    def auditLogsFrom(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._auditLogsFrom = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "auditLogsFrom" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def auditLogsTo(self):
-        """str: Audit logs to date in ISO-8601 format"""
-        return self._auditLogsTo
+    def name(self):
+        """str: The maintainer's name (required for each maintainer)"""
+        return self._name
 
-    @auditLogsTo.setter
-    def auditLogsTo(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._auditLogsTo = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "auditLogsTo" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def url(self):
+        """str: A URL for the maintainer (optional for each maintainer)"""
+        return self._url
+
+    @url.setter
+    def url(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._url = value
+        else:
+            raise TypeError(
+                'Property "url" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._auditLogsFrom is not None:
-            result["auditLogsFrom"] = \
-                self._auditLogsFrom
-        if self._auditLogsTo is not None:
-            result["auditLogsTo"] = \
-                self._auditLogsTo
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._url is not None:
+            result["url"] = \
+                self._url
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._auditLogsFrom is None:
-            raise ValueError(
-                "AuditLogsRequest.auditLogsFrom doesnt match requirement:" 
-                "required: True"
-            )
-        if self._auditLogsTo is None:
-            raise ValueError(
-                "AuditLogsRequest.auditLogsTo doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/AuditLogsResponse.py` & `organization/data/subscription_management_service/ProductResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,57 +6,55 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AuditLogs import AuditLogs
+from .Product import Product
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(AuditLogs))
+str(repr(Product))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AuditLogsResponse(object):
-    """List of audit logs object"""
+class ProductResponse(object):
+    """Response for product API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.auditLogsList = (
+        self.product = (
             None if not fromDict or propDict.get(
-                "auditLogsList"
+                "product"
             ) is None
-            else [ AuditLogs(i)
-            for i in propDict["auditLogsList"] ])
+            else propDict["product"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def auditLogsList(self):
-        """list: Array of auditLogs object"""
-        return self._auditLogsList
-
-    @auditLogsList.setter
-    def auditLogsList(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._auditLogsList = value
+    def product(self):
+        """ """
+        return self._product
+
+    @product.setter
+    def product(self, value):
+        if value is not None and not isinstance(value, Product):
+            value = Product(value)
+        if (value is None) or isinstance(value, Product):
+            self._product = value
         else:
             raise TypeError(
-                'Property "auditLogsList" of type "list<AuditLogs>" set to wr'
-                'ong type'
+                'Property "product" of type "list<Product>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,30 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._auditLogsList:
-            result["auditLogsList"] = [
-                i.toDict() for i in self._auditLogsList 
-            ] if self._auditLogsList else []
+        if self._product:
+            result["product"] = \
+                self._product.toDict() if self._product is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._auditLogsList is not None):
-            for obj in self._auditLogsList:
-                if (obj is not None): obj.isValid()
+        if (self._product is not None): self._product.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEvent.py` & `ngcbpc/data/model/CatalogArtifactMetadata.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,146 +6,159 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncident import BannerEventIncident
-from .BannerEventTypeEnum import BannerEventTypeEnum
+from .AccessTypeEnum import AccessTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
-str(repr(BannerEventIncident))
+str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEvent(object):
-    """Object of banner event data"""
+class CatalogArtifactMetadata(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.bannerEventType = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "bannerEventType"
+                "accessType"
             ) is None
-            else propDict["bannerEventType"])
-        self.eventId = (
+            else propDict["accessType"])
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "eventId"
+                "canGuestPull"
             ) is None
-            else propDict["eventId"])
-        self.eventUuid = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "eventUuid"
+                "canPublicList"
             ) is None
-            else propDict["eventUuid"])
-        self.incident = (
+            else propDict["canPublicList"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "incident"
+                "isPublic"
             ) is None
-            else propDict["incident"])
+            else propDict["isPublic"])
+        self.productNames = (
+            None if not fromDict or propDict.get(
+                "productNames"
+            ) is None
+            else propDict["productNames"])
 
     @property
-    def bannerEventType(self):
-        """BannerEventTypeEnum: Banner event type. Default to INCIDENT"""
-        return self._bannerEventType
+    def accessType(self):
+        """ """
+        return self._accessType
 
-    @bannerEventType.setter
-    def bannerEventType(self, value):
+    @accessType.setter
+    def accessType(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._bannerEventType = value
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "bannerEventType" of type "list<BannerEventTypeEnum'
-                '>" set to wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def eventId(self):
-        """str: EventId generated by server. For example U20210610A. The date 
-        inside the eventId is UTC 00:00 based"""
-        return self._eventId
-
-    @eventId.setter
-    def eventId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._eventId = value
+    def canGuestPull(self):
+        """bool: Guest users can download from the Catalog registry"""
+        return self._canGuestPull
+
+    @canGuestPull.setter
+    def canGuestPull(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "eventId" of type "list<str>" set to wrong type'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def eventUuid(self):
-        """str: Event unique time UUID."""
-        return self._eventUuid
-
-    @eventUuid.setter
-    def eventUuid(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._eventUuid = value
+    def canPublicList(self):
+        """bool: Publicly listed/searchable in the Catalog registry"""
+        return self._canPublicList
+
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "eventUuid" of type "list<str>" set to wrong type'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def incident(self):
-        """BannerEventIncident: Object of banner event incident data"""
-        return self._incident
-
-    @incident.setter
-    def incident(self, value):
-        if value is not None and not isinstance(value, BannerEventIncident):
-            value = BannerEventIncident(value)
-        if (value is None) or isinstance(value, BannerEventIncident):
-            self._incident = value
+    def isPublic(self):
+        """bool: Publicly available in the Catalog registry"""
+        return self._isPublic
+
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
         else:
             raise TypeError(
-                'Property "incident" of type "list<BannerEventIncident>" set '
-                'to wrong type'
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
+
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
+        else:
+            raise TypeError(
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._bannerEventType is not None:
-            result["bannerEventType"] = \
-                self._bannerEventType
-        if self._eventId is not None:
-            result["eventId"] = \
-                self._eventId
-        if self._eventUuid is not None:
-            result["eventUuid"] = \
-                self._eventUuid
-        if self._incident:
-            result["incident"] = \
-                self._incident.toDict() if self._incident is not None else None
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._eventUuid is None:
-            raise ValueError(
-                "BannerEvent.eventUuid doesnt match requirement:" 
-                "required: True"
-            )
-        if self._eventId is None:
-            raise ValueError(
-                "BannerEvent.eventId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._incident is not None): self._incident.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventCreateRequest.py` & `basecommand/data/pym/ProjectTemplateParams.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,199 +6,211 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventTypeEnum import BannerEventTypeEnum
+from .ClusterParams import ClusterParams
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
-str(repr(BannerEventIncidentSeverityEnum))
+str(repr(ClusterParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventCreateRequest(object):
-    """request to create a banner event"""
+class ProjectTemplateParams(object):
+    """Project template parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.backfilledTime = (
+        self.clusterParams = (
             None if not fromDict or propDict.get(
-                "backfilledTime"
+                "clusterParams"
             ) is None
-            else propDict["backfilledTime"])
-        self.bannerEventType = (
+            else propDict["clusterParams"])
+        self.clusterType = (
             None if not fromDict or propDict.get(
-                "bannerEventType"
+                "clusterType"
             ) is None
-            else propDict["bannerEventType"])
-        self.estimatedUpdateTime = (
+            else propDict["clusterType"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "description"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.incidentSeverity = (
+            else propDict["description"])
+        self.displayImageURL = (
             None if not fromDict or propDict.get(
-                "incidentSeverity"
+                "displayImageURL"
             ) is None
-            else propDict["incidentSeverity"])
-        self.message = (
+            else propDict["displayImageURL"])
+        self.isDefault = (
             None if not fromDict or propDict.get(
-                "message"
+                "isDefault"
             ) is None
-            else propDict["message"])
+            else propDict["isDefault"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
 
     @property
-    def backfilledTime(self):
-        """str: Backfilled time for the banner event"""
-        return self._backfilledTime
+    def clusterParams(self):
+        """ClusterParams: Cluster params"""
+        return self._clusterParams
+
+    @clusterParams.setter
+    def clusterParams(self, value):
+        if value is not None and not isinstance(value, ClusterParams):
+            value = ClusterParams(value)
+        if (value is None) or isinstance(value, ClusterParams):
+            self._clusterParams = value
+        else:
+            raise TypeError(
+                'Property "clusterParams" of type "list<ClusterParams>" set t'
+                'o wrong type'
+            )
 
-    @backfilledTime.setter
-    def backfilledTime(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._backfilledTime = value
+    @property
+    def clusterType(self):
+        """ """
+        return self._clusterType
+
+    @clusterType.setter
+    def clusterType(self, value):
+        if value is not None and not isinstance(value, str):
+            value = str(value)
+        if (value is None) or isinstance(value, str):
+            self._clusterType = value
         else:
             raise TypeError(
-                'Property "backfilledTime" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "clusterType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bannerEventType(self):
-        """BannerEventTypeEnum: Banner event type. Default to INCIDENT"""
-        return self._bannerEventType
+    def description(self):
+        """str: Project template description"""
+        return self._description
 
-    @bannerEventType.setter
-    def bannerEventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._bannerEventType = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "bannerEventType" of type "list<BannerEventTypeEnum'
-                '>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated update time for the banner event"""
-        return self._estimatedUpdateTime
+    def displayImageURL(self):
+        """str: Display Image URL"""
+        return self._displayImageURL
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
+    @displayImageURL.setter
+    def displayImageURL(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+            self._displayImageURL = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "displayImageURL" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def incidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._incidentSeverity
-
-    @incidentSeverity.setter
-    def incidentSeverity(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentSeverity = value
+    def isDefault(self):
+        """bool: Indicate if template is default"""
+        return self._isDefault
+
+    @isDefault.setter
+    def isDefault(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isDefault = value
         else:
             raise TypeError(
-                'Property "incidentSeverity" of type "list<BannerEventInciden'
-                'tSeverityEnum>" set to wrong type'
+                'Property "isDefault" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def message(self):
-        """str: User defined message for the banner announcement event, max 10
-        24 chars"""
-        return self._message
+    def name(self):
+        """str: Project template name"""
+        return self._name
 
-    @message.setter
-    def message(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._backfilledTime is not None:
-            result["backfilledTime"] = \
-                self._backfilledTime
-        if self._bannerEventType is not None:
-            result["bannerEventType"] = \
-                self._bannerEventType
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._incidentSeverity is not None:
-            result["incidentSeverity"] = \
-                self._incidentSeverity
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._clusterParams:
+            result["clusterParams"] = \
+                self._clusterParams.toDict() if self._clusterParams is not None else None
+        if self._clusterType is not None:
+            result["clusterType"] = \
+                self._clusterType
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayImageURL is not None:
+            result["displayImageURL"] = \
+                self._displayImageURL
+        if self._isDefault is not None:
+            result["isDefault"] = \
+                self._isDefault
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._message is None:
+        if self._name is None:
             raise ValueError(
-                "BannerEventCreateRequest.message doesnt match requirement:" 
+                "ProjectTemplateParams.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._message is not None
-            and
-            len(self._message) < 2):
-            raise ValueError(
-                "BannerEventCreateRequest.message: " + str(self._message) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._message is not None
+        if (self._name is not None
             and
-            len(self._message) > 1024):
+            len(self._name) < 1):
             raise ValueError(
-                "BannerEventCreateRequest.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 1024")
-        if self._incidentSeverity is None:
+                "ProjectTemplateParams.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._description is None:
             raise ValueError(
-                "BannerEventCreateRequest.incidentSeverity doesnt match requirement:" 
+                "ProjectTemplateParams.description doesnt match requirement:" 
                 "required: True"
             )
-        if (self._backfilledTime is not None
+        if (self._description is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._backfilledTime)):
+            len(self._description) < 1):
             raise ValueError(
-                "BannerEventCreateRequest.backfilledTime: " + str(self._backfilledTime) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._estimatedUpdateTime is not None
+                "ProjectTemplateParams.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._displayImageURL is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._estimatedUpdateTime)):
+            len(self._displayImageURL) < 1):
             raise ValueError(
-                "BannerEventCreateRequest.estimatedUpdateTime: " + str(self._estimatedUpdateTime) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "ProjectTemplateParams.displayImageURL: " + str(self._displayImageURL) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._clusterParams is not None): self._clusterParams.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventCreateResponse.py` & `ngcbpc/data/uis/UserProfile.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,340 +6,350 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
-from .BannerEventTypeEnum import BannerEventTypeEnum
+from .UserProfileOrgInfo import UserProfileOrgInfo
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
-str(repr(BannerEventIncidentStatusEnum))
-str(repr(BannerEventIncidentSeverityEnum))
+str(repr(UserProfileOrgInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventCreateResponse(object):
-    """response to create a banner event"""
+class UserProfile(object):
+    """The profile of user."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.backfilledTime = (
+        self.country = (
             None if not fromDict or propDict.get(
-                "backfilledTime"
+                "country"
             ) is None
-            else propDict["backfilledTime"])
-        self.bannerEventType = (
+            else propDict["country"])
+        self.devEmailable = (
             None if not fromDict or propDict.get(
-                "bannerEventType"
+                "devEmailable"
             ) is None
-            else propDict["bannerEventType"])
-        self.createdTime = (
+            else propDict["devEmailable"])
+        self.email = (
             None if not fromDict or propDict.get(
-                "createdTime"
+                "email"
             ) is None
-            else propDict["createdTime"])
-        self.estimatedUpdateTime = (
+            else propDict["email"])
+        self.entEmailable = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "entEmailable"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.eventId = (
+            else propDict["entEmailable"])
+        self.firstName = (
             None if not fromDict or propDict.get(
-                "eventId"
+                "firstName"
             ) is None
-            else propDict["eventId"])
-        self.eventIdSequenceNumber = (
+            else propDict["firstName"])
+        self.gender = (
             None if not fromDict or propDict.get(
-                "eventIdSequenceNumber"
+                "gender"
             ) is None
-            else propDict["eventIdSequenceNumber"])
-        self.eventUuid = (
+            else propDict["gender"])
+        self.lastName = (
             None if not fromDict or propDict.get(
-                "eventUuid"
+                "lastName"
             ) is None
-            else propDict["eventUuid"])
-        self.incidentSeverity = (
+            else propDict["lastName"])
+        self.locale = (
             None if not fromDict or propDict.get(
-                "incidentSeverity"
+                "locale"
             ) is None
-            else propDict["incidentSeverity"])
-        self.incidentStatus = (
+            else propDict["locale"])
+        self.orgInfo = (
             None if not fromDict or propDict.get(
-                "incidentStatus"
+                "orgInfo"
             ) is None
-            else propDict["incidentStatus"])
-        self.message = (
+            else [ UserProfileOrgInfo(i)
+            for i in propDict["orgInfo"] ])
+        self.preferences = (
             None if not fromDict or propDict.get(
-                "message"
+                "preferences"
             ) is None
-            else propDict["message"])
-        self.orgName = (
+            else propDict["preferences"])
+        self.starfleetId = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "starfleetId"
             ) is None
-            else propDict["orgName"])
+            else propDict["starfleetId"])
 
     @property
-    def backfilledTime(self):
-        """str: Backfilled time of the banner event in UTC 00:00"""
-        return self._backfilledTime
+    def country(self):
+        """str: Country of the user"""
+        return self._country
 
-    @backfilledTime.setter
-    def backfilledTime(self, value):
+    @country.setter
+    def country(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._backfilledTime = value
+            self._country = value
         else:
             raise TypeError(
-                'Property "backfilledTime" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "country" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bannerEventType(self):
-        """BannerEventTypeEnum: Banner event type. Default to INCIDENT"""
-        return self._bannerEventType
+    def devEmailable(self):
+        """bool: User want to receive development promotions"""
+        return self._devEmailable
 
-    @bannerEventType.setter
-    def bannerEventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._bannerEventType = value
+    @devEmailable.setter
+    def devEmailable(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._devEmailable = value
         else:
             raise TypeError(
-                'Property "bannerEventType" of type "list<BannerEventTypeEnum'
-                '>" set to wrong type'
+                'Property "devEmailable" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def createdTime(self):
-        """str: Created time of the banner event in UTC 00:00"""
-        return self._createdTime
+    def email(self):
+        """str: Email of the user"""
+        return self._email
 
-    @createdTime.setter
-    def createdTime(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdTime = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "createdTime" of type "list<str>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated update time of the banner event in UTC 00:00"""
-        return self._estimatedUpdateTime
+    def entEmailable(self):
+        """bool: User want to receive enterprise promotions"""
+        return self._entEmailable
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+    @entEmailable.setter
+    def entEmailable(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._entEmailable = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "entEmailable" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def eventId(self):
-        """str: EventId generated by server. For example U20210610A. The date 
-        inside the eventId is UTC 00:00 based"""
-        return self._eventId
+    def firstName(self):
+        """str: User's first name"""
+        return self._firstName
 
-    @eventId.setter
-    def eventId(self, value):
+    @firstName.setter
+    def firstName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._eventId = value
+            self._firstName = value
         else:
             raise TypeError(
-                'Property "eventId" of type "list<str>" set to wrong type'
+                'Property "firstName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventIdSequenceNumber(self):
-        """long: Sequence number of the eventId, initialized to 0 and incremen
-        ted by one each time the event gets updated"""
-        return self._eventIdSequenceNumber
+    def gender(self):
+        """str: User's gender"""
+        return self._gender
 
-    @eventIdSequenceNumber.setter
-    def eventIdSequenceNumber(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._eventIdSequenceNumber = value
+    @gender.setter
+    def gender(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gender = value
         else:
             raise TypeError(
-                'Property "eventIdSequenceNumber" of type "list<long>" set to'
-                ' wrong type'
+                'Property "gender" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventUuid(self):
-        """str: Event unique UUID."""
-        return self._eventUuid
+    def lastName(self):
+        """str: User's last name"""
+        return self._lastName
 
-    @eventUuid.setter
-    def eventUuid(self, value):
+    @lastName.setter
+    def lastName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._eventUuid = value
+            self._lastName = value
         else:
             raise TypeError(
-                'Property "eventUuid" of type "list<str>" set to wrong type'
+                'Property "lastName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._incidentSeverity
+    def locale(self):
+        """str: Locale of the user"""
+        return self._locale
 
-    @incidentSeverity.setter
-    def incidentSeverity(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentSeverity = value
+    @locale.setter
+    def locale(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._locale = value
         else:
             raise TypeError(
-                'Property "incidentSeverity" of type "list<BannerEventInciden'
-                'tSeverityEnum>" set to wrong type'
+                'Property "locale" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentStatus(self):
-        """BannerEventIncidentStatusEnum: Banner event incident status."""
-        return self._incidentStatus
+    def orgInfo(self):
+        """list: organization information about the user"""
+        return self._orgInfo
 
-    @incidentStatus.setter
-    def incidentStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentStatus = value
+    @orgInfo.setter
+    def orgInfo(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._orgInfo = value
         else:
             raise TypeError(
-                'Property "incidentStatus" of type "list<BannerEventIncidentS'
-                'tatusEnum>" set to wrong type'
+                'Property "orgInfo" of type "list<UserProfileOrgInfo>" set to'
+                ' wrong type'
             )
 
     @property
-    def message(self):
-        """str: User defined message for the banner announcement event, max 10
-        24 chars"""
-        return self._message
+    def preferences(self):
+        """list: List of development areas that user has preference"""
+        return self._preferences
 
-    @message.setter
-    def message(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._message = value
+    @preferences.setter
+    def preferences(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._preferences = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "preferences" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Name of org that the banner event belongs to"""
-        return self._orgName
+    def starfleetId(self):
+        """str: User's starfleet id"""
+        return self._starfleetId
 
-    @orgName.setter
-    def orgName(self, value):
+    @starfleetId.setter
+    def starfleetId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._starfleetId = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "starfleetId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._backfilledTime is not None:
-            result["backfilledTime"] = \
-                self._backfilledTime
-        if self._bannerEventType is not None:
-            result["bannerEventType"] = \
-                self._bannerEventType
-        if self._createdTime is not None:
-            result["createdTime"] = \
-                self._createdTime
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._eventId is not None:
-            result["eventId"] = \
-                self._eventId
-        if self._eventIdSequenceNumber is not None:
-            result["eventIdSequenceNumber"] = \
-                self._eventIdSequenceNumber
-        if self._eventUuid is not None:
-            result["eventUuid"] = \
-                self._eventUuid
-        if self._incidentSeverity is not None:
-            result["incidentSeverity"] = \
-                self._incidentSeverity
-        if self._incidentStatus is not None:
-            result["incidentStatus"] = \
-                self._incidentStatus
-        if self._message is not None:
-            result["message"] = \
-                self._message
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._country is not None:
+            result["country"] = \
+                self._country
+        if self._devEmailable is not None:
+            result["devEmailable"] = \
+                self._devEmailable
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._entEmailable is not None:
+            result["entEmailable"] = \
+                self._entEmailable
+        if self._firstName is not None:
+            result["firstName"] = \
+                self._firstName
+        if self._gender is not None:
+            result["gender"] = \
+                self._gender
+        if self._lastName is not None:
+            result["lastName"] = \
+                self._lastName
+        if self._locale is not None:
+            result["locale"] = \
+                self._locale
+        if self._orgInfo:
+            result["orgInfo"] = [
+                i.toDict() for i in self._orgInfo 
+            ] if self._orgInfo else []
+        if self._preferences is not None:
+            result["preferences"] = \
+                self._preferences
+        if self._starfleetId is not None:
+            result["starfleetId"] = \
+                self._starfleetId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._eventUuid is None:
+        if self._email is None:
             raise ValueError(
-                "BannerEventCreateResponse.eventUuid doesnt match requirement:" 
+                "UserProfile.email doesnt match requirement:" 
                 "required: True"
             )
-        if self._eventId is None:
+        if (self._firstName is not None
+            and
+            len(self._firstName) > 255):
+            raise ValueError(
+                "UserProfile.firstName: " + str(self._firstName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._lastName is not None
+            and
+            len(self._lastName) > 255):
+            raise ValueError(
+                "UserProfile.lastName: " + str(self._lastName) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._country is None:
             raise ValueError(
-                "BannerEventCreateResponse.eventId doesnt match requirement:" 
+                "UserProfile.country doesnt match requirement:" 
                 "required: True"
             )
-        if self._eventIdSequenceNumber is None:
+        if self._locale is None:
             raise ValueError(
-                "BannerEventCreateResponse.eventIdSequenceNumber doesnt match requirement:" 
+                "UserProfile.locale doesnt match requirement:" 
                 "required: True"
             )
-        if (self._eventIdSequenceNumber is not None
-            and
-            self._eventIdSequenceNumber < 0):
+        if self._starfleetId is None:
             raise ValueError(
-                "BannerEventCreateResponse.eventIdSequenceNumber: " + str(self._eventIdSequenceNumber) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._message is not None
-            and
-            len(self._message) < 2):
+                "UserProfile.starfleetId doesnt match requirement:" 
+                "required: True"
+            )
+        if self._devEmailable is None:
             raise ValueError(
-                "BannerEventCreateResponse.message: " + str(self._message) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._message is not None
-            and
-            len(self._message) > 1024):
+                "UserProfile.devEmailable doesnt match requirement:" 
+                "required: True"
+            )
+        if self._entEmailable is None:
             raise ValueError(
-                "BannerEventCreateResponse.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 1024")
+                "UserProfile.entEmailable doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._orgInfo is not None):
+            for obj in self._orgInfo:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventIncident.py` & `ngcbpc/data/registry/ImageScanDetails.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,259 +6,322 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
-from .BannerEventIncidentMeta import BannerEventIncidentMeta
+from .ScanIssue import ScanIssue
+from .ScanIssueCount import ScanIssueCount
+from .SecurityRatingType import SecurityRatingTypeEnum
+from .ScanStatus import ScanStatusEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventIncidentStatusEnum))
-str(repr(BannerEventIncidentMeta))
-str(repr(BannerEventIncidentSeverityEnum))
+str(repr(ScanIssue))
+str(repr(ScanStatusEnum))
+str(repr(SecurityRatingTypeEnum))
+str(repr(ScanIssueCount))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventIncident(object):
-    """Object of banner event incident data"""
+class ImageScanDetails(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.backfilledTime = (
+        self.evaluationProblems = (
             None if not fromDict or propDict.get(
-                "backfilledTime"
+                "evaluationProblems"
             ) is None
-            else propDict["backfilledTime"])
-        self.currentIncidentSeverity = (
+            else propDict["evaluationProblems"])
+        self.finalAction = (
             None if not fromDict or propDict.get(
-                "currentIncidentSeverity"
+                "finalAction"
             ) is None
-            else propDict["currentIncidentSeverity"])
-        self.currentIncidentStatus = (
+            else propDict["finalAction"])
+        self.finalActionReason = (
             None if not fromDict or propDict.get(
-                "currentIncidentStatus"
+                "finalActionReason"
             ) is None
-            else propDict["currentIncidentStatus"])
-        self.currentMessage = (
+            else propDict["finalActionReason"])
+        self.policyBundleName = (
             None if not fromDict or propDict.get(
-                "currentMessage"
+                "policyBundleName"
             ) is None
-            else propDict["currentMessage"])
-        self.estimatedUpdateTime = (
+            else propDict["policyBundleName"])
+        self.policyLastUpdate = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "policyLastUpdate"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.incidentHistory = (
+            else propDict["policyLastUpdate"])
+        self.rating = (
             None if not fromDict or propDict.get(
-                "incidentHistory"
+                "rating"
             ) is None
-            else [ BannerEventIncidentMeta(i)
-            for i in propDict["incidentHistory"] ])
-        self.initialPostTime = (
+            else propDict["rating"])
+        self.scanDate = (
             None if not fromDict or propDict.get(
-                "initialPostTime"
+                "scanDate"
             ) is None
-            else propDict["initialPostTime"])
-        self.lastUpdatedTime = (
+            else propDict["scanDate"])
+        self.scanIssueCounts = (
             None if not fromDict or propDict.get(
-                "lastUpdatedTime"
+                "scanIssueCounts"
             ) is None
-            else propDict["lastUpdatedTime"])
+            else [ ScanIssueCount(i)
+            for i in propDict["scanIssueCounts"] ])
+        self.scanIssues = (
+            None if not fromDict or propDict.get(
+                "scanIssues"
+            ) is None
+            else [ ScanIssue(i)
+            for i in propDict["scanIssues"] ])
+        self.scanOutcome = (
+            None if not fromDict or propDict.get(
+                "scanOutcome"
+            ) is None
+            else propDict["scanOutcome"])
+        self.scanStatus = (
+            None if not fromDict or propDict.get(
+                "scanStatus"
+            ) is None
+            else propDict["scanStatus"])
 
     @property
-    def backfilledTime(self):
-        """str: Backfilled time of the banner event in UTC 00:00"""
-        return self._backfilledTime
+    def evaluationProblems(self):
+        """list: Problems reported by anchore engine"""
+        return self._evaluationProblems
+
+    @evaluationProblems.setter
+    def evaluationProblems(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._evaluationProblems = value
+        else:
+            raise TypeError(
+                'Property "evaluationProblems" of type "list<str>" set to wro'
+                'ng type'
+            )
 
-    @backfilledTime.setter
-    def backfilledTime(self, value):
+    @property
+    def finalAction(self):
+        """str: Recommended action, decided by the policy"""
+        return self._finalAction
+
+    @finalAction.setter
+    def finalAction(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._backfilledTime = value
+            self._finalAction = value
         else:
             raise TypeError(
-                'Property "backfilledTime" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "finalAction" of type "list<str>" set to wrong type'
             )
 
     @property
-    def currentIncidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._currentIncidentSeverity
+    def finalActionReason(self):
+        """str: Reason why final action is returned"""
+        return self._finalActionReason
 
-    @currentIncidentSeverity.setter
-    def currentIncidentSeverity(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._currentIncidentSeverity = value
+    @finalActionReason.setter
+    def finalActionReason(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._finalActionReason = value
         else:
             raise TypeError(
-                'Property "currentIncidentSeverity" of type "list<BannerEvent'
-                'IncidentSeverityEnum>" set to wrong type'
+                'Property "finalActionReason" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def currentIncidentStatus(self):
-        """BannerEventIncidentStatusEnum: Banner event incident status."""
-        return self._currentIncidentStatus
+    def policyBundleName(self):
+        """str: Name of the policy used to scan the image"""
+        return self._policyBundleName
 
-    @currentIncidentStatus.setter
-    def currentIncidentStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._currentIncidentStatus = value
+    @policyBundleName.setter
+    def policyBundleName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._policyBundleName = value
         else:
             raise TypeError(
-                'Property "currentIncidentStatus" of type "list<BannerEventIn'
-                'cidentStatusEnum>" set to wrong type'
+                'Property "policyBundleName" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def currentMessage(self):
-        """str: Latest user updated message for the banner announcement event,
-         max 1024 chars"""
-        return self._currentMessage
+    def policyLastUpdate(self):
+        """str: Date of the policy last update"""
+        return self._policyLastUpdate
 
-    @currentMessage.setter
-    def currentMessage(self, value):
+    @policyLastUpdate.setter
+    def policyLastUpdate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._currentMessage = value
+            self._policyLastUpdate = value
         else:
             raise TypeError(
-                'Property "currentMessage" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "policyLastUpdate" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated next update time of the banner event in UTC 00:00"""
-        return self._estimatedUpdateTime
+    def rating(self):
+        """SecurityRatingTypeEnum: Security Rating Type"""
+        return self._rating
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
+    @rating.setter
+    def rating(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._rating = value
+        else:
+            raise TypeError(
+                'Property "rating" of type "list<SecurityRatingTypeEnum>" set'
+                ' to wrong type'
+            )
+
+    @property
+    def scanDate(self):
+        """str: Date for this scan in ISO-8601 format"""
+        return self._scanDate
+
+    @scanDate.setter
+    def scanDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+            self._scanDate = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "scanDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentHistory(self):
-        """list: Array of bannerEventIncidentMeta Objects"""
-        return self._incidentHistory
+    def scanIssueCounts(self):
+        """ """
+        return self._scanIssueCounts
 
-    @incidentHistory.setter
-    def incidentHistory(self, value):
+    @scanIssueCounts.setter
+    def scanIssueCounts(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._incidentHistory = value
+            self._scanIssueCounts = value
         else:
             raise TypeError(
-                'Property "incidentHistory" of type "list<BannerEventIncident'
-                'Meta>" set to wrong type'
+                'Property "scanIssueCounts" of type "list<ScanIssueCount>" se'
+                't to wrong type'
             )
 
     @property
-    def initialPostTime(self):
-        """str: Initial post time of the banner event in UTC 00:00"""
-        return self._initialPostTime
+    def scanIssues(self):
+        """ """
+        return self._scanIssues
 
-    @initialPostTime.setter
-    def initialPostTime(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._initialPostTime = value
+    @scanIssues.setter
+    def scanIssues(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._scanIssues = value
         else:
             raise TypeError(
-                'Property "initialPostTime" of type "list<str>" set to wrong '
-                'type'
+                'Property "scanIssues" of type "list<ScanIssue>" set to wrong'
+                ' type'
             )
 
     @property
-    def lastUpdatedTime(self):
-        """str: Last updated time of the banner event in UTC 00:00"""
-        return self._lastUpdatedTime
+    def scanOutcome(self):
+        """ScanOutcomeEnum: If at least 1 critical or high, outcome will be FA
+        IL."""
+        return self._scanOutcome
 
-    @lastUpdatedTime.setter
-    def lastUpdatedTime(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._lastUpdatedTime = value
+    @scanOutcome.setter
+    def scanOutcome(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._scanOutcome = value
+        else:
+            raise TypeError(
+                'Property "scanOutcome" of type "list<ScanOutcomeEnum>" set t'
+                'o wrong type'
+            )
+
+    ScanOutcomeEnum=["PASS","FAIL","NOT_SCANNED",]
+    str(repr(ScanOutcomeEnum))  # Prevent optimizer removing enum
+
+    @property
+    def scanStatus(self):
+        """ScanStatusEnum: Image scan statuses"""
+        return self._scanStatus
+
+    @scanStatus.setter
+    def scanStatus(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._scanStatus = value
         else:
             raise TypeError(
-                'Property "lastUpdatedTime" of type "list<str>" set to wrong '
-                'type'
+                'Property "scanStatus" of type "list<ScanStatusEnum>" set to '
+                'wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._backfilledTime is not None:
-            result["backfilledTime"] = \
-                self._backfilledTime
-        if self._currentIncidentSeverity is not None:
-            result["currentIncidentSeverity"] = \
-                self._currentIncidentSeverity
-        if self._currentIncidentStatus is not None:
-            result["currentIncidentStatus"] = \
-                self._currentIncidentStatus
-        if self._currentMessage is not None:
-            result["currentMessage"] = \
-                self._currentMessage
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._incidentHistory:
-            result["incidentHistory"] = [
-                i.toDict() for i in self._incidentHistory 
-            ] if self._incidentHistory else []
-        if self._initialPostTime is not None:
-            result["initialPostTime"] = \
-                self._initialPostTime
-        if self._lastUpdatedTime is not None:
-            result["lastUpdatedTime"] = \
-                self._lastUpdatedTime
+        if self._evaluationProblems is not None:
+            result["evaluationProblems"] = \
+                self._evaluationProblems
+        if self._finalAction is not None:
+            result["finalAction"] = \
+                self._finalAction
+        if self._finalActionReason is not None:
+            result["finalActionReason"] = \
+                self._finalActionReason
+        if self._policyBundleName is not None:
+            result["policyBundleName"] = \
+                self._policyBundleName
+        if self._policyLastUpdate is not None:
+            result["policyLastUpdate"] = \
+                self._policyLastUpdate
+        if self._rating is not None:
+            result["rating"] = \
+                self._rating
+        if self._scanDate is not None:
+            result["scanDate"] = \
+                self._scanDate
+        if self._scanIssueCounts:
+            result["scanIssueCounts"] = [
+                i.toDict() for i in self._scanIssueCounts 
+            ] if self._scanIssueCounts else []
+        if self._scanIssues:
+            result["scanIssues"] = [
+                i.toDict() for i in self._scanIssues 
+            ] if self._scanIssues else []
+        if self._scanOutcome is not None:
+            result["scanOutcome"] = \
+                self._scanOutcome
+        if self._scanStatus is not None:
+            result["scanStatus"] = \
+                self._scanStatus
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._currentMessage is None:
-            raise ValueError(
-                "BannerEventIncident.currentMessage doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._currentMessage is not None
-            and
-            len(self._currentMessage) < 2):
-            raise ValueError(
-                "BannerEventIncident.currentMessage: " + str(self._currentMessage) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._currentMessage is not None
-            and
-            len(self._currentMessage) > 1024):
-            raise ValueError(
-                "BannerEventIncident.currentMessage: " + str(self._currentMessage) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._incidentHistory is not None):
-            for obj in self._incidentHistory:
+        if (self._scanIssues is not None):
+            for obj in self._scanIssues:
+                if (obj is not None): obj.isValid()
+        if (self._scanIssueCounts is not None):
+            for obj in self._scanIssueCounts:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventIncidentMeta.py` & `ngcbpc/data/uis/ApiKey.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,230 +6,291 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
+from .ApiKeyPolicy import ApiKeyPolicy
+from .ApiKeyStatusEnum import ApiKeyStatusEnum
+from .ApiKeyTypeEnum import ApiKeyTypeEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventIncidentStatusEnum))
-str(repr(BannerEventIncidentSeverityEnum))
+str(repr(ApiKeyPolicy))
+str(repr(ApiKeyStatusEnum))
+str(repr(ApiKeyTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventIncidentMeta(object):
-    """Object of banner event incident meta data"""
+class ApiKey(object):
+    """Api Key"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.createdTime = (
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "createdTime"
+                "createdDate"
             ) is None
-            else propDict["createdTime"])
-        self.estimatedUpdateTime = (
+            else propDict["createdDate"])
+        self.expiryDate = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "expiryDate"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.eventIdSequenceNumber = (
+            else propDict["expiryDate"])
+        self.keyId = (
             None if not fromDict or propDict.get(
-                "eventIdSequenceNumber"
+                "keyId"
             ) is None
-            else propDict["eventIdSequenceNumber"])
-        self.incidentSeverity = (
+            else propDict["keyId"])
+        self.lastUsedTimestamp = (
             None if not fromDict or propDict.get(
-                "incidentSeverity"
+                "lastUsedTimestamp"
             ) is None
-            else propDict["incidentSeverity"])
-        self.incidentStatus = (
+            else propDict["lastUsedTimestamp"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "incidentStatus"
+                "name"
             ) is None
-            else propDict["incidentStatus"])
-        self.message = (
+            else propDict["name"])
+        self.policies = (
             None if not fromDict or propDict.get(
-                "message"
+                "policies"
             ) is None
-            else propDict["message"])
+            else [ ApiKeyPolicy(i)
+            for i in propDict["policies"] ])
+        self.status = (
+            None if not fromDict or propDict.get(
+                "status"
+            ) is None
+            else propDict["status"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
+        self.value = (
+            None if not fromDict or propDict.get(
+                "value"
+            ) is None
+            else propDict["value"])
 
     @property
-    def createdTime(self):
-        """str: Created time for the banner event"""
-        return self._createdTime
+    def createdDate(self):
+        """str: Created date of the key"""
+        return self._createdDate
 
-    @createdTime.setter
-    def createdTime(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdTime = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "createdTime" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated update time for the banner event"""
-        return self._estimatedUpdateTime
+    def expiryDate(self):
+        """str: Expiration date of the key"""
+        return self._expiryDate
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
+    @expiryDate.setter
+    def expiryDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+            self._expiryDate = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "expiryDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventIdSequenceNumber(self):
-        """long: Sequence number of the eventId, initialized to 0 and incremen
-        ted by one each time the event gets updated"""
-        return self._eventIdSequenceNumber
+    def keyId(self):
+        """str: Unique key-id generated by SAK"""
+        return self._keyId
 
-    @eventIdSequenceNumber.setter
-    def eventIdSequenceNumber(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._eventIdSequenceNumber = value
+    @keyId.setter
+    def keyId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._keyId = value
         else:
             raise TypeError(
-                'Property "eventIdSequenceNumber" of type "list<long>" set to'
-                ' wrong type'
+                'Property "keyId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._incidentSeverity
+    def lastUsedTimestamp(self):
+        """str: last timestamp the api key was used"""
+        return self._lastUsedTimestamp
 
-    @incidentSeverity.setter
-    def incidentSeverity(self, value):
+    @lastUsedTimestamp.setter
+    def lastUsedTimestamp(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._lastUsedTimestamp = value
+        else:
+            raise TypeError(
+                'Property "lastUsedTimestamp" of type "list<str>" set to wron'
+                'g type'
+            )
+
+    @property
+    def name(self):
+        """str: Name of the key"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def policies(self):
+        """list: Access permissions of the key"""
+        return self._policies
+
+    @policies.setter
+    def policies(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._policies = value
+        else:
+            raise TypeError(
+                'Property "policies" of type "list<ApiKeyPolicy>" set to wron'
+                'g type'
+            )
+
+    @property
+    def status(self):
+        """ApiKeyStatusEnum: Possible api key statuses"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentSeverity = value
+            self._status = value
         else:
             raise TypeError(
-                'Property "incidentSeverity" of type "list<BannerEventInciden'
-                'tSeverityEnum>" set to wrong type'
+                'Property "status" of type "list<ApiKeyStatusEnum>" set to wr'
+                'ong type'
             )
 
     @property
-    def incidentStatus(self):
-        """BannerEventIncidentStatusEnum: Banner event incident status."""
-        return self._incidentStatus
+    def type(self):
+        """ApiKeyTypeEnum: Possible api key types"""
+        return self._type
 
-    @incidentStatus.setter
-    def incidentStatus(self, value):
+    @type.setter
+    def type(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentStatus = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "incidentStatus" of type "list<BannerEventIncidentS'
-                'tatusEnum>" set to wrong type'
+                'Property "type" of type "list<ApiKeyTypeEnum>" set to wrong '
+                'type'
             )
 
     @property
-    def message(self):
-        """str: User defined message for the banner announcement event, max 10
-        24 chars"""
-        return self._message
+    def value(self):
+        """str: Api key generated by SAK"""
+        return self._value
 
-    @message.setter
-    def message(self, value):
+    @value.setter
+    def value(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._value = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._createdTime is not None:
-            result["createdTime"] = \
-                self._createdTime
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._eventIdSequenceNumber is not None:
-            result["eventIdSequenceNumber"] = \
-                self._eventIdSequenceNumber
-        if self._incidentSeverity is not None:
-            result["incidentSeverity"] = \
-                self._incidentSeverity
-        if self._incidentStatus is not None:
-            result["incidentStatus"] = \
-                self._incidentStatus
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._expiryDate is not None:
+            result["expiryDate"] = \
+                self._expiryDate
+        if self._keyId is not None:
+            result["keyId"] = \
+                self._keyId
+        if self._lastUsedTimestamp is not None:
+            result["lastUsedTimestamp"] = \
+                self._lastUsedTimestamp
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._policies:
+            result["policies"] = [
+                i.toDict() for i in self._policies 
+            ] if self._policies else []
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._type is not None:
+            result["type"] = \
+                self._type
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._eventIdSequenceNumber is None:
+        if self._keyId is None:
+            raise ValueError(
+                "ApiKey.keyId doesnt match requirement:" 
+                "required: True"
+            )
+        if self._status is None:
+            raise ValueError(
+                "ApiKey.status doesnt match requirement:" 
+                "required: True"
+            )
+        if self._expiryDate is None:
+            raise ValueError(
+                "ApiKey.expiryDate doesnt match requirement:" 
+                "required: True"
+            )
+        if self._createdDate is None:
+            raise ValueError(
+                "ApiKey.createdDate doesnt match requirement:" 
+                "required: True"
+            )
+        if self._lastUsedTimestamp is None:
+            raise ValueError(
+                "ApiKey.lastUsedTimestamp doesnt match requirement:" 
+                "required: True"
+            )
+        if self._policies is None:
             raise ValueError(
-                "BannerEventIncidentMeta.eventIdSequenceNumber doesnt match requirement:" 
+                "ApiKey.policies doesnt match requirement:" 
                 "required: True"
             )
-        if (self._eventIdSequenceNumber is not None
-            and
-            self._eventIdSequenceNumber < 0):
-            raise ValueError(
-                "BannerEventIncidentMeta.eventIdSequenceNumber: " + str(self._eventIdSequenceNumber) + 
-                " doesnt match requirement: minimum: 0")
-        if self._message is None:
-            raise ValueError(
-                "BannerEventIncidentMeta.message doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._message is not None
-            and
-            len(self._message) < 2):
-            raise ValueError(
-                "BannerEventIncidentMeta.message: " + str(self._message) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._message is not None
-            and
-            len(self._message) > 1024):
-            raise ValueError(
-                "BannerEventIncidentMeta.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._createdTime is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdTime)):
-            raise ValueError(
-                "BannerEventIncidentMeta.createdTime: " + str(self._createdTime) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._estimatedUpdateTime is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._estimatedUpdateTime)):
-            raise ValueError(
-                "BannerEventIncidentMeta.estimatedUpdateTime: " + str(self._estimatedUpdateTime) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._policies is not None):
+            for obj in self._policies:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventListResponse.py` & `ngcbpc/data/model/RecipeListResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,83 +6,85 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEvent import BannerEvent
 from .RequestStatus import RequestStatus
+from .Recipe import Recipe
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
+str(repr(Recipe))
 str(repr(RequestStatus))
-str(repr(BannerEvent))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventListResponse(object):
-    """response to get banner events within one org"""
+class RecipeListResponse(object):
+    """Response to list recipes request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.events = (
+        self.paginationInfo = (
             None if not fromDict or propDict.get(
-                "events"
+                "paginationInfo"
             ) is None
-            else [ BannerEvent(i)
-            for i in propDict["events"] ])
-        self.orgName = (
+            else propDict["paginationInfo"])
+        self.recipes = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "recipes"
             ) is None
-            else propDict["orgName"])
+            else [ Recipe(i)
+            for i in propDict["recipes"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def events(self):
-        """list: Array of bannerEvent Objects"""
-        return self._events
-
-    @events.setter
-    def events(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._events = value
+    def paginationInfo(self):
+        """PaginationInfo: Pagination Information"""
+        return self._paginationInfo
+
+    @paginationInfo.setter
+    def paginationInfo(self, value):
+        if value is not None and not isinstance(value, PaginationInfo):
+            value = PaginationInfo(value)
+        if (value is None) or isinstance(value, PaginationInfo):
+            self._paginationInfo = value
         else:
             raise TypeError(
-                'Property "events" of type "list<BannerEvent>" set to wrong t'
-                'ype'
+                'Property "paginationInfo" of type "list<PaginationInfo>" set'
+                ' to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Name of org that the banner events belongs to"""
-        return self._orgName
-
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    def recipes(self):
+        """ """
+        return self._recipes
+
+    @recipes.setter
+    def recipes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._recipes = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "recipes" of type "list<Recipe>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -91,33 +93,34 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._events:
-            result["events"] = [
-                i.toDict() for i in self._events 
-            ] if self._events else []
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._paginationInfo:
+            result["paginationInfo"] = \
+                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._recipes:
+            result["recipes"] = [
+                i.toDict() for i in self._recipes 
+            ] if self._recipes else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._events is not None):
-            for obj in self._events:
+        if (self._recipes is not None):
+            for obj in self._recipes:
                 if (obj is not None): obj.isValid()
+        if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventResponse.py` & `ngcbpc/data/registry/GetRepositoryTagVexResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,114 +6,118 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEvent import BannerEvent
 from .RequestStatus import RequestStatus
+from .RepositoryTagVexByDigest import RepositoryTagVexByDigest
 
 # Unused import over optimization prevention
+str(repr(RepositoryTagVexByDigest))
 str(repr(RequestStatus))
-str(repr(BannerEvent))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventResponse(object):
-    """response to get a banner event by event uuid"""
+class GetRepositoryTagVexResponse(object):
+    """Get repository tag VEX response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.event = (
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "event"
+                "requestStatus"
             ) is None
-            else propDict["event"])
-        self.orgName = (
+            else propDict["requestStatus"])
+        self.tag = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "tag"
             ) is None
-            else propDict["orgName"])
-        self.requestStatus = (
+            else propDict["tag"])
+        self.vexes = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "vexes"
             ) is None
-            else propDict["requestStatus"])
+            else [ RepositoryTagVexByDigest(i)
+            for i in propDict["vexes"] ])
 
     @property
-    def event(self):
-        """BannerEvent: Object of banner event data"""
-        return self._event
-
-    @event.setter
-    def event(self, value):
-        if value is not None and not isinstance(value, BannerEvent):
-            value = BannerEvent(value)
-        if (value is None) or isinstance(value, BannerEvent):
-            self._event = value
+    def requestStatus(self):
+        """ """
+        return self._requestStatus
+
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "event" of type "list<BannerEvent>" set to wrong ty'
-                'pe'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Name of org that the banner event belongs to"""
-        return self._orgName
+    def tag(self):
+        """str: Image tag detail"""
+        return self._tag
 
-    @orgName.setter
-    def orgName(self, value):
+    @tag.setter
+    def tag(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._tag = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def vexes(self):
         """ """
-        return self._requestStatus
+        return self._vexes
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @vexes.setter
+    def vexes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._vexes = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "vexes" of type "list<RepositoryTagVexByDigest>" se'
+                't to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._event:
-            result["event"] = \
-                self._event.toDict() if self._event is not None else None
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
+        if self._vexes:
+            result["vexes"] = [
+                i.toDict() for i in self._vexes 
+            ] if self._vexes else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._event is not None): self._event.isValid()
+        if (self._vexes is not None):
+            for obj in self._vexes:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/BannerEventUpdateRequest.py` & `ngcbpc/data/registry/EventTarget.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,165 +6,205 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
 
 # Unused import over optimization prevention
-str(repr(BannerEventIncidentStatusEnum))
-str(repr(BannerEventIncidentSeverityEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventUpdateRequest(object):
-    """Update banner event request"""
+class EventTarget(object):
+    """Target uniquely describes the target of the event."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.estimatedUpdateTime = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "digest"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.incidentSeverity = (
+            else propDict["digest"])
+        self.length = (
             None if not fromDict or propDict.get(
-                "incidentSeverity"
+                "length"
             ) is None
-            else propDict["incidentSeverity"])
-        self.incidentStatus = (
+            else propDict["length"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "incidentStatus"
+                "mediaType"
             ) is None
-            else propDict["incidentStatus"])
-        self.message = (
+            else propDict["mediaType"])
+        self.repository = (
             None if not fromDict or propDict.get(
-                "message"
+                "repository"
             ) is None
-            else propDict["message"])
+            else propDict["repository"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
+        self.tag = (
+            None if not fromDict or propDict.get(
+                "tag"
+            ) is None
+            else propDict["tag"])
+        self.url = (
+            None if not fromDict or propDict.get(
+                "url"
+            ) is None
+            else propDict["url"])
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated update time for the banner event"""
-        return self._estimatedUpdateTime
+    def digest(self):
+        """str: Digest uniquely identifies the content. A byte stream can be v
+        erified against against this digest."""
+        return self._digest
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+            self._digest = value
+        else:
+            raise TypeError(
+                'Property "digest" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def length(self):
+        """long: Length in bytes of content. Same as Size field in Descriptor.
+         Provided for backwards compatibility."""
+        return self._length
+
+    @length.setter
+    def length(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._length = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "length" of type "list<long>" set to wrong type'
             )
 
     @property
-    def incidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._incidentSeverity
+    def mediaType(self):
+        """str: MediaType describe the type of the content. All text based for
+        mats are encoded as utf-8."""
+        return self._mediaType
 
-    @incidentSeverity.setter
-    def incidentSeverity(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentSeverity = value
+    @mediaType.setter
+    def mediaType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "incidentSeverity" of type "list<BannerEventInciden'
-                'tSeverityEnum>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentStatus(self):
-        """BannerEventIncidentStatusEnum: Banner event incident status."""
-        return self._incidentStatus
+    def repository(self):
+        """str: Repository identifies the named repository."""
+        return self._repository
 
-    @incidentStatus.setter
-    def incidentStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentStatus = value
+    @repository.setter
+    def repository(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._repository = value
+        else:
+            raise TypeError(
+                'Property "repository" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def size(self):
+        """long: Size in bytes of content."""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
+        else:
+            raise TypeError(
+                'Property "size" of type "list<long>" set to wrong type'
+            )
+
+    @property
+    def tag(self):
+        """str: Tag provides the tag."""
+        return self._tag
+
+    @tag.setter
+    def tag(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._tag = value
         else:
             raise TypeError(
-                'Property "incidentStatus" of type "list<BannerEventIncidentS'
-                'tatusEnum>" set to wrong type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     @property
-    def message(self):
-        """str: User defined message for the banner announcement update, max 1
-        024 chars"""
-        return self._message
+    def url(self):
+        """str: URL provides a direct link to the content."""
+        return self._url
 
-    @message.setter
-    def message(self, value):
+    @url.setter
+    def url(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._url = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "url" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._incidentSeverity is not None:
-            result["incidentSeverity"] = \
-                self._incidentSeverity
-        if self._incidentStatus is not None:
-            result["incidentStatus"] = \
-                self._incidentStatus
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._length is not None:
+            result["length"] = \
+                self._length
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._repository is not None:
+            result["repository"] = \
+                self._repository
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
+        if self._url is not None:
+            result["url"] = \
+                self._url
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._message is None:
-            raise ValueError(
-                "BannerEventUpdateRequest.message doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._message is not None
-            and
-            len(self._message) < 2):
-            raise ValueError(
-                "BannerEventUpdateRequest.message: " + str(self._message) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._message is not None
-            and
-            len(self._message) > 1024):
-            raise ValueError(
-                "BannerEventUpdateRequest.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 1024")
-        if self._incidentStatus is None:
-            raise ValueError(
-                "BannerEventUpdateRequest.incidentStatus doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._estimatedUpdateTime is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._estimatedUpdateTime)):
-            raise ValueError(
-                "BannerEventUpdateRequest.estimatedUpdateTime: " + str(self._estimatedUpdateTime) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/api/BannerEventUpdateResponse.py` & `ngcbpc/data/model/HelmChartVersion.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,340 +6,388 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BannerEventIncidentSeverityEnum import BannerEventIncidentSeverityEnum
-from .BannerEventIncidentStatusEnum import BannerEventIncidentStatusEnum
-from .BannerEventTypeEnum import BannerEventTypeEnum
+from .HelmChartDependency import HelmChartDependency
+from .HelmChartMaintainer import HelmChartMaintainer
 
 # Unused import over optimization prevention
-str(repr(BannerEventTypeEnum))
-str(repr(BannerEventIncidentStatusEnum))
-str(repr(BannerEventIncidentSeverityEnum))
+str(repr(HelmChartMaintainer))
+str(repr(HelmChartDependency))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BannerEventUpdateResponse(object):
-    """Update banner event response"""
+class HelmChartVersion(object):
+    """Helm chart version object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.backfilledTime = (
+        self.apiVersion = (
             None if not fromDict or propDict.get(
-                "backfilledTime"
+                "apiVersion"
             ) is None
-            else propDict["backfilledTime"])
-        self.bannerEventType = (
+            else propDict["apiVersion"])
+        self.appVersion = (
             None if not fromDict or propDict.get(
-                "bannerEventType"
+                "appVersion"
             ) is None
-            else propDict["bannerEventType"])
-        self.createdTime = (
+            else propDict["appVersion"])
+        self.dependencies = (
             None if not fromDict or propDict.get(
-                "createdTime"
+                "dependencies"
             ) is None
-            else propDict["createdTime"])
-        self.estimatedUpdateTime = (
+            else [ HelmChartDependency(i)
+            for i in propDict["dependencies"] ])
+        self.deprecated = (
             None if not fromDict or propDict.get(
-                "estimatedUpdateTime"
+                "deprecated"
             ) is None
-            else propDict["estimatedUpdateTime"])
-        self.eventId = (
+            else propDict["deprecated"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "eventId"
+                "description"
             ) is None
-            else propDict["eventId"])
-        self.eventIdSequenceNumber = (
+            else propDict["description"])
+        self.home = (
             None if not fromDict or propDict.get(
-                "eventIdSequenceNumber"
+                "home"
             ) is None
-            else propDict["eventIdSequenceNumber"])
-        self.eventUuid = (
+            else propDict["home"])
+        self.icon = (
             None if not fromDict or propDict.get(
-                "eventUuid"
+                "icon"
             ) is None
-            else propDict["eventUuid"])
-        self.incidentSeverity = (
+            else propDict["icon"])
+        self.keywords = (
             None if not fromDict or propDict.get(
-                "incidentSeverity"
+                "keywords"
             ) is None
-            else propDict["incidentSeverity"])
-        self.incidentStatus = (
+            else propDict["keywords"])
+        self.kubeVersion = (
             None if not fromDict or propDict.get(
-                "incidentStatus"
+                "kubeVersion"
             ) is None
-            else propDict["incidentStatus"])
-        self.message = (
+            else propDict["kubeVersion"])
+        self.maintainers = (
             None if not fromDict or propDict.get(
-                "message"
+                "maintainers"
             ) is None
-            else propDict["message"])
-        self.orgName = (
+            else [ HelmChartMaintainer(i)
+            for i in propDict["maintainers"] ])
+        self.name = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "name"
             ) is None
-            else propDict["orgName"])
+            else propDict["name"])
+        self.sources = (
+            None if not fromDict or propDict.get(
+                "sources"
+            ) is None
+            else propDict["sources"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
+
+    @property
+    def apiVersion(self):
+        """str: The chart API version (required)"""
+        return self._apiVersion
+
+    @apiVersion.setter
+    def apiVersion(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._apiVersion = value
+        else:
+            raise TypeError(
+                'Property "apiVersion" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def backfilledTime(self):
-        """str: Backfilled time of the banner event in UTC 00:00"""
-        return self._backfilledTime
+    def appVersion(self):
+        """str: The version of the app that this contains (optional). This nee
+        dn't be SemVer."""
+        return self._appVersion
 
-    @backfilledTime.setter
-    def backfilledTime(self, value):
+    @appVersion.setter
+    def appVersion(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._backfilledTime = value
+            self._appVersion = value
         else:
             raise TypeError(
-                'Property "backfilledTime" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "appVersion" of type "list<str>" set to wrong type'
             )
 
     @property
-    def bannerEventType(self):
-        """BannerEventTypeEnum: Banner event type. Default to INCIDENT"""
-        return self._bannerEventType
+    def dependencies(self):
+        """list: A list of the chart requirements (optional)"""
+        return self._dependencies
 
-    @bannerEventType.setter
-    def bannerEventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._bannerEventType = value
+    @dependencies.setter
+    def dependencies(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._dependencies = value
         else:
             raise TypeError(
-                'Property "bannerEventType" of type "list<BannerEventTypeEnum'
-                '>" set to wrong type'
+                'Property "dependencies" of type "list<HelmChartDependency>" '
+                'set to wrong type'
             )
 
     @property
-    def createdTime(self):
-        """str: Created time of the banner event in UTC 00:00"""
-        return self._createdTime
+    def deprecated(self):
+        """bool: Whether this chart is deprecated (optional, boolean)"""
+        return self._deprecated
 
-    @createdTime.setter
-    def createdTime(self, value):
+    @deprecated.setter
+    def deprecated(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._deprecated = value
+        else:
+            raise TypeError(
+                'Property "deprecated" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def description(self):
+        """str: A single-sentence description of this project (optional)"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdTime = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "createdTime" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def estimatedUpdateTime(self):
-        """str: Estimated update time of the banner event in UTC 00:00"""
-        return self._estimatedUpdateTime
+    def home(self):
+        """str: The URL of this project's home page (optional)"""
+        return self._home
 
-    @estimatedUpdateTime.setter
-    def estimatedUpdateTime(self, value):
+    @home.setter
+    def home(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._estimatedUpdateTime = value
+            self._home = value
         else:
             raise TypeError(
-                'Property "estimatedUpdateTime" of type "list<str>" set to wr'
-                'ong type'
+                'Property "home" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventId(self):
-        """str: EventId generated by server. For example U20210610A. The date 
-        inside the eventId is UTC 00:00 based"""
-        return self._eventId
+    def icon(self):
+        """str: A URL to an SVG or PNG image to be used as an icon (optional).
+        """
+        return self._icon
 
-    @eventId.setter
-    def eventId(self, value):
+    @icon.setter
+    def icon(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._eventId = value
+            self._icon = value
         else:
             raise TypeError(
-                'Property "eventId" of type "list<str>" set to wrong type'
+                'Property "icon" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventIdSequenceNumber(self):
-        """long: Sequence number of the eventId, initialized to 0 and incremen
-        ted by one each time the event gets updated"""
-        return self._eventIdSequenceNumber
+    def keywords(self):
+        """list: A list of keywords about this project (optional)"""
+        return self._keywords
 
-    @eventIdSequenceNumber.setter
-    def eventIdSequenceNumber(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._eventIdSequenceNumber = value
+    @keywords.setter
+    def keywords(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._keywords = value
         else:
             raise TypeError(
-                'Property "eventIdSequenceNumber" of type "list<long>" set to'
-                ' wrong type'
+                'Property "keywords" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventUuid(self):
-        """str: Event unique UUID."""
-        return self._eventUuid
+    def kubeVersion(self):
+        """str: A SemVer range of compatible Kubernetes versions (optional)"""
+        return self._kubeVersion
 
-    @eventUuid.setter
-    def eventUuid(self, value):
+    @kubeVersion.setter
+    def kubeVersion(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._eventUuid = value
+            self._kubeVersion = value
         else:
             raise TypeError(
-                'Property "eventUuid" of type "list<str>" set to wrong type'
+                'Property "kubeVersion" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentSeverity(self):
-        """BannerEventIncidentSeverityEnum: Severity of banner incident"""
-        return self._incidentSeverity
+    def maintainers(self):
+        """ """
+        return self._maintainers
 
-    @incidentSeverity.setter
-    def incidentSeverity(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentSeverity = value
+    @maintainers.setter
+    def maintainers(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._maintainers = value
+        else:
+            raise TypeError(
+                'Property "maintainers" of type "list<HelmChartMaintainer>" s'
+                'et to wrong type'
+            )
+
+    @property
+    def name(self):
+        """str: The name of the chart (required)"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "incidentSeverity" of type "list<BannerEventInciden'
-                'tSeverityEnum>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def incidentStatus(self):
-        """BannerEventIncidentStatusEnum: Banner event incident status."""
-        return self._incidentStatus
+    def sources(self):
+        """list: A list of URLs to source code for this project (optional)"""
+        return self._sources
 
-    @incidentStatus.setter
-    def incidentStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._incidentStatus = value
+    @sources.setter
+    def sources(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._sources = value
         else:
             raise TypeError(
-                'Property "incidentStatus" of type "list<BannerEventIncidentS'
-                'tatusEnum>" set to wrong type'
+                'Property "sources" of type "list<str>" set to wrong type'
             )
 
     @property
-    def message(self):
-        """str: User defined message for the banner announcement event, max 10
-        24 chars"""
-        return self._message
+    def type(self):
+        """str: It is the type of chart (optional)"""
+        return self._type
 
-    @message.setter
-    def message(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Name of org that the banner event belongs to"""
-        return self._orgName
+    def version(self):
+        """str: A SemVer 2 version (required)"""
+        return self._version
 
-    @orgName.setter
-    def orgName(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._backfilledTime is not None:
-            result["backfilledTime"] = \
-                self._backfilledTime
-        if self._bannerEventType is not None:
-            result["bannerEventType"] = \
-                self._bannerEventType
-        if self._createdTime is not None:
-            result["createdTime"] = \
-                self._createdTime
-        if self._estimatedUpdateTime is not None:
-            result["estimatedUpdateTime"] = \
-                self._estimatedUpdateTime
-        if self._eventId is not None:
-            result["eventId"] = \
-                self._eventId
-        if self._eventIdSequenceNumber is not None:
-            result["eventIdSequenceNumber"] = \
-                self._eventIdSequenceNumber
-        if self._eventUuid is not None:
-            result["eventUuid"] = \
-                self._eventUuid
-        if self._incidentSeverity is not None:
-            result["incidentSeverity"] = \
-                self._incidentSeverity
-        if self._incidentStatus is not None:
-            result["incidentStatus"] = \
-                self._incidentStatus
-        if self._message is not None:
-            result["message"] = \
-                self._message
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._apiVersion is not None:
+            result["apiVersion"] = \
+                self._apiVersion
+        if self._appVersion is not None:
+            result["appVersion"] = \
+                self._appVersion
+        if self._dependencies:
+            result["dependencies"] = [
+                i.toDict() for i in self._dependencies 
+            ] if self._dependencies else []
+        if self._deprecated is not None:
+            result["deprecated"] = \
+                self._deprecated
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._home is not None:
+            result["home"] = \
+                self._home
+        if self._icon is not None:
+            result["icon"] = \
+                self._icon
+        if self._keywords is not None:
+            result["keywords"] = \
+                self._keywords
+        if self._kubeVersion is not None:
+            result["kubeVersion"] = \
+                self._kubeVersion
+        if self._maintainers:
+            result["maintainers"] = [
+                i.toDict() for i in self._maintainers 
+            ] if self._maintainers else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._sources is not None:
+            result["sources"] = \
+                self._sources
+        if self._type is not None:
+            result["type"] = \
+                self._type
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._eventUuid is None:
-            raise ValueError(
-                "BannerEventUpdateResponse.eventUuid doesnt match requirement:" 
-                "required: True"
-            )
-        if self._eventId is None:
-            raise ValueError(
-                "BannerEventUpdateResponse.eventId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._eventIdSequenceNumber is None:
-            raise ValueError(
-                "BannerEventUpdateResponse.eventIdSequenceNumber doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._eventIdSequenceNumber is not None
-            and
-            self._eventIdSequenceNumber < 0):
-            raise ValueError(
-                "BannerEventUpdateResponse.eventIdSequenceNumber: " + str(self._eventIdSequenceNumber) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._message is not None
-            and
-            len(self._message) < 2):
-            raise ValueError(
-                "BannerEventUpdateResponse.message: " + str(self._message) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._message is not None
-            and
-            len(self._message) > 1024):
-            raise ValueError(
-                "BannerEventUpdateResponse.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 1024")
+        if (self._dependencies is not None):
+            for obj in self._dependencies:
+                if (obj is not None): obj.isValid()
+        if (self._maintainers is not None):
+            for obj in self._maintainers:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/CelestialErrorDetail.py` & `basecommand/data/pym/ProjectTemplateRequestStatus.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,74 +14,84 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CelestialErrorDetail(object):
-    """ACE is a collection of nodes that can run jobs"""
+class ProjectTemplateRequestStatus(object):
+    """Project Template Request status"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.errorCode = (
+        self.id = (
             None if not fromDict or propDict.get(
-                "errorCode"
+                "id"
             ) is None
-            else propDict["errorCode"])
-        self.message = (
+            else propDict["id"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "message"
+                "name"
             ) is None
-            else propDict["message"])
+            else propDict["name"])
 
     @property
-    def errorCode(self):
-        """int: Celestial error code"""
-        return self._errorCode
-
-    @errorCode.setter
-    def errorCode(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._errorCode = value
+    def id(self):
+        """str: Project template ID"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "errorCode" of type "list<int>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def message(self):
-        """str: error message"""
-        return self._message
+    def name(self):
+        """str: Project template name"""
+        return self._name
 
-    @message.setter
-    def message(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._errorCode is not None:
-            result["errorCode"] = \
-                self._errorCode
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._id is None:
+            raise ValueError(
+                "ProjectTemplateRequestStatus.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
+            raise ValueError(
+                "ProjectTemplateRequestStatus.name doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/CelestialFilters.py` & `basecommand/data/pym/Env.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,55 +14,90 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CelestialFilters(object):
-    """Celestial service filters for Kafka request message"""
+class Env(object):
+    """Environment variable"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "name"
             ) is None
-            else propDict["orgName"])
+            else propDict["name"])
+        self.value = (
+            None if not fromDict or propDict.get(
+                "value"
+            ) is None
+            else propDict["value"])
 
     @property
-    def orgName(self):
-        """str: Org context for the audit logs"""
-        return self._orgName
+    def name(self):
+        """str: Environment variable name"""
+        return self._name
 
-    @orgName.setter
-    def orgName(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def value(self):
+        """str: Environment variable value"""
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._value = value
+        else:
+            raise TypeError(
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._orgName is None:
+        if self._name is None:
+            raise ValueError(
+                "Env.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "Env.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._value is None:
             raise ValueError(
-                "CelestialFilters.orgName doesnt match requirement:" 
+                "Env.value doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/ConfigRequest.py` & `ngcbpc/data/model/AIFoundationModel.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,210 +14,214 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ConfigRequest(object):
-    """Object used to update configuration of different components running on 
-    the node. As a result of this message, node is expected to send 'NodeS
-    tatus' message back to the cloud when configuration is done."""
+class AIFoundationModel(object):
+    """Get AI Playground Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.artifactName = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "artifactName"
             ) is None
-            else propDict["aceId"])
-        self.authToken = (
+            else propDict["artifactName"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "authToken"
+                "attributes"
             ) is None
-            else propDict["authToken"])
-        self.configService = (
+            else propDict["attributes"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "configService"
+                "createdDate"
             ) is None
-            else propDict["configService"])
-        self.configType = (
+            else propDict["createdDate"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "configType"
+                "namespace"
             ) is None
-            else propDict["configType"])
-        self.dataB64 = (
+            else propDict["namespace"])
+        self.nvcfFunctionId = (
             None if not fromDict or propDict.get(
-                "dataB64"
+                "nvcfFunctionId"
             ) is None
-            else propDict["dataB64"])
-        self.turnId = (
+            else propDict["nvcfFunctionId"])
+        self.openAPISpec = (
             None if not fromDict or propDict.get(
-                "turnId"
+                "openAPISpec"
             ) is None
-            else propDict["turnId"])
+            else propDict["openAPISpec"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
 
     @property
-    def aceId(self):
-        """long: Unique ID of the ACE for which this configuration is sent"""
-        return self._aceId
+    def artifactName(self):
+        """str: Unique name of the model"""
+        return self._artifactName
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @artifactName.setter
+    def artifactName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactName = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "artifactName" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def authToken(self):
-        """str: authentication token to be used when downloading configuration
-        . If configuration is provided inline, this token can be empty"""
-        return self._authToken
+    def attributes(self):
+        """str: Metadata json string"""
+        return self._attributes
 
-    @authToken.setter
-    def authToken(self, value):
+    @attributes.setter
+    def attributes(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authToken = value
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "authToken" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<str>" set to wrong type'
             )
 
     @property
-    def configService(self):
-        """ConfigServiceEnum: identifies the service that would need to update
-         its configuration"""
-        return self._configService
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @configService.setter
-    def configService(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._configService = value
+    @createdDate.setter
+    def createdDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "configService" of type "list<ConfigServiceEnum>" s'
-                'et to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
-    ConfigServiceEnum=["UNKNOWN","NODE_STATUS","MESOS","MARATHON","ZOOKEPER","RINETD","AUTHZ_NODE_TOKEN","HOST_NAME","UPGRADE_ON_BOOT",]
-    str(repr(ConfigServiceEnum))  # Prevent optimizer removing enum
-
     @property
-    def configType(self):
-        """ConfigTypeEnum: configuration can be provided as part of this reque
-        st in data field - i.e. INLINE, or can be downloaded from a UR
-        L"""
-        return self._configType
+    def namespace(self):
+        """str: org/team of the model"""
+        return self._namespace
 
-    @configType.setter
-    def configType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._configType = value
+    @namespace.setter
+    def namespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "configType" of type "list<ConfigTypeEnum>" set to '
-                'wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
-    ConfigTypeEnum=["UNKNOWN","INLINE","URL",]
-    str(repr(ConfigTypeEnum))  # Prevent optimizer removing enum
+    @property
+    def nvcfFunctionId(self):
+        """str: NVCF function id for the model playground"""
+        return self._nvcfFunctionId
+
+    @nvcfFunctionId.setter
+    def nvcfFunctionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._nvcfFunctionId = value
+        else:
+            raise TypeError(
+                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
+                'ype'
+            )
 
     @property
-    def dataB64(self):
-        """str: this field contains either the whole configuration as a base64
-         encoded value, or it contains the URL from where the configur
-        ation needs to be downloaded"""
-        return self._dataB64
+    def openAPISpec(self):
+        """str: OpenAPI specification for this model"""
+        return self._openAPISpec
 
-    @dataB64.setter
-    def dataB64(self, value):
+    @openAPISpec.setter
+    def openAPISpec(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dataB64 = value
+            self._openAPISpec = value
         else:
             raise TypeError(
-                'Property "dataB64" of type "list<str>" set to wrong type'
+                'Property "openAPISpec" of type "list<str>" set to wrong type'
             )
 
     @property
-    def turnId(self):
-        """str: Turn ID of the ACE configuration which resulted in the current
-         config request. By default this value should be 0"""
-        return self._turnId
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
 
-    @turnId.setter
-    def turnId(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._turnId = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "turnId" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._authToken is not None:
-            result["authToken"] = \
-                self._authToken
-        if self._configService is not None:
-            result["configService"] = \
-                self._configService
-        if self._configType is not None:
-            result["configType"] = \
-                self._configType
-        if self._dataB64 is not None:
-            result["dataB64"] = \
-                self._dataB64
-        if self._turnId is not None:
-            result["turnId"] = \
-                self._turnId
+        if self._artifactName is not None:
+            result["artifactName"] = \
+                self._artifactName
+        if self._attributes is not None:
+            result["attributes"] = \
+                self._attributes
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._nvcfFunctionId is not None:
+            result["nvcfFunctionId"] = \
+                self._nvcfFunctionId
+        if self._openAPISpec is not None:
+            result["openAPISpec"] = \
+                self._openAPISpec
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceId is None:
-            raise ValueError(
-                "ConfigRequest.aceId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._configService is None:
-            raise ValueError(
-                "ConfigRequest.configService doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._dataB64 is not None
+        if (self._createdDate is not None
             and
-            len(self._dataB64) > 65535):
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "ConfigRequest.dataB64: " + str(self._dataB64) + 
-                " doesnt match requirement: maxLength: 65535")
-        if (self._authToken is not None
+                "AIFoundationModel.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
             and
-            len(self._authToken) > 128):
-            raise ValueError(
-                "ConfigRequest.authToken: " + str(self._authToken) + 
-                " doesnt match requirement: maxLength: 128")
-        if self._turnId is None:
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
             raise ValueError(
-                "ConfigRequest.turnId doesnt match requirement:" 
-                "required: True"
-            )
+                "AIFoundationModel.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/api/ContainerResources.py` & `ngcbpc/data/model/DeploymentCpuParametersMeta.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,89 +6,67 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobContainerResources import JobContainerResources
+from .CountableResource import CountableResource
 
 # Unused import over optimization prevention
-str(repr(JobContainerResources))
+str(repr(CountableResource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ContainerResources(object):
+class DeploymentCpuParametersMeta(object):
+    """Cloud Service Provider Deployment CPU Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.limits = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "limits"
+                "count"
             ) is None
-            else propDict["limits"])
-        self.requests = (
-            None if not fromDict or propDict.get(
-                "requests"
-            ) is None
-            else propDict["requests"])
-
-    @property
-    def limits(self):
-        """JobContainerResources: Describes the cpu and memory resources for t
-        he job containers"""
-        return self._limits
-
-    @limits.setter
-    def limits(self, value):
-        if value is not None and not isinstance(value, JobContainerResources):
-            value = JobContainerResources(value)
-        if (value is None) or isinstance(value, JobContainerResources):
-            self._limits = value
-        else:
-            raise TypeError(
-                'Property "limits" of type "list<JobContainerResources>" set '
-                'to wrong type'
-            )
+            else propDict["count"])
 
     @property
-    def requests(self):
-        """JobContainerResources: Describes the cpu and memory resources for t
-        he job containers"""
-        return self._requests
-
-    @requests.setter
-    def requests(self, value):
-        if value is not None and not isinstance(value, JobContainerResources):
-            value = JobContainerResources(value)
-        if (value is None) or isinstance(value, JobContainerResources):
-            self._requests = value
+    def count(self):
+        """CountableResource: Countable Resource object"""
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, CountableResource):
+            value = CountableResource(value)
+        if (value is None) or isinstance(value, CountableResource):
+            self._count = value
         else:
             raise TypeError(
-                'Property "requests" of type "list<JobContainerResources>" se'
-                't to wrong type'
+                'Property "count" of type "list<CountableResource>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
-        if self._limits:
-            result["limits"] = \
-                self._limits.toDict() if self._limits is not None else None
-        if self._requests:
-            result["requests"] = \
-                self._requests.toDict() if self._requests is not None else None
+        if self._count:
+            result["count"] = \
+                self._count.toDict() if self._count is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requests is not None): self._requests.isValid()
-        if (self._limits is not None): self._limits.isValid()
+        if self._count is None:
+            raise ValueError(
+                "DeploymentCpuParametersMeta.count doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._count is not None): self._count.isValid()
         return True
```

## Comparing `ngccli/data/api/CreditsHistory.py` & `organization/data/subscription_management_service/Tab.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,45 +14,68 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreditsHistory(object):
+class Tab(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.creditBalance = (
+        self.content = (
             None if not fromDict or propDict.get(
-                "creditBalance"
+                "content"
             ) is None
-            else propDict["creditBalance"])
+            else propDict["content"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
+
+    @property
+    def content(self):
+        """str: markdown content of the privacy content"""
+        return self._content
+
+    @content.setter
+    def content(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._content = value
+        else:
+            raise TypeError(
+                'Property "content" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def creditBalance(self):
-        """int: Latest credit balance information"""
-        return self._creditBalance
-
-    @creditBalance.setter
-    def creditBalance(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._creditBalance = value
+    def name(self):
+        """str: display name of the tab"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "creditBalance" of type "list<int>" set to wrong ty'
-                'pe'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._creditBalance is not None:
-            result["creditBalance"] = \
-                self._creditBalance
+        if self._content is not None:
+            result["content"] = \
+                self._content
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/CreditsHistoryResponse.py` & `ngcbpc/data/uis/ErrorResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,59 +6,34 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CreditsHistory import CreditsHistory
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(CreditsHistory))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreditsHistoryResponse(object):
-    """showing credit balance"""
+class ErrorResponse(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.creditsHistory = (
-            None if not fromDict or propDict.get(
-                "creditsHistory"
-            ) is None
-            else propDict["creditsHistory"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def creditsHistory(self):
-        """ """
-        return self._creditsHistory
-
-    @creditsHistory.setter
-    def creditsHistory(self, value):
-        if value is not None and not isinstance(value, CreditsHistory):
-            value = CreditsHistory(value)
-        if (value is None) or isinstance(value, CreditsHistory):
-            self._creditsHistory = value
-        else:
-            raise TypeError(
-                'Property "creditsHistory" of type "list<CreditsHistory>" set'
-                ' to wrong type'
-            )
-
-    @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
@@ -69,27 +44,23 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._creditsHistory:
-            result["creditsHistory"] = \
-                self._creditsHistory.toDict() if self._creditsHistory is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._creditsHistory is not None): self._creditsHistory.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/Dataset.py` & `ngcbpc/data/model/Recipe.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,766 +6,823 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DatasetFile import DatasetFile
-from .Team import Team
-from .DatasetStatusEnum import DatasetStatusEnum
-from .StorageLocation import StorageLocation
-from .Organization import Organization
+from .FrameworkType import FrameworkTypeEnum
+from .PrecisionType import PrecisionTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
+from .Dataset import Dataset
+from .Model import Model
+from .AccessTypeEnum import AccessTypeEnum
+from .ApplicationType import ApplicationTypeEnum
 
 # Unused import over optimization prevention
-str(repr(StorageLocation))
-str(repr(DatasetFile))
-str(repr(Team))
-str(repr(Organization))
-str(repr(DatasetStatusEnum))
+str(repr(ProductNamesEnum))
+str(repr(AccessTypeEnum))
+str(repr(PrecisionTypeEnum))
+str(repr(FrameworkTypeEnum))
+str(repr(ApplicationTypeEnum))
+str(repr(Model))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Dataset(object):
-    """Dataset for DL jobs."""
+class Recipe(object):
+    """Recipe object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "accessType"
             ) is None
-            else propDict["aceId"])
-        self.aceName = (
+            else propDict["accessType"])
+        self.advanced = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "advanced"
             ) is None
-            else propDict["aceName"])
-        self.aceStorageServiceUrl = (
+            else propDict["advanced"])
+        self.application = (
             None if not fromDict or propDict.get(
-                "aceStorageServiceUrl"
+                "application"
             ) is None
-            else propDict["aceStorageServiceUrl"])
+            else propDict["application"])
+        self.builtBy = (
+            None if not fromDict or propDict.get(
+                "builtBy"
+            ) is None
+            else propDict["builtBy"])
+        self.canGuestDownload = (
+            None if not fromDict or propDict.get(
+                "canGuestDownload"
+            ) is None
+            else propDict["canGuestDownload"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.creatorUserId = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "creatorUserId"
+                "description"
             ) is None
-            else propDict["creatorUserId"])
-        self.creatorUserName = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "creatorUserName"
+                "displayName"
             ) is None
-            else propDict["creatorUserName"])
-        self.datasetUuid = (
+            else propDict["displayName"])
+        self.isFavourite = (
             None if not fromDict or propDict.get(
-                "datasetUuid"
+                "isFavourite"
             ) is None
-            else propDict["datasetUuid"])
-        self.description = (
+            else propDict["isFavourite"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "description"
+                "isPublic"
             ) is None
-            else propDict["description"])
-        self.fileDownloadUrl = (
+            else propDict["isPublic"])
+        self.isReadOnly = (
             None if not fromDict or propDict.get(
-                "fileDownloadUrl"
+                "isReadOnly"
             ) is None
-            else propDict["fileDownloadUrl"])
-        self.fileUploadUrl = (
+            else propDict["isReadOnly"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "fileUploadUrl"
+                "labels"
             ) is None
-            else propDict["fileUploadUrl"])
-        self.files = (
+            else propDict["labels"])
+        self.latestVersionId = (
             None if not fromDict or propDict.get(
-                "files"
+                "latestVersionId"
             ) is None
-            else [ DatasetFile(i)
-            for i in propDict["files"] ])
-        self.id = (
+            else propDict["latestVersionId"])
+        self.latestVersionIdStr = (
             None if not fromDict or propDict.get(
-                "id"
+                "latestVersionIdStr"
             ) is None
-            else propDict["id"])
-        self.lastAccessDate = (
+            else propDict["latestVersionIdStr"])
+        self.latestVersionSizeInBytes = (
             None if not fromDict or propDict.get(
-                "lastAccessDate"
+                "latestVersionSizeInBytes"
             ) is None
-            else propDict["lastAccessDate"])
-        self.modifiedDate = (
+            else propDict["latestVersionSizeInBytes"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "modifiedDate"
+                "logo"
             ) is None
-            else propDict["modifiedDate"])
+            else propDict["logo"])
+        self.modelFormat = (
+            None if not fromDict or propDict.get(
+                "modelFormat"
+            ) is None
+            else propDict["modelFormat"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.nfsRoot = (
+        self.orgName = (
+            None if not fromDict or propDict.get(
+                "orgName"
+            ) is None
+            else propDict["orgName"])
+        self.performance = (
             None if not fromDict or propDict.get(
-                "nfsRoot"
+                "performance"
             ) is None
-            else propDict["nfsRoot"])
-        self.nfsShare = (
+            else propDict["performance"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "nfsShare"
+                "precision"
             ) is None
-            else propDict["nfsShare"])
-        self.owned = (
+            else propDict["precision"])
+        self.productNames = (
             None if not fromDict or propDict.get(
-                "owned"
+                "productNames"
             ) is None
-            else propDict["owned"])
-        self.prepopulated = (
+            else propDict["productNames"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "prepopulated"
+                "publicDatasetUsed"
             ) is None
-            else propDict["prepopulated"])
-        self.shared = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "shared"
+                "publisher"
             ) is None
-            else propDict["shared"])
-        self.sharedWithOrg = (
+            else propDict["publisher"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "sharedWithOrg"
+                "quickStartGuide"
             ) is None
-            else propDict["sharedWithOrg"])
-        self.sharedWithTeams = (
+            else propDict["quickStartGuide"])
+        self.relatedModels = (
             None if not fromDict or propDict.get(
-                "sharedWithTeams"
+                "relatedModels"
             ) is None
-            else [ Team(i)
-            for i in propDict["sharedWithTeams"] ])
-        self.size = (
+            else [ Model(i)
+            for i in propDict["relatedModels"] ])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "size"
+                "setup"
             ) is None
-            else propDict["size"])
-        self.status = (
+            else propDict["setup"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "status"
+                "shortDescription"
             ) is None
-            else propDict["status"])
-        self.storageLocations = (
+            else propDict["shortDescription"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "storageLocations"
+                "teamName"
             ) is None
-            else [ StorageLocation(i)
-            for i in propDict["storageLocations"] ])
-        self.token = (
+            else propDict["teamName"])
+        self.trainingFramework = (
             None if not fromDict or propDict.get(
-                "token"
+                "trainingFramework"
             ) is None
-            else propDict["token"])
-        self.totalFiles = (
+            else propDict["trainingFramework"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "totalFiles"
+                "updatedDate"
             ) is None
-            else propDict["totalFiles"])
+            else propDict["updatedDate"])
 
     @property
-    def aceId(self):
-        """long: Id of the ACE to which the dataset is local."""
-        return self._aceId
+    def accessType(self):
+        """ """
+        return self._accessType
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def aceName(self):
-        """str: Name of the ACE to which the dataset is local."""
-        return self._aceName
+    def advanced(self):
+        """str: Text for describing advanced information"""
+        return self._advanced
 
-    @aceName.setter
-    def aceName(self, value):
+    @advanced.setter
+    def advanced(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._advanced = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "advanced" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceStorageServiceUrl(self):
-        """str: URL of the storage service of given ACE"""
-        return self._aceStorageServiceUrl
+    def application(self):
+        """ """
+        return self._application
 
-    @aceStorageServiceUrl.setter
-    def aceStorageServiceUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceStorageServiceUrl = value
+    @application.setter
+    def application(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._application = value
         else:
             raise TypeError(
-                'Property "aceStorageServiceUrl" of type "list<str>" set to w'
-                'rong type'
+                'Property "application" of type "list<ApplicationTypeEnum>" s'
+                'et to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """str: Dataset creation date in ISO-8601 format"""
-        return self._createdDate
+    def builtBy(self):
+        """str: Organization that built the recipe"""
+        return self._builtBy
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def creatorUserId(self):
-        """long: User ID of the creator of the dataset."""
-        return self._creatorUserId
+    def canGuestDownload(self):
+        """bool: Indicates if a guest user can download"""
+        return self._canGuestDownload
 
-    @creatorUserId.setter
-    def creatorUserId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._creatorUserId = value
-        else:
-            raise TypeError(
-                'Property "creatorUserId" of type "list<long>" set to wrong t'
-                'ype'
-            )
-
-    @property
-    def creatorUserName(self):
-        """str: User name of the creator of the dataset."""
-        return self._creatorUserName
-
-    @creatorUserName.setter
-    def creatorUserName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._creatorUserName = value
+    @canGuestDownload.setter
+    def canGuestDownload(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestDownload = value
         else:
             raise TypeError(
-                'Property "creatorUserName" of type "list<str>" set to wrong '
-                'type'
+                'Property "canGuestDownload" of type "list<bool>" set to wron'
+                'g type'
             )
 
     @property
-    def datasetUuid(self):
-        """str: Dataset unique UUID."""
-        return self._datasetUuid
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @datasetUuid.setter
-    def datasetUuid(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._datasetUuid = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "datasetUuid" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Dataset description."""
+        """str: Description of the recipe"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fileDownloadUrl(self):
-        """str: Base URL for file download from this dataset"""
-        return self._fileDownloadUrl
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @fileDownloadUrl.setter
-    def fileDownloadUrl(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fileDownloadUrl = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "fileDownloadUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fileUploadUrl(self):
-        """str: Base URL for file upload in this dataset"""
-        return self._fileUploadUrl
+    def isFavourite(self):
+        """bool: Flag indicating if recipe is user's favorite"""
+        return self._isFavourite
 
-    @fileUploadUrl.setter
-    def fileUploadUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._fileUploadUrl = value
+    @isFavourite.setter
+    def isFavourite(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isFavourite = value
         else:
             raise TypeError(
-                'Property "fileUploadUrl" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "isFavourite" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def files(self):
-        """list: list of files in this dataset"""
-        return self._files
+    def isPublic(self):
+        """bool: Determines if this recipe is publicly accessible"""
+        return self._isPublic
 
-    @files.setter
-    def files(self, value):
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
+        else:
+            raise TypeError(
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def isReadOnly(self):
+        """bool: indicate if current user has read only permissions"""
+        return self._isReadOnly
+
+    @isReadOnly.setter
+    def isReadOnly(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isReadOnly = value
+        else:
+            raise TypeError(
+                'Property "isReadOnly" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def labels(self):
+        """ """
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._files = value
+            self._labels = value
+        else:
+            raise TypeError(
+                'Property "labels" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def latestVersionId(self):
+        """long: Deprecated: Please use latestVersionIdStr instead. ID of the 
+        latest version"""
+        return self._latestVersionId
+
+    @latestVersionId.setter
+    def latestVersionId(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._latestVersionId = value
         else:
             raise TypeError(
-                'Property "files" of type "list<DatasetFile>" set to wrong ty'
-                'pe'
+                'Property "latestVersionId" of type "list<long>" set to wrong'
+                ' type'
             )
 
     @property
-    def id(self):
-        """long: Dataset unique ID."""
-        return self._id
+    def latestVersionIdStr(self):
+        """str: ID of the latest version"""
+        return self._latestVersionIdStr
 
-    @id.setter
-    def id(self, value):
+    @latestVersionIdStr.setter
+    def latestVersionIdStr(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._latestVersionIdStr = value
+        else:
+            raise TypeError(
+                'Property "latestVersionIdStr" of type "list<str>" set to wro'
+                'ng type'
+            )
+
+    @property
+    def latestVersionSizeInBytes(self):
+        """long: Size of the latest version in bytes"""
+        return self._latestVersionSizeInBytes
+
+    @latestVersionSizeInBytes.setter
+    def latestVersionSizeInBytes(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._id = value
+            self._latestVersionSizeInBytes = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "latestVersionSizeInBytes" of type "list<long>" set'
+                ' to wrong type'
             )
 
     @property
-    def lastAccessDate(self):
-        """str: Date when dataset was last accessed in ISO-8601 format"""
-        return self._lastAccessDate
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @lastAccessDate.setter
-    def lastAccessDate(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastAccessDate = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "lastAccessDate" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def modifiedDate(self):
-        """str: Date when dataset was last modified in ISO-8601 format"""
-        return self._modifiedDate
+    def modelFormat(self):
+        """str: Format of the model this recipe produces"""
+        return self._modelFormat
 
-    @modifiedDate.setter
-    def modifiedDate(self, value):
+    @modelFormat.setter
+    def modelFormat(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._modifiedDate = value
+            self._modelFormat = value
         else:
             raise TypeError(
-                'Property "modifiedDate" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Name of the dataset."""
+        """str: Unique name of the recipe"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsRoot(self):
-        """str: Path on the NFS share that indicates root directory for the da
-        taset"""
-        return self._nfsRoot
+    def orgName(self):
+        """str: Name of the org that the recipe belongs to"""
+        return self._orgName
 
-    @nfsRoot.setter
-    def nfsRoot(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsRoot = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "nfsRoot" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsShare(self):
-        """str: Location of the NFS share"""
-        return self._nfsShare
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @nfsShare.setter
-    def nfsShare(self, value):
+    @performance.setter
+    def performance(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsShare = value
+            self._performance = value
         else:
             raise TypeError(
-                'Property "nfsShare" of type "list<str>" set to wrong type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def owned(self):
-        """bool: Indicates whether the dataset has been created by the current
-         user"""
-        return self._owned
+    def precision(self):
+        """ """
+        return self._precision
 
-    @owned.setter
-    def owned(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._owned = value
+    @precision.setter
+    def precision(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._precision = value
         else:
             raise TypeError(
-                'Property "owned" of type "list<bool>" set to wrong type'
+                'Property "precision" of type "list<PrecisionTypeEnum>" set t'
+                'o wrong type'
             )
 
     @property
-    def prepopulated(self):
-        """str: Empty means not prepopulated anywhere. Contain e.g. 'prd0' or 
-        'prd0,prd2' or 'all ace', if a roll out is done in stages."""
-        return self._prepopulated
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
 
-    @prepopulated.setter
-    def prepopulated(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._prepopulated = value
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "prepopulated" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def shared(self):
-        """bool: Indicates whether or not the dataset has been shared with eit
-        her a team or an organization."""
-        return self._shared
+    def publicDatasetUsed(self):
+        """ """
+        return self._publicDatasetUsed
 
-    @shared.setter
-    def shared(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._shared = value
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "shared" of type "list<bool>" set to wrong type'
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
+                'wrong type'
             )
 
     @property
-    def sharedWithOrg(self):
-        """Organization: Information about the Organization"""
-        return self._sharedWithOrg
+    def publisher(self):
+        """str: Organization that published this recipe"""
+        return self._publisher
 
-    @sharedWithOrg.setter
-    def sharedWithOrg(self, value):
-        if value is not None and not isinstance(value, Organization):
-            value = Organization(value)
-        if (value is None) or isinstance(value, Organization):
-            self._sharedWithOrg = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "sharedWithOrg" of type "list<Organization>" set to'
-                ' wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sharedWithTeams(self):
-        """list: Shared with these teams"""
-        return self._sharedWithTeams
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @sharedWithTeams.setter
-    def sharedWithTeams(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._sharedWithTeams = value
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "sharedWithTeams" of type "list<Team>" set to wrong'
-                ' type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def size(self):
-        """long: Size of the dataset in MB."""
-        return self._size
+    def relatedModels(self):
+        """ """
+        return self._relatedModels
 
-    @size.setter
-    def size(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._size = value
+    @relatedModels.setter
+    def relatedModels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._relatedModels = value
         else:
             raise TypeError(
-                'Property "size" of type "list<long>" set to wrong type'
+                'Property "relatedModels" of type "list<Model>" set to wrong '
+                'type'
             )
 
     @property
-    def status(self):
-        """DatasetStatusEnum: Indicates the current status of a dataset."""
-        return self._status
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @setup.setter
+    def setup(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._setup = value
         else:
             raise TypeError(
-                'Property "status" of type "list<DatasetStatusEnum>" set to w'
-                'rong type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageLocations(self):
-        """list: Storage locations of the dataset"""
-        return self._storageLocations
+    def shortDescription(self):
+        """str: Short description of the recipe"""
+        return self._shortDescription
 
-    @storageLocations.setter
-    def storageLocations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageLocations = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "storageLocations" of type "list<StorageLocation>" '
-                'set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def token(self):
-        """str: Token to be used with file upload/download operations"""
-        return self._token
+    def teamName(self):
+        """str: Name of the team that the recipe belongs to"""
+        return self._teamName
 
-    @token.setter
-    def token(self, value):
+    @teamName.setter
+    def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._token = value
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "token" of type "list<str>" set to wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def totalFiles(self):
-        """long: Number of files in this dataset."""
-        return self._totalFiles
+    def trainingFramework(self):
+        """ """
+        return self._trainingFramework
 
-    @totalFiles.setter
-    def totalFiles(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalFiles = value
+    @trainingFramework.setter
+    def trainingFramework(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._trainingFramework = value
         else:
             raise TypeError(
-                'Property "totalFiles" of type "list<long>" set to wrong type'
+                'Property "trainingFramework" of type "list<FrameworkTypeEnum'
+                '>" set to wrong type'
+            )
+
+    @property
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
+        else:
+            raise TypeError(
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._aceStorageServiceUrl is not None:
-            result["aceStorageServiceUrl"] = \
-                self._aceStorageServiceUrl
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._advanced is not None:
+            result["advanced"] = \
+                self._advanced
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._canGuestDownload is not None:
+            result["canGuestDownload"] = \
+                self._canGuestDownload
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._creatorUserId is not None:
-            result["creatorUserId"] = \
-                self._creatorUserId
-        if self._creatorUserName is not None:
-            result["creatorUserName"] = \
-                self._creatorUserName
-        if self._datasetUuid is not None:
-            result["datasetUuid"] = \
-                self._datasetUuid
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._fileDownloadUrl is not None:
-            result["fileDownloadUrl"] = \
-                self._fileDownloadUrl
-        if self._fileUploadUrl is not None:
-            result["fileUploadUrl"] = \
-                self._fileUploadUrl
-        if self._files:
-            result["files"] = [
-                i.toDict() for i in self._files 
-            ] if self._files else []
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._lastAccessDate is not None:
-            result["lastAccessDate"] = \
-                self._lastAccessDate
-        if self._modifiedDate is not None:
-            result["modifiedDate"] = \
-                self._modifiedDate
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._isFavourite is not None:
+            result["isFavourite"] = \
+                self._isFavourite
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._isReadOnly is not None:
+            result["isReadOnly"] = \
+                self._isReadOnly
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._latestVersionId is not None:
+            result["latestVersionId"] = \
+                self._latestVersionId
+        if self._latestVersionIdStr is not None:
+            result["latestVersionIdStr"] = \
+                self._latestVersionIdStr
+        if self._latestVersionSizeInBytes is not None:
+            result["latestVersionSizeInBytes"] = \
+                self._latestVersionSizeInBytes
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._nfsRoot is not None:
-            result["nfsRoot"] = \
-                self._nfsRoot
-        if self._nfsShare is not None:
-            result["nfsShare"] = \
-                self._nfsShare
-        if self._owned is not None:
-            result["owned"] = \
-                self._owned
-        if self._prepopulated is not None:
-            result["prepopulated"] = \
-                self._prepopulated
-        if self._shared is not None:
-            result["shared"] = \
-                self._shared
-        if self._sharedWithOrg:
-            result["sharedWithOrg"] = \
-                self._sharedWithOrg.toDict() if self._sharedWithOrg is not None else None
-        if self._sharedWithTeams:
-            result["sharedWithTeams"] = [
-                i.toDict() for i in self._sharedWithTeams 
-            ] if self._sharedWithTeams else []
-        if self._size is not None:
-            result["size"] = \
-                self._size
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._storageLocations:
-            result["storageLocations"] = [
-                i.toDict() for i in self._storageLocations 
-            ] if self._storageLocations else []
-        if self._token is not None:
-            result["token"] = \
-                self._token
-        if self._totalFiles is not None:
-            result["totalFiles"] = \
-                self._totalFiles
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._relatedModels:
+            result["relatedModels"] = [
+                i.toDict() for i in self._relatedModels 
+            ] if self._relatedModels else []
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
+        if self._trainingFramework is not None:
+            result["trainingFramework"] = \
+                self._trainingFramework
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceId is None:
-            raise ValueError(
-                "Dataset.aceId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._aceId is not None
-            and
-            self._aceId < 1):
-            raise ValueError(
-                "Dataset.aceId: " + str(self._aceId) + 
-                " doesnt match requirement: minimum: 1")
-        if self._name is None:
-            raise ValueError(
-                "Dataset.name doesnt match requirement:" 
-                "required: True"
-            )
         if (self._createdDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._createdDate)):
             raise ValueError(
-                "Dataset.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._modifiedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._modifiedDate)):
-            raise ValueError(
-                "Dataset.modifiedDate: " + str(self._modifiedDate) + 
+                "Recipe.createdDate: " + str(self._createdDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._lastAccessDate is not None
+        if (self._updatedDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._lastAccessDate)):
+                 self._updatedDate)):
             raise ValueError(
-                "Dataset.lastAccessDate: " + str(self._lastAccessDate) + 
+                "Recipe.updatedDate: " + str(self._updatedDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._files is not None):
-            for obj in self._files:
-                if (obj is not None): obj.isValid()
-        if (self._sharedWithOrg is not None): self._sharedWithOrg.isValid()
-        if (self._sharedWithTeams is not None):
-            for obj in self._sharedWithTeams:
-                if (obj is not None): obj.isValid()
-        if (self._storageLocations is not None):
-            for obj in self._storageLocations:
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
+        if (self._relatedModels is not None):
+            for obj in self._relatedModels:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetAddFilesRequest.py` & `basecommand/data/pym/ProjectListResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,72 +6,100 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DatasetFilePath import DatasetFilePath
+from .ProjectDetails import ProjectDetails
 
 # Unused import over optimization prevention
-str(repr(DatasetFilePath))
+str(repr(ProjectDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetAddFilesRequest(object):
-    """Add files to dataset request."""
+class ProjectListResponse(object):
+    """Project List Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.files = (
+        self.projects = (
             None if not fromDict or propDict.get(
-                "files"
+                "projects"
             ) is None
-            else [ DatasetFilePath(i)
-            for i in propDict["files"] ])
+            else [ ProjectDetails(i)
+            for i in propDict["projects"] ])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def files(self):
-        """list: Array of file names (in unix format)."""
-        return self._files
+    def projects(self):
+        """ """
+        return self._projects
 
-    @files.setter
-    def files(self, value):
+    @projects.setter
+    def projects(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._files = value
+            self._projects = value
+        else:
+            raise TypeError(
+                'Property "projects" of type "list<ProjectDetails>" set to wr'
+                'ong type'
+            )
+
+    @property
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "files" of type "list<DatasetFilePath>" set to wron'
-                'g type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._files:
-            result["files"] = [
-                i.toDict() for i in self._files 
-            ] if self._files else []
+        if self._projects:
+            result["projects"] = [
+                i.toDict() for i in self._projects 
+            ] if self._projects else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._files is not None
-            and
-            len(self._files) > 1000):
+        if self._version is None:
             raise ValueError(
-                "DatasetAddFilesRequest.files: " + str(self._files) + 
-                " doesnt match requirement: maxItems: 1000")
-        if (self._files is not None):
-            for obj in self._files:
+                "ProjectListResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._projects is None:
+            raise ValueError(
+                "ProjectListResponse.projects doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._projects is not None):
+            for obj in self._projects:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetCreateRequest.py` & `ngcbpc/data/registry/SecurityRatingDescription.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,247 +6,216 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SecurityRatingType import SecurityRatingTypeEnum
 
 # Unused import over optimization prevention
+str(repr(SecurityRatingTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetCreateRequest(object):
-    """Dataset creation request."""
+class SecurityRatingDescription(object):
+    """Security rating description"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
-            None if not fromDict or propDict.get(
-                "aceId"
-            ) is None
-            else propDict["aceId"])
-        self.aceName = (
-            None if not fromDict or propDict.get(
-                "aceName"
-            ) is None
-            else propDict["aceName"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.name = (
+        self.details = (
             None if not fromDict or propDict.get(
-                "name"
+                "details"
             ) is None
-            else propDict["name"])
-        self.nfsRoot = (
+            else propDict["details"])
+        self.scale = (
             None if not fromDict or propDict.get(
-                "nfsRoot"
+                "scale"
             ) is None
-            else propDict["nfsRoot"])
-        self.nfsShare = (
+            else propDict["scale"])
+        self.vulnerabilities = (
             None if not fromDict or propDict.get(
-                "nfsShare"
+                "vulnerabilities"
             ) is None
-            else propDict["nfsShare"])
-        self.onBehalfOf = (
+            else propDict["vulnerabilities"])
+        self.vulnerabilitiesMaxCount = (
             None if not fromDict or propDict.get(
-                "onBehalfOf"
+                "vulnerabilitiesMaxCount"
             ) is None
-            else propDict["onBehalfOf"])
-        self.resultsetIdForBaseDataSource = (
+            else propDict["vulnerabilitiesMaxCount"])
+        self.vulnerabilitiesMinCount = (
             None if not fromDict or propDict.get(
-                "resultsetIdForBaseDataSource"
+                "vulnerabilitiesMinCount"
             ) is None
-            else propDict["resultsetIdForBaseDataSource"])
-
-    @property
-    def aceId(self):
-        """long: ID of the ACE to which the dataset will belong"""
-        return self._aceId
-
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
-        else:
-            raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
-            )
-
-    @property
-    def aceName(self):
-        """str: Name of the ACE to which the dataset will belong"""
-        return self._aceName
-
-    @aceName.setter
-    def aceName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceName = value
-        else:
-            raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
-            )
+            else propDict["vulnerabilitiesMinCount"])
 
     @property
     def description(self):
-        """str: Description of the dataset"""
+        """str: Description of the security rating"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name for the dataset"""
-        return self._name
+    def details(self):
+        """str: Detailed description relating to the number of packages vulner
+        abilities when this security rating is given"""
+        return self._details
 
-    @name.setter
-    def name(self, value):
+    @details.setter
+    def details(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._details = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "details" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsRoot(self):
-        """str: Path on the NFS share that indicates root directory for the da
-        taset"""
-        return self._nfsRoot
+    def scale(self):
+        """SecurityRatingTypeEnum: Security Rating Type"""
+        return self._scale
 
-    @nfsRoot.setter
-    def nfsRoot(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._nfsRoot = value
+    @scale.setter
+    def scale(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._scale = value
         else:
             raise TypeError(
-                'Property "nfsRoot" of type "list<str>" set to wrong type'
+                'Property "scale" of type "list<SecurityRatingTypeEnum>" set '
+                'to wrong type'
             )
 
     @property
-    def nfsShare(self):
-        """str: Location of the NFS share"""
-        return self._nfsShare
+    def vulnerabilities(self):
+        """str: Numeric description relating to the number of packages vulnera
+        bilities when this rating is given"""
+        return self._vulnerabilities
 
-    @nfsShare.setter
-    def nfsShare(self, value):
+    @vulnerabilities.setter
+    def vulnerabilities(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsShare = value
+            self._vulnerabilities = value
         else:
             raise TypeError(
-                'Property "nfsShare" of type "list<str>" set to wrong type'
+                'Property "vulnerabilities" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def onBehalfOf(self):
-        """str: Auth client Id that we want to create this dataset on behalf o
-        f. Only for dataset admins"""
-        return self._onBehalfOf
+    def vulnerabilitiesMaxCount(self):
+        """int: Upper bound for the vulnerability count used for rating calcul
+        ation (inclusive)"""
+        return self._vulnerabilitiesMaxCount
 
-    @onBehalfOf.setter
-    def onBehalfOf(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._onBehalfOf = value
+    @vulnerabilitiesMaxCount.setter
+    def vulnerabilitiesMaxCount(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._vulnerabilitiesMaxCount = value
         else:
             raise TypeError(
-                'Property "onBehalfOf" of type "list<str>" set to wrong type'
+                'Property "vulnerabilitiesMaxCount" of type "list<int>" set t'
+                'o wrong type'
             )
 
     @property
-    def resultsetIdForBaseDataSource(self):
-        """long: Id of the resultset which should be used to create the datase
-        t. The dataset will contain all the files of the resultset."""
-        return self._resultsetIdForBaseDataSource
+    def vulnerabilitiesMinCount(self):
+        """int: Lower bound for the vulnerability count used for rating calcul
+        ation (inclusive)"""
+        return self._vulnerabilitiesMinCount
 
-    @resultsetIdForBaseDataSource.setter
-    def resultsetIdForBaseDataSource(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resultsetIdForBaseDataSource = value
+    @vulnerabilitiesMinCount.setter
+    def vulnerabilitiesMinCount(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._vulnerabilitiesMinCount = value
         else:
             raise TypeError(
-                'Property "resultsetIdForBaseDataSource" of type "list<long>"'
-                ' set to wrong type'
+                'Property "vulnerabilitiesMinCount" of type "list<int>" set t'
+                'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._nfsRoot is not None:
-            result["nfsRoot"] = \
-                self._nfsRoot
-        if self._nfsShare is not None:
-            result["nfsShare"] = \
-                self._nfsShare
-        if self._onBehalfOf is not None:
-            result["onBehalfOf"] = \
-                self._onBehalfOf
-        if self._resultsetIdForBaseDataSource is not None:
-            result["resultsetIdForBaseDataSource"] = \
-                self._resultsetIdForBaseDataSource
+        if self._details is not None:
+            result["details"] = \
+                self._details
+        if self._scale is not None:
+            result["scale"] = \
+                self._scale
+        if self._vulnerabilities is not None:
+            result["vulnerabilities"] = \
+                self._vulnerabilities
+        if self._vulnerabilitiesMaxCount is not None:
+            result["vulnerabilitiesMaxCount"] = \
+                self._vulnerabilitiesMaxCount
+        if self._vulnerabilitiesMinCount is not None:
+            result["vulnerabilitiesMinCount"] = \
+                self._vulnerabilitiesMinCount
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._scale is None:
             raise ValueError(
-                "DatasetCreateRequest.name doesnt match requirement:" 
+                "SecurityRatingDescription.scale doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) < 2):
+        if self._description is None:
             raise ValueError(
-                "DatasetCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
-            and
-            len(self._name) > 255):
+                "SecurityRatingDescription.description doesnt match requirement:" 
+                "required: True"
+            )
+        if self._vulnerabilities is None:
             raise ValueError(
-                "DatasetCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
+                "SecurityRatingDescription.vulnerabilities doesnt match requirement:" 
+                "required: True"
+            )
+        if self._details is None:
+            raise ValueError(
+                "SecurityRatingDescription.details doesnt match requirement:" 
+                "required: True"
+            )
+        if self._vulnerabilitiesMinCount is None:
+            raise ValueError(
+                "SecurityRatingDescription.vulnerabilitiesMinCount doesnt match requirement:" 
+                "required: True"
+            )
+        if self._vulnerabilitiesMaxCount is None:
+            raise ValueError(
+                "SecurityRatingDescription.vulnerabilitiesMaxCount doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/DatasetFile.py` & `ngcbpc/data/uis/OrgOwner.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,178 +14,160 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetFile(object):
-    """File in the dataset."""
+class OrgOwner(object):
+    """Org owner"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.createdDate = (
+        self.email = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "email"
             ) is None
-            else propDict["createdDate"])
-        self.datasetId = (
+            else propDict["email"])
+        self.fullName = (
             None if not fromDict or propDict.get(
-                "datasetId"
+                "fullName"
             ) is None
-            else propDict["datasetId"])
-        self.fileSize = (
+            else propDict["fullName"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "fileSize"
+                "id"
             ) is None
-            else propDict["fileSize"])
-        self.isDir = (
+            else propDict["id"])
+        self.lastLoginDate = (
             None if not fromDict or propDict.get(
-                "isDir"
+                "lastLoginDate"
             ) is None
-            else propDict["isDir"])
-        self.path = (
-            None if not fromDict or propDict.get(
-                "path"
-            ) is None
-            else propDict["path"])
+            else propDict["lastLoginDate"])
 
     @property
-    def createdDate(self):
-        """str: Date when file was uploaded in ISO-8601 format."""
-        return self._createdDate
+    def email(self):
+        """str: Email address of the org owner."""
+        return self._email
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def datasetId(self):
-        """long: Dataset ID this file belongs to."""
-        return self._datasetId
+    def fullName(self):
+        """str: user name"""
+        return self._fullName
 
-    @datasetId.setter
-    def datasetId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._datasetId = value
+    @fullName.setter
+    def fullName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._fullName = value
         else:
             raise TypeError(
-                'Property "datasetId" of type "list<long>" set to wrong type'
+                'Property "fullName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fileSize(self):
-        """long: Size of the file in bytes."""
-        return self._fileSize
+    def id(self):
+        """long: unique Id of this user."""
+        return self._id
 
-    @fileSize.setter
-    def fileSize(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._fileSize = value
-        else:
-            raise TypeError(
-                'Property "fileSize" of type "list<long>" set to wrong type'
-            )
-
-    @property
-    def isDir(self):
-        """bool: Indicates if this is a directory or not"""
-        return self._isDir
-
-    @isDir.setter
-    def isDir(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDir = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "isDir" of type "list<bool>" set to wrong type'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
-    def path(self):
-        """str: Relative file path from the root of the dataset."""
-        return self._path
+    def lastLoginDate(self):
+        """str: Last time the org owner logged in."""
+        return self._lastLoginDate
 
-    @path.setter
-    def path(self, value):
+    @lastLoginDate.setter
+    def lastLoginDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._path = value
+            self._lastLoginDate = value
         else:
             raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
+                'Property "lastLoginDate" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._datasetId is not None:
-            result["datasetId"] = \
-                self._datasetId
-        if self._fileSize is not None:
-            result["fileSize"] = \
-                self._fileSize
-        if self._isDir is not None:
-            result["isDir"] = \
-                self._isDir
-        if self._path is not None:
-            result["path"] = \
-                self._path
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._fullName is not None:
+            result["fullName"] = \
+                self._fullName
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._lastLoginDate is not None:
+            result["lastLoginDate"] = \
+                self._lastLoginDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._path is None:
+        if self._email is None:
             raise ValueError(
-                "DatasetFile.path doesnt match requirement:" 
+                "OrgOwner.email doesnt match requirement:" 
                 "required: True"
             )
-        if (self._path is not None
+        if (self._email is not None
             and
-            len(self._path) < 2):
+            len(self._email) > 128):
             raise ValueError(
-                "DatasetFile.path: " + str(self._path) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._path is not None
+                "OrgOwner.email: " + str(self._email) + 
+                " doesnt match requirement: maxLength: 128")
+        if (self._email is not None
             and
-            len(self._path) > 1024):
+            not re.match(
+                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
+                 self._email)):
             raise ValueError(
-                "DatasetFile.path: " + str(self._path) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._fileSize is not None
+                "OrgOwner.email: " + str(self._email) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
+                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
+        if self._fullName is None:
+            raise ValueError(
+                "OrgOwner.fullName doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._fullName is not None
             and
-            self._fileSize < 0):
+            len(self._fullName) < 1):
             raise ValueError(
-                "DatasetFile.fileSize: " + str(self._fileSize) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._createdDate is not None
+                "OrgOwner.fullName: " + str(self._fullName) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._fullName is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._fullName) > 64):
             raise ValueError(
-                "DatasetFile.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "OrgOwner.fullName: " + str(self._fullName) + 
+                " doesnt match requirement: maxLength: 64")
         return True
```

## Comparing `ngccli/data/api/DatasetFileBatch.py` & `ngcbpc/data/registry/RepositoryLabelsPatchRequest.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,66 +6,58 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DatasetFile import DatasetFile
 
 # Unused import over optimization prevention
-str(repr(DatasetFile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetFileBatch(object):
-    """Batch of dataset files"""
+class RepositoryLabelsPatchRequest(object):
+    """Request to patch repository labels"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.files = (
+        self.labels = (
             None if not fromDict or propDict.get(
-                "files"
+                "labels"
             ) is None
-            else [ DatasetFile(i)
-            for i in propDict["files"] ])
+            else propDict["labels"])
 
     @property
-    def files(self):
-        """list: Batch of files belonging to same dataset."""
-        return self._files
+    def labels(self):
+        """ """
+        return self._labels
 
-    @files.setter
-    def files(self, value):
+    @labels.setter
+    def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._files = value
+            self._labels = value
         else:
             raise TypeError(
-                'Property "files" of type "list<DatasetFile>" set to wrong ty'
-                'pe'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._files:
-            result["files"] = [
-                i.toDict() for i in self._files 
-            ] if self._files else []
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._files is not None):
-            for obj in self._files:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetFileEventRequest.py` & `ngcbpc/data/model/ArtifactEvent.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,179 +6,166 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactTypeEnum import ArtifactTypeEnum
 
 # Unused import over optimization prevention
+str(repr(ArtifactTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetFileEventRequest(object):
-    """This request tells that a file belonging to a dataset has been uploaded
+class ArtifactEvent(object):
+    """This event in the topic means that some change happened to the artifact
     """
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.datasetId = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "datasetId"
+                "artifactType"
             ) is None
-            else propDict["datasetId"])
+            else propDict["artifactType"])
         self.eventType = (
             None if not fromDict or propDict.get(
                 "eventType"
             ) is None
             else propDict["eventType"])
-        self.filePath = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "filePath"
+                "name"
             ) is None
-            else propDict["filePath"])
-        self.fileSize = (
+            else propDict["name"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "fileSize"
+                "namespace"
             ) is None
-            else propDict["fileSize"])
-        self.orgName = (
-            None if not fromDict or propDict.get(
-                "orgName"
-            ) is None
-            else propDict["orgName"])
+            else propDict["namespace"])
 
     @property
-    def datasetId(self):
-        """ """
-        return self._datasetId
-
-    @datasetId.setter
-    def datasetId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._datasetId = value
+    def artifactType(self):
+        """ArtifactTypeEnum: Artifact type"""
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "datasetId" of type "list<long>" set to wrong type'
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
     def eventType(self):
-        """ """
+        """EventTypeEnum: Artifact event type"""
         return self._eventType
 
     @eventType.setter
     def eventType(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._eventType = value
         else:
             raise TypeError(
                 'Property "eventType" of type "list<EventTypeEnum>" set to wr'
                 'ong type'
             )
 
-    EventTypeEnum=["UPLOAD_STARTED","UPLOAD_INTERRUPTED","UPLOAD_COMPLETED","UPLOAD_FAILED","DATASET_UPLOAD_COMPLETED","DELETE_STARTED","DELETE_INTERRUPTED","DELETE_FAILED","DELETE_COMPLETED",]
+    EventTypeEnum=["CREATED","UPDATED","DELETED","UNPUBLISHED",]
     str(repr(EventTypeEnum))  # Prevent optimizer removing enum
 
     @property
-    def filePath(self):
-        """str: Full file path."""
-        return self._filePath
+    def name(self):
+        """str: Artifact name"""
+        return self._name
 
-    @filePath.setter
-    def filePath(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._filePath = value
-        else:
-            raise TypeError(
-                'Property "filePath" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def fileSize(self):
-        """long: file size in bytes"""
-        return self._fileSize
-
-    @fileSize.setter
-    def fileSize(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._fileSize = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "fileSize" of type "list<long>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: org name that the dataset belongs to. This is used by DATASET_
-        UPLOAD_COMPLETED"""
-        return self._orgName
+    def namespace(self):
+        """str: Artifact namespace"""
+        return self._namespace
 
-    @orgName.setter
-    def orgName(self, value):
+    @namespace.setter
+    def namespace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._datasetId is not None:
-            result["datasetId"] = \
-                self._datasetId
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
         if self._eventType is not None:
             result["eventType"] = \
                 self._eventType
-        if self._filePath is not None:
-            result["filePath"] = \
-                self._filePath
-        if self._fileSize is not None:
-            result["fileSize"] = \
-                self._fileSize
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._filePath is not None
-            and
-            len(self._filePath) < 2):
+        if self._namespace is None:
             raise ValueError(
-                "DatasetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._filePath is not None
+                "ArtifactEvent.namespace doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._namespace is not None
             and
-            len(self._filePath) > 1024):
+            len(self._namespace) > 255):
+            raise ValueError(
+                "ArtifactEvent.namespace: " + str(self._namespace) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._name is None:
             raise ValueError(
-                "DatasetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._filePath is not None
+                "ArtifactEvent.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
             and
-            not re.match(
-                r"^(\/(?!\/)([\w- %\.(?!\.)])+)+$",
-                 self._filePath)):
-            raise ValueError(
-                "DatasetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: pattern: ^(\/(?!\/)([\w- %\.(?!\."
-                ")])+)+$")
+            len(self._name) > 255):
+            raise ValueError(
+                "ArtifactEvent.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._artifactType is None:
+            raise ValueError(
+                "ArtifactEvent.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._eventType is None:
+            raise ValueError(
+                "ArtifactEvent.eventType doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/DatasetFilePath.py` & `ngcbpc/data/uis/MetaData.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,71 +14,79 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetFilePath(object):
-    """File in the dataset"""
+class MetaData(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.path = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "path"
+                "key"
             ) is None
-            else propDict["path"])
+            else propDict["key"])
+        self.value = (
+            None if not fromDict or propDict.get(
+                "value"
+            ) is None
+            else propDict["value"])
 
     @property
-    def path(self):
-        """str: Full file path."""
-        return self._path
+    def key(self):
+        """ """
+        return self._key
 
-    @path.setter
-    def path(self, value):
+    @key.setter
+    def key(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._path = value
+            self._key = value
         else:
             raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
+                'Property "key" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def value(self):
+        """ """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._value = value
+        else:
+            raise TypeError(
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._path is not None:
-            result["path"] = \
-                self._path
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._path is not None
-            and
-            len(self._path) < 2):
-            raise ValueError(
-                "DatasetFilePath.path: " + str(self._path) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._path is not None
-            and
-            len(self._path) > 1024):
-            raise ValueError(
-                "DatasetFilePath.path: " + str(self._path) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._path is not None
+        if (self._key is not None
             and
-            not re.match(
-                r"^(\/(?!\/)([\w- %\.(?!\.)])+)+$",
-                 self._path)):
+            len(self._key) > 255):
             raise ValueError(
-                "DatasetFilePath.path: " + str(self._path) + 
-                " doesnt match requirement: pattern: ^(\/(?!\/)([\w- %\.(?!\."
-                ")])+)+$")
+                "MetaData.key: " + str(self._key) + 
+                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/DatasetListResponse.py` & `ngcbpc/data/model/ModelVersionListResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,95 +6,92 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .DatasetSimplified import DatasetSimplified
 from .RequestStatus import RequestStatus
-from .MetaData import MetaData
+from .Model import Model
+from .PaginationInfo import PaginationInfo
+from .ModelVersion import ModelVersion
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(DatasetSimplified))
 str(repr(PaginationInfo))
-str(repr(MetaData))
+str(repr(Model))
+str(repr(ModelVersion))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetListResponse(object):
-    """listing of all datasets under one team"""
+class ModelVersionListResponse(object):
+    """Response to list model versions request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.datasets = (
+        self.model = (
             None if not fromDict or propDict.get(
-                "datasets"
+                "model"
             ) is None
-            else [ DatasetSimplified(i)
-            for i in propDict["datasets"] ])
-        self.filters = (
+            else propDict["model"])
+        self.modelVersions = (
             None if not fromDict or propDict.get(
-                "filters"
+                "modelVersions"
             ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
+            else [ ModelVersion(i)
+            for i in propDict["modelVersions"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def datasets(self):
-        """ """
-        return self._datasets
-
-    @datasets.setter
-    def datasets(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._datasets = value
+    def model(self):
+        """Model: Model object"""
+        return self._model
+
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
         else:
             raise TypeError(
-                'Property "datasets" of type "list<DatasetSimplified>" set to'
-                ' wrong type'
+                'Property "model" of type "list<Model>" set to wrong type'
             )
 
     @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
+    def modelVersions(self):
+        """ """
+        return self._modelVersions
 
-    @filters.setter
-    def filters(self, value):
+    @modelVersions.setter
+    def modelVersions(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._filters = value
+            self._modelVersions = value
         else:
             raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
-                'e'
+                'Property "modelVersions" of type "list<ModelVersion>" set to'
+                ' wrong type'
             )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -103,15 +100,15 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -120,22 +117,21 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._datasets:
-            result["datasets"] = [
-                i.toDict() for i in self._datasets 
-            ] if self._datasets else []
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._modelVersions:
+            result["modelVersions"] = [
+                i.toDict() for i in self._modelVersions 
+            ] if self._modelVersions else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -143,18 +139,16 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._datasets is not None):
-            for obj in self._datasets:
-                if (obj is not None): obj.isValid()
-        if (self._filters is not None):
-            for obj in self._filters:
+        if (self._model is not None): self._model.isValid()
+        if (self._modelVersions is not None):
+            for obj in self._modelVersions:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetResponse.py` & `ngcbpc/data/uis/IdpRuleListResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,86 +7,62 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .Dataset import Dataset
 from .RequestStatus import RequestStatus
-from .MetaData import MetaData
+from .IdpRule import IdpRule
 
 # Unused import over optimization prevention
 str(repr(PaginationInfo))
+str(repr(IdpRule))
 str(repr(RequestStatus))
-str(repr(Dataset))
-str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetResponse(object):
-    """showing details of the dataset"""
+class IdpRuleListResponse(object):
+    """Response containing info about the IDP rule CRUD operation"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.dataset = (
+        self.idpRules = (
             None if not fromDict or propDict.get(
-                "dataset"
+                "idpRules"
             ) is None
-            else propDict["dataset"])
-        self.filters = (
-            None if not fromDict or propDict.get(
-                "filters"
-            ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
+            else [ IdpRule(i)
+            for i in propDict["idpRules"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def dataset(self):
-        """Dataset: Dataset for DL jobs."""
-        return self._dataset
-
-    @dataset.setter
-    def dataset(self, value):
-        if value is not None and not isinstance(value, Dataset):
-            value = Dataset(value)
-        if (value is None) or isinstance(value, Dataset):
-            self._dataset = value
-        else:
-            raise TypeError(
-                'Property "dataset" of type "list<Dataset>" set to wrong type'
-            )
+    def idpRules(self):
+        """list: List of IDP rules"""
+        return self._idpRules
 
-    @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
-
-    @filters.setter
-    def filters(self, value):
+    @idpRules.setter
+    def idpRules(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._filters = value
+            self._idpRules = value
         else:
             raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
+                'Property "idpRules" of type "list<IdpRule>" set to wrong typ'
                 'e'
             )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
@@ -118,21 +94,18 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._dataset:
-            result["dataset"] = \
-                self._dataset.toDict() if self._dataset is not None else None
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
+        if self._idpRules:
+            result["idpRules"] = [
+                i.toDict() for i in self._idpRules 
+            ] if self._idpRules else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -140,16 +113,25 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._dataset is not None): self._dataset.isValid()
-        if (self._filters is not None):
-            for obj in self._filters:
+        if self._requestStatus is None:
+            raise ValueError(
+                "IdpRuleListResponse.requestStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if self._idpRules is None:
+            raise ValueError(
+                "IdpRuleListResponse.idpRules doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._idpRules is not None):
+            for obj in self._idpRules:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetSimplified.py` & `ngcbpc/data/model/ModelUpdateRequest.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,617 +6,589 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DatasetStatusEnum import DatasetStatusEnum
+from .Dataset import Dataset
 
 # Unused import over optimization prevention
-str(repr(DatasetStatusEnum))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetSimplified(object):
-    """Dataset for DL jobs."""
+class ModelUpdateRequest(object):
+    """Request to create a new model"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.application = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "application"
             ) is None
-            else propDict["aceId"])
-        self.aceName = (
+            else propDict["application"])
+        self.bias = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "bias"
             ) is None
-            else propDict["aceName"])
-        self.aceStorageServiceUrl = (
+            else propDict["bias"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "aceStorageServiceUrl"
+                "builtBy"
             ) is None
-            else propDict["aceStorageServiceUrl"])
-        self.createdDate = (
-            None if not fromDict or propDict.get(
-                "createdDate"
-            ) is None
-            else propDict["createdDate"])
-        self.creatorUserId = (
-            None if not fromDict or propDict.get(
-                "creatorUserId"
-            ) is None
-            else propDict["creatorUserId"])
-        self.datasetUuid = (
-            None if not fromDict or propDict.get(
-                "datasetUuid"
-            ) is None
-            else propDict["datasetUuid"])
+            else propDict["builtBy"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.fileDownloadUrl = (
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "fileDownloadUrl"
+                "displayName"
             ) is None
-            else propDict["fileDownloadUrl"])
-        self.fileUploadUrl = (
+            else propDict["displayName"])
+        self.explainability = (
             None if not fromDict or propDict.get(
-                "fileUploadUrl"
+                "explainability"
             ) is None
-            else propDict["fileUploadUrl"])
-        self.id = (
+            else propDict["explainability"])
+        self.framework = (
             None if not fromDict or propDict.get(
-                "id"
+                "framework"
             ) is None
-            else propDict["id"])
-        self.lastAccessDate = (
+            else propDict["framework"])
+        self.hasPlayground = (
             None if not fromDict or propDict.get(
-                "lastAccessDate"
+                "hasPlayground"
             ) is None
-            else propDict["lastAccessDate"])
-        self.modifiedDate = (
+            else propDict["hasPlayground"])
+        self.isPlaygroundEnabled = (
             None if not fromDict or propDict.get(
-                "modifiedDate"
+                "isPlaygroundEnabled"
             ) is None
-            else propDict["modifiedDate"])
-        self.name = (
+            else propDict["isPlaygroundEnabled"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "name"
+                "labels"
             ) is None
-            else propDict["name"])
-        self.nfsRoot = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "nfsRoot"
+                "labelsV2"
             ) is None
-            else propDict["nfsRoot"])
-        self.nfsShare = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "nfsShare"
+                "logo"
             ) is None
-            else propDict["nfsShare"])
-        self.owned = (
+            else propDict["logo"])
+        self.modelFormat = (
             None if not fromDict or propDict.get(
-                "owned"
+                "modelFormat"
             ) is None
-            else propDict["owned"])
-        self.prepopulated = (
+            else propDict["modelFormat"])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "prepopulated"
+                "ownerName"
             ) is None
-            else propDict["prepopulated"])
-        self.shared = (
+            else propDict["ownerName"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "shared"
+                "precision"
             ) is None
-            else propDict["shared"])
-        self.size = (
+            else propDict["precision"])
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "size"
+                "privacy"
             ) is None
-            else propDict["size"])
-        self.status = (
+            else propDict["privacy"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "status"
+                "publicDatasetUsed"
             ) is None
-            else propDict["status"])
-        self.token = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "token"
+                "publisher"
             ) is None
-            else propDict["token"])
-        self.totalFiles = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "totalFiles"
+                "safetyAndSecurity"
             ) is None
-            else propDict["totalFiles"])
-
-    @property
-    def aceId(self):
-        """long: Id of the ACE to which the dataset is local."""
-        return self._aceId
-
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
-        else:
-            raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
-            )
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
 
     @property
-    def aceName(self):
-        """str: Name of the ACE to which the dataset is local."""
-        return self._aceName
+    def application(self):
+        """str: Application of the model"""
+        return self._application
 
-    @aceName.setter
-    def aceName(self, value):
+    @application.setter
+    def application(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._application = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "application" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceStorageServiceUrl(self):
-        """str: URL of the storage service of given ACE"""
-        return self._aceStorageServiceUrl
+    def bias(self):
+        """str: Text describing bias in the model"""
+        return self._bias
 
-    @aceStorageServiceUrl.setter
-    def aceStorageServiceUrl(self, value):
+    @bias.setter
+    def bias(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceStorageServiceUrl = value
+            self._bias = value
         else:
             raise TypeError(
-                'Property "aceStorageServiceUrl" of type "list<str>" set to w'
-                'rong type'
+                'Property "bias" of type "list<str>" set to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """str: Dataset creation date in ISO-8601 format"""
-        return self._createdDate
+    def builtBy(self):
+        """str: organization that built the repository"""
+        return self._builtBy
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def creatorUserId(self):
-        """long: User ID of the creator of the dataset."""
-        return self._creatorUserId
-
-    @creatorUserId.setter
-    def creatorUserId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._creatorUserId = value
-        else:
-            raise TypeError(
-                'Property "creatorUserId" of type "list<long>" set to wrong t'
-                'ype'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def datasetUuid(self):
-        """str: Dataset unique UUID."""
-        return self._datasetUuid
+    def description(self):
+        """str: Description of the model"""
+        return self._description
 
-    @datasetUuid.setter
-    def datasetUuid(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._datasetUuid = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "datasetUuid" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: Dataset description."""
-        return self._description
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @description.setter
-    def description(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fileDownloadUrl(self):
-        """str: Base URL for file download from this dataset"""
-        return self._fileDownloadUrl
+    def explainability(self):
+        """str: Text describing explainability for this model"""
+        return self._explainability
 
-    @fileDownloadUrl.setter
-    def fileDownloadUrl(self, value):
+    @explainability.setter
+    def explainability(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fileDownloadUrl = value
+            self._explainability = value
         else:
             raise TypeError(
-                'Property "fileDownloadUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def fileUploadUrl(self):
-        """str: Base URL for file upload in this dataset"""
-        return self._fileUploadUrl
+    def framework(self):
+        """str: Framework used to train this model"""
+        return self._framework
 
-    @fileUploadUrl.setter
-    def fileUploadUrl(self, value):
+    @framework.setter
+    def framework(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fileUploadUrl = value
+            self._framework = value
         else:
             raise TypeError(
-                'Property "fileUploadUrl" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "framework" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Dataset unique ID."""
-        return self._id
+    def hasPlayground(self):
+        """bool: indicate if the Model has AI Playground configured"""
+        return self._hasPlayground
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @hasPlayground.setter
+    def hasPlayground(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._hasPlayground = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "hasPlayground" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def lastAccessDate(self):
-        """str: Date when dataset was last accessed in ISO-8601 format"""
-        return self._lastAccessDate
+    def isPlaygroundEnabled(self):
+        """bool: indicate if AI Playground is enabled in the catalog"""
+        return self._isPlaygroundEnabled
 
-    @lastAccessDate.setter
-    def lastAccessDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._lastAccessDate = value
+    @isPlaygroundEnabled.setter
+    def isPlaygroundEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPlaygroundEnabled = value
         else:
             raise TypeError(
-                'Property "lastAccessDate" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "isPlaygroundEnabled" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def modifiedDate(self):
-        """str: Date when dataset was last modified in ISO-8601 format"""
-        return self._modifiedDate
+    def labels(self):
+        """ """
+        return self._labels
 
-    @modifiedDate.setter
-    def modifiedDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._modifiedDate = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "modifiedDate" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the dataset."""
-        return self._name
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsRoot(self):
-        """str: Path on the NFS share that indicates root directory for the da
-        taset"""
-        return self._nfsRoot
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @nfsRoot.setter
-    def nfsRoot(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsRoot = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "nfsRoot" of type "list<str>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsShare(self):
-        """str: Location of the NFS share"""
-        return self._nfsShare
+    def modelFormat(self):
+        """str: Format of the model"""
+        return self._modelFormat
 
-    @nfsShare.setter
-    def nfsShare(self, value):
+    @modelFormat.setter
+    def modelFormat(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsShare = value
+            self._modelFormat = value
         else:
             raise TypeError(
-                'Property "nfsShare" of type "list<str>" set to wrong type'
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
-    def owned(self):
-        """bool: Indicates whether the dataset has been created by the current
-         user"""
-        return self._owned
+    def ownerName(self):
+        """str: Name of the user who owns this model"""
+        return self._ownerName
 
-    @owned.setter
-    def owned(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._owned = value
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "owned" of type "list<bool>" set to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def prepopulated(self):
-        """str: Empty means not prepopulated anywhere. Contain e.g. 'prd0' or 
-        'prd0,prd2' or 'all ace', if a roll out is done in stages."""
-        return self._prepopulated
+    def precision(self):
+        """str: Precision this model was trained with"""
+        return self._precision
 
-    @prepopulated.setter
-    def prepopulated(self, value):
+    @precision.setter
+    def precision(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._prepopulated = value
+            self._precision = value
         else:
             raise TypeError(
-                'Property "prepopulated" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "precision" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shared(self):
-        """bool: Indicates whether or not the dataset has been shared with eit
-        her a team or an organization."""
-        return self._shared
+    def privacy(self):
+        """str: Text describing the privacy for this model"""
+        return self._privacy
 
-    @shared.setter
-    def shared(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._shared = value
+    @privacy.setter
+    def privacy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._privacy = value
         else:
             raise TypeError(
-                'Property "shared" of type "list<bool>" set to wrong type'
+                'Property "privacy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def size(self):
-        """long: Size of the dataset in MB."""
-        return self._size
+    def publicDatasetUsed(self):
+        """ """
+        return self._publicDatasetUsed
 
-    @size.setter
-    def size(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._size = value
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "size" of type "list<long>" set to wrong type'
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
+                'wrong type'
             )
 
     @property
-    def status(self):
-        """DatasetStatusEnum: Indicates the current status of a dataset."""
-        return self._status
+    def publisher(self):
+        """str: organization that published the repository"""
+        return self._publisher
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "status" of type "list<DatasetStatusEnum>" set to w'
-                'rong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def token(self):
-        """str: Token to be used with file upload/download operations"""
-        return self._token
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the model"""
+        return self._safetyAndSecurity
 
-    @token.setter
-    def token(self, value):
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._token = value
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "token" of type "list<str>" set to wrong type'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def totalFiles(self):
-        """long: Number of files in this dataset."""
-        return self._totalFiles
+    def shortDescription(self):
+        """str: Short description of the model"""
+        return self._shortDescription
 
-    @totalFiles.setter
-    def totalFiles(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalFiles = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "totalFiles" of type "list<long>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._aceStorageServiceUrl is not None:
-            result["aceStorageServiceUrl"] = \
-                self._aceStorageServiceUrl
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._creatorUserId is not None:
-            result["creatorUserId"] = \
-                self._creatorUserId
-        if self._datasetUuid is not None:
-            result["datasetUuid"] = \
-                self._datasetUuid
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._fileDownloadUrl is not None:
-            result["fileDownloadUrl"] = \
-                self._fileDownloadUrl
-        if self._fileUploadUrl is not None:
-            result["fileUploadUrl"] = \
-                self._fileUploadUrl
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._lastAccessDate is not None:
-            result["lastAccessDate"] = \
-                self._lastAccessDate
-        if self._modifiedDate is not None:
-            result["modifiedDate"] = \
-                self._modifiedDate
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._nfsRoot is not None:
-            result["nfsRoot"] = \
-                self._nfsRoot
-        if self._nfsShare is not None:
-            result["nfsShare"] = \
-                self._nfsShare
-        if self._owned is not None:
-            result["owned"] = \
-                self._owned
-        if self._prepopulated is not None:
-            result["prepopulated"] = \
-                self._prepopulated
-        if self._shared is not None:
-            result["shared"] = \
-                self._shared
-        if self._size is not None:
-            result["size"] = \
-                self._size
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._token is not None:
-            result["token"] = \
-                self._token
-        if self._totalFiles is not None:
-            result["totalFiles"] = \
-                self._totalFiles
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._framework is not None:
+            result["framework"] = \
+                self._framework
+        if self._hasPlayground is not None:
+            result["hasPlayground"] = \
+                self._hasPlayground
+        if self._isPlaygroundEnabled is not None:
+            result["isPlaygroundEnabled"] = \
+                self._isPlaygroundEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceId is None:
+        if (self._ownerName is not None
+            and
+            len(self._ownerName) > 255):
             raise ValueError(
-                "DatasetSimplified.aceId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._aceId is not None
+                "ModelUpdateRequest.ownerName: " + str(self._ownerName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._framework is not None
             and
-            self._aceId < 1):
+            len(self._framework) > 255):
             raise ValueError(
-                "DatasetSimplified.aceId: " + str(self._aceId) + 
-                " doesnt match requirement: minimum: 1")
-        if self._name is None:
+                "ModelUpdateRequest.framework: " + str(self._framework) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._modelFormat is not None
+            and
+            len(self._modelFormat) > 255):
             raise ValueError(
-                "DatasetSimplified.name doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._createdDate is not None
+                "ModelUpdateRequest.modelFormat: " + str(self._modelFormat) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._shortDescription is not None
+            and
+            len(self._shortDescription) > 255):
+            raise ValueError(
+                "ModelUpdateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
+            and
+            len(self._displayName) < 2):
+            raise ValueError(
+                "ModelUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "ModelUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._precision is not None
+            and
+            len(self._precision) > 255):
+            raise ValueError(
+                "ModelUpdateRequest.precision: " + str(self._precision) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._application is not None
+            and
+            len(self._application) > 255):
+            raise ValueError(
+                "ModelUpdateRequest.application: " + str(self._application) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._logo is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._logo) > 255):
             raise ValueError(
-                "DatasetSimplified.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._modifiedDate is not None
+                "ModelUpdateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._builtBy is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._modifiedDate)):
+            len(self._builtBy) > 255):
             raise ValueError(
-                "DatasetSimplified.modifiedDate: " + str(self._modifiedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._lastAccessDate is not None
+                "ModelUpdateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._lastAccessDate)):
+            len(self._publisher) > 255):
             raise ValueError(
-                "DatasetSimplified.lastAccessDate: " + str(self._lastAccessDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "ModelUpdateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
         return True
```

## Comparing `ngccli/data/api/DatasetUpdateRequest.py` & `ngcbpc/data/registry/ImageArchitectureVariant.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,221 +6,260 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DatasetStatusEnum import DatasetStatusEnum
+from .ScanStatus import ScanStatusEnum
+from .SecurityRatingType import SecurityRatingTypeEnum
 
 # Unused import over optimization prevention
-str(repr(DatasetStatusEnum))
+str(repr(ScanStatusEnum))
+str(repr(SecurityRatingTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DatasetUpdateRequest(object):
-    """Dataset update request."""
+class ImageArchitectureVariant(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.convertToDatasetFromResultsetUuid = (
+        self.architecture = (
             None if not fromDict or propDict.get(
-                "convertToDatasetFromResultsetUuid"
+                "architecture"
             ) is None
-            else propDict["convertToDatasetFromResultsetUuid"])
-        self.description = (
+            else propDict["architecture"])
+        self.compressedSize = (
             None if not fromDict or propDict.get(
-                "description"
+                "compressedSize"
             ) is None
-            else propDict["description"])
-        self.name = (
+            else propDict["compressedSize"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "name"
+                "createdDate"
             ) is None
-            else propDict["name"])
-        self.nfsRoot = (
+            else propDict["createdDate"])
+        self.digest = (
             None if not fromDict or propDict.get(
-                "nfsRoot"
+                "digest"
             ) is None
-            else propDict["nfsRoot"])
-        self.nfsShare = (
+            else propDict["digest"])
+        self.os = (
             None if not fromDict or propDict.get(
-                "nfsShare"
+                "os"
             ) is None
-            else propDict["nfsShare"])
-        self.prepopulated = (
+            else propDict["os"])
+        self.rating = (
             None if not fromDict or propDict.get(
-                "prepopulated"
+                "rating"
             ) is None
-            else propDict["prepopulated"])
-        self.status = (
+            else propDict["rating"])
+        self.scanDate = (
             None if not fromDict or propDict.get(
-                "status"
+                "scanDate"
             ) is None
-            else propDict["status"])
+            else propDict["scanDate"])
+        self.scanStatus = (
+            None if not fromDict or propDict.get(
+                "scanStatus"
+            ) is None
+            else propDict["scanStatus"])
+        self.variant = (
+            None if not fromDict or propDict.get(
+                "variant"
+            ) is None
+            else propDict["variant"])
 
     @property
-    def convertToDatasetFromResultsetUuid(self):
-        """str: UUID to convert resultset in dataset service to dataset resour
-        ce type. This is only applicable for dataset service enabled A
-        CEs"""
-        return self._convertToDatasetFromResultsetUuid
+    def architecture(self):
+        """str: The architecture field specifies the CPU architecture, for exa
+        mple amd64 or ppc64le."""
+        return self._architecture
 
-    @convertToDatasetFromResultsetUuid.setter
-    def convertToDatasetFromResultsetUuid(self, value):
+    @architecture.setter
+    def architecture(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._convertToDatasetFromResultsetUuid = value
+            self._architecture = value
+        else:
+            raise TypeError(
+                'Property "architecture" of type "list<str>" set to wrong typ'
+                'e'
+            )
+
+    @property
+    def compressedSize(self):
+        """long: Total size in bytes of all layers of this image in compressed
+         format."""
+        return self._compressedSize
+
+    @compressedSize.setter
+    def compressedSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._compressedSize = value
         else:
             raise TypeError(
-                'Property "convertToDatasetFromResultsetUuid" of type "list<s'
-                'tr>" set to wrong type'
+                'Property "compressedSize" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def description(self):
-        """str: Description of the dataset"""
-        return self._description
+    def createdDate(self):
+        """str: UTC date/time this image variant was created."""
+        return self._createdDate
 
-    @description.setter
-    def description(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name for the dataset"""
-        return self._name
+    def digest(self):
+        """str: The digest of the content, as defined by the Registry V2 HTTP 
+        API Specification."""
+        return self._digest
 
-    @name.setter
-    def name(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._digest = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsRoot(self):
-        """str: Path on the NFS share that indicates root directory for the da
-        taset"""
-        return self._nfsRoot
+    def os(self):
+        """str: The os field specifies the operating system, for example linux
+         or windows."""
+        return self._os
 
-    @nfsRoot.setter
-    def nfsRoot(self, value):
+    @os.setter
+    def os(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nfsRoot = value
+            self._os = value
         else:
             raise TypeError(
-                'Property "nfsRoot" of type "list<str>" set to wrong type'
+                'Property "os" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nfsShare(self):
-        """str: Location of the NFS share"""
-        return self._nfsShare
+    def rating(self):
+        """SecurityRatingTypeEnum: Security Rating Type"""
+        return self._rating
 
-    @nfsShare.setter
-    def nfsShare(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._nfsShare = value
+    @rating.setter
+    def rating(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._rating = value
         else:
             raise TypeError(
-                'Property "nfsShare" of type "list<str>" set to wrong type'
+                'Property "rating" of type "list<SecurityRatingTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def prepopulated(self):
-        """str: Empty means not prepopulated anywhere. Contain e.g. 'prd0' or 
-        'prd0,prd2' or 'all ace', if a roll out is done in stages."""
-        return self._prepopulated
+    def scanDate(self):
+        """str: Scan date in ISO-8601 format (yyyy-MM-dd'T'HH:mm:ss.SSS'Z'). E
+        xample: 2021-08-26T17:29:29.000Z"""
+        return self._scanDate
 
-    @prepopulated.setter
-    def prepopulated(self, value):
+    @scanDate.setter
+    def scanDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._prepopulated = value
+            self._scanDate = value
         else:
             raise TypeError(
-                'Property "prepopulated" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "scanDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """DatasetStatusEnum: Indicates the current status of a dataset."""
-        return self._status
+    def scanStatus(self):
+        """ScanStatusEnum: Image scan statuses"""
+        return self._scanStatus
 
-    @status.setter
-    def status(self, value):
+    @scanStatus.setter
+    def scanStatus(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+            self._scanStatus = value
+        else:
+            raise TypeError(
+                'Property "scanStatus" of type "list<ScanStatusEnum>" set to '
+                'wrong type'
+            )
+
+    @property
+    def variant(self):
+        """str: The optional variant field specifies a variant of the CPU, for
+         example armv6l to specify a particular CPU variant of the ARM
+         CPU."""
+        return self._variant
+
+    @variant.setter
+    def variant(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._variant = value
         else:
             raise TypeError(
-                'Property "status" of type "list<DatasetStatusEnum>" set to w'
-                'rong type'
+                'Property "variant" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._convertToDatasetFromResultsetUuid is not None:
-            result["convertToDatasetFromResultsetUuid"] = \
-                self._convertToDatasetFromResultsetUuid
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._nfsRoot is not None:
-            result["nfsRoot"] = \
-                self._nfsRoot
-        if self._nfsShare is not None:
-            result["nfsShare"] = \
-                self._nfsShare
-        if self._prepopulated is not None:
-            result["prepopulated"] = \
-                self._prepopulated
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._architecture is not None:
+            result["architecture"] = \
+                self._architecture
+        if self._compressedSize is not None:
+            result["compressedSize"] = \
+                self._compressedSize
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._os is not None:
+            result["os"] = \
+                self._os
+        if self._rating is not None:
+            result["rating"] = \
+                self._rating
+        if self._scanDate is not None:
+            result["scanDate"] = \
+                self._scanDate
+        if self._scanStatus is not None:
+            result["scanStatus"] = \
+                self._scanStatus
+        if self._variant is not None:
+            result["variant"] = \
+                self._variant
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) < 2):
-            raise ValueError(
-                "DatasetUpdateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
-            and
-            len(self._name) > 255):
-            raise ValueError(
-                "DatasetUpdateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/DeviceLoginRequest.py` & `ngcbpc/data/model/Dataset.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,103 +14,115 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeviceLoginRequest(object):
-    """Request to Login from Device"""
+class Dataset(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deviceId = (
+        self.license = (
             None if not fromDict or propDict.get(
-                "deviceId"
+                "license"
             ) is None
-            else propDict["deviceId"])
-        self.email = (
+            else propDict["license"])
+        self.link = (
             None if not fromDict or propDict.get(
-                "email"
+                "link"
             ) is None
-            else propDict["email"])
+            else propDict["link"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
 
     @property
-    def deviceId(self):
-        """str: Identifier assigned by the client to the device on which it is
-         running"""
-        return self._deviceId
+    def license(self):
+        """str: License of the dataset"""
+        return self._license
 
-    @deviceId.setter
-    def deviceId(self, value):
+    @license.setter
+    def license(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._deviceId = value
+            self._license = value
         else:
             raise TypeError(
-                'Property "deviceId" of type "list<str>" set to wrong type'
+                'Property "license" of type "list<str>" set to wrong type'
             )
 
     @property
-    def email(self):
-        """str: Email of the user"""
-        return self._email
+    def link(self):
+        """str: Link to the dataset"""
+        return self._link
 
-    @email.setter
-    def email(self, value):
+    @link.setter
+    def link(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._email = value
+            self._link = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "link" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def name(self):
+        """str: Name of the dataset"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deviceId is not None:
-            result["deviceId"] = \
-                self._deviceId
-        if self._email is not None:
-            result["email"] = \
-                self._email
+        if self._license is not None:
+            result["license"] = \
+                self._license
+        if self._link is not None:
+            result["link"] = \
+                self._link
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._deviceId is None:
-            raise ValueError(
-                "DeviceLoginRequest.deviceId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._deviceId is not None
+        if (self._name is not None
             and
-            len(self._deviceId) < 2):
+            len(self._name) > 255):
             raise ValueError(
-                "DeviceLoginRequest.deviceId: " + str(self._deviceId) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._deviceId is not None
+                "Dataset.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._link is not None
             and
-            len(self._deviceId) > 19):
-            raise ValueError(
-                "DeviceLoginRequest.deviceId: " + str(self._deviceId) + 
-                " doesnt match requirement: maxLength: 19")
-        if self._email is None:
+            len(self._link) > 255):
             raise ValueError(
-                "DeviceLoginRequest.email doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._email is not None
+                "Dataset.link: " + str(self._link) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._license is not None
             and
-            len(self._email) > 255):
+            len(self._license) > 255):
             raise ValueError(
-                "DeviceLoginRequest.email: " + str(self._email) + 
+                "Dataset.license: " + str(self._license) + 
                 " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/DeviceLoginResponse.py` & `ngcbpc/data/model/CloneableArtifact.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,120 +14,122 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeviceLoginResponse(object):
-    """Response to the device login"""
+class CloneableArtifact(object):
+    """Cloneable Artifact Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.expiresIn = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "expiresIn"
+                "name"
             ) is None
-            else propDict["expiresIn"])
-        self.loginUrl = (
+            else propDict["name"])
+        self.org = (
             None if not fromDict or propDict.get(
-                "loginUrl"
+                "org"
             ) is None
-            else propDict["loginUrl"])
-        self.sessionKey = (
+            else propDict["org"])
+        self.team = (
             None if not fromDict or propDict.get(
-                "sessionKey"
+                "team"
             ) is None
-            else propDict["sessionKey"])
+            else propDict["team"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def expiresIn(self):
-        """long: Expiration time of the session key in seconds"""
-        return self._expiresIn
-
-    @expiresIn.setter
-    def expiresIn(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._expiresIn = value
+    def name(self):
+        """str: Unique name of the artifact"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "expiresIn" of type "list<long>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def loginUrl(self):
-        """str: Login URL to be opened in any browser"""
-        return self._loginUrl
+    def org(self):
+        """str: Name of the org that the artifact belongs to"""
+        return self._org
 
-    @loginUrl.setter
-    def loginUrl(self, value):
+    @org.setter
+    def org(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._loginUrl = value
+            self._org = value
         else:
             raise TypeError(
-                'Property "loginUrl" of type "list<str>" set to wrong type'
+                'Property "org" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sessionKey(self):
-        """str: Session Key"""
-        return self._sessionKey
+    def team(self):
+        """str: Name of the team that the artifact belongs to"""
+        return self._team
 
-    @sessionKey.setter
-    def sessionKey(self, value):
+    @team.setter
+    def team(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sessionKey = value
+            self._team = value
         else:
             raise TypeError(
-                'Property "sessionKey" of type "list<str>" set to wrong type'
+                'Property "team" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def version(self):
+        """str: ID of the version or tag"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
+        else:
+            raise TypeError(
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._expiresIn is not None:
-            result["expiresIn"] = \
-                self._expiresIn
-        if self._loginUrl is not None:
-            result["loginUrl"] = \
-                self._loginUrl
-        if self._sessionKey is not None:
-            result["sessionKey"] = \
-                self._sessionKey
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._team is not None:
+            result["team"] = \
+                self._team
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._loginUrl is None:
-            raise ValueError(
-                "DeviceLoginResponse.loginUrl doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._loginUrl is not None
-            and
-            len(self._loginUrl) > 1024):
-            raise ValueError(
-                "DeviceLoginResponse.loginUrl: " + str(self._loginUrl) + 
-                " doesnt match requirement: maxLength: 1024")
-        if self._sessionKey is None:
-            raise ValueError(
-                "DeviceLoginResponse.sessionKey doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._sessionKey is not None
-            and
-            len(self._sessionKey) > 255):
-            raise ValueError(
-                "DeviceLoginResponse.sessionKey: " + str(self._sessionKey) + 
-                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/DownloadTokenMetadata.py` & `ngcbpc/data/model/MetaData.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,99 +14,85 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DownloadTokenMetadata(object):
-    """This is the JSON metadata that'll be stored in Redis"""
+class MetaData(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "key"
             ) is None
-            else propDict["orgName"])
-        self.owner = (
+            else propDict["key"])
+        self.value = (
             None if not fromDict or propDict.get(
-                "owner"
+                "value"
             ) is None
-            else propDict["owner"])
-        self.requesterJwt = (
-            None if not fromDict or propDict.get(
-                "requesterJwt"
-            ) is None
-            else propDict["requesterJwt"])
-
-    @property
-    def orgName(self):
-        """str: The owner's org name"""
-        return self._orgName
-
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
-        else:
-            raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
-            )
+            else propDict["value"])
 
     @property
-    def owner(self):
-        """str: The resource owner Auth client id """
-        return self._owner
+    def key(self):
+        """ """
+        return self._key
 
-    @owner.setter
-    def owner(self, value):
+    @key.setter
+    def key(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._owner = value
+            self._key = value
         else:
             raise TypeError(
-                'Property "owner" of type "list<str>" set to wrong type'
+                'Property "key" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requesterJwt(self):
-        """str: JWT of the requester"""
-        return self._requesterJwt
+    def value(self):
+        """ """
+        return self._value
 
-    @requesterJwt.setter
-    def requesterJwt(self, value):
+    @value.setter
+    def value(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requesterJwt = value
+            self._value = value
         else:
             raise TypeError(
-                'Property "requesterJwt" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._owner is not None:
-            result["owner"] = \
-                self._owner
-        if self._requesterJwt is not None:
-            result["requesterJwt"] = \
-                self._requesterJwt
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._key is not None
+            and
+            len(self._key) > 255):
+            raise ValueError(
+                "MetaData.key: " + str(self._key) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._value is not None
+            and
+            len(self._value) > 255):
+            raise ValueError(
+                "MetaData.value: " + str(self._value) + 
+                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/EarlyAccessOrgCreateRequest.py` & `ngcbpc/data/model/CloudServiceProviderCreateRequest.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,60 +6,85 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .OrgOwner import OrgOwner
-from .ProductEnablement import ProductEnablement
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(ProductEnablement))
-str(repr(OrgOwner))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class EarlyAccessOrgCreateRequest(object):
-    """Request to create new Organization"""
+class CloudServiceProviderCreateRequest(object):
+    """Request to create a new Cloud Service Provider"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.attributes = (
+            None if not fromDict or propDict.get(
+                "attributes"
+            ) is None
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
-        self.idpId = (
+        self.isEnabled = (
             None if not fromDict or propDict.get(
-                "idpId"
+                "isEnabled"
             ) is None
-            else propDict["idpId"])
-        self.orgOwner = (
+            else propDict["isEnabled"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "orgOwner"
+                "labels"
             ) is None
-            else propDict["orgOwner"])
-        self.productEnablements = (
+            else propDict["labels"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "productEnablements"
+                "logo"
             ) is None
-            else [ ProductEnablement(i)
-            for i in propDict["productEnablements"] ])
+            else propDict["logo"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
+
+    @property
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
+        else:
+            raise TypeError(
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
+            )
 
     @property
     def description(self):
-        """str: Optional description of the organization."""
+        """str: Description of the Cloud Service Provider"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -67,133 +92,129 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """str: Name of the organization that will be shown to users."""
+        """str: Display name of the Cloud Service Provider"""
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def idpId(self):
-        """str: Identity provider ID."""
-        return self._idpId
+    def isEnabled(self):
+        """bool: Determines if this Cloud Service Provider is enabled"""
+        return self._isEnabled
+
+    @isEnabled.setter
+    def isEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isEnabled = value
+        else:
+            raise TypeError(
+                'Property "isEnabled" of type "list<bool>" set to wrong type'
+            )
 
-    @idpId.setter
-    def idpId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._idpId = value
+    @property
+    def labels(self):
+        """list: Labels that are associated with the Cloud Service Provider"""
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "idpId" of type "list<str>" set to wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgOwner(self):
-        """OrgOwner: Org owner."""
-        return self._orgOwner
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @orgOwner.setter
-    def orgOwner(self, value):
-        if value is not None and not isinstance(value, OrgOwner):
-            value = OrgOwner(value)
-        if (value is None) or isinstance(value, OrgOwner):
-            self._orgOwner = value
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
         else:
             raise TypeError(
-                'Property "orgOwner" of type "list<OrgOwner>" set to wrong ty'
-                'pe'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productEnablements(self):
-        """ """
-        return self._productEnablements
+    def name(self):
+        """str: Unique name of the Cloud Service Provider"""
+        return self._name
 
-    @productEnablements.setter
-    def productEnablements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productEnablements = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "productEnablements" of type "list<ProductEnablemen'
-                't>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._idpId is not None:
-            result["idpId"] = \
-                self._idpId
-        if self._orgOwner:
-            result["orgOwner"] = \
-                self._orgOwner.toDict() if self._orgOwner is not None else None
-        if self._productEnablements:
-            result["productEnablements"] = [
-                i.toDict() for i in self._productEnablements 
-            ] if self._productEnablements else []
+        if self._isEnabled is not None:
+            result["isEnabled"] = \
+                self._isEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._displayName is not None
-            and
-            len(self._displayName) < 1):
-            raise ValueError(
-                "EarlyAccessOrgCreateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 255):
-            raise ValueError(
-                "EarlyAccessOrgCreateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._description is not None
-            and
-            len(self._description) > 128):
-            raise ValueError(
-                "EarlyAccessOrgCreateRequest.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 128")
-        if self._orgOwner is None:
-            raise ValueError(
-                "EarlyAccessOrgCreateRequest.orgOwner doesnt match requirement:" 
-                "required: True"
-            )
-        if self._productEnablements is None:
+        if self._name is None:
             raise ValueError(
-                "EarlyAccessOrgCreateRequest.productEnablements doesnt match requirement:" 
+                "CloudServiceProviderCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._orgOwner is not None): self._orgOwner.isValid()
-        if (self._productEnablements is not None):
-            for obj in self._productEnablements:
+        if (self._attributes is not None):
+            for obj in self._attributes:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/Entitlement.py` & `organization/data/subscription_management_service/ProductEnablement.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,167 +6,159 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .EntitlementProduct import EntitlementProduct
+from .PurchaseOrder import PurchaseOrder
 
 # Unused import over optimization prevention
-str(repr(EntitlementProduct))
+str(repr(PurchaseOrder))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Entitlement(object):
-    """Information about the entitlement for an org"""
+class ProductEnablement(object):
+    """Product Enablement"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.entitlementExpirationTime = (
+        self.expirationDate = (
             None if not fromDict or propDict.get(
-                "entitlementExpirationTime"
+                "expirationDate"
             ) is None
-            else propDict["entitlementExpirationTime"])
-        self.entitlementId = (
+            else propDict["expirationDate"])
+        self.poDetails = (
             None if not fromDict or propDict.get(
-                "entitlementId"
+                "poDetails"
             ) is None
-            else propDict["entitlementId"])
-        self.entitlementState = (
+            else [ PurchaseOrder(i)
+            for i in propDict["poDetails"] ])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "entitlementState"
+                "productName"
             ) is None
-            else propDict["entitlementState"])
-        self.pecSfdcId = (
+            else propDict["productName"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "pecSfdcId"
+                "type"
             ) is None
-            else propDict["pecSfdcId"])
-        self.products = (
-            None if not fromDict or propDict.get(
-                "products"
-            ) is None
-            else [ EntitlementProduct(i)
-            for i in propDict["products"] ])
+            else propDict["type"])
 
     @property
-    def entitlementExpirationTime(self):
-        """str: Entitlement expiration time"""
-        return self._entitlementExpirationTime
+    def expirationDate(self):
+        """str: Date on which the subscription expires. The subscription is in
+        valid after this date. (yyyy-MM-dd)"""
+        return self._expirationDate
 
-    @entitlementExpirationTime.setter
-    def entitlementExpirationTime(self, value):
+    @expirationDate.setter
+    def expirationDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._entitlementExpirationTime = value
+            self._expirationDate = value
         else:
             raise TypeError(
-                'Property "entitlementExpirationTime" of type "list<str>" set'
-                ' to wrong type'
+                'Property "expirationDate" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def entitlementId(self):
-        """str: Unique entitlement identifier"""
-        return self._entitlementId
+    def poDetails(self):
+        """ """
+        return self._poDetails
 
-    @entitlementId.setter
-    def entitlementId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._entitlementId = value
+    @poDetails.setter
+    def poDetails(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._poDetails = value
         else:
             raise TypeError(
-                'Property "entitlementId" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "poDetails" of type "list<PurchaseOrder>" set to wr'
+                'ong type'
             )
 
     @property
-    def entitlementState(self):
-        """str: Entitlement state"""
-        return self._entitlementState
+    def productName(self):
+        """str: Product Name (NVAIE, BASE_COMMAND, REGISTRY, etc)"""
+        return self._productName
 
-    @entitlementState.setter
-    def entitlementState(self, value):
+    @productName.setter
+    def productName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._entitlementState = value
+            self._productName = value
         else:
             raise TypeError(
-                'Property "entitlementState" of type "list<str>" set to wrong'
-                ' type'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def pecSfdcId(self):
-        """str: Product end customer salesforce.com Id (external customer Id).
-         pecSfdcId is for EMS (entitlement management service) to trac
-        k external paid customer"""
-        return self._pecSfdcId
+    def type(self):
+        """str: Product Enablement Types (NGC_ADMIN_EVAL, EMS_EVAL, EMS_NFR, e
+        tc)."""
+        return self._type
 
-    @pecSfdcId.setter
-    def pecSfdcId(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._pecSfdcId = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "pecSfdcId" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def products(self):
-        """ """
-        return self._products
-
-    @products.setter
-    def products(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._products = value
-        else:
-            raise TypeError(
-                'Property "products" of type "list<EntitlementProduct>" set t'
-                'o wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._entitlementExpirationTime is not None:
-            result["entitlementExpirationTime"] = \
-                self._entitlementExpirationTime
-        if self._entitlementId is not None:
-            result["entitlementId"] = \
-                self._entitlementId
-        if self._entitlementState is not None:
-            result["entitlementState"] = \
-                self._entitlementState
-        if self._pecSfdcId is not None:
-            result["pecSfdcId"] = \
-                self._pecSfdcId
-        if self._products:
-            result["products"] = [
-                i.toDict() for i in self._products 
-            ] if self._products else []
+        if self._expirationDate is not None:
+            result["expirationDate"] = \
+                self._expirationDate
+        if self._poDetails:
+            result["poDetails"] = [
+                i.toDict() for i in self._poDetails 
+            ] if self._poDetails else []
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._products is not None):
-            for obj in self._products:
+        if self._type is None:
+            raise ValueError(
+                "ProductEnablement.type doesnt match requirement:" 
+                "required: True"
+            )
+        if self._productName is None:
+            raise ValueError(
+                "ProductEnablement.productName doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._expirationDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\d",
+                 self._expirationDate)):
+            raise ValueError(
+                "ProductEnablement.expirationDate: " + str(self._expirationDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\d")
+        if (self._poDetails is not None):
+            for obj in self._poDetails:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/EntitlementProduct.py` & `basecommand/data/pym/ProjectModifyParams.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,99 +14,86 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class EntitlementProduct(object):
-    """Information about the entitlement product"""
+class ProjectModifyParams(object):
+    """Project modification params"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.pkId = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "pkId"
+                "description"
             ) is None
-            else propDict["pkId"])
-        self.productName = (
+            else propDict["description"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "productName"
+                "name"
             ) is None
-            else propDict["productName"])
-        self.subscriptionType = (
-            None if not fromDict or propDict.get(
-                "subscriptionType"
-            ) is None
-            else propDict["subscriptionType"])
-
-    @property
-    def pkId(self):
-        """str: Unique product key identifier"""
-        return self._pkId
-
-    @pkId.setter
-    def pkId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._pkId = value
-        else:
-            raise TypeError(
-                'Property "pkId" of type "list<str>" set to wrong type'
-            )
+            else propDict["name"])
 
     @property
-    def productName(self):
-        """str: Product name. ex: FleetCommand, Batch, etc"""
-        return self._productName
+    def description(self):
+        """str: Project description"""
+        return self._description
 
-    @productName.setter
-    def productName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._productName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "productName" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def subscriptionType(self):
-        """str: Subscription type"""
-        return self._subscriptionType
+    def name(self):
+        """str: Project name"""
+        return self._name
 
-    @subscriptionType.setter
-    def subscriptionType(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._subscriptionType = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "subscriptionType" of type "list<str>" set to wrong'
-                ' type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._pkId is not None:
-            result["pkId"] = \
-                self._pkId
-        if self._productName is not None:
-            result["productName"] = \
-                self._productName
-        if self._subscriptionType is not None:
-            result["subscriptionType"] = \
-                self._subscriptionType
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "ProjectModifyParams.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._description is not None
+            and
+            len(self._description) < 1):
+            raise ValueError(
+                "ProjectModifyParams.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/api/Env.py` & `basecommand/data/pym/AdditionalOpenPortURLs.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,90 +14,96 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Env(object):
-    """Environment variable"""
+class AdditionalOpenPortURLs(object):
+    """Open port URLS"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.port = (
             None if not fromDict or propDict.get(
-                "name"
+                "port"
             ) is None
-            else propDict["name"])
-        self.value = (
+            else propDict["port"])
+        self.url = (
             None if not fromDict or propDict.get(
-                "value"
+                "url"
             ) is None
-            else propDict["value"])
+            else propDict["url"])
 
     @property
-    def name(self):
-        """str: Environment variable name"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def port(self):
+        """int: Open port"""
+        return self._port
+
+    @port.setter
+    def port(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._port = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "port" of type "list<int>" set to wrong type'
             )
 
     @property
-    def value(self):
-        """str: Environment variable value"""
-        return self._value
+    def url(self):
+        """str: Open port URL"""
+        return self._url
 
-    @value.setter
-    def value(self, value):
+    @url.setter
+    def url(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._value = value
+            self._url = value
         else:
             raise TypeError(
-                'Property "value" of type "list<str>" set to wrong type'
+                'Property "url" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._value is not None:
-            result["value"] = \
-                self._value
+        if self._port is not None:
+            result["port"] = \
+                self._port
+        if self._url is not None:
+            result["url"] = \
+                self._url
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._port is None:
             raise ValueError(
-                "Env.name doesnt match requirement:" 
+                "AdditionalOpenPortURLs.port doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
+        if (self._port is not None
+            and
+            self._port < 1):
+            raise ValueError(
+                "AdditionalOpenPortURLs.port: " + str(self._port) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._port is not None
             and
-            len(self._name) < 1):
+            self._port > 65535):
             raise ValueError(
-                "Env.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if self._value is None:
+                "AdditionalOpenPortURLs.port: " + str(self._port) + 
+                " doesnt match requirement: maximum: 65535")
+        if self._url is None:
             raise ValueError(
-                "Env.value doesnt match requirement:" 
+                "AdditionalOpenPortURLs.url doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/ErrorResponse.py` & `organization/data/subscription_management_service/ErrorResponse.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/Eula.py` & `ngcbpc/data/model/DeploymentGpuParameters.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,86 +14,74 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Eula(object):
+class DeploymentGpuParameters(object):
+    """Deployment GPU Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.details = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "details"
+                "count"
             ) is None
-            else propDict["details"])
+            else propDict["count"])
         self.type = (
             None if not fromDict or propDict.get(
                 "type"
             ) is None
             else propDict["type"])
 
     @property
-    def details(self):
-        """str: Full EULA  including file name, content, and name/type"""
-        return self._details
-
-    @details.setter
-    def details(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._details = value
+    def count(self):
+        """long: Total count of GPUs"""
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._count = value
         else:
             raise TypeError(
-                'Property "details" of type "list<str>" set to wrong type'
+                'Property "count" of type "list<long>" set to wrong type'
             )
 
     @property
     def type(self):
-        """TypeEnum: End User License Agreement supported types"""
+        """str: GPU Type"""
         return self._type
 
     @type.setter
     def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
             self._type = value
         else:
             raise TypeError(
-                'Property "type" of type "list<TypeEnum>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
-    TypeEnum=["UNKNOWN","CUSTOMER_EULA","APPLIANCE_EULA",]
-    str(repr(TypeEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._details is not None:
-            result["details"] = \
-                self._details
+        if self._count is not None:
+            result["count"] = \
+                self._count
         if self._type is not None:
             result["type"] = \
                 self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._details is not None
-            and
-            len(self._details) < 1):
-            raise ValueError(
-                "Eula.details: " + str(self._details) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._details is not None
-            and
-            len(self._details) > 128000):
-            raise ValueError(
-                "Eula.details: " + str(self._details) + 
-                " doesnt match requirement: maxLength: 128000")
         return True
```

## Comparing `ngccli/data/api/EulaSubmitResponse.py` & `ngcbpc/data/uis/TeamResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,55 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Eula import Eula
+from .Team import Team
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Eula))
 str(repr(RequestStatus))
+str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class EulaSubmitResponse(object):
+class TeamResponse(object):
+    """details about one team"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.eula = (
-            None if not fromDict or propDict.get(
-                "eula"
-            ) is None
-            else propDict["eula"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def eula(self):
-        """ """
-        return self._eula
-
-    @eula.setter
-    def eula(self, value):
-        if value is not None and not isinstance(value, Eula):
-            value = Eula(value)
-        if (value is None) or isinstance(value, Eula):
-            self._eula = value
-        else:
-            raise TypeError(
-                'Property "eula" of type "list<Eula>" set to wrong type'
-            )
+        self.team = (
+            None if not fromDict or propDict.get(
+                "team"
+            ) is None
+            else propDict["team"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -65,29 +50,45 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def team(self):
+        """Team: Information about the team"""
+        return self._team
+
+    @team.setter
+    def team(self, value):
+        if value is not None and not isinstance(value, Team):
+            value = Team(value)
+        if (value is None) or isinstance(value, Team):
+            self._team = value
+        else:
+            raise TypeError(
+                'Property "team" of type "list<Team>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._eula:
-            result["eula"] = \
-                self._eula.toDict() if self._eula is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._team:
+            result["team"] = \
+                self._team.toDict() if self._team is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._eula is not None): self._eula.isValid()
+        if (self._team is not None): self._team.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/ExpTrackingParams.py` & `organization/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,120 +6,130 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobFlowTypeEnum import JobFlowTypeEnum
 
 # Unused import over optimization prevention
-str(repr(JobFlowTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ExpTrackingParams(object):
-    """ML experimentation tracking params associated to the job, when the job 
-    is submitted for a third-party ML experimentation tracking system like
-     Weights&Biases, MLFlow, etc"""
+class AzureMarketplaceSubscriptionUser(object):
+    """Subscription User Object in AzureMarketplace-webhook-event"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.emailId = (
             None if not fromDict or propDict.get(
-                "name"
+                "emailId"
             ) is None
-            else propDict["name"])
-        self.projectName = (
+            else propDict["emailId"])
+        self.objectId = (
             None if not fromDict or propDict.get(
-                "projectName"
+                "objectId"
             ) is None
-            else propDict["projectName"])
-        self.type = (
+            else propDict["objectId"])
+        self.puid = (
             None if not fromDict or propDict.get(
-                "type"
+                "puid"
             ) is None
-            else propDict["type"])
+            else propDict["puid"])
+        self.tenantId = (
+            None if not fromDict or propDict.get(
+                "tenantId"
+            ) is None
+            else propDict["tenantId"])
 
     @property
-    def name(self):
-        """str: Optional Third-party experiment name to group the jobs/runs"""
-        return self._name
+    def emailId(self):
+        """str: email address of the user"""
+        return self._emailId
 
-    @name.setter
-    def name(self, value):
+    @emailId.setter
+    def emailId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._emailId = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "emailId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def projectName(self):
-        """str: Third-party project/environment name to associate the current 
-        job/run"""
-        return self._projectName
+    def objectId(self):
+        """str: object id of the user"""
+        return self._objectId
 
-    @projectName.setter
-    def projectName(self, value):
+    @objectId.setter
+    def objectId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._projectName = value
+            self._objectId = value
         else:
             raise TypeError(
-                'Property "projectName" of type "list<str>" set to wrong type'
+                'Property "objectId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """JobFlowTypeEnum: Type of ML experiment flow"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    def puid(self):
+        """str: id of the user"""
+        return self._puid
+
+    @puid.setter
+    def puid(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._puid = value
         else:
             raise TypeError(
-                'Property "type" of type "list<JobFlowTypeEnum>" set to wrong'
-                ' type'
+                'Property "puid" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def tenantId(self):
+        """str: tenant id of the user"""
+        return self._tenantId
+
+    @tenantId.setter
+    def tenantId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._tenantId = value
+        else:
+            raise TypeError(
+                'Property "tenantId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._projectName is not None:
-            result["projectName"] = \
-                self._projectName
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._emailId is not None:
+            result["emailId"] = \
+                self._emailId
+        if self._objectId is not None:
+            result["objectId"] = \
+                self._objectId
+        if self._puid is not None:
+            result["puid"] = \
+                self._puid
+        if self._tenantId is not None:
+            result["tenantId"] = \
+                self._tenantId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._projectName is None:
-            raise ValueError(
-                "ExpTrackingParams.projectName doesnt match requirement:" 
-                "required: True"
-            )
-        if self._type is None:
-            raise ValueError(
-                "ExpTrackingParams.type doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/FcOnboardingEventRequest.py` & `ngcbpc/data/registry/Actor.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,54 +14,50 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class FcOnboardingEventRequest(object):
+class Actor(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "name"
             ) is None
-            else propDict["orgName"])
+            else propDict["name"])
 
     @property
-    def orgName(self):
-        """str: Name of org for Fleet Command backend stack"""
-        return self._orgName
+    def name(self):
+        """str: Name corresponds to the subject or username associated with th
+        e request context that generated the event."""
+        return self._name
 
-    @orgName.setter
-    def orgName(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._orgName is None:
-            raise ValueError(
-                "FcOnboardingEventRequest.orgName doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/GetRepositoryTagVexResponse.py` & `ngcbpc/data/model/RecipeVersionResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,118 +6,117 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RepositoryTagVexByDigest import RepositoryTagVexByDigest
 from .RequestStatus import RequestStatus
+from .RecipeVersion import RecipeVersion
+from .Recipe import Recipe
 
 # Unused import over optimization prevention
+str(repr(Recipe))
+str(repr(RecipeVersion))
 str(repr(RequestStatus))
-str(repr(RepositoryTagVexByDigest))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GetRepositoryTagVexResponse(object):
-    """Get VEX for repository tag response"""
+class RecipeVersionResponse(object):
+    """Response to recipe version request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.requestStatus = (
+        self.recipe = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "recipe"
             ) is None
-            else propDict["requestStatus"])
-        self.tag = (
+            else propDict["recipe"])
+        self.recipeVersion = (
             None if not fromDict or propDict.get(
-                "tag"
+                "recipeVersion"
             ) is None
-            else propDict["tag"])
-        self.vexes = (
+            else propDict["recipeVersion"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "vexes"
+                "requestStatus"
             ) is None
-            else [ RepositoryTagVexByDigest(i)
-            for i in propDict["vexes"] ])
+            else propDict["requestStatus"])
+
+    @property
+    def recipe(self):
+        """Recipe: Recipe object"""
+        return self._recipe
+
+    @recipe.setter
+    def recipe(self, value):
+        if value is not None and not isinstance(value, Recipe):
+            value = Recipe(value)
+        if (value is None) or isinstance(value, Recipe):
+            self._recipe = value
+        else:
+            raise TypeError(
+                'Property "recipe" of type "list<Recipe>" set to wrong type'
+            )
+
+    @property
+    def recipeVersion(self):
+        """RecipeVersion: Recipe version object"""
+        return self._recipeVersion
+
+    @recipeVersion.setter
+    def recipeVersion(self, value):
+        if value is not None and not isinstance(value, RecipeVersion):
+            value = RecipeVersion(value)
+        if (value is None) or isinstance(value, RecipeVersion):
+            self._recipeVersion = value
+        else:
+            raise TypeError(
+                'Property "recipeVersion" of type "list<RecipeVersion>" set t'
+                'o wrong type'
+            )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def tag(self):
-        """str: Image tag detail"""
-        return self._tag
-
-    @tag.setter
-    def tag(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tag = value
-        else:
-            raise TypeError(
-                'Property "tag" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def vexes(self):
-        """ """
-        return self._vexes
-
-    @vexes.setter
-    def vexes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._vexes = value
-        else:
-            raise TypeError(
-                'Property "vexes" of type "list<RepositoryTagVexByDigest>" se'
-                't to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._recipe:
+            result["recipe"] = \
+                self._recipe.toDict() if self._recipe is not None else None
+        if self._recipeVersion:
+            result["recipeVersion"] = \
+                self._recipeVersion.toDict() if self._recipeVersion is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._tag is not None:
-            result["tag"] = \
-                self._tag
-        if self._vexes:
-            result["vexes"] = [
-                i.toDict() for i in self._vexes 
-            ] if self._vexes else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._vexes is not None):
-            for obj in self._vexes:
-                if (obj is not None): obj.isValid()
+        if (self._recipe is not None): self._recipe.isValid()
+        if (self._recipeVersion is not None): self._recipeVersion.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/Health.py` & `ngcbpc/data/model/Health.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/HealthResponse.py` & `organization/data/subscription_management_service/HealthResponse.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/HttpGet.py` & `basecommand/data/pym/ProjectModifyRequest.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,82 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectModifyParams import ProjectModifyParams
 
 # Unused import over optimization prevention
+str(repr(ProjectModifyParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class HttpGet(object):
-    """Health check using HTTP Get request"""
+class ProjectModifyRequest(object):
+    """Project Modify Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.path = (
+        self.params = (
             None if not fromDict or propDict.get(
-                "path"
+                "params"
             ) is None
-            else propDict["path"])
-        self.port = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "port"
+                "version"
             ) is None
-            else propDict["port"])
+            else propDict["version"])
 
     @property
-    def path(self):
-        """str: Path to access on the HTTP server."""
-        return self._path
-
-    @path.setter
-    def path(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._path = value
+    def params(self):
+        """ProjectModifyParams: Project modification params"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectModifyParams):
+            value = ProjectModifyParams(value)
+        if (value is None) or isinstance(value, ProjectModifyParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
+                'Property "params" of type "list<ProjectModifyParams>" set to'
+                ' wrong type'
             )
 
     @property
-    def port(self):
-        """int: Number of the port to access on the container."""
-        return self._port
-
-    @port.setter
-    def port(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._port = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "port" of type "list<int>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._path is not None:
-            result["path"] = \
-                self._path
-        if self._port is not None:
-            result["port"] = \
-                self._port
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "ProjectModifyRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
+            raise ValueError(
+                "ProjectModifyRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/api/IPAddress.py` & `ngcbpc/data/registry/ScanIssueCount.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,75 +6,82 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ScanIssueSeverity import ScanIssueSeverityEnum
 
 # Unused import over optimization prevention
+str(repr(ScanIssueSeverityEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class IPAddress(object):
-    """Generic IP address"""
+class ScanIssueCount(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ip = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "ip"
+                "count"
             ) is None
-            else propDict["ip"])
+            else propDict["count"])
+        self.severity = (
+            None if not fromDict or propDict.get(
+                "severity"
+            ) is None
+            else propDict["severity"])
+
+    @property
+    def count(self):
+        """long: Count of vulnerabilities with severity status"""
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._count = value
+        else:
+            raise TypeError(
+                'Property "count" of type "list<long>" set to wrong type'
+            )
 
     @property
-    def ip(self):
-        """ """
-        return self._ip
-
-    @ip.setter
-    def ip(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._ip = value
+    def severity(self):
+        """ScanIssueSeverityEnum: Image scan issue severity"""
+        return self._severity
+
+    @severity.setter
+    def severity(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._severity = value
         else:
             raise TypeError(
-                'Property "ip" of type "list<str>" set to wrong type'
+                'Property "severity" of type "list<ScanIssueSeverityEnum>" se'
+                't to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._ip is not None:
-            result["ip"] = \
-                self._ip
+        if self._count is not None:
+            result["count"] = \
+                self._count
+        if self._severity is not None:
+            result["severity"] = \
+                self._severity
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._ip is None:
-            raise ValueError(
-                "IPAddress.ip doesnt match requirement:" 
-                "required: true"
-            )
-        if (self._ip is not None
-            and
-            not re.match(
-                r"^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0"
-                "-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5"
-                "])$",
-                 self._ip)):
-            raise ValueError(
-                "IPAddress.ip: " + str(self._ip) + 
-                " doesnt match requirement: pattern: ^(([0-9]|[1-9][0-9]|1[0-"
-                "9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9"
-                "][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
         return True
```

## Comparing `ngccli/data/api/InfinityManagerSettings.py` & `ngcbpc/data/model/CountableResource.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,73 +14,95 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class InfinityManagerSettings(object):
-    """Infinity manager setting definition"""
+class CountableResource(object):
+    """Countable Resource object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.infinityManagerEnableTeamOverride = (
+        self.defaultValue = (
             None if not fromDict or propDict.get(
-                "infinityManagerEnableTeamOverride"
+                "defaultValue"
             ) is None
-            else propDict["infinityManagerEnableTeamOverride"])
-        self.infinityManagerEnabled = (
+            else propDict["defaultValue"])
+        self.maxValue = (
             None if not fromDict or propDict.get(
-                "infinityManagerEnabled"
+                "maxValue"
             ) is None
-            else propDict["infinityManagerEnabled"])
+            else propDict["maxValue"])
+        self.minValue = (
+            None if not fromDict or propDict.get(
+                "minValue"
+            ) is None
+            else propDict["minValue"])
+
+    @property
+    def defaultValue(self):
+        """long: Deprecated: Default value. Please use actual CloudServiceProv
+        ider values instead"""
+        return self._defaultValue
+
+    @defaultValue.setter
+    def defaultValue(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._defaultValue = value
+        else:
+            raise TypeError(
+                'Property "defaultValue" of type "list<long>" set to wrong ty'
+                'pe'
+            )
 
     @property
-    def infinityManagerEnableTeamOverride(self):
-        """bool: Allow override settings at team level. Only used in org level
-         object"""
-        return self._infinityManagerEnableTeamOverride
-
-    @infinityManagerEnableTeamOverride.setter
-    def infinityManagerEnableTeamOverride(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._infinityManagerEnableTeamOverride = value
+    def maxValue(self):
+        """long: Maximum value"""
+        return self._maxValue
+
+    @maxValue.setter
+    def maxValue(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._maxValue = value
         else:
             raise TypeError(
-                'Property "infinityManagerEnableTeamOverride" of type "list<b'
-                'ool>" set to wrong type'
+                'Property "maxValue" of type "list<long>" set to wrong type'
             )
 
     @property
-    def infinityManagerEnabled(self):
-        """bool: Enable the infinity manager or not. Used both in org and team
-         level object"""
-        return self._infinityManagerEnabled
-
-    @infinityManagerEnabled.setter
-    def infinityManagerEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._infinityManagerEnabled = value
+    def minValue(self):
+        """long: Minimum value"""
+        return self._minValue
+
+    @minValue.setter
+    def minValue(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._minValue = value
         else:
             raise TypeError(
-                'Property "infinityManagerEnabled" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "minValue" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._infinityManagerEnableTeamOverride is not None:
-            result["infinityManagerEnableTeamOverride"] = \
-                self._infinityManagerEnableTeamOverride
-        if self._infinityManagerEnabled is not None:
-            result["infinityManagerEnabled"] = \
-                self._infinityManagerEnabled
+        if self._defaultValue is not None:
+            result["defaultValue"] = \
+                self._defaultValue
+        if self._maxValue is not None:
+            result["maxValue"] = \
+                self._maxValue
+        if self._minValue is not None:
+            result["minValue"] = \
+                self._minValue
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/Job.py` & `ngcbpc/data/model/Model.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,895 +6,888 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageResource import StorageResource
-from .AceProvider import AceProviderEnum
-from .JobLabels import JobLabels
-from .JobPriorityEnum import JobPriorityEnum
-from .JobStatus import JobStatus
-from .JobDefinition import JobDefinition
-from .MeasurementSeries import MeasurementSeries
+from .AccessTypeEnum import AccessTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
+from .Dataset import Dataset
 
 # Unused import over optimization prevention
-str(repr(JobDefinition))
-str(repr(AceProviderEnum))
-str(repr(MeasurementSeries))
-str(repr(JobPriorityEnum))
-str(repr(JobStatus))
-str(repr(StorageResource))
-str(repr(JobLabels))
+str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Job(object):
-    """object that describes submitted job"""
+class Model(object):
+    """Model object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "accessType"
             ) is None
-            else propDict["aceId"])
-        self.aceName = (
+            else propDict["accessType"])
+        self.application = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "application"
             ) is None
-            else propDict["aceName"])
-        self.aceProvider = (
+            else propDict["application"])
+        self.bias = (
             None if not fromDict or propDict.get(
-                "aceProvider"
+                "bias"
             ) is None
-            else propDict["aceProvider"])
-        self.aceResourceInstance = (
+            else propDict["bias"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "aceResourceInstance"
+                "builtBy"
             ) is None
-            else propDict["aceResourceInstance"])
-        self.baseImageName = (
+            else propDict["builtBy"])
+        self.canGuestDownload = (
             None if not fromDict or propDict.get(
-                "baseImageName"
+                "canGuestDownload"
             ) is None
-            else propDict["baseImageName"])
+            else propDict["canGuestDownload"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.datasets = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "datasets"
+                "description"
             ) is None
-            else [ StorageResource(i)
-            for i in propDict["datasets"] ])
-        self.expTrackingURL = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "expTrackingURL"
+                "displayName"
             ) is None
-            else propDict["expTrackingURL"])
-        self.gpuActiveTime = (
+            else propDict["displayName"])
+        self.explainability = (
             None if not fromDict or propDict.get(
-                "gpuActiveTime"
+                "explainability"
             ) is None
-            else propDict["gpuActiveTime"])
-        self.gpuUtilization = (
+            else propDict["explainability"])
+        self.framework = (
             None if not fromDict or propDict.get(
-                "gpuUtilization"
+                "framework"
             ) is None
-            else propDict["gpuUtilization"])
-        self.id = (
+            else propDict["framework"])
+        self.hasPlayground = (
             None if not fromDict or propDict.get(
-                "id"
+                "hasPlayground"
             ) is None
-            else propDict["id"])
-        self.jobDefinition = (
+            else propDict["hasPlayground"])
+        self.isFavourite = (
             None if not fromDict or propDict.get(
-                "jobDefinition"
+                "isFavourite"
             ) is None
-            else propDict["jobDefinition"])
-        self.jobOrder = (
+            else propDict["isFavourite"])
+        self.isPlaygroundEnabled = (
             None if not fromDict or propDict.get(
-                "jobOrder"
+                "isPlaygroundEnabled"
             ) is None
-            else propDict["jobOrder"])
-        self.jobPriority = (
+            else propDict["isPlaygroundEnabled"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "jobPriority"
+                "isPublic"
             ) is None
-            else propDict["jobPriority"])
-        self.jobStatus = (
+            else propDict["isPublic"])
+        self.isReadOnly = (
             None if not fromDict or propDict.get(
-                "jobStatus"
+                "isReadOnly"
             ) is None
-            else propDict["jobStatus"])
+            else propDict["isReadOnly"])
         self.labels = (
             None if not fromDict or propDict.get(
                 "labels"
             ) is None
             else propDict["labels"])
-        self.lastStatusUpdatedDate = (
+        self.latestVersionGpuModel = (
             None if not fromDict or propDict.get(
-                "lastStatusUpdatedDate"
+                "latestVersionGpuModel"
             ) is None
-            else propDict["lastStatusUpdatedDate"])
-        self.orgName = (
+            else propDict["latestVersionGpuModel"])
+        self.latestVersionId = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "latestVersionId"
             ) is None
-            else propDict["orgName"])
-        self.preemptionRequestedByUser = (
+            else propDict["latestVersionId"])
+        self.latestVersionIdStr = (
             None if not fromDict or propDict.get(
-                "preemptionRequestedByUser"
+                "latestVersionIdStr"
             ) is None
-            else propDict["preemptionRequestedByUser"])
-        self.preemptionRequestedDate = (
+            else propDict["latestVersionIdStr"])
+        self.latestVersionSizeInBytes = (
             None if not fromDict or propDict.get(
-                "preemptionRequestedDate"
+                "latestVersionSizeInBytes"
             ) is None
-            else propDict["preemptionRequestedDate"])
-        self.resultset = (
+            else propDict["latestVersionSizeInBytes"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "resultset"
+                "logo"
             ) is None
-            else propDict["resultset"])
-        self.resumeRequestedByUser = (
+            else propDict["logo"])
+        self.modelFormat = (
             None if not fromDict or propDict.get(
-                "resumeRequestedByUser"
+                "modelFormat"
             ) is None
-            else propDict["resumeRequestedByUser"])
-        self.resumeRequestedDate = (
+            else propDict["modelFormat"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "resumeRequestedDate"
+                "name"
             ) is None
-            else propDict["resumeRequestedDate"])
-        self.sparklines = (
+            else propDict["name"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "sparklines"
+                "orgName"
             ) is None
-            else [ MeasurementSeries(i)
-            for i in propDict["sparklines"] ])
-        self.submittedByUser = (
+            else propDict["orgName"])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "submittedByUser"
+                "ownerName"
             ) is None
-            else propDict["submittedByUser"])
-        self.submittedByUserId = (
+            else propDict["ownerName"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "submittedByUserId"
+                "precision"
             ) is None
-            else propDict["submittedByUserId"])
-        self.teamName = (
+            else propDict["precision"])
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "teamName"
+                "privacy"
             ) is None
-            else propDict["teamName"])
-        self.tensorCoreActive = (
+            else propDict["privacy"])
+        self.productNames = (
             None if not fromDict or propDict.get(
-                "tensorCoreActive"
+                "productNames"
             ) is None
-            else propDict["tensorCoreActive"])
-        self.tensorCoreActiveWhileGpuActive = (
+            else propDict["productNames"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "tensorCoreActiveWhileGpuActive"
+                "publicDatasetUsed"
             ) is None
-            else propDict["tensorCoreActiveWhileGpuActive"])
-        self.terminationReason = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "terminationReason"
+                "publisher"
             ) is None
-            else propDict["terminationReason"])
-        self.terminationRequestedByUser = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "terminationRequestedByUser"
+                "safetyAndSecurity"
             ) is None
-            else propDict["terminationRequestedByUser"])
-        self.terminationRequestedByUserName = (
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "terminationRequestedByUserName"
+                "shortDescription"
             ) is None
-            else propDict["terminationRequestedByUserName"])
-        self.terminationRequestedDate = (
+            else propDict["shortDescription"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "terminationRequestedDate"
+                "teamName"
             ) is None
-            else propDict["terminationRequestedDate"])
-        self.workspaces = (
+            else propDict["teamName"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
+        self.versions = (
             None if not fromDict or propDict.get(
-                "workspaces"
+                "versions"
             ) is None
-            else [ StorageResource(i)
-            for i in propDict["workspaces"] ])
+            else propDict["versions"])
 
     @property
-    def aceId(self):
-        """long: id of ACE that the job belongs to"""
-        return self._aceId
+    def accessType(self):
+        """ """
+        return self._accessType
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def aceName(self):
-        """str: name of ACE that the job belongs to"""
-        return self._aceName
+    def application(self):
+        """str: Application of the model"""
+        return self._application
 
-    @aceName.setter
-    def aceName(self, value):
+    @application.setter
+    def application(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._application = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "application" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceProvider(self):
-        """ """
-        return self._aceProvider
+    def bias(self):
+        """str: Text describing bias in the model"""
+        return self._bias
 
-    @aceProvider.setter
-    def aceProvider(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._aceProvider = value
+    @bias.setter
+    def bias(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._bias = value
         else:
             raise TypeError(
-                'Property "aceProvider" of type "list<AceProviderEnum>" set t'
-                'o wrong type'
+                'Property "bias" of type "list<str>" set to wrong type'
             )
 
     @property
-    def aceResourceInstance(self):
-        """str: Name of instance of ace resources that the job used"""
-        return self._aceResourceInstance
+    def builtBy(self):
+        """str: organization that built the repository"""
+        return self._builtBy
 
-    @aceResourceInstance.setter
-    def aceResourceInstance(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceResourceInstance = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "aceResourceInstance" of type "list<str>" set to wr'
-                'ong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def baseImageName(self):
-        """str: The base image name of this image"""
-        return self._baseImageName
+    def canGuestDownload(self):
+        """bool: Indicates if a guest user can download"""
+        return self._canGuestDownload
 
-    @baseImageName.setter
-    def baseImageName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._baseImageName = value
+    @canGuestDownload.setter
+    def canGuestDownload(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestDownload = value
         else:
             raise TypeError(
-                'Property "baseImageName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "canGuestDownload" of type "list<bool>" set to wron'
+                'g type'
             )
 
     @property
     def createdDate(self):
-        """str: Created date for this job"""
+        """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._createdDate = value
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def datasets(self):
-        """list: List of datasets used for this job"""
-        return self._datasets
+    def description(self):
+        """str: Description of the model"""
+        return self._description
 
-    @datasets.setter
-    def datasets(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._datasets = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "datasets" of type "list<StorageResource>" set to w'
-                'rong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def expTrackingURL(self):
-        """str: URL to navigate to third-party ML experimentation tracking sys
-        tem like Weights&Biases, MLFlow, etc"""
-        return self._expTrackingURL
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @expTrackingURL.setter
-    def expTrackingURL(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._expTrackingURL = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "expTrackingURL" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpuActiveTime(self):
-        """float: Total active time, in %, of GPU for the lifetime of the job
-        """
-        return self._gpuActiveTime
+    def explainability(self):
+        """str: Text describing explainability for this model"""
+        return self._explainability
 
-    @gpuActiveTime.setter
-    def gpuActiveTime(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._gpuActiveTime = value
+    @explainability.setter
+    def explainability(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._explainability = value
         else:
             raise TypeError(
-                'Property "gpuActiveTime" of type "list<float>" set to wrong '
-                'type'
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def gpuUtilization(self):
-        """float: Total utilization of GPU for the lifetime of the job (gpu ac
-        tive)"""
-        return self._gpuUtilization
+    def framework(self):
+        """str: Framework used to train this model"""
+        return self._framework
 
-    @gpuUtilization.setter
-    def gpuUtilization(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._gpuUtilization = value
+    @framework.setter
+    def framework(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._framework = value
         else:
             raise TypeError(
-                'Property "gpuUtilization" of type "list<float>" set to wrong'
-                ' type'
+                'Property "framework" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: the id of the job"""
-        return self._id
+    def hasPlayground(self):
+        """bool: indicate if the Model has AI Playground configured"""
+        return self._hasPlayground
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @hasPlayground.setter
+    def hasPlayground(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._hasPlayground = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "hasPlayground" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def jobDefinition(self):
-        """JobDefinition: This object is populated when job request is submitt
-        ed by the user"""
-        return self._jobDefinition
-
-    @jobDefinition.setter
-    def jobDefinition(self, value):
-        if value is not None and not isinstance(value, JobDefinition):
-            value = JobDefinition(value)
-        if (value is None) or isinstance(value, JobDefinition):
-            self._jobDefinition = value
+    def isFavourite(self):
+        """bool: Flag indicating if model is user's favorite"""
+        return self._isFavourite
+
+    @isFavourite.setter
+    def isFavourite(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isFavourite = value
         else:
             raise TypeError(
-                'Property "jobDefinition" of type "list<JobDefinition>" set t'
-                'o wrong type'
+                'Property "isFavourite" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def jobOrder(self):
-        """int: The order of job. Job order is from 1 to 99. Default value is 
-        50"""
-        return self._jobOrder
-
-    @jobOrder.setter
-    def jobOrder(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._jobOrder = value
+    def isPlaygroundEnabled(self):
+        """bool: indicate if AI Playground is enabled in the catalog"""
+        return self._isPlaygroundEnabled
+
+    @isPlaygroundEnabled.setter
+    def isPlaygroundEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPlaygroundEnabled = value
         else:
             raise TypeError(
-                'Property "jobOrder" of type "list<int>" set to wrong type'
+                'Property "isPlaygroundEnabled" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def jobPriority(self):
-        """JobPriorityEnum: Indicates the job priority enum"""
-        return self._jobPriority
+    def isPublic(self):
+        """bool: Determines if model is publicly accessible"""
+        return self._isPublic
 
-    @jobPriority.setter
-    def jobPriority(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._jobPriority = value
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
         else:
             raise TypeError(
-                'Property "jobPriority" of type "list<JobPriorityEnum>" set t'
-                'o wrong type'
+                'Property "isPublic" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def jobStatus(self):
-        """JobStatus: updates about job status are coming from the nodes"""
-        return self._jobStatus
+    def isReadOnly(self):
+        """bool: indicate if current user has read only permissions"""
+        return self._isReadOnly
 
-    @jobStatus.setter
-    def jobStatus(self, value):
-        if value is not None and not isinstance(value, JobStatus):
-            value = JobStatus(value)
-        if (value is None) or isinstance(value, JobStatus):
-            self._jobStatus = value
+    @isReadOnly.setter
+    def isReadOnly(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isReadOnly = value
         else:
             raise TypeError(
-                'Property "jobStatus" of type "list<JobStatus>" set to wrong '
-                'type'
+                'Property "isReadOnly" of type "list<bool>" set to wrong type'
             )
 
     @property
     def labels(self):
-        """JobLabels: All the labels specified by user or admin that descibe t
-        his job"""
+        """ """
         return self._labels
 
     @labels.setter
     def labels(self, value):
-        if value is not None and not isinstance(value, JobLabels):
-            value = JobLabels(value)
-        if (value is None) or isinstance(value, JobLabels):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
             self._labels = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<JobLabels>" set to wrong typ'
-                'e'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def lastStatusUpdatedDate(self):
-        """str: Last updated status date"""
-        return self._lastStatusUpdatedDate
+    def latestVersionGpuModel(self):
+        """str: GPU model and memory used for the latest version"""
+        return self._latestVersionGpuModel
 
-    @lastStatusUpdatedDate.setter
-    def lastStatusUpdatedDate(self, value):
+    @latestVersionGpuModel.setter
+    def latestVersionGpuModel(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastStatusUpdatedDate = value
+            self._latestVersionGpuModel = value
         else:
             raise TypeError(
-                'Property "lastStatusUpdatedDate" of type "list<str>" set to '
+                'Property "latestVersionGpuModel" of type "list<str>" set to '
                 'wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: name of org that the job belongs to"""
-        return self._orgName
+    def latestVersionId(self):
+        """long: Deprecated: Please use latestVersionIdStr instead. ID of the 
+        latest version"""
+        return self._latestVersionId
 
-    @orgName.setter
-    def orgName(self, value):
+    @latestVersionId.setter
+    def latestVersionId(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._latestVersionId = value
+        else:
+            raise TypeError(
+                'Property "latestVersionId" of type "list<long>" set to wrong'
+                ' type'
+            )
+
+    @property
+    def latestVersionIdStr(self):
+        """str: ID of the latest version"""
+        return self._latestVersionIdStr
+
+    @latestVersionIdStr.setter
+    def latestVersionIdStr(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._latestVersionIdStr = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "latestVersionIdStr" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def preemptionRequestedByUser(self):
-        """long: ID of the user who requested preemption of this job"""
-        return self._preemptionRequestedByUser
+    def latestVersionSizeInBytes(self):
+        """long: Size of the latest version in bytes"""
+        return self._latestVersionSizeInBytes
 
-    @preemptionRequestedByUser.setter
-    def preemptionRequestedByUser(self, value):
+    @latestVersionSizeInBytes.setter
+    def latestVersionSizeInBytes(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._preemptionRequestedByUser = value
+            self._latestVersionSizeInBytes = value
         else:
             raise TypeError(
-                'Property "preemptionRequestedByUser" of type "list<long>" se'
-                't to wrong type'
+                'Property "latestVersionSizeInBytes" of type "list<long>" set'
+                ' to wrong type'
             )
 
     @property
-    def preemptionRequestedDate(self):
-        """str: Date at which preemption of this job was requested"""
-        return self._preemptionRequestedDate
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @preemptionRequestedDate.setter
-    def preemptionRequestedDate(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._preemptionRequestedDate = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "preemptionRequestedDate" of type "list<str>" set t'
-                'o wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resultset(self):
-        """StorageResource: Generic Storage Resource for DL jobs."""
-        return self._resultset
+    def modelFormat(self):
+        """str: Format of the model"""
+        return self._modelFormat
 
-    @resultset.setter
-    def resultset(self, value):
-        if value is not None and not isinstance(value, StorageResource):
-            value = StorageResource(value)
-        if (value is None) or isinstance(value, StorageResource):
-            self._resultset = value
+    @modelFormat.setter
+    def modelFormat(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._modelFormat = value
         else:
             raise TypeError(
-                'Property "resultset" of type "list<StorageResource>" set to '
-                'wrong type'
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resumeRequestedByUser(self):
-        """long: ID of the user who requested resumption of this job"""
-        return self._resumeRequestedByUser
+    def name(self):
+        """str: Unique name of the model"""
+        return self._name
 
-    @resumeRequestedByUser.setter
-    def resumeRequestedByUser(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resumeRequestedByUser = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "resumeRequestedByUser" of type "list<long>" set to'
-                ' wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resumeRequestedDate(self):
-        """str: Date at which resumption of this job was requested"""
-        return self._resumeRequestedDate
+    def orgName(self):
+        """str: Name of the org that the model belongs to"""
+        return self._orgName
 
-    @resumeRequestedDate.setter
-    def resumeRequestedDate(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resumeRequestedDate = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "resumeRequestedDate" of type "list<str>" set to wr'
-                'ong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sparklines(self):
-        """list: array of series within a measurement"""
-        return self._sparklines
+    def ownerName(self):
+        """str: Name of model's owner"""
+        return self._ownerName
 
-    @sparklines.setter
-    def sparklines(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._sparklines = value
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "sparklines" of type "list<MeasurementSeries>" set '
-                'to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def submittedByUser(self):
-        """str: user that submitted this job"""
-        return self._submittedByUser
+    def precision(self):
+        """str: Precision this model was trained with"""
+        return self._precision
 
-    @submittedByUser.setter
-    def submittedByUser(self, value):
+    @precision.setter
+    def precision(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._submittedByUser = value
+            self._precision = value
         else:
             raise TypeError(
-                'Property "submittedByUser" of type "list<str>" set to wrong '
-                'type'
+                'Property "precision" of type "list<str>" set to wrong type'
             )
 
     @property
-    def submittedByUserId(self):
-        """long: User id of the user that submitted this job"""
-        return self._submittedByUserId
+    def privacy(self):
+        """str: Text describing the privacy for this model"""
+        return self._privacy
 
-    @submittedByUserId.setter
-    def submittedByUserId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._submittedByUserId = value
+    @privacy.setter
+    def privacy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._privacy = value
         else:
             raise TypeError(
-                'Property "submittedByUserId" of type "list<long>" set to wro'
-                'ng type'
+                'Property "privacy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def teamName(self):
-        """str: name of team that the job belongs to"""
-        return self._teamName
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
 
-    @teamName.setter
-    def teamName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def tensorCoreActive(self):
-        """float: Total tensor core active for the lifetime of the job (TC act
-        ive)"""
-        return self._tensorCoreActive
-
-    @tensorCoreActive.setter
-    def tensorCoreActive(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._tensorCoreActive = value
+    def publicDatasetUsed(self):
+        """ """
+        return self._publicDatasetUsed
+
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "tensorCoreActive" of type "list<float>" set to wro'
-                'ng type'
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
+                'wrong type'
             )
 
     @property
-    def tensorCoreActiveWhileGpuActive(self):
-        """float: Ratio of tensor core active to gpu active"""
-        return self._tensorCoreActiveWhileGpuActive
+    def publisher(self):
+        """str: organization that published the repository"""
+        return self._publisher
 
-    @tensorCoreActiveWhileGpuActive.setter
-    def tensorCoreActiveWhileGpuActive(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._tensorCoreActiveWhileGpuActive = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "tensorCoreActiveWhileGpuActive" of type "list<floa'
-                't>" set to wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def terminationReason(self):
-        """str: Reason given by user or admin to terminate this job"""
-        return self._terminationReason
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the model"""
+        return self._safetyAndSecurity
 
-    @terminationReason.setter
-    def terminationReason(self, value):
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._terminationReason = value
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "terminationReason" of type "list<str>" set to wron'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
                 'g type'
             )
 
     @property
-    def terminationRequestedByUser(self):
-        """long: ID of the user who requested termination of this job"""
-        return self._terminationRequestedByUser
+    def shortDescription(self):
+        """str: Short description of the model"""
+        return self._shortDescription
 
-    @terminationRequestedByUser.setter
-    def terminationRequestedByUser(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._terminationRequestedByUser = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "terminationRequestedByUser" of type "list<long>" s'
-                'et to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def terminationRequestedByUserName(self):
-        """str: Name of the user who requested termination of this job"""
-        return self._terminationRequestedByUserName
+    def teamName(self):
+        """str: Name of the team that the model belongs to"""
+        return self._teamName
 
-    @terminationRequestedByUserName.setter
-    def terminationRequestedByUserName(self, value):
+    @teamName.setter
+    def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._terminationRequestedByUserName = value
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "terminationRequestedByUserName" of type "list<str>'
-                '" set to wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def terminationRequestedDate(self):
-        """str: Date at which termination of this job was requested"""
-        return self._terminationRequestedDate
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
 
-    @terminationRequestedDate.setter
-    def terminationRequestedDate(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._terminationRequestedDate = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "terminationRequestedDate" of type "list<str>" set '
-                'to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def workspaces(self):
-        """list: List of workspaces used for this job"""
-        return self._workspaces
+    def versions(self):
+        """ """
+        return self._versions
 
-    @workspaces.setter
-    def workspaces(self, value):
+    @versions.setter
+    def versions(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._workspaces = value
+            self._versions = value
         else:
             raise TypeError(
-                'Property "workspaces" of type "list<StorageResource>" set to'
-                ' wrong type'
+                'Property "versions" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._aceProvider is not None:
-            result["aceProvider"] = \
-                self._aceProvider
-        if self._aceResourceInstance is not None:
-            result["aceResourceInstance"] = \
-                self._aceResourceInstance
-        if self._baseImageName is not None:
-            result["baseImageName"] = \
-                self._baseImageName
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._canGuestDownload is not None:
+            result["canGuestDownload"] = \
+                self._canGuestDownload
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._datasets:
-            result["datasets"] = [
-                i.toDict() for i in self._datasets 
-            ] if self._datasets else []
-        if self._expTrackingURL is not None:
-            result["expTrackingURL"] = \
-                self._expTrackingURL
-        if self._gpuActiveTime is not None:
-            result["gpuActiveTime"] = \
-                self._gpuActiveTime
-        if self._gpuUtilization is not None:
-            result["gpuUtilization"] = \
-                self._gpuUtilization
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._jobDefinition:
-            result["jobDefinition"] = \
-                self._jobDefinition.toDict() if self._jobDefinition is not None else None
-        if self._jobOrder is not None:
-            result["jobOrder"] = \
-                self._jobOrder
-        if self._jobPriority is not None:
-            result["jobPriority"] = \
-                self._jobPriority
-        if self._jobStatus:
-            result["jobStatus"] = \
-                self._jobStatus.toDict() if self._jobStatus is not None else None
-        if self._labels:
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._framework is not None:
+            result["framework"] = \
+                self._framework
+        if self._hasPlayground is not None:
+            result["hasPlayground"] = \
+                self._hasPlayground
+        if self._isFavourite is not None:
+            result["isFavourite"] = \
+                self._isFavourite
+        if self._isPlaygroundEnabled is not None:
+            result["isPlaygroundEnabled"] = \
+                self._isPlaygroundEnabled
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._isReadOnly is not None:
+            result["isReadOnly"] = \
+                self._isReadOnly
+        if self._labels is not None:
             result["labels"] = \
-                self._labels.toDict() if self._labels is not None else None
-        if self._lastStatusUpdatedDate is not None:
-            result["lastStatusUpdatedDate"] = \
-                self._lastStatusUpdatedDate
+                self._labels
+        if self._latestVersionGpuModel is not None:
+            result["latestVersionGpuModel"] = \
+                self._latestVersionGpuModel
+        if self._latestVersionId is not None:
+            result["latestVersionId"] = \
+                self._latestVersionId
+        if self._latestVersionIdStr is not None:
+            result["latestVersionIdStr"] = \
+                self._latestVersionIdStr
+        if self._latestVersionSizeInBytes is not None:
+            result["latestVersionSizeInBytes"] = \
+                self._latestVersionSizeInBytes
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
+        if self._name is not None:
+            result["name"] = \
+                self._name
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
-        if self._preemptionRequestedByUser is not None:
-            result["preemptionRequestedByUser"] = \
-                self._preemptionRequestedByUser
-        if self._preemptionRequestedDate is not None:
-            result["preemptionRequestedDate"] = \
-                self._preemptionRequestedDate
-        if self._resultset:
-            result["resultset"] = \
-                self._resultset.toDict() if self._resultset is not None else None
-        if self._resumeRequestedByUser is not None:
-            result["resumeRequestedByUser"] = \
-                self._resumeRequestedByUser
-        if self._resumeRequestedDate is not None:
-            result["resumeRequestedDate"] = \
-                self._resumeRequestedDate
-        if self._sparklines:
-            result["sparklines"] = [
-                i.toDict() for i in self._sparklines 
-            ] if self._sparklines else []
-        if self._submittedByUser is not None:
-            result["submittedByUser"] = \
-                self._submittedByUser
-        if self._submittedByUserId is not None:
-            result["submittedByUserId"] = \
-                self._submittedByUserId
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         if self._teamName is not None:
             result["teamName"] = \
                 self._teamName
-        if self._tensorCoreActive is not None:
-            result["tensorCoreActive"] = \
-                self._tensorCoreActive
-        if self._tensorCoreActiveWhileGpuActive is not None:
-            result["tensorCoreActiveWhileGpuActive"] = \
-                self._tensorCoreActiveWhileGpuActive
-        if self._terminationReason is not None:
-            result["terminationReason"] = \
-                self._terminationReason
-        if self._terminationRequestedByUser is not None:
-            result["terminationRequestedByUser"] = \
-                self._terminationRequestedByUser
-        if self._terminationRequestedByUserName is not None:
-            result["terminationRequestedByUserName"] = \
-                self._terminationRequestedByUserName
-        if self._terminationRequestedDate is not None:
-            result["terminationRequestedDate"] = \
-                self._terminationRequestedDate
-        if self._workspaces:
-            result["workspaces"] = [
-                i.toDict() for i in self._workspaces 
-            ] if self._workspaces else []
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
+        if self._versions is not None:
+            result["versions"] = \
+                self._versions
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
@@ -902,80 +895,23 @@
     def isValid(self):
         if (self._createdDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._createdDate)):
             raise ValueError(
-                "Job.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._lastStatusUpdatedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._lastStatusUpdatedDate)):
-            raise ValueError(
-                "Job.lastStatusUpdatedDate: " + str(self._lastStatusUpdatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._terminationRequestedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._terminationRequestedDate)):
-            raise ValueError(
-                "Job.terminationRequestedDate: " + str(self._terminationRequestedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._terminationReason is not None
-            and
-            len(self._terminationReason) > 80):
-            raise ValueError(
-                "Job.terminationReason: " + str(self._terminationReason) + 
-                " doesnt match requirement: maxLength: 80")
-        if (self._preemptionRequestedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._preemptionRequestedDate)):
-            raise ValueError(
-                "Job.preemptionRequestedDate: " + str(self._preemptionRequestedDate) + 
+                "Model.createdDate: " + str(self._createdDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._resumeRequestedDate is not None
+        if (self._updatedDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._resumeRequestedDate)):
+                 self._updatedDate)):
             raise ValueError(
-                "Job.resumeRequestedDate: " + str(self._resumeRequestedDate) + 
+                "Model.updatedDate: " + str(self._updatedDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._jobOrder is not None
-            and
-            self._jobOrder < 1):
-            raise ValueError(
-                "Job.jobOrder: " + str(self._jobOrder) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._jobOrder is not None
-            and
-            self._jobOrder > 99):
-            raise ValueError(
-                "Job.jobOrder: " + str(self._jobOrder) + 
-                " doesnt match requirement: maximum: 99")
-        if (self._jobStatus is not None): self._jobStatus.isValid()
-        if (self._jobDefinition is not None): self._jobDefinition.isValid()
-        if (self._datasets is not None):
-            for obj in self._datasets:
-                if (obj is not None): obj.isValid()
-        if (self._workspaces is not None):
-            for obj in self._workspaces:
-                if (obj is not None): obj.isValid()
-        if (self._resultset is not None): self._resultset.isValid()
-        if (self._sparklines is not None):
-            for obj in self._sparklines:
-                if (obj is not None): obj.isValid()
-        if (self._labels is not None): self._labels.isValid()
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
         return True
```

## Comparing `ngccli/data/api/JobContainerProperties.py` & `basecommand/data/pym/ClusterRequestStatus.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,359 +6,387 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Env import Env
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
-from .JobVolumeMount import JobVolumeMount
-from .JobDatasetMountInfo import JobDatasetMountInfo
-from .ContainerResources import ContainerResources
+from .ClusterTypeEnum import ClusterTypeEnum
+from .ClusterStatusEnum import ClusterStatusEnum
 
 # Unused import over optimization prevention
-str(repr(Env))
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
-str(repr(ContainerResources))
-str(repr(JobDatasetMountInfo))
+str(repr(ClusterTypeEnum))
+str(repr(ClusterStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobContainerProperties(object):
-    """Describes the common properties of a kubernetes container"""
+class ClusterRequestStatus(object):
+    """Cluster Request status"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.command = (
+        self.additionalInfo = (
             None if not fromDict or propDict.get(
-                "command"
+                "additionalInfo"
             ) is None
-            else propDict["command"])
-        self.containerName = (
+            else propDict["additionalInfo"])
+        self.clusterRuntimeInSeconds = (
             None if not fromDict or propDict.get(
-                "containerName"
+                "clusterRuntimeInSeconds"
             ) is None
-            else propDict["containerName"])
-        self.containerResources = (
+            else propDict["clusterRuntimeInSeconds"])
+        self.creationTimestamp = (
             None if not fromDict or propDict.get(
-                "containerResources"
+                "creationTimestamp"
             ) is None
-            else propDict["containerResources"])
-        self.datasetMounts = (
+            else propDict["creationTimestamp"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "datasetMounts"
+                "id"
             ) is None
-            else [ JobDatasetMountInfo(i)
-            for i in propDict["datasetMounts"] ])
-        self.dockerImageName = (
+            else propDict["id"])
+        self.jobId = (
             None if not fromDict or propDict.get(
-                "dockerImageName"
+                "jobId"
             ) is None
-            else propDict["dockerImageName"])
-        self.entryPoint = (
+            else propDict["jobId"])
+        self.managerId = (
             None if not fromDict or propDict.get(
-                "entryPoint"
+                "managerId"
             ) is None
-            else propDict["entryPoint"])
-        self.envs = (
+            else propDict["managerId"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "envs"
+                "name"
             ) is None
-            else [ Env(i)
-            for i in propDict["envs"] ])
-        self.jobVolumeMounts = (
+            else propDict["name"])
+        self.org = (
             None if not fromDict or propDict.get(
-                "jobVolumeMounts"
+                "org"
             ) is None
-            else [ JobVolumeMount(i)
-            for i in propDict["jobVolumeMounts"] ])
-        self.resultContainerMountPoint = (
+            else propDict["org"])
+        self.startedRunningAt = (
             None if not fromDict or propDict.get(
-                "resultContainerMountPoint"
+                "startedRunningAt"
             ) is None
-            else propDict["resultContainerMountPoint"])
-        self.useImageEntryPoint = (
+            else propDict["startedRunningAt"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "useImageEntryPoint"
+                "status"
             ) is None
-            else propDict["useImageEntryPoint"])
-        self.workspaceMounts = (
+            else propDict["status"])
+        self.stoppedRunningAt = (
             None if not fromDict or propDict.get(
-                "workspaceMounts"
+                "stoppedRunningAt"
             ) is None
-            else [ JobWorkspaceMountInfo(i)
-            for i in propDict["workspaceMounts"] ])
+            else propDict["stoppedRunningAt"])
+        self.team = (
+            None if not fromDict or propDict.get(
+                "team"
+            ) is None
+            else propDict["team"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
 
     @property
-    def command(self):
-        """str: Run command to be associated with the container."""
-        return self._command
+    def additionalInfo(self):
+        """str: Any other pertinent information on the status"""
+        return self._additionalInfo
 
-    @command.setter
-    def command(self, value):
+    @additionalInfo.setter
+    def additionalInfo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._command = value
+            self._additionalInfo = value
+        else:
+            raise TypeError(
+                'Property "additionalInfo" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def clusterRuntimeInSeconds(self):
+        """long: How long the cluster has been running in seconds"""
+        return self._clusterRuntimeInSeconds
+
+    @clusterRuntimeInSeconds.setter
+    def clusterRuntimeInSeconds(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._clusterRuntimeInSeconds = value
         else:
             raise TypeError(
-                'Property "command" of type "list<str>" set to wrong type'
+                'Property "clusterRuntimeInSeconds" of type "list<long>" set '
+                'to wrong type'
             )
 
     @property
-    def containerName(self):
-        """str: Name of the init container, MUST be unique among all helper co
-        ntainers."""
-        return self._containerName
+    def creationTimestamp(self):
+        """str: Cluster creation date time in YYYY-MM-DDThh:mm:ssZ format"""
+        return self._creationTimestamp
 
-    @containerName.setter
-    def containerName(self, value):
+    @creationTimestamp.setter
+    def creationTimestamp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerName = value
+            self._creationTimestamp = value
         else:
             raise TypeError(
-                'Property "containerName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "creationTimestamp" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def containerResources(self):
-        """ """
-        return self._containerResources
+    def id(self):
+        """str: Cluster ID"""
+        return self._id
 
-    @containerResources.setter
-    def containerResources(self, value):
-        if value is not None and not isinstance(value, ContainerResources):
-            value = ContainerResources(value)
-        if (value is None) or isinstance(value, ContainerResources):
-            self._containerResources = value
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "containerResources" of type "list<ContainerResourc'
-                'es>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def datasetMounts(self):
-        """ """
-        return self._datasetMounts
+    def jobId(self):
+        """long: Unique Id of the BCP job"""
+        return self._jobId
 
-    @datasetMounts.setter
-    def datasetMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._datasetMounts = value
+    @jobId.setter
+    def jobId(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._jobId = value
         else:
             raise TypeError(
-                'Property "datasetMounts" of type "list<JobDatasetMountInfo>"'
-                ' set to wrong type'
+                'Property "jobId" of type "list<long>" set to wrong type'
             )
 
     @property
-    def dockerImageName(self):
-        """str: Docker container image name to use when submitting this job. P
-        rovide full namespace - org/team/repo:tag. If tag is not speci
-        fied, latest will be used by default."""
-        return self._dockerImageName
+    def managerId(self):
+        """str: Manager ID"""
+        return self._managerId
 
-    @dockerImageName.setter
-    def dockerImageName(self, value):
+    @managerId.setter
+    def managerId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dockerImageName = value
+            self._managerId = value
         else:
             raise TypeError(
-                'Property "dockerImageName" of type "list<str>" set to wrong '
-                'type'
+                'Property "managerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def entryPoint(self):
-        """str: Overwrite the default ENTRYPOINT of the image"""
-        return self._entryPoint
+    def name(self):
+        """str: Cluster name"""
+        return self._name
 
-    @entryPoint.setter
-    def entryPoint(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._entryPoint = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "entryPoint" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def envs(self):
-        """list: List of environment variables associated to the job"""
-        return self._envs
+    def org(self):
+        """str: Org name that the cluster belongs to (only used in LIST and IN
+        FO command responses)"""
+        return self._org
 
-    @envs.setter
-    def envs(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._envs = value
+    @org.setter
+    def org(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._org = value
         else:
             raise TypeError(
-                'Property "envs" of type "list<Env>" set to wrong type'
+                'Property "org" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobVolumeMounts(self):
-        """list: A list of job volume mount points in the init container."""
-        return self._jobVolumeMounts
+    def startedRunningAt(self):
+        """str: Cluster started running date time in YYYY-MM-DDThh:mm:ss.SSSZ 
+        format"""
+        return self._startedRunningAt
 
-    @jobVolumeMounts.setter
-    def jobVolumeMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._jobVolumeMounts = value
+    @startedRunningAt.setter
+    def startedRunningAt(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._startedRunningAt = value
         else:
             raise TypeError(
-                'Property "jobVolumeMounts" of type "list<JobVolumeMount>" se'
-                't to wrong type'
+                'Property "startedRunningAt" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def resultContainerMountPoint(self):
-        """str: Mount Point inside container to which result set mount will be
-         mapped"""
-        return self._resultContainerMountPoint
+    def status(self):
+        """ClusterStatusEnum: All possible cluster status enums"""
+        return self._status
 
-    @resultContainerMountPoint.setter
-    def resultContainerMountPoint(self, value):
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
+        else:
+            raise TypeError(
+                'Property "status" of type "list<ClusterStatusEnum>" set to w'
+                'rong type'
+            )
+
+    @property
+    def stoppedRunningAt(self):
+        """str: Cluster stopped running date time in YYYY-MM-DDThh:mm:ss.SSSZ 
+        format"""
+        return self._stoppedRunningAt
+
+    @stoppedRunningAt.setter
+    def stoppedRunningAt(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resultContainerMountPoint = value
+            self._stoppedRunningAt = value
         else:
             raise TypeError(
-                'Property "resultContainerMountPoint" of type "list<str>" set'
-                ' to wrong type'
+                'Property "stoppedRunningAt" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def useImageEntryPoint(self):
-        """bool: opt-in flag for enabling image entrypoint."""
-        return self._useImageEntryPoint
+    def team(self):
+        """str: Team name that the cluster belongs to (only used in LIST and I
+        NFO command responses)"""
+        return self._team
 
-    @useImageEntryPoint.setter
-    def useImageEntryPoint(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useImageEntryPoint = value
+    @team.setter
+    def team(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._team = value
         else:
             raise TypeError(
-                'Property "useImageEntryPoint" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     @property
-    def workspaceMounts(self):
-        """ """
-        return self._workspaceMounts
+    def type(self):
+        """ClusterTypeEnum: All supported cluster types"""
+        return self._type
 
-    @workspaceMounts.setter
-    def workspaceMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._workspaceMounts = value
+    @type.setter
+    def type(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._type = value
         else:
             raise TypeError(
-                'Property "workspaceMounts" of type "list<JobWorkspaceMountIn'
-                'fo>" set to wrong type'
+                'Property "type" of type "list<ClusterTypeEnum>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._command is not None:
-            result["command"] = \
-                self._command
-        if self._containerName is not None:
-            result["containerName"] = \
-                self._containerName
-        if self._containerResources:
-            result["containerResources"] = \
-                self._containerResources.toDict() if self._containerResources is not None else None
-        if self._datasetMounts:
-            result["datasetMounts"] = [
-                i.toDict() for i in self._datasetMounts 
-            ] if self._datasetMounts else []
-        if self._dockerImageName is not None:
-            result["dockerImageName"] = \
-                self._dockerImageName
-        if self._entryPoint is not None:
-            result["entryPoint"] = \
-                self._entryPoint
-        if self._envs:
-            result["envs"] = [
-                i.toDict() for i in self._envs 
-            ] if self._envs else []
-        if self._jobVolumeMounts:
-            result["jobVolumeMounts"] = [
-                i.toDict() for i in self._jobVolumeMounts 
-            ] if self._jobVolumeMounts else []
-        if self._resultContainerMountPoint is not None:
-            result["resultContainerMountPoint"] = \
-                self._resultContainerMountPoint
-        if self._useImageEntryPoint is not None:
-            result["useImageEntryPoint"] = \
-                self._useImageEntryPoint
-        if self._workspaceMounts:
-            result["workspaceMounts"] = [
-                i.toDict() for i in self._workspaceMounts 
-            ] if self._workspaceMounts else []
+        if self._additionalInfo is not None:
+            result["additionalInfo"] = \
+                self._additionalInfo
+        if self._clusterRuntimeInSeconds is not None:
+            result["clusterRuntimeInSeconds"] = \
+                self._clusterRuntimeInSeconds
+        if self._creationTimestamp is not None:
+            result["creationTimestamp"] = \
+                self._creationTimestamp
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._jobId is not None:
+            result["jobId"] = \
+                self._jobId
+        if self._managerId is not None:
+            result["managerId"] = \
+                self._managerId
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._startedRunningAt is not None:
+            result["startedRunningAt"] = \
+                self._startedRunningAt
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._stoppedRunningAt is not None:
+            result["stoppedRunningAt"] = \
+                self._stoppedRunningAt
+        if self._team is not None:
+            result["team"] = \
+                self._team
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._dockerImageName is None:
+        if self._id is None:
             raise ValueError(
-                "JobContainerProperties.dockerImageName doesnt match requirement:" 
+                "ClusterRequestStatus.id doesnt match requirement:" 
                 "required: True"
             )
-        if (self._dockerImageName is not None
-            and
-            not re.match(
-                r"[\x20-\x7E]*",
-                 self._dockerImageName)):
+        if self._name is None:
             raise ValueError(
-                "JobContainerProperties.dockerImageName: " + str(self._dockerImageName) + 
-                " doesnt match requirement: pattern: [\x20-\x7E]*")
-        if self._resultContainerMountPoint is None:
+                "ClusterRequestStatus.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._creationTimestamp is None:
+            raise ValueError(
+                "ClusterRequestStatus.creationTimestamp doesnt match requirement:" 
+                "required: True"
+            )
+        if self._clusterRuntimeInSeconds is None:
+            raise ValueError(
+                "ClusterRequestStatus.clusterRuntimeInSeconds doesnt match requirement:" 
+                "required: True"
+            )
+        if self._startedRunningAt is None:
+            raise ValueError(
+                "ClusterRequestStatus.startedRunningAt doesnt match requirement:" 
+                "required: True"
+            )
+        if self._stoppedRunningAt is None:
             raise ValueError(
-                "JobContainerProperties.resultContainerMountPoint doesnt match requirement:" 
+                "ClusterRequestStatus.stoppedRunningAt doesnt match requirement:" 
                 "required: True"
             )
-        if (self._datasetMounts is not None):
-            for obj in self._datasetMounts:
-                if (obj is not None): obj.isValid()
-        if (self._workspaceMounts is not None):
-            for obj in self._workspaceMounts:
-                if (obj is not None): obj.isValid()
-        if (self._envs is not None):
-            for obj in self._envs:
-                if (obj is not None): obj.isValid()
-        if (self._jobVolumeMounts is not None):
-            for obj in self._jobVolumeMounts:
-                if (obj is not None): obj.isValid()
-        if (self._containerResources is not None): self._containerResources.isValid()
         return True
```

## Comparing `ngccli/data/api/JobContainerResources.py` & `ngcbpc/data/registry/Header.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,84 +6,85 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Jwk import Jwk
 
 # Unused import over optimization prevention
+str(repr(Jwk))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobContainerResources(object):
-    """Describes the cpu and memory resources for the job containers"""
+class Header(object):
+    """Signature header"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.cpu = (
+        self.alg = (
             None if not fromDict or propDict.get(
-                "cpu"
+                "alg"
             ) is None
-            else propDict["cpu"])
-        self.memory = (
+            else propDict["alg"])
+        self.jwk = (
             None if not fromDict or propDict.get(
-                "memory"
+                "jwk"
             ) is None
-            else propDict["memory"])
+            else propDict["jwk"])
 
     @property
-    def cpu(self):
-        """str: CPU resource allocated for the container, default is 100m (=0.
-        1 cores)"""
-        return self._cpu
+    def alg(self):
+        """str: Algorithm used for encryption"""
+        return self._alg
 
-    @cpu.setter
-    def cpu(self, value):
+    @alg.setter
+    def alg(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._cpu = value
+            self._alg = value
         else:
             raise TypeError(
-                'Property "cpu" of type "list<str>" set to wrong type'
+                'Property "alg" of type "list<str>" set to wrong type'
             )
 
     @property
-    def memory(self):
-        """str: Memory resource allocated for the container, default is 500Mi 
-        (=500 * 1024 * 1024 bytes)"""
-        return self._memory
-
-    @memory.setter
-    def memory(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._memory = value
+    def jwk(self):
+        """Jwk: JSON Web Key"""
+        return self._jwk
+
+    @jwk.setter
+    def jwk(self, value):
+        if value is not None and not isinstance(value, Jwk):
+            value = Jwk(value)
+        if (value is None) or isinstance(value, Jwk):
+            self._jwk = value
         else:
             raise TypeError(
-                'Property "memory" of type "list<str>" set to wrong type'
+                'Property "jwk" of type "list<Jwk>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._cpu is not None:
-            result["cpu"] = \
-                self._cpu
-        if self._memory is not None:
-            result["memory"] = \
-                self._memory
+        if self._alg is not None:
+            result["alg"] = \
+                self._alg
+        if self._jwk:
+            result["jwk"] = \
+                self._jwk.toDict() if self._jwk is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._jwk is not None): self._jwk.isValid()
         return True
```

## Comparing `ngccli/data/api/JobDataLocation.py` & `ngcbpc/data/uis/UserInvitation.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,287 +6,299 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageAccessInfo import StorageAccessInfo
+from .RoleType import RoleTypeEnum
 
 # Unused import over optimization prevention
-str(repr(StorageAccessInfo))
+str(repr(RoleTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobDataLocation(object):
-    """describes the data used for this job"""
+class UserInvitation(object):
+    """User invitation to an NGC org or team"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accessRights = (
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "accessRights"
+                "createdDate"
             ) is None
-            else propDict["accessRights"])
-        self.mountPoint = (
+            else propDict["createdDate"])
+        self.email = (
             None if not fromDict or propDict.get(
-                "mountPoint"
+                "email"
             ) is None
-            else propDict["mountPoint"])
-        self.protocol = (
+            else propDict["email"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "protocol"
+                "id"
             ) is None
-            else propDict["protocol"])
-        self.resourceId = (
+            else propDict["id"])
+        self.isProcessed = (
             None if not fromDict or propDict.get(
-                "resourceId"
+                "isProcessed"
             ) is None
-            else propDict["resourceId"])
-        self.shareClientId = (
+            else propDict["isProcessed"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "shareClientId"
+                "name"
             ) is None
-            else propDict["shareClientId"])
-        self.shareHost = (
+            else propDict["name"])
+        self.org = (
             None if not fromDict or propDict.get(
-                "shareHost"
+                "org"
             ) is None
-            else propDict["shareHost"])
-        self.sharePath = (
+            else propDict["org"])
+        self.roles = (
             None if not fromDict or propDict.get(
-                "sharePath"
+                "roles"
             ) is None
-            else propDict["sharePath"])
-        self.shareSecret = (
+            else propDict["roles"])
+        self.team = (
             None if not fromDict or propDict.get(
-                "shareSecret"
+                "team"
             ) is None
-            else propDict["shareSecret"])
-        self.storageAccessInfo = (
-            None if not fromDict or propDict.get(
-                "storageAccessInfo"
-            ) is None
-            else propDict["storageAccessInfo"])
+            else propDict["team"])
         self.type = (
             None if not fromDict or propDict.get(
                 "type"
             ) is None
             else propDict["type"])
 
     @property
-    def accessRights(self):
-        """AccessRightsEnum: Permissions for the volume when mounted"""
-        return self._accessRights
+    def createdDate(self):
+        """str: Date on which the invitation was created. (ISO-8601 format)"""
+        return self._createdDate
 
-    @accessRights.setter
-    def accessRights(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._accessRights = value
+    @createdDate.setter
+    def createdDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "accessRights" of type "list<AccessRightsEnum>" set'
-                ' to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
-    AccessRightsEnum=["RO","RW",]
-    str(repr(AccessRightsEnum))  # Prevent optimizer removing enum
-
     @property
-    def mountPoint(self):
-        """str: [DEPRECATED] Set this in StorageAccessInfo"""
-        return self._mountPoint
+    def email(self):
+        """str: Email address of the user."""
+        return self._email
 
-    @mountPoint.setter
-    def mountPoint(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._mountPoint = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "mountPoint" of type "list<str>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def protocol(self):
-        """ProtocolEnum: [DEPRECATED] Set this in StorageAccessInfo"""
-        return self._protocol
-
-    @protocol.setter
-    def protocol(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._protocol = value
+    def id(self):
+        """long: Unique invitation ID"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
         else:
             raise TypeError(
-                'Property "protocol" of type "list<ProtocolEnum>" set to wron'
-                'g type'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
-    ProtocolEnum=["UNKNOWN","NFSV3","CEPH","LOCAL","ZFS","YAROFS","LUSTRE","PROXYFS",]
-    str(repr(ProtocolEnum))  # Prevent optimizer removing enum
-
     @property
-    def resourceId(self):
-        """str: Unique identifier for the resource data"""
-        return self._resourceId
-
-    @resourceId.setter
-    def resourceId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._resourceId = value
+    def isProcessed(self):
+        """bool: Flag indicating if the invitation has already been accepted b
+        y the user."""
+        return self._isProcessed
+
+    @isProcessed.setter
+    def isProcessed(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isProcessed = value
         else:
             raise TypeError(
-                'Property "resourceId" of type "list<str>" set to wrong type'
+                'Property "isProcessed" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def shareClientId(self):
-        """str: [DEPRECATED] Ceph specific field. Set this in StorageCephInfo
-        """
-        return self._shareClientId
+    def name(self):
+        """str: user name"""
+        return self._name
 
-    @shareClientId.setter
-    def shareClientId(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareClientId = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "shareClientId" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shareHost(self):
-        """str: [DEPRECATED] Set this in StorageAccessInfo"""
-        return self._shareHost
+    def org(self):
+        """str: Org to which a user was invited."""
+        return self._org
 
-    @shareHost.setter
-    def shareHost(self, value):
+    @org.setter
+    def org(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareHost = value
+            self._org = value
         else:
             raise TypeError(
-                'Property "shareHost" of type "list<str>" set to wrong type'
+                'Property "org" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sharePath(self):
-        """str: [DEPRECATED] Set this in StorageAccessInfo"""
-        return self._sharePath
-
-    @sharePath.setter
-    def sharePath(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._sharePath = value
+    def roles(self):
+        """list: List of roles that the user have."""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "sharePath" of type "list<str>" set to wrong type'
+                'Property "roles" of type "list<RoleTypeEnum>" set to wrong t'
+                'ype'
             )
 
     @property
-    def shareSecret(self):
-        """str: [DEPRECATED] Ceph specific field. Set this in StorageCephInfo
-        """
-        return self._shareSecret
+    def team(self):
+        """str: Team to which a user was invited."""
+        return self._team
 
-    @shareSecret.setter
-    def shareSecret(self, value):
+    @team.setter
+    def team(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareSecret = value
-        else:
-            raise TypeError(
-                'Property "shareSecret" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def storageAccessInfo(self):
-        """StorageAccessInfo: Describes the information required to access and
-         mount the storage resource"""
-        return self._storageAccessInfo
-
-    @storageAccessInfo.setter
-    def storageAccessInfo(self, value):
-        if value is not None and not isinstance(value, StorageAccessInfo):
-            value = StorageAccessInfo(value)
-        if (value is None) or isinstance(value, StorageAccessInfo):
-            self._storageAccessInfo = value
+            self._team = value
         else:
             raise TypeError(
-                'Property "storageAccessInfo" of type "list<StorageAccessInfo'
-                '>" set to wrong type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     @property
     def type(self):
-        """ """
+        """TypeEnum: Type of invitation. The invitation is either to an organi
+        zation or to a team within organization."""
         return self._type
 
     @type.setter
     def type(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._type = value
         else:
             raise TypeError(
                 'Property "type" of type "list<TypeEnum>" set to wrong type'
             )
 
-    TypeEnum=["DATASET","RESULTSET","WORKSPACE","LOGSPACE","SCRATCHSPACE",]
+    TypeEnum=["ORGANIZATION","TEAM",]
     str(repr(TypeEnum))  # Prevent optimizer removing enum
 
     def toDict(self):
         result = {}
-        if self._accessRights is not None:
-            result["accessRights"] = \
-                self._accessRights
-        if self._mountPoint is not None:
-            result["mountPoint"] = \
-                self._mountPoint
-        if self._protocol is not None:
-            result["protocol"] = \
-                self._protocol
-        if self._resourceId is not None:
-            result["resourceId"] = \
-                self._resourceId
-        if self._shareClientId is not None:
-            result["shareClientId"] = \
-                self._shareClientId
-        if self._shareHost is not None:
-            result["shareHost"] = \
-                self._shareHost
-        if self._sharePath is not None:
-            result["sharePath"] = \
-                self._sharePath
-        if self._shareSecret is not None:
-            result["shareSecret"] = \
-                self._shareSecret
-        if self._storageAccessInfo:
-            result["storageAccessInfo"] = \
-                self._storageAccessInfo.toDict() if self._storageAccessInfo is not None else None
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._isProcessed is not None:
+            result["isProcessed"] = \
+                self._isProcessed
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
+        if self._team is not None:
+            result["team"] = \
+                self._team
         if self._type is not None:
             result["type"] = \
                 self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._storageAccessInfo is not None): self._storageAccessInfo.isValid()
+        if (self._email is not None
+            and
+            len(self._email) < 7):
+            raise ValueError(
+                "UserInvitation.email: " + str(self._email) + 
+                " doesnt match requirement: minLength: 7")
+        if (self._email is not None
+            and
+            len(self._email) > 128):
+            raise ValueError(
+                "UserInvitation.email: " + str(self._email) + 
+                " doesnt match requirement: maxLength: 128")
+        if (self._email is not None
+            and
+            not re.match(
+                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
+                 self._email)):
+            raise ValueError(
+                "UserInvitation.email: " + str(self._email) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
+                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "UserInvitation.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._name is not None
+            and
+            len(self._name) > 64):
+            raise ValueError(
+                "UserInvitation.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
+            raise ValueError(
+                "UserInvitation.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/api/JobDatasetMountInfo.py` & `ngcbpc/data/model/HelmChartDependency.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,104 +14,113 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobDatasetMountInfo(object):
+class HelmChartDependency(object):
+    """Helm chart dependency object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerMountPoint = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "containerMountPoint"
+                "name"
             ) is None
-            else propDict["containerMountPoint"])
-        self.id = (
+            else propDict["name"])
+        self.repository = (
             None if not fromDict or propDict.get(
-                "id"
+                "repository"
             ) is None
-            else propDict["id"])
-        self.uuid = (
+            else propDict["repository"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "uuid"
+                "version"
             ) is None
-            else propDict["uuid"])
+            else propDict["version"])
 
     @property
-    def containerMountPoint(self):
-        """str: Mount point inside the container to which this dataset will be
-         mapped"""
-        return self._containerMountPoint
+    def name(self):
+        """str: The name of the chart (example: nginx)"""
+        return self._name
 
-    @containerMountPoint.setter
-    def containerMountPoint(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerMountPoint = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "containerMountPoint" of type "list<str>" set to wr'
-                'ong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: NGC Dataset ID"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    def repository(self):
+        """str: The repository URL (example: https://example.com/charts)"""
+        return self._repository
+
+    @repository.setter
+    def repository(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._repository = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "repository" of type "list<str>" set to wrong type'
             )
 
     @property
-    def uuid(self):
-        """str: Dataset Service ID"""
-        return self._uuid
+    def version(self):
+        """str: The version of the chart (example: 1.2.3)"""
+        return self._version
 
-    @uuid.setter
-    def uuid(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._uuid = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "uuid" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._containerMountPoint is not None:
-            result["containerMountPoint"] = \
-                self._containerMountPoint
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._uuid is not None:
-            result["uuid"] = \
-                self._uuid
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._repository is not None:
+            result["repository"] = \
+                self._repository
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._containerMountPoint is None:
+        if self._name is None:
+            raise ValueError(
+                "HelmChartDependency.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._version is None:
+            raise ValueError(
+                "HelmChartDependency.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._repository is None:
             raise ValueError(
-                "JobDatasetMountInfo.containerMountPoint doesnt match requirement:" 
+                "HelmChartDependency.repository doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/JobHealthCheck.py` & `ngcbpc/data/registry/RuleSet.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,138 +6,163 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .HttpGet import HttpGet
+from .PolicyRule import PolicyRule
 
 # Unused import over optimization prevention
-str(repr(HttpGet))
+str(repr(PolicyRule))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobHealthCheck(object):
+class RuleSet(object):
+    """Rule Set which defines the go/stop/warn status of an image using rule m
+    atches on image properties"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.httpGet = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "httpGet"
+                "description"
             ) is None
-            else propDict["httpGet"])
-        self.initialDelaySeconds = (
+            else propDict["description"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "initialDelaySeconds"
+                "id"
             ) is None
-            else propDict["initialDelaySeconds"])
-        self.periodSeconds = (
+            else propDict["id"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "periodSeconds"
+                "name"
             ) is None
-            else propDict["periodSeconds"])
-        self.timeoutSeconds = (
+            else propDict["name"])
+        self.rules = (
             None if not fromDict or propDict.get(
-                "timeoutSeconds"
+                "rules"
             ) is None
-            else propDict["timeoutSeconds"])
+            else [ PolicyRule(i)
+            for i in propDict["rules"] ])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
+
+    @property
+    def description(self):
+        """ """
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
+        else:
+            raise TypeError(
+                'Property "description" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def httpGet(self):
-        """HttpGet: Health check using HTTP Get request"""
-        return self._httpGet
-
-    @httpGet.setter
-    def httpGet(self, value):
-        if value is not None and not isinstance(value, HttpGet):
-            value = HttpGet(value)
-        if (value is None) or isinstance(value, HttpGet):
-            self._httpGet = value
+    def id(self):
+        """ """
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "httpGet" of type "list<HttpGet>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def initialDelaySeconds(self):
-        """int: How much to wait (in seconds) for container to initialize befo
-        re performing the health check, default is 0."""
-        return self._initialDelaySeconds
-
-    @initialDelaySeconds.setter
-    def initialDelaySeconds(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._initialDelaySeconds = value
+    def name(self):
+        """ """
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "initialDelaySeconds" of type "list<int>" set to wr'
-                'ong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def periodSeconds(self):
-        """int: How often (in seconds) to perform the health check, default is
-         10."""
-        return self._periodSeconds
-
-    @periodSeconds.setter
-    def periodSeconds(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._periodSeconds = value
+    def rules(self):
+        """ """
+        return self._rules
+
+    @rules.setter
+    def rules(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._rules = value
         else:
             raise TypeError(
-                'Property "periodSeconds" of type "list<int>" set to wrong ty'
-                'pe'
+                'Property "rules" of type "list<PolicyRule>" set to wrong typ'
+                'e'
             )
 
     @property
-    def timeoutSeconds(self):
-        """int: Number of seconds after which health check times out and consi
-        der failed, default is 1."""
-        return self._timeoutSeconds
-
-    @timeoutSeconds.setter
-    def timeoutSeconds(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._timeoutSeconds = value
+    def version(self):
+        """ """
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "timeoutSeconds" of type "list<int>" set to wrong t'
-                'ype'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._httpGet:
-            result["httpGet"] = \
-                self._httpGet.toDict() if self._httpGet is not None else None
-        if self._initialDelaySeconds is not None:
-            result["initialDelaySeconds"] = \
-                self._initialDelaySeconds
-        if self._periodSeconds is not None:
-            result["periodSeconds"] = \
-                self._periodSeconds
-        if self._timeoutSeconds is not None:
-            result["timeoutSeconds"] = \
-                self._timeoutSeconds
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._rules:
+            result["rules"] = [
+                i.toDict() for i in self._rules 
+            ] if self._rules else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._httpGet is not None): self._httpGet.isValid()
+        if (self._rules is not None):
+            for obj in self._rules:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/JobInitContainer.py` & `ngcbpc/data/model/ModelVersionCreateRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,358 +6,384 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Env import Env
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
-from .JobVolumeMount import JobVolumeMount
-from .JobDatasetMountInfo import JobDatasetMountInfo
-from .ContainerResources import ContainerResources
+from .CustomMetricGroup import CustomMetricGroup
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(Env))
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
-str(repr(ContainerResources))
-str(repr(JobDatasetMountInfo))
+str(repr(CustomMetricGroup))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobInitContainer(object):
+class ModelVersionCreateRequest(object):
+    """Request to create a new model version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.command = (
+        self.accuracyReached = (
             None if not fromDict or propDict.get(
-                "command"
+                "accuracyReached"
             ) is None
-            else propDict["command"])
-        self.containerName = (
+            else propDict["accuracyReached"])
+        self.batchSize = (
             None if not fromDict or propDict.get(
-                "containerName"
+                "batchSize"
             ) is None
-            else propDict["containerName"])
-        self.containerResources = (
+            else propDict["batchSize"])
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "containerResources"
+                "customMetrics"
             ) is None
-            else propDict["containerResources"])
-        self.datasetMounts = (
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "datasetMounts"
+                "description"
             ) is None
-            else [ JobDatasetMountInfo(i)
-            for i in propDict["datasetMounts"] ])
-        self.dockerImageName = (
+            else propDict["description"])
+        self.gpuModel = (
             None if not fromDict or propDict.get(
-                "dockerImageName"
+                "gpuModel"
             ) is None
-            else propDict["dockerImageName"])
-        self.entryPoint = (
+            else propDict["gpuModel"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "entryPoint"
+                "id"
             ) is None
-            else propDict["entryPoint"])
-        self.envs = (
+            else propDict["id"])
+        self.memoryFootprint = (
             None if not fromDict or propDict.get(
-                "envs"
+                "memoryFootprint"
             ) is None
-            else [ Env(i)
-            for i in propDict["envs"] ])
-        self.jobVolumeMounts = (
+            else propDict["memoryFootprint"])
+        self.numberOfEpochs = (
             None if not fromDict or propDict.get(
-                "jobVolumeMounts"
+                "numberOfEpochs"
             ) is None
-            else [ JobVolumeMount(i)
-            for i in propDict["jobVolumeMounts"] ])
-        self.resultContainerMountPoint = (
+            else propDict["numberOfEpochs"])
+        self.otherContents = (
             None if not fromDict or propDict.get(
-                "resultContainerMountPoint"
+                "otherContents"
             ) is None
-            else propDict["resultContainerMountPoint"])
-        self.useImageEntryPoint = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["otherContents"] ])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "useImageEntryPoint"
+                "ownerName"
             ) is None
-            else propDict["useImageEntryPoint"])
-        self.workspaceMounts = (
+            else propDict["ownerName"])
+        self.versionId = (
             None if not fromDict or propDict.get(
-                "workspaceMounts"
+                "versionId"
             ) is None
-            else [ JobWorkspaceMountInfo(i)
-            for i in propDict["workspaceMounts"] ])
+            else propDict["versionId"])
 
     @property
-    def command(self):
-        """str: Run command to be associated with the container."""
-        return self._command
+    def accuracyReached(self):
+        """float: Accuracy this model reached"""
+        return self._accuracyReached
 
-    @command.setter
-    def command(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._command = value
+    @accuracyReached.setter
+    def accuracyReached(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._accuracyReached = value
         else:
             raise TypeError(
-                'Property "command" of type "list<str>" set to wrong type'
+                'Property "accuracyReached" of type "list<float>" set to wron'
+                'g type'
             )
 
     @property
-    def containerName(self):
-        """str: Name of the init container, MUST be unique among all helper co
-        ntainers."""
-        return self._containerName
+    def batchSize(self):
+        """long: Batch size this model was trained with"""
+        return self._batchSize
 
-    @containerName.setter
-    def containerName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._containerName = value
+    @batchSize.setter
+    def batchSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._batchSize = value
         else:
             raise TypeError(
-                'Property "containerName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "batchSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def containerResources(self):
-        """ """
-        return self._containerResources
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
 
-    @containerResources.setter
-    def containerResources(self, value):
-        if value is not None and not isinstance(value, ContainerResources):
-            value = ContainerResources(value)
-        if (value is None) or isinstance(value, ContainerResources):
-            self._containerResources = value
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
         else:
             raise TypeError(
-                'Property "containerResources" of type "list<ContainerResourc'
-                'es>" set to wrong type'
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
             )
 
     @property
-    def datasetMounts(self):
-        """ """
-        return self._datasetMounts
+    def description(self):
+        """str: Description of the model version"""
+        return self._description
 
-    @datasetMounts.setter
-    def datasetMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._datasetMounts = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "datasetMounts" of type "list<JobDatasetMountInfo>"'
-                ' set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def dockerImageName(self):
-        """str: Docker container image name to use when submitting this job. P
-        rovide full namespace - org/team/repo:tag. If tag is not speci
-        fied, latest will be used by default."""
-        return self._dockerImageName
+    def gpuModel(self):
+        """str: GPU model and memory"""
+        return self._gpuModel
 
-    @dockerImageName.setter
-    def dockerImageName(self, value):
+    @gpuModel.setter
+    def gpuModel(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dockerImageName = value
+            self._gpuModel = value
         else:
             raise TypeError(
-                'Property "dockerImageName" of type "list<str>" set to wrong '
-                'type'
+                'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def entryPoint(self):
-        """str: Overwrite the default ENTRYPOINT of the image"""
-        return self._entryPoint
+    def id(self):
+        """long: Deprecated: Please use version instead. Unique ID of the vers
+        ion"""
+        return self._id
 
-    @entryPoint.setter
-    def entryPoint(self, value):
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
+        else:
+            raise TypeError(
+                'Property "id" of type "list<long>" set to wrong type'
+            )
+
+    @property
+    def memoryFootprint(self):
+        """str: Model size/memory footprint for inference"""
+        return self._memoryFootprint
+
+    @memoryFootprint.setter
+    def memoryFootprint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._entryPoint = value
+            self._memoryFootprint = value
         else:
             raise TypeError(
-                'Property "entryPoint" of type "list<str>" set to wrong type'
+                'Property "memoryFootprint" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def envs(self):
-        """list: List of environment variables associated to the job"""
-        return self._envs
-
-    @envs.setter
-    def envs(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._envs = value
+    def numberOfEpochs(self):
+        """long: Number of epochs this model trained"""
+        return self._numberOfEpochs
+
+    @numberOfEpochs.setter
+    def numberOfEpochs(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._numberOfEpochs = value
         else:
             raise TypeError(
-                'Property "envs" of type "list<Env>" set to wrong type'
+                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def jobVolumeMounts(self):
-        """list: A list of job volume mount points in the init container."""
-        return self._jobVolumeMounts
+    def otherContents(self):
+        """list: List of external contents"""
+        return self._otherContents
 
-    @jobVolumeMounts.setter
-    def jobVolumeMounts(self, value):
+    @otherContents.setter
+    def otherContents(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._jobVolumeMounts = value
+            self._otherContents = value
         else:
             raise TypeError(
-                'Property "jobVolumeMounts" of type "list<JobVolumeMount>" se'
-                't to wrong type'
+                'Property "otherContents" of type "list<ArtifactAttribute>" s'
+                'et to wrong type'
             )
 
     @property
-    def resultContainerMountPoint(self):
-        """str: Mount Point inside container to which result set mount will be
-         mapped"""
-        return self._resultContainerMountPoint
+    def ownerName(self):
+        """str: Name of the user who owns this version"""
+        return self._ownerName
 
-    @resultContainerMountPoint.setter
-    def resultContainerMountPoint(self, value):
+    @ownerName.setter
+    def ownerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resultContainerMountPoint = value
-        else:
-            raise TypeError(
-                'Property "resultContainerMountPoint" of type "list<str>" set'
-                ' to wrong type'
-            )
-
-    @property
-    def useImageEntryPoint(self):
-        """bool: opt-in flag for enabling image entrypoint."""
-        return self._useImageEntryPoint
-
-    @useImageEntryPoint.setter
-    def useImageEntryPoint(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useImageEntryPoint = value
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "useImageEntryPoint" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def workspaceMounts(self):
-        """ """
-        return self._workspaceMounts
+    def versionId(self):
+        """str: Unique version id. Please use this instead of 'id'"""
+        return self._versionId
 
-    @workspaceMounts.setter
-    def workspaceMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._workspaceMounts = value
+    @versionId.setter
+    def versionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._versionId = value
         else:
             raise TypeError(
-                'Property "workspaceMounts" of type "list<JobWorkspaceMountIn'
-                'fo>" set to wrong type'
+                'Property "versionId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._command is not None:
-            result["command"] = \
-                self._command
-        if self._containerName is not None:
-            result["containerName"] = \
-                self._containerName
-        if self._containerResources:
-            result["containerResources"] = \
-                self._containerResources.toDict() if self._containerResources is not None else None
-        if self._datasetMounts:
-            result["datasetMounts"] = [
-                i.toDict() for i in self._datasetMounts 
-            ] if self._datasetMounts else []
-        if self._dockerImageName is not None:
-            result["dockerImageName"] = \
-                self._dockerImageName
-        if self._entryPoint is not None:
-            result["entryPoint"] = \
-                self._entryPoint
-        if self._envs:
-            result["envs"] = [
-                i.toDict() for i in self._envs 
-            ] if self._envs else []
-        if self._jobVolumeMounts:
-            result["jobVolumeMounts"] = [
-                i.toDict() for i in self._jobVolumeMounts 
-            ] if self._jobVolumeMounts else []
-        if self._resultContainerMountPoint is not None:
-            result["resultContainerMountPoint"] = \
-                self._resultContainerMountPoint
-        if self._useImageEntryPoint is not None:
-            result["useImageEntryPoint"] = \
-                self._useImageEntryPoint
-        if self._workspaceMounts:
-            result["workspaceMounts"] = [
-                i.toDict() for i in self._workspaceMounts 
-            ] if self._workspaceMounts else []
+        if self._accuracyReached is not None:
+            result["accuracyReached"] = \
+                self._accuracyReached
+        if self._batchSize is not None:
+            result["batchSize"] = \
+                self._batchSize
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._gpuModel is not None:
+            result["gpuModel"] = \
+                self._gpuModel
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._memoryFootprint is not None:
+            result["memoryFootprint"] = \
+                self._memoryFootprint
+        if self._numberOfEpochs is not None:
+            result["numberOfEpochs"] = \
+                self._numberOfEpochs
+        if self._otherContents:
+            result["otherContents"] = [
+                i.toDict() for i in self._otherContents 
+            ] if self._otherContents else []
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._versionId is not None:
+            result["versionId"] = \
+                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._dockerImageName is None:
+        if (self._id is not None
+            and
+            self._id < 1):
             raise ValueError(
-                "JobInitContainer.dockerImageName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._dockerImageName is not None
+                "ModelVersionCreateRequest.id: " + str(self._id) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._id is not None
             and
-            not re.match(
-                r"[\x20-\x7E]*",
-                 self._dockerImageName)):
+            self._id > 2147483647):
             raise ValueError(
-                "JobInitContainer.dockerImageName: " + str(self._dockerImageName) + 
-                " doesnt match requirement: pattern: [\x20-\x7E]*")
-        if self._resultContainerMountPoint is None:
+                "ModelVersionCreateRequest.id: " + str(self._id) + 
+                " doesnt match requirement: maximum: 2147483647")
+        if (self._versionId is not None
+            and
+            len(self._versionId) > 255):
             raise ValueError(
-                "JobInitContainer.resultContainerMountPoint doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._datasetMounts is not None):
-            for obj in self._datasetMounts:
-                if (obj is not None): obj.isValid()
-        if (self._workspaceMounts is not None):
-            for obj in self._workspaceMounts:
-                if (obj is not None): obj.isValid()
-        if (self._envs is not None):
-            for obj in self._envs:
+                "ModelVersionCreateRequest.versionId: " + str(self._versionId) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._description is not None
+            and
+            len(self._description) > 255):
+            raise ValueError(
+                "ModelVersionCreateRequest.description: " + str(self._description) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._ownerName is not None
+            and
+            len(self._ownerName) > 255):
+            raise ValueError(
+                "ModelVersionCreateRequest.ownerName: " + str(self._ownerName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached < 0):
+            raise ValueError(
+                "ModelVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached > 100):
+            raise ValueError(
+                "ModelVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: maximum: 100")
+        if (self._numberOfEpochs is not None
+            and
+            self._numberOfEpochs < 0):
+            raise ValueError(
+                "ModelVersionCreateRequest.numberOfEpochs: " + str(self._numberOfEpochs) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._gpuModel is not None
+            and
+            len(self._gpuModel) > 255):
+            raise ValueError(
+                "ModelVersionCreateRequest.gpuModel: " + str(self._gpuModel) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._batchSize is not None
+            and
+            self._batchSize < 0):
+            raise ValueError(
+                "ModelVersionCreateRequest.batchSize: " + str(self._batchSize) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._memoryFootprint is not None
+            and
+            len(self._memoryFootprint) > 255):
+            raise ValueError(
+                "ModelVersionCreateRequest.memoryFootprint: " + str(self._memoryFootprint) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
                 if (obj is not None): obj.isValid()
-        if (self._jobVolumeMounts is not None):
-            for obj in self._jobVolumeMounts:
+        if (self._otherContents is not None):
+            for obj in self._otherContents:
                 if (obj is not None): obj.isValid()
-        if (self._containerResources is not None): self._containerResources.isValid()
         return True
```

## Comparing `ngccli/data/api/JobLabelDeleteRequest.py` & `ngcbpc/data/uis/TeamCreatedEvent.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,98 +14,93 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobLabelDeleteRequest(object):
-    """request to delete matched labels of a job"""
+class TeamCreatedEvent(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.reservedLabels = (
+        self.actorStarfleetId = (
             None if not fromDict or propDict.get(
-                "reservedLabels"
+                "actorStarfleetId"
             ) is None
-            else propDict["reservedLabels"])
-        self.systemLabels = (
+            else propDict["actorStarfleetId"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "systemLabels"
+                "orgName"
             ) is None
-            else propDict["systemLabels"])
-        self.userLabels = (
+            else propDict["orgName"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "userLabels"
+                "teamName"
             ) is None
-            else propDict["userLabels"])
+            else propDict["teamName"])
 
     @property
-    def reservedLabels(self):
-        """list: An array of reserved labels specified by the user to be delet
-        ed"""
-        return self._reservedLabels
-
-    @reservedLabels.setter
-    def reservedLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._reservedLabels = value
+    def actorStarfleetId(self):
+        """str: StarfleetId of actor"""
+        return self._actorStarfleetId
+
+    @actorStarfleetId.setter
+    def actorStarfleetId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._actorStarfleetId = value
         else:
             raise TypeError(
-                'Property "reservedLabels" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "actorStarfleetId" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def systemLabels(self):
-        """list: An array of system labels specified by the user to be deleted
-        """
-        return self._systemLabels
-
-    @systemLabels.setter
-    def systemLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._systemLabels = value
+    def orgName(self):
+        """str: Unique identifier of the org"""
+        return self._orgName
+
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "systemLabels" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def userLabels(self):
-        """list: An array of user labels specified by the user to be deleted
-        """
-        return self._userLabels
-
-    @userLabels.setter
-    def userLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._userLabels = value
+    def teamName(self):
+        """str: Unique identifier of the team"""
+        return self._teamName
+
+    @teamName.setter
+    def teamName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "userLabels" of type "list<str>" set to wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._reservedLabels is not None:
-            result["reservedLabels"] = \
-                self._reservedLabels
-        if self._systemLabels is not None:
-            result["systemLabels"] = \
-                self._systemLabels
-        if self._userLabels is not None:
-            result["userLabels"] = \
-                self._userLabels
+        if self._actorStarfleetId is not None:
+            result["actorStarfleetId"] = \
+                self._actorStarfleetId
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/JobLabelResponse.py` & `ngcbpc/data/uis/SakCallerInfoResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,106 +7,95 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .JobLabels import JobLabels
+from .User import User
+from .ApiKeyTypeEnum import ApiKeyTypeEnum
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(JobLabels))
+str(repr(ApiKeyTypeEnum))
+str(repr(User))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobLabelResponse(object):
-    """Information about one job"""
+class SakCallerInfoResponse(object):
+    """info about key used and user"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobId = (
-            None if not fromDict or propDict.get(
-                "jobId"
-            ) is None
-            else propDict["jobId"])
-        self.labels = (
-            None if not fromDict or propDict.get(
-                "labels"
-            ) is None
-            else propDict["labels"])
         self.orgName = (
             None if not fromDict or propDict.get(
                 "orgName"
             ) is None
             else propDict["orgName"])
+        self.products = (
+            None if not fromDict or propDict.get(
+                "products"
+            ) is None
+            else propDict["products"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.teamName = (
+        self.type = (
             None if not fromDict or propDict.get(
-                "teamName"
+                "type"
             ) is None
-            else propDict["teamName"])
-
-    @property
-    def jobId(self):
-        """long: the id of the job"""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
-        else:
-            raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
-            )
-
-    @property
-    def labels(self):
-        """JobLabels: All the labels specified by user or admin that descibe t
-        his job"""
-        return self._labels
-
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, JobLabels):
-            value = JobLabels(value)
-        if (value is None) or isinstance(value, JobLabels):
-            self._labels = value
-        else:
-            raise TypeError(
-                'Property "labels" of type "list<JobLabels>" set to wrong typ'
-                'e'
-            )
+            else propDict["type"])
+        self.user = (
+            None if not fromDict or propDict.get(
+                "user"
+            ) is None
+            else propDict["user"])
+        self.userId = (
+            None if not fromDict or propDict.get(
+                "userId"
+            ) is None
+            else propDict["userId"])
 
     @property
     def orgName(self):
-        """str: name of org that the job belongs to"""
+        """str: Org in which the key was created"""
         return self._orgName
 
     @orgName.setter
     def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._orgName = value
         else:
             raise TypeError(
                 'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
+    def products(self):
+        """list: A list of products"""
+        return self._products
+
+    @products.setter
+    def products(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._products = value
+        else:
+            raise TypeError(
+                'Property "products" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
@@ -116,53 +105,87 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def teamName(self):
-        """str: name of team that the job belongs to"""
-        return self._teamName
+    def type(self):
+        """ApiKeyTypeEnum: Possible api key types"""
+        return self._type
+
+    @type.setter
+    def type(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._type = value
+        else:
+            raise TypeError(
+                'Property "type" of type "list<ApiKeyTypeEnum>" set to wrong '
+                'type'
+            )
+
+    @property
+    def user(self):
+        """User: information about the user"""
+        return self._user
+
+    @user.setter
+    def user(self, value):
+        if value is not None and not isinstance(value, User):
+            value = User(value)
+        if (value is None) or isinstance(value, User):
+            self._user = value
+        else:
+            raise TypeError(
+                'Property "user" of type "list<User>" set to wrong type'
+            )
+
+    @property
+    def userId(self):
+        """str: Starfleet ID of the user if personal key is used"""
+        return self._userId
 
-    @teamName.setter
-    def teamName(self, value):
+    @userId.setter
+    def userId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+            self._userId = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "userId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._labels:
-            result["labels"] = \
-                self._labels.toDict() if self._labels is not None else None
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
+        if self._products is not None:
+            result["products"] = \
+                self._products
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
+        if self._type is not None:
+            result["type"] = \
+                self._type
+        if self._user:
+            result["user"] = \
+                self._user.toDict() if self._user is not None else None
+        if self._userId is not None:
+            result["userId"] = \
+                self._userId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._labels is not None): self._labels.isValid()
+        if (self._user is not None): self._user.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobLabelUpdateRequest.py` & `ngcbpc/data/uis/UserProfileOrgInfo.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,124 +14,153 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobLabelUpdateRequest(object):
-    """request to update labels of a job."""
+class UserProfileOrgInfo(object):
+    """The organization information of user."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.lockLabels = (
+        self.industry = (
             None if not fromDict or propDict.get(
-                "lockLabels"
+                "industry"
             ) is None
-            else propDict["lockLabels"])
-        self.reservedLabels = (
+            else propDict["industry"])
+        self.jobRole = (
             None if not fromDict or propDict.get(
-                "reservedLabels"
+                "jobRole"
             ) is None
-            else propDict["reservedLabels"])
-        self.systemLabels = (
+            else propDict["jobRole"])
+        self.jobTitle = (
             None if not fromDict or propDict.get(
-                "systemLabels"
+                "jobTitle"
             ) is None
-            else propDict["systemLabels"])
-        self.userLabels = (
+            else propDict["jobTitle"])
+        self.organization = (
             None if not fromDict or propDict.get(
-                "userLabels"
+                "organization"
             ) is None
-            else propDict["userLabels"])
+            else propDict["organization"])
+        self.organizationUrl = (
+            None if not fromDict or propDict.get(
+                "organizationUrl"
+            ) is None
+            else propDict["organizationUrl"])
+
+    @property
+    def industry(self):
+        """str: Industry segment"""
+        return self._industry
+
+    @industry.setter
+    def industry(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._industry = value
+        else:
+            raise TypeError(
+                'Property "industry" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def lockLabels(self):
-        """bool: Indicates whether the labels will be locked or not"""
-        return self._lockLabels
-
-    @lockLabels.setter
-    def lockLabels(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._lockLabels = value
+    def jobRole(self):
+        """str: Role of the user in the organization"""
+        return self._jobRole
+
+    @jobRole.setter
+    def jobRole(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._jobRole = value
         else:
             raise TypeError(
-                'Property "lockLabels" of type "list<bool>" set to wrong type'
+                'Property "jobRole" of type "list<str>" set to wrong type'
             )
 
     @property
-    def reservedLabels(self):
-        """list: An array of reserved labels"""
-        return self._reservedLabels
-
-    @reservedLabels.setter
-    def reservedLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._reservedLabels = value
+    def jobTitle(self):
+        """str: Title of the user in the organization"""
+        return self._jobTitle
+
+    @jobTitle.setter
+    def jobTitle(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._jobTitle = value
         else:
             raise TypeError(
-                'Property "reservedLabels" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "jobTitle" of type "list<str>" set to wrong type'
             )
 
     @property
-    def systemLabels(self):
-        """list: An array of system labels"""
-        return self._systemLabels
-
-    @systemLabels.setter
-    def systemLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._systemLabels = value
+    def organization(self):
+        """str: Name of the organization"""
+        return self._organization
+
+    @organization.setter
+    def organization(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._organization = value
         else:
             raise TypeError(
-                'Property "systemLabels" of type "list<str>" set to wrong typ'
+                'Property "organization" of type "list<str>" set to wrong typ'
                 'e'
             )
 
     @property
-    def userLabels(self):
-        """list: An array of user labels that describe this job"""
-        return self._userLabels
-
-    @userLabels.setter
-    def userLabels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._userLabels = value
+    def organizationUrl(self):
+        """str: Organization URL"""
+        return self._organizationUrl
+
+    @organizationUrl.setter
+    def organizationUrl(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._organizationUrl = value
         else:
             raise TypeError(
-                'Property "userLabels" of type "list<str>" set to wrong type'
+                'Property "organizationUrl" of type "list<str>" set to wrong '
+                'type'
             )
 
     def toDict(self):
         result = {}
-        if self._lockLabels is not None:
-            result["lockLabels"] = \
-                self._lockLabels
-        if self._reservedLabels is not None:
-            result["reservedLabels"] = \
-                self._reservedLabels
-        if self._systemLabels is not None:
-            result["systemLabels"] = \
-                self._systemLabels
-        if self._userLabels is not None:
-            result["userLabels"] = \
-                self._userLabels
+        if self._industry is not None:
+            result["industry"] = \
+                self._industry
+        if self._jobRole is not None:
+            result["jobRole"] = \
+                self._jobRole
+        if self._jobTitle is not None:
+            result["jobTitle"] = \
+                self._jobTitle
+        if self._organization is not None:
+            result["organization"] = \
+                self._organization
+        if self._organizationUrl is not None:
+            result["organizationUrl"] = \
+                self._organizationUrl
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._organization is None:
+            raise ValueError(
+                "UserProfileOrgInfo.organization doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/JobLabels.py` & `ngcbpc/data/uis/UpdateUisOrgInfoRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,142 +6,133 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SystemLabels import SystemLabels
-from .ReservedLabels import ReservedLabels
-from .UserLabels import UserLabels
 
 # Unused import over optimization prevention
-str(repr(UserLabels))
-str(repr(SystemLabels))
-str(repr(ReservedLabels))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobLabels(object):
-    """All the labels specified by user or admin that descibe this job"""
+class UpdateUisOrgInfoRequest(object):
+    """Update the info about an organizations"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.isLocked = (
+        self.emsOrgUniqueIdentifier = (
             None if not fromDict or propDict.get(
-                "isLocked"
+                "emsOrgUniqueIdentifier"
             ) is None
-            else propDict["isLocked"])
-        self.reservedLabels = (
+            else propDict["emsOrgUniqueIdentifier"])
+        self.isInternal = (
             None if not fromDict or propDict.get(
-                "reservedLabels"
+                "isInternal"
             ) is None
-            else propDict["reservedLabels"])
-        self.systemLabels = (
+            else propDict["isInternal"])
+        self.orgOwnerIds = (
             None if not fromDict or propDict.get(
-                "systemLabels"
+                "orgOwnerIds"
             ) is None
-            else propDict["systemLabels"])
-        self.userLabels = (
+            else propDict["orgOwnerIds"])
+        self.productAccessTier = (
             None if not fromDict or propDict.get(
-                "userLabels"
+                "productAccessTier"
             ) is None
-            else propDict["userLabels"])
+            else propDict["productAccessTier"])
 
     @property
-    def isLocked(self):
-        """bool: Indicates whether the labels of this job are locked or not"""
-        return self._isLocked
-
-    @isLocked.setter
-    def isLocked(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isLocked = value
+    def emsOrgUniqueIdentifier(self):
+        """ """
+        return self._emsOrgUniqueIdentifier
+
+    @emsOrgUniqueIdentifier.setter
+    def emsOrgUniqueIdentifier(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._emsOrgUniqueIdentifier = value
         else:
             raise TypeError(
-                'Property "isLocked" of type "list<bool>" set to wrong type'
+                'Property "emsOrgUniqueIdentifier" of type "list<str>" set to'
+                ' wrong type'
             )
 
     @property
-    def reservedLabels(self):
-        """ReservedLabels: Reserved labels specified by the user or admin"""
-        return self._reservedLabels
-
-    @reservedLabels.setter
-    def reservedLabels(self, value):
-        if value is not None and not isinstance(value, ReservedLabels):
-            value = ReservedLabels(value)
-        if (value is None) or isinstance(value, ReservedLabels):
-            self._reservedLabels = value
+    def isInternal(self):
+        """bool: Is NVIDIA internal org or not"""
+        return self._isInternal
+
+    @isInternal.setter
+    def isInternal(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isInternal = value
         else:
             raise TypeError(
-                'Property "reservedLabels" of type "list<ReservedLabels>" set'
-                ' to wrong type'
+                'Property "isInternal" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def systemLabels(self):
-        """SystemLabels: System labels specified by admin"""
-        return self._systemLabels
-
-    @systemLabels.setter
-    def systemLabels(self, value):
-        if value is not None and not isinstance(value, SystemLabels):
-            value = SystemLabels(value)
-        if (value is None) or isinstance(value, SystemLabels):
-            self._systemLabels = value
+    def orgOwnerIds(self):
+        """list: List of Org owner ids."""
+        return self._orgOwnerIds
+
+    @orgOwnerIds.setter
+    def orgOwnerIds(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._orgOwnerIds = value
         else:
             raise TypeError(
-                'Property "systemLabels" of type "list<SystemLabels>" set to '
-                'wrong type'
+                'Property "orgOwnerIds" of type "list<long>" set to wrong typ'
+                'e'
             )
 
     @property
-    def userLabels(self):
-        """UserLabels: User labels specified by the user or admin"""
-        return self._userLabels
-
-    @userLabels.setter
-    def userLabels(self, value):
-        if value is not None and not isinstance(value, UserLabels):
-            value = UserLabels(value)
-        if (value is None) or isinstance(value, UserLabels):
-            self._userLabels = value
+    def productAccessTier(self):
+        """ """
+        return self._productAccessTier
+
+    @productAccessTier.setter
+    def productAccessTier(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productAccessTier = value
         else:
             raise TypeError(
-                'Property "userLabels" of type "list<UserLabels>" set to wron'
+                'Property "productAccessTier" of type "list<str>" set to wron'
                 'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._isLocked is not None:
-            result["isLocked"] = \
-                self._isLocked
-        if self._reservedLabels:
-            result["reservedLabels"] = \
-                self._reservedLabels.toDict() if self._reservedLabels is not None else None
-        if self._systemLabels:
-            result["systemLabels"] = \
-                self._systemLabels.toDict() if self._systemLabels is not None else None
-        if self._userLabels:
-            result["userLabels"] = \
-                self._userLabels.toDict() if self._userLabels is not None else None
+        if self._emsOrgUniqueIdentifier is not None:
+            result["emsOrgUniqueIdentifier"] = \
+                self._emsOrgUniqueIdentifier
+        if self._isInternal is not None:
+            result["isInternal"] = \
+                self._isInternal
+        if self._orgOwnerIds is not None:
+            result["orgOwnerIds"] = \
+                self._orgOwnerIds
+        if self._productAccessTier is not None:
+            result["productAccessTier"] = \
+                self._productAccessTier
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._userLabels is not None): self._userLabels.isValid()
-        if (self._reservedLabels is not None): self._reservedLabels.isValid()
-        if (self._systemLabels is not None): self._systemLabels.isValid()
         return True
```

## Comparing `ngccli/data/api/JobListResponse.py` & `ngcbpc/data/registry/MetaImageDetailsList.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,88 +7,73 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .Job import Job
 from .RequestStatus import RequestStatus
-from .MetaData import MetaData
+from .MetaImageDetails import MetaImageDetails
 
 # Unused import over optimization prevention
-str(repr(Job))
+str(repr(MetaImageDetails))
 str(repr(RequestStatus))
 str(repr(PaginationInfo))
-str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobListResponse(object):
-    """listing of all jobs with filters applied"""
+class MetaImageDetailsList(object):
+    """Repository images list"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filters = (
+        self.images = (
             None if not fromDict or propDict.get(
-                "filters"
+                "images"
             ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
-        self.jobs = (
-            None if not fromDict or propDict.get(
-                "jobs"
-            ) is None
-            else [ Job(i)
-            for i in propDict["jobs"] ])
+            else [ MetaImageDetails(i)
+            for i in propDict["images"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
+        self.repositoryName = (
+            None if not fromDict or propDict.get(
+                "repositoryName"
+            ) is None
+            else propDict["repositoryName"])
+        self.repositoryNamespace = (
+            None if not fromDict or propDict.get(
+                "repositoryNamespace"
+            ) is None
+            else propDict["repositoryNamespace"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
-
-    @filters.setter
-    def filters(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._filters = value
-        else:
-            raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def jobs(self):
-        """list: array of object that describes submitted job"""
-        return self._jobs
+    def images(self):
+        """list: Images in repository"""
+        return self._images
 
-    @jobs.setter
-    def jobs(self, value):
+    @images.setter
+    def images(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._jobs = value
+            self._images = value
         else:
             raise TypeError(
-                'Property "jobs" of type "list<Job>" set to wrong type'
+                'Property "images" of type "list<MetaImageDetails>" set to wr'
+                'ong type'
             )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
@@ -101,14 +86,48 @@
         else:
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
+    def repositoryName(self):
+        """str: Repository name"""
+        return self._repositoryName
+
+    @repositoryName.setter
+    def repositoryName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._repositoryName = value
+        else:
+            raise TypeError(
+                'Property "repositoryName" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def repositoryNamespace(self):
+        """str: Repository namespace (org) or (org/team)"""
+        return self._repositoryNamespace
+
+    @repositoryNamespace.setter
+    def repositoryNamespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._repositoryNamespace = value
+        else:
+            raise TypeError(
+                'Property "repositoryNamespace" of type "list<str>" set to wr'
+                'ong type'
+            )
+
+    @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
@@ -119,41 +138,40 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
-        if self._jobs:
-            result["jobs"] = [
-                i.toDict() for i in self._jobs 
-            ] if self._jobs else []
+        if self._images:
+            result["images"] = [
+                i.toDict() for i in self._images 
+            ] if self._images else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._repositoryName is not None:
+            result["repositoryName"] = \
+                self._repositoryName
+        if self._repositoryNamespace is not None:
+            result["repositoryNamespace"] = \
+                self._repositoryNamespace
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._filters is not None):
-            for obj in self._filters:
-                if (obj is not None): obj.isValid()
-        if (self._jobs is not None):
-            for obj in self._jobs:
+        if (self._images is not None):
+            for obj in self._images:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobNodeCreateRequest.py` & `ngcbpc/data/model/CollectionUpdateRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,324 +6,344 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SCPJobDetails import SCPJobDetails
-from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
-from .JobPriorityEnum import JobPriorityEnum
-from .JobDefinition import JobDefinition
-from .Secret import Secret
+from .CollectionCategoryType import CollectionCategoryTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(SCPJobDetails))
-str(repr(JobDefinition))
-str(repr(Secret))
-str(repr(JobPriorityEnum))
-str(repr(TargetSystemUserIdentifier))
+str(repr(ArtifactAttribute))
+str(repr(CollectionCategoryTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobNodeCreateRequest(object):
-    """object used to send request from cloud to node to create a job"""
+class CollectionUpdateRequest(object):
+    """Request to update a collection"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.authClientId = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "authClientId"
+                "attributes"
             ) is None
-            else propDict["authClientId"])
-        self.authClientSecret = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "authClientSecret"
+                "builtBy"
             ) is None
-            else propDict["authClientSecret"])
-        self.dockerToken = (
+            else propDict["builtBy"])
+        self.category = (
             None if not fromDict or propDict.get(
-                "dockerToken"
+                "category"
             ) is None
-            else propDict["dockerToken"])
-        self.encryptedUserSecrets = (
+            else propDict["category"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "encryptedUserSecrets"
+                "description"
             ) is None
-            else [ Secret(i)
-            for i in propDict["encryptedUserSecrets"] ])
-        self.jobDefinition = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "jobDefinition"
+                "displayName"
             ) is None
-            else propDict["jobDefinition"])
-        self.jobId = (
+            else propDict["displayName"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "labels"
             ) is None
-            else propDict["jobId"])
-        self.jobOrder = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "jobOrder"
+                "labelsV2"
             ) is None
-            else propDict["jobOrder"])
-        self.jobPriority = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "jobPriority"
+                "logo"
             ) is None
-            else propDict["jobPriority"])
-        self.scpJobDetails = (
+            else propDict["logo"])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "scpJobDetails"
+                "ownerName"
             ) is None
-            else propDict["scpJobDetails"])
-        self.targetSystemUserIdentifier = (
+            else propDict["ownerName"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "targetSystemUserIdentifier"
+                "publisher"
             ) is None
-            else propDict["targetSystemUserIdentifier"])
+            else propDict["publisher"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
 
     @property
-    def authClientId(self):
-        """str: Client ID to be used for this Job"""
-        return self._authClientId
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
 
-    @authClientId.setter
-    def authClientId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._authClientId = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "authClientId" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def authClientSecret(self):
-        """str: Client Secret to be used for this Job"""
-        return self._authClientSecret
+    def builtBy(self):
+        """str: organization that built the collection"""
+        return self._builtBy
 
-    @authClientSecret.setter
-    def authClientSecret(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authClientSecret = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "authClientSecret" of type "list<str>" set to wrong'
-                ' type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def dockerToken(self):
-        """str: docker token that is associated with the user requesting a job
-        """
-        return self._dockerToken
+    def category(self):
+        """ """
+        return self._category
 
-    @dockerToken.setter
-    def dockerToken(self, value):
+    @category.setter
+    def category(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._category = value
+        else:
+            raise TypeError(
+                'Property "category" of type "list<CollectionCategoryTypeEnum'
+                '>" set to wrong type'
+            )
+
+    @property
+    def description(self):
+        """str: Description of the collection"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dockerToken = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "dockerToken" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def encryptedUserSecrets(self):
-        """list: List of encrypted user secrets associated to the job"""
-        return self._encryptedUserSecrets
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @encryptedUserSecrets.setter
-    def encryptedUserSecrets(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._encryptedUserSecrets = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "encryptedUserSecrets" of type "list<Secret>" set t'
-                'o wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobDefinition(self):
-        """JobDefinition: This object is populated when job request is submitt
-        ed by the user"""
-        return self._jobDefinition
+    def labels(self):
+        """ """
+        return self._labels
 
-    @jobDefinition.setter
-    def jobDefinition(self, value):
-        if value is not None and not isinstance(value, JobDefinition):
-            value = JobDefinition(value)
-        if (value is None) or isinstance(value, JobDefinition):
-            self._jobDefinition = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "jobDefinition" of type "list<JobDefinition>" set t'
-                'o wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: unique identifier of the job"""
-        return self._jobId
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobOrder(self):
-        """int: The order of job. Job order is from 1 to 99. Default value is 
-        50"""
-        return self._jobOrder
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @jobOrder.setter
-    def jobOrder(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._jobOrder = value
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
         else:
             raise TypeError(
-                'Property "jobOrder" of type "list<int>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobPriority(self):
-        """JobPriorityEnum: Indicates the job priority enum"""
-        return self._jobPriority
+    def ownerName(self):
+        """str: Name of the user who owns this collection"""
+        return self._ownerName
 
-    @jobPriority.setter
-    def jobPriority(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._jobPriority = value
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "jobPriority" of type "list<JobPriorityEnum>" set t'
-                'o wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def scpJobDetails(self):
-        """SCPJobDetails: Metadata used by storage control plane during base c
-        ommand job submission"""
-        return self._scpJobDetails
+    def publisher(self):
+        """str: organization that published the collection"""
+        return self._publisher
 
-    @scpJobDetails.setter
-    def scpJobDetails(self, value):
-        if value is not None and not isinstance(value, SCPJobDetails):
-            value = SCPJobDetails(value)
-        if (value is None) or isinstance(value, SCPJobDetails):
-            self._scpJobDetails = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "scpJobDetails" of type "list<SCPJobDetails>" set t'
-                'o wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def targetSystemUserIdentifier(self):
-        """TargetSystemUserIdentifier: Information about the user who is attem
-        pting to run the job"""
-        return self._targetSystemUserIdentifier
+    def shortDescription(self):
+        """str: Short description of the collection"""
+        return self._shortDescription
 
-    @targetSystemUserIdentifier.setter
-    def targetSystemUserIdentifier(self, value):
-        if value is not None and not isinstance(value, TargetSystemUserIdentifier):
-            value = TargetSystemUserIdentifier(value)
-        if (value is None) or isinstance(value, TargetSystemUserIdentifier):
-            self._targetSystemUserIdentifier = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "targetSystemUserIdentifier" of type "list<TargetSy'
-                'stemUserIdentifier>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._authClientId is not None:
-            result["authClientId"] = \
-                self._authClientId
-        if self._authClientSecret is not None:
-            result["authClientSecret"] = \
-                self._authClientSecret
-        if self._dockerToken is not None:
-            result["dockerToken"] = \
-                self._dockerToken
-        if self._encryptedUserSecrets:
-            result["encryptedUserSecrets"] = [
-                i.toDict() for i in self._encryptedUserSecrets 
-            ] if self._encryptedUserSecrets else []
-        if self._jobDefinition:
-            result["jobDefinition"] = \
-                self._jobDefinition.toDict() if self._jobDefinition is not None else None
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._jobOrder is not None:
-            result["jobOrder"] = \
-                self._jobOrder
-        if self._jobPriority is not None:
-            result["jobPriority"] = \
-                self._jobPriority
-        if self._scpJobDetails:
-            result["scpJobDetails"] = \
-                self._scpJobDetails.toDict() if self._scpJobDetails is not None else None
-        if self._targetSystemUserIdentifier:
-            result["targetSystemUserIdentifier"] = \
-                self._targetSystemUserIdentifier.toDict() if self._targetSystemUserIdentifier is not None else None
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._category is not None:
+            result["category"] = \
+                self._category
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobId is None:
+        if (self._shortDescription is not None
+            and
+            len(self._shortDescription) > 255):
             raise ValueError(
-                "JobNodeCreateRequest.jobId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._dockerToken is None:
+                "CollectionUpdateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
+            and
+            len(self._displayName) < 2):
             raise ValueError(
-                "JobNodeCreateRequest.dockerToken doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._jobOrder is not None
+                "CollectionUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "CollectionUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._logo is not None
+            and
+            len(self._logo) > 255):
+            raise ValueError(
+                "CollectionUpdateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
             and
-            self._jobOrder < 1):
+            len(self._publisher) > 255):
             raise ValueError(
-                "JobNodeCreateRequest.jobOrder: " + str(self._jobOrder) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._jobOrder is not None
+                "CollectionUpdateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._ownerName is not None
             and
-            self._jobOrder > 99):
+            len(self._ownerName) > 255):
             raise ValueError(
-                "JobNodeCreateRequest.jobOrder: " + str(self._jobOrder) + 
-                " doesnt match requirement: maximum: 99")
-        if (self._targetSystemUserIdentifier is not None): self._targetSystemUserIdentifier.isValid()
-        if (self._encryptedUserSecrets is not None):
-            for obj in self._encryptedUserSecrets:
+                "CollectionUpdateRequest.ownerName: " + str(self._ownerName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
                 if (obj is not None): obj.isValid()
-        if (self._scpJobDetails is not None): self._scpJobDetails.isValid()
-        if (self._jobDefinition is not None): self._jobDefinition.isValid()
         return True
```

## Comparing `ngccli/data/api/JobNodeDeleteRequest.py` & `organization/data/subscription_management_service/MetaData.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,85 +14,85 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobNodeDeleteRequest(object):
-    """object used to send request from cloud to the node to delete a job"""
+class MetaData(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.dockerToken = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "dockerToken"
+                "key"
             ) is None
-            else propDict["dockerToken"])
-        self.jobId = (
+            else propDict["key"])
+        self.value = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "value"
             ) is None
-            else propDict["jobId"])
+            else propDict["value"])
 
     @property
-    def dockerToken(self):
-        """str: docker token that is associated with the user requesting a job
-        """
-        return self._dockerToken
+    def key(self):
+        """ """
+        return self._key
 
-    @dockerToken.setter
-    def dockerToken(self, value):
+    @key.setter
+    def key(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dockerToken = value
+            self._key = value
         else:
             raise TypeError(
-                'Property "dockerToken" of type "list<str>" set to wrong type'
+                'Property "key" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: unique identifier of the job"""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    def value(self):
+        """ """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._value = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._dockerToken is not None:
-            result["dockerToken"] = \
-                self._dockerToken
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobId is None:
+        if (self._key is not None
+            and
+            len(self._key) > 255):
             raise ValueError(
-                "JobNodeDeleteRequest.jobId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._dockerToken is None:
+                "MetaData.key: " + str(self._key) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._value is not None
+            and
+            len(self._value) > 255):
             raise ValueError(
-                "JobNodeDeleteRequest.dockerToken doesnt match requirement:" 
-                "required: True"
-            )
+                "MetaData.value: " + str(self._value) + 
+                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/JobNodePreemptRequest.py` & `organization/data/subscription_management_service/RedeemSubscriptionRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,63 +6,91 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .BusinessContact import BusinessContact
 
 # Unused import over optimization prevention
+str(repr(BusinessContact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobNodePreemptRequest(object):
-    """object used to send request from cloud to the node to preempt a job"""
+class RedeemSubscriptionRequest(object):
+    """Redeem subscription request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobId = (
+        self.businessContact = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "businessContact"
             ) is None
-            else propDict["jobId"])
+            else propDict["businessContact"])
+        self.codes = (
+            None if not fromDict or propDict.get(
+                "codes"
+            ) is None
+            else propDict["codes"])
+
+    @property
+    def businessContact(self):
+        """ """
+        return self._businessContact
+
+    @businessContact.setter
+    def businessContact(self, value):
+        if value is not None and not isinstance(value, BusinessContact):
+            value = BusinessContact(value)
+        if (value is None) or isinstance(value, BusinessContact):
+            self._businessContact = value
+        else:
+            raise TypeError(
+                'Property "businessContact" of type "list<BusinessContact>" s'
+                'et to wrong type'
+            )
 
     @property
-    def jobId(self):
-        """long: unique identifier of the job"""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    def codes(self):
+        """list: codes/serial numbers to redeem offer"""
+        return self._codes
+
+    @codes.setter
+    def codes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._codes = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "codes" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
+        if self._businessContact:
+            result["businessContact"] = \
+                self._businessContact.toDict() if self._businessContact is not None else None
+        if self._codes is not None:
+            result["codes"] = \
+                self._codes
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobId is None:
+        if self._codes is None:
             raise ValueError(
-                "JobNodePreemptRequest.jobId doesnt match requirement:" 
+                "RedeemSubscriptionRequest.codes doesnt match requirement:" 
                 "required: True"
             )
+        if (self._businessContact is not None): self._businessContact.isValid()
         return True
```

## Comparing `ngccli/data/api/JobNodeResumeRequest.py` & `ngcbpc/data/uis/UpdateApiKeyRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,64 +6,91 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ApiKeyPolicy import ApiKeyPolicy
+from .ApiKeyStatusEnum import ApiKeyStatusEnum
 
 # Unused import over optimization prevention
+str(repr(ApiKeyPolicy))
+str(repr(ApiKeyStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobNodeResumeRequest(object):
-    """object used to send request from cloud to the node to resume a preempte
-    d job"""
+class UpdateApiKeyRequest(object):
+    """Update api key request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobId = (
+        self.policies = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "policies"
             ) is None
-            else propDict["jobId"])
+            else [ ApiKeyPolicy(i)
+            for i in propDict["policies"] ])
+        self.status = (
+            None if not fromDict or propDict.get(
+                "status"
+            ) is None
+            else propDict["status"])
+
+    @property
+    def policies(self):
+        """list: Access permissions of the key"""
+        return self._policies
+
+    @policies.setter
+    def policies(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._policies = value
+        else:
+            raise TypeError(
+                'Property "policies" of type "list<ApiKeyPolicy>" set to wron'
+                'g type'
+            )
 
     @property
-    def jobId(self):
-        """long: unique identifier of the job"""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    def status(self):
+        """ApiKeyStatusEnum: Possible api key statuses"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "status" of type "list<ApiKeyStatusEnum>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
+        if self._policies:
+            result["policies"] = [
+                i.toDict() for i in self._policies 
+            ] if self._policies else []
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobId is None:
-            raise ValueError(
-                "JobNodeResumeRequest.jobId doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._policies is not None):
+            for obj in self._policies:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/JobPortMapping.py` & `basecommand/data/pym/ClusterPortMapping.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobPortMapping(object):
+class ClusterPortMapping(object):
     """Port mapping between host and container"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.containerPort = (
             None if not fromDict or propDict.get(
                 "containerPort"
             ) is None
@@ -179,21 +179,21 @@
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if (self._name is not None
             and
             len(self._name) > 10):
             raise ValueError(
-                "JobPortMapping.name: " + str(self._name) + 
+                "ClusterPortMapping.name: " + str(self._name) + 
                 " doesnt match requirement: maxLength: 10")
         if (self._name is not None
             and
             not re.match(
                 r"^([a-zA-Z])([a-zA-Z\d])*$",
                  self._name)):
             raise ValueError(
-                "JobPortMapping.name: " + str(self._name) + 
+                "ClusterPortMapping.name: " + str(self._name) + 
                 " doesnt match requirement: pattern: ^([a-zA-Z])([a-zA-Z\d])*"
                 "$")
         return True
```

## Comparing `ngccli/data/api/JobResponse.py` & `ngcbpc/data/registry/OciIndexResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,102 +6,84 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Job import Job
 from .RequestStatus import RequestStatus
-from .JobStatus import JobStatus
+from .OciIndexManifest import OciIndexManifest
 
 # Unused import over optimization prevention
-str(repr(JobStatus))
+str(repr(OciIndexManifest))
 str(repr(RequestStatus))
-str(repr(Job))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobResponse(object):
-    """Information about one job"""
+class OciIndexResponse(object):
+    """Oci index response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.job = (
+        self.manifests = (
             None if not fromDict or propDict.get(
-                "job"
+                "manifests"
             ) is None
-            else propDict["job"])
-        self.jobRequestJson = (
+            else [ OciIndexManifest(i)
+            for i in propDict["manifests"] ])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "jobRequestJson"
+                "mediaType"
             ) is None
-            else propDict["jobRequestJson"])
-        self.jobStatusHistory = (
-            None if not fromDict or propDict.get(
-                "jobStatusHistory"
-            ) is None
-            else [ JobStatus(i)
-            for i in propDict["jobStatusHistory"] ])
+            else propDict["mediaType"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.schemaVersion = (
+            None if not fromDict or propDict.get(
+                "schemaVersion"
+            ) is None
+            else propDict["schemaVersion"])
 
     @property
-    def job(self):
-        """Job: object that describes submitted job"""
-        return self._job
-
-    @job.setter
-    def job(self, value):
-        if value is not None and not isinstance(value, Job):
-            value = Job(value)
-        if (value is None) or isinstance(value, Job):
-            self._job = value
+    def manifests(self):
+        """ """
+        return self._manifests
+
+    @manifests.setter
+    def manifests(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._manifests = value
         else:
             raise TypeError(
-                'Property "job" of type "list<Job>" set to wrong type'
+                'Property "manifests" of type "list<OciIndexManifest>" set to'
+                ' wrong type'
             )
 
     @property
-    def jobRequestJson(self):
-        """str: JSON request that was used to create this Job"""
-        return self._jobRequestJson
+    def mediaType(self):
+        """str: defines version. must be 'application/vnd.oci.image.index.v1+j
+        son'"""
+        return self._mediaType
 
-    @jobRequestJson.setter
-    def jobRequestJson(self, value):
+    @mediaType.setter
+    def mediaType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._jobRequestJson = value
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "jobRequestJson" of type "list<str>" set to wrong t'
-                'ype'
-            )
-
-    @property
-    def jobStatusHistory(self):
-        """list: history of job status, sorted by most recent status first"""
-        return self._jobStatusHistory
-
-    @jobStatusHistory.setter
-    def jobStatusHistory(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._jobStatusHistory = value
-        else:
-            raise TypeError(
-                'Property "jobStatusHistory" of type "list<JobStatus>" set to'
-                ' wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -113,39 +95,55 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def schemaVersion(self):
+        """int: Response schema version"""
+        return self._schemaVersion
+
+    @schemaVersion.setter
+    def schemaVersion(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schemaVersion = value
+        else:
+            raise TypeError(
+                'Property "schemaVersion" of type "list<int>" set to wrong ty'
+                'pe'
+            )
+
     def toDict(self):
         result = {}
-        if self._job:
-            result["job"] = \
-                self._job.toDict() if self._job is not None else None
-        if self._jobRequestJson is not None:
-            result["jobRequestJson"] = \
-                self._jobRequestJson
-        if self._jobStatusHistory:
-            result["jobStatusHistory"] = [
-                i.toDict() for i in self._jobStatusHistory 
-            ] if self._jobStatusHistory else []
+        if self._manifests:
+            result["manifests"] = [
+                i.toDict() for i in self._manifests 
+            ] if self._manifests else []
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._schemaVersion is not None:
+            result["schemaVersion"] = \
+                self._schemaVersion
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._job is not None): self._job.isValid()
-        if (self._jobStatusHistory is not None):
-            for obj in self._jobStatusHistory:
+        if (self._manifests is not None):
+            for obj in self._manifests:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobResultsetMountInfo.py` & `ngcbpc/data/model/AssetStorageEvent.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,120 +6,136 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Asset import Asset
 
 # Unused import over optimization prevention
+str(repr(Asset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobResultsetMountInfo(object):
-    """This is used for data mover job and not regular GPU/CPU jobs"""
+class AssetStorageEvent(object):
+    """This event in the topic means that some change happened to the asset st
+    orage object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerMountPoint = (
+        self.asset = (
             None if not fromDict or propDict.get(
-                "containerMountPoint"
+                "asset"
             ) is None
-            else propDict["containerMountPoint"])
-        self.id = (
+            else propDict["asset"])
+        self.eventType = (
             None if not fromDict or propDict.get(
-                "id"
+                "eventType"
             ) is None
-            else propDict["id"])
-        self.mountMode = (
+            else propDict["eventType"])
+        self.timestamp = (
             None if not fromDict or propDict.get(
-                "mountMode"
+                "timestamp"
             ) is None
-            else propDict["mountMode"])
+            else propDict["timestamp"])
 
     @property
-    def containerMountPoint(self):
-        """str: Mount point inside the container to which this workspace will 
-        be mapped"""
-        return self._containerMountPoint
-
-    @containerMountPoint.setter
-    def containerMountPoint(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._containerMountPoint = value
+    def asset(self):
+        """Asset: Asset object"""
+        return self._asset
+
+    @asset.setter
+    def asset(self, value):
+        if value is not None and not isinstance(value, Asset):
+            value = Asset(value)
+        if (value is None) or isinstance(value, Asset):
+            self._asset = value
         else:
             raise TypeError(
-                'Property "containerMountPoint" of type "list<str>" set to wr'
-                'ong type'
+                'Property "asset" of type "list<Asset>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """str: Resultset ID"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._id = value
+    def eventType(self):
+        """EventTypeEnum: Asset storage event type"""
+        return self._eventType
+
+    @eventType.setter
+    def eventType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._eventType = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "eventType" of type "list<EventTypeEnum>" set to wr'
+                'ong type'
             )
 
-    @property
-    def mountMode(self):
-        """MountModeEnum: Permissions for the volume when mounted"""
-        return self._mountMode
+    EventTypeEnum=["ASSET_OBJECT_CREATED","ASSET_OBJECT_DELETED",]
+    str(repr(EventTypeEnum))  # Prevent optimizer removing enum
 
-    @mountMode.setter
-    def mountMode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._mountMode = value
+    @property
+    def timestamp(self):
+        """str: Timestamp in ISO-8601 format"""
+        return self._timestamp
+
+    @timestamp.setter
+    def timestamp(self, value):
+        if value is not None and not isinstance(value, str):
+            value = str(value)
+        if (value is None) or isinstance(value, str):
+            self._timestamp = value
         else:
             raise TypeError(
-                'Property "mountMode" of type "list<MountModeEnum>" set to wr'
-                'ong type'
+                'Property "timestamp" of type "list<str>" set to wrong type'
             )
 
-    MountModeEnum=["RO","RW",]
-    str(repr(MountModeEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._containerMountPoint is not None:
-            result["containerMountPoint"] = \
-                self._containerMountPoint
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._mountMode is not None:
-            result["mountMode"] = \
-                self._mountMode
+        if self._asset:
+            result["asset"] = \
+                self._asset.toDict() if self._asset is not None else None
+        if self._eventType is not None:
+            result["eventType"] = \
+                self._eventType
+        if self._timestamp is not None:
+            result["timestamp"] = \
+                self._timestamp
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._id is None:
+        if self._asset is None:
+            raise ValueError(
+                "AssetStorageEvent.asset doesnt match requirement:" 
+                "required: True"
+            )
+        if self._timestamp is None:
             raise ValueError(
-                "JobResultsetMountInfo.id doesnt match requirement:" 
+                "AssetStorageEvent.timestamp doesnt match requirement:" 
                 "required: True"
             )
-        if self._containerMountPoint is None:
+        if (self._timestamp is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._timestamp)):
+            raise ValueError(
+                "AssetStorageEvent.timestamp: " + str(self._timestamp) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if self._eventType is None:
             raise ValueError(
-                "JobResultsetMountInfo.containerMountPoint doesnt match requirement:" 
+                "AssetStorageEvent.eventType doesnt match requirement:" 
                 "required: True"
             )
+        if (self._asset is not None): self._asset.isValid()
         return True
```

## Comparing `ngccli/data/api/JobRunPolicy.py` & `ngcbpc/data/model/CloudServiceProviderUpdateRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,160 +6,186 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobRunPolicy(object):
-    """Kill policy of the job"""
+class CloudServiceProviderUpdateRequest(object):
+    """Request to update existing Cloud Service Provider"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.expirySeconds = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "expirySeconds"
+                "attributes"
             ) is None
-            else propDict["expirySeconds"])
-        self.minTimesliceSeconds = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "minTimesliceSeconds"
+                "description"
             ) is None
-            else propDict["minTimesliceSeconds"])
-        self.preemptClass = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "preemptClass"
+                "displayName"
             ) is None
-            else propDict["preemptClass"])
-        self.totalRuntimeSeconds = (
+            else propDict["displayName"])
+        self.isEnabled = (
             None if not fromDict or propDict.get(
-                "totalRuntimeSeconds"
+                "isEnabled"
             ) is None
-            else propDict["totalRuntimeSeconds"])
+            else propDict["isEnabled"])
+        self.labels = (
+            None if not fromDict or propDict.get(
+                "labels"
+            ) is None
+            else propDict["labels"])
+        self.logo = (
+            None if not fromDict or propDict.get(
+                "logo"
+            ) is None
+            else propDict["logo"])
 
     @property
-    def expirySeconds(self):
-        """long: Maximum duration in seconds from submission time during which
-         the job will be allowed to run. If not specified, or is 0, th
-        en ACE limit will be applied."""
-        return self._expirySeconds
-
-    @expirySeconds.setter
-    def expirySeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._expirySeconds = value
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "expirySeconds" of type "list<long>" set to wrong t'
-                'ype'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def minTimesliceSeconds(self):
-        """long: Minimum time in seconds job is expected (not guaranteed) to b
-        e in the RUNNING state once scheduled to assure forward progre
-        ss."""
-        return self._minTimesliceSeconds
-
-    @minTimesliceSeconds.setter
-    def minTimesliceSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._minTimesliceSeconds = value
+    def description(self):
+        """str: Description of the Cloud Service Provider"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "minTimesliceSeconds" of type "list<long>" set to w'
-                'rong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def preemptClass(self):
-        """PreemptClassEnum: Describes the job class for preemption and schedu
-        ling behavior. One of RESUMABLE, RESTARTABLE, or RUNONCE (defa
-        ult)."""
-        return self._preemptClass
-
-    @preemptClass.setter
-    def preemptClass(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._preemptClass = value
+    def displayName(self):
+        """str: Display name of the Cloud Service Provider"""
+        return self._displayName
+
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "preemptClass" of type "list<PreemptClassEnum>" set'
-                ' to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
-    PreemptClassEnum=["RESUMABLE","RESTARTABLE","RUNONCE",]
-    str(repr(PreemptClassEnum))  # Prevent optimizer removing enum
+    @property
+    def isEnabled(self):
+        """bool: Determines if this Cloud Service Provider is enabled"""
+        return self._isEnabled
+
+    @isEnabled.setter
+    def isEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isEnabled = value
+        else:
+            raise TypeError(
+                'Property "isEnabled" of type "list<bool>" set to wrong type'
+            )
 
     @property
-    def totalRuntimeSeconds(self):
-        """long: Maximum duration in seconds after which the job will be kille
-        d. If not specified, or is 0, then ACE limit will be applied."""
-        return self._totalRuntimeSeconds
+    def labels(self):
+        """list: Labels that are associated with the Cloud Service Provider"""
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
+        else:
+            raise TypeError(
+                'Property "labels" of type "list<str>" set to wrong type'
+            )
 
-    @totalRuntimeSeconds.setter
-    def totalRuntimeSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalRuntimeSeconds = value
+    @property
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
+
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
         else:
             raise TypeError(
-                'Property "totalRuntimeSeconds" of type "list<long>" set to w'
-                'rong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._expirySeconds is not None:
-            result["expirySeconds"] = \
-                self._expirySeconds
-        if self._minTimesliceSeconds is not None:
-            result["minTimesliceSeconds"] = \
-                self._minTimesliceSeconds
-        if self._preemptClass is not None:
-            result["preemptClass"] = \
-                self._preemptClass
-        if self._totalRuntimeSeconds is not None:
-            result["totalRuntimeSeconds"] = \
-                self._totalRuntimeSeconds
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._isEnabled is not None:
+            result["isEnabled"] = \
+                self._isEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._totalRuntimeSeconds is not None
-            and
-            self._totalRuntimeSeconds < 0):
-            raise ValueError(
-                "JobRunPolicy.totalRuntimeSeconds: " + str(self._totalRuntimeSeconds) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._minTimesliceSeconds is not None
-            and
-            self._minTimesliceSeconds < 0):
-            raise ValueError(
-                "JobRunPolicy.minTimesliceSeconds: " + str(self._minTimesliceSeconds) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._expirySeconds is not None
-            and
-            self._expirySeconds < 0):
-            raise ValueError(
-                "JobRunPolicy.expirySeconds: " + str(self._expirySeconds) + 
-                " doesnt match requirement: minimum: 0")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/JobSidecarContainer.py` & `basecommand/data/pym/ProjectTemplateParamsDeprecated.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,445 +6,475 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Env import Env
-from .JobWorkspaceMountInfo import JobWorkspaceMountInfo
-from .JobPortMapping import JobPortMapping
-from .JobDatasetMountInfo import JobDatasetMountInfo
-from .JobVolumeMount import JobVolumeMount
-from .JobHealthCheck import JobHealthCheck
-from .ContainerResources import ContainerResources
+from .DataInput import DataInput
 
 # Unused import over optimization prevention
-str(repr(Env))
-str(repr(JobPortMapping))
-str(repr(JobVolumeMount))
-str(repr(JobWorkspaceMountInfo))
-str(repr(JobHealthCheck))
-str(repr(ContainerResources))
-str(repr(JobDatasetMountInfo))
+str(repr(DataInput))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobSidecarContainer(object):
+class ProjectTemplateParamsDeprecated(object):
+    """Project template parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.command = (
+        self.ace = (
             None if not fromDict or propDict.get(
-                "command"
+                "ace"
             ) is None
-            else propDict["command"])
-        self.containerName = (
+            else propDict["ace"])
+        self.clusterLifetime = (
             None if not fromDict or propDict.get(
-                "containerName"
+                "clusterLifetime"
             ) is None
-            else propDict["containerName"])
-        self.containerResources = (
+            else propDict["clusterLifetime"])
+        self.containerImage = (
             None if not fromDict or propDict.get(
-                "containerResources"
+                "containerImage"
             ) is None
-            else propDict["containerResources"])
-        self.datasetMounts = (
+            else propDict["containerImage"])
+        self.dataInput = (
             None if not fromDict or propDict.get(
-                "datasetMounts"
+                "dataInput"
             ) is None
-            else [ JobDatasetMountInfo(i)
-            for i in propDict["datasetMounts"] ])
-        self.dockerImageName = (
+            else propDict["dataInput"])
+        self.dataOutputMountPoint = (
             None if not fromDict or propDict.get(
-                "dockerImageName"
+                "dataOutputMountPoint"
             ) is None
-            else propDict["dockerImageName"])
-        self.entryPoint = (
+            else propDict["dataOutputMountPoint"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "entryPoint"
+                "description"
             ) is None
-            else propDict["entryPoint"])
-        self.envs = (
+            else propDict["description"])
+        self.displayImageURL = (
             None if not fromDict or propDict.get(
-                "envs"
+                "displayImageURL"
             ) is None
-            else [ Env(i)
-            for i in propDict["envs"] ])
-        self.healthCheck = (
+            else propDict["displayImageURL"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "healthCheck"
+                "name"
             ) is None
-            else propDict["healthCheck"])
-        self.jobVolumeMounts = (
+            else propDict["name"])
+        self.nworkers = (
             None if not fromDict or propDict.get(
-                "jobVolumeMounts"
+                "nworkers"
             ) is None
-            else [ JobVolumeMount(i)
-            for i in propDict["jobVolumeMounts"] ])
-        self.portMappings = (
+            else propDict["nworkers"])
+        self.schedulerInstanceType = (
             None if not fromDict or propDict.get(
-                "portMappings"
+                "schedulerInstanceType"
             ) is None
-            else [ JobPortMapping(i)
-            for i in propDict["portMappings"] ])
-        self.publishedContainerPorts = (
+            else propDict["schedulerInstanceType"])
+        self.schedulerStartupScript = (
             None if not fromDict or propDict.get(
-                "publishedContainerPorts"
+                "schedulerStartupScript"
             ) is None
-            else propDict["publishedContainerPorts"])
-        self.resultContainerMountPoint = (
+            else propDict["schedulerStartupScript"])
+        self.workerInstanceType = (
             None if not fromDict or propDict.get(
-                "resultContainerMountPoint"
+                "workerInstanceType"
             ) is None
-            else propDict["resultContainerMountPoint"])
-        self.useImageEntryPoint = (
+            else propDict["workerInstanceType"])
+        self.workerStartupScript = (
             None if not fromDict or propDict.get(
-                "useImageEntryPoint"
+                "workerStartupScript"
             ) is None
-            else propDict["useImageEntryPoint"])
-        self.workspaceMounts = (
-            None if not fromDict or propDict.get(
-                "workspaceMounts"
-            ) is None
-            else [ JobWorkspaceMountInfo(i)
-            for i in propDict["workspaceMounts"] ])
+            else propDict["workerStartupScript"])
 
     @property
-    def command(self):
-        """str: Run command to be associated with the container."""
-        return self._command
+    def ace(self):
+        """str: ACE instance"""
+        return self._ace
 
-    @command.setter
-    def command(self, value):
+    @ace.setter
+    def ace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._command = value
+            self._ace = value
         else:
             raise TypeError(
-                'Property "command" of type "list<str>" set to wrong type'
+                'Property "ace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def containerName(self):
-        """str: Name of the init container, MUST be unique among all helper co
-        ntainers."""
-        return self._containerName
+    def clusterLifetime(self):
+        """str: Cluster lifetime"""
+        return self._clusterLifetime
 
-    @containerName.setter
-    def containerName(self, value):
+    @clusterLifetime.setter
+    def clusterLifetime(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerName = value
+            self._clusterLifetime = value
         else:
             raise TypeError(
-                'Property "containerName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "clusterLifetime" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def containerResources(self):
-        """ """
-        return self._containerResources
+    def containerImage(self):
+        """str: Container image"""
+        return self._containerImage
 
-    @containerResources.setter
-    def containerResources(self, value):
-        if value is not None and not isinstance(value, ContainerResources):
-            value = ContainerResources(value)
-        if (value is None) or isinstance(value, ContainerResources):
-            self._containerResources = value
+    @containerImage.setter
+    def containerImage(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._containerImage = value
         else:
             raise TypeError(
-                'Property "containerResources" of type "list<ContainerResourc'
-                'es>" set to wrong type'
+                'Property "containerImage" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def datasetMounts(self):
-        """ """
-        return self._datasetMounts
+    def dataInput(self):
+        """DataInput: Data Input"""
+        return self._dataInput
 
-    @datasetMounts.setter
-    def datasetMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._datasetMounts = value
+    @dataInput.setter
+    def dataInput(self, value):
+        if value is not None and not isinstance(value, DataInput):
+            value = DataInput(value)
+        if (value is None) or isinstance(value, DataInput):
+            self._dataInput = value
         else:
             raise TypeError(
-                'Property "datasetMounts" of type "list<JobDatasetMountInfo>"'
-                ' set to wrong type'
+                'Property "dataInput" of type "list<DataInput>" set to wrong '
+                'type'
             )
 
     @property
-    def dockerImageName(self):
-        """str: Docker container image name to use when submitting this job. P
-        rovide full namespace - org/team/repo:tag. If tag is not speci
-        fied, latest will be used by default."""
-        return self._dockerImageName
+    def dataOutputMountPoint(self):
+        """str: Data output results mount point"""
+        return self._dataOutputMountPoint
 
-    @dockerImageName.setter
-    def dockerImageName(self, value):
+    @dataOutputMountPoint.setter
+    def dataOutputMountPoint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._dockerImageName = value
+            self._dataOutputMountPoint = value
         else:
             raise TypeError(
-                'Property "dockerImageName" of type "list<str>" set to wrong '
-                'type'
+                'Property "dataOutputMountPoint" of type "list<str>" set to w'
+                'rong type'
             )
 
     @property
-    def entryPoint(self):
-        """str: Overwrite the default ENTRYPOINT of the image"""
-        return self._entryPoint
+    def description(self):
+        """str: Project template description"""
+        return self._description
 
-    @entryPoint.setter
-    def entryPoint(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._entryPoint = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "entryPoint" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def envs(self):
-        """list: List of environment variables associated to the job"""
-        return self._envs
+    def displayImageURL(self):
+        """str: Display Image URL"""
+        return self._displayImageURL
 
-    @envs.setter
-    def envs(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._envs = value
+    @displayImageURL.setter
+    def displayImageURL(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayImageURL = value
         else:
             raise TypeError(
-                'Property "envs" of type "list<Env>" set to wrong type'
+                'Property "displayImageURL" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def healthCheck(self):
-        """ """
-        return self._healthCheck
+    def name(self):
+        """str: Project template name"""
+        return self._name
 
-    @healthCheck.setter
-    def healthCheck(self, value):
-        if value is not None and not isinstance(value, JobHealthCheck):
-            value = JobHealthCheck(value)
-        if (value is None) or isinstance(value, JobHealthCheck):
-            self._healthCheck = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "healthCheck" of type "list<JobHealthCheck>" set to'
-                ' wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobVolumeMounts(self):
-        """list: A list of job volume mount points in the init container."""
-        return self._jobVolumeMounts
+    def nworkers(self):
+        """int: Number of workers"""
+        return self._nworkers
 
-    @jobVolumeMounts.setter
-    def jobVolumeMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._jobVolumeMounts = value
+    @nworkers.setter
+    def nworkers(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._nworkers = value
         else:
             raise TypeError(
-                'Property "jobVolumeMounts" of type "list<JobVolumeMount>" se'
-                't to wrong type'
+                'Property "nworkers" of type "list<int>" set to wrong type'
             )
 
     @property
-    def portMappings(self):
-        """list: Actual port mappings used for the job"""
-        return self._portMappings
+    def schedulerInstanceType(self):
+        """str: Scheduler Instance type"""
+        return self._schedulerInstanceType
 
-    @portMappings.setter
-    def portMappings(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._portMappings = value
+    @schedulerInstanceType.setter
+    def schedulerInstanceType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._schedulerInstanceType = value
         else:
             raise TypeError(
-                'Property "portMappings" of type "list<JobPortMapping>" set t'
-                'o wrong type'
+                'Property "schedulerInstanceType" of type "list<str>" set to '
+                'wrong type'
             )
 
     @property
-    def publishedContainerPorts(self):
-        """list: List of ports to be published from the container. These will 
-        be bound to random ports on hosts. Mapping can be found in res
-        ulting Job Status."""
-        return self._publishedContainerPorts
+    def schedulerStartupScript(self):
+        """str: Scheduler startup script"""
+        return self._schedulerStartupScript
 
-    @publishedContainerPorts.setter
-    def publishedContainerPorts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._publishedContainerPorts = value
+    @schedulerStartupScript.setter
+    def schedulerStartupScript(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._schedulerStartupScript = value
         else:
             raise TypeError(
-                'Property "publishedContainerPorts" of type "list<int>" set t'
-                'o wrong type'
+                'Property "schedulerStartupScript" of type "list<str>" set to'
+                ' wrong type'
             )
 
     @property
-    def resultContainerMountPoint(self):
-        """str: Mount Point inside container to which result set mount will be
-         mapped"""
-        return self._resultContainerMountPoint
+    def workerInstanceType(self):
+        """str: Worker Instance type"""
+        return self._workerInstanceType
 
-    @resultContainerMountPoint.setter
-    def resultContainerMountPoint(self, value):
+    @workerInstanceType.setter
+    def workerInstanceType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resultContainerMountPoint = value
+            self._workerInstanceType = value
         else:
             raise TypeError(
-                'Property "resultContainerMountPoint" of type "list<str>" set'
-                ' to wrong type'
+                'Property "workerInstanceType" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def useImageEntryPoint(self):
-        """bool: opt-in flag for enabling image entrypoint."""
-        return self._useImageEntryPoint
+    def workerStartupScript(self):
+        """str: Worker startup script"""
+        return self._workerStartupScript
 
-    @useImageEntryPoint.setter
-    def useImageEntryPoint(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useImageEntryPoint = value
+    @workerStartupScript.setter
+    def workerStartupScript(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._workerStartupScript = value
         else:
             raise TypeError(
-                'Property "useImageEntryPoint" of type "list<bool>" set to wr'
+                'Property "workerStartupScript" of type "list<str>" set to wr'
                 'ong type'
             )
 
-    @property
-    def workspaceMounts(self):
-        """ """
-        return self._workspaceMounts
-
-    @workspaceMounts.setter
-    def workspaceMounts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._workspaceMounts = value
-        else:
-            raise TypeError(
-                'Property "workspaceMounts" of type "list<JobWorkspaceMountIn'
-                'fo>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
-        if self._command is not None:
-            result["command"] = \
-                self._command
-        if self._containerName is not None:
-            result["containerName"] = \
-                self._containerName
-        if self._containerResources:
-            result["containerResources"] = \
-                self._containerResources.toDict() if self._containerResources is not None else None
-        if self._datasetMounts:
-            result["datasetMounts"] = [
-                i.toDict() for i in self._datasetMounts 
-            ] if self._datasetMounts else []
-        if self._dockerImageName is not None:
-            result["dockerImageName"] = \
-                self._dockerImageName
-        if self._entryPoint is not None:
-            result["entryPoint"] = \
-                self._entryPoint
-        if self._envs:
-            result["envs"] = [
-                i.toDict() for i in self._envs 
-            ] if self._envs else []
-        if self._healthCheck:
-            result["healthCheck"] = \
-                self._healthCheck.toDict() if self._healthCheck is not None else None
-        if self._jobVolumeMounts:
-            result["jobVolumeMounts"] = [
-                i.toDict() for i in self._jobVolumeMounts 
-            ] if self._jobVolumeMounts else []
-        if self._portMappings:
-            result["portMappings"] = [
-                i.toDict() for i in self._portMappings 
-            ] if self._portMappings else []
-        if self._publishedContainerPorts is not None:
-            result["publishedContainerPorts"] = \
-                self._publishedContainerPorts
-        if self._resultContainerMountPoint is not None:
-            result["resultContainerMountPoint"] = \
-                self._resultContainerMountPoint
-        if self._useImageEntryPoint is not None:
-            result["useImageEntryPoint"] = \
-                self._useImageEntryPoint
-        if self._workspaceMounts:
-            result["workspaceMounts"] = [
-                i.toDict() for i in self._workspaceMounts 
-            ] if self._workspaceMounts else []
+        if self._ace is not None:
+            result["ace"] = \
+                self._ace
+        if self._clusterLifetime is not None:
+            result["clusterLifetime"] = \
+                self._clusterLifetime
+        if self._containerImage is not None:
+            result["containerImage"] = \
+                self._containerImage
+        if self._dataInput:
+            result["dataInput"] = \
+                self._dataInput.toDict() if self._dataInput is not None else None
+        if self._dataOutputMountPoint is not None:
+            result["dataOutputMountPoint"] = \
+                self._dataOutputMountPoint
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayImageURL is not None:
+            result["displayImageURL"] = \
+                self._displayImageURL
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._nworkers is not None:
+            result["nworkers"] = \
+                self._nworkers
+        if self._schedulerInstanceType is not None:
+            result["schedulerInstanceType"] = \
+                self._schedulerInstanceType
+        if self._schedulerStartupScript is not None:
+            result["schedulerStartupScript"] = \
+                self._schedulerStartupScript
+        if self._workerInstanceType is not None:
+            result["workerInstanceType"] = \
+                self._workerInstanceType
+        if self._workerStartupScript is not None:
+            result["workerStartupScript"] = \
+                self._workerStartupScript
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._dockerImageName is None:
+        if self._name is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._description is None:
             raise ValueError(
-                "JobSidecarContainer.dockerImageName doesnt match requirement:" 
+                "ProjectTemplateParamsDeprecated.description doesnt match requirement:" 
                 "required: True"
             )
-        if (self._dockerImageName is not None
+        if (self._description is not None
+            and
+            len(self._description) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if self._nworkers is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.nworkers doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._nworkers is not None
+            and
+            self._nworkers < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.nworkers: " + str(self._nworkers) + 
+                " doesnt match requirement: minimum: 1")
+        if self._displayImageURL is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.displayImageURL doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._displayImageURL is not None
+            and
+            len(self._displayImageURL) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.displayImageURL: " + str(self._displayImageURL) + 
+                " doesnt match requirement: minLength: 1")
+        if self._containerImage is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.containerImage doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._containerImage is not None
+            and
+            len(self._containerImage) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.containerImage: " + str(self._containerImage) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._containerImage is not None
             and
             not re.match(
                 r"[\x20-\x7E]*",
-                 self._dockerImageName)):
+                 self._containerImage)):
             raise ValueError(
-                "JobSidecarContainer.dockerImageName: " + str(self._dockerImageName) + 
+                "ProjectTemplateParamsDeprecated.containerImage: " + str(self._containerImage) + 
                 " doesnt match requirement: pattern: [\x20-\x7E]*")
-        if self._resultContainerMountPoint is None:
+        if (self._schedulerStartupScript is not None
+            and
+            len(self._schedulerStartupScript) < 1):
             raise ValueError(
-                "JobSidecarContainer.resultContainerMountPoint doesnt match requirement:" 
+                "ProjectTemplateParamsDeprecated.schedulerStartupScript: " + str(self._schedulerStartupScript) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._schedulerInstanceType is not None
+            and
+            len(self._schedulerInstanceType) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.schedulerInstanceType: " + str(self._schedulerInstanceType) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._workerStartupScript is not None
+            and
+            len(self._workerStartupScript) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.workerStartupScript: " + str(self._workerStartupScript) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._workerInstanceType is not None
+            and
+            len(self._workerInstanceType) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.workerInstanceType: " + str(self._workerInstanceType) + 
+                " doesnt match requirement: minLength: 1")
+        if self._clusterLifetime is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.clusterLifetime doesnt match requirement:" 
                 "required: True"
             )
-        if (self._portMappings is not None):
-            for obj in self._portMappings:
-                if (obj is not None): obj.isValid()
-        if (self._healthCheck is not None): self._healthCheck.isValid()
-        if (self._datasetMounts is not None):
-            for obj in self._datasetMounts:
-                if (obj is not None): obj.isValid()
-        if (self._workspaceMounts is not None):
-            for obj in self._workspaceMounts:
-                if (obj is not None): obj.isValid()
-        if (self._envs is not None):
-            for obj in self._envs:
-                if (obj is not None): obj.isValid()
-        if (self._jobVolumeMounts is not None):
-            for obj in self._jobVolumeMounts:
-                if (obj is not None): obj.isValid()
-        if (self._containerResources is not None): self._containerResources.isValid()
+        if (self._clusterLifetime is not None
+            and
+            not re.match(
+                r"[0-9]+[DdHhMmSs]",
+                 self._clusterLifetime)):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.clusterLifetime: " + str(self._clusterLifetime) + 
+                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
+        if (self._ace is not None
+            and
+            len(self._ace) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.ace: " + str(self._ace) + 
+                " doesnt match requirement: minLength: 1")
+        if self._dataOutputMountPoint is None:
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.dataOutputMountPoint doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._dataOutputMountPoint is not None
+            and
+            len(self._dataOutputMountPoint) < 1):
+            raise ValueError(
+                "ProjectTemplateParamsDeprecated.dataOutputMountPoint: " + str(self._dataOutputMountPoint) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._dataInput is not None): self._dataInput.isValid()
         return True
```

## Comparing `ngccli/data/api/JobStatus.py` & `ngcbpc/data/model/RecipeVersion.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,555 +6,531 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobPortMapping import JobPortMapping
-from .JobStatusEnum import JobStatusEnum
-from .JobDataLocation import JobDataLocation
-from .NodeSimplified import NodeSimplified
+from .VersionStatusEnum import VersionStatusEnum
+from .CustomMetricGroup import CustomMetricGroup
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(JobDataLocation))
-str(repr(JobPortMapping))
-str(repr(NodeSimplified))
-str(repr(JobStatusEnum))
+str(repr(CustomMetricGroup))
+str(repr(ArtifactAttribute))
+str(repr(VersionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatus(object):
-    """updates about job status are coming from the nodes"""
+class RecipeVersion(object):
+    """Recipe version object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aggregatedPreviousRunTimeSeconds = (
+        self.accuracyReached = (
             None if not fromDict or propDict.get(
-                "aggregatedPreviousRunTimeSeconds"
+                "accuracyReached"
             ) is None
-            else propDict["aggregatedPreviousRunTimeSeconds"])
-        self.containerName = (
+            else propDict["accuracyReached"])
+        self.batchSize = (
             None if not fromDict or propDict.get(
-                "containerName"
+                "batchSize"
             ) is None
-            else propDict["containerName"])
+            else propDict["batchSize"])
+        self.createdByUser = (
+            None if not fromDict or propDict.get(
+                "createdByUser"
+            ) is None
+            else propDict["createdByUser"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.endedAt = (
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "endedAt"
+                "customMetrics"
             ) is None
-            else propDict["endedAt"])
-        self.jobDataLocations = (
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "jobDataLocations"
+                "description"
             ) is None
-            else [ JobDataLocation(i)
-            for i in propDict["jobDataLocations"] ])
-        self.jobId = (
+            else propDict["description"])
+        self.gpuModel = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "gpuModel"
             ) is None
-            else propDict["jobId"])
-        self.logUrlError = (
+            else propDict["gpuModel"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "logUrlError"
+                "id"
             ) is None
-            else propDict["logUrlError"])
-        self.logUrlOutput = (
+            else propDict["id"])
+        self.memoryFootprint = (
             None if not fromDict or propDict.get(
-                "logUrlOutput"
+                "memoryFootprint"
             ) is None
-            else propDict["logUrlOutput"])
-        self.portMappings = (
+            else propDict["memoryFootprint"])
+        self.numberOfEpochs = (
             None if not fromDict or propDict.get(
-                "portMappings"
+                "numberOfEpochs"
             ) is None
-            else [ JobPortMapping(i)
-            for i in propDict["portMappings"] ])
-        self.preemptedAt = (
+            else propDict["numberOfEpochs"])
+        self.otherContents = (
             None if not fromDict or propDict.get(
-                "preemptedAt"
+                "otherContents"
             ) is None
-            else propDict["preemptedAt"])
-        self.queuedAt = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["otherContents"] ])
+        self.performance = (
             None if not fromDict or propDict.get(
-                "queuedAt"
+                "performance"
             ) is None
-            else propDict["queuedAt"])
-        self.resubmitId = (
+            else propDict["performance"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "resubmitId"
+                "quickStartGuide"
             ) is None
-            else propDict["resubmitId"])
-        self.selectedNodes = (
+            else propDict["quickStartGuide"])
+        self.releaseNotes = (
             None if not fromDict or propDict.get(
-                "selectedNodes"
+                "releaseNotes"
             ) is None
-            else [ NodeSimplified(i)
-            for i in propDict["selectedNodes"] ])
-        self.startedAt = (
+            else propDict["releaseNotes"])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "startedAt"
+                "setup"
             ) is None
-            else propDict["startedAt"])
+            else propDict["setup"])
         self.status = (
             None if not fromDict or propDict.get(
                 "status"
             ) is None
             else propDict["status"])
-        self.statusDetails = (
-            None if not fromDict or propDict.get(
-                "statusDetails"
-            ) is None
-            else propDict["statusDetails"])
-        self.statusType = (
-            None if not fromDict or propDict.get(
-                "statusType"
-            ) is None
-            else propDict["statusType"])
-        self.timestamp = (
+        self.totalFileCount = (
             None if not fromDict or propDict.get(
-                "timestamp"
+                "totalFileCount"
             ) is None
-            else propDict["timestamp"])
-        self.timestampStateEntry = (
+            else propDict["totalFileCount"])
+        self.totalSizeInBytes = (
             None if not fromDict or propDict.get(
-                "timestampStateEntry"
+                "totalSizeInBytes"
             ) is None
-            else propDict["timestampStateEntry"])
-        self.totalRuntimeSeconds = (
+            else propDict["totalSizeInBytes"])
+        self.versionId = (
             None if not fromDict or propDict.get(
-                "totalRuntimeSeconds"
+                "versionId"
             ) is None
-            else propDict["totalRuntimeSeconds"])
+            else propDict["versionId"])
+
+    @property
+    def accuracyReached(self):
+        """float: Accuracy this recipe reached"""
+        return self._accuracyReached
+
+    @accuracyReached.setter
+    def accuracyReached(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._accuracyReached = value
+        else:
+            raise TypeError(
+                'Property "accuracyReached" of type "list<float>" set to wron'
+                'g type'
+            )
 
     @property
-    def aggregatedPreviousRunTimeSeconds(self):
-        """long: Total time that job ran during the last submission (/preempti
-        on) in seconds, If the job was not resubmitted (/preempted), t
-        hen this field will be either 0 or null"""
-        return self._aggregatedPreviousRunTimeSeconds
+    def batchSize(self):
+        """long: Batch size this recipe was trained with"""
+        return self._batchSize
 
-    @aggregatedPreviousRunTimeSeconds.setter
-    def aggregatedPreviousRunTimeSeconds(self, value):
+    @batchSize.setter
+    def batchSize(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._aggregatedPreviousRunTimeSeconds = value
+            self._batchSize = value
         else:
             raise TypeError(
-                'Property "aggregatedPreviousRunTimeSeconds" of type "list<lo'
-                'ng>" set to wrong type'
+                'Property "batchSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def containerName(self):
-        """str: Name of the docker container running this job. Only set for a 
-        RUNNING job."""
-        return self._containerName
+    def createdByUser(self):
+        """str: Id of the user who created this recipe"""
+        return self._createdByUser
 
-    @containerName.setter
-    def containerName(self, value):
+    @createdByUser.setter
+    def createdByUser(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerName = value
+            self._createdByUser = value
         else:
             raise TypeError(
-                'Property "containerName" of type "list<str>" set to wrong ty'
+                'Property "createdByUser" of type "list<str>" set to wrong ty'
                 'pe'
             )
 
     @property
     def createdDate(self):
-        """str: ISO date time describing create time of this job status"""
+        """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._createdDate = value
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def endedAt(self):
-        """str: ISO date time describing end of the job, null if job is still 
-        running"""
-        return self._endedAt
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
+
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
+        else:
+            raise TypeError(
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
+            )
 
-    @endedAt.setter
-    def endedAt(self, value):
+    @property
+    def description(self):
+        """str: Description of the recipe version"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._endedAt = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "endedAt" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobDataLocations(self):
-        """list: Actual data localtions used for the job"""
-        return self._jobDataLocations
+    def gpuModel(self):
+        """str: GPU model and memory"""
+        return self._gpuModel
 
-    @jobDataLocations.setter
-    def jobDataLocations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._jobDataLocations = value
+    @gpuModel.setter
+    def gpuModel(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gpuModel = value
         else:
             raise TypeError(
-                'Property "jobDataLocations" of type "list<JobDataLocation>" '
-                'set to wrong type'
+                'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: [DEPRECATED] Unique Id of the job"""
-        return self._jobId
+    def id(self):
+        """long: Deprecated: Please use versionId instead. Unique ID of the ve
+        rsion"""
+        return self._id
 
-    @jobId.setter
-    def jobId(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._jobId = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
-    def logUrlError(self):
-        """str: [DEPRECATED] The URL for std error logging."""
-        return self._logUrlError
+    def memoryFootprint(self):
+        """str: recipe size/memory footprint for inference"""
+        return self._memoryFootprint
 
-    @logUrlError.setter
-    def logUrlError(self, value):
+    @memoryFootprint.setter
+    def memoryFootprint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logUrlError = value
+            self._memoryFootprint = value
         else:
             raise TypeError(
-                'Property "logUrlError" of type "list<str>" set to wrong type'
+                'Property "memoryFootprint" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def logUrlOutput(self):
-        """str: [DEPRECATED] The URL for std output logging."""
-        return self._logUrlOutput
+    def numberOfEpochs(self):
+        """long: Number of epochs this recipe trained"""
+        return self._numberOfEpochs
 
-    @logUrlOutput.setter
-    def logUrlOutput(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._logUrlOutput = value
+    @numberOfEpochs.setter
+    def numberOfEpochs(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._numberOfEpochs = value
         else:
             raise TypeError(
-                'Property "logUrlOutput" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def portMappings(self):
-        """list: Actual port mappings used for the job"""
-        return self._portMappings
+    def otherContents(self):
+        """list: List of external contents"""
+        return self._otherContents
 
-    @portMappings.setter
-    def portMappings(self, value):
+    @otherContents.setter
+    def otherContents(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._portMappings = value
+            self._otherContents = value
         else:
             raise TypeError(
-                'Property "portMappings" of type "list<JobPortMapping>" set t'
-                'o wrong type'
+                'Property "otherContents" of type "list<ArtifactAttribute>" s'
+                'et to wrong type'
             )
 
     @property
-    def preemptedAt(self):
-        """str: ISO date time describing when job got preempted"""
-        return self._preemptedAt
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @preemptedAt.setter
-    def preemptedAt(self, value):
+    @performance.setter
+    def performance(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._preemptedAt = value
+            self._performance = value
         else:
             raise TypeError(
-                'Property "preemptedAt" of type "list<str>" set to wrong type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def queuedAt(self):
-        """str: ISO date time describing queued time of the job"""
-        return self._queuedAt
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @queuedAt.setter
-    def queuedAt(self, value):
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._queuedAt = value
-        else:
-            raise TypeError(
-                'Property "queuedAt" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def resubmitId(self):
-        """long: Id of the submission of the job, beginning with 0"""
-        return self._resubmitId
-
-    @resubmitId.setter
-    def resubmitId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resubmitId = value
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "resubmitId" of type "list<long>" set to wrong type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def selectedNodes(self):
-        """list: an array of nodes that uniquely identify nodes this job is ru
-        nning on"""
-        return self._selectedNodes
+    def releaseNotes(self):
+        """str: Text describing this release"""
+        return self._releaseNotes
 
-    @selectedNodes.setter
-    def selectedNodes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._selectedNodes = value
+    @releaseNotes.setter
+    def releaseNotes(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._releaseNotes = value
         else:
             raise TypeError(
-                'Property "selectedNodes" of type "list<NodeSimplified>" set '
-                'to wrong type'
+                'Property "releaseNotes" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def startedAt(self):
-        """str: ISO date time describing start of the job"""
-        return self._startedAt
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
 
-    @startedAt.setter
-    def startedAt(self, value):
+    @setup.setter
+    def setup(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._startedAt = value
+            self._setup = value
         else:
             raise TypeError(
-                'Property "startedAt" of type "list<str>" set to wrong type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
     def status(self):
-        """JobStatusEnum: All possible job status enums"""
+        """VersionStatusEnum: Version status"""
         return self._status
 
     @status.setter
     def status(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._status = value
         else:
             raise TypeError(
-                'Property "status" of type "list<JobStatusEnum>" set to wrong'
-                ' type'
-            )
-
-    @property
-    def statusDetails(self):
-        """str: Error information for a terminated job (finished/killed/failed
-        )"""
-        return self._statusDetails
-
-    @statusDetails.setter
-    def statusDetails(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._statusDetails = value
-        else:
-            raise TypeError(
-                'Property "statusDetails" of type "list<str>" set to wrong ty'
-                'pe'
-            )
-
-    @property
-    def statusType(self):
-        """ """
-        return self._statusType
-
-    @statusType.setter
-    def statusType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._statusType = value
-        else:
-            raise TypeError(
-                'Property "statusType" of type "list<StatusTypeEnum>" set to '
-                'wrong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
-    StatusTypeEnum=["UNKNOWN","OK","APPLICATION_ERROR","DOCKER_ERROR","CONTAINER_ERROR","SYSTEM_ERROR",]
-    str(repr(StatusTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def timestamp(self):
-        """long: Unix timestamp in milliseconds, when the status was sent from
-         appliance"""
-        return self._timestamp
+    def totalFileCount(self):
+        """long: Total file count"""
+        return self._totalFileCount
 
-    @timestamp.setter
-    def timestamp(self, value):
+    @totalFileCount.setter
+    def totalFileCount(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._timestamp = value
+            self._totalFileCount = value
         else:
             raise TypeError(
-                'Property "timestamp" of type "list<long>" set to wrong type'
+                'Property "totalFileCount" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def timestampStateEntry(self):
-        """long: Unix timestamp in milliseconds, when job entered current stat
-        e for current resubmitId"""
-        return self._timestampStateEntry
+    def totalSizeInBytes(self):
+        """long: Total size of the recipe in bytes"""
+        return self._totalSizeInBytes
 
-    @timestampStateEntry.setter
-    def timestampStateEntry(self, value):
+    @totalSizeInBytes.setter
+    def totalSizeInBytes(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._timestampStateEntry = value
+            self._totalSizeInBytes = value
         else:
             raise TypeError(
-                'Property "timestampStateEntry" of type "list<long>" set to w'
-                'rong type'
+                'Property "totalSizeInBytes" of type "list<long>" set to wron'
+                'g type'
             )
 
     @property
-    def totalRuntimeSeconds(self):
-        """long: Total runtime of the job in seconds"""
-        return self._totalRuntimeSeconds
+    def versionId(self):
+        """str: Unique version id. Please use this instead of 'id'"""
+        return self._versionId
 
-    @totalRuntimeSeconds.setter
-    def totalRuntimeSeconds(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalRuntimeSeconds = value
+    @versionId.setter
+    def versionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._versionId = value
         else:
             raise TypeError(
-                'Property "totalRuntimeSeconds" of type "list<long>" set to w'
-                'rong type'
+                'Property "versionId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aggregatedPreviousRunTimeSeconds is not None:
-            result["aggregatedPreviousRunTimeSeconds"] = \
-                self._aggregatedPreviousRunTimeSeconds
-        if self._containerName is not None:
-            result["containerName"] = \
-                self._containerName
+        if self._accuracyReached is not None:
+            result["accuracyReached"] = \
+                self._accuracyReached
+        if self._batchSize is not None:
+            result["batchSize"] = \
+                self._batchSize
+        if self._createdByUser is not None:
+            result["createdByUser"] = \
+                self._createdByUser
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._endedAt is not None:
-            result["endedAt"] = \
-                self._endedAt
-        if self._jobDataLocations:
-            result["jobDataLocations"] = [
-                i.toDict() for i in self._jobDataLocations 
-            ] if self._jobDataLocations else []
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._logUrlError is not None:
-            result["logUrlError"] = \
-                self._logUrlError
-        if self._logUrlOutput is not None:
-            result["logUrlOutput"] = \
-                self._logUrlOutput
-        if self._portMappings:
-            result["portMappings"] = [
-                i.toDict() for i in self._portMappings 
-            ] if self._portMappings else []
-        if self._preemptedAt is not None:
-            result["preemptedAt"] = \
-                self._preemptedAt
-        if self._queuedAt is not None:
-            result["queuedAt"] = \
-                self._queuedAt
-        if self._resubmitId is not None:
-            result["resubmitId"] = \
-                self._resubmitId
-        if self._selectedNodes:
-            result["selectedNodes"] = [
-                i.toDict() for i in self._selectedNodes 
-            ] if self._selectedNodes else []
-        if self._startedAt is not None:
-            result["startedAt"] = \
-                self._startedAt
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._gpuModel is not None:
+            result["gpuModel"] = \
+                self._gpuModel
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._memoryFootprint is not None:
+            result["memoryFootprint"] = \
+                self._memoryFootprint
+        if self._numberOfEpochs is not None:
+            result["numberOfEpochs"] = \
+                self._numberOfEpochs
+        if self._otherContents:
+            result["otherContents"] = [
+                i.toDict() for i in self._otherContents 
+            ] if self._otherContents else []
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._releaseNotes is not None:
+            result["releaseNotes"] = \
+                self._releaseNotes
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
         if self._status is not None:
             result["status"] = \
                 self._status
-        if self._statusDetails is not None:
-            result["statusDetails"] = \
-                self._statusDetails
-        if self._statusType is not None:
-            result["statusType"] = \
-                self._statusType
-        if self._timestamp is not None:
-            result["timestamp"] = \
-                self._timestamp
-        if self._timestampStateEntry is not None:
-            result["timestampStateEntry"] = \
-                self._timestampStateEntry
-        if self._totalRuntimeSeconds is not None:
-            result["totalRuntimeSeconds"] = \
-                self._totalRuntimeSeconds
+        if self._totalFileCount is not None:
+            result["totalFileCount"] = \
+                self._totalFileCount
+        if self._totalSizeInBytes is not None:
+            result["totalSizeInBytes"] = \
+                self._totalSizeInBytes
+        if self._versionId is not None:
+            result["versionId"] = \
+                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._selectedNodes is not None):
-            for obj in self._selectedNodes:
-                if (obj is not None): obj.isValid()
-        if (self._portMappings is not None):
-            for obj in self._portMappings:
+        if (self._versionId is not None
+            and
+            len(self._versionId) > 255):
+            raise ValueError(
+                "RecipeVersion.versionId: " + str(self._versionId) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
+            raise ValueError(
+                "RecipeVersion.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
                 if (obj is not None): obj.isValid()
-        if (self._jobDataLocations is not None):
-            for obj in self._jobDataLocations:
+        if (self._otherContents is not None):
+            for obj in self._otherContents:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/JobStatusChangedEvent.py` & `ngcbpc/data/model/ArtifactAttribute.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,83 +6,102 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobStatusEnum import JobStatusEnum
 
 # Unused import over optimization prevention
-str(repr(JobStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatusChangedEvent(object):
-    """This event in the queue means a job status has been updated"""
+class ArtifactAttribute(object):
+    """Attribute on the artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobId = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "key"
             ) is None
-            else propDict["jobId"])
-        self.status = (
+            else propDict["key"])
+        self.value = (
             None if not fromDict or propDict.get(
-                "status"
+                "value"
             ) is None
-            else propDict["status"])
+            else propDict["value"])
 
     @property
-    def jobId(self):
-        """long: Unique identifier of the job."""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    def key(self):
+        """ """
+        return self._key
+
+    @key.setter
+    def key(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._key = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "key" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """JobStatusEnum: All possible job status enums"""
-        return self._status
-
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    def value(self):
+        """ """
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._value = value
         else:
             raise TypeError(
-                'Property "status" of type "list<JobStatusEnum>" set to wrong'
-                ' type'
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._key is not None
+            and
+            len(self._key) > 255):
+            raise ValueError(
+                "ArtifactAttribute.key: " + str(self._key) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._key is not None
+            and
+            not re.match(
+                r"[a-zA-Z0-9]+",
+                 self._key)):
+            raise ValueError(
+                "ArtifactAttribute.key: " + str(self._key) + 
+                " doesnt match requirement: pattern: [a-zA-Z0-9]+")
+        if (self._value is not None
+            and
+            len(self._value) > 255):
+            raise ValueError(
+                "ArtifactAttribute.value: " + str(self._value) + 
+                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/JobStatusCount.py` & `basecommand/data/pym/ClusterListResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,83 +6,100 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobStatusEnum import JobStatusEnum
+from .ClusterRequestStatus import ClusterRequestStatus
 
 # Unused import over optimization prevention
-str(repr(JobStatusEnum))
+str(repr(ClusterRequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatusCount(object):
-    """updates about job status are coming from the nodes"""
+class ClusterListResponse(object):
+    """Cluster List Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.status = (
+        self.clusters = (
             None if not fromDict or propDict.get(
-                "status"
+                "clusters"
             ) is None
-            else propDict["status"])
-        self.total = (
+            else [ ClusterRequestStatus(i)
+            for i in propDict["clusters"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "total"
+                "version"
             ) is None
-            else propDict["total"])
+            else propDict["version"])
 
     @property
-    def status(self):
-        """JobStatusEnum: All possible job status enums"""
-        return self._status
-
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    def clusters(self):
+        """ """
+        return self._clusters
+
+    @clusters.setter
+    def clusters(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._clusters = value
         else:
             raise TypeError(
-                'Property "status" of type "list<JobStatusEnum>" set to wrong'
-                ' type'
+                'Property "clusters" of type "list<ClusterRequestStatus>" set'
+                ' to wrong type'
             )
 
     @property
-    def total(self):
-        """long: The number of jobs"""
-        return self._total
-
-    @total.setter
-    def total(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._total = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "total" of type "list<long>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._total is not None:
-            result["total"] = \
-                self._total
+        if self._clusters:
+            result["clusters"] = [
+                i.toDict() for i in self._clusters 
+            ] if self._clusters else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "ClusterListResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._clusters is None:
+            raise ValueError(
+                "ClusterListResponse.clusters doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusters is not None):
+            for obj in self._clusters:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/JobStatusCountResponse.py` & `organization/data/subscription_management_service/UpdateAccountStatusGtsResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,41 +6,38 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobStatusCount import JobStatusCount
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(JobStatusCount))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatusCountResponse(object):
-    """The number of jobs per job status"""
+class UpdateAccountStatusGtsResponse(object):
+    """Response for updating account status for redemption from GTS"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.statusCount = (
+        self.status = (
             None if not fromDict or propDict.get(
-                "statusCount"
+                "status"
             ) is None
-            else [ JobStatusCount(i)
-            for i in propDict["statusCount"] ])
+            else propDict["status"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -52,48 +49,43 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def statusCount(self):
+    def status(self):
         """ """
-        return self._statusCount
+        return self._status
 
-    @statusCount.setter
-    def statusCount(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._statusCount = value
+    @status.setter
+    def status(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._status = value
         else:
             raise TypeError(
-                'Property "statusCount" of type "list<JobStatusCount>" set to'
-                ' wrong type'
+                'Property "status" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._statusCount:
-            result["statusCount"] = [
-                i.toDict() for i in self._statusCount 
-            ] if self._statusCount else []
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._statusCount is not None):
-            for obj in self._statusCount:
-                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobStatusSyncRequest.py` & `ngcbpc/data/uis/RemoveRolesRequest.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,64 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatusSyncRequest(object):
-    """object used by the cloud to send a request on /queue/v1/marathon/jobSta
-    tus subscription to the node expecting the node to provide current sta
-    tus for the list of jobs in the request"""
+class RemoveRolesRequest(object):
+    """Remove roles from a given user request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobIds = (
+        self.roles = (
             None if not fromDict or propDict.get(
-                "jobIds"
+                "roles"
             ) is None
-            else propDict["jobIds"])
+            else propDict["roles"])
 
     @property
-    def jobIds(self):
-        """list: list of job ids that cloud is requesting status update from t
-        he node"""
-        return self._jobIds
+    def roles(self):
+        """list: A list of roles to be removed"""
+        return self._roles
 
-    @jobIds.setter
-    def jobIds(self, value):
+    @roles.setter
+    def roles(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._jobIds = value
+            self._roles = value
         else:
             raise TypeError(
-                'Property "jobIds" of type "list<long>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobIds is not None:
-            result["jobIds"] = \
-                self._jobIds
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobIds is None:
+        if self._roles is None:
             raise ValueError(
-                "JobStatusSyncRequest.jobIds doesnt match requirement:" 
+                "RemoveRolesRequest.roles doesnt match requirement:" 
                 "required: True"
             )
-        if (self._jobIds is not None
-            and
-            len(self._jobIds) < 1):
-            raise ValueError(
-                "JobStatusSyncRequest.jobIds: " + str(self._jobIds) + 
-                " doesnt match requirement: minItems: 1")
         return True
```

## Comparing `ngccli/data/api/JobStatusUpdateRequest.py` & `organization/data/subscription_management_service/LineItem.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,251 +6,262 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobPortMapping import JobPortMapping
-from .JobStatus import JobStatus
+from .OrderActionTypeEnum import OrderActionTypeEnum
+from .LineItemTypeEnum import LineItemTypeEnum
+from .Charge import Charge
 
 # Unused import over optimization prevention
-str(repr(JobPortMapping))
-str(repr(JobStatus))
+str(repr(LineItemTypeEnum))
+str(repr(OrderActionTypeEnum))
+str(repr(Charge))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobStatusUpdateRequest(object):
-    """object used by the node to send job/task status updates to the cloud"""
+class LineItem(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerName = (
+        self.charges = (
             None if not fromDict or propDict.get(
-                "containerName"
+                "charges"
             ) is None
-            else propDict["containerName"])
-        self.jobId = (
+            else [ Charge(i)
+            for i in propDict["charges"] ])
+        self.orderActionType = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "orderActionType"
             ) is None
-            else propDict["jobId"])
-        self.jobStatus = (
+            else propDict["orderActionType"])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "jobStatus"
+                "productName"
             ) is None
-            else propDict["jobStatus"])
-        self.poolId = (
+            else propDict["productName"])
+        self.productRatePlanName = (
             None if not fromDict or propDict.get(
-                "poolId"
+                "productRatePlanName"
             ) is None
-            else propDict["poolId"])
-        self.portMappings = (
+            else propDict["productRatePlanName"])
+        self.productRatePlanSku = (
             None if not fromDict or propDict.get(
-                "portMappings"
+                "productRatePlanSku"
             ) is None
-            else [ JobPortMapping(i)
-            for i in propDict["portMappings"] ])
-        self.status = (
+            else propDict["productRatePlanSku"])
+        self.quantity = (
             None if not fromDict or propDict.get(
-                "status"
+                "quantity"
             ) is None
-            else propDict["status"])
-        self.statusType = (
+            else propDict["quantity"])
+        self.subscriptionEndDate = (
             None if not fromDict or propDict.get(
-                "statusType"
+                "subscriptionEndDate"
             ) is None
-            else propDict["statusType"])
-        self.taskId = (
+            else propDict["subscriptionEndDate"])
+        self.subscriptionStartDate = (
             None if not fromDict or propDict.get(
-                "taskId"
+                "subscriptionStartDate"
             ) is None
-            else propDict["taskId"])
+            else propDict["subscriptionStartDate"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
 
     @property
-    def containerName(self):
-        """str: [DEPRECATED] DO NOT USE, WILL BE REMOVED SOONtm"""
-        return self._containerName
+    def charges(self):
+        """ """
+        return self._charges
 
-    @containerName.setter
-    def containerName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._containerName = value
+    @charges.setter
+    def charges(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._charges = value
         else:
             raise TypeError(
-                'Property "containerName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "charges" of type "list<Charge>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: Id of the job"""
-        return self._jobId
+    def orderActionType(self):
+        """OrderActionTypeEnum: All possible types of order action"""
+        return self._orderActionType
 
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    @orderActionType.setter
+    def orderActionType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._orderActionType = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "orderActionType" of type "list<OrderActionTypeEnum'
+                '>" set to wrong type'
             )
 
     @property
-    def jobStatus(self):
-        """JobStatus: updates about job status are coming from the nodes"""
-        return self._jobStatus
+    def productName(self):
+        """str: name of the product"""
+        return self._productName
 
-    @jobStatus.setter
-    def jobStatus(self, value):
-        if value is not None and not isinstance(value, JobStatus):
-            value = JobStatus(value)
-        if (value is None) or isinstance(value, JobStatus):
-            self._jobStatus = value
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
         else:
             raise TypeError(
-                'Property "jobStatus" of type "list<JobStatus>" set to wrong '
-                'type'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def poolId(self):
-        """str: Infinity Manager's poolId which is the identifier of the pool 
-        against which the job runs."""
-        return self._poolId
+    def productRatePlanName(self):
+        """str: product rate plan name of the product"""
+        return self._productRatePlanName
 
-    @poolId.setter
-    def poolId(self, value):
+    @productRatePlanName.setter
+    def productRatePlanName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._poolId = value
+            self._productRatePlanName = value
         else:
             raise TypeError(
-                'Property "poolId" of type "list<str>" set to wrong type'
+                'Property "productRatePlanName" of type "list<str>" set to wr'
+                'ong type'
             )
 
     @property
-    def portMappings(self):
-        """list: [DEPRECATED] DO NOT USE, WILL BE REMOVED SOONtm"""
-        return self._portMappings
+    def productRatePlanSku(self):
+        """str: product rate plan sku of the product"""
+        return self._productRatePlanSku
 
-    @portMappings.setter
-    def portMappings(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._portMappings = value
+    @productRatePlanSku.setter
+    def productRatePlanSku(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productRatePlanSku = value
+        else:
+            raise TypeError(
+                'Property "productRatePlanSku" of type "list<str>" set to wro'
+                'ng type'
+            )
+
+    @property
+    def quantity(self):
+        """int: quantity of product ordered"""
+        return self._quantity
+
+    @quantity.setter
+    def quantity(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._quantity = value
         else:
             raise TypeError(
-                'Property "portMappings" of type "list<JobPortMapping>" set t'
-                'o wrong type'
+                'Property "quantity" of type "list<int>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """JobStatus: updates about job status are coming from the nodes"""
-        return self._status
+    def subscriptionEndDate(self):
+        """str: end date of the subscription"""
+        return self._subscriptionEndDate
 
-    @status.setter
-    def status(self, value):
-        if value is not None and not isinstance(value, JobStatus):
-            value = JobStatus(value)
-        if (value is None) or isinstance(value, JobStatus):
-            self._status = value
+    @subscriptionEndDate.setter
+    def subscriptionEndDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._subscriptionEndDate = value
         else:
             raise TypeError(
-                'Property "status" of type "list<JobStatus>" set to wrong typ'
-                'e'
+                'Property "subscriptionEndDate" of type "list<str>" set to wr'
+                'ong type'
             )
 
     @property
-    def statusType(self):
-        """StatusTypeEnum: identifies whether the status is of a job or task i
-        n a multinode job"""
-        return self._statusType
+    def subscriptionStartDate(self):
+        """str: start date of the subscription"""
+        return self._subscriptionStartDate
 
-    @statusType.setter
-    def statusType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._statusType = value
+    @subscriptionStartDate.setter
+    def subscriptionStartDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._subscriptionStartDate = value
         else:
             raise TypeError(
-                'Property "statusType" of type "list<StatusTypeEnum>" set to '
+                'Property "subscriptionStartDate" of type "list<str>" set to '
                 'wrong type'
             )
 
-    StatusTypeEnum=["JOB","TASK",]
-    str(repr(StatusTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def taskId(self):
-        """long: Id of the task of the job, beginning with 0, null value means
-         status of the job"""
-        return self._taskId
+    def type(self):
+        """LineItemTypeEnum: All possible line item types"""
+        return self._type
 
-    @taskId.setter
-    def taskId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._taskId = value
+    @type.setter
+    def type(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._type = value
         else:
             raise TypeError(
-                'Property "taskId" of type "list<long>" set to wrong type'
+                'Property "type" of type "list<LineItemTypeEnum>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._containerName is not None:
-            result["containerName"] = \
-                self._containerName
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._jobStatus:
-            result["jobStatus"] = \
-                self._jobStatus.toDict() if self._jobStatus is not None else None
-        if self._poolId is not None:
-            result["poolId"] = \
-                self._poolId
-        if self._portMappings:
-            result["portMappings"] = [
-                i.toDict() for i in self._portMappings 
-            ] if self._portMappings else []
-        if self._status:
-            result["status"] = \
-                self._status.toDict() if self._status is not None else None
-        if self._statusType is not None:
-            result["statusType"] = \
-                self._statusType
-        if self._taskId is not None:
-            result["taskId"] = \
-                self._taskId
+        if self._charges:
+            result["charges"] = [
+                i.toDict() for i in self._charges 
+            ] if self._charges else []
+        if self._orderActionType is not None:
+            result["orderActionType"] = \
+                self._orderActionType
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._productRatePlanName is not None:
+            result["productRatePlanName"] = \
+                self._productRatePlanName
+        if self._productRatePlanSku is not None:
+            result["productRatePlanSku"] = \
+                self._productRatePlanSku
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
+        if self._subscriptionEndDate is not None:
+            result["subscriptionEndDate"] = \
+                self._subscriptionEndDate
+        if self._subscriptionStartDate is not None:
+            result["subscriptionStartDate"] = \
+                self._subscriptionStartDate
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._statusType is None:
-            raise ValueError(
-                "JobStatusUpdateRequest.statusType doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._portMappings is not None):
-            for obj in self._portMappings:
+        if (self._charges is not None):
+            for obj in self._charges:
                 if (obj is not None): obj.isValid()
-        if (self._jobStatus is not None): self._jobStatus.isValid()
-        if (self._status is not None): self._status.isValid()
         return True
```

## Comparing `ngccli/data/api/JobSubmitResponse.py` & `ngcbpc/data/model/RecipeResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,57 +7,59 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
+from .Recipe import Recipe
 
 # Unused import over optimization prevention
+str(repr(Recipe))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobSubmitResponse(object):
-    """response to the UI after submitting a job request"""
+class RecipeResponse(object):
+    """Response to recipe request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobId = (
+        self.recipe = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "recipe"
             ) is None
-            else propDict["jobId"])
+            else propDict["recipe"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def jobId(self):
-        """ """
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    def recipe(self):
+        """Recipe: Recipe object"""
+        return self._recipe
+
+    @recipe.setter
+    def recipe(self, value):
+        if value is not None and not isinstance(value, Recipe):
+            value = Recipe(value)
+        if (value is None) or isinstance(value, Recipe):
+            self._recipe = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "recipe" of type "list<Recipe>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -66,31 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
+        if self._recipe:
+            result["recipe"] = \
+                self._recipe.toDict() if self._recipe is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._jobId is None:
-            raise ValueError(
-                "JobSubmitResponse.jobId doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._recipe is not None): self._recipe.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobTemplate.py` & `registry/data/publishing/ArtifactBatch.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,207 +6,188 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobDefinition import JobDefinition
 
 # Unused import over optimization prevention
-str(repr(JobDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobTemplate(object):
-    """object that describes a template that can be used to submit job"""
+class ArtifactBatch(object):
+    """NGC Artifact Batch which allows for publishing a batch of a maximum of 
+    10 artifacts. This schema allows batches of different versions of a so
+    urce artifact, and batches of different artifacts (by name) in the same so
+    urce org/team"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.environmentUri = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "environmentUri"
             ) is None
-            else propDict["aceName"])
-        self.description = (
+            else propDict["environmentUri"])
+        self.names = (
             None if not fromDict or propDict.get(
-                "description"
+                "names"
             ) is None
-            else propDict["description"])
-        self.id = (
+            else propDict["names"])
+        self.org = (
             None if not fromDict or propDict.get(
-                "id"
+                "org"
             ) is None
-            else propDict["id"])
-        self.jobDefinition = (
+            else propDict["org"])
+        self.team = (
             None if not fromDict or propDict.get(
-                "jobDefinition"
+                "team"
             ) is None
-            else propDict["jobDefinition"])
-        self.name = (
+            else propDict["team"])
+        self.versions = (
             None if not fromDict or propDict.get(
-                "name"
+                "versions"
             ) is None
-            else propDict["name"])
-        self.orgName = (
-            None if not fromDict or propDict.get(
-                "orgName"
-            ) is None
-            else propDict["orgName"])
-        self.teamName = (
-            None if not fromDict or propDict.get(
-                "teamName"
-            ) is None
-            else propDict["teamName"])
-
-    @property
-    def aceName(self):
-        """str: name of ace that the job belongs to"""
-        return self._aceName
-
-    @aceName.setter
-    def aceName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceName = value
-        else:
-            raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
-            )
+            else propDict["versions"])
 
     @property
-    def description(self):
-        """str: description of this job template"""
-        return self._description
+    def environmentUri(self):
+        """str: Environment and microservice URI artifact(s) is/are from. Exam
+        ples: https://models.ngc.nvidia.com, https://nvcr.io, etc."""
+        return self._environmentUri
 
-    @description.setter
-    def description(self, value):
+    @environmentUri.setter
+    def environmentUri(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._environmentUri = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "environmentUri" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def id(self):
-        """str: Id of this job template"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._id = value
-        else:
-            raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
-            )
+    def names(self):
+        """list: Name(s) of the NGC artifact(s) unique to the org or team"""
+        return self._names
 
-    @property
-    def jobDefinition(self):
-        """JobDefinition: This object is populated when job request is submitt
-        ed by the user"""
-        return self._jobDefinition
-
-    @jobDefinition.setter
-    def jobDefinition(self, value):
-        if value is not None and not isinstance(value, JobDefinition):
-            value = JobDefinition(value)
-        if (value is None) or isinstance(value, JobDefinition):
-            self._jobDefinition = value
+    @names.setter
+    def names(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._names = value
         else:
             raise TypeError(
-                'Property "jobDefinition" of type "list<JobDefinition>" set t'
-                'o wrong type'
+                'Property "names" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of this job template"""
-        return self._name
+    def org(self):
+        """str: Name of the NGC org that owns the artifact(s)"""
+        return self._org
 
-    @name.setter
-    def name(self, value):
+    @org.setter
+    def org(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._org = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "org" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: name of org that the job belongs to"""
-        return self._orgName
+    def team(self):
+        """str: (Optional) Name of the NGC team under the specified org that o
+        wns the artifact(s)"""
+        return self._team
 
-    @orgName.setter
-    def orgName(self, value):
+    @team.setter
+    def team(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._team = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     @property
-    def teamName(self):
-        """str: name of team that the job belongs to"""
-        return self._teamName
+    def versions(self):
+        """list: Versions of the NGC artifact(s)"""
+        return self._versions
 
-    @teamName.setter
-    def teamName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+    @versions.setter
+    def versions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._versions = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "versions" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._jobDefinition:
-            result["jobDefinition"] = \
-                self._jobDefinition.toDict() if self._jobDefinition is not None else None
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
+        if self._environmentUri is not None:
+            result["environmentUri"] = \
+                self._environmentUri
+        if self._names is not None:
+            result["names"] = \
+                self._names
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._team is not None:
+            result["team"] = \
+                self._team
+        if self._versions is not None:
+            result["versions"] = \
+                self._versions
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._jobDefinition is not None): self._jobDefinition.isValid()
+        if self._org is None:
+            raise ValueError(
+                "ArtifactBatch.org doesnt match requirement:" 
+                "required: True"
+            )
+        if self._names is None:
+            raise ValueError(
+                "ArtifactBatch.names doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._names is not None
+            and
+            len(self._names) > 10):
+            raise ValueError(
+                "ArtifactBatch.names: " + str(self._names) + 
+                " doesnt match requirement: maxItems: 10")
+        if (self._names is not None
+            and
+            len(self._names) < 1):
+            raise ValueError(
+                "ArtifactBatch.names: " + str(self._names) + 
+                " doesnt match requirement: minItems: 1")
+        if (self._versions is not None
+            and
+            len(self._versions) > 10):
+            raise ValueError(
+                "ArtifactBatch.versions: " + str(self._versions) + 
+                " doesnt match requirement: maxItems: 10")
         return True
```

## Comparing `ngccli/data/api/JobTemplateCreateRequest.py` & `ngcbpc/data/uis/TeamCreateRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,70 +14,48 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobTemplateCreateRequest(object):
-    """request to create a job template"""
+class TeamCreateRequest(object):
+    """Request to create new Team"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.jobId = (
-            None if not fromDict or propDict.get(
-                "jobId"
-            ) is None
-            else propDict["jobId"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
 
     @property
     def description(self):
-        """str: optional description of the job, max 512 chars."""
+        """str: description of the team"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: Job id that the template is based on."""
-        return self._jobId
-
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
-        else:
-            raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
-            )
-
-    @property
     def name(self):
-        """str: name for the job template, does not need to be unique max 128 
-        characters"""
+        """str: team name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -88,62 +66,54 @@
             )
 
     def toDict(self):
         result = {}
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
         if self._name is not None:
             result["name"] = \
                 self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "JobTemplateCreateRequest.name doesnt match requirement:" 
+                "TeamCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
         if (self._name is not None
             and
             len(self._name) < 2):
             raise ValueError(
-                "JobTemplateCreateRequest.name: " + str(self._name) + 
+                "TeamCreateRequest.name: " + str(self._name) + 
                 " doesnt match requirement: minLength: 2")
         if (self._name is not None
             and
-            len(self._name) > 128):
+            len(self._name) > 19):
             raise ValueError(
-                "JobTemplateCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 128")
+                "TeamCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 19")
         if (self._name is not None
             and
             not re.match(
-                r"^[a-zA-Z\d][a-zA-Z\d\-\. ,_]*$",
+                r"(?![_-])(?!.*[_-]$)[a-z][a-z\d_-]+",
                  self._name)):
             raise ValueError(
-                "JobTemplateCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d][a-zA-Z\d\-\."
-                " ,_]*$")
+                "TeamCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: (?![_-])(?!.*[_-]$)[a-z]"
+                "[a-z\d_-]+")
         if (self._description is not None
             and
-            len(self._description) > 512):
-            raise ValueError(
-                "JobTemplateCreateRequest.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 512")
-        if self._jobId is None:
+            len(self._description) > 255):
             raise ValueError(
-                "JobTemplateCreateRequest.jobId doesnt match requirement:" 
-                "required: True"
-            )
+                "TeamCreateRequest.description: " + str(self._description) + 
+                " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/JobTemplateResponse.py` & `ngcbpc/data/uis/NvcfGpuUsageResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,56 +7,56 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .JobTemplate import JobTemplate
+from .NvcfGpuUsage import NvcfGpuUsage
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(JobTemplate))
+str(repr(NvcfGpuUsage))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobTemplateResponse(object):
-    """Information about job template"""
+class NvcfGpuUsageResponse(object):
+    """NVCF GPU Usage response body"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.jobTemplate = (
+        self.gpuUsages = (
             None if not fromDict or propDict.get(
-                "jobTemplate"
+                "gpuUsages"
             ) is None
-            else propDict["jobTemplate"])
+            else [ NvcfGpuUsage(i)
+            for i in propDict["gpuUsages"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def jobTemplate(self):
-        """JobTemplate: object that describes a template that can be used to s
-        ubmit job"""
-        return self._jobTemplate
-
-    @jobTemplate.setter
-    def jobTemplate(self, value):
-        if value is not None and not isinstance(value, JobTemplate):
-            value = JobTemplate(value)
-        if (value is None) or isinstance(value, JobTemplate):
-            self._jobTemplate = value
+    def gpuUsages(self):
+        """ """
+        return self._gpuUsages
+
+    @gpuUsages.setter
+    def gpuUsages(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._gpuUsages = value
         else:
             raise TypeError(
-                'Property "jobTemplate" of type "list<JobTemplate>" set to wr'
-                'ong type'
+                'Property "gpuUsages" of type "list<NvcfGpuUsage>" set to wro'
+                'ng type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,27 +70,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._jobTemplate:
-            result["jobTemplate"] = \
-                self._jobTemplate.toDict() if self._jobTemplate is not None else None
+        if self._gpuUsages:
+            result["gpuUsages"] = [
+                i.toDict() for i in self._gpuUsages 
+            ] if self._gpuUsages else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._jobTemplate is not None): self._jobTemplate.isValid()
+        if (self._gpuUsages is not None):
+            for obj in self._gpuUsages:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/JobTemplateUpdateRequest.py` & `basecommand/data/pym/ProjectCreateRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,173 +6,166 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobDefinition import JobDefinition
-from .JobLabels import JobLabels
+from .ProjectParams import ProjectParams
 
 # Unused import over optimization prevention
-str(repr(JobDefinition))
-str(repr(JobLabels))
+str(repr(ProjectParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobTemplateUpdateRequest(object):
-    """request to update a job template"""
+class ProjectCreateRequest(object):
+    """Project Create Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.description = (
+        self.ace = (
             None if not fromDict or propDict.get(
-                "description"
+                "ace"
             ) is None
-            else propDict["description"])
-        self.jobDefinition = (
+            else propDict["ace"])
+        self.owner = (
             None if not fromDict or propDict.get(
-                "jobDefinition"
+                "owner"
             ) is None
-            else propDict["jobDefinition"])
-        self.labels = (
+            else propDict["owner"])
+        self.params = (
             None if not fromDict or propDict.get(
-                "labels"
+                "params"
             ) is None
-            else propDict["labels"])
-        self.name = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "name"
+                "version"
             ) is None
-            else propDict["name"])
+            else propDict["version"])
 
     @property
-    def description(self):
-        """str: optional description of the job, max 512 chars."""
-        return self._description
+    def ace(self):
+        """str: ACE instance"""
+        return self._ace
 
-    @description.setter
-    def description(self, value):
+    @ace.setter
+    def ace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._ace = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "ace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobDefinition(self):
-        """JobDefinition: This object is populated when job request is submitt
-        ed by the user"""
-        return self._jobDefinition
-
-    @jobDefinition.setter
-    def jobDefinition(self, value):
-        if value is not None and not isinstance(value, JobDefinition):
-            value = JobDefinition(value)
-        if (value is None) or isinstance(value, JobDefinition):
-            self._jobDefinition = value
+    def owner(self):
+        """str: Project owner"""
+        return self._owner
+
+    @owner.setter
+    def owner(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._owner = value
         else:
             raise TypeError(
-                'Property "jobDefinition" of type "list<JobDefinition>" set t'
-                'o wrong type'
+                'Property "owner" of type "list<str>" set to wrong type'
             )
 
     @property
-    def labels(self):
-        """JobLabels: All the labels specified by user or admin that descibe t
-        his job"""
-        return self._labels
-
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, JobLabels):
-            value = JobLabels(value)
-        if (value is None) or isinstance(value, JobLabels):
-            self._labels = value
+    def params(self):
+        """ProjectParams: Project params"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectParams):
+            value = ProjectParams(value)
+        if (value is None) or isinstance(value, ProjectParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<JobLabels>" set to wrong typ'
-                'e'
+                'Property "params" of type "list<ProjectParams>" set to wrong'
+                ' type'
             )
 
     @property
-    def name(self):
-        """str: name for the job template, does not need to be unique max 128 
-        characters"""
-        return self._name
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @name.setter
-    def name(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._jobDefinition:
-            result["jobDefinition"] = \
-                self._jobDefinition.toDict() if self._jobDefinition is not None else None
-        if self._labels:
-            result["labels"] = \
-                self._labels.toDict() if self._labels is not None else None
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._ace is not None:
+            result["ace"] = \
+                self._ace
+        if self._owner is not None:
+            result["owner"] = \
+                self._owner
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._version is None:
             raise ValueError(
-                "JobTemplateUpdateRequest.name doesnt match requirement:" 
+                "ProjectCreateRequest.version doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) < 2):
+        if self._ace is None:
             raise ValueError(
-                "JobTemplateUpdateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
+                "ProjectCreateRequest.ace doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._ace is not None
             and
-            len(self._name) > 128):
+            len(self._ace) < 1):
             raise ValueError(
-                "JobTemplateUpdateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 128")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-zA-Z\d][a-zA-Z\d\-\. ,_]*$",
-                 self._name)):
-            raise ValueError(
-                "JobTemplateUpdateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d][a-zA-Z\d\-\."
-                " ,_]*$")
-        if (self._description is not None
+                "ProjectCreateRequest.ace: " + str(self._ace) + 
+                " doesnt match requirement: minLength: 1")
+        if self._owner is None:
+            raise ValueError(
+                "ProjectCreateRequest.owner doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._owner is not None
             and
-            len(self._description) > 512):
+            len(self._owner) < 1):
             raise ValueError(
-                "JobTemplateUpdateRequest.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 512")
-        if (self._jobDefinition is not None): self._jobDefinition.isValid()
-        if (self._labels is not None): self._labels.isValid()
+                "ProjectCreateRequest.owner: " + str(self._owner) + 
+                " doesnt match requirement: minLength: 1")
+        if self._params is None:
+            raise ValueError(
+                "ProjectCreateRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/api/JobVolume.py` & `ngcbpc/data/uis/CreateUserRolesRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,54 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobVolume(object):
+class CreateUserRolesRequest(object):
+    """Create UserRoles request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.roles = (
             None if not fromDict or propDict.get(
-                "name"
+                "roles"
             ) is None
-            else propDict["name"])
+            else propDict["roles"])
 
     @property
-    def name(self):
-        """str: Name of the job volume"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def roles(self):
+        """list: A list of roles to be added"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._roles is None:
             raise ValueError(
-                "JobVolume.name doesnt match requirement:" 
+                "CreateUserRolesRequest.roles doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/JobVolumeMount.py` & `ngcbpc/data/registry/Platform.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,111 +14,127 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobVolumeMount(object):
+class Platform(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerMountPoint = (
+        self.architecture = (
             None if not fromDict or propDict.get(
-                "containerMountPoint"
+                "architecture"
             ) is None
-            else propDict["containerMountPoint"])
-        self.mountMode = (
+            else propDict["architecture"])
+        self.features = (
             None if not fromDict or propDict.get(
-                "mountMode"
+                "features"
             ) is None
-            else propDict["mountMode"])
-        self.name = (
+            else propDict["features"])
+        self.os = (
             None if not fromDict or propDict.get(
-                "name"
+                "os"
             ) is None
-            else propDict["name"])
+            else propDict["os"])
+        self.variant = (
+            None if not fromDict or propDict.get(
+                "variant"
+            ) is None
+            else propDict["variant"])
 
     @property
-    def containerMountPoint(self):
-        """str: Mount point inside the container to which this job volume will
-         be mapped"""
-        return self._containerMountPoint
+    def architecture(self):
+        """str: The architecture field specifies the CPU architecture, for exa
+        mple amd64 or ppc64le."""
+        return self._architecture
 
-    @containerMountPoint.setter
-    def containerMountPoint(self, value):
+    @architecture.setter
+    def architecture(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerMountPoint = value
+            self._architecture = value
         else:
             raise TypeError(
-                'Property "containerMountPoint" of type "list<str>" set to wr'
-                'ong type'
+                'Property "architecture" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def mountMode(self):
-        """MountModeEnum: Permissions for the volume when mounted"""
-        return self._mountMode
-
-    @mountMode.setter
-    def mountMode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._mountMode = value
+    def features(self):
+        """list: The optional features field specifies an array of strings, ea
+        ch listing a required CPU feature (for example sse4 or aes)."""
+        return self._features
+
+    @features.setter
+    def features(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._features = value
         else:
             raise TypeError(
-                'Property "mountMode" of type "list<MountModeEnum>" set to wr'
-                'ong type'
+                'Property "features" of type "list<str>" set to wrong type'
             )
 
-    MountModeEnum=["RO","RW",]
-    str(repr(MountModeEnum))  # Prevent optimizer removing enum
+    @property
+    def os(self):
+        """str: The os field specifies the operating system, for example linux
+         or windows."""
+        return self._os
+
+    @os.setter
+    def os(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._os = value
+        else:
+            raise TypeError(
+                'Property "os" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def name(self):
-        """str: Name of the job volume"""
-        return self._name
+    def variant(self):
+        """str: The optional variant field specifies a variant of the CPU, for
+         example armv6l to specify a particular CPU variant of the ARM
+         CPU."""
+        return self._variant
 
-    @name.setter
-    def name(self, value):
+    @variant.setter
+    def variant(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._variant = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "variant" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._containerMountPoint is not None:
-            result["containerMountPoint"] = \
-                self._containerMountPoint
-        if self._mountMode is not None:
-            result["mountMode"] = \
-                self._mountMode
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._architecture is not None:
+            result["architecture"] = \
+                self._architecture
+        if self._features is not None:
+            result["features"] = \
+                self._features
+        if self._os is not None:
+            result["os"] = \
+                self._os
+        if self._variant is not None:
+            result["variant"] = \
+                self._variant
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "JobVolumeMount.name doesnt match requirement:" 
-                "required: True"
-            )
-        if self._containerMountPoint is None:
-            raise ValueError(
-                "JobVolumeMount.containerMountPoint doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/JobWorkspaceMountInfo.py` & `basecommand/data/pym/Workspace.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,111 +14,125 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class JobWorkspaceMountInfo(object):
+class Workspace(object):
+    """Workspace mount"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerMountPoint = (
-            None if not fromDict or propDict.get(
-                "containerMountPoint"
-            ) is None
-            else propDict["containerMountPoint"])
         self.id = (
             None if not fromDict or propDict.get(
                 "id"
             ) is None
             else propDict["id"])
-        self.mountMode = (
+        self.mountPoint = (
+            None if not fromDict or propDict.get(
+                "mountPoint"
+            ) is None
+            else propDict["mountPoint"])
+        self.rw = (
             None if not fromDict or propDict.get(
-                "mountMode"
+                "rw"
             ) is None
-            else propDict["mountMode"])
+            else propDict["rw"])
 
     @property
-    def containerMountPoint(self):
-        """str: Mount point inside the container to which this workspace will 
-        be mapped"""
-        return self._containerMountPoint
+    def id(self):
+        """str: Workspace id"""
+        return self._id
 
-    @containerMountPoint.setter
-    def containerMountPoint(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerMountPoint = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "containerMountPoint" of type "list<str>" set to wr'
-                'ong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """str: Workspace ID"""
-        return self._id
+    def mountPoint(self):
+        """str: Workspace mount point"""
+        return self._mountPoint
 
-    @id.setter
-    def id(self, value):
+    @mountPoint.setter
+    def mountPoint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._id = value
+            self._mountPoint = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "mountPoint" of type "list<str>" set to wrong type'
             )
 
     @property
-    def mountMode(self):
-        """MountModeEnum: Permissions for the volume when mounted"""
-        return self._mountMode
-
-    @mountMode.setter
-    def mountMode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._mountMode = value
+    def rw(self):
+        """bool: Workspace read write"""
+        return self._rw
+
+    @rw.setter
+    def rw(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._rw = value
         else:
             raise TypeError(
-                'Property "mountMode" of type "list<MountModeEnum>" set to wr'
-                'ong type'
+                'Property "rw" of type "list<bool>" set to wrong type'
             )
 
-    MountModeEnum=["RO","RW",]
-    str(repr(MountModeEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._containerMountPoint is not None:
-            result["containerMountPoint"] = \
-                self._containerMountPoint
         if self._id is not None:
             result["id"] = \
                 self._id
-        if self._mountMode is not None:
-            result["mountMode"] = \
-                self._mountMode
+        if self._mountPoint is not None:
+            result["mountPoint"] = \
+                self._mountPoint
+        if self._rw is not None:
+            result["rw"] = \
+                self._rw
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._id is None:
             raise ValueError(
-                "JobWorkspaceMountInfo.id doesnt match requirement:" 
+                "Workspace.id doesnt match requirement:" 
                 "required: True"
             )
-        if self._containerMountPoint is None:
+        if (self._id is not None
+            and
+            len(self._id) < 1):
+            raise ValueError(
+                "Workspace.id: " + str(self._id) + 
+                " doesnt match requirement: minLength: 1")
+        if self._mountPoint is None:
+            raise ValueError(
+                "Workspace.mountPoint doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._mountPoint is not None
+            and
+            len(self._mountPoint) < 1):
+            raise ValueError(
+                "Workspace.mountPoint: " + str(self._mountPoint) + 
+                " doesnt match requirement: minLength: 1")
+        if self._rw is None:
             raise ValueError(
-                "JobWorkspaceMountInfo.containerMountPoint doesnt match requirement:" 
+                "Workspace.rw doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/api/Measurement.py` & `ngcbpc/data/registry/AnchoreParameter.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,42 +14,66 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Measurement(object):
-    """object for the measurement values"""
+class AnchoreParameter(object):
+    """Name-value parameter"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
         self.value = (
             None if not fromDict or propDict.get(
                 "value"
             ) is None
             else propDict["value"])
 
     @property
+    def name(self):
+        """ """
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def value(self):
-        """list: list of values, in the same order as columns"""
+        """ """
         return self._value
 
     @value.setter
     def value(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
             self._value = value
         else:
             raise TypeError(
                 'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._name is not None:
+            result["name"] = \
+                self._name
         if self._value is not None:
             result["value"] = \
                 self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
```

## Comparing `ngccli/data/api/MeasurementAlert.py` & `ngcbpc/data/uis/IdpRule.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,235 +6,245 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeasurementType import MeasurementTypeEnum
-from .MeasurementAlertCriteria import MeasurementAlertCriteria
-from .AlertDeliveryMode import AlertDeliveryMode
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlertCriteria))
-str(repr(AlertDeliveryMode))
-str(repr(MeasurementTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementAlert(object):
-    """Measurement Alert"""
+class IdpRule(object):
+    """Information about the IDP rule"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.createdBy = (
+            None if not fromDict or propDict.get(
+                "createdBy"
+            ) is None
+            else propDict["createdBy"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.criteria = (
+        self.idpId = (
             None if not fromDict or propDict.get(
-                "criteria"
+                "idpId"
             ) is None
-            else [ MeasurementAlertCriteria(i)
-            for i in propDict["criteria"] ])
-        self.deliveryModes = (
+            else propDict["idpId"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "deliveryModes"
+                "namespace"
             ) is None
-            else [ AlertDeliveryMode(i)
-            for i in propDict["deliveryModes"] ])
-        self.description = (
+            else propDict["namespace"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "description"
+                "orgName"
             ) is None
-            else propDict["description"])
-        self.enabled = (
+            else propDict["orgName"])
+        self.queryString = (
             None if not fromDict or propDict.get(
-                "enabled"
+                "queryString"
             ) is None
-            else propDict["enabled"])
-        self.eventType = (
+            else propDict["queryString"])
+        self.roles = (
             None if not fromDict or propDict.get(
-                "eventType"
+                "roles"
             ) is None
-            else propDict["eventType"])
-        self.id = (
+            else propDict["roles"])
+        self.ruleId = (
             None if not fromDict or propDict.get(
-                "id"
+                "ruleId"
             ) is None
-            else propDict["id"])
-        self.message = (
+            else propDict["ruleId"])
+        self.ruleName = (
             None if not fromDict or propDict.get(
-                "message"
+                "ruleName"
             ) is None
-            else propDict["message"])
-        self.name = (
+            else propDict["ruleName"])
+        self.updatedBy = (
             None if not fromDict or propDict.get(
-                "name"
+                "updatedBy"
             ) is None
-            else propDict["name"])
+            else propDict["updatedBy"])
         self.updatedDate = (
             None if not fromDict or propDict.get(
                 "updatedDate"
             ) is None
             else propDict["updatedDate"])
 
     @property
+    def createdBy(self):
+        """str: Email of user creating the rule"""
+        return self._createdBy
+
+    @createdBy.setter
+    def createdBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdBy = value
+        else:
+            raise TypeError(
+                'Property "createdBy" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def createdDate(self):
-        """str: Date at which this alert was created"""
+        """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._createdDate = value
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def criteria(self):
-        """list: List of criterion at which alerts will be fired"""
-        return self._criteria
+    def idpId(self):
+        """str: Unique IDP ID"""
+        return self._idpId
 
-    @criteria.setter
-    def criteria(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._criteria = value
+    @idpId.setter
+    def idpId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._idpId = value
         else:
             raise TypeError(
-                'Property "criteria" of type "list<MeasurementAlertCriteria>"'
-                ' set to wrong type'
+                'Property "idpId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def deliveryModes(self):
-        """ """
-        return self._deliveryModes
+    def namespace(self):
+        """str: Namespace to add users to if the rule applies"""
+        return self._namespace
 
-    @deliveryModes.setter
-    def deliveryModes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._deliveryModes = value
+    @namespace.setter
+    def namespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "deliveryModes" of type "list<AlertDeliveryMode>" s'
-                'et to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: User defined description for this alert"""
-        return self._description
+    def orgName(self):
+        """str: Organization name"""
+        return self._orgName
 
-    @description.setter
-    def description(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def enabled(self):
-        """bool: Specifies whether is alert is enabled or disabled. Alerts are
-         enabled by default, but can be created disabled."""
-        return self._enabled
+    def queryString(self):
+        """str: Query to use to determine if rule applies"""
+        return self._queryString
 
-    @enabled.setter
-    def enabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enabled = value
+    @queryString.setter
+    def queryString(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._queryString = value
         else:
             raise TypeError(
-                'Property "enabled" of type "list<bool>" set to wrong type'
+                'Property "queryString" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventType(self):
-        """ """
-        return self._eventType
+    def roles(self):
+        """list: A list of roles to be added"""
+        return self._roles
 
-    @eventType.setter
-    def eventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._eventType = value
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "eventType" of type "list<MeasurementTypeEnum>" set'
-                ' to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Unique identification for this measurement alert"""
-        return self._id
+    def ruleId(self):
+        """str: Unique IDP rule UUID"""
+        return self._ruleId
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @ruleId.setter
+    def ruleId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ruleId = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "ruleId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def message(self):
-        """str: Message generated for alert, leave blank for default message
-        """
-        return self._message
+    def ruleName(self):
+        """str: User readable name of the IDP rule"""
+        return self._ruleName
 
-    @message.setter
-    def message(self, value):
+    @ruleName.setter
+    def ruleName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._ruleName = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "ruleName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: User defined alert name"""
-        return self._name
+    def updatedBy(self):
+        """str: Email of user updating the rule"""
+        return self._updatedBy
 
-    @name.setter
-    def name(self, value):
+    @updatedBy.setter
+    def updatedBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._updatedBy = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "updatedBy" of type "list<str>" set to wrong type'
             )
 
     @property
     def updatedDate(self):
-        """str: Date at which this alert was updated"""
+        """str: Update date in ISO-8601 format"""
         return self._updatedDate
 
     @updatedDate.setter
     def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -242,57 +252,92 @@
         else:
             raise TypeError(
                 'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._createdBy is not None:
+            result["createdBy"] = \
+                self._createdBy
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._criteria:
-            result["criteria"] = [
-                i.toDict() for i in self._criteria 
-            ] if self._criteria else []
-        if self._deliveryModes:
-            result["deliveryModes"] = [
-                i.toDict() for i in self._deliveryModes 
-            ] if self._deliveryModes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._enabled is not None:
-            result["enabled"] = \
-                self._enabled
-        if self._eventType is not None:
-            result["eventType"] = \
-                self._eventType
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._message is not None:
-            result["message"] = \
-                self._message
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._idpId is not None:
+            result["idpId"] = \
+                self._idpId
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._queryString is not None:
+            result["queryString"] = \
+                self._queryString
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
+        if self._ruleId is not None:
+            result["ruleId"] = \
+                self._ruleId
+        if self._ruleName is not None:
+            result["ruleName"] = \
+                self._ruleName
+        if self._updatedBy is not None:
+            result["updatedBy"] = \
+                self._updatedBy
         if self._updatedDate is not None:
             result["updatedDate"] = \
                 self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._criteria is not None):
-            for obj in self._criteria:
-                if (obj is not None): obj.isValid()
-        if (self._deliveryModes is not None):
-            for obj in self._deliveryModes:
-                if (obj is not None): obj.isValid()
+        if self._idpId is None:
+            raise ValueError(
+                "IdpRule.idpId doesnt match requirement:" 
+                "required: True"
+            )
+        if self._orgName is None:
+            raise ValueError(
+                "IdpRule.orgName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._ruleId is None:
+            raise ValueError(
+                "IdpRule.ruleId doesnt match requirement:" 
+                "required: True"
+            )
+        if self._ruleName is None:
+            raise ValueError(
+                "IdpRule.ruleName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._namespace is None:
+            raise ValueError(
+                "IdpRule.namespace doesnt match requirement:" 
+                "required: True"
+            )
+        if self._queryString is None:
+            raise ValueError(
+                "IdpRule.queryString doesnt match requirement:" 
+                "required: True"
+            )
+        if self._roles is None:
+            raise ValueError(
+                "IdpRule.roles doesnt match requirement:" 
+                "required: True"
+            )
+        if self._createdDate is None:
+            raise ValueError(
+                "IdpRule.createdDate doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/MeasurementAlertCreateRequest.py` & `ngcbpc/data/uis/UserCreateRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,264 +6,275 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeasurementType import MeasurementTypeEnum
-from .MeasurementAlertCriteria import MeasurementAlertCriteria
-from .AlertDeliveryMode import AlertDeliveryMode
+from .UserMetadata import UserMetadata
+from .RoleType import RoleTypeEnum
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlertCriteria))
-str(repr(AlertDeliveryMode))
-str(repr(MeasurementTypeEnum))
+str(repr(UserMetadata))
+str(repr(RoleTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementAlertCreateRequest(object):
-    """Request to create measurement alert"""
+class UserCreateRequest(object):
+    """object used request user creation in an existing org"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.criteria = (
+        self.email = (
             None if not fromDict or propDict.get(
-                "criteria"
+                "email"
             ) is None
-            else [ MeasurementAlertCriteria(i)
-            for i in propDict["criteria"] ])
-        self.deliveryModes = (
+            else propDict["email"])
+        self.emailOptIn = (
             None if not fromDict or propDict.get(
-                "deliveryModes"
+                "emailOptIn"
             ) is None
-            else [ AlertDeliveryMode(i)
-            for i in propDict["deliveryModes"] ])
-        self.description = (
+            else propDict["emailOptIn"])
+        self.eulaAccepted = (
             None if not fromDict or propDict.get(
-                "description"
+                "eulaAccepted"
             ) is None
-            else propDict["description"])
-        self.enabled = (
+            else propDict["eulaAccepted"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "enabled"
+                "name"
             ) is None
-            else propDict["enabled"])
-        self.eventType = (
+            else propDict["name"])
+        self.roleType = (
             None if not fromDict or propDict.get(
-                "eventType"
+                "roleType"
             ) is None
-            else propDict["eventType"])
-        self.message = (
+            else propDict["roleType"])
+        self.roleTypes = (
             None if not fromDict or propDict.get(
-                "message"
+                "roleTypes"
             ) is None
-            else propDict["message"])
-        self.name = (
+            else propDict["roleTypes"])
+        self.salesforceContactJobRole = (
             None if not fromDict or propDict.get(
-                "name"
+                "salesforceContactJobRole"
             ) is None
-            else propDict["name"])
+            else propDict["salesforceContactJobRole"])
+        self.userMetadata = (
+            None if not fromDict or propDict.get(
+                "userMetadata"
+            ) is None
+            else propDict["userMetadata"])
 
     @property
-    def criteria(self):
-        """list: List of criterion at which alerts will be fired"""
-        return self._criteria
+    def email(self):
+        """str: Email address of the user. This should be unique."""
+        return self._email
 
-    @criteria.setter
-    def criteria(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._criteria = value
+    @email.setter
+    def email(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._email = value
         else:
             raise TypeError(
-                'Property "criteria" of type "list<MeasurementAlertCriteria>"'
-                ' set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def deliveryModes(self):
-        """ """
-        return self._deliveryModes
+    def emailOptIn(self):
+        """bool: indicates if user has opt in to nvidia emails"""
+        return self._emailOptIn
 
-    @deliveryModes.setter
-    def deliveryModes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._deliveryModes = value
+    @emailOptIn.setter
+    def emailOptIn(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._emailOptIn = value
         else:
             raise TypeError(
-                'Property "deliveryModes" of type "list<AlertDeliveryMode>" s'
-                'et to wrong type'
+                'Property "emailOptIn" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: User defined description for this alert"""
-        return self._description
+    def eulaAccepted(self):
+        """bool: indicates if user has accepted EULA"""
+        return self._eulaAccepted
+
+    @eulaAccepted.setter
+    def eulaAccepted(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._eulaAccepted = value
+        else:
+            raise TypeError(
+                'Property "eulaAccepted" of type "list<bool>" set to wrong ty'
+                'pe'
+            )
 
-    @description.setter
-    def description(self, value):
+    @property
+    def name(self):
+        """str: user name"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def enabled(self):
-        """bool: Specifies whether is alert is enabled or disabled. Alerts are
-         enabled by default, but can be created disabled"""
-        return self._enabled
+    def roleType(self):
+        """RoleTypeEnum: ADMIN have admin access over all features. ADMIN_READ
+        _ONLY have admin_read access over all features. USER have user
+         access over all features. The remaining roles specify the features th
+        at it has access to."""
+        return self._roleType
 
-    @enabled.setter
-    def enabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enabled = value
+    @roleType.setter
+    def roleType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._roleType = value
         else:
             raise TypeError(
-                'Property "enabled" of type "list<bool>" set to wrong type'
+                'Property "roleType" of type "list<RoleTypeEnum>" set to wron'
+                'g type'
             )
 
     @property
-    def eventType(self):
-        """ """
-        return self._eventType
+    def roleTypes(self):
+        """list: feature roles to give to the user"""
+        return self._roleTypes
 
-    @eventType.setter
-    def eventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._eventType = value
+    @roleTypes.setter
+    def roleTypes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roleTypes = value
         else:
             raise TypeError(
-                'Property "eventType" of type "list<MeasurementTypeEnum>" set'
-                ' to wrong type'
+                'Property "roleTypes" of type "list<RoleTypeEnum>" set to wro'
+                'ng type'
             )
 
     @property
-    def message(self):
-        """str: Message generated for alert, leave blank for custom message"""
-        return self._message
+    def salesforceContactJobRole(self):
+        """str: user job role"""
+        return self._salesforceContactJobRole
 
-    @message.setter
-    def message(self, value):
+    @salesforceContactJobRole.setter
+    def salesforceContactJobRole(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._message = value
+            self._salesforceContactJobRole = value
         else:
             raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
+                'Property "salesforceContactJobRole" of type "list<str>" set '
+                'to wrong type'
             )
 
     @property
-    def name(self):
-        """str: User defined alert name"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def userMetadata(self):
+        """UserMetadata: Metadata information about the user."""
+        return self._userMetadata
+
+    @userMetadata.setter
+    def userMetadata(self, value):
+        if value is not None and not isinstance(value, UserMetadata):
+            value = UserMetadata(value)
+        if (value is None) or isinstance(value, UserMetadata):
+            self._userMetadata = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "userMetadata" of type "list<UserMetadata>" set to '
+                'wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._criteria:
-            result["criteria"] = [
-                i.toDict() for i in self._criteria 
-            ] if self._criteria else []
-        if self._deliveryModes:
-            result["deliveryModes"] = [
-                i.toDict() for i in self._deliveryModes 
-            ] if self._deliveryModes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._enabled is not None:
-            result["enabled"] = \
-                self._enabled
-        if self._eventType is not None:
-            result["eventType"] = \
-                self._eventType
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._emailOptIn is not None:
+            result["emailOptIn"] = \
+                self._emailOptIn
+        if self._eulaAccepted is not None:
+            result["eulaAccepted"] = \
+                self._eulaAccepted
         if self._name is not None:
             result["name"] = \
                 self._name
+        if self._roleType is not None:
+            result["roleType"] = \
+                self._roleType
+        if self._roleTypes is not None:
+            result["roleTypes"] = \
+                self._roleTypes
+        if self._salesforceContactJobRole is not None:
+            result["salesforceContactJobRole"] = \
+                self._salesforceContactJobRole
+        if self._userMetadata:
+            result["userMetadata"] = \
+                self._userMetadata.toDict() if self._userMetadata is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if (self._name is not None
+            and
+            len(self._name) < 1):
             raise ValueError(
-                "MeasurementAlertCreateRequest.name doesnt match requirement:" 
-                "required: True"
-            )
+                "UserCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
         if (self._name is not None
             and
             len(self._name) > 64):
             raise ValueError(
-                "MeasurementAlertCreateRequest.name: " + str(self._name) + 
+                "UserCreateRequest.name: " + str(self._name) + 
                 " doesnt match requirement: maxLength: 64")
-        if (self._description is not None
-            and
-            len(self._description) > 128):
-            raise ValueError(
-                "MeasurementAlertCreateRequest.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 128")
-        if (self._message is not None
-            and
-            len(self._message) > 255):
+        if self._email is None:
             raise ValueError(
-                "MeasurementAlertCreateRequest.message: " + str(self._message) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._eventType is None:
-            raise ValueError(
-                "MeasurementAlertCreateRequest.eventType doesnt match requirement:" 
+                "UserCreateRequest.email doesnt match requirement:" 
                 "required: True"
             )
-        if self._criteria is None:
+        if (self._email is not None
+            and
+            len(self._email) < 6):
             raise ValueError(
-                "MeasurementAlertCreateRequest.criteria doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._criteria is not None
+                "UserCreateRequest.email: " + str(self._email) + 
+                " doesnt match requirement: minLength: 6")
+        if (self._email is not None
             and
-            len(self._criteria) < 1):
+            len(self._email) > 128):
             raise ValueError(
-                "MeasurementAlertCreateRequest.criteria: " + str(self._criteria) + 
-                " doesnt match requirement: minItems: 1")
-        if self._deliveryModes is None:
+                "UserCreateRequest.email: " + str(self._email) + 
+                " doesnt match requirement: maxLength: 128")
+        if (self._email is not None
+            and
+            not re.match(
+                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
+                 self._email)):
             raise ValueError(
-                "MeasurementAlertCreateRequest.deliveryModes doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._criteria is not None):
-            for obj in self._criteria:
-                if (obj is not None): obj.isValid()
-        if (self._deliveryModes is not None):
-            for obj in self._deliveryModes:
-                if (obj is not None): obj.isValid()
+                "UserCreateRequest.email: " + str(self._email) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
+                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
+        if (self._userMetadata is not None): self._userMetadata.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementAlertCriteria.py` & `ngcbpc/data/registry/PlatformManifest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,136 +6,143 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Platform import Platform
 
 # Unused import over optimization prevention
+str(repr(Platform))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementAlertCriteria(object):
-    """Measurement Alert"""
+class PlatformManifest(object):
+    """Image manifest specific to a platform i.e. os/architecture. Used for mu
+    lti-arch manifest list. For more information see: https://github.com/d
+    ocker/distribution/blob/master/docs/spec/manifest-v2-2.md"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.comparator = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "comparator"
+                "digest"
             ) is None
-            else propDict["comparator"])
-        self.level = (
+            else propDict["digest"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "level"
+                "mediaType"
             ) is None
-            else propDict["level"])
-        self.percent = (
+            else propDict["mediaType"])
+        self.platform = (
             None if not fromDict or propDict.get(
-                "percent"
+                "platform"
             ) is None
-            else propDict["percent"])
+            else propDict["platform"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
 
     @property
-    def comparator(self):
-        """ """
-        return self._comparator
-
-    @comparator.setter
-    def comparator(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._comparator = value
+    def digest(self):
+        """str: The digest of the content, as defined by the Registry V2 HTTP 
+        API Specificiation."""
+        return self._digest
+
+    @digest.setter
+    def digest(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._digest = value
         else:
             raise TypeError(
-                'Property "comparator" of type "list<ComparatorEnum>" set to '
-                'wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
-    ComparatorEnum=["LESS_THAN","LESS_THAN_OR_EQUAL_TO","GREATER_THAN","GREATER_THAN_OR_EQUAL_TO",]
-    str(repr(ComparatorEnum))  # Prevent optimizer removing enum
+    @property
+    def mediaType(self):
+        """str: The MIME type of the referenced object. This will generally be
+         application/vnd.docker.distribution.manifest.v2+json, but it 
+        could also be application/vnd.docker.distribution.manifest.v1+json if 
+        the manifest list references a legacy schema-1 manifest."""
+        return self._mediaType
+
+    @mediaType.setter
+    def mediaType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._mediaType = value
+        else:
+            raise TypeError(
+                'Property "mediaType" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def level(self):
+    def platform(self):
         """ """
-        return self._level
+        return self._platform
 
-    @level.setter
-    def level(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._level = value
+    @platform.setter
+    def platform(self, value):
+        if value is not None and not isinstance(value, Platform):
+            value = Platform(value)
+        if (value is None) or isinstance(value, Platform):
+            self._platform = value
         else:
             raise TypeError(
-                'Property "level" of type "list<LevelEnum>" set to wrong type'
+                'Property "platform" of type "list<Platform>" set to wrong ty'
+                'pe'
             )
 
-    LevelEnum=["INFO","WARN","CRITICAL",]
-    str(repr(LevelEnum))  # Prevent optimizer removing enum
-
     @property
-    def percent(self):
-        """long: Percentage value used for comparison"""
-        return self._percent
-
-    @percent.setter
-    def percent(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._percent = value
+    def size(self):
+        """int: The size in bytes of the object. This field exists so that a c
+        lient will have an expected size for the content before valida
+        ting. If the length of the retrieved content does not match the specif
+        ied length, the content should not be trusted."""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._size = value
         else:
             raise TypeError(
-                'Property "percent" of type "list<long>" set to wrong type'
+                'Property "size" of type "list<int>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._comparator is not None:
-            result["comparator"] = \
-                self._comparator
-        if self._level is not None:
-            result["level"] = \
-                self._level
-        if self._percent is not None:
-            result["percent"] = \
-                self._percent
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._platform:
+            result["platform"] = \
+                self._platform.toDict() if self._platform is not None else None
+        if self._size is not None:
+            result["size"] = \
+                self._size
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._percent is None:
-            raise ValueError(
-                "MeasurementAlertCriteria.percent doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._percent is not None
-            and
-            self._percent < 0):
-            raise ValueError(
-                "MeasurementAlertCriteria.percent: " + str(self._percent) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._percent is not None
-            and
-            self._percent > 100):
-            raise ValueError(
-                "MeasurementAlertCriteria.percent: " + str(self._percent) + 
-                " doesnt match requirement: maximum: 100")
-        if self._comparator is None:
-            raise ValueError(
-                "MeasurementAlertCriteria.comparator doesnt match requirement:" 
-                "required: True"
-            )
-        if self._level is None:
-            raise ValueError(
-                "MeasurementAlertCriteria.level doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._platform is not None): self._platform.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementAlertListResponse.py` & `ngcbpc/data/model/ModelListResponse.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,69 +6,68 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
-from .MeasurementAlert import MeasurementAlert
+from .Model import Model
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlert))
 str(repr(RequestStatus))
+str(repr(Model))
 str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementAlertListResponse(object):
-    """Response to show measurement alerts"""
+class ModelListResponse(object):
+    """Response to list models request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alerts = (
+        self.models = (
             None if not fromDict or propDict.get(
-                "alerts"
+                "models"
             ) is None
-            else [ MeasurementAlert(i)
-            for i in propDict["alerts"] ])
+            else [ Model(i)
+            for i in propDict["models"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def alerts(self):
+    def models(self):
         """ """
-        return self._alerts
+        return self._models
 
-    @alerts.setter
-    def alerts(self, value):
+    @models.setter
+    def models(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._alerts = value
+            self._models = value
         else:
             raise TypeError(
-                'Property "alerts" of type "list<MeasurementAlert>" set to wr'
-                'ong type'
+                'Property "models" of type "list<Model>" set to wrong type'
             )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -77,15 +76,15 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -94,18 +93,18 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._alerts:
-            result["alerts"] = [
-                i.toDict() for i in self._alerts 
-            ] if self._alerts else []
+        if self._models:
+            result["models"] = [
+                i.toDict() for i in self._models 
+            ] if self._models else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -113,15 +112,15 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._alerts is not None):
-            for obj in self._alerts:
+        if (self._models is not None):
+            for obj in self._models:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementAlertResponse.py` & `ngcbpc/data/model/ModelCreateResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,60 +7,59 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .MeasurementAlert import MeasurementAlert
+from .Model import Model
 
 # Unused import over optimization prevention
-str(repr(MeasurementAlert))
 str(repr(RequestStatus))
+str(repr(Model))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementAlertResponse(object):
-    """Response to show measurement alert"""
+class ModelCreateResponse(object):
+    """DEPRECATED - use ModelResponse schema"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alert = (
+        self.model = (
             None if not fromDict or propDict.get(
-                "alert"
+                "model"
             ) is None
-            else propDict["alert"])
+            else propDict["model"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def alert(self):
-        """MeasurementAlert: Measurement Alert"""
-        return self._alert
-
-    @alert.setter
-    def alert(self, value):
-        if value is not None and not isinstance(value, MeasurementAlert):
-            value = MeasurementAlert(value)
-        if (value is None) or isinstance(value, MeasurementAlert):
-            self._alert = value
+    def model(self):
+        """Model: Model object"""
+        return self._model
+
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
         else:
             raise TypeError(
-                'Property "alert" of type "list<MeasurementAlert>" set to wro'
-                'ng type'
+                'Property "model" of type "list<Model>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -69,27 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._alert:
-            result["alert"] = \
-                self._alert.toDict() if self._alert is not None else None
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._alert is not None): self._alert.isValid()
+        if (self._model is not None): self._model.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementQueryParams.py` & `basecommand/data/pym/ClusterURLs.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,183 +6,158 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeasurementType import MeasurementTypeEnum
-from .MeasurementAggregationType import MeasurementAggregationTypeEnum
+from .AdditionalOpenPortURLs import AdditionalOpenPortURLs
 
 # Unused import over optimization prevention
-str(repr(MeasurementAggregationTypeEnum))
-str(repr(MeasurementTypeEnum))
+str(repr(AdditionalOpenPortURLs))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementQueryParams(object):
-    """object for defining params to a single series in the measurement"""
+class ClusterURLs(object):
+    """Cluster URLs"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aggregation = (
+        self.additionalOpenPorts = (
             None if not fromDict or propDict.get(
-                "aggregation"
+                "additionalOpenPorts"
             ) is None
-            else propDict["aggregation"])
-        self.fromDate = (
+            else [ AdditionalOpenPortURLs(i)
+            for i in propDict["additionalOpenPorts"] ])
+        self.dashboard = (
             None if not fromDict or propDict.get(
-                "fromDate"
+                "dashboard"
             ) is None
-            else propDict["fromDate"])
-        self.groupBy = (
+            else propDict["dashboard"])
+        self.scheduler = (
             None if not fromDict or propDict.get(
-                "groupBy"
+                "scheduler"
             ) is None
-            else propDict["groupBy"])
-        self.period = (
+            else propDict["scheduler"])
+        self.telemetry = (
             None if not fromDict or propDict.get(
-                "period"
+                "telemetry"
             ) is None
-            else propDict["period"])
-        self.toDate = (
-            None if not fromDict or propDict.get(
-                "toDate"
-            ) is None
-            else propDict["toDate"])
-        self.type = (
-            None if not fromDict or propDict.get(
-                "type"
-            ) is None
-            else propDict["type"])
+            else propDict["telemetry"])
 
     @property
-    def aggregation(self):
-        """ """
-        return self._aggregation
-
-    @aggregation.setter
-    def aggregation(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._aggregation = value
+    def additionalOpenPorts(self):
+        """list: Additional open port URLs"""
+        return self._additionalOpenPorts
+
+    @additionalOpenPorts.setter
+    def additionalOpenPorts(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._additionalOpenPorts = value
         else:
             raise TypeError(
-                'Property "aggregation" of type "list<MeasurementAggregationT'
-                'ypeEnum>" set to wrong type'
+                'Property "additionalOpenPorts" of type "list<AdditionalOpenP'
+                'ortURLs>" set to wrong type'
             )
 
     @property
-    def fromDate(self):
-        """str: end time range for the data, in ISO formate, yyyy-MM-dd'T'HH:m
-        m:ss.SSS'Z'"""
-        return self._fromDate
+    def dashboard(self):
+        """str: Dashboard endpoint URL"""
+        return self._dashboard
 
-    @fromDate.setter
-    def fromDate(self, value):
+    @dashboard.setter
+    def dashboard(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fromDate = value
+            self._dashboard = value
         else:
             raise TypeError(
-                'Property "fromDate" of type "list<str>" set to wrong type'
+                'Property "dashboard" of type "list<str>" set to wrong type'
             )
 
     @property
-    def groupBy(self):
-        """list: group by specific tags"""
-        return self._groupBy
-
-    @groupBy.setter
-    def groupBy(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._groupBy = value
-        else:
-            raise TypeError(
-                'Property "groupBy" of type "list<str>" set to wrong type'
-            )
+    def scheduler(self):
+        """str: Scheduler endpoint URL"""
+        return self._scheduler
 
-    @property
-    def period(self):
-        """float: time period to aggregate the data over with, in seconds. If 
-        none provided, raw data will be returned."""
-        return self._period
-
-    @period.setter
-    def period(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._period = value
+    @scheduler.setter
+    def scheduler(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._scheduler = value
         else:
             raise TypeError(
-                'Property "period" of type "list<float>" set to wrong type'
+                'Property "scheduler" of type "list<str>" set to wrong type'
             )
 
     @property
-    def toDate(self):
-        """str: start time range for the data, in ISO formate, yyyy-MM-dd'T'HH
-        :mm:ss.SSS'Z'"""
-        return self._toDate
+    def telemetry(self):
+        """str: Cluster telemetry URL"""
+        return self._telemetry
 
-    @toDate.setter
-    def toDate(self, value):
+    @telemetry.setter
+    def telemetry(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._toDate = value
-        else:
-            raise TypeError(
-                'Property "toDate" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def type(self):
-        """ """
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+            self._telemetry = value
         else:
             raise TypeError(
-                'Property "type" of type "list<MeasurementTypeEnum>" set to w'
-                'rong type'
+                'Property "telemetry" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aggregation is not None:
-            result["aggregation"] = \
-                self._aggregation
-        if self._fromDate is not None:
-            result["fromDate"] = \
-                self._fromDate
-        if self._groupBy is not None:
-            result["groupBy"] = \
-                self._groupBy
-        if self._period is not None:
-            result["period"] = \
-                self._period
-        if self._toDate is not None:
-            result["toDate"] = \
-                self._toDate
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._additionalOpenPorts:
+            result["additionalOpenPorts"] = [
+                i.toDict() for i in self._additionalOpenPorts 
+            ] if self._additionalOpenPorts else []
+        if self._dashboard is not None:
+            result["dashboard"] = \
+                self._dashboard
+        if self._scheduler is not None:
+            result["scheduler"] = \
+                self._scheduler
+        if self._telemetry is not None:
+            result["telemetry"] = \
+                self._telemetry
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._scheduler is None:
+            raise ValueError(
+                "ClusterURLs.scheduler doesnt match requirement:" 
+                "required: True"
+            )
+        if self._dashboard is None:
+            raise ValueError(
+                "ClusterURLs.dashboard doesnt match requirement:" 
+                "required: True"
+            )
+        if self._additionalOpenPorts is None:
+            raise ValueError(
+                "ClusterURLs.additionalOpenPorts doesnt match requirement:" 
+                "required: True"
+            )
+        if self._telemetry is None:
+            raise ValueError(
+                "ClusterURLs.telemetry doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._additionalOpenPorts is not None):
+            for obj in self._additionalOpenPorts:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementQueryRequest.py` & `organization/data/subscription_management_service/Tou.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,66 +6,81 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeasurementQueryParams import MeasurementQueryParams
 
 # Unused import over optimization prevention
-str(repr(MeasurementQueryParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementQueryRequest(object):
-    """request params for getting measurements"""
+class Tou(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.measurements = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "measurements"
+                "key"
             ) is None
-            else [ MeasurementQueryParams(i)
-            for i in propDict["measurements"] ])
+            else propDict["key"])
+        self.url = (
+            None if not fromDict or propDict.get(
+                "url"
+            ) is None
+            else propDict["url"])
+
+    @property
+    def key(self):
+        """ """
+        return self._key
+
+    @key.setter
+    def key(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._key = value
+        else:
+            raise TypeError(
+                'Property "key" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def measurements(self):
+    def url(self):
         """ """
-        return self._measurements
+        return self._url
 
-    @measurements.setter
-    def measurements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._measurements = value
+    @url.setter
+    def url(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._url = value
         else:
             raise TypeError(
-                'Property "measurements" of type "list<MeasurementQueryParams'
-                '>" set to wrong type'
+                'Property "url" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._measurements:
-            result["measurements"] = [
-                i.toDict() for i in self._measurements 
-            ] if self._measurements else []
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._url is not None:
+            result["url"] = \
+                self._url
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._measurements is not None):
-            for obj in self._measurements:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementResult.py` & `organization/data/subscription_management_service/ListProductOffersResponse.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,66 +6,94 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeasurementSeries import MeasurementSeries
+from .ProductOffer import ProductOffer
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(MeasurementSeries))
+str(repr(ProductOffer))
+str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementResult(object):
-    """result of a single measurement query"""
+class ListProductOffersResponse(object):
+    """List product offer response object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.series = (
+        self.offers = (
             None if not fromDict or propDict.get(
-                "series"
+                "offers"
             ) is None
-            else [ MeasurementSeries(i)
-            for i in propDict["series"] ])
+            else [ ProductOffer(i)
+            for i in propDict["offers"] ])
+        self.requestStatus = (
+            None if not fromDict or propDict.get(
+                "requestStatus"
+            ) is None
+            else propDict["requestStatus"])
 
     @property
-    def series(self):
-        """list: array of series within a measurement"""
-        return self._series
+    def offers(self):
+        """list: product offers"""
+        return self._offers
 
-    @series.setter
-    def series(self, value):
+    @offers.setter
+    def offers(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._series = value
+            self._offers = value
+        else:
+            raise TypeError(
+                'Property "offers" of type "list<ProductOffer>" set to wrong '
+                'type'
+            )
+
+    @property
+    def requestStatus(self):
+        """ """
+        return self._requestStatus
+
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "series" of type "list<MeasurementSeries>" set to w'
-                'rong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._series:
-            result["series"] = [
-                i.toDict() for i in self._series 
-            ] if self._series else []
+        if self._offers:
+            result["offers"] = [
+                i.toDict() for i in self._offers 
+            ] if self._offers else []
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._series is not None):
-            for obj in self._series:
+        if (self._offers is not None):
+            for obj in self._offers:
                 if (obj is not None): obj.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementResultListResponse.py` & `organization/data/subscription_management_service/ProductPlansResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,57 +6,57 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProductPlan import ProductPlan
 from .RequestStatus import RequestStatus
-from .MeasurementResult import MeasurementResult
 
 # Unused import over optimization prevention
-str(repr(MeasurementResult))
 str(repr(RequestStatus))
+str(repr(ProductPlan))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementResultListResponse(object):
-    """response containing a list of all measurement queries results"""
+class ProductPlansResponse(object):
+    """Response for list product plans API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.measurements = (
+        self.productPlans = (
             None if not fromDict or propDict.get(
-                "measurements"
+                "productPlans"
             ) is None
-            else [ MeasurementResult(i)
-            for i in propDict["measurements"] ])
+            else [ ProductPlan(i)
+            for i in propDict["productPlans"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def measurements(self):
-        """ """
-        return self._measurements
+    def productPlans(self):
+        """list: array of product plan objects"""
+        return self._productPlans
 
-    @measurements.setter
-    def measurements(self, value):
+    @productPlans.setter
+    def productPlans(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._measurements = value
+            self._productPlans = value
         else:
             raise TypeError(
-                'Property "measurements" of type "list<MeasurementResult>" se'
-                't to wrong type'
+                'Property "productPlans" of type "list<ProductPlan>" set to w'
+                'rong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,30 +70,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._measurements:
-            result["measurements"] = [
-                i.toDict() for i in self._measurements 
-            ] if self._measurements else []
+        if self._productPlans:
+            result["productPlans"] = [
+                i.toDict() for i in self._productPlans 
+            ] if self._productPlans else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._measurements is not None):
-            for obj in self._measurements:
+        if (self._productPlans is not None):
+            for obj in self._productPlans:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementSeries.py` & `basecommand/data/pym/SecretSpec.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,147 +6,127 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Measurement import Measurement
-from .MeasurementTag import MeasurementTag
+from .SecretKeySpec import SecretKeySpec
 
 # Unused import over optimization prevention
-str(repr(MeasurementTag))
-str(repr(Measurement))
+str(repr(SecretKeySpec))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementSeries(object):
-    """object for a single series in the measurement"""
+class SecretSpec(object):
+    """Specification about the secret association to the job"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.columns = (
+        self.allKeys = (
             None if not fromDict or propDict.get(
-                "columns"
+                "allKeys"
             ) is None
-            else propDict["columns"])
+            else propDict["allKeys"])
+        self.keysSpec = (
+            None if not fromDict or propDict.get(
+                "keysSpec"
+            ) is None
+            else [ SecretKeySpec(i)
+            for i in propDict["keysSpec"] ])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.tags = (
-            None if not fromDict or propDict.get(
-                "tags"
-            ) is None
-            else [ MeasurementTag(i)
-            for i in propDict["tags"] ])
-        self.values = (
-            None if not fromDict or propDict.get(
-                "values"
-            ) is None
-            else [ Measurement(i)
-            for i in propDict["values"] ])
 
     @property
-    def columns(self):
-        """list: list of columns, in order, for the series."""
-        return self._columns
+    def allKeys(self):
+        """bool: Indicate that all the KV pairs associated to the secret will 
+        be exported as environment variables with key name as env vari
+        able name"""
+        return self._allKeys
+
+    @allKeys.setter
+    def allKeys(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._allKeys = value
+        else:
+            raise TypeError(
+                'Property "allKeys" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def keysSpec(self):
+        """list: List of {KeyName,EnvName} tuples associated to the secret"""
+        return self._keysSpec
 
-    @columns.setter
-    def columns(self, value):
+    @keysSpec.setter
+    def keysSpec(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._columns = value
+            self._keysSpec = value
         else:
             raise TypeError(
-                'Property "columns" of type "list<str>" set to wrong type'
+                'Property "keysSpec" of type "list<SecretKeySpec>" set to wro'
+                'ng type'
             )
 
     @property
     def name(self):
-        """str: name for the measurement"""
+        """str: Secret name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
-    @property
-    def tags(self):
-        """list: list of tags identifying the series."""
-        return self._tags
-
-    @tags.setter
-    def tags(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._tags = value
-        else:
-            raise TypeError(
-                'Property "tags" of type "list<MeasurementTag>" set to wrong '
-                'type'
-            )
-
-    @property
-    def values(self):
-        """list: array of values, in the same order as the columns, for the se
-        ries."""
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._values = value
-        else:
-            raise TypeError(
-                'Property "values" of type "list<Measurement>" set to wrong t'
-                'ype'
-            )
-
     def toDict(self):
         result = {}
-        if self._columns is not None:
-            result["columns"] = \
-                self._columns
+        if self._allKeys is not None:
+            result["allKeys"] = \
+                self._allKeys
+        if self._keysSpec:
+            result["keysSpec"] = [
+                i.toDict() for i in self._keysSpec 
+            ] if self._keysSpec else []
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._tags:
-            result["tags"] = [
-                i.toDict() for i in self._tags 
-            ] if self._tags else []
-        if self._values:
-            result["values"] = [
-                i.toDict() for i in self._values 
-            ] if self._values else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._tags is not None):
-            for obj in self._tags:
-                if (obj is not None): obj.isValid()
-        if (self._values is not None):
-            for obj in self._values:
+        if self._name is None:
+            raise ValueError(
+                "SecretSpec.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "SecretSpec.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._keysSpec is not None):
+            for obj in self._keysSpec:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/MeasurementTag.py` & `ngcbpc/data/uis/Resource.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,69 +14,68 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeasurementTag(object):
-    """object for measurement tags which identifies a measuurement series"""
+class Resource(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.tagKey = (
+        self.id = (
             None if not fromDict or propDict.get(
-                "tagKey"
+                "id"
             ) is None
-            else propDict["tagKey"])
-        self.tagValue = (
+            else propDict["id"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "tagValue"
+                "type"
             ) is None
-            else propDict["tagValue"])
+            else propDict["type"])
 
     @property
-    def tagKey(self):
-        """str: key for the tag, ie)host, job_id, gpu_id"""
-        return self._tagKey
+    def id(self):
+        """str: uuid of the resource"""
+        return self._id
 
-    @tagKey.setter
-    def tagKey(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tagKey = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "tagKey" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tagValue(self):
-        """str: value for the tag, ie)host=foo, job_id=bar, gpu_id=racecar"""
-        return self._tagValue
+    def type(self):
+        """str: type of the resource"""
+        return self._type
 
-    @tagValue.setter
-    def tagValue(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tagValue = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "tagValue" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._tagKey is not None:
-            result["tagKey"] = \
-                self._tagKey
-        if self._tagValue is not None:
-            result["tagValue"] = \
-                self._tagValue
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/MetaData.py` & `ngcbpc/data/model/CustomMetric.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,16 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MetaData(object):
+class CustomMetric(object):
+    """Custom metrics"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.key = (
             None if not fromDict or propDict.get(
                 "key"
             ) is None
             else propDict["key"])
@@ -81,18 +82,18 @@
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if (self._key is not None
             and
             len(self._key) > 255):
             raise ValueError(
-                "MetaData.key: " + str(self._key) + 
+                "CustomMetric.key: " + str(self._key) + 
                 " doesnt match requirement: maxLength: 255")
         if (self._value is not None
             and
             len(self._value) > 255):
             raise ValueError(
-                "MetaData.value: " + str(self._value) + 
+                "CustomMetric.value: " + str(self._value) + 
                 " doesnt match requirement: maxLength: 255")
         return True
```

## Comparing `ngccli/data/api/MeteringQueryParams.py` & `ngcbpc/data/registry/BaseImageDetails.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,179 +6,175 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeteringType import MeteringTypeEnum
 
 # Unused import over optimization prevention
-str(repr(MeteringTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeteringQueryParams(object):
-    """object used for sending metering query parameter request"""
+class BaseImageDetails(object):
+    """the details of a base image"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.fill = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "fill"
+                "digest"
             ) is None
-            else propDict["fill"])
-        self.fromDate = (
+            else propDict["digest"])
+        self.fullImageName = (
             None if not fromDict or propDict.get(
-                "fromDate"
+                "fullImageName"
             ) is None
-            else propDict["fromDate"])
-        self.groupBy = (
+            else propDict["fullImageName"])
+        self.modifiedDate = (
             None if not fromDict or propDict.get(
-                "groupBy"
+                "modifiedDate"
             ) is None
-            else propDict["groupBy"])
-        self.periodInSeconds = (
+            else propDict["modifiedDate"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "periodInSeconds"
+                "name"
             ) is None
-            else propDict["periodInSeconds"])
-        self.toDate = (
+            else propDict["name"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "toDate"
+                "namespace"
             ) is None
-            else propDict["toDate"])
-        self.type = (
+            else propDict["namespace"])
+        self.tagName = (
             None if not fromDict or propDict.get(
-                "type"
+                "tagName"
             ) is None
-            else propDict["type"])
+            else propDict["tagName"])
 
     @property
-    def fill(self):
-        """float: this replaces all null values in an output stream with a non
-        -null value that is provided."""
-        return self._fill
+    def digest(self):
+        """str: digest of the image"""
+        return self._digest
 
-    @fill.setter
-    def fill(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._fill = value
+    @digest.setter
+    def digest(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._digest = value
         else:
             raise TypeError(
-                'Property "fill" of type "list<float>" set to wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fromDate(self):
-        """str: end time range for the data, in ISO formate, yyyy-MM-dd'T'HH:m
-        m:ss.SSS'Z'"""
-        return self._fromDate
+    def fullImageName(self):
+        """str: full image name"""
+        return self._fullImageName
 
-    @fromDate.setter
-    def fromDate(self, value):
+    @fullImageName.setter
+    def fullImageName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fromDate = value
+            self._fullImageName = value
         else:
             raise TypeError(
-                'Property "fromDate" of type "list<str>" set to wrong type'
+                'Property "fullImageName" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def groupBy(self):
-        """list: group by specific tags"""
-        return self._groupBy
+    def modifiedDate(self):
+        """str: date of last modification"""
+        return self._modifiedDate
 
-    @groupBy.setter
-    def groupBy(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._groupBy = value
+    @modifiedDate.setter
+    def modifiedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._modifiedDate = value
         else:
             raise TypeError(
-                'Property "groupBy" of type "list<str>" set to wrong type'
+                'Property "modifiedDate" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def periodInSeconds(self):
-        """float: time period to aggregate the data over with, in seconds. If 
-        none provided, raw data will be returned."""
-        return self._periodInSeconds
+    def name(self):
+        """ """
+        return self._name
 
-    @periodInSeconds.setter
-    def periodInSeconds(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._periodInSeconds = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "periodInSeconds" of type "list<float>" set to wron'
-                'g type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def toDate(self):
-        """str: start time range for the data, in ISO formate, yyyy-MM-dd'T'HH
-        :mm:ss.SSS'Z'"""
-        return self._toDate
+    def namespace(self):
+        """ """
+        return self._namespace
 
-    @toDate.setter
-    def toDate(self, value):
+    @namespace.setter
+    def namespace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._toDate = value
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "toDate" of type "list<str>" set to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
+    def tagName(self):
         """ """
-        return self._type
+        return self._tagName
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @tagName.setter
+    def tagName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._tagName = value
         else:
             raise TypeError(
-                'Property "type" of type "list<MeteringTypeEnum>" set to wron'
-                'g type'
+                'Property "tagName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._fill is not None:
-            result["fill"] = \
-                self._fill
-        if self._fromDate is not None:
-            result["fromDate"] = \
-                self._fromDate
-        if self._groupBy is not None:
-            result["groupBy"] = \
-                self._groupBy
-        if self._periodInSeconds is not None:
-            result["periodInSeconds"] = \
-                self._periodInSeconds
-        if self._toDate is not None:
-            result["toDate"] = \
-                self._toDate
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._fullImageName is not None:
+            result["fullImageName"] = \
+                self._fullImageName
+        if self._modifiedDate is not None:
+            result["modifiedDate"] = \
+                self._modifiedDate
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._tagName is not None:
+            result["tagName"] = \
+                self._tagName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/MeteringQueryRequest.py` & `ngcbpc/data/model/EnumerableResourceItem.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,66 +6,106 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MeteringQueryParams import MeteringQueryParams
 
 # Unused import over optimization prevention
-str(repr(MeteringQueryParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeteringQueryRequest(object):
-    """request params for getting metering usage"""
+class EnumerableResourceItem(object):
+    """Enumerable Resource Item object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.measurements = (
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "measurements"
+                "displayName"
             ) is None
-            else [ MeteringQueryParams(i)
-            for i in propDict["measurements"] ])
+            else propDict["displayName"])
+        self.logo = (
+            None if not fromDict or propDict.get(
+                "logo"
+            ) is None
+            else propDict["logo"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
+
+    @property
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
+
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
+        else:
+            raise TypeError(
+                'Property "displayName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def logo(self):
+        """str: Logo URL"""
+        return self._logo
+
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
+        else:
+            raise TypeError(
+                'Property "logo" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def measurements(self):
-        """ """
-        return self._measurements
-
-    @measurements.setter
-    def measurements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._measurements = value
+    def name(self):
+        """str: Name"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "measurements" of type "list<MeteringQueryParams>" '
-                'set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._measurements:
-            result["measurements"] = [
-                i.toDict() for i in self._measurements 
-            ] if self._measurements else []
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._measurements is not None):
-            for obj in self._measurements:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/MeteringResourceUtilizationEvent.py` & `organization/data/sms/Secret.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,253 +6,269 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .KV import KV
 
 # Unused import over optimization prevention
+str(repr(KV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeteringResourceUtilizationEvent(object):
-    """Metering Resource Utilization Event"""
+class Secret(object):
+    """Definition of a secret"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.createdAt = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "createdAt"
             ) is None
-            else propDict["orgName"])
-        self.resourceName = (
+            else propDict["createdAt"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "resourceName"
+                "description"
             ) is None
-            else propDict["resourceName"])
-        self.resourceType = (
+            else propDict["description"])
+        self.enabled = (
             None if not fromDict or propDict.get(
-                "resourceType"
+                "enabled"
             ) is None
-            else propDict["resourceType"])
-        self.resourceUsage = (
+            else propDict["enabled"])
+        self.kv = (
             None if not fromDict or propDict.get(
-                "resourceUsage"
+                "kv"
             ) is None
-            else propDict["resourceUsage"])
-        self.resourceUsageInt = (
+            else [ KV(i)
+            for i in propDict["kv"] ])
+        self.name = (
             None if not fromDict or propDict.get(
-                "resourceUsageInt"
+                "name"
             ) is None
-            else propDict["resourceUsageInt"])
-        self.resourceUsageUnit = (
+            else propDict["name"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "resourceUsageUnit"
+                "namespace"
             ) is None
-            else propDict["resourceUsageUnit"])
-        self.teamName = (
+            else propDict["namespace"])
+        self.updatedAt = (
             None if not fromDict or propDict.get(
-                "teamName"
+                "updatedAt"
             ) is None
-            else propDict["teamName"])
-        self.timestamp = (
-            None if not fromDict or propDict.get(
-                "timestamp"
-            ) is None
-            else propDict["timestamp"])
+            else propDict["updatedAt"])
 
     @property
-    def orgName(self):
-        """str: The name of the organization"""
-        return self._orgName
+    def createdAt(self):
+        """str: Secret creation date time in YYYY-MM-DDThh:mm:ssZ format"""
+        return self._createdAt
 
-    @orgName.setter
-    def orgName(self, value):
+    @createdAt.setter
+    def createdAt(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._createdAt = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "createdAt" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resourceName(self):
-        """str: Name of the resource - e.g. container name, model name (nvidia
-        /jarvis), gpu-type (A1000, RX6000) """
-        return self._resourceName
+    def description(self):
+        """str: Secret description"""
+        return self._description
 
-    @resourceName.setter
-    def resourceName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resourceName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "resourceName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resourceType(self):
-        """ResourceTypeEnum: When you are sending the event, this defines what
-         type you want to use when storing the metric."""
-        return self._resourceType
-
-    @resourceType.setter
-    def resourceType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._resourceType = value
+    def enabled(self):
+        """bool: Secret enabled/disabled"""
+        return self._enabled
+
+    @enabled.setter
+    def enabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._enabled = value
         else:
             raise TypeError(
-                'Property "resourceType" of type "list<ResourceTypeEnum>" set'
-                ' to wrong type'
+                'Property "enabled" of type "list<bool>" set to wrong type'
             )
 
-    ResourceTypeEnum=["MODEL","CONTAINER","RESOURCE","HELM_CHART","EGX_GPU","EGX_LOG_STORAGE",]
-    str(repr(ResourceTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def resourceUsage(self):
-        """float: Default numerical type. IEEE-754 64-bit floating-point numbe
-        rs (except NaN or +/- Inf). Examples: 1, 1.0, 1.e+78, 1.E+78."""
-        return self._resourceUsage
-
-    @resourceUsage.setter
-    def resourceUsage(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._resourceUsage = value
+    def kv(self):
+        """ """
+        return self._kv
+
+    @kv.setter
+    def kv(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._kv = value
         else:
             raise TypeError(
-                'Property "resourceUsage" of type "list<float>" set to wrong '
-                'type'
+                'Property "kv" of type "list<KV>" set to wrong type'
             )
 
     @property
-    def resourceUsageInt(self):
-        """long: Usage of the resource as signed 64-bit integers, Values must 
-        have a minimum value of -2^63 and a maximum value of 2^63-1."""
-        return self._resourceUsageInt
+    def name(self):
+        """str: Secret name"""
+        return self._name
 
-    @resourceUsageInt.setter
-    def resourceUsageInt(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resourceUsageInt = value
-        else:
-            raise TypeError(
-                'Property "resourceUsageInt" of type "list<long>" set to wron'
-                'g type'
-            )
-
-    @property
-    def resourceUsageUnit(self):
-        """ResourceUsageUnitEnum: When you are sending the event, this defines
-         what unit you want to use when storing the usage."""
-        return self._resourceUsageUnit
-
-    @resourceUsageUnit.setter
-    def resourceUsageUnit(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._resourceUsageUnit = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "resourceUsageUnit" of type "list<ResourceUsageUnit'
-                'Enum>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
-    ResourceUsageUnitEnum=["Bytes","Kilobytes","Megabytes","Gigabytes","None",]
-    str(repr(ResourceUsageUnitEnum))  # Prevent optimizer removing enum
-
     @property
-    def teamName(self):
-        """str: The name of the team within an organization"""
-        return self._teamName
+    def namespace(self):
+        """str: Secret namespace"""
+        return self._namespace
 
-    @teamName.setter
-    def teamName(self, value):
+    @namespace.setter
+    def namespace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def timestamp(self):
-        """str: The timestamp at which the event was created"""
-        return self._timestamp
+    def updatedAt(self):
+        """str: Secret update date time in YYYY-MM-DDThh:mm:ssZ format"""
+        return self._updatedAt
 
-    @timestamp.setter
-    def timestamp(self, value):
+    @updatedAt.setter
+    def updatedAt(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._timestamp = value
+            self._updatedAt = value
         else:
             raise TypeError(
-                'Property "timestamp" of type "list<str>" set to wrong type'
+                'Property "updatedAt" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._resourceName is not None:
-            result["resourceName"] = \
-                self._resourceName
-        if self._resourceType is not None:
-            result["resourceType"] = \
-                self._resourceType
-        if self._resourceUsage is not None:
-            result["resourceUsage"] = \
-                self._resourceUsage
-        if self._resourceUsageInt is not None:
-            result["resourceUsageInt"] = \
-                self._resourceUsageInt
-        if self._resourceUsageUnit is not None:
-            result["resourceUsageUnit"] = \
-                self._resourceUsageUnit
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
-        if self._timestamp is not None:
-            result["timestamp"] = \
-                self._timestamp
+        if self._createdAt is not None:
+            result["createdAt"] = \
+                self._createdAt
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._enabled is not None:
+            result["enabled"] = \
+                self._enabled
+        if self._kv:
+            result["kv"] = [
+                i.toDict() for i in self._kv 
+            ] if self._kv else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._updatedAt is not None:
+            result["updatedAt"] = \
+                self._updatedAt
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._orgName is None:
+        if self._namespace is None:
             raise ValueError(
-                "MeteringResourceUtilizationEvent.orgName doesnt match requirement:" 
+                "Secret.namespace doesnt match requirement:" 
                 "required: True"
             )
-        if self._timestamp is None:
+        if (self._namespace is not None
+            and
+            len(self._namespace) < 1):
+            raise ValueError(
+                "Secret.namespace: " + str(self._namespace) + 
+                " doesnt match requirement: minLength: 1")
+        if self._name is None:
+            raise ValueError(
+                "Secret.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "Secret.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._description is None:
+            raise ValueError(
+                "Secret.description doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._description is not None
+            and
+            len(self._description) < 1):
+            raise ValueError(
+                "Secret.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if self._createdAt is None:
+            raise ValueError(
+                "Secret.createdAt doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._createdAt is not None
+            and
+            len(self._createdAt) < 1):
+            raise ValueError(
+                "Secret.createdAt: " + str(self._createdAt) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._updatedAt is not None
+            and
+            len(self._updatedAt) < 1):
+            raise ValueError(
+                "Secret.updatedAt: " + str(self._updatedAt) + 
+                " doesnt match requirement: minLength: 1")
+        if self._enabled is None:
             raise ValueError(
-                "MeteringResourceUtilizationEvent.timestamp doesnt match requirement:" 
+                "Secret.enabled doesnt match requirement:" 
                 "required: True"
             )
-        if self._resourceType is None:
+        if self._kv is None:
             raise ValueError(
-                "MeteringResourceUtilizationEvent.resourceType doesnt match requirement:" 
+                "Secret.kv doesnt match requirement:" 
                 "required: True"
             )
+        if (self._kv is not None):
+            for obj in self._kv:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/MeteringResultListResponse.py` & `ngcbpc/data/registry/GetTagsResponse.py`

 * *Files 15% similar despite different names*

```diff
@@ -7,56 +7,57 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .MeasurementResult import MeasurementResult
 
 # Unused import over optimization prevention
-str(repr(MeasurementResult))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MeteringResultListResponse(object):
-    """response containing a list of all metering queries results"""
+class GetTagsResponse(object):
+    """Registry label"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.measurements = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "measurements"
+                "name"
             ) is None
-            else [ MeasurementResult(i)
-            for i in propDict["measurements"] ])
+            else propDict["name"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.tags = (
+            None if not fromDict or propDict.get(
+                "tags"
+            ) is None
+            else propDict["tags"])
 
     @property
-    def measurements(self):
-        """ """
-        return self._measurements
-
-    @measurements.setter
-    def measurements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._measurements = value
+    def name(self):
+        """str: Repository name"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "measurements" of type "list<MeasurementResult>" se'
-                't to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -68,32 +69,47 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def tags(self):
+        """list: Tags associated with repository."""
+        return self._tags
+
+    @tags.setter
+    def tags(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._tags = value
+        else:
+            raise TypeError(
+                'Property "tags" of type "list<str>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._measurements:
-            result["measurements"] = [
-                i.toDict() for i in self._measurements 
-            ] if self._measurements else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._tags is not None:
+            result["tags"] = \
+                self._tags
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._measurements is not None):
-            for obj in self._measurements:
-                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/MoveNodeRequest.py` & `ngcbpc/data/model/DeploymentCpuParameters.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,55 +14,50 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MoveNodeRequest(object):
-    """object used to move node between ACE"""
+class DeploymentCpuParameters(object):
+    """Deployment CPU Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "count"
             ) is None
-            else propDict["aceId"])
+            else propDict["count"])
 
     @property
-    def aceId(self):
-        """long: id of the ace that the node should belong to"""
-        return self._aceId
+    def count(self):
+        """long: Total count of CPUs"""
+        return self._count
 
-    @aceId.setter
-    def aceId(self, value):
+    @count.setter
+    def count(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._aceId = value
+            self._count = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "count" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
+        if self._count is not None:
+            result["count"] = \
+                self._count
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceId is None:
-            raise ValueError(
-                "MoveNodeRequest.aceId doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/Node.py` & `ngcbpc/data/model/ArtifactCreateRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,351 +6,447 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NodeStatus import NodeStatus
-from .NodeType import NodeTypeEnum
-from .WebSocket import WebSocket
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(NodeTypeEnum))
-str(repr(NodeStatus))
-str(repr(WebSocket))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Node(object):
-    """Information about the node"""
+class ArtifactCreateRequest(object):
+    """Request to create a new artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.authClientId = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "authClientId"
+                "attributes"
             ) is None
-            else propDict["authClientId"])
-        self.createdBy = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.bias = (
             None if not fromDict or propDict.get(
-                "createdBy"
+                "bias"
             ) is None
-            else propDict["createdBy"])
-        self.createdDate = (
+            else propDict["bias"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "builtBy"
             ) is None
-            else propDict["createdDate"])
-        self.eulaAccepted = (
+            else propDict["builtBy"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "eulaAccepted"
+                "description"
             ) is None
-            else propDict["eulaAccepted"])
+            else propDict["description"])
+        self.displayName = (
+            None if not fromDict or propDict.get(
+                "displayName"
+            ) is None
+            else propDict["displayName"])
+        self.explainability = (
+            None if not fromDict or propDict.get(
+                "explainability"
+            ) is None
+            else propDict["explainability"])
+        self.labels = (
+            None if not fromDict or propDict.get(
+                "labels"
+            ) is None
+            else propDict["labels"])
+        self.labelsV2 = (
+            None if not fromDict or propDict.get(
+                "labelsV2"
+            ) is None
+            else propDict["labelsV2"])
+        self.logo = (
+            None if not fromDict or propDict.get(
+                "logo"
+            ) is None
+            else propDict["logo"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.nodeStatus = (
-            None if not fromDict or propDict.get(
-                "nodeStatus"
-            ) is None
-            else propDict["nodeStatus"])
-        self.nodeType = (
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "nodeType"
+                "privacy"
             ) is None
-            else propDict["nodeType"])
-        self.serialNumber = (
+            else propDict["privacy"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "serialNumber"
+                "publisher"
             ) is None
-            else propDict["serialNumber"])
-        self.updatedDate = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "updatedDate"
+                "safetyAndSecurity"
             ) is None
-            else propDict["updatedDate"])
-        self.webSocket = (
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "webSocket"
+                "shortDescription"
             ) is None
-            else propDict["webSocket"])
+            else propDict["shortDescription"])
 
     @property
-    def authClientId(self):
-        """str: DEPRECATED - Will be removed soon. Please use NodeCreateRespon
-        se JSON."""
-        return self._authClientId
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
+        else:
+            raise TypeError(
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
+            )
 
-    @authClientId.setter
-    def authClientId(self, value):
+    @property
+    def bias(self):
+        """str: Text describing bias in the model"""
+        return self._bias
+
+    @bias.setter
+    def bias(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authClientId = value
+            self._bias = value
         else:
             raise TypeError(
-                'Property "authClientId" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "bias" of type "list<str>" set to wrong type'
             )
 
     @property
-    def createdBy(self):
-        """str: name of user that created the node"""
-        return self._createdBy
+    def builtBy(self):
+        """str: organization that built the artifact"""
+        return self._builtBy
 
-    @createdBy.setter
-    def createdBy(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdBy = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "createdBy" of type "list<str>" set to wrong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """ """
-        return self._createdDate
+    def description(self):
+        """str: Description of the artifact"""
+        return self._description
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eulaAccepted(self):
-        """bool: must be set to true to start using this node in the ACE"""
-        return self._eulaAccepted
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @eulaAccepted.setter
-    def eulaAccepted(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._eulaAccepted = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "eulaAccepted" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: hostname for the node"""
-        return self._name
+    def explainability(self):
+        """str: Text describing explainability for this model"""
+        return self._explainability
 
-    @name.setter
-    def name(self, value):
+    @explainability.setter
+    def explainability(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._explainability = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def nodeStatus(self):
-        """NodeStatus: data in this object is populated from the node"""
-        return self._nodeStatus
-
-    @nodeStatus.setter
-    def nodeStatus(self, value):
-        if value is not None and not isinstance(value, NodeStatus):
-            value = NodeStatus(value)
-        if (value is None) or isinstance(value, NodeStatus):
-            self._nodeStatus = value
+    def labels(self):
+        """ """
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "nodeStatus" of type "list<NodeStatus>" set to wron'
-                'g type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nodeType(self):
+    def labelsV2(self):
         """ """
-        return self._nodeType
+        return self._labelsV2
 
-    @nodeType.setter
-    def nodeType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._nodeType = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "nodeType" of type "list<NodeTypeEnum>" set to wron'
-                'g type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def serialNumber(self):
-        """str: serial number of the server, required while registering the se
-        rver"""
-        return self._serialNumber
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @serialNumber.setter
-    def serialNumber(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._serialNumber = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "serialNumber" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def updatedDate(self):
-        """ """
-        return self._updatedDate
+    def name(self):
+        """str: Unique name of the artifact"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def privacy(self):
+        """str: Text describing the privacy for this model"""
+        return self._privacy
+
+    @privacy.setter
+    def privacy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._privacy = value
+        else:
+            raise TypeError(
+                'Property "privacy" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def publisher(self):
+        """str: organization that published the artifact"""
+        return self._publisher
+
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
+        else:
+            raise TypeError(
+                'Property "publisher" of type "list<str>" set to wrong type'
+            )
 
-    @updatedDate.setter
-    def updatedDate(self, value):
+    @property
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the model"""
+        return self._safetyAndSecurity
+
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def webSocket(self):
-        """WebSocket: object used to show the status of the websocket between 
-        node and the cloud"""
-        return self._webSocket
+    def shortDescription(self):
+        """str: Short description of the artifact"""
+        return self._shortDescription
 
-    @webSocket.setter
-    def webSocket(self, value):
-        if value is not None and not isinstance(value, WebSocket):
-            value = WebSocket(value)
-        if (value is None) or isinstance(value, WebSocket):
-            self._webSocket = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "webSocket" of type "list<WebSocket>" set to wrong '
-                'type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._authClientId is not None:
-            result["authClientId"] = \
-                self._authClientId
-        if self._createdBy is not None:
-            result["createdBy"] = \
-                self._createdBy
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._eulaAccepted is not None:
-            result["eulaAccepted"] = \
-                self._eulaAccepted
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._nodeStatus:
-            result["nodeStatus"] = \
-                self._nodeStatus.toDict() if self._nodeStatus is not None else None
-        if self._nodeType is not None:
-            result["nodeType"] = \
-                self._nodeType
-        if self._serialNumber is not None:
-            result["serialNumber"] = \
-                self._serialNumber
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
-        if self._webSocket:
-            result["webSocket"] = \
-                self._webSocket.toDict() if self._webSocket is not None else None
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._serialNumber is not None
-            and
-            len(self._serialNumber) < 8):
-            raise ValueError(
-                "Node.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: minLength: 8")
-        if (self._serialNumber is not None
-            and
-            len(self._serialNumber) > 64):
+        if self._name is None:
             raise ValueError(
-                "Node.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._serialNumber is not None
-            and
-            not re.match(
-                r"^[a-zA-Z\d_-]*$",
-                 self._serialNumber)):
-            raise ValueError(
-                "Node.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d_-]*$")
+                "ArtifactCreateRequest.name doesnt match requirement:" 
+                "required: True"
+            )
         if (self._name is not None
             and
             len(self._name) < 1):
             raise ValueError(
-                "Node.name: " + str(self._name) + 
+                "ArtifactCreateRequest.name: " + str(self._name) + 
                 " doesnt match requirement: minLength: 1")
         if (self._name is not None
             and
-            len(self._name) > 255):
+            len(self._name) > 64):
             raise ValueError(
-                "Node.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
+                "ArtifactCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
         if (self._name is not None
             and
             not re.match(
-                r"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A"
-                "-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0"
-                "-9])$",
+                r"^[a-z][a-z\d_-]*$",
                  self._name)):
             raise ValueError(
-                "Node.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^(([a-zA-Z0-9]|[a-zA-Z0-"
-                "9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9"
-                "]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$")
-        if (self._createdDate is not None
+                "ArtifactCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: ^[a-z][a-z\d_-]*$")
+        if self._shortDescription is None:
+            raise ValueError(
+                "ArtifactCreateRequest.shortDescription doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._shortDescription is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._shortDescription) > 255):
             raise ValueError(
-                "Node.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
+                "ArtifactCreateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
+            len(self._displayName) < 2):
             raise ValueError(
-                "Node.updatedDate: " + str(self._updatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._webSocket is not None): self._webSocket.isValid()
-        if (self._nodeStatus is not None): self._nodeStatus.isValid()
+                "ArtifactCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "ArtifactCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._logo is not None
+            and
+            len(self._logo) > 255):
+            raise ValueError(
+                "ArtifactCreateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._builtBy is not None
+            and
+            len(self._builtBy) > 255):
+            raise ValueError(
+                "ArtifactCreateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
+            and
+            len(self._publisher) > 255):
+            raise ValueError(
+                "ArtifactCreateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeCommand.py` & `ngcbpc/data/model/AIPlaygroundUpdateRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,98 +14,94 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeCommand(object):
-    """Specifies the command to run on a node."""
+class AIPlaygroundUpdateRequest(object):
+    """Request to update an AI Playground config"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.command = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "command"
+                "attributes"
             ) is None
-            else propDict["command"])
-        self.data = (
+            else propDict["attributes"])
+        self.nvcfFunctionId = (
             None if not fromDict or propDict.get(
-                "data"
+                "nvcfFunctionId"
             ) is None
-            else propDict["data"])
-        self.masterIpAddresses = (
+            else propDict["nvcfFunctionId"])
+        self.openAPISpec = (
             None if not fromDict or propDict.get(
-                "masterIpAddresses"
+                "openAPISpec"
             ) is None
-            else propDict["masterIpAddresses"])
+            else propDict["openAPISpec"])
 
     @property
-    def command(self):
-        """CommandEnum: Specify the type of command."""
-        return self._command
-
-    @command.setter
-    def command(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._command = value
+    def attributes(self):
+        """str: Metadata json string"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "command" of type "list<CommandEnum>" set to wrong '
-                'type'
+                'Property "attributes" of type "list<str>" set to wrong type'
             )
 
-    CommandEnum=["BASH","MAKE_MASTER","MAKE_SLAVE","GET_NODE_STATUS",]
-    str(repr(CommandEnum))  # Prevent optimizer removing enum
-
     @property
-    def data(self):
-        """str: Specify the command to execute. For example, if the command is
-         a 'BASH' command, then specify the bash command to execute."""
-        return self._data
+    def nvcfFunctionId(self):
+        """str: NVCF function id for the model playground"""
+        return self._nvcfFunctionId
 
-    @data.setter
-    def data(self, value):
+    @nvcfFunctionId.setter
+    def nvcfFunctionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._data = value
+            self._nvcfFunctionId = value
         else:
             raise TypeError(
-                'Property "data" of type "list<str>" set to wrong type'
+                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def masterIpAddresses(self):
-        """list: An array of the IP addresses of all the masters in the ACE.
-        """
-        return self._masterIpAddresses
-
-    @masterIpAddresses.setter
-    def masterIpAddresses(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._masterIpAddresses = value
+    def openAPISpec(self):
+        """str: OpenAPI specification for this model"""
+        return self._openAPISpec
+
+    @openAPISpec.setter
+    def openAPISpec(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._openAPISpec = value
         else:
             raise TypeError(
-                'Property "masterIpAddresses" of type "list<str>" set to wron'
-                'g type'
+                'Property "openAPISpec" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._command is not None:
-            result["command"] = \
-                self._command
-        if self._data is not None:
-            result["data"] = \
-                self._data
-        if self._masterIpAddresses is not None:
-            result["masterIpAddresses"] = \
-                self._masterIpAddresses
+        if self._attributes is not None:
+            result["attributes"] = \
+                self._attributes
+        if self._nvcfFunctionId is not None:
+            result["nvcfFunctionId"] = \
+                self._nvcfFunctionId
+        if self._openAPISpec is not None:
+            result["openAPISpec"] = \
+                self._openAPISpec
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/NodeCommandRequest.py` & `ngcbpc/data/registry/AllowlistItem.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,86 +6,107 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NodeCommand import NodeCommand
 
 # Unused import over optimization prevention
-str(repr(NodeCommand))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeCommandRequest(object):
-    """Request to execute a command on a node."""
+class AllowlistItem(object):
+    """Identifies a specific gate and trigger match from a policy against an i
+    mage and indicates it should be ignored in final policy decisions"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodeCommand = (
+        self.gate = (
             None if not fromDict or propDict.get(
-                "nodeCommand"
+                "gate"
             ) is None
-            else propDict["nodeCommand"])
-        self.output = (
+            else propDict["gate"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "output"
+                "id"
             ) is None
-            else propDict["output"])
+            else propDict["id"])
+        self.trigger_id = (
+            None if not fromDict or propDict.get(
+                "trigger_id"
+            ) is None
+            else propDict["trigger_id"])
 
     @property
-    def nodeCommand(self):
-        """NodeCommand: Specifies the command to run on a node."""
-        return self._nodeCommand
-
-    @nodeCommand.setter
-    def nodeCommand(self, value):
-        if value is not None and not isinstance(value, NodeCommand):
-            value = NodeCommand(value)
-        if (value is None) or isinstance(value, NodeCommand):
-            self._nodeCommand = value
+    def gate(self):
+        """ """
+        return self._gate
+
+    @gate.setter
+    def gate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gate = value
+        else:
+            raise TypeError(
+                'Property "gate" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def id(self):
+        """ """
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "nodeCommand" of type "list<NodeCommand>" set to wr'
-                'ong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def output(self):
-        """str: The output corresponding to the node command execution."""
-        return self._output
+    def trigger_id(self):
+        """ """
+        return self._trigger_id
 
-    @output.setter
-    def output(self, value):
+    @trigger_id.setter
+    def trigger_id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._output = value
+            self._trigger_id = value
         else:
             raise TypeError(
-                'Property "output" of type "list<str>" set to wrong type'
+                'Property "trigger_id" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._nodeCommand:
-            result["nodeCommand"] = \
-                self._nodeCommand.toDict() if self._nodeCommand is not None else None
-        if self._output is not None:
-            result["output"] = \
-                self._output
+        if self._gate is not None:
+            result["gate"] = \
+                self._gate
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._trigger_id is not None:
+            result["trigger_id"] = \
+                self._trigger_id
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._nodeCommand is not None): self._nodeCommand.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeCreateResponse.py` & `ngcbpc/data/uis/UserRoles.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,166 +6,158 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AceSimplified import AceSimplified
-from .RequestStatus import RequestStatus
-from .Node import Node
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(AceSimplified))
-str(repr(Node))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeCreateResponse(object):
-    """Information about Node/Appliance"""
+class UserRoles(object):
+    """The model class that store User and its Roles information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ace = (
+        self.clientId = (
             None if not fromDict or propDict.get(
-                "ace"
+                "clientId"
             ) is None
-            else propDict["ace"])
-        self.authClientId = (
+            else propDict["clientId"])
+        self.clientIdType = (
             None if not fromDict or propDict.get(
-                "authClientId"
+                "clientIdType"
             ) is None
-            else propDict["authClientId"])
-        self.authSecret = (
+            else propDict["clientIdType"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "authSecret"
+                "orgName"
             ) is None
-            else propDict["authSecret"])
-        self.node = (
+            else propDict["orgName"])
+        self.roles = (
             None if not fromDict or propDict.get(
-                "node"
+                "roles"
             ) is None
-            else propDict["node"])
-        self.requestStatus = (
+            else propDict["roles"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "teamName"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["teamName"])
 
     @property
-    def ace(self):
-        """AceSimplified: ACE is a collection of nodes that can run jobs"""
-        return self._ace
-
-    @ace.setter
-    def ace(self, value):
-        if value is not None and not isinstance(value, AceSimplified):
-            value = AceSimplified(value)
-        if (value is None) or isinstance(value, AceSimplified):
-            self._ace = value
+    def clientId(self):
+        """str: Unique authentication client id of this user"""
+        return self._clientId
+
+    @clientId.setter
+    def clientId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._clientId = value
         else:
             raise TypeError(
-                'Property "ace" of type "list<AceSimplified>" set to wrong ty'
-                'pe'
+                'Property "clientId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def authClientId(self):
-        """str: Auth ClientId"""
-        return self._authClientId
-
-    @authClientId.setter
-    def authClientId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._authClientId = value
+    def clientIdType(self):
+        """ClientIdTypeEnum: Type of ClientId, i.e. STARFLEET, AUTH"""
+        return self._clientIdType
+
+    @clientIdType.setter
+    def clientIdType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._clientIdType = value
         else:
             raise TypeError(
-                'Property "authClientId" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "clientIdType" of type "list<ClientIdTypeEnum>" set'
+                ' to wrong type'
             )
 
+    ClientIdTypeEnum=["STARFLEET","AUTH",]
+    str(repr(ClientIdTypeEnum))  # Prevent optimizer removing enum
+
     @property
-    def authSecret(self):
-        """str: Auth Secret - this is irrecoverable"""
-        return self._authSecret
+    def orgName(self):
+        """str: The name of the organization that the list query is targeting 
+        to"""
+        return self._orgName
 
-    @authSecret.setter
-    def authSecret(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authSecret = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "authSecret" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def node(self):
-        """Node: Information about the node"""
-        return self._node
-
-    @node.setter
-    def node(self, value):
-        if value is not None and not isinstance(value, Node):
-            value = Node(value)
-        if (value is None) or isinstance(value, Node):
-            self._node = value
+    def roles(self):
+        """list: A list of roles which belongs to the user"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "node" of type "list<Node>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def teamName(self):
+        """str: The name of team that the list query is targeting to. Nullable
+        ."""
+        return self._teamName
+
+    @teamName.setter
+    def teamName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._ace:
-            result["ace"] = \
-                self._ace.toDict() if self._ace is not None else None
-        if self._authClientId is not None:
-            result["authClientId"] = \
-                self._authClientId
-        if self._authSecret is not None:
-            result["authSecret"] = \
-                self._authSecret
-        if self._node:
-            result["node"] = \
-                self._node.toDict() if self._node is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._clientId is not None:
+            result["clientId"] = \
+                self._clientId
+        if self._clientIdType is not None:
+            result["clientIdType"] = \
+                self._clientIdType
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._node is not None): self._node.isValid()
-        if (self._ace is not None): self._ace.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeListResponse.py` & `ngcbpc/data/uis/UserListResponse.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,62 +8,46 @@
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
-from .Node import Node
+from .User import User
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
 str(repr(PaginationInfo))
-str(repr(Node))
+str(repr(User))
+str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeListResponse(object):
-    """listing of all nodes"""
+class UserListResponse(object):
+    """Response for List User reponse"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodes = (
-            None if not fromDict or propDict.get(
-                "nodes"
-            ) is None
-            else [ Node(i)
-            for i in propDict["nodes"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def nodes(self):
-        """ """
-        return self._nodes
-
-    @nodes.setter
-    def nodes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._nodes = value
-        else:
-            raise TypeError(
-                'Property "nodes" of type "list<Node>" set to wrong type'
-            )
+        self.users = (
+            None if not fromDict or propDict.get(
+                "users"
+            ) is None
+            else [ User(i)
+            for i in propDict["users"] ])
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
@@ -91,36 +75,52 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def users(self):
+        """list: information about the user"""
+        return self._users
+
+    @users.setter
+    def users(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._users = value
+        else:
+            raise TypeError(
+                'Property "users" of type "list<User>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._nodes:
-            result["nodes"] = [
-                i.toDict() for i in self._nodes 
-            ] if self._nodes else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._users:
+            result["users"] = [
+                i.toDict() for i in self._users 
+            ] if self._users else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._nodes is not None):
-            for obj in self._nodes:
+        if (self._users is not None):
+            for obj in self._users:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeResponse.py` & `ngcbpc/data/uis/CreateBillingAccountResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,80 +6,43 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AceSimplified import AceSimplified
 from .RequestStatus import RequestStatus
-from .Node import Node
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(AceSimplified))
-str(repr(Node))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeResponse(object):
-    """Information about Node/Appliance"""
+class CreateBillingAccountResponse(object):
+    """Create billing account response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ace = (
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "ace"
+                "requestStatus"
             ) is None
-            else propDict["ace"])
-        self.node = (
+            else propDict["requestStatus"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "node"
+                "status"
             ) is None
-            else propDict["node"])
-        self.requestStatus = (
+            else propDict["status"])
+        self.uchId = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "uchId"
             ) is None
-            else propDict["requestStatus"])
-
-    @property
-    def ace(self):
-        """AceSimplified: ACE is a collection of nodes that can run jobs"""
-        return self._ace
-
-    @ace.setter
-    def ace(self, value):
-        if value is not None and not isinstance(value, AceSimplified):
-            value = AceSimplified(value)
-        if (value is None) or isinstance(value, AceSimplified):
-            self._ace = value
-        else:
-            raise TypeError(
-                'Property "ace" of type "list<AceSimplified>" set to wrong ty'
-                'pe'
-            )
-
-    @property
-    def node(self):
-        """Node: Information about the node"""
-        return self._node
-
-    @node.setter
-    def node(self, value):
-        if value is not None and not isinstance(value, Node):
-            value = Node(value)
-        if (value is None) or isinstance(value, Node):
-            self._node = value
-        else:
-            raise TypeError(
-                'Property "node" of type "list<Node>" set to wrong type'
-            )
+            else propDict["uchId"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -90,33 +53,63 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def status(self):
+        """ """
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._status = value
+        else:
+            raise TypeError(
+                'Property "status" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def uchId(self):
+        """ """
+        return self._uchId
+
+    @uchId.setter
+    def uchId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uchId = value
+        else:
+            raise TypeError(
+                'Property "uchId" of type "list<str>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._ace:
-            result["ace"] = \
-                self._ace.toDict() if self._ace is not None else None
-        if self._node:
-            result["node"] = \
-                self._node.toDict() if self._node is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._uchId is not None:
+            result["uchId"] = \
+                self._uchId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._node is not None): self._node.isValid()
-        if (self._ace is not None): self._ace.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeSimplified.py` & `ngcbpc/data/model/CustomMetricGroup.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,108 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .CustomMetric import CustomMetric
 
 # Unused import over optimization prevention
+str(repr(CustomMetric))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeSimplified(object):
-    """Information about the node"""
+class CustomMetricGroup(object):
+    """Defines the group of custom metrics."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ipAddress = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "ipAddress"
+                "attributes"
             ) is None
-            else propDict["ipAddress"])
+            else [ CustomMetric(i)
+            for i in propDict["attributes"] ])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.serialNumber = (
-            None if not fromDict or propDict.get(
-                "serialNumber"
-            ) is None
-            else propDict["serialNumber"])
 
     @property
-    def ipAddress(self):
-        """str: ip address of the node"""
-        return self._ipAddress
-
-    @ipAddress.setter
-    def ipAddress(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._ipAddress = value
+    def attributes(self):
+        """list: Custom Metric key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "ipAddress" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<CustomMetric>" set to wr'
+                'ong type'
             )
 
     @property
     def name(self):
-        """str: hostname for the node"""
+        """ """
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
-    @property
-    def serialNumber(self):
-        """str: serial number of the server, required while registering the se
-        rver"""
-        return self._serialNumber
-
-    @serialNumber.setter
-    def serialNumber(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._serialNumber = value
-        else:
-            raise TypeError(
-                'Property "serialNumber" of type "list<str>" set to wrong typ'
-                'e'
-            )
-
     def toDict(self):
         result = {}
-        if self._ipAddress is not None:
-            result["ipAddress"] = \
-                self._ipAddress
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._serialNumber is not None:
-            result["serialNumber"] = \
-                self._serialNumber
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._name is not None
+            and
+            len(self._name) > 255):
+            raise ValueError(
+                "CustomMetricGroup.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeStatus.py` & `ngcbpc/data/uis/Organization.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,860 +6,716 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .WebSocket import WebSocket
+from .OrgOwner import OrgOwner
+from .InfinityManagerSettings import InfinityManagerSettings
+from .OrgType import OrgTypeEnum
+from .UsersInfo import UsersInfo
+from .ProductEnablement import ProductEnablement
+from .RepoScanSettings import RepoScanSettings
+from .AlternateContact import AlternateContact
 
 # Unused import over optimization prevention
-str(repr(WebSocket))
+str(repr(OrgOwner))
+str(repr(AlternateContact))
+str(repr(ProductEnablement))
+str(repr(RepoScanSettings))
+str(repr(OrgTypeEnum))
+str(repr(UsersInfo))
+str(repr(InfinityManagerSettings))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeStatus(object):
-    """data in this object is populated from the node"""
+class Organization(object):
+    """Information about the Organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.biosVersion = (
+        self.alternateContact = (
             None if not fromDict or propDict.get(
-                "biosVersion"
+                "alternateContact"
             ) is None
-            else propDict["biosVersion"])
-        self.bmcVersion = (
+            else propDict["alternateContact"])
+        self.billingAccountId = (
             None if not fromDict or propDict.get(
-                "bmcVersion"
+                "billingAccountId"
             ) is None
-            else propDict["bmcVersion"])
-        self.cloudManaged = (
+            else propDict["billingAccountId"])
+        self.canAddOn = (
             None if not fromDict or propDict.get(
-                "cloudManaged"
+                "canAddOn"
             ) is None
-            else propDict["cloudManaged"])
-        self.configTurnId = (
+            else propDict["canAddOn"])
+        self.country = (
             None if not fromDict or propDict.get(
-                "configTurnId"
+                "country"
             ) is None
-            else propDict["configTurnId"])
-        self.cpuCoresPerSocket = (
+            else propDict["country"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "cpuCoresPerSocket"
+                "description"
             ) is None
-            else propDict["cpuCoresPerSocket"])
-        self.cpuModelName = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "cpuModelName"
+                "displayName"
             ) is None
-            else propDict["cpuModelName"])
-        self.cpuSockets = (
+            else propDict["displayName"])
+        self.emsOrgUniqueIdentifier = (
             None if not fromDict or propDict.get(
-                "cpuSockets"
+                "emsOrgUniqueIdentifier"
             ) is None
-            else propDict["cpuSockets"])
-        self.debianRepoURL = (
+            else propDict["emsOrgUniqueIdentifier"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "debianRepoURL"
+                "id"
             ) is None
-            else propDict["debianRepoURL"])
-        self.diskSpace = (
+            else propDict["id"])
+        self.idpId = (
             None if not fromDict or propDict.get(
-                "diskSpace"
+                "idpId"
             ) is None
-            else propDict["diskSpace"])
-        self.dockerApiVersion = (
+            else propDict["idpId"])
+        self.industry = (
             None if not fromDict or propDict.get(
-                "dockerApiVersion"
+                "industry"
             ) is None
-            else propDict["dockerApiVersion"])
-        self.fwVersion = (
+            else propDict["industry"])
+        self.infinityManagerSettings = (
             None if not fromDict or propDict.get(
-                "fwVersion"
+                "infinityManagerSettings"
             ) is None
-            else propDict["fwVersion"])
-        self.gatewayIp = (
+            else propDict["infinityManagerSettings"])
+        self.isDatasetServiceEnabled = (
             None if not fromDict or propDict.get(
-                "gatewayIp"
+                "isDatasetServiceEnabled"
             ) is None
-            else propDict["gatewayIp"])
-        self.gpuModelName = (
+            else propDict["isDatasetServiceEnabled"])
+        self.isInternal = (
             None if not fromDict or propDict.get(
-                "gpuModelName"
+                "isInternal"
             ) is None
-            else propDict["gpuModelName"])
-        self.healthStatus = (
+            else propDict["isInternal"])
+        self.isQuickStartEnabled = (
             None if not fromDict or propDict.get(
-                "healthStatus"
+                "isQuickStartEnabled"
             ) is None
-            else propDict["healthStatus"])
-        self.ipAddress = (
+            else propDict["isQuickStartEnabled"])
+        self.isSecretsManagerServiceEnabled = (
             None if not fromDict or propDict.get(
-                "ipAddress"
+                "isSecretsManagerServiceEnabled"
             ) is None
-            else propDict["ipAddress"])
-        self.ipmi = (
+            else propDict["isSecretsManagerServiceEnabled"])
+        self.isSeparateInfluxDbUsed = (
             None if not fromDict or propDict.get(
-                "ipmi"
+                "isSeparateInfluxDbUsed"
             ) is None
-            else propDict["ipmi"])
-        self.isMarathonLeader = (
+            else propDict["isSeparateInfluxDbUsed"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "isMarathonLeader"
+                "name"
             ) is None
-            else propDict["isMarathonLeader"])
-        self.isMaster = (
+            else propDict["name"])
+        self.orgOwner = (
             None if not fromDict or propDict.get(
-                "isMaster"
+                "orgOwner"
             ) is None
-            else propDict["isMaster"])
-        self.isMesosLeader = (
+            else propDict["orgOwner"])
+        self.orgOwnerIds = (
             None if not fromDict or propDict.get(
-                "isMesosLeader"
+                "orgOwnerIds"
             ) is None
-            else propDict["isMesosLeader"])
-        self.isSchedulerLeader = (
+            else propDict["orgOwnerIds"])
+        self.orgOwners = (
             None if not fromDict or propDict.get(
-                "isSchedulerLeader"
+                "orgOwners"
             ) is None
-            else propDict["isSchedulerLeader"])
-        self.isZooKeeperLeader = (
+            else [ OrgOwner(i)
+            for i in propDict["orgOwners"] ])
+        self.pecSfdcId = (
             None if not fromDict or propDict.get(
-                "isZooKeeperLeader"
+                "pecSfdcId"
             ) is None
-            else propDict["isZooKeeperLeader"])
-        self.lastBoot = (
+            else propDict["pecSfdcId"])
+        self.productAccessTier = (
             None if not fromDict or propDict.get(
-                "lastBoot"
+                "productAccessTier"
             ) is None
-            else propDict["lastBoot"])
-        self.masterIpAddress = (
+            else propDict["productAccessTier"])
+        self.productEnablements = (
             None if not fromDict or propDict.get(
-                "masterIpAddress"
+                "productEnablements"
             ) is None
-            else propDict["masterIpAddress"])
-        self.memory = (
+            else [ ProductEnablement(i)
+            for i in propDict["productEnablements"] ])
+        self.repoScanSettings = (
             None if not fromDict or propDict.get(
-                "memory"
+                "repoScanSettings"
             ) is None
-            else propDict["memory"])
-        self.modelName = (
+            else propDict["repoScanSettings"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "modelName"
+                "type"
             ) is None
-            else propDict["modelName"])
-        self.networkType = (
+            else propDict["type"])
+        self.usersInfo = (
             None if not fromDict or propDict.get(
-                "networkType"
+                "usersInfo"
             ) is None
-            else propDict["networkType"])
-        self.numGpus = (
-            None if not fromDict or propDict.get(
-                "numGpus"
-            ) is None
-            else propDict["numGpus"])
-        self.roleTurnId = (
-            None if not fromDict or propDict.get(
-                "roleTurnId"
-            ) is None
-            else propDict["roleTurnId"])
-        self.state = (
-            None if not fromDict or propDict.get(
-                "state"
-            ) is None
-            else propDict["state"])
-        self.subNet = (
-            None if not fromDict or propDict.get(
-                "subNet"
-            ) is None
-            else propDict["subNet"])
-        self.swVersion = (
-            None if not fromDict or propDict.get(
-                "swVersion"
-            ) is None
-            else propDict["swVersion"])
-        self.upgradeOnBoot = (
-            None if not fromDict or propDict.get(
-                "upgradeOnBoot"
-            ) is None
-            else propDict["upgradeOnBoot"])
-        self.webSocket = (
-            None if not fromDict or propDict.get(
-                "webSocket"
-            ) is None
-            else propDict["webSocket"])
+            else propDict["usersInfo"])
 
     @property
-    def biosVersion(self):
-        """ """
-        return self._biosVersion
+    def alternateContact(self):
+        """AlternateContact: Org Owner Alternate Contact"""
+        return self._alternateContact
 
-    @biosVersion.setter
-    def biosVersion(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._biosVersion = value
+    @alternateContact.setter
+    def alternateContact(self, value):
+        if value is not None and not isinstance(value, AlternateContact):
+            value = AlternateContact(value)
+        if (value is None) or isinstance(value, AlternateContact):
+            self._alternateContact = value
         else:
             raise TypeError(
-                'Property "biosVersion" of type "list<str>" set to wrong type'
+                'Property "alternateContact" of type "list<AlternateContact>"'
+                ' set to wrong type'
             )
 
     @property
-    def bmcVersion(self):
-        """ """
-        return self._bmcVersion
+    def billingAccountId(self):
+        """str: Billing account ID."""
+        return self._billingAccountId
 
-    @bmcVersion.setter
-    def bmcVersion(self, value):
+    @billingAccountId.setter
+    def billingAccountId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._bmcVersion = value
+            self._billingAccountId = value
         else:
             raise TypeError(
-                'Property "bmcVersion" of type "list<str>" set to wrong type'
+                'Property "billingAccountId" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def cloudManaged(self):
-        """bool: Represent if the node is managed by the cloud or not. Set at 
-        the time of node boot by default and can be turned off by cust
-        omer admin."""
-        return self._cloudManaged
+    def canAddOn(self):
+        """bool: Identifies if the org can be reused."""
+        return self._canAddOn
 
-    @cloudManaged.setter
-    def cloudManaged(self, value):
+    @canAddOn.setter
+    def canAddOn(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._cloudManaged = value
+            self._canAddOn = value
         else:
             raise TypeError(
-                'Property "cloudManaged" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "canAddOn" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def configTurnId(self):
-        """str: Turn ID of the ACE configuration which resulted in the current
-         configuration. By default this value should be 0"""
-        return self._configTurnId
+    def country(self):
+        """str: ISO country code of the organization"""
+        return self._country
 
-    @configTurnId.setter
-    def configTurnId(self, value):
+    @country.setter
+    def country(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._configTurnId = value
-        else:
-            raise TypeError(
-                'Property "configTurnId" of type "list<str>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def cpuCoresPerSocket(self):
-        """int: number of CPU cores per socket"""
-        return self._cpuCoresPerSocket
-
-    @cpuCoresPerSocket.setter
-    def cpuCoresPerSocket(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._cpuCoresPerSocket = value
+            self._country = value
         else:
             raise TypeError(
-                'Property "cpuCoresPerSocket" of type "list<int>" set to wron'
-                'g type'
+                'Property "country" of type "list<str>" set to wrong type'
             )
 
     @property
-    def cpuModelName(self):
-        """str: cpu model"""
-        return self._cpuModelName
+    def description(self):
+        """str: optional description of the organization"""
+        return self._description
 
-    @cpuModelName.setter
-    def cpuModelName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._cpuModelName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "cpuModelName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def cpuSockets(self):
-        """int: number of CPU sockets"""
-        return self._cpuSockets
+    def displayName(self):
+        """str: Name of the organization that will be shown to users."""
+        return self._displayName
 
-    @cpuSockets.setter
-    def cpuSockets(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._cpuSockets = value
-        else:
-            raise TypeError(
-                'Property "cpuSockets" of type "list<int>" set to wrong type'
-            )
-
-    @property
-    def debianRepoURL(self):
-        """str: Debian repo from where SW is upgraded."""
-        return self._debianRepoURL
-
-    @debianRepoURL.setter
-    def debianRepoURL(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._debianRepoURL = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "debianRepoURL" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def diskSpace(self):
+    def emsOrgUniqueIdentifier(self):
         """ """
-        return self._diskSpace
+        return self._emsOrgUniqueIdentifier
 
-    @diskSpace.setter
-    def diskSpace(self, value):
+    @emsOrgUniqueIdentifier.setter
+    def emsOrgUniqueIdentifier(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._diskSpace = value
+            self._emsOrgUniqueIdentifier = value
         else:
             raise TypeError(
-                'Property "diskSpace" of type "list<str>" set to wrong type'
+                'Property "emsOrgUniqueIdentifier" of type "list<str>" set to'
+                ' wrong type'
             )
 
     @property
-    def dockerApiVersion(self):
-        """str: Current docker API version supported by the docker daemon inst
-        alled on appliance"""
-        return self._dockerApiVersion
+    def id(self):
+        """long: unique Id of this org."""
+        return self._id
 
-    @dockerApiVersion.setter
-    def dockerApiVersion(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._dockerApiVersion = value
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
         else:
             raise TypeError(
-                'Property "dockerApiVersion" of type "list<str>" set to wrong'
-                ' type'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
-    def fwVersion(self):
-        """ """
-        return self._fwVersion
+    def idpId(self):
+        """str: Identity Provider ID."""
+        return self._idpId
 
-    @fwVersion.setter
-    def fwVersion(self, value):
+    @idpId.setter
+    def idpId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fwVersion = value
-        else:
-            raise TypeError(
-                'Property "fwVersion" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def gatewayIp(self):
-        """ """
-        return self._gatewayIp
-
-    @gatewayIp.setter
-    def gatewayIp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._gatewayIp = value
-        else:
-            raise TypeError(
-                'Property "gatewayIp" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def gpuModelName(self):
-        """str: gpu model"""
-        return self._gpuModelName
-
-    @gpuModelName.setter
-    def gpuModelName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._gpuModelName = value
-        else:
-            raise TypeError(
-                'Property "gpuModelName" of type "list<str>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def healthStatus(self):
-        """ """
-        return self._healthStatus
-
-    @healthStatus.setter
-    def healthStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._healthStatus = value
+            self._idpId = value
         else:
             raise TypeError(
-                'Property "healthStatus" of type "list<HealthStatusEnum>" set'
-                ' to wrong type'
+                'Property "idpId" of type "list<str>" set to wrong type'
             )
 
-    HealthStatusEnum=["UNKNOWN","OK","UNDER_MAINTENANCE","FAILED",]
-    str(repr(HealthStatusEnum))  # Prevent optimizer removing enum
-
     @property
-    def ipAddress(self):
-        """str: ip address of the node"""
-        return self._ipAddress
+    def industry(self):
+        """str: industry of the organization"""
+        return self._industry
 
-    @ipAddress.setter
-    def ipAddress(self, value):
+    @industry.setter
+    def industry(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._ipAddress = value
+            self._industry = value
         else:
             raise TypeError(
-                'Property "ipAddress" of type "list<str>" set to wrong type'
+                'Property "industry" of type "list<str>" set to wrong type'
             )
 
     @property
-    def ipmi(self):
-        """str: IP address that can be used for IPMI reset"""
-        return self._ipmi
+    def infinityManagerSettings(self):
+        """InfinityManagerSettings: Infinity manager setting definition"""
+        return self._infinityManagerSettings
 
-    @ipmi.setter
-    def ipmi(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._ipmi = value
+    @infinityManagerSettings.setter
+    def infinityManagerSettings(self, value):
+        if value is not None and not isinstance(value, InfinityManagerSettings):
+            value = InfinityManagerSettings(value)
+        if (value is None) or isinstance(value, InfinityManagerSettings):
+            self._infinityManagerSettings = value
         else:
             raise TypeError(
-                'Property "ipmi" of type "list<str>" set to wrong type'
+                'Property "infinityManagerSettings" of type "list<InfinityMan'
+                'agerSettings>" set to wrong type'
             )
 
     @property
-    def isMarathonLeader(self):
-        """bool: true is this node is designated as the leader. job request is
-         sent to marathon leader"""
-        return self._isMarathonLeader
+    def isDatasetServiceEnabled(self):
+        """bool: Dataset Service enable flag for an organization"""
+        return self._isDatasetServiceEnabled
 
-    @isMarathonLeader.setter
-    def isMarathonLeader(self, value):
+    @isDatasetServiceEnabled.setter
+    def isDatasetServiceEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isMarathonLeader = value
+            self._isDatasetServiceEnabled = value
         else:
             raise TypeError(
-                'Property "isMarathonLeader" of type "list<bool>" set to wron'
-                'g type'
+                'Property "isDatasetServiceEnabled" of type "list<bool>" set '
+                'to wrong type'
             )
 
     @property
-    def isMaster(self):
-        """bool: If not master then it is a slave node."""
-        return self._isMaster
+    def isInternal(self):
+        """bool: Is NVIDIA internal org or not"""
+        return self._isInternal
 
-    @isMaster.setter
-    def isMaster(self, value):
+    @isInternal.setter
+    def isInternal(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isMaster = value
+            self._isInternal = value
         else:
             raise TypeError(
-                'Property "isMaster" of type "list<bool>" set to wrong type'
+                'Property "isInternal" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def isMesosLeader(self):
-        """bool: true is this node is designated as the mesos leader. job stat
-        us polling is sent to mesos leader"""
-        return self._isMesosLeader
+    def isQuickStartEnabled(self):
+        """bool: Quick Start enable flag for an organization"""
+        return self._isQuickStartEnabled
 
-    @isMesosLeader.setter
-    def isMesosLeader(self, value):
+    @isQuickStartEnabled.setter
+    def isQuickStartEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isMesosLeader = value
+            self._isQuickStartEnabled = value
         else:
             raise TypeError(
-                'Property "isMesosLeader" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "isQuickStartEnabled" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def isSchedulerLeader(self):
-        """bool: indicates if this node is the current leader for scheduling j
-        obs on ACE. If value is provided, then it will be used instead
-         of isMarathonLeader"""
-        return self._isSchedulerLeader
+    def isSecretsManagerServiceEnabled(self):
+        """bool: Secrets Manager Service enable flag for an organization"""
+        return self._isSecretsManagerServiceEnabled
 
-    @isSchedulerLeader.setter
-    def isSchedulerLeader(self, value):
+    @isSecretsManagerServiceEnabled.setter
+    def isSecretsManagerServiceEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isSchedulerLeader = value
+            self._isSecretsManagerServiceEnabled = value
         else:
             raise TypeError(
-                'Property "isSchedulerLeader" of type "list<bool>" set to wro'
-                'ng type'
+                'Property "isSecretsManagerServiceEnabled" of type "list<bool'
+                '>" set to wrong type'
             )
 
     @property
-    def isZooKeeperLeader(self):
-        """bool: true if this node is a master leader designated for schedulin
-        g"""
-        return self._isZooKeeperLeader
+    def isSeparateInfluxDbUsed(self):
+        """bool: If a separate influx db used for an organization in BCP for j
+        ob telemetry"""
+        return self._isSeparateInfluxDbUsed
 
-    @isZooKeeperLeader.setter
-    def isZooKeeperLeader(self, value):
+    @isSeparateInfluxDbUsed.setter
+    def isSeparateInfluxDbUsed(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isZooKeeperLeader = value
-        else:
-            raise TypeError(
-                'Property "isZooKeeperLeader" of type "list<bool>" set to wro'
-                'ng type'
-            )
-
-    @property
-    def lastBoot(self):
-        """ """
-        return self._lastBoot
-
-    @lastBoot.setter
-    def lastBoot(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._lastBoot = value
+            self._isSeparateInfluxDbUsed = value
         else:
             raise TypeError(
-                'Property "lastBoot" of type "list<str>" set to wrong type'
+                'Property "isSeparateInfluxDbUsed" of type "list<bool>" set t'
+                'o wrong type'
             )
 
     @property
-    def masterIpAddress(self):
-        """str: ip address of the master, can be the same as IP address of the
-         node"""
-        return self._masterIpAddress
+    def name(self):
+        """str: Organization name"""
+        return self._name
 
-    @masterIpAddress.setter
-    def masterIpAddress(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._masterIpAddress = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "masterIpAddress" of type "list<str>" set to wrong '
-                'type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def memory(self):
-        """int: memory in MegaBytes"""
-        return self._memory
+    def orgOwner(self):
+        """OrgOwner: Org owner"""
+        return self._orgOwner
 
-    @memory.setter
-    def memory(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._memory = value
+    @orgOwner.setter
+    def orgOwner(self, value):
+        if value is not None and not isinstance(value, OrgOwner):
+            value = OrgOwner(value)
+        if (value is None) or isinstance(value, OrgOwner):
+            self._orgOwner = value
         else:
             raise TypeError(
-                'Property "memory" of type "list<int>" set to wrong type'
-            )
-
-    @property
-    def modelName(self):
-        """ """
-        return self._modelName
-
-    @modelName.setter
-    def modelName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._modelName = value
-        else:
-            raise TypeError(
-                'Property "modelName" of type "list<str>" set to wrong type'
+                'Property "orgOwner" of type "list<OrgOwner>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def networkType(self):
-        """ """
-        return self._networkType
-
-    @networkType.setter
-    def networkType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._networkType = value
+    def orgOwnerIds(self):
+        """list: List of Org owner ids."""
+        return self._orgOwnerIds
+
+    @orgOwnerIds.setter
+    def orgOwnerIds(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._orgOwnerIds = value
         else:
             raise TypeError(
-                'Property "networkType" of type "list<NetworkTypeEnum>" set t'
-                'o wrong type'
+                'Property "orgOwnerIds" of type "list<long>" set to wrong typ'
+                'e'
             )
 
-    NetworkTypeEnum=["UNKNOWN","INFINIBAND",]
-    str(repr(NetworkTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def numGpus(self):
-        """int: number of GPUs in the node"""
-        return self._numGpus
-
-    @numGpus.setter
-    def numGpus(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._numGpus = value
+    def orgOwners(self):
+        """list: Org owners"""
+        return self._orgOwners
+
+    @orgOwners.setter
+    def orgOwners(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._orgOwners = value
         else:
             raise TypeError(
-                'Property "numGpus" of type "list<int>" set to wrong type'
+                'Property "orgOwners" of type "list<OrgOwner>" set to wrong t'
+                'ype'
             )
 
     @property
-    def roleTurnId(self):
-        """str: Turn ID of the ACE configuration which resulted in the current
-         role. By default this value should be 0"""
-        return self._roleTurnId
+    def pecSfdcId(self):
+        """str: Product end customer salesforce.com Id (external customer Id).
+         pecSfdcId is for EMS (entitlement management service) to trac
+        k external paid customer"""
+        return self._pecSfdcId
 
-    @roleTurnId.setter
-    def roleTurnId(self, value):
+    @pecSfdcId.setter
+    def pecSfdcId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._roleTurnId = value
+            self._pecSfdcId = value
         else:
             raise TypeError(
-                'Property "roleTurnId" of type "list<str>" set to wrong type'
+                'Property "pecSfdcId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def state(self):
+    def productAccessTier(self):
         """ """
-        return self._state
+        return self._productAccessTier
 
-    @state.setter
-    def state(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._state = value
+    @productAccessTier.setter
+    def productAccessTier(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productAccessTier = value
         else:
             raise TypeError(
-                'Property "state" of type "list<StateEnum>" set to wrong type'
+                'Property "productAccessTier" of type "list<str>" set to wron'
+                'g type'
             )
 
-    StateEnum=["UNKNOWN","OK","DEGRADED","FAILED","UNDER_MAINTENANCE",]
-    str(repr(StateEnum))  # Prevent optimizer removing enum
-
     @property
-    def subNet(self):
+    def productEnablements(self):
         """ """
-        return self._subNet
+        return self._productEnablements
 
-    @subNet.setter
-    def subNet(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._subNet = value
+    @productEnablements.setter
+    def productEnablements(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productEnablements = value
         else:
             raise TypeError(
-                'Property "subNet" of type "list<str>" set to wrong type'
+                'Property "productEnablements" of type "list<ProductEnablemen'
+                't>" set to wrong type'
             )
 
     @property
-    def swVersion(self):
-        """ """
-        return self._swVersion
+    def repoScanSettings(self):
+        """RepoScanSettings: Repo scan setting definition"""
+        return self._repoScanSettings
 
-    @swVersion.setter
-    def swVersion(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._swVersion = value
+    @repoScanSettings.setter
+    def repoScanSettings(self, value):
+        if value is not None and not isinstance(value, RepoScanSettings):
+            value = RepoScanSettings(value)
+        if (value is None) or isinstance(value, RepoScanSettings):
+            self._repoScanSettings = value
         else:
             raise TypeError(
-                'Property "swVersion" of type "list<str>" set to wrong type'
+                'Property "repoScanSettings" of type "list<RepoScanSettings>"'
+                ' set to wrong type'
             )
 
     @property
-    def upgradeOnBoot(self):
-        """bool: If set to true, this node will update on boot"""
-        return self._upgradeOnBoot
+    def type(self):
+        """ """
+        return self._type
 
-    @upgradeOnBoot.setter
-    def upgradeOnBoot(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._upgradeOnBoot = value
+    @type.setter
+    def type(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._type = value
         else:
             raise TypeError(
-                'Property "upgradeOnBoot" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "type" of type "list<OrgTypeEnum>" set to wrong typ'
+                'e'
             )
 
     @property
-    def webSocket(self):
-        """WebSocket: object used to show the status of the websocket between 
-        node and the cloud"""
-        return self._webSocket
-
-    @webSocket.setter
-    def webSocket(self, value):
-        if value is not None and not isinstance(value, WebSocket):
-            value = WebSocket(value)
-        if (value is None) or isinstance(value, WebSocket):
-            self._webSocket = value
+    def usersInfo(self):
+        """UsersInfo: Users information."""
+        return self._usersInfo
+
+    @usersInfo.setter
+    def usersInfo(self, value):
+        if value is not None and not isinstance(value, UsersInfo):
+            value = UsersInfo(value)
+        if (value is None) or isinstance(value, UsersInfo):
+            self._usersInfo = value
         else:
             raise TypeError(
-                'Property "webSocket" of type "list<WebSocket>" set to wrong '
+                'Property "usersInfo" of type "list<UsersInfo>" set to wrong '
                 'type'
             )
 
     def toDict(self):
         result = {}
-        if self._biosVersion is not None:
-            result["biosVersion"] = \
-                self._biosVersion
-        if self._bmcVersion is not None:
-            result["bmcVersion"] = \
-                self._bmcVersion
-        if self._cloudManaged is not None:
-            result["cloudManaged"] = \
-                self._cloudManaged
-        if self._configTurnId is not None:
-            result["configTurnId"] = \
-                self._configTurnId
-        if self._cpuCoresPerSocket is not None:
-            result["cpuCoresPerSocket"] = \
-                self._cpuCoresPerSocket
-        if self._cpuModelName is not None:
-            result["cpuModelName"] = \
-                self._cpuModelName
-        if self._cpuSockets is not None:
-            result["cpuSockets"] = \
-                self._cpuSockets
-        if self._debianRepoURL is not None:
-            result["debianRepoURL"] = \
-                self._debianRepoURL
-        if self._diskSpace is not None:
-            result["diskSpace"] = \
-                self._diskSpace
-        if self._dockerApiVersion is not None:
-            result["dockerApiVersion"] = \
-                self._dockerApiVersion
-        if self._fwVersion is not None:
-            result["fwVersion"] = \
-                self._fwVersion
-        if self._gatewayIp is not None:
-            result["gatewayIp"] = \
-                self._gatewayIp
-        if self._gpuModelName is not None:
-            result["gpuModelName"] = \
-                self._gpuModelName
-        if self._healthStatus is not None:
-            result["healthStatus"] = \
-                self._healthStatus
-        if self._ipAddress is not None:
-            result["ipAddress"] = \
-                self._ipAddress
-        if self._ipmi is not None:
-            result["ipmi"] = \
-                self._ipmi
-        if self._isMarathonLeader is not None:
-            result["isMarathonLeader"] = \
-                self._isMarathonLeader
-        if self._isMaster is not None:
-            result["isMaster"] = \
-                self._isMaster
-        if self._isMesosLeader is not None:
-            result["isMesosLeader"] = \
-                self._isMesosLeader
-        if self._isSchedulerLeader is not None:
-            result["isSchedulerLeader"] = \
-                self._isSchedulerLeader
-        if self._isZooKeeperLeader is not None:
-            result["isZooKeeperLeader"] = \
-                self._isZooKeeperLeader
-        if self._lastBoot is not None:
-            result["lastBoot"] = \
-                self._lastBoot
-        if self._masterIpAddress is not None:
-            result["masterIpAddress"] = \
-                self._masterIpAddress
-        if self._memory is not None:
-            result["memory"] = \
-                self._memory
-        if self._modelName is not None:
-            result["modelName"] = \
-                self._modelName
-        if self._networkType is not None:
-            result["networkType"] = \
-                self._networkType
-        if self._numGpus is not None:
-            result["numGpus"] = \
-                self._numGpus
-        if self._roleTurnId is not None:
-            result["roleTurnId"] = \
-                self._roleTurnId
-        if self._state is not None:
-            result["state"] = \
-                self._state
-        if self._subNet is not None:
-            result["subNet"] = \
-                self._subNet
-        if self._swVersion is not None:
-            result["swVersion"] = \
-                self._swVersion
-        if self._upgradeOnBoot is not None:
-            result["upgradeOnBoot"] = \
-                self._upgradeOnBoot
-        if self._webSocket:
-            result["webSocket"] = \
-                self._webSocket.toDict() if self._webSocket is not None else None
+        if self._alternateContact:
+            result["alternateContact"] = \
+                self._alternateContact.toDict() if self._alternateContact is not None else None
+        if self._billingAccountId is not None:
+            result["billingAccountId"] = \
+                self._billingAccountId
+        if self._canAddOn is not None:
+            result["canAddOn"] = \
+                self._canAddOn
+        if self._country is not None:
+            result["country"] = \
+                self._country
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._emsOrgUniqueIdentifier is not None:
+            result["emsOrgUniqueIdentifier"] = \
+                self._emsOrgUniqueIdentifier
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._idpId is not None:
+            result["idpId"] = \
+                self._idpId
+        if self._industry is not None:
+            result["industry"] = \
+                self._industry
+        if self._infinityManagerSettings:
+            result["infinityManagerSettings"] = \
+                self._infinityManagerSettings.toDict() if self._infinityManagerSettings is not None else None
+        if self._isDatasetServiceEnabled is not None:
+            result["isDatasetServiceEnabled"] = \
+                self._isDatasetServiceEnabled
+        if self._isInternal is not None:
+            result["isInternal"] = \
+                self._isInternal
+        if self._isQuickStartEnabled is not None:
+            result["isQuickStartEnabled"] = \
+                self._isQuickStartEnabled
+        if self._isSecretsManagerServiceEnabled is not None:
+            result["isSecretsManagerServiceEnabled"] = \
+                self._isSecretsManagerServiceEnabled
+        if self._isSeparateInfluxDbUsed is not None:
+            result["isSeparateInfluxDbUsed"] = \
+                self._isSeparateInfluxDbUsed
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._orgOwner:
+            result["orgOwner"] = \
+                self._orgOwner.toDict() if self._orgOwner is not None else None
+        if self._orgOwnerIds is not None:
+            result["orgOwnerIds"] = \
+                self._orgOwnerIds
+        if self._orgOwners:
+            result["orgOwners"] = [
+                i.toDict() for i in self._orgOwners 
+            ] if self._orgOwners else []
+        if self._pecSfdcId is not None:
+            result["pecSfdcId"] = \
+                self._pecSfdcId
+        if self._productAccessTier is not None:
+            result["productAccessTier"] = \
+                self._productAccessTier
+        if self._productEnablements:
+            result["productEnablements"] = [
+                i.toDict() for i in self._productEnablements 
+            ] if self._productEnablements else []
+        if self._repoScanSettings:
+            result["repoScanSettings"] = \
+                self._repoScanSettings.toDict() if self._repoScanSettings is not None else None
+        if self._type is not None:
+            result["type"] = \
+                self._type
+        if self._usersInfo:
+            result["usersInfo"] = \
+                self._usersInfo.toDict() if self._usersInfo is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._webSocket is not None): self._webSocket.isValid()
+        if (self._displayName is not None
+            and
+            len(self._displayName) < 1):
+            raise ValueError(
+                "Organization.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 255):
+            raise ValueError(
+                "Organization.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._repoScanSettings is not None): self._repoScanSettings.isValid()
+        if (self._infinityManagerSettings is not None): self._infinityManagerSettings.isValid()
+        if (self._orgOwner is not None): self._orgOwner.isValid()
+        if (self._orgOwners is not None):
+            for obj in self._orgOwners:
+                if (obj is not None): obj.isValid()
+        if (self._productEnablements is not None):
+            for obj in self._productEnablements:
+                if (obj is not None): obj.isValid()
+        if (self._alternateContact is not None): self._alternateContact.isValid()
+        if (self._usersInfo is not None): self._usersInfo.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeStatusChangedEvent.py` & `ngcbpc/data/model/EnumerableResource.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,59 +6,92 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .EnumerableResourceItem import EnumerableResourceItem
 
 # Unused import over optimization prevention
+str(repr(EnumerableResourceItem))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeStatusChangedEvent(object):
-    """This event is used to notify that Node Status has changed"""
+class EnumerableResource(object):
+    """Enumerable Resource object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodeSerialNumber = (
+        self.defaultItemName = (
             None if not fromDict or propDict.get(
-                "nodeSerialNumber"
+                "defaultItemName"
             ) is None
-            else propDict["nodeSerialNumber"])
+            else propDict["defaultItemName"])
+        self.items = (
+            None if not fromDict or propDict.get(
+                "items"
+            ) is None
+            else [ EnumerableResourceItem(i)
+            for i in propDict["items"] ])
 
     @property
-    def nodeSerialNumber(self):
-        """str: Unique identifier of the Node."""
-        return self._nodeSerialNumber
+    def defaultItemName(self):
+        """str: Deprecated: Default item name. Please use actual CloudServiceP
+        rovider values instead"""
+        return self._defaultItemName
 
-    @nodeSerialNumber.setter
-    def nodeSerialNumber(self, value):
+    @defaultItemName.setter
+    def defaultItemName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nodeSerialNumber = value
+            self._defaultItemName = value
+        else:
+            raise TypeError(
+                'Property "defaultItemName" of type "list<str>" set to wrong '
+                'type'
+            )
+
+    @property
+    def items(self):
+        """ """
+        return self._items
+
+    @items.setter
+    def items(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._items = value
         else:
             raise TypeError(
-                'Property "nodeSerialNumber" of type "list<str>" set to wrong'
-                ' type'
+                'Property "items" of type "list<EnumerableResourceItem>" set '
+                'to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._nodeSerialNumber is not None:
-            result["nodeSerialNumber"] = \
-                self._nodeSerialNumber
+        if self._defaultItemName is not None:
+            result["defaultItemName"] = \
+                self._defaultItemName
+        if self._items:
+            result["items"] = [
+                i.toDict() for i in self._items 
+            ] if self._items else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._items is not None):
+            for obj in self._items:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/NodeStatusUpdate.py` & `basecommand/data/pym/HealthInfoItem.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,118 +6,139 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NodeStatus import NodeStatus
 
 # Unused import over optimization prevention
-str(repr(NodeStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeStatusUpdate(object):
-    """This message is sent from the node in order to update node status"""
+class HealthInfoItem(object):
+    """Health Indicator"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodeStatus = (
+        self.component = (
             None if not fromDict or propDict.get(
-                "nodeStatus"
+                "component"
             ) is None
-            else propDict["nodeStatus"])
-        self.serialNumber = (
+            else propDict["component"])
+        self.details = (
             None if not fromDict or propDict.get(
-                "serialNumber"
+                "details"
             ) is None
-            else propDict["serialNumber"])
+            else propDict["details"])
+        self.status = (
+            None if not fromDict or propDict.get(
+                "status"
+            ) is None
+            else propDict["status"])
 
     @property
-    def nodeStatus(self):
-        """NodeStatus: data in this object is populated from the node"""
-        return self._nodeStatus
-
-    @nodeStatus.setter
-    def nodeStatus(self, value):
-        if value is not None and not isinstance(value, NodeStatus):
-            value = NodeStatus(value)
-        if (value is None) or isinstance(value, NodeStatus):
-            self._nodeStatus = value
+    def component(self):
+        """str: Component Name"""
+        return self._component
+
+    @component.setter
+    def component(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._component = value
         else:
             raise TypeError(
-                'Property "nodeStatus" of type "list<NodeStatus>" set to wron'
-                'g type'
+                'Property "component" of type "list<str>" set to wrong type'
             )
 
     @property
-    def serialNumber(self):
-        """str: serial number of the appliance, required while registering the
-         appliance"""
-        return self._serialNumber
+    def details(self):
+        """str: Component details"""
+        return self._details
 
-    @serialNumber.setter
-    def serialNumber(self, value):
+    @details.setter
+    def details(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._serialNumber = value
+            self._details = value
         else:
             raise TypeError(
-                'Property "serialNumber" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "details" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def status(self):
+        """str: Component Status"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._status = value
+        else:
+            raise TypeError(
+                'Property "status" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._nodeStatus:
-            result["nodeStatus"] = \
-                self._nodeStatus.toDict() if self._nodeStatus is not None else None
-        if self._serialNumber is not None:
-            result["serialNumber"] = \
-                self._serialNumber
+        if self._component is not None:
+            result["component"] = \
+                self._component
+        if self._details is not None:
+            result["details"] = \
+                self._details
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._serialNumber is None:
+        if self._component is None:
             raise ValueError(
-                "NodeStatusUpdate.serialNumber doesnt match requirement:" 
+                "HealthInfoItem.component doesnt match requirement:" 
                 "required: True"
             )
-        if (self._serialNumber is not None
+        if (self._component is not None
             and
-            len(self._serialNumber) < 8):
+            len(self._component) < 1):
             raise ValueError(
-                "NodeStatusUpdate.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: minLength: 8")
-        if (self._serialNumber is not None
-            and
-            len(self._serialNumber) > 64):
+                "HealthInfoItem.component: " + str(self._component) + 
+                " doesnt match requirement: minLength: 1")
+        if self._status is None:
             raise ValueError(
-                "NodeStatusUpdate.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._serialNumber is not None
+                "HealthInfoItem.status doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._status is not None
             and
-            not re.match(
-                r"^[a-zA-Z\d_-]*$",
-                 self._serialNumber)):
-            raise ValueError(
-                "NodeStatusUpdate.serialNumber: " + str(self._serialNumber) + 
-                " doesnt match requirement: pattern: ^[a-zA-Z\d_-]*$")
-        if self._nodeStatus is None:
+            len(self._status) < 1):
+            raise ValueError(
+                "HealthInfoItem.status: " + str(self._status) + 
+                " doesnt match requirement: minLength: 1")
+        if self._details is None:
             raise ValueError(
-                "NodeStatusUpdate.nodeStatus doesnt match requirement:" 
+                "HealthInfoItem.details doesnt match requirement:" 
                 "required: True"
             )
-        if (self._nodeStatus is not None): self._nodeStatus.isValid()
+        if (self._details is not None
+            and
+            len(self._details) < 1):
+            raise ValueError(
+                "HealthInfoItem.details: " + str(self._details) + 
+                " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/api/OrgAdminUserCreatedEvent.py` & `ngcbpc/data/uis/OrgAdminUserCreatedEvent.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/OrgCreateRequest.py` & `ngcbpc/data/model/ArtifactUpdateRequest.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,121 +6,147 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .OrgOwner import OrgOwner
-from .ProductEnablement import ProductEnablement
-from .OrgType import OrgTypeEnum
-from .ProductSubscription import ProductSubscription
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(ProductEnablement))
-str(repr(OrgOwner))
-str(repr(OrgTypeEnum))
-str(repr(ProductSubscription))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgCreateRequest(object):
-    """Request to create new Organization"""
+class ArtifactUpdateRequest(object):
+    """Request to update a artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.country = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "country"
+                "attributes"
             ) is None
-            else propDict["country"])
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.bias = (
+            None if not fromDict or propDict.get(
+                "bias"
+            ) is None
+            else propDict["bias"])
+        self.builtBy = (
+            None if not fromDict or propDict.get(
+                "builtBy"
+            ) is None
+            else propDict["builtBy"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
-        self.idpId = (
-            None if not fromDict or propDict.get(
-                "idpId"
-            ) is None
-            else propDict["idpId"])
-        self.name = (
-            None if not fromDict or propDict.get(
-                "name"
-            ) is None
-            else propDict["name"])
-        self.orgOwner = (
+        self.explainability = (
             None if not fromDict or propDict.get(
-                "orgOwner"
+                "explainability"
             ) is None
-            else propDict["orgOwner"])
-        self.pecName = (
+            else propDict["explainability"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "pecName"
+                "labels"
             ) is None
-            else propDict["pecName"])
-        self.pecSfdcId = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "pecSfdcId"
+                "labelsV2"
             ) is None
-            else propDict["pecSfdcId"])
-        self.productEnablements = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "productEnablements"
+                "logo"
             ) is None
-            else [ ProductEnablement(i)
-            for i in propDict["productEnablements"] ])
-        self.productSubscriptions = (
+            else propDict["logo"])
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "productSubscriptions"
+                "privacy"
             ) is None
-            else [ ProductSubscription(i)
-            for i in propDict["productSubscriptions"] ])
-        self.salesforceAccountIndustry = (
+            else propDict["privacy"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "salesforceAccountIndustry"
+                "publisher"
             ) is None
-            else propDict["salesforceAccountIndustry"])
-        self.sendEmail = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "sendEmail"
+                "safetyAndSecurity"
             ) is None
-            else propDict["sendEmail"])
-        self.type = (
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "type"
+                "shortDescription"
             ) is None
-            else propDict["type"])
+            else propDict["shortDescription"])
+
+    @property
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
+        else:
+            raise TypeError(
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
+            )
 
     @property
-    def country(self):
-        """str: user country"""
-        return self._country
+    def bias(self):
+        """str: Text describing bias in the model"""
+        return self._bias
 
-    @country.setter
-    def country(self, value):
+    @bias.setter
+    def bias(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._country = value
+            self._bias = value
         else:
             raise TypeError(
-                'Property "country" of type "list<str>" set to wrong type'
+                'Property "bias" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def builtBy(self):
+        """str: organization that built the artifact"""
+        return self._builtBy
+
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
+        else:
+            raise TypeError(
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: optional description of the organization"""
+        """str: Description of the artifact"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -128,291 +154,245 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """str: Name of the organization that will be shown to users."""
+        """str: Display name"""
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def idpId(self):
-        """str: Identity Provider ID."""
-        return self._idpId
+    def explainability(self):
+        """str: Text describing explainability for this model"""
+        return self._explainability
 
-    @idpId.setter
-    def idpId(self, value):
+    @explainability.setter
+    def explainability(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._idpId = value
+            self._explainability = value
         else:
             raise TypeError(
-                'Property "idpId" of type "list<str>" set to wrong type'
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def name(self):
-        """str: Organization name"""
-        return self._name
+    def labels(self):
+        """ """
+        return self._labels
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgOwner(self):
-        """OrgOwner: Org owner."""
-        return self._orgOwner
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @orgOwner.setter
-    def orgOwner(self, value):
-        if value is not None and not isinstance(value, OrgOwner):
-            value = OrgOwner(value)
-        if (value is None) or isinstance(value, OrgOwner):
-            self._orgOwner = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "orgOwner" of type "list<OrgOwner>" set to wrong ty'
-                'pe'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def pecName(self):
-        """str: product end customer name for enterprise(Fleet Command) produc
-        t"""
-        return self._pecName
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @pecName.setter
-    def pecName(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._pecName = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "pecName" of type "list<str>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def pecSfdcId(self):
-        """str: product end customer salesforce.com Id (external customer Id) 
-        for enterprise(Fleet Command) product"""
-        return self._pecSfdcId
+    def privacy(self):
+        """str: Text describing the privacy for this model"""
+        return self._privacy
 
-    @pecSfdcId.setter
-    def pecSfdcId(self, value):
+    @privacy.setter
+    def privacy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._pecSfdcId = value
+            self._privacy = value
         else:
             raise TypeError(
-                'Property "pecSfdcId" of type "list<str>" set to wrong type'
+                'Property "privacy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productEnablements(self):
-        """ """
-        return self._productEnablements
+    def publisher(self):
+        """str: organization that published the artifact"""
+        return self._publisher
 
-    @productEnablements.setter
-    def productEnablements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productEnablements = value
-        else:
-            raise TypeError(
-                'Property "productEnablements" of type "list<ProductEnablemen'
-                't>" set to wrong type'
-            )
-
-    @property
-    def productSubscriptions(self):
-        """list: This should be deprecated, use productEnablements instead"""
-        return self._productSubscriptions
-
-    @productSubscriptions.setter
-    def productSubscriptions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productSubscriptions = value
-        else:
-            raise TypeError(
-                'Property "productSubscriptions" of type "list<ProductSubscri'
-                'ption>" set to wrong type'
-            )
-
-    @property
-    def salesforceAccountIndustry(self):
-        """str: Company or organization industry"""
-        return self._salesforceAccountIndustry
-
-    @salesforceAccountIndustry.setter
-    def salesforceAccountIndustry(self, value):
+    @publisher.setter
+    def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._salesforceAccountIndustry = value
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "salesforceAccountIndustry" of type "list<str>" set'
-                ' to wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sendEmail(self):
-        """bool: Send email to org owner or not. Default is true"""
-        return self._sendEmail
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the model"""
+        return self._safetyAndSecurity
 
-    @sendEmail.setter
-    def sendEmail(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._sendEmail = value
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "sendEmail" of type "list<bool>" set to wrong type'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def shortDescription(self):
+        """str: Short description of the artifact"""
+        return self._shortDescription
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "type" of type "list<OrgTypeEnum>" set to wrong typ'
-                'e'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._country is not None:
-            result["country"] = \
-                self._country
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._idpId is not None:
-            result["idpId"] = \
-                self._idpId
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgOwner:
-            result["orgOwner"] = \
-                self._orgOwner.toDict() if self._orgOwner is not None else None
-        if self._pecName is not None:
-            result["pecName"] = \
-                self._pecName
-        if self._pecSfdcId is not None:
-            result["pecSfdcId"] = \
-                self._pecSfdcId
-        if self._productEnablements:
-            result["productEnablements"] = [
-                i.toDict() for i in self._productEnablements 
-            ] if self._productEnablements else []
-        if self._productSubscriptions:
-            result["productSubscriptions"] = [
-                i.toDict() for i in self._productSubscriptions 
-            ] if self._productSubscriptions else []
-        if self._salesforceAccountIndustry is not None:
-            result["salesforceAccountIndustry"] = \
-                self._salesforceAccountIndustry
-        if self._sendEmail is not None:
-            result["sendEmail"] = \
-                self._sendEmail
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
+        if (self._shortDescription is not None
             and
-            len(self._name) < 2):
+            len(self._shortDescription) > 255):
             raise ValueError(
-                "OrgCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
-            and
-            len(self._name) > 64):
-            raise ValueError(
-                "OrgCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._name is not None
+                "ArtifactUpdateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
             and
-            not re.match(
-                r"[a-z][a-z\d_-]+",
-                 self._name)):
+            len(self._displayName) < 2):
             raise ValueError(
-                "OrgCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: [a-z][a-z\d_-]+")
+                "ArtifactUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
         if (self._displayName is not None
             and
-            len(self._displayName) < 1):
+            len(self._displayName) > 64):
             raise ValueError(
-                "OrgCreateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._displayName is not None
+                "ArtifactUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._logo is not None
             and
-            len(self._displayName) > 255):
+            len(self._logo) > 255):
             raise ValueError(
-                "OrgCreateRequest.displayName: " + str(self._displayName) + 
+                "ArtifactUpdateRequest.logo: " + str(self._logo) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._description is not None
+        if (self._builtBy is not None
             and
-            len(self._description) > 128):
+            len(self._builtBy) > 255):
             raise ValueError(
-                "OrgCreateRequest.description: " + str(self._description) + 
-                " doesnt match requirement: maxLength: 128")
-        if self._orgOwner is None:
+                "ArtifactUpdateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
+            and
+            len(self._publisher) > 255):
             raise ValueError(
-                "OrgCreateRequest.orgOwner doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._orgOwner is not None): self._orgOwner.isValid()
-        if (self._productSubscriptions is not None):
-            for obj in self._productSubscriptions:
-                if (obj is not None): obj.isValid()
-        if (self._productEnablements is not None):
-            for obj in self._productEnablements:
+                "ArtifactUpdateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/OrgCreateResponse.py` & `ngcbpc/data/uis/UisOrgInfoResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,56 +6,56 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
 from .Organization import Organization
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(Organization))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgCreateResponse(object):
-    """response to an org creation request, includes unique org id"""
+class UisOrgInfoResponse(object):
+    """info about an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.org = (
+        self.organization = (
             None if not fromDict or propDict.get(
-                "org"
+                "organization"
             ) is None
-            else propDict["org"])
+            else propDict["organization"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def org(self):
+    def organization(self):
         """Organization: Information about the Organization"""
-        return self._org
+        return self._organization
 
-    @org.setter
-    def org(self, value):
+    @organization.setter
+    def organization(self, value):
         if value is not None and not isinstance(value, Organization):
             value = Organization(value)
         if (value is None) or isinstance(value, Organization):
-            self._org = value
+            self._organization = value
         else:
             raise TypeError(
-                'Property "org" of type "list<Organization>" set to wrong typ'
-                'e'
+                'Property "organization" of type "list<Organization>" set to '
+                'wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -69,27 +69,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._org:
-            result["org"] = \
-                self._org.toDict() if self._org is not None else None
+        if self._organization:
+            result["organization"] = \
+                self._organization.toDict() if self._organization is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._org is not None): self._org.isValid()
+        if (self._organization is not None): self._organization.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/OrgCreatedEvent.py` & `ngcbpc/data/uis/RotateApiKeyRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,51 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgCreatedEvent(object):
-    """This event in the queue means an org should be created/updated in third
-     party CRM"""
+class RotateApiKeyRequest(object):
+    """Rotate api key request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.expiryDate = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "expiryDate"
             ) is None
-            else propDict["orgName"])
+            else propDict["expiryDate"])
 
     @property
-    def orgName(self):
-        """str: Unique identifier of the org."""
-        return self._orgName
+    def expiryDate(self):
+        """str: Expiration date of the key"""
+        return self._expiryDate
 
-    @orgName.setter
-    def orgName(self, value):
+    @expiryDate.setter
+    def expiryDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._expiryDate = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "expiryDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
+        if self._expiryDate is not None:
+            result["expiryDate"] = \
+                self._expiryDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._expiryDate is None:
+            raise ValueError(
+                "RotateApiKeyRequest.expiryDate doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/OrgEnablementCreateRequest.py` & `organization/data/subscription_management_service/OrgEnablementCreateRequest.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/OrgListEntitlementResponse.py` & `organization/data/subscription_management_service/ListUserSubscriptionsResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,59 +6,41 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .OrganizationEntitlement import OrganizationEntitlement
+from .UserSubscriptions import UserSubscriptions
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(OrganizationEntitlement))
+str(repr(UserSubscriptions))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgListEntitlementResponse(object):
-    """List of all organizations which have entitlement information. Only acce
-    ssible by NGC admin portal"""
+class ListUserSubscriptionsResponse(object):
+    """Response for list subscriptions API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.entitlements = (
-            None if not fromDict or propDict.get(
-                "entitlements"
-            ) is None
-            else [ OrganizationEntitlement(i)
-            for i in propDict["entitlements"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def entitlements(self):
-        """ """
-        return self._entitlements
-
-    @entitlements.setter
-    def entitlements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._entitlements = value
-        else:
-            raise TypeError(
-                'Property "entitlements" of type "list<OrganizationEntitlemen'
-                't>" set to wrong type'
-            )
+        self.subscriptions = (
+            None if not fromDict or propDict.get(
+                "subscriptions"
+            ) is None
+            else [ UserSubscriptions(i)
+            for i in propDict["subscriptions"] ])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -69,32 +51,49 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscriptions(self):
+        """list: array of user subscriptions objects"""
+        return self._subscriptions
+
+    @subscriptions.setter
+    def subscriptions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._subscriptions = value
+        else:
+            raise TypeError(
+                'Property "subscriptions" of type "list<UserSubscriptions>" s'
+                'et to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._entitlements:
-            result["entitlements"] = [
-                i.toDict() for i in self._entitlements 
-            ] if self._entitlements else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptions:
+            result["subscriptions"] = [
+                i.toDict() for i in self._subscriptions 
+            ] if self._subscriptions else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._entitlements is not None):
-            for obj in self._entitlements:
+        if (self._subscriptions is not None):
+            for obj in self._subscriptions:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/OrgListResponse.py` & `ngcbpc/data/uis/OrgListResponse.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .RequestStatus import RequestStatus
 from .Organization import Organization
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(Organization))
-str(repr(RequestStatus))
 str(repr(PaginationInfo))
+str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class OrgListResponse(object):
```

## Comparing `ngccli/data/api/OrgOwner.py` & `ngcbpc/data/registry/PaginationInfo.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,136 +14,148 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgOwner(object):
-    """Org owner."""
+class PaginationInfo(object):
+    """object that describes the pagination information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.email = (
+        self.index = (
             None if not fromDict or propDict.get(
-                "email"
+                "index"
             ) is None
-            else propDict["email"])
-        self.fullName = (
+            else propDict["index"])
+        self.nextPage = (
             None if not fromDict or propDict.get(
-                "fullName"
+                "nextPage"
             ) is None
-            else propDict["fullName"])
-        self.lastLoginDate = (
+            else propDict["nextPage"])
+        self.size = (
             None if not fromDict or propDict.get(
-                "lastLoginDate"
+                "size"
             ) is None
-            else propDict["lastLoginDate"])
+            else propDict["size"])
+        self.totalPages = (
+            None if not fromDict or propDict.get(
+                "totalPages"
+            ) is None
+            else propDict["totalPages"])
+        self.totalResults = (
+            None if not fromDict or propDict.get(
+                "totalResults"
+            ) is None
+            else propDict["totalResults"])
 
     @property
-    def email(self):
-        """str: Email address of the org owner."""
-        return self._email
-
-    @email.setter
-    def email(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._email = value
+    def index(self):
+        """int: Page index of results"""
+        return self._index
+
+    @index.setter
+    def index(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._index = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "index" of type "list<int>" set to wrong type'
             )
 
     @property
-    def fullName(self):
-        """str: Org owner name."""
-        return self._fullName
+    def nextPage(self):
+        """str: Serialized pointer to the next results page. Should be used fo
+        r fetching next page. Can be empty"""
+        return self._nextPage
 
-    @fullName.setter
-    def fullName(self, value):
+    @nextPage.setter
+    def nextPage(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fullName = value
+            self._nextPage = value
+        else:
+            raise TypeError(
+                'Property "nextPage" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def size(self):
+        """int: Number of results in page"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._size = value
         else:
             raise TypeError(
-                'Property "fullName" of type "list<str>" set to wrong type'
+                'Property "size" of type "list<int>" set to wrong type'
             )
 
     @property
-    def lastLoginDate(self):
-        """str: Last time the org owner logged in."""
-        return self._lastLoginDate
+    def totalPages(self):
+        """long: Total number of pages available"""
+        return self._totalPages
+
+    @totalPages.setter
+    def totalPages(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalPages = value
+        else:
+            raise TypeError(
+                'Property "totalPages" of type "list<long>" set to wrong type'
+            )
 
-    @lastLoginDate.setter
-    def lastLoginDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._lastLoginDate = value
+    @property
+    def totalResults(self):
+        """long: Total number of results available"""
+        return self._totalResults
+
+    @totalResults.setter
+    def totalResults(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalResults = value
         else:
             raise TypeError(
-                'Property "lastLoginDate" of type "list<str>" set to wrong ty'
+                'Property "totalResults" of type "list<long>" set to wrong ty'
                 'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._email is not None:
-            result["email"] = \
-                self._email
-        if self._fullName is not None:
-            result["fullName"] = \
-                self._fullName
-        if self._lastLoginDate is not None:
-            result["lastLoginDate"] = \
-                self._lastLoginDate
+        if self._index is not None:
+            result["index"] = \
+                self._index
+        if self._nextPage is not None:
+            result["nextPage"] = \
+                self._nextPage
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._totalPages is not None:
+            result["totalPages"] = \
+                self._totalPages
+        if self._totalResults is not None:
+            result["totalResults"] = \
+                self._totalResults
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._email is None:
-            raise ValueError(
-                "OrgOwner.email doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._email is not None
-            and
-            len(self._email) > 128):
-            raise ValueError(
-                "OrgOwner.email: " + str(self._email) + 
-                " doesnt match requirement: maxLength: 128")
-        if (self._email is not None
-            and
-            not re.match(
-                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
-                 self._email)):
-            raise ValueError(
-                "OrgOwner.email: " + str(self._email) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
-                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
-        if self._fullName is None:
-            raise ValueError(
-                "OrgOwner.fullName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._fullName is not None
-            and
-            len(self._fullName) < 1):
-            raise ValueError(
-                "OrgOwner.fullName: " + str(self._fullName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._fullName is not None
-            and
-            len(self._fullName) > 64):
-            raise ValueError(
-                "OrgOwner.fullName: " + str(self._fullName) + 
-                " doesnt match requirement: maxLength: 64")
         return True
```

## Comparing `ngccli/data/api/OrgProfileUpdateRequest.py` & `ngcbpc/data/uis/OrgProfileUpdateRequest.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/OrgResponse.py` & `ngcbpc/data/registry/RepositoryTagsCountResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,55 +7,53 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .Organization import Organization
 
 # Unused import over optimization prevention
-str(repr(Organization))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrgResponse(object):
-    """info about an organizations"""
+class RepositoryTagsCountResponse(object):
+    """Repository tags count response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.organizations = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "organizations"
+                "count"
             ) is None
-            else propDict["organizations"])
+            else propDict["count"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def organizations(self):
-        """Organization: Information about the Organization"""
-        return self._organizations
-
-    @organizations.setter
-    def organizations(self, value):
-        if value is not None and not isinstance(value, Organization):
-            value = Organization(value)
-        if (value is None) or isinstance(value, Organization):
-            self._organizations = value
+    def count(self):
+        """long: Total number of repository tags count by name and namespace
+        """
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._count = value
         else:
             raise TypeError(
-                'Property "organizations" of type "list<Organization>" set to'
-                ' wrong type'
+                'Property "count" of type "list<long>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -69,27 +67,26 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._organizations:
-            result["organizations"] = \
-                self._organizations.toDict() if self._organizations is not None else None
+        if self._count is not None:
+            result["count"] = \
+                self._count
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._organizations is not None): self._organizations.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/OrgUpdateRequest.py` & `ngcbpc/data/uis/OrgUpdateRequest.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,28 +6,28 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ProductEnablement import ProductEnablement
-from .ProductSubscription import ProductSubscription
 from .OrgOwner import OrgOwner
+from .InfinityManagerSettings import InfinityManagerSettings
 from .OrgType import OrgTypeEnum
+from .ProductSubscription import ProductSubscription
+from .ProductEnablement import ProductEnablement
 from .AlternateContact import AlternateContact
-from .InfinityManagerSettings import InfinityManagerSettings
 from .RepoScanSettings import RepoScanSettings
 
 # Unused import over optimization prevention
+str(repr(OrgOwner))
+str(repr(ProductSubscription))
 str(repr(AlternateContact))
 str(repr(ProductEnablement))
 str(repr(RepoScanSettings))
-str(repr(ProductSubscription))
-str(repr(OrgOwner))
 str(repr(OrgTypeEnum))
 str(repr(InfinityManagerSettings))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
@@ -295,15 +295,15 @@
             raise TypeError(
                 'Property "isSeparateInfluxDbUsed" of type "list<bool>" set t'
                 'o wrong type'
             )
 
     @property
     def orgOwner(self):
-        """OrgOwner: Org owner."""
+        """OrgOwner: Org owner"""
         return self._orgOwner
 
     @orgOwner.setter
     def orgOwner(self, value):
         if value is not None and not isinstance(value, OrgOwner):
             value = OrgOwner(value)
         if (value is None) or isinstance(value, OrgOwner):
```

## Comparing `ngccli/data/api/Organization.py` & `ngcbpc/data/model/Asset.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,624 +6,571 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ProductEnablement import ProductEnablement
-from .ProductSubscription import ProductSubscription
-from .OrgOwner import OrgOwner
-from .OrgType import OrgTypeEnum
-from .UsersInfo import UsersInfo
-from .AlternateContact import AlternateContact
-from .InfinityManagerSettings import InfinityManagerSettings
-from .RepoScanSettings import RepoScanSettings
+from .AssetCdnProviderTypeEnum import AssetCdnProviderTypeEnum
+from .AssetStorageTypeEnum import AssetStorageTypeEnum
+from .ArtifactTypeEnum import ArtifactTypeEnum
+from .AssetStatusTypeEnum import AssetStatusTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(AlternateContact))
-str(repr(ProductEnablement))
-str(repr(RepoScanSettings))
-str(repr(ProductSubscription))
-str(repr(OrgOwner))
-str(repr(UsersInfo))
-str(repr(OrgTypeEnum))
-str(repr(InfinityManagerSettings))
+str(repr(AssetStorageTypeEnum))
+str(repr(AssetStatusTypeEnum))
+str(repr(ArtifactAttribute))
+str(repr(ArtifactTypeEnum))
+str(repr(AssetCdnProviderTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Organization(object):
-    """Information about the Organization"""
+class Asset(object):
+    """Asset object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alternateContact = (
+        self.artifactName = (
             None if not fromDict or propDict.get(
-                "alternateContact"
+                "artifactName"
             ) is None
-            else propDict["alternateContact"])
-        self.canAddOn = (
+            else propDict["artifactName"])
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "canAddOn"
+                "artifactType"
             ) is None
-            else propDict["canAddOn"])
-        self.country = (
+            else propDict["artifactType"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "country"
+                "attributes"
             ) is None
-            else propDict["country"])
-        self.description = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.cdnProvider = (
             None if not fromDict or propDict.get(
-                "description"
+                "cdnProvider"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else propDict["cdnProvider"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "createdDate"
             ) is None
-            else propDict["displayName"])
-        self.id = (
+            else propDict["createdDate"])
+        self.fileName = (
             None if not fromDict or propDict.get(
-                "id"
+                "fileName"
             ) is None
-            else propDict["id"])
-        self.idpId = (
+            else propDict["fileName"])
+        self.hostedAt = (
             None if not fromDict or propDict.get(
-                "idpId"
+                "hostedAt"
             ) is None
-            else propDict["idpId"])
-        self.industry = (
+            else propDict["hostedAt"])
+        self.mimeType = (
             None if not fromDict or propDict.get(
-                "industry"
+                "mimeType"
             ) is None
-            else propDict["industry"])
-        self.infinityManagerSettings = (
-            None if not fromDict or propDict.get(
-                "infinityManagerSettings"
-            ) is None
-            else propDict["infinityManagerSettings"])
-        self.isDatasetServiceEnabled = (
-            None if not fromDict or propDict.get(
-                "isDatasetServiceEnabled"
-            ) is None
-            else propDict["isDatasetServiceEnabled"])
-        self.isQuickStartEnabled = (
-            None if not fromDict or propDict.get(
-                "isQuickStartEnabled"
-            ) is None
-            else propDict["isQuickStartEnabled"])
-        self.isSecretsManagerServiceEnabled = (
-            None if not fromDict or propDict.get(
-                "isSecretsManagerServiceEnabled"
-            ) is None
-            else propDict["isSecretsManagerServiceEnabled"])
-        self.isSeparateInfluxDbUsed = (
-            None if not fromDict or propDict.get(
-                "isSeparateInfluxDbUsed"
-            ) is None
-            else propDict["isSeparateInfluxDbUsed"])
+            else propDict["mimeType"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.orgOwner = (
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "orgOwner"
+                "orgName"
             ) is None
-            else propDict["orgOwner"])
-        self.orgOwners = (
+            else propDict["orgName"])
+        self.originUrl = (
             None if not fromDict or propDict.get(
-                "orgOwners"
+                "originUrl"
             ) is None
-            else [ OrgOwner(i)
-            for i in propDict["orgOwners"] ])
-        self.pecSfdcId = (
+            else propDict["originUrl"])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "pecSfdcId"
+                "ownerName"
             ) is None
-            else propDict["pecSfdcId"])
-        self.productEnablements = (
+            else propDict["ownerName"])
+        self.sizeInBytes = (
             None if not fromDict or propDict.get(
-                "productEnablements"
+                "sizeInBytes"
             ) is None
-            else [ ProductEnablement(i)
-            for i in propDict["productEnablements"] ])
-        self.productSubscriptions = (
+            else propDict["sizeInBytes"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "productSubscriptions"
+                "status"
             ) is None
-            else [ ProductSubscription(i)
-            for i in propDict["productSubscriptions"] ])
-        self.repoScanSettings = (
+            else propDict["status"])
+        self.storageProvider = (
             None if not fromDict or propDict.get(
-                "repoScanSettings"
+                "storageProvider"
             ) is None
-            else propDict["repoScanSettings"])
-        self.type = (
+            else propDict["storageProvider"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "type"
+                "teamName"
             ) is None
-            else propDict["type"])
-        self.usersInfo = (
+            else propDict["teamName"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "usersInfo"
+                "updatedDate"
             ) is None
-            else propDict["usersInfo"])
-
-    @property
-    def alternateContact(self):
-        """AlternateContact: Org Owner Alternate Contact"""
-        return self._alternateContact
-
-    @alternateContact.setter
-    def alternateContact(self, value):
-        if value is not None and not isinstance(value, AlternateContact):
-            value = AlternateContact(value)
-        if (value is None) or isinstance(value, AlternateContact):
-            self._alternateContact = value
-        else:
-            raise TypeError(
-                'Property "alternateContact" of type "list<AlternateContact>"'
-                ' set to wrong type'
-            )
-
-    @property
-    def canAddOn(self):
-        """bool: Identifies if the org can be reused."""
-        return self._canAddOn
-
-    @canAddOn.setter
-    def canAddOn(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canAddOn = value
-        else:
-            raise TypeError(
-                'Property "canAddOn" of type "list<bool>" set to wrong type'
-            )
+            else propDict["updatedDate"])
+        self.uploadUrl = (
+            None if not fromDict or propDict.get(
+                "uploadUrl"
+            ) is None
+            else propDict["uploadUrl"])
 
     @property
-    def country(self):
-        """str: ISO country code of the organization."""
-        return self._country
+    def artifactName(self):
+        """str: Artifact name that asset belongs to"""
+        return self._artifactName
 
-    @country.setter
-    def country(self, value):
+    @artifactName.setter
+    def artifactName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._country = value
+            self._artifactName = value
         else:
             raise TypeError(
-                'Property "country" of type "list<str>" set to wrong type'
+                'Property "artifactName" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def description(self):
-        """str: Optional description of the organization."""
-        return self._description
+    def artifactType(self):
+        """ArtifactTypeEnum: Artifact type"""
+        return self._artifactType
 
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Name of the organization that will be shown to users."""
-        return self._displayName
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
 
-    @displayName.setter
-    def displayName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Unique Id of this team."""
-        return self._id
+    def cdnProvider(self):
+        """AssetCdnProviderTypeEnum: Asset content delivery network provider t
+        ype"""
+        return self._cdnProvider
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @cdnProvider.setter
+    def cdnProvider(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._cdnProvider = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "cdnProvider" of type "list<AssetCdnProviderTypeEnu'
+                'm>" set to wrong type'
             )
 
     @property
-    def idpId(self):
-        """str: Identity Provider ID."""
-        return self._idpId
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @idpId.setter
-    def idpId(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._idpId = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "idpId" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def industry(self):
-        """str: Industry of the organization."""
-        return self._industry
+    def fileName(self):
+        """str: Asset file name"""
+        return self._fileName
 
-    @industry.setter
-    def industry(self, value):
+    @fileName.setter
+    def fileName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._industry = value
-        else:
-            raise TypeError(
-                'Property "industry" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def infinityManagerSettings(self):
-        """InfinityManagerSettings: Infinity manager setting definition"""
-        return self._infinityManagerSettings
-
-    @infinityManagerSettings.setter
-    def infinityManagerSettings(self, value):
-        if value is not None and not isinstance(value, InfinityManagerSettings):
-            value = InfinityManagerSettings(value)
-        if (value is None) or isinstance(value, InfinityManagerSettings):
-            self._infinityManagerSettings = value
-        else:
-            raise TypeError(
-                'Property "infinityManagerSettings" of type "list<InfinityMan'
-                'agerSettings>" set to wrong type'
-            )
-
-    @property
-    def isDatasetServiceEnabled(self):
-        """bool: Dataset Service enable flag for an organization"""
-        return self._isDatasetServiceEnabled
-
-    @isDatasetServiceEnabled.setter
-    def isDatasetServiceEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDatasetServiceEnabled = value
-        else:
-            raise TypeError(
-                'Property "isDatasetServiceEnabled" of type "list<bool>" set '
-                'to wrong type'
-            )
-
-    @property
-    def isQuickStartEnabled(self):
-        """bool: Quick Start enable flag for an organization"""
-        return self._isQuickStartEnabled
-
-    @isQuickStartEnabled.setter
-    def isQuickStartEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isQuickStartEnabled = value
+            self._fileName = value
         else:
             raise TypeError(
-                'Property "isQuickStartEnabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "fileName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isSecretsManagerServiceEnabled(self):
-        """bool: Secrets Manager Service enable flag for an organization"""
-        return self._isSecretsManagerServiceEnabled
+    def hostedAt(self):
+        """list: URLs where the asset is hosted"""
+        return self._hostedAt
 
-    @isSecretsManagerServiceEnabled.setter
-    def isSecretsManagerServiceEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isSecretsManagerServiceEnabled = value
+    @hostedAt.setter
+    def hostedAt(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._hostedAt = value
         else:
             raise TypeError(
-                'Property "isSecretsManagerServiceEnabled" of type "list<bool'
-                '>" set to wrong type'
+                'Property "hostedAt" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isSeparateInfluxDbUsed(self):
-        """bool: If a separate influx db used for an organization in BCP for j
-        ob telemetry"""
-        return self._isSeparateInfluxDbUsed
+    def mimeType(self):
+        """str: Asset mime type"""
+        return self._mimeType
 
-    @isSeparateInfluxDbUsed.setter
-    def isSeparateInfluxDbUsed(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isSeparateInfluxDbUsed = value
+    @mimeType.setter
+    def mimeType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._mimeType = value
         else:
             raise TypeError(
-                'Property "isSeparateInfluxDbUsed" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "mimeType" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Organization name."""
+        """str: Unique name of the asset"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgOwner(self):
-        """OrgOwner: Org owner."""
-        return self._orgOwner
+    def orgName(self):
+        """str: Name of the org that the collection belongs to"""
+        return self._orgName
 
-    @orgOwner.setter
-    def orgOwner(self, value):
-        if value is not None and not isinstance(value, OrgOwner):
-            value = OrgOwner(value)
-        if (value is None) or isinstance(value, OrgOwner):
-            self._orgOwner = value
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "orgOwner" of type "list<OrgOwner>" set to wrong ty'
-                'pe'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgOwners(self):
-        """list: Org owners"""
-        return self._orgOwners
+    def originUrl(self):
+        """str: Asset origin URL"""
+        return self._originUrl
 
-    @orgOwners.setter
-    def orgOwners(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._orgOwners = value
+    @originUrl.setter
+    def originUrl(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._originUrl = value
         else:
             raise TypeError(
-                'Property "orgOwners" of type "list<OrgOwner>" set to wrong t'
-                'ype'
+                'Property "originUrl" of type "list<str>" set to wrong type'
             )
 
     @property
-    def pecSfdcId(self):
-        """str: Product end customer salesforce.com Id (external customer Id).
-         pecSfdcId is for EMS (entitlement management service) to trac
-        k external paid customer."""
-        return self._pecSfdcId
+    def ownerName(self):
+        """str: Name of the user who owns this version"""
+        return self._ownerName
 
-    @pecSfdcId.setter
-    def pecSfdcId(self, value):
+    @ownerName.setter
+    def ownerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._pecSfdcId = value
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "pecSfdcId" of type "list<str>" set to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productEnablements(self):
-        """ """
-        return self._productEnablements
+    def sizeInBytes(self):
+        """long: Size in bytes"""
+        return self._sizeInBytes
 
-    @productEnablements.setter
-    def productEnablements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productEnablements = value
+    @sizeInBytes.setter
+    def sizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._sizeInBytes = value
         else:
             raise TypeError(
-                'Property "productEnablements" of type "list<ProductEnablemen'
-                't>" set to wrong type'
+                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
+                'e'
             )
 
     @property
-    def productSubscriptions(self):
-        """ """
-        return self._productSubscriptions
+    def status(self):
+        """AssetStatusTypeEnum: Asset status type"""
+        return self._status
 
-    @productSubscriptions.setter
-    def productSubscriptions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productSubscriptions = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "productSubscriptions" of type "list<ProductSubscri'
-                'ption>" set to wrong type'
+                'Property "status" of type "list<AssetStatusTypeEnum>" set to'
+                ' wrong type'
             )
 
     @property
-    def repoScanSettings(self):
-        """RepoScanSettings: Repo scan setting definition"""
-        return self._repoScanSettings
+    def storageProvider(self):
+        """AssetStorageTypeEnum: Asset storage provider type"""
+        return self._storageProvider
 
-    @repoScanSettings.setter
-    def repoScanSettings(self, value):
-        if value is not None and not isinstance(value, RepoScanSettings):
-            value = RepoScanSettings(value)
-        if (value is None) or isinstance(value, RepoScanSettings):
-            self._repoScanSettings = value
+    @storageProvider.setter
+    def storageProvider(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._storageProvider = value
         else:
             raise TypeError(
-                'Property "repoScanSettings" of type "list<RepoScanSettings>"'
-                ' set to wrong type'
+                'Property "storageProvider" of type "list<AssetStorageTypeEnu'
+                'm>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def teamName(self):
+        """str: Name of the team that the collection belongs to"""
+        return self._teamName
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @teamName.setter
+    def teamName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "type" of type "list<OrgTypeEnum>" set to wrong typ'
-                'e'
+                'Property "teamName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
+        else:
+            raise TypeError(
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def usersInfo(self):
-        """UsersInfo: Users information."""
-        return self._usersInfo
-
-    @usersInfo.setter
-    def usersInfo(self, value):
-        if value is not None and not isinstance(value, UsersInfo):
-            value = UsersInfo(value)
-        if (value is None) or isinstance(value, UsersInfo):
-            self._usersInfo = value
+    def uploadUrl(self):
+        """str: Asset upload URL"""
+        return self._uploadUrl
+
+    @uploadUrl.setter
+    def uploadUrl(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uploadUrl = value
         else:
             raise TypeError(
-                'Property "usersInfo" of type "list<UsersInfo>" set to wrong '
-                'type'
+                'Property "uploadUrl" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._alternateContact:
-            result["alternateContact"] = \
-                self._alternateContact.toDict() if self._alternateContact is not None else None
-        if self._canAddOn is not None:
-            result["canAddOn"] = \
-                self._canAddOn
-        if self._country is not None:
-            result["country"] = \
-                self._country
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._idpId is not None:
-            result["idpId"] = \
-                self._idpId
-        if self._industry is not None:
-            result["industry"] = \
-                self._industry
-        if self._infinityManagerSettings:
-            result["infinityManagerSettings"] = \
-                self._infinityManagerSettings.toDict() if self._infinityManagerSettings is not None else None
-        if self._isDatasetServiceEnabled is not None:
-            result["isDatasetServiceEnabled"] = \
-                self._isDatasetServiceEnabled
-        if self._isQuickStartEnabled is not None:
-            result["isQuickStartEnabled"] = \
-                self._isQuickStartEnabled
-        if self._isSecretsManagerServiceEnabled is not None:
-            result["isSecretsManagerServiceEnabled"] = \
-                self._isSecretsManagerServiceEnabled
-        if self._isSeparateInfluxDbUsed is not None:
-            result["isSeparateInfluxDbUsed"] = \
-                self._isSeparateInfluxDbUsed
+        if self._artifactName is not None:
+            result["artifactName"] = \
+                self._artifactName
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._cdnProvider is not None:
+            result["cdnProvider"] = \
+                self._cdnProvider
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._fileName is not None:
+            result["fileName"] = \
+                self._fileName
+        if self._hostedAt is not None:
+            result["hostedAt"] = \
+                self._hostedAt
+        if self._mimeType is not None:
+            result["mimeType"] = \
+                self._mimeType
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._orgOwner:
-            result["orgOwner"] = \
-                self._orgOwner.toDict() if self._orgOwner is not None else None
-        if self._orgOwners:
-            result["orgOwners"] = [
-                i.toDict() for i in self._orgOwners 
-            ] if self._orgOwners else []
-        if self._pecSfdcId is not None:
-            result["pecSfdcId"] = \
-                self._pecSfdcId
-        if self._productEnablements:
-            result["productEnablements"] = [
-                i.toDict() for i in self._productEnablements 
-            ] if self._productEnablements else []
-        if self._productSubscriptions:
-            result["productSubscriptions"] = [
-                i.toDict() for i in self._productSubscriptions 
-            ] if self._productSubscriptions else []
-        if self._repoScanSettings:
-            result["repoScanSettings"] = \
-                self._repoScanSettings.toDict() if self._repoScanSettings is not None else None
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._usersInfo:
-            result["usersInfo"] = \
-                self._usersInfo.toDict() if self._usersInfo is not None else None
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._originUrl is not None:
+            result["originUrl"] = \
+                self._originUrl
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._sizeInBytes is not None:
+            result["sizeInBytes"] = \
+                self._sizeInBytes
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._storageProvider is not None:
+            result["storageProvider"] = \
+                self._storageProvider
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
+        if self._uploadUrl is not None:
+            result["uploadUrl"] = \
+                self._uploadUrl
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._displayName is not None
+        if self._artifactType is None:
+            raise ValueError(
+                "Asset.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._artifactName is None:
+            raise ValueError(
+                "Asset.artifactName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
+            raise ValueError(
+                "Asset.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
             and
-            len(self._displayName) < 1):
+            len(self._name) > 255):
+            raise ValueError(
+                "Asset.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._status is None:
+            raise ValueError(
+                "Asset.status doesnt match requirement:" 
+                "required: True"
+            )
+        if self._fileName is None:
             raise ValueError(
-                "Organization.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._displayName is not None
+                "Asset.fileName doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._fileName is not None
             and
-            len(self._displayName) > 255):
+            len(self._fileName) > 255):
             raise ValueError(
-                "Organization.displayName: " + str(self._displayName) + 
+                "Asset.fileName: " + str(self._fileName) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._repoScanSettings is not None): self._repoScanSettings.isValid()
-        if (self._infinityManagerSettings is not None): self._infinityManagerSettings.isValid()
-        if (self._orgOwner is not None): self._orgOwner.isValid()
-        if (self._orgOwners is not None):
-            for obj in self._orgOwners:
-                if (obj is not None): obj.isValid()
-        if (self._productSubscriptions is not None):
-            for obj in self._productSubscriptions:
-                if (obj is not None): obj.isValid()
-        if (self._productEnablements is not None):
-            for obj in self._productEnablements:
+        if (self._originUrl is not None
+            and
+            len(self._originUrl) > 2000):
+            raise ValueError(
+                "Asset.originUrl: " + str(self._originUrl) + 
+                " doesnt match requirement: maxLength: 2000")
+        if (self._originUrl is not None
+            and
+            not re.match(
+                r"^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0"
+                "-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"
+                "+$",
+                 self._originUrl)):
+            raise ValueError(
+                "Asset.originUrl: " + str(self._originUrl) + 
+                " doesnt match requirement: pattern: ^https?:\/\/(www\.)?[-a-"
+                "zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,"
+                "6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)+$")
+        if (self._uploadUrl is not None
+            and
+            not re.match(
+                r"^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0"
+                "-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"
+                "+$",
+                 self._uploadUrl)):
+            raise ValueError(
+                "Asset.uploadUrl: " + str(self._uploadUrl) + 
+                " doesnt match requirement: pattern: ^https?:\/\/(www\.)?[-a-"
+                "zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,"
+                "6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)+$")
+        if self._orgName is None:
+            raise ValueError(
+                "Asset.orgName doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
+            raise ValueError(
+                "Asset.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
+            raise ValueError(
+                "Asset.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._attributes is not None):
+            for obj in self._attributes:
                 if (obj is not None): obj.isValid()
-        if (self._alternateContact is not None): self._alternateContact.isValid()
-        if (self._usersInfo is not None): self._usersInfo.isValid()
         return True
```

## Comparing `ngccli/data/api/OrganizationEntitlement.py` & `ngcbpc/data/uis/UserCreatedEvent.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,90 +6,83 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Entitlement import Entitlement
 
 # Unused import over optimization prevention
-str(repr(Entitlement))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class OrganizationEntitlement(object):
-    """Information about the organization entitlements"""
+class UserCreatedEvent(object):
+    """This event in the queue means an user should be created/updated in thir
+    d party CRM"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.entitlements = (
-            None if not fromDict or propDict.get(
-                "entitlements"
-            ) is None
-            else [ Entitlement(i)
-            for i in propDict["entitlements"] ])
         self.orgName = (
             None if not fromDict or propDict.get(
                 "orgName"
             ) is None
             else propDict["orgName"])
-
-    @property
-    def entitlements(self):
-        """ """
-        return self._entitlements
-
-    @entitlements.setter
-    def entitlements(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._entitlements = value
-        else:
-            raise TypeError(
-                'Property "entitlements" of type "list<Entitlement>" set to w'
-                'rong type'
-            )
+        self.userId = (
+            None if not fromDict or propDict.get(
+                "userId"
+            ) is None
+            else propDict["userId"])
 
     @property
     def orgName(self):
-        """str: Organization name"""
+        """str: org name that the user should belong to"""
         return self._orgName
 
     @orgName.setter
     def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._orgName = value
         else:
             raise TypeError(
                 'Property "orgName" of type "list<str>" set to wrong type'
             )
 
+    @property
+    def userId(self):
+        """long: Unique identifier of the user."""
+        return self._userId
+
+    @userId.setter
+    def userId(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._userId = value
+        else:
+            raise TypeError(
+                'Property "userId" of type "list<long>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._entitlements:
-            result["entitlements"] = [
-                i.toDict() for i in self._entitlements 
-            ] if self._entitlements else []
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
+        if self._userId is not None:
+            result["userId"] = \
+                self._userId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._entitlements is not None):
-            for obj in self._entitlements:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/PackageVersion.py` & `ngcbpc/data/model/ArtifactVersionUpdateRequest.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,130 +6,121 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .VersionStatusEnum import VersionStatusEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
+str(repr(ArtifactAttribute))
+str(repr(VersionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PackageVersion(object):
-    """Latest version information for a specific package"""
+class ArtifactVersionUpdateRequest(object):
+    """Request to create a new artifact version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.createdAt = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "createdAt"
+                "attributes"
             ) is None
-            else propDict["createdAt"])
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.name = (
+        self.status = (
             None if not fromDict or propDict.get(
-                "name"
+                "status"
             ) is None
-            else propDict["name"])
-        self.version = (
-            None if not fromDict or propDict.get(
-                "version"
-            ) is None
-            else propDict["version"])
+            else propDict["status"])
 
     @property
-    def createdAt(self):
-        """str: The creation date of the version"""
-        return self._createdAt
-
-    @createdAt.setter
-    def createdAt(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdAt = value
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "createdAt" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
     def description(self):
-        """str: Human readable description of the package"""
+        """str: Description of the artifact version"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: The name of the package"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
-        else:
-            raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def version(self):
-        """str: The version number"""
-        return self._version
-
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
+    def status(self):
+        """VersionStatusEnum: Version status"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
     def toDict(self):
         result = {}
-        if self._createdAt is not None:
-            result["createdAt"] = \
-                self._createdAt
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._description is not None
+            and
+            len(self._description) > 255):
+            raise ValueError(
+                "ArtifactVersionUpdateRequest.description: " + str(self._description) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/PackageVersionListResponse.py` & `organization/data/sms/SecretSuccessResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,94 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PackageVersion import PackageVersion
-from .RequestStatus import RequestStatus
+from .SecretRequestStatus import SecretRequestStatus
 
 # Unused import over optimization prevention
-str(repr(PackageVersion))
-str(repr(RequestStatus))
+str(repr(SecretRequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PackageVersionListResponse(object):
-    """an array of versions"""
+class SecretSuccessResponse(object):
+    """Secret Success Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.versions = (
+        self.version = (
             None if not fromDict or propDict.get(
-                "versions"
+                "version"
             ) is None
-            else [ PackageVersion(i)
-            for i in propDict["versions"] ])
+            else propDict["version"])
 
     @property
     def requestStatus(self):
-        """ """
+        """SecretRequestStatus: Secret Request status"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
+        if value is not None and not isinstance(value, SecretRequestStatus):
+            value = SecretRequestStatus(value)
+        if (value is None) or isinstance(value, SecretRequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "requestStatus" of type "list<SecretRequestStatus>"'
+                ' set to wrong type'
             )
 
     @property
-    def versions(self):
-        """ """
-        return self._versions
-
-    @versions.setter
-    def versions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._versions = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "versions" of type "list<PackageVersion>" set to wr'
-                'ong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._versions:
-            result["versions"] = [
-                i.toDict() for i in self._versions 
-            ] if self._versions else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._versions is not None):
-            for obj in self._versions:
-                if (obj is not None): obj.isValid()
+        if self._version is None:
+            raise ValueError(
+                "SecretSuccessResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._requestStatus is None:
+            raise ValueError(
+                "SecretSuccessResponse.requestStatus doesnt match requirement:" 
+                "required: True"
+            )
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/PaginationInfo.py` & `ngcbpc/data/uis/PaginationInfo.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/PasswordChangeRequest.py` & `ngcbpc/data/model/CollectionOperation.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,101 +14,95 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PasswordChangeRequest(object):
+class CollectionOperation(object):
+    """Collection operation object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.email = (
+        self.operation = (
             None if not fromDict or propDict.get(
-                "email"
+                "operation"
             ) is None
-            else propDict["email"])
-        self.password = (
+            else propDict["operation"])
+        self.path = (
             None if not fromDict or propDict.get(
-                "password"
+                "path"
             ) is None
-            else propDict["password"])
+            else propDict["path"])
 
     @property
-    def email(self):
-        """ """
-        return self._email
+    def operation(self):
+        """str: Collection operation"""
+        return self._operation
 
-    @email.setter
-    def email(self, value):
+    @operation.setter
+    def operation(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._email = value
+            self._operation = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "operation" of type "list<str>" set to wrong type'
             )
 
     @property
-    def password(self):
-        """ """
-        return self._password
+    def path(self):
+        """str: Path to a collection item in a scoped format"""
+        return self._path
 
-    @password.setter
-    def password(self, value):
+    @path.setter
+    def path(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._password = value
+            self._path = value
         else:
             raise TypeError(
-                'Property "password" of type "list<str>" set to wrong type'
+                'Property "path" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._email is not None:
-            result["email"] = \
-                self._email
-        if self._password is not None:
-            result["password"] = \
-                self._password
+        if self._operation is not None:
+            result["operation"] = \
+                self._operation
+        if self._path is not None:
+            result["path"] = \
+                self._path
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._password is None:
-            raise ValueError(
-                "PasswordChangeRequest.password doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._password is not None
+        if (self._operation is not None
             and
-            len(self._password) < 9):
+            len(self._operation) > 255):
             raise ValueError(
-                "PasswordChangeRequest.password: " + str(self._password) + 
-                " doesnt match requirement: minLength: 9")
-        if (self._password is not None
+                "CollectionOperation.operation: " + str(self._operation) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._path is not None
             and
-            len(self._password) > 64):
+            len(self._path) > 255):
             raise ValueError(
-                "PasswordChangeRequest.password: " + str(self._password) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._password is not None
+                "CollectionOperation.path: " + str(self._path) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._path is not None
             and
             not re.match(
-                r"^(?=.*[\p{Nd}])(?=.*[\p{Ll}])(?=.*[\p{Lu}\p{Lt}])(?=.*[~!@#"
-                "$%^&*_\-+=`|\\(){}\[\]:;\\\"'<>,.?/]).*$",
-                 self._password)):
+                r"^(/(?!/)([\w- %\.(?!\.)])+)+$",
+                 self._path)):
             raise ValueError(
-                "PasswordChangeRequest.password: " + str(self._password) + 
-                " doesnt match requirement: pattern: ^(?=.*[\p{Nd}])(?=.*[\p{"
-                "Ll}])(?=.*[\p{Lu}\p{Lt}])(?=.*[~!@#$%^&*_\-"
-                "+=`|\\(){}\[\]:;\\\"'<>,.?/]).*$")
+                "CollectionOperation.path: " + str(self._path) + 
+                " doesnt match requirement: pattern: ^(/(?!/)([\w- %\.(?!\.)]"
+                ")+)+$")
         return True
```

## Comparing `ngccli/data/api/PoolMeasurementQueryRequest.py` & `ngcbpc/data/registry/Envelope.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,66 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PoolMeasurementQueryParams import PoolMeasurementQueryParams
+from .RegistryEvent import RegistryEvent
 
 # Unused import over optimization prevention
-str(repr(PoolMeasurementQueryParams))
+str(repr(RegistryEvent))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PoolMeasurementQueryRequest(object):
-    """request params for getting pool measurements"""
+class Envelope(object):
+    """Envelope filled with 1+ registry events"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.measurements = (
+        self.events = (
             None if not fromDict or propDict.get(
-                "measurements"
+                "events"
             ) is None
-            else [ PoolMeasurementQueryParams(i)
-            for i in propDict["measurements"] ])
+            else [ RegistryEvent(i)
+            for i in propDict["events"] ])
 
     @property
-    def measurements(self):
-        """ """
-        return self._measurements
+    def events(self):
+        """list: list of events received from the registry"""
+        return self._events
 
-    @measurements.setter
-    def measurements(self, value):
+    @events.setter
+    def events(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._measurements = value
+            self._events = value
         else:
             raise TypeError(
-                'Property "measurements" of type "list<PoolMeasurementQueryPa'
-                'rams>" set to wrong type'
+                'Property "events" of type "list<RegistryEvent>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._measurements:
-            result["measurements"] = [
-                i.toDict() for i in self._measurements 
-            ] if self._measurements else []
+        if self._events:
+            result["events"] = [
+                i.toDict() for i in self._events 
+            ] if self._events else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._measurements is not None):
-            for obj in self._measurements:
+        if (self._events is not None):
+            for obj in self._events:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/PostStorageProvision.py` & `ngcbpc/data/model/PaginationInfo.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,140 +6,156 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BatchResourceTypeEnum import BatchResourceTypeEnum
 
 # Unused import over optimization prevention
-str(repr(BatchResourceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PostStorageProvision(object):
-    """Event to CAS once FSS provisions storage account"""
+class PaginationInfo(object):
+    """Pagination Information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.key = (
+        self.index = (
             None if not fromDict or propDict.get(
-                "key"
+                "index"
             ) is None
-            else propDict["key"])
-        self.resourceId = (
+            else propDict["index"])
+        self.nextPage = (
             None if not fromDict or propDict.get(
-                "resourceId"
+                "nextPage"
             ) is None
-            else propDict["resourceId"])
-        self.resourceType = (
+            else propDict["nextPage"])
+        self.size = (
             None if not fromDict or propDict.get(
-                "resourceType"
+                "size"
             ) is None
-            else propDict["resourceType"])
-        self.storageClientId = (
+            else propDict["size"])
+        self.totalPages = (
             None if not fromDict or propDict.get(
-                "storageClientId"
+                "totalPages"
             ) is None
-            else propDict["storageClientId"])
+            else propDict["totalPages"])
+        self.totalResults = (
+            None if not fromDict or propDict.get(
+                "totalResults"
+            ) is None
+            else propDict["totalResults"])
 
     @property
-    def key(self):
-        """str: Some storage like Ceph requires secret key to mount. This will
-         be the mount key for this storage account"""
-        return self._key
-
-    @key.setter
-    def key(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._key = value
+    def index(self):
+        """int: Page index of results"""
+        return self._index
+
+    @index.setter
+    def index(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._index = value
         else:
             raise TypeError(
-                'Property "key" of type "list<str>" set to wrong type'
+                'Property "index" of type "list<int>" set to wrong type'
             )
 
     @property
-    def resourceId(self):
-        """str: The resource id that initiated this storage acc provisioning
-        """
-        return self._resourceId
+    def nextPage(self):
+        """str: Serialized pointer to the next results page. Should be used fo
+        r fetching next page. Can be empty"""
+        return self._nextPage
 
-    @resourceId.setter
-    def resourceId(self, value):
+    @nextPage.setter
+    def nextPage(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resourceId = value
+            self._nextPage = value
         else:
             raise TypeError(
-                'Property "resourceId" of type "list<str>" set to wrong type'
+                'Property "nextPage" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resourceType(self):
-        """BatchResourceTypeEnum: All possible storage resource for batch serv
-        ice"""
-        return self._resourceType
-
-    @resourceType.setter
-    def resourceType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._resourceType = value
+    def size(self):
+        """int: Number of results in page"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._size = value
         else:
             raise TypeError(
-                'Property "resourceType" of type "list<BatchResourceTypeEnum>'
-                '" set to wrong type'
+                'Property "size" of type "list<int>" set to wrong type'
             )
 
     @property
-    def storageClientId(self):
-        """str: The storage client id. Also the user mount"""
-        return self._storageClientId
+    def totalPages(self):
+        """long: Total number of pages available"""
+        return self._totalPages
+
+    @totalPages.setter
+    def totalPages(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalPages = value
+        else:
+            raise TypeError(
+                'Property "totalPages" of type "list<long>" set to wrong type'
+            )
 
-    @storageClientId.setter
-    def storageClientId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._storageClientId = value
+    @property
+    def totalResults(self):
+        """long: Total number of results available"""
+        return self._totalResults
+
+    @totalResults.setter
+    def totalResults(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalResults = value
         else:
             raise TypeError(
-                'Property "storageClientId" of type "list<str>" set to wrong '
-                'type'
+                'Property "totalResults" of type "list<long>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._key is not None:
-            result["key"] = \
-                self._key
-        if self._resourceId is not None:
-            result["resourceId"] = \
-                self._resourceId
-        if self._resourceType is not None:
-            result["resourceType"] = \
-                self._resourceType
-        if self._storageClientId is not None:
-            result["storageClientId"] = \
-                self._storageClientId
+        if self._index is not None:
+            result["index"] = \
+                self._index
+        if self._nextPage is not None:
+            result["nextPage"] = \
+                self._nextPage
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._totalPages is not None:
+            result["totalPages"] = \
+                self._totalPages
+        if self._totalResults is not None:
+            result["totalResults"] = \
+                self._totalResults
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._storageClientId is None:
-            raise ValueError(
-                "PostStorageProvision.storageClientId doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/Price.py` & `ngcbpc/data/registry/Jwk.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,128 +6,149 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CurrencyCode import CurrencyCodeEnum
-from .PriceType import PriceTypeEnum
 
 # Unused import over optimization prevention
-str(repr(CurrencyCodeEnum))
-str(repr(PriceTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Price(object):
-    """Localized price"""
+class Jwk(object):
+    """JSON Web Key"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.amount = (
+        self.crv = (
             None if not fromDict or propDict.get(
-                "amount"
+                "crv"
             ) is None
-            else propDict["amount"])
-        self.currencyCode = (
+            else propDict["crv"])
+        self.kid = (
             None if not fromDict or propDict.get(
-                "currencyCode"
+                "kid"
             ) is None
-            else propDict["currencyCode"])
-        self.currencySymbol = (
+            else propDict["kid"])
+        self.kty = (
             None if not fromDict or propDict.get(
-                "currencySymbol"
+                "kty"
             ) is None
-            else propDict["currencySymbol"])
-        self.priceType = (
+            else propDict["kty"])
+        self.x = (
             None if not fromDict or propDict.get(
-                "priceType"
+                "x"
             ) is None
-            else propDict["priceType"])
+            else propDict["x"])
+        self.y = (
+            None if not fromDict or propDict.get(
+                "y"
+            ) is None
+            else propDict["y"])
 
     @property
-    def amount(self):
-        """float: Price amount"""
-        return self._amount
-
-    @amount.setter
-    def amount(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._amount = value
+    def crv(self):
+        """str: Elliptic Curve Public Key's: 'Curve' Parameter"""
+        return self._crv
+
+    @crv.setter
+    def crv(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._crv = value
         else:
             raise TypeError(
-                'Property "amount" of type "list<float>" set to wrong type'
+                'Property "crv" of type "list<str>" set to wrong type'
             )
 
     @property
-    def currencyCode(self):
-        """CurrencyCodeEnum: Currency code"""
-        return self._currencyCode
-
-    @currencyCode.setter
-    def currencyCode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._currencyCode = value
+    def kid(self):
+        """str: Key id"""
+        return self._kid
+
+    @kid.setter
+    def kid(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._kid = value
         else:
             raise TypeError(
-                'Property "currencyCode" of type "list<CurrencyCodeEnum>" set'
-                ' to wrong type'
+                'Property "kid" of type "list<str>" set to wrong type'
             )
 
     @property
-    def currencySymbol(self):
-        """str: Currency symbol"""
-        return self._currencySymbol
+    def kty(self):
+        """str: Key type"""
+        return self._kty
 
-    @currencySymbol.setter
-    def currencySymbol(self, value):
+    @kty.setter
+    def kty(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._currencySymbol = value
+            self._kty = value
         else:
             raise TypeError(
-                'Property "currencySymbol" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "kty" of type "list<str>" set to wrong type'
             )
 
     @property
-    def priceType(self):
-        """PriceTypeEnum: Price types"""
-        return self._priceType
-
-    @priceType.setter
-    def priceType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._priceType = value
+    def x(self):
+        """str: Elliptic Curve Public Key's: 'X Coordinate' Parameter"""
+        return self._x
+
+    @x.setter
+    def x(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._x = value
+        else:
+            raise TypeError(
+                'Property "x" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def y(self):
+        """str: Elliptic Curve Public Key's: 'Y Coordinate' Parameter"""
+        return self._y
+
+    @y.setter
+    def y(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._y = value
         else:
             raise TypeError(
-                'Property "priceType" of type "list<PriceTypeEnum>" set to wr'
-                'ong type'
+                'Property "y" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._amount is not None:
-            result["amount"] = \
-                self._amount
-        if self._currencyCode is not None:
-            result["currencyCode"] = \
-                self._currencyCode
-        if self._currencySymbol is not None:
-            result["currencySymbol"] = \
-                self._currencySymbol
-        if self._priceType is not None:
-            result["priceType"] = \
-                self._priceType
+        if self._crv is not None:
+            result["crv"] = \
+                self._crv
+        if self._kid is not None:
+            result["kid"] = \
+                self._kid
+        if self._kty is not None:
+            result["kty"] = \
+                self._kty
+        if self._x is not None:
+            result["x"] = \
+                self._x
+        if self._y is not None:
+            result["y"] = \
+                self._y
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/ProductEnablement.py` & `ngcbpc/data/model/ModelFile.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,161 +6,158 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PurchaseOrder import PurchaseOrder
-from .ProductEnablementTypeEnum import ProductEnablementTypeEnum
-from .ProductNameEnum import ProductNameEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNameEnum))
-str(repr(PurchaseOrder))
-str(repr(ProductEnablementTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ProductEnablement(object):
-    """Product Enablement"""
+class ModelFile(object):
+    """Model file object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.expirationDate = (
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "expirationDate"
+                "createdDate"
             ) is None
-            else propDict["expirationDate"])
-        self.poDetails = (
+            else propDict["createdDate"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "poDetails"
+                "description"
             ) is None
-            else [ PurchaseOrder(i)
-            for i in propDict["poDetails"] ])
-        self.productName = (
+            else propDict["description"])
+        self.path = (
             None if not fromDict or propDict.get(
-                "productName"
+                "path"
             ) is None
-            else propDict["productName"])
-        self.type = (
+            else propDict["path"])
+        self.sizeInBytes = (
             None if not fromDict or propDict.get(
-                "type"
+                "sizeInBytes"
             ) is None
-            else propDict["type"])
+            else propDict["sizeInBytes"])
 
     @property
-    def expirationDate(self):
-        """str: Date on which the subscription expires. The subscription is in
-        valid after this date. (yyyy-MM-dd)"""
-        return self._expirationDate
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @expirationDate.setter
-    def expirationDate(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._expirationDate = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "expirationDate" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def poDetails(self):
-        """ """
-        return self._poDetails
-
-    @poDetails.setter
-    def poDetails(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._poDetails = value
+    def description(self):
+        """str: Description of the file"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "poDetails" of type "list<PurchaseOrder>" set to wr'
-                'ong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productName(self):
-        """ProductNameEnum: Product Names (NVAIE, BASE_COMMAND, FleetCommand, 
-        etc)."""
-        return self._productName
-
-    @productName.setter
-    def productName(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._productName = value
+    def path(self):
+        """str: Relative file path from the root of the model"""
+        return self._path
+
+    @path.setter
+    def path(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._path = value
         else:
             raise TypeError(
-                'Property "productName" of type "list<ProductNameEnum>" set t'
-                'o wrong type'
+                'Property "path" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """ProductEnablementTypeEnum: Product Enablement Types"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    def sizeInBytes(self):
+        """long: Size of the file in bytes"""
+        return self._sizeInBytes
+
+    @sizeInBytes.setter
+    def sizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._sizeInBytes = value
         else:
             raise TypeError(
-                'Property "type" of type "list<ProductEnablementTypeEnum>" se'
-                't to wrong type'
+                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._expirationDate is not None:
-            result["expirationDate"] = \
-                self._expirationDate
-        if self._poDetails:
-            result["poDetails"] = [
-                i.toDict() for i in self._poDetails 
-            ] if self._poDetails else []
-        if self._productName is not None:
-            result["productName"] = \
-                self._productName
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._path is not None:
+            result["path"] = \
+                self._path
+        if self._sizeInBytes is not None:
+            result["sizeInBytes"] = \
+                self._sizeInBytes
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._type is None:
+        if (self._path is not None
+            and
+            len(self._path) < 1):
             raise ValueError(
-                "ProductEnablement.type doesnt match requirement:" 
-                "required: True"
-            )
-        if self._productName is None:
+                "ModelFile.path: " + str(self._path) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._path is not None
+            and
+            len(self._path) > 1023):
             raise ValueError(
-                "ProductEnablement.productName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._expirationDate is not None
+                "ModelFile.path: " + str(self._path) + 
+                " doesnt match requirement: maxLength: 1023")
+        if (self._sizeInBytes is not None
+            and
+            self._sizeInBytes < 0):
+            raise ValueError(
+                "ModelFile.sizeInBytes: " + str(self._sizeInBytes) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._createdDate is not None
             and
             not re.match(
-                r"\d{4}-[01]\d-[0-3]\d",
-                 self._expirationDate)):
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "ProductEnablement.expirationDate: " + str(self._expirationDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\d")
-        if (self._poDetails is not None):
-            for obj in self._poDetails:
-                if (obj is not None): obj.isValid()
+                "ModelFile.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/api/ProductSubscription.py` & `ngcbpc/data/uis/ProductSubscription.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,26 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ProductNameEnum import ProductNameEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNameEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ProductSubscription(object):
-    """Product Subscription"""
+    """Product Subsciption"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.emsEntitlementType = (
             None if not fromDict or propDict.get(
                 "emsEntitlementType"
             ) is None
             else propDict["emsEntitlementType"])
@@ -54,15 +52,15 @@
                 "type"
             ) is None
             else propDict["type"])
 
     @property
     def emsEntitlementType(self):
         """EmsEntitlementTypeEnum: EMS Subscription type. (options: EMS_EVAL, 
-        EMS_NFR and EMS_COMMERCIAL)"""
+        EMS_NFR and EMS_COMMERICAL)"""
         return self._emsEntitlementType
 
     @emsEntitlementType.setter
     def emsEntitlementType(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._emsEntitlementType = value
         else:
@@ -106,28 +104,31 @@
         else:
             raise TypeError(
                 'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
     def productName(self):
-        """ProductNameEnum: Product Names (NVAIE, BASE_COMMAND, FleetCommand, 
-        etc)."""
+        """ProductNameEnum: Product Name. (options: NVAIE, BASE_COMMAND, Fleet
+        Command, REGISTRY)"""
         return self._productName
 
     @productName.setter
     def productName(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._productName = value
         else:
             raise TypeError(
                 'Property "productName" of type "list<ProductNameEnum>" set t'
                 'o wrong type'
             )
 
+    ProductNameEnum=["NVAIE","BASE_COMMAND","FleetCommand","REGISTRY","OMNIVERSE","RIVA_ENTEPRISE","TAO_STUDIO","PYM",]
+    str(repr(ProductNameEnum))  # Prevent optimizer removing enum
+
     @property
     def startDate(self):
         """str: Date on which the subscription becomes active. (yyyy-MM-dd)"""
         return self._startDate
 
     @startDate.setter
     def startDate(self, value):
```

## Comparing `ngccli/data/api/PurchaseOrder.py` & `ngcbpc/data/uis/PurchaseOrder.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/Replica.py` & `ngcbpc/data/model/ArtifactVersion.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,324 +6,283 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .JobStatus import JobStatus
+from .VersionStatusEnum import VersionStatusEnum
+from .CustomMetricGroup import CustomMetricGroup
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(JobStatus))
+str(repr(CustomMetricGroup))
+str(repr(ArtifactAttribute))
+str(repr(VersionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Replica(object):
-    """object that describes submitted job"""
+class ArtifactVersion(object):
+    """Artifact version object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "attributes"
             ) is None
-            else propDict["aceId"])
-        self.aceName = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.createdByUser = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "createdByUser"
             ) is None
-            else propDict["aceName"])
-        self.aceResourceInstance = (
-            None if not fromDict or propDict.get(
-                "aceResourceInstance"
-            ) is None
-            else propDict["aceResourceInstance"])
+            else propDict["createdByUser"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.jobId = (
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "jobId"
+                "customMetrics"
             ) is None
-            else propDict["jobId"])
-        self.lastStatusUpdatedDate = (
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "lastStatusUpdatedDate"
+                "description"
             ) is None
-            else propDict["lastStatusUpdatedDate"])
-        self.orgName = (
+            else propDict["description"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "id"
             ) is None
-            else propDict["orgName"])
-        self.replicaId = (
+            else propDict["id"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "replicaId"
+                "status"
             ) is None
-            else propDict["replicaId"])
-        self.replicaStatus = (
+            else propDict["status"])
+        self.totalFileCount = (
             None if not fromDict or propDict.get(
-                "replicaStatus"
+                "totalFileCount"
             ) is None
-            else propDict["replicaStatus"])
-        self.submittedByUser = (
+            else propDict["totalFileCount"])
+        self.totalSizeInBytes = (
             None if not fromDict or propDict.get(
-                "submittedByUser"
+                "totalSizeInBytes"
             ) is None
-            else propDict["submittedByUser"])
-        self.submittedByUserId = (
+            else propDict["totalSizeInBytes"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "submittedByUserId"
+                "updatedDate"
             ) is None
-            else propDict["submittedByUserId"])
-        self.teamName = (
-            None if not fromDict or propDict.get(
-                "teamName"
-            ) is None
-            else propDict["teamName"])
+            else propDict["updatedDate"])
 
     @property
-    def aceId(self):
-        """long: id of ACE that the job belongs to"""
-        return self._aceId
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def aceName(self):
-        """str: name of ACE that the job belongs to"""
-        return self._aceName
+    def createdByUser(self):
+        """str: Id of the user who created this version"""
+        return self._createdByUser
 
-    @aceName.setter
-    def aceName(self, value):
+    @createdByUser.setter
+    def createdByUser(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._createdByUser = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def aceResourceInstance(self):
-        """str: Name of instance of ace resources that the job used"""
-        return self._aceResourceInstance
-
-    @aceResourceInstance.setter
-    def aceResourceInstance(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceResourceInstance = value
-        else:
-            raise TypeError(
-                'Property "aceResourceInstance" of type "list<str>" set to wr'
-                'ong type'
+                'Property "createdByUser" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
     def createdDate(self):
-        """str: Created date for this job"""
+        """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._createdDate = value
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def jobId(self):
-        """long: the id of the job"""
-        return self._jobId
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
 
-    @jobId.setter
-    def jobId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._jobId = value
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
         else:
             raise TypeError(
-                'Property "jobId" of type "list<long>" set to wrong type'
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
             )
 
     @property
-    def lastStatusUpdatedDate(self):
-        """str: Last updated status date"""
-        return self._lastStatusUpdatedDate
+    def description(self):
+        """str: Description of the version"""
+        return self._description
 
-    @lastStatusUpdatedDate.setter
-    def lastStatusUpdatedDate(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastStatusUpdatedDate = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "lastStatusUpdatedDate" of type "list<str>" set to '
-                'wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: name of org that the job belongs to"""
-        return self._orgName
+    def id(self):
+        """str: Unique ID of the version"""
+        return self._id
 
-    @orgName.setter
-    def orgName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def replicaId(self):
-        """long: the id of the replica"""
-        return self._replicaId
-
-    @replicaId.setter
-    def replicaId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._replicaId = value
-        else:
-            raise TypeError(
-                'Property "replicaId" of type "list<long>" set to wrong type'
-            )
+    def status(self):
+        """VersionStatusEnum: Version status"""
+        return self._status
 
-    @property
-    def replicaStatus(self):
-        """JobStatus: updates about job status are coming from the nodes"""
-        return self._replicaStatus
-
-    @replicaStatus.setter
-    def replicaStatus(self, value):
-        if value is not None and not isinstance(value, JobStatus):
-            value = JobStatus(value)
-        if (value is None) or isinstance(value, JobStatus):
-            self._replicaStatus = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "replicaStatus" of type "list<JobStatus>" set to wr'
-                'ong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
     @property
-    def submittedByUser(self):
-        """str: user that submitted this job"""
-        return self._submittedByUser
+    def totalFileCount(self):
+        """long: Total file count"""
+        return self._totalFileCount
 
-    @submittedByUser.setter
-    def submittedByUser(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._submittedByUser = value
+    @totalFileCount.setter
+    def totalFileCount(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalFileCount = value
         else:
             raise TypeError(
-                'Property "submittedByUser" of type "list<str>" set to wrong '
+                'Property "totalFileCount" of type "list<long>" set to wrong '
                 'type'
             )
 
     @property
-    def submittedByUserId(self):
-        """long: User id of the user that submitted this job"""
-        return self._submittedByUserId
+    def totalSizeInBytes(self):
+        """long: Total size of the version in bytes"""
+        return self._totalSizeInBytes
 
-    @submittedByUserId.setter
-    def submittedByUserId(self, value):
+    @totalSizeInBytes.setter
+    def totalSizeInBytes(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._submittedByUserId = value
+            self._totalSizeInBytes = value
         else:
             raise TypeError(
-                'Property "submittedByUserId" of type "list<long>" set to wro'
-                'ng type'
+                'Property "totalSizeInBytes" of type "list<long>" set to wron'
+                'g type'
             )
 
     @property
-    def teamName(self):
-        """str: name of team that the job belongs to"""
-        return self._teamName
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
 
-    @teamName.setter
-    def teamName(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._aceResourceInstance is not None:
-            result["aceResourceInstance"] = \
-                self._aceResourceInstance
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._createdByUser is not None:
+            result["createdByUser"] = \
+                self._createdByUser
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._jobId is not None:
-            result["jobId"] = \
-                self._jobId
-        if self._lastStatusUpdatedDate is not None:
-            result["lastStatusUpdatedDate"] = \
-                self._lastStatusUpdatedDate
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._replicaId is not None:
-            result["replicaId"] = \
-                self._replicaId
-        if self._replicaStatus:
-            result["replicaStatus"] = \
-                self._replicaStatus.toDict() if self._replicaStatus is not None else None
-        if self._submittedByUser is not None:
-            result["submittedByUser"] = \
-                self._submittedByUser
-        if self._submittedByUserId is not None:
-            result["submittedByUserId"] = \
-                self._submittedByUserId
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._totalFileCount is not None:
+            result["totalFileCount"] = \
+                self._totalFileCount
+        if self._totalSizeInBytes is not None:
+            result["totalSizeInBytes"] = \
+                self._totalSizeInBytes
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
@@ -331,23 +290,28 @@
     def isValid(self):
         if (self._createdDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._createdDate)):
             raise ValueError(
-                "Replica.createdDate: " + str(self._createdDate) + 
+                "ArtifactVersion.createdDate: " + str(self._createdDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._lastStatusUpdatedDate is not None
+        if (self._updatedDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._lastStatusUpdatedDate)):
+                 self._updatedDate)):
             raise ValueError(
-                "Replica.lastStatusUpdatedDate: " + str(self._lastStatusUpdatedDate) + 
+                "ArtifactVersion.updatedDate: " + str(self._updatedDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._replicaStatus is not None): self._replicaStatus.isValid()
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/ReplicaListResponse.py` & `ngcbpc/data/model/ArtifactListResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,52 +6,69 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .Replica import Replica
 from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
+from .Artifact import Artifact
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Replica))
 str(repr(PaginationInfo))
+str(repr(Artifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ReplicaListResponse(object):
-    """listing of all task for a particular job"""
+class ArtifactListResponse(object):
+    """Response to list artifacts request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.artifacts = (
+            None if not fromDict or propDict.get(
+                "artifacts"
+            ) is None
+            else [ Artifact(i)
+            for i in propDict["artifacts"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
-        self.replicas = (
-            None if not fromDict or propDict.get(
-                "replicas"
-            ) is None
-            else [ Replica(i)
-            for i in propDict["replicas"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
+    def artifacts(self):
+        """ """
+        return self._artifacts
+
+    @artifacts.setter
+    def artifacts(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._artifacts = value
+        else:
+            raise TypeError(
+                'Property "artifacts" of type "list<Artifact>" set to wrong t'
+                'ype'
+            )
+
+    @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -59,33 +76,16 @@
         else:
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
-    def replicas(self):
-        """list: array of object that describes the replicas"""
-        return self._replicas
-
-    @replicas.setter
-    def replicas(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._replicas = value
-        else:
-            raise TypeError(
-                'Property "replicas" of type "list<Replica>" set to wrong typ'
-                'e'
-            )
-
-    @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -94,34 +94,34 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._artifacts:
+            result["artifacts"] = [
+                i.toDict() for i in self._artifacts 
+            ] if self._artifacts else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._replicas:
-            result["replicas"] = [
-                i.toDict() for i in self._replicas 
-            ] if self._replicas else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._replicas is not None):
-            for obj in self._replicas:
+        if (self._artifacts is not None):
+            for obj in self._artifacts:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/ReplicaResponse.py` & `ngcbpc/data/uis/RemovedUserListResponse.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,81 +6,64 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Replica import Replica
-from .JobStatus import JobStatus
+from .PaginationInfo import PaginationInfo
+from .RemovedUser import RemovedUser
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(JobStatus))
-str(repr(Replica))
+str(repr(PaginationInfo))
+str(repr(RemovedUser))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ReplicaResponse(object):
-    """Information about replica for a Job"""
+class RemovedUserListResponse(object):
+    """Response for List Removed Users from an Org"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.replica = (
+        self.paginationInfo = (
             None if not fromDict or propDict.get(
-                "replica"
+                "paginationInfo"
             ) is None
-            else propDict["replica"])
-        self.replicaStatusHistory = (
-            None if not fromDict or propDict.get(
-                "replicaStatusHistory"
-            ) is None
-            else [ JobStatus(i)
-            for i in propDict["replicaStatusHistory"] ])
+            else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.users = (
+            None if not fromDict or propDict.get(
+                "users"
+            ) is None
+            else [ RemovedUser(i)
+            for i in propDict["users"] ])
 
     @property
-    def replica(self):
-        """Replica: object that describes submitted job"""
-        return self._replica
-
-    @replica.setter
-    def replica(self, value):
-        if value is not None and not isinstance(value, Replica):
-            value = Replica(value)
-        if (value is None) or isinstance(value, Replica):
-            self._replica = value
-        else:
-            raise TypeError(
-                'Property "replica" of type "list<Replica>" set to wrong type'
-            )
-
-    @property
-    def replicaStatusHistory(self):
-        """list: history of replica status, sorted by most recent status first
-        """
-        return self._replicaStatusHistory
-
-    @replicaStatusHistory.setter
-    def replicaStatusHistory(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._replicaStatusHistory = value
+    def paginationInfo(self):
+        """PaginationInfo: object that describes the pagination information"""
+        return self._paginationInfo
+
+    @paginationInfo.setter
+    def paginationInfo(self, value):
+        if value is not None and not isinstance(value, PaginationInfo):
+            value = PaginationInfo(value)
+        if (value is None) or isinstance(value, PaginationInfo):
+            self._paginationInfo = value
         else:
             raise TypeError(
-                'Property "replicaStatusHistory" of type "list<JobStatus>" se'
-                't to wrong type'
+                'Property "paginationInfo" of type "list<PaginationInfo>" set'
+                ' to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -92,36 +75,53 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def users(self):
+        """list: information about the user"""
+        return self._users
+
+    @users.setter
+    def users(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._users = value
+        else:
+            raise TypeError(
+                'Property "users" of type "list<RemovedUser>" set to wrong ty'
+                'pe'
+            )
+
     def toDict(self):
         result = {}
-        if self._replica:
-            result["replica"] = \
-                self._replica.toDict() if self._replica is not None else None
-        if self._replicaStatusHistory:
-            result["replicaStatusHistory"] = [
-                i.toDict() for i in self._replicaStatusHistory 
-            ] if self._replicaStatusHistory else []
+        if self._paginationInfo:
+            result["paginationInfo"] = \
+                self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._users:
+            result["users"] = [
+                i.toDict() for i in self._users 
+            ] if self._users else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._replica is not None): self._replica.isValid()
-        if (self._replicaStatusHistory is not None):
-            for obj in self._replicaStatusHistory:
+        if (self._users is not None):
+            for obj in self._users:
                 if (obj is not None): obj.isValid()
+        if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/RepoScanSettings.py` & `ngcbpc/data/uis/RepoScanSettings.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/RepositoryTagVexByDigest.py` & `ngcbpc/data/registry/RepositoryTagVexByDigest.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/RepositoryTagVexDetail.py` & `ngcbpc/data/registry/RepositoryTagVexDetail.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/RequestStatus.py` & `ngcbpc/data/registry/RequestStatus.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/ReservedLabels.py` & `ngcbpc/data/uis/UsersInfo.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,45 +14,45 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ReservedLabels(object):
-    """Reserved labels specified by the user or admin"""
+class UsersInfo(object):
+    """Users information."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.values = (
+        self.totalUsers = (
             None if not fromDict or propDict.get(
-                "values"
+                "totalUsers"
             ) is None
-            else propDict["values"])
+            else propDict["totalUsers"])
 
     @property
-    def values(self):
-        """list: An array of reserved labels that describe this job"""
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._values = value
+    def totalUsers(self):
+        """long: Total number of users."""
+        return self._totalUsers
+
+    @totalUsers.setter
+    def totalUsers(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalUsers = value
         else:
             raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "totalUsers" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._totalUsers is not None:
+            result["totalUsers"] = \
+                self._totalUsers
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/Response.py` & `ngcbpc/data/registry/Response.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/Resultset.py` & `ngcbpc/data/uis/RemovedUser.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,363 +6,349 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageLocation import StorageLocation
-from .ResultsetFile import ResultsetFile
+from .UserStatus import UserStatusEnum
+from .UserGdprStatus import UserGdprStatusEnum
 
 # Unused import over optimization prevention
-str(repr(ResultsetFile))
-str(repr(StorageLocation))
+str(repr(UserStatusEnum))
+str(repr(UserGdprStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Resultset(object):
-    """Resultset of the job."""
+class RemovedUser(object):
+    """information about a user removed from an org"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.clientId = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "clientId"
             ) is None
-            else propDict["aceId"])
-        self.aceStorageServiceUrl = (
-            None if not fromDict or propDict.get(
-                "aceStorageServiceUrl"
-            ) is None
-            else propDict["aceStorageServiceUrl"])
+            else propDict["clientId"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
-        self.fileDownloadUrl = (
+        self.email = (
             None if not fromDict or propDict.get(
-                "fileDownloadUrl"
+                "email"
             ) is None
-            else propDict["fileDownloadUrl"])
-        self.files = (
+            else propDict["email"])
+        self.gdprDeletedDate = (
             None if not fromDict or propDict.get(
-                "files"
+                "gdprDeletedDate"
             ) is None
-            else [ ResultsetFile(i)
-            for i in propDict["files"] ])
-        self.id = (
+            else propDict["gdprDeletedDate"])
+        self.gdprRequestedDate = (
             None if not fromDict or propDict.get(
-                "id"
+                "gdprRequestedDate"
             ) is None
-            else propDict["id"])
-        self.replicaId = (
+            else propDict["gdprRequestedDate"])
+        self.gdprStatus = (
             None if not fromDict or propDict.get(
-                "replicaId"
+                "gdprStatus"
             ) is None
-            else propDict["replicaId"])
-        self.size = (
+            else propDict["gdprStatus"])
+        self.modifiedDate = (
             None if not fromDict or propDict.get(
-                "size"
+                "modifiedDate"
             ) is None
-            else propDict["size"])
-        self.status = (
+            else propDict["modifiedDate"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "status"
+                "name"
             ) is None
-            else propDict["status"])
-        self.storageLocations = (
+            else propDict["name"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "storageLocations"
+                "orgName"
             ) is None
-            else [ StorageLocation(i)
-            for i in propDict["storageLocations"] ])
-        self.token = (
+            else propDict["orgName"])
+        self.removedDate = (
             None if not fromDict or propDict.get(
-                "token"
+                "removedDate"
             ) is None
-            else propDict["token"])
-        self.totalFiles = (
+            else propDict["removedDate"])
+        self.starfleetId = (
             None if not fromDict or propDict.get(
-                "totalFiles"
+                "starfleetId"
             ) is None
-            else propDict["totalFiles"])
-
-    @property
-    def aceId(self):
-        """long: Id of the ACE to which the resultset is local."""
-        return self._aceId
-
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
-        else:
-            raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
-            )
+            else propDict["starfleetId"])
+        self.status = (
+            None if not fromDict or propDict.get(
+                "status"
+            ) is None
+            else propDict["status"])
 
     @property
-    def aceStorageServiceUrl(self):
-        """str: URL of the storage service of given ACE"""
-        return self._aceStorageServiceUrl
+    def clientId(self):
+        """str: user's unique auth client id"""
+        return self._clientId
 
-    @aceStorageServiceUrl.setter
-    def aceStorageServiceUrl(self, value):
+    @clientId.setter
+    def clientId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceStorageServiceUrl = value
+            self._clientId = value
         else:
             raise TypeError(
-                'Property "aceStorageServiceUrl" of type "list<str>" set to w'
-                'rong type'
+                'Property "clientId" of type "list<str>" set to wrong type'
             )
 
     @property
     def createdDate(self):
-        """str: Resultset creation date in ISO-8601 format"""
+        """str: date on which the user the joined the org for the first time
+        """
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._createdDate = value
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def fileDownloadUrl(self):
-        """str: Base URL for file download from this resultset"""
-        return self._fileDownloadUrl
+    def email(self):
+        """str: user's email. this should be unique"""
+        return self._email
 
-    @fileDownloadUrl.setter
-    def fileDownloadUrl(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fileDownloadUrl = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "fileDownloadUrl" of type "list<str>" set to wrong '
-                'type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def files(self):
-        """list: list of files in this resultset"""
-        return self._files
-
-    @files.setter
-    def files(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._files = value
+    def gdprDeletedDate(self):
+        """str: date on which the user's gdpr data was deleted"""
+        return self._gdprDeletedDate
+
+    @gdprDeletedDate.setter
+    def gdprDeletedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gdprDeletedDate = value
         else:
             raise TypeError(
-                'Property "files" of type "list<ResultsetFile>" set to wrong '
+                'Property "gdprDeletedDate" of type "list<str>" set to wrong '
                 'type'
             )
 
     @property
-    def id(self):
-        """long: Resultset unique ID (equals to job ID)"""
-        return self._id
+    def gdprRequestedDate(self):
+        """str: date on which the user requested their gdpr data"""
+        return self._gdprRequestedDate
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @gdprRequestedDate.setter
+    def gdprRequestedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gdprRequestedDate = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "gdprRequestedDate" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def replicaId(self):
-        """long: Resultset replica ID in case of multinode job (equals to repl
-        ica ID)"""
-        return self._replicaId
+    def gdprStatus(self):
+        """ """
+        return self._gdprStatus
 
-    @replicaId.setter
-    def replicaId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._replicaId = value
+    @gdprStatus.setter
+    def gdprStatus(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._gdprStatus = value
         else:
             raise TypeError(
-                'Property "replicaId" of type "list<long>" set to wrong type'
+                'Property "gdprStatus" of type "list<UserGdprStatusEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def size(self):
-        """long: Resultset size in bytes."""
-        return self._size
+    def modifiedDate(self):
+        """str: date on which the user was last modified"""
+        return self._modifiedDate
 
-    @size.setter
-    def size(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._size = value
+    @modifiedDate.setter
+    def modifiedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._modifiedDate = value
         else:
             raise TypeError(
-                'Property "size" of type "list<long>" set to wrong type'
+                'Property "modifiedDate" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def status(self):
-        """StatusEnum: Indicates the current status of the dataset."""
-        return self._status
+    def name(self):
+        """str: user's name"""
+        return self._name
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "status" of type "list<StatusEnum>" set to wrong ty'
-                'pe'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
-    StatusEnum=["FETCHING","FETCHED",]
-    str(repr(StatusEnum))  # Prevent optimizer removing enum
+    @property
+    def orgName(self):
+        """str: name of the org that the user was removed from"""
+        return self._orgName
+
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
+        else:
+            raise TypeError(
+                'Property "orgName" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def storageLocations(self):
-        """list: Storage locations of the resultset"""
-        return self._storageLocations
+    def removedDate(self):
+        """str: date on which the user was removed from the org"""
+        return self._removedDate
 
-    @storageLocations.setter
-    def storageLocations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageLocations = value
+    @removedDate.setter
+    def removedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._removedDate = value
         else:
             raise TypeError(
-                'Property "storageLocations" of type "list<StorageLocation>" '
-                'set to wrong type'
+                'Property "removedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def token(self):
-        """str: Token to be used with file download operations"""
-        return self._token
+    def starfleetId(self):
+        """str: user's starfleet id"""
+        return self._starfleetId
 
-    @token.setter
-    def token(self, value):
+    @starfleetId.setter
+    def starfleetId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._token = value
+            self._starfleetId = value
         else:
             raise TypeError(
-                'Property "token" of type "list<str>" set to wrong type'
+                'Property "starfleetId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def totalFiles(self):
-        """long: Number of files in this resultset."""
-        return self._totalFiles
+    def status(self):
+        """ """
+        return self._status
 
-    @totalFiles.setter
-    def totalFiles(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalFiles = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "totalFiles" of type "list<long>" set to wrong type'
+                'Property "status" of type "list<UserStatusEnum>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._aceStorageServiceUrl is not None:
-            result["aceStorageServiceUrl"] = \
-                self._aceStorageServiceUrl
+        if self._clientId is not None:
+            result["clientId"] = \
+                self._clientId
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
-        if self._fileDownloadUrl is not None:
-            result["fileDownloadUrl"] = \
-                self._fileDownloadUrl
-        if self._files:
-            result["files"] = [
-                i.toDict() for i in self._files 
-            ] if self._files else []
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._replicaId is not None:
-            result["replicaId"] = \
-                self._replicaId
-        if self._size is not None:
-            result["size"] = \
-                self._size
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._gdprDeletedDate is not None:
+            result["gdprDeletedDate"] = \
+                self._gdprDeletedDate
+        if self._gdprRequestedDate is not None:
+            result["gdprRequestedDate"] = \
+                self._gdprRequestedDate
+        if self._gdprStatus is not None:
+            result["gdprStatus"] = \
+                self._gdprStatus
+        if self._modifiedDate is not None:
+            result["modifiedDate"] = \
+                self._modifiedDate
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._removedDate is not None:
+            result["removedDate"] = \
+                self._removedDate
+        if self._starfleetId is not None:
+            result["starfleetId"] = \
+                self._starfleetId
         if self._status is not None:
             result["status"] = \
                 self._status
-        if self._storageLocations:
-            result["storageLocations"] = [
-                i.toDict() for i in self._storageLocations 
-            ] if self._storageLocations else []
-        if self._token is not None:
-            result["token"] = \
-                self._token
-        if self._totalFiles is not None:
-            result["totalFiles"] = \
-                self._totalFiles
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceId is None:
+        if (self._email is not None
+            and
+            len(self._email) < 7):
             raise ValueError(
-                "Resultset.aceId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._aceId is not None
+                "RemovedUser.email: " + str(self._email) + 
+                " doesnt match requirement: minLength: 7")
+        if (self._email is not None
             and
-            self._aceId < 1):
+            len(self._email) > 128):
             raise ValueError(
-                "Resultset.aceId: " + str(self._aceId) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._createdDate is not None
+                "RemovedUser.email: " + str(self._email) + 
+                " doesnt match requirement: maxLength: 128")
+        if (self._email is not None
             and
             not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
+                 self._email)):
             raise ValueError(
-                "Resultset.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._files is not None):
-            for obj in self._files:
-                if (obj is not None): obj.isValid()
-        if (self._storageLocations is not None):
-            for obj in self._storageLocations:
-                if (obj is not None): obj.isValid()
+                "RemovedUser.email: " + str(self._email) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
+                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
         return True
```

## Comparing `ngccli/data/api/ResultsetFile.py` & `ngcbpc/data/uis/TargetSystemUserIdentifier.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,190 +14,170 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetFile(object):
-    """File in the resultset."""
+class TargetSystemUserIdentifier(object):
+    """Information about the user who is attempting to run the job"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.createdDate = (
+        self.gid = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "gid"
             ) is None
-            else propDict["createdDate"])
-        self.fileSize = (
+            else propDict["gid"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "fileSize"
+                "orgName"
             ) is None
-            else propDict["fileSize"])
-        self.isDir = (
+            else propDict["orgName"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "isDir"
+                "teamName"
             ) is None
-            else propDict["isDir"])
-        self.path = (
+            else propDict["teamName"])
+        self.uid = (
             None if not fromDict or propDict.get(
-                "path"
+                "uid"
             ) is None
-            else propDict["path"])
-        self.resultsetId = (
+            else propDict["uid"])
+        self.userId = (
             None if not fromDict or propDict.get(
-                "resultsetId"
+                "userId"
             ) is None
-            else propDict["resultsetId"])
+            else propDict["userId"])
 
     @property
-    def createdDate(self):
-        """str: Date when file was created in ISO-8601 format."""
-        return self._createdDate
+    def gid(self):
+        """long: gid of the user on this team"""
+        return self._gid
 
-    @createdDate.setter
-    def createdDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
-        else:
-            raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def fileSize(self):
-        """long: Size of the file in bytes."""
-        return self._fileSize
-
-    @fileSize.setter
-    def fileSize(self, value):
+    @gid.setter
+    def gid(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._fileSize = value
+            self._gid = value
         else:
             raise TypeError(
-                'Property "fileSize" of type "list<long>" set to wrong type'
+                'Property "gid" of type "list<long>" set to wrong type'
             )
 
     @property
-    def isDir(self):
-        """bool: Indicates if this is a directory or not"""
-        return self._isDir
-
-    @isDir.setter
-    def isDir(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDir = value
+    def orgName(self):
+        """str: Org context for the job"""
+        return self._orgName
+
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "isDir" of type "list<bool>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def path(self):
-        """str: Relative file path from the root of the resultset."""
-        return self._path
+    def teamName(self):
+        """str: Team context for the job"""
+        return self._teamName
 
-    @path.setter
-    def path(self, value):
+    @teamName.setter
+    def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._path = value
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resultsetId(self):
-        """long: Resultset ID this file belongs to."""
-        return self._resultsetId
+    def uid(self):
+        """long: uid of the user on this team"""
+        return self._uid
 
-    @resultsetId.setter
-    def resultsetId(self, value):
+    @uid.setter
+    def uid(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._resultsetId = value
+            self._uid = value
         else:
             raise TypeError(
-                'Property "resultsetId" of type "list<long>" set to wrong typ'
-                'e'
+                'Property "uid" of type "list<long>" set to wrong type'
+            )
+
+    @property
+    def userId(self):
+        """long: Unique ID of the user who submitted the job"""
+        return self._userId
+
+    @userId.setter
+    def userId(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._userId = value
+        else:
+            raise TypeError(
+                'Property "userId" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._fileSize is not None:
-            result["fileSize"] = \
-                self._fileSize
-        if self._isDir is not None:
-            result["isDir"] = \
-                self._isDir
-        if self._path is not None:
-            result["path"] = \
-                self._path
-        if self._resultsetId is not None:
-            result["resultsetId"] = \
-                self._resultsetId
+        if self._gid is not None:
+            result["gid"] = \
+                self._gid
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
+        if self._uid is not None:
+            result["uid"] = \
+                self._uid
+        if self._userId is not None:
+            result["userId"] = \
+                self._userId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._resultsetId is None:
-            raise ValueError(
-                "ResultsetFile.resultsetId doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._resultsetId is not None
+        if (self._uid is not None
             and
-            self._resultsetId < 1):
+            self._uid < 1):
             raise ValueError(
-                "ResultsetFile.resultsetId: " + str(self._resultsetId) + 
+                "TargetSystemUserIdentifier.uid: " + str(self._uid) + 
                 " doesnt match requirement: minimum: 1")
-        if self._path is None:
-            raise ValueError(
-                "ResultsetFile.path doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._path is not None
+        if (self._uid is not None
             and
-            len(self._path) < 2):
+            self._uid > 4294967296):
             raise ValueError(
-                "ResultsetFile.path: " + str(self._path) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._path is not None
+                "TargetSystemUserIdentifier.uid: " + str(self._uid) + 
+                " doesnt match requirement: maximum: 4294967296")
+        if (self._gid is not None
             and
-            len(self._path) > 1024):
+            self._gid < 1):
             raise ValueError(
-                "ResultsetFile.path: " + str(self._path) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._fileSize is not None
-            and
-            self._fileSize < 0):
-            raise ValueError(
-                "ResultsetFile.fileSize: " + str(self._fileSize) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._createdDate is not None
+                "TargetSystemUserIdentifier.gid: " + str(self._gid) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._gid is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            self._gid > 4294967296):
             raise ValueError(
-                "ResultsetFile.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "TargetSystemUserIdentifier.gid: " + str(self._gid) + 
+                " doesnt match requirement: maximum: 4294967296")
         return True
```

## Comparing `ngccli/data/api/ResultsetFileBatch.py` & `ngcbpc/data/registry/BaseImageList.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,66 +6,58 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ResultsetFile import ResultsetFile
 
 # Unused import over optimization prevention
-str(repr(ResultsetFile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetFileBatch(object):
-    """Batch of resultset files"""
+class BaseImageList(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.files = (
+        self.fullImageNames = (
             None if not fromDict or propDict.get(
-                "files"
+                "fullImageNames"
             ) is None
-            else [ ResultsetFile(i)
-            for i in propDict["files"] ])
+            else propDict["fullImageNames"])
 
     @property
-    def files(self):
-        """list: Batch of files belonging to same resultset."""
-        return self._files
+    def fullImageNames(self):
+        """ """
+        return self._fullImageNames
 
-    @files.setter
-    def files(self, value):
+    @fullImageNames.setter
+    def fullImageNames(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._files = value
+            self._fullImageNames = value
         else:
             raise TypeError(
-                'Property "files" of type "list<ResultsetFile>" set to wrong '
-                'type'
+                'Property "fullImageNames" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     def toDict(self):
         result = {}
-        if self._files:
-            result["files"] = [
-                i.toDict() for i in self._files 
-            ] if self._files else []
+        if self._fullImageNames is not None:
+            result["fullImageNames"] = \
+                self._fullImageNames
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._files is not None):
-            for obj in self._files:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/ResultsetFileEventRequest.py` & `organization/data/sms/SecretDecryptRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,127 +6,135 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SecretNameKV import SecretNameKV
 
 # Unused import over optimization prevention
+str(repr(SecretNameKV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetFileEventRequest(object):
+class SecretDecryptRequest(object):
+    """Secret Decrypt Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filePath = (
+        self.encryptedSecrets = (
             None if not fromDict or propDict.get(
-                "filePath"
+                "encryptedSecrets"
             ) is None
-            else propDict["filePath"])
-        self.fileSize = (
+            else [ SecretNameKV(i)
+            for i in propDict["encryptedSecrets"] ])
+        self.user = (
             None if not fromDict or propDict.get(
-                "fileSize"
+                "user"
             ) is None
-            else propDict["fileSize"])
-        self.resultsetId = (
+            else propDict["user"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "resultsetId"
+                "version"
             ) is None
-            else propDict["resultsetId"])
+            else propDict["version"])
 
     @property
-    def filePath(self):
-        """str: Full file path."""
-        return self._filePath
+    def encryptedSecrets(self):
+        """ """
+        return self._encryptedSecrets
 
-    @filePath.setter
-    def filePath(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._filePath = value
+    @encryptedSecrets.setter
+    def encryptedSecrets(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._encryptedSecrets = value
         else:
             raise TypeError(
-                'Property "filePath" of type "list<str>" set to wrong type'
+                'Property "encryptedSecrets" of type "list<SecretNameKV>" set'
+                ' to wrong type'
             )
 
     @property
-    def fileSize(self):
-        """long: file size in bytes"""
-        return self._fileSize
-
-    @fileSize.setter
-    def fileSize(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._fileSize = value
+    def user(self):
+        """str: User requesting the decryption"""
+        return self._user
+
+    @user.setter
+    def user(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._user = value
         else:
             raise TypeError(
-                'Property "fileSize" of type "list<long>" set to wrong type'
+                'Property "user" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resultsetId(self):
-        """ """
-        return self._resultsetId
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @resultsetId.setter
-    def resultsetId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resultsetId = value
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "resultsetId" of type "list<long>" set to wrong typ'
-                'e'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._filePath is not None:
-            result["filePath"] = \
-                self._filePath
-        if self._fileSize is not None:
-            result["fileSize"] = \
-                self._fileSize
-        if self._resultsetId is not None:
-            result["resultsetId"] = \
-                self._resultsetId
+        if self._encryptedSecrets:
+            result["encryptedSecrets"] = [
+                i.toDict() for i in self._encryptedSecrets 
+            ] if self._encryptedSecrets else []
+        if self._user is not None:
+            result["user"] = \
+                self._user
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._filePath is not None
-            and
-            len(self._filePath) < 2):
+        if self._version is None:
             raise ValueError(
-                "ResultsetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._filePath is not None
-            and
-            len(self._filePath) > 1024):
+                "SecretDecryptRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._user is None:
             raise ValueError(
-                "ResultsetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: maxLength: 1024")
-        if (self._filePath is not None
+                "SecretDecryptRequest.user doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._user is not None
             and
-            not re.match(
-                r"^(\/(?!\/)([\w- %\.(?!\.)])+)+$",
-                 self._filePath)):
+            len(self._user) < 1):
             raise ValueError(
-                "ResultsetFileEventRequest.filePath: " + str(self._filePath) + 
-                " doesnt match requirement: pattern: ^(\/(?!\/)([\w- %\.(?!\."
-                ")])+)+$")
+                "SecretDecryptRequest.user: " + str(self._user) + 
+                " doesnt match requirement: minLength: 1")
+        if self._encryptedSecrets is None:
+            raise ValueError(
+                "SecretDecryptRequest.encryptedSecrets doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._encryptedSecrets is not None):
+            for obj in self._encryptedSecrets:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/ResultsetListResponse.py` & `ngcbpc/data/model/ArtifactVersionListResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,79 +6,93 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .Resultset import Resultset
+from .ArtifactVersion import ArtifactVersion
 from .RequestStatus import RequestStatus
-from .MetaData import MetaData
+from .PaginationInfo import PaginationInfo
+from .Artifact import Artifact
 
 # Unused import over optimization prevention
-str(repr(Resultset))
 str(repr(RequestStatus))
+str(repr(ArtifactVersion))
 str(repr(PaginationInfo))
-str(repr(MetaData))
+str(repr(Artifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetListResponse(object):
-    """Listing of all resultsets available for the user. Files are not include
-    d."""
+class ArtifactVersionListResponse(object):
+    """Response to list artifact versions request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filters = (
+        self.artifact = (
+            None if not fromDict or propDict.get(
+                "artifact"
+            ) is None
+            else propDict["artifact"])
+        self.artifactVersions = (
             None if not fromDict or propDict.get(
-                "filters"
+                "artifactVersions"
             ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
+            else [ ArtifactVersion(i)
+            for i in propDict["artifactVersions"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.resultsets = (
-            None if not fromDict or propDict.get(
-                "resultsets"
-            ) is None
-            else [ Resultset(i)
-            for i in propDict["resultsets"] ])
 
     @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
+    def artifact(self):
+        """Artifact: Artifact object"""
+        return self._artifact
+
+    @artifact.setter
+    def artifact(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._artifact = value
+        else:
+            raise TypeError(
+                'Property "artifact" of type "list<Artifact>" set to wrong ty'
+                'pe'
+            )
+
+    @property
+    def artifactVersions(self):
+        """ """
+        return self._artifactVersions
 
-    @filters.setter
-    def filters(self, value):
+    @artifactVersions.setter
+    def artifactVersions(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._filters = value
+            self._artifactVersions = value
         else:
             raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
-                'e'
+                'Property "artifactVersions" of type "list<ArtifactVersion>" '
+                'set to wrong type'
             )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -87,75 +101,55 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def resultsets(self):
-        """ """
-        return self._resultsets
-
-    @resultsets.setter
-    def resultsets(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._resultsets = value
-        else:
-            raise TypeError(
-                'Property "resultsets" of type "list<Resultset>" set to wrong'
-                ' type'
-            )
-
     def toDict(self):
         result = {}
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
+        if self._artifact:
+            result["artifact"] = \
+                self._artifact.toDict() if self._artifact is not None else None
+        if self._artifactVersions:
+            result["artifactVersions"] = [
+                i.toDict() for i in self._artifactVersions 
+            ] if self._artifactVersions else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._resultsets:
-            result["resultsets"] = [
-                i.toDict() for i in self._resultsets 
-            ] if self._resultsets else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._resultsets is not None):
-            for obj in self._resultsets:
-                if (obj is not None): obj.isValid()
-        if (self._filters is not None):
-            for obj in self._filters:
+        if (self._artifact is not None): self._artifact.isValid()
+        if (self._artifactVersions is not None):
+            for obj in self._artifactVersions:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/ResultsetResponse.py` & `ngcbpc/data/model/MultipartUploadAbortRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,151 +6,181 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .Resultset import Resultset
-from .RequestStatus import RequestStatus
-from .MetaData import MetaData
 
 # Unused import over optimization prevention
-str(repr(Resultset))
-str(repr(RequestStatus))
-str(repr(PaginationInfo))
-str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetResponse(object):
-    """showing details of the resultset"""
+class MultipartUploadAbortRequest(object):
+    """Request body for aborting a multipart upload for artifacts"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filters = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "filters"
+                "artifactType"
             ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
-        self.paginationInfo = (
+            else propDict["artifactType"])
+        self.filePath = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "filePath"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["filePath"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "name"
             ) is None
-            else propDict["requestStatus"])
-        self.resultset = (
+            else propDict["name"])
+        self.uploadID = (
             None if not fromDict or propDict.get(
-                "resultset"
+                "uploadID"
             ) is None
-            else propDict["resultset"])
+            else propDict["uploadID"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
-
-    @filters.setter
-    def filters(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._filters = value
+    def artifactType(self):
+        """str: Type of artifact"""
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
+                'Property "artifactType" of type "list<str>" set to wrong typ'
                 'e'
             )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def filePath(self):
+        """str: The file path for the artifact upload"""
+        return self._filePath
+
+    @filePath.setter
+    def filePath(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._filePath = value
+        else:
+            raise TypeError(
+                'Property "filePath" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def name(self):
+        """str: Name of the artifact"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def uploadID(self):
+        """str: The unique ID assigned by AWS for this multipart upload to ass
+        ociate all upload parts"""
+        return self._uploadID
+
+    @uploadID.setter
+    def uploadID(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uploadID = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "uploadID" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resultset(self):
-        """Resultset: Resultset of the job."""
-        return self._resultset
-
-    @resultset.setter
-    def resultset(self, value):
-        if value is not None and not isinstance(value, Resultset):
-            value = Resultset(value)
-        if (value is None) or isinstance(value, Resultset):
-            self._resultset = value
+    def version(self):
+        """str: Artifact version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "resultset" of type "list<Resultset>" set to wrong '
-                'type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._resultset:
-            result["resultset"] = \
-                self._resultset.toDict() if self._resultset is not None else None
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._filePath is not None:
+            result["filePath"] = \
+                self._filePath
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._uploadID is not None:
+            result["uploadID"] = \
+                self._uploadID
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._resultset is not None): self._resultset.isValid()
-        if (self._filters is not None):
-            for obj in self._filters:
-                if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if self._name is None:
+            raise ValueError(
+                "MultipartUploadAbortRequest.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._version is None:
+            raise ValueError(
+                "MultipartUploadAbortRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._artifactType is None:
+            raise ValueError(
+                "MultipartUploadAbortRequest.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._filePath is None:
+            raise ValueError(
+                "MultipartUploadAbortRequest.filePath doesnt match requirement:" 
+                "required: True"
+            )
+        if self._uploadID is None:
+            raise ValueError(
+                "MultipartUploadAbortRequest.uploadID doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/ResultsetToDatasetConversionEvent.py` & `organization/data/sms/SecretDecryptResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,109 +6,100 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SecretNameKV import SecretNameKV
 
 # Unused import over optimization prevention
+str(repr(SecretNameKV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ResultsetToDatasetConversionEvent(object):
+class SecretDecryptResponse(object):
+    """Secret Decrypt Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.datasetId = (
+        self.decryptedSecrets = (
             None if not fromDict or propDict.get(
-                "datasetId"
+                "decryptedSecrets"
             ) is None
-            else propDict["datasetId"])
-        self.orgName = (
+            else [ SecretNameKV(i)
+            for i in propDict["decryptedSecrets"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "version"
             ) is None
-            else propDict["orgName"])
-        self.resultsetId = (
-            None if not fromDict or propDict.get(
-                "resultsetId"
-            ) is None
-            else propDict["resultsetId"])
+            else propDict["version"])
 
     @property
-    def datasetId(self):
-        """long: Unique identifier of the dataset that we'll be copying the da
-        ta to"""
-        return self._datasetId
-
-    @datasetId.setter
-    def datasetId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._datasetId = value
+    def decryptedSecrets(self):
+        """ """
+        return self._decryptedSecrets
+
+    @decryptedSecrets.setter
+    def decryptedSecrets(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._decryptedSecrets = value
         else:
             raise TypeError(
-                'Property "datasetId" of type "list<long>" set to wrong type'
+                'Property "decryptedSecrets" of type "list<SecretNameKV>" set'
+                ' to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Unique identifier of the org that the resultset and dataset be
-        longs to"""
-        return self._orgName
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @orgName.setter
-    def orgName(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def resultsetId(self):
-        """long: Unique identifier of the resultset that we'll be copying the 
-        data from"""
-        return self._resultsetId
-
-    @resultsetId.setter
-    def resultsetId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resultsetId = value
-        else:
-            raise TypeError(
-                'Property "resultsetId" of type "list<long>" set to wrong typ'
-                'e'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._datasetId is not None:
-            result["datasetId"] = \
-                self._datasetId
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._resultsetId is not None:
-            result["resultsetId"] = \
-                self._resultsetId
+        if self._decryptedSecrets:
+            result["decryptedSecrets"] = [
+                i.toDict() for i in self._decryptedSecrets 
+            ] if self._decryptedSecrets else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "SecretDecryptResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._decryptedSecrets is None:
+            raise ValueError(
+                "SecretDecryptResponse.decryptedSecrets doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._decryptedSecrets is not None):
+            for obj in self._decryptedSecrets:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/RoleProduct.py` & `basecommand/data/pym/ProjectParams.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,50 +14,48 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RoleProduct(object):
-    """Product information of the role"""
+class ProjectParams(object):
+    """Project params"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.displayName = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "description"
             ) is None
-            else propDict["displayName"])
+            else propDict["description"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
 
     @property
-    def displayName(self):
-        """str: Display Name of the product from the product catalog to which 
-        this role is associated with"""
-        return self._displayName
+    def description(self):
+        """str: Project description"""
+        return self._description
 
-    @displayName.setter
-    def displayName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Name of the product from the product catalog to which this rol
-        e is associated with"""
+        """str: Project name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -65,25 +63,47 @@
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
+        if self._description is not None:
+            result["description"] = \
+                self._description
         if self._name is not None:
             result["name"] = \
                 self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "ProjectParams.name doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "ProjectParams.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if self._description is None:
+            raise ValueError(
+                "ProjectParams.description doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._description is not None
+            and
+            len(self._description) < 1):
+            raise ValueError(
+                "ProjectParams.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/api/RoleType.py` & `ngcbpc/data/uis/RoleType.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,3 +1,3 @@
-RoleTypeEnum=["ADMIN","ADMIN_READ_ONLY","USER","REGISTRY_ONLY","REGISTRY_USER_USER","REGISTRY_USER_ADMIN","REGISTRY_READ","REGISTRY_USER","REGISTRY_ADMIN","USER_READ","USER_WRITE","USER_ADMIN","EGX_ADMIN","EGX_USER","EGX_READ","BASE_COMMAND_USER","BASE_COMMAND_ADMIN","BASE_COMMAND_VIEWER","BASE_COMMAND_BANNER_ADMIN","ORG_OWNER","ACE_ADMIN","FLEET_COMMAND_VIEWER","FLEET_COMMAND_OPERATOR","FLEET_COMMAND_ADMIN","NVIDIA_AI_ENTERPRISE_VIEWER","OMNIVERSE_READ","OMNIVERSE_USER","OMNIVERSE_ADMIN","OMNIVERSE_SUBSCRIPTION_REQUEST_APPROVER","BASE_COMMAND_ENABLER","REGISTRY_ENABLER","FLEET_COMMAND_ENABLER","OMNIVERSE_ENABLER","NVIDIA_AI_ENTERPRISE_ENABLER","RIVA_ENTERPRISE_USER","RIVA_ENTERPRISE_ENABLER","PYM_ADMIN","PYM_USER","PYM_VIEWER","TAO_STUDIO_ADMIN","TAO_STUDIO_USER","TAO_STUDIO_VIEWER","TAO_STUDIO_ENABLER","PYM_ENABLER","ARTIFACT_CATALOG_ADMIN","ARTIFACT_CATALOG_USER","ARTIFACT_CATALOG_READ","LLM_ENABLER","LLM_CUSTOMIZATION_BASIC","LLM_INFERENCE_BASIC","LLM_CUSTOMIZATION_ADVANCED","LLM_INFERENCE_ADVANCED","LLM_INFORM","BIONEMO_ENABLER","BIONEMO_INFERENCE","FORGE_PROVIDER_ADMIN","FORGE_TENANT_ADMIN","DGX_SW_BUNDLE_ENABLER","FORGE_ENABLER","UCL_ADMIN","UCL_USER","UCL_VIEWER","UCL_ENABLER","CLOUD_TRUST_ADMIN","CLOUD_TRUST_USER","CLOUD_TRUST_VIEWER","CLOUD_TRUST_ENABLER","NVCF_ENABLER","NVCF_ADMIN","NVCF_VIEWER","NVCF_USER","CUOPT_USER","CUOPT_ENABLER","DATA_SERVICES_USER","DATA_SERVICES_VIEWER","DATA_SERVICES_ADMIN","DATA_SERVICES_ENABLER","CHIPNEMO_INFERENCE","CHIPNEMO_INFERENCE_ENABLER","DGX_CLOUD_SUBSCRIPTION_REQUEST_APPROVER","E2_ADMIN","E2_USER","E2_ENABLER","PICASSO_ADMIN","PICASSO_USER","PICASSO_VIEWER","PICASSO_ENABLER","MONAI_USER","MONAI_ENABLER","MET_ADMIN","MET_USER","MET_API_USER","MET_API_WRITE","MET_ENABLER",]
+RoleTypeEnum=["ADMIN","ADMIN_READ_ONLY","USER","REGISTRY_ONLY","REGISTRY_USER_USER","REGISTRY_USER_ADMIN","REGISTRY_READ","REGISTRY_USER","REGISTRY_ADMIN","USER_READ","USER_WRITE","USER_ADMIN","EGX_ADMIN","EGX_USER","EGX_READ","BASE_COMMAND_USER","BASE_COMMAND_ADMIN","BASE_COMMAND_VIEWER","BASE_COMMAND_BANNER_ADMIN","ORG_OWNER","ACE_ADMIN","FLEET_COMMAND_VIEWER","FLEET_COMMAND_OPERATOR","FLEET_COMMAND_ADMIN","NVIDIA_AI_ENTERPRISE_VIEWER","OMNIVERSE_READ","OMNIVERSE_USER","OMNIVERSE_ADMIN","OMNIVERSE_SUBSCRIPTION_REQUEST_APPROVER","BASE_COMMAND_ENABLER","REGISTRY_ENABLER","FLEET_COMMAND_ENABLER","OMNIVERSE_ENABLER","NVIDIA_AI_ENTERPRISE_ENABLER","RIVA_ENTERPRISE_USER","RIVA_ENTERPRISE_ENABLER","PYM_ADMIN","PYM_USER","PYM_VIEWER","TAO_STUDIO_ADMIN","TAO_STUDIO_USER","TAO_STUDIO_VIEWER","TAO_STUDIO_ENABLER","PYM_ENABLER","ARTIFACT_CATALOG_ADMIN","ARTIFACT_CATALOG_USER","ARTIFACT_CATALOG_READ","LLM_ENABLER","LLM_CUSTOMIZATION_BASIC","LLM_INFERENCE_BASIC","LLM_CUSTOMIZATION_ADVANCED","LLM_INFERENCE_ADVANCED","LLM_INFORM","BIONEMO_ENABLER","BIONEMO_INFERENCE","FORGE_PROVIDER_ADMIN","FORGE_TENANT_ADMIN","DGX_SW_BUNDLE_ENABLER","FORGE_ENABLER","UCL_ADMIN","UCL_USER","UCL_VIEWER","UCL_ENABLER","CLOUD_TRUST_ADMIN","CLOUD_TRUST_USER","CLOUD_TRUST_VIEWER","CLOUD_TRUST_ENABLER","NVCF_ENABLER","NVCF_ADMIN","NVCF_VIEWER","NVCF_USER","CUOPT_USER","CUOPT_ENABLER","DATA_SERVICES_USER","DATA_SERVICES_VIEWER","DATA_SERVICES_ADMIN","DATA_SERVICES_ENABLER","CHIPNEMO_INFERENCE","CHIPNEMO_INFERENCE_ENABLER","DGX_CLOUD_SUBSCRIPTION_REQUEST_APPROVER","E2_ADMIN","E2_USER","E2_ENABLER","PICASSO_ADMIN","PICASSO_USER","PICASSO_VIEWER","PICASSO_ENABLER","MONAI_USER",]
 str(repr(RoleTypeEnum))  # Prevent optimizer removing enum
```

## Comparing `ngccli/data/api/SCPJobDetails.py` & `ngcbpc/data/registry/TagUpdateRequest.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,46 +14,45 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SCPJobDetails(object):
-    """Metadata used by storage control plane during base command job submissi
-    on"""
+class TagUpdateRequest(object):
+    """Defines update tag request."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.blobs = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "blobs"
+                "description"
             ) is None
-            else propDict["blobs"])
+            else propDict["description"])
 
     @property
-    def blobs(self):
-        """ """
-        return self._blobs
-
-    @blobs.setter
-    def blobs(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._blobs = value
+    def description(self):
+        """str: Sets description for the tag"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "blobs" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._blobs is not None:
-            result["blobs"] = \
-                self._blobs
+        if self._description is not None:
+            result["description"] = \
+                self._description
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/Saml.py` & `ngcbpc/data/registry/ImageSignature.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,81 +6,84 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Header import Header
 
 # Unused import over optimization prevention
+str(repr(Header))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Saml(object):
+class ImageSignature(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.domain = (
+        self.header = (
             None if not fromDict or propDict.get(
-                "domain"
+                "header"
             ) is None
-            else propDict["domain"])
-        self.useSaml = (
+            else propDict["header"])
+        self.signature = (
             None if not fromDict or propDict.get(
-                "useSaml"
+                "signature"
             ) is None
-            else propDict["useSaml"])
+            else propDict["signature"])
 
     @property
-    def domain(self):
-        """str: domain name"""
-        return self._domain
-
-    @domain.setter
-    def domain(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._domain = value
+    def header(self):
+        """Header: Signature header"""
+        return self._header
+
+    @header.setter
+    def header(self, value):
+        if value is not None and not isinstance(value, Header):
+            value = Header(value)
+        if (value is None) or isinstance(value, Header):
+            self._header = value
         else:
             raise TypeError(
-                'Property "domain" of type "list<str>" set to wrong type'
+                'Property "header" of type "list<Header>" set to wrong type'
             )
 
     @property
-    def useSaml(self):
-        """bool: a boolean flag use to show if the domain is SAML enabled"""
-        return self._useSaml
-
-    @useSaml.setter
-    def useSaml(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useSaml = value
+    def signature(self):
+        """str: Signature"""
+        return self._signature
+
+    @signature.setter
+    def signature(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._signature = value
         else:
             raise TypeError(
-                'Property "useSaml" of type "list<bool>" set to wrong type'
+                'Property "signature" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._domain is not None:
-            result["domain"] = \
-                self._domain
-        if self._useSaml is not None:
-            result["useSaml"] = \
-                self._useSaml
+        if self._header:
+            result["header"] = \
+                self._header.toDict() if self._header is not None else None
+        if self._signature is not None:
+            result["signature"] = \
+                self._signature
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._header is not None): self._header.isValid()
         return True
```

## Comparing `ngccli/data/api/SamlResponse.py` & `ngcbpc/data/uis/TeamCreateResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,39 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Saml import Saml
+from .Team import Team
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Saml))
 str(repr(RequestStatus))
+str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SamlResponse(object):
+class TeamCreateResponse(object):
+    """response to an team creation request, includes unique team id"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.saml = (
+        self.team = (
             None if not fromDict or propDict.get(
-                "saml"
+                "team"
             ) is None
-            else propDict["saml"])
+            else propDict["team"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -50,44 +51,44 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def saml(self):
-        """ """
-        return self._saml
-
-    @saml.setter
-    def saml(self, value):
-        if value is not None and not isinstance(value, Saml):
-            value = Saml(value)
-        if (value is None) or isinstance(value, Saml):
-            self._saml = value
+    def team(self):
+        """Team: Information about the team"""
+        return self._team
+
+    @team.setter
+    def team(self, value):
+        if value is not None and not isinstance(value, Team):
+            value = Team(value)
+        if (value is None) or isinstance(value, Team):
+            self._team = value
         else:
             raise TypeError(
-                'Property "saml" of type "list<Saml>" set to wrong type'
+                'Property "team" of type "list<Team>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._saml:
-            result["saml"] = \
-                self._saml.toDict() if self._saml is not None else None
+        if self._team:
+            result["team"] = \
+                self._team.toDict() if self._team is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._saml is not None): self._saml.isValid()
+        if (self._team is not None): self._team.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/Secret.py` & `ngcbpc/data/uis/CreateBillingAccountRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,84 +6,102 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SecretKVEnv import SecretKVEnv
+from .AccountInfo import AccountInfo
 
 # Unused import over optimization prevention
-str(repr(SecretKVEnv))
+str(repr(AccountInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Secret(object):
-    """Information about the secret"""
+class CreateBillingAccountRequest(object):
+    """Create billing account request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allKVs = (
+        self.accountContact = (
             None if not fromDict or propDict.get(
-                "allKVs"
+                "accountContact"
             ) is None
-            else propDict["allKVs"])
-        self.kvEnvs = (
+            else propDict["accountContact"])
+        self.billToContact = (
             None if not fromDict or propDict.get(
-                "kvEnvs"
+                "billToContact"
             ) is None
-            else [ SecretKVEnv(i)
-            for i in propDict["kvEnvs"] ])
+            else propDict["billToContact"])
+        self.description = (
+            None if not fromDict or propDict.get(
+                "description"
+            ) is None
+            else propDict["description"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
 
     @property
-    def allKVs(self):
-        """bool: Indicate that all the KV pairs associated to the secret will 
-        be exported as environment variables with key name as env vari
-        able name"""
-        return self._allKVs
-
-    @allKVs.setter
-    def allKVs(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allKVs = value
+    def accountContact(self):
+        """AccountInfo: information about the account"""
+        return self._accountContact
+
+    @accountContact.setter
+    def accountContact(self, value):
+        if value is not None and not isinstance(value, AccountInfo):
+            value = AccountInfo(value)
+        if (value is None) or isinstance(value, AccountInfo):
+            self._accountContact = value
         else:
             raise TypeError(
-                'Property "allKVs" of type "list<bool>" set to wrong type'
+                'Property "accountContact" of type "list<AccountInfo>" set to'
+                ' wrong type'
             )
 
     @property
-    def kvEnvs(self):
-        """list: List of {KeyName,Value,EnvName} tuples associated to the secr
-        et"""
-        return self._kvEnvs
-
-    @kvEnvs.setter
-    def kvEnvs(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._kvEnvs = value
+    def billToContact(self):
+        """AccountInfo: information about the account"""
+        return self._billToContact
+
+    @billToContact.setter
+    def billToContact(self, value):
+        if value is not None and not isinstance(value, AccountInfo):
+            value = AccountInfo(value)
+        if (value is None) or isinstance(value, AccountInfo):
+            self._billToContact = value
         else:
             raise TypeError(
-                'Property "kvEnvs" of type "list<SecretKVEnv>" set to wrong t'
-                'ype'
+                'Property "billToContact" of type "list<AccountInfo>" set to '
+                'wrong type'
+            )
+
+    @property
+    def description(self):
+        """ """
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
+        else:
+            raise TypeError(
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Secret name"""
+        """str: Account name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -91,43 +109,43 @@
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allKVs is not None:
-            result["allKVs"] = \
-                self._allKVs
-        if self._kvEnvs:
-            result["kvEnvs"] = [
-                i.toDict() for i in self._kvEnvs 
-            ] if self._kvEnvs else []
+        if self._accountContact:
+            result["accountContact"] = \
+                self._accountContact.toDict() if self._accountContact is not None else None
+        if self._billToContact:
+            result["billToContact"] = \
+                self._billToContact.toDict() if self._billToContact is not None else None
+        if self._description is not None:
+            result["description"] = \
+                self._description
         if self._name is not None:
             result["name"] = \
                 self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "Secret.name doesnt match requirement:" 
+                "CreateBillingAccountRequest.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) < 1):
+        if self._description is None:
             raise ValueError(
-                "Secret.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._kvEnvs is not None):
-            for obj in self._kvEnvs:
-                if (obj is not None): obj.isValid()
+                "CreateBillingAccountRequest.description doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._accountContact is not None): self._accountContact.isValid()
+        if (self._billToContact is not None): self._billToContact.isValid()
         return True
```

## Comparing `ngccli/data/api/SecretKVEnv.py` & `basecommand/data/pym/SecretKeySpec.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,34 +14,28 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SecretKVEnv(object):
-    """Information about the secret key name, key value and optional env name
-    """
+class SecretKeySpec(object):
+    """Information about the secret key name and optional env name"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.envName = (
             None if not fromDict or propDict.get(
                 "envName"
             ) is None
             else propDict["envName"])
         self.keyName = (
             None if not fromDict or propDict.get(
                 "keyName"
             ) is None
             else propDict["keyName"])
-        self.keyValue = (
-            None if not fromDict or propDict.get(
-                "keyValue"
-            ) is None
-            else propDict["keyValue"])
 
     @property
     def envName(self):
         """str: Env variable name to export the secret KV pair"""
         return self._envName
 
     @envName.setter
@@ -69,74 +63,44 @@
         if (value is None) or isinstance(value, string_types):
             self._keyName = value
         else:
             raise TypeError(
                 'Property "keyName" of type "list<str>" set to wrong type'
             )
 
-    @property
-    def keyValue(self):
-        """str: Secret value"""
-        return self._keyValue
-
-    @keyValue.setter
-    def keyValue(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._keyValue = value
-        else:
-            raise TypeError(
-                'Property "keyValue" of type "list<str>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
         if self._envName is not None:
             result["envName"] = \
                 self._envName
         if self._keyName is not None:
             result["keyName"] = \
                 self._keyName
-        if self._keyValue is not None:
-            result["keyValue"] = \
-                self._keyValue
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._keyName is None:
             raise ValueError(
-                "SecretKVEnv.keyName doesnt match requirement:" 
+                "SecretKeySpec.keyName doesnt match requirement:" 
                 "required: True"
             )
         if (self._keyName is not None
             and
             len(self._keyName) < 1):
             raise ValueError(
-                "SecretKVEnv.keyName: " + str(self._keyName) + 
-                " doesnt match requirement: minLength: 1")
-        if self._keyValue is None:
-            raise ValueError(
-                "SecretKVEnv.keyValue doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._keyValue is not None
-            and
-            len(self._keyValue) < 1):
-            raise ValueError(
-                "SecretKVEnv.keyValue: " + str(self._keyValue) + 
+                "SecretKeySpec.keyName: " + str(self._keyName) + 
                 " doesnt match requirement: minLength: 1")
         if (self._envName is not None
             and
             len(self._envName) < 1):
             raise ValueError(
-                "SecretKVEnv.envName: " + str(self._envName) + 
+                "SecretKeySpec.envName: " + str(self._envName) + 
                 " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/api/SecretKeySpec.py` & `basecommand/data/pym/ClusterCreateRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,101 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterParams import ClusterParams
 
 # Unused import over optimization prevention
+str(repr(ClusterParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SecretKeySpec(object):
-    """Information about the secret key name and optional env name"""
+class ClusterCreateRequest(object):
+    """Cluster Create Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.envName = (
+        self.params = (
             None if not fromDict or propDict.get(
-                "envName"
+                "params"
             ) is None
-            else propDict["envName"])
-        self.keyName = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "keyName"
+                "version"
             ) is None
-            else propDict["keyName"])
+            else propDict["version"])
 
     @property
-    def envName(self):
-        """str: Env variable name to export the secret KV pair"""
-        return self._envName
-
-    @envName.setter
-    def envName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._envName = value
+    def params(self):
+        """ClusterParams: Cluster params"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ClusterParams):
+            value = ClusterParams(value)
+        if (value is None) or isinstance(value, ClusterParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "envName" of type "list<str>" set to wrong type'
+                'Property "params" of type "list<ClusterParams>" set to wrong'
+                ' type'
             )
 
     @property
-    def keyName(self):
-        """str: Secret key name (if no env variable name specified below, the 
-        secret KV pair will be exported with key name as env variable 
-        name)"""
-        return self._keyName
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @keyName.setter
-    def keyName(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._keyName = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "keyName" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._envName is not None:
-            result["envName"] = \
-                self._envName
-        if self._keyName is not None:
-            result["keyName"] = \
-                self._keyName
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._keyName is None:
+        if self._version is None:
             raise ValueError(
-                "SecretKeySpec.keyName doesnt match requirement:" 
+                "ClusterCreateRequest.version doesnt match requirement:" 
                 "required: True"
             )
-        if (self._keyName is not None
-            and
-            len(self._keyName) < 1):
+        if self._params is None:
             raise ValueError(
-                "SecretKeySpec.keyName: " + str(self._keyName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._envName is not None
-            and
-            len(self._envName) < 1):
-            raise ValueError(
-                "SecretKeySpec.envName: " + str(self._envName) + 
-                " doesnt match requirement: minLength: 1")
+                "ClusterCreateRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/api/SecretSpec.py` & `ngcbpc/data/registry/RepositoryImagesDeletedEvent.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,127 +6,134 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SecretKeySpec import SecretKeySpec
 
 # Unused import over optimization prevention
-str(repr(SecretKeySpec))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SecretSpec(object):
-    """Specification about the secret association to the job"""
+class RepositoryImagesDeletedEvent(object):
+    """Event sent when repository images are deleted in metadata service. The 
+    primary purpose of this event is to trigger asynchronous cleanup and d
+    eletion of manifests in docker container registry"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allKeys = (
+        self.deletedByUserId = (
             None if not fromDict or propDict.get(
-                "allKeys"
+                "deletedByUserId"
             ) is None
-            else propDict["allKeys"])
-        self.keysSpec = (
+            else propDict["deletedByUserId"])
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "keysSpec"
+                "namespace"
             ) is None
-            else [ SecretKeySpec(i)
-            for i in propDict["keysSpec"] ])
-        self.name = (
+            else propDict["namespace"])
+        self.repositoryName = (
             None if not fromDict or propDict.get(
-                "name"
+                "repositoryName"
             ) is None
-            else propDict["name"])
+            else propDict["repositoryName"])
+        self.tags = (
+            None if not fromDict or propDict.get(
+                "tags"
+            ) is None
+            else propDict["tags"])
 
     @property
-    def allKeys(self):
-        """bool: Indicate that all the KV pairs associated to the secret will 
-        be exported as environment variables with key name as env vari
-        able name"""
-        return self._allKeys
-
-    @allKeys.setter
-    def allKeys(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allKeys = value
+    def deletedByUserId(self):
+        """str: Authentication ID for the user who deleted the images"""
+        return self._deletedByUserId
+
+    @deletedByUserId.setter
+    def deletedByUserId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._deletedByUserId = value
         else:
             raise TypeError(
-                'Property "allKeys" of type "list<bool>" set to wrong type'
+                'Property "deletedByUserId" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def keysSpec(self):
-        """list: List of {KeyName,EnvName} tuples associated to the secret"""
-        return self._keysSpec
+    def namespace(self):
+        """str: Namespace repository belongs to i.e. org or org/team"""
+        return self._namespace
 
-    @keysSpec.setter
-    def keysSpec(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._keysSpec = value
+    @namespace.setter
+    def namespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "keysSpec" of type "list<SecretKeySpec>" set to wro'
-                'ng type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Secret name"""
-        return self._name
+    def repositoryName(self):
+        """str: Unique name of the repository in the namespace"""
+        return self._repositoryName
 
-    @name.setter
-    def name(self, value):
+    @repositoryName.setter
+    def repositoryName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._repositoryName = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "repositoryName" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def tags(self):
+        """list: List of deleted image tags """
+        return self._tags
+
+    @tags.setter
+    def tags(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._tags = value
+        else:
+            raise TypeError(
+                'Property "tags" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allKeys is not None:
-            result["allKeys"] = \
-                self._allKeys
-        if self._keysSpec:
-            result["keysSpec"] = [
-                i.toDict() for i in self._keysSpec 
-            ] if self._keysSpec else []
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._deletedByUserId is not None:
+            result["deletedByUserId"] = \
+                self._deletedByUserId
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._repositoryName is not None:
+            result["repositoryName"] = \
+                self._repositoryName
+        if self._tags is not None:
+            result["tags"] = \
+                self._tags
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "SecretSpec.name doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "SecretSpec.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._keysSpec is not None):
-            for obj in self._keysSpec:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/ServiceAccess.py` & `ngcbpc/data/uis/ServiceAccess.py`

 * *Files 19% similar despite different names*

```diff
@@ -45,15 +45,15 @@
             self._accessLevels = value
         else:
             raise TypeError(
                 'Property "accessLevels" of type "list<AccessLevelsEnum>" set'
                 ' to wrong type'
             )
 
-    AccessLevelsEnum=["READ","WRITE","ADMIN","ADMIN_READ","OWNER","READ_SUBSCRIPTION_REQUEST","WRITE_SUBSCRIPTION_REQUEST",]
+    AccessLevelsEnum=["READ","WRITE","ADMIN","ADMIN_READ","OWNER",]
     str(repr(AccessLevelsEnum))  # Prevent optimizer removing enum
 
 
     @property
     def service(self):
         """ServiceEnum: Service that this role allows"""
         return self._service
@@ -64,15 +64,15 @@
             self._service = value
         else:
             raise TypeError(
                 'Property "service" of type "list<ServiceEnum>" set to wrong '
                 'type'
             )
 
-    ServiceEnum=["DATASET","JOB","WORKSPACE","CONTAINER","MODEL","MODELSCRIPT","HELM","ORG","TEAM","USER","ACE","EGX","COLLECTION","FLEET_COMMAND_LOCATION","FLEET_COMMAND_APPLICATION","FLEET_COMMAND_DEPLOYMENT","FLEET_COMMAND_DASHBOARD","NVAIE","BASE_COMMAND_BANNER","SUBSCRIPTION_REQUEST","OMNIVERSE","RIVA_ENTERPRISE","PYM","TAO_STUDIO","CATALOG","LLM_CUSTOMIZATION_BASIC","LLM_INFERENCE_BASIC","LLM_CUSTOMIZATION_ADVANCED","LLM_INFERENCE_ADVANCED","LLM_INFORM","BIONEMO_INFERENCE","FORGE_ALLOCATION","FORGE_DASHBOARD","FORGE_OPERATING_SYSTEM","FORGE_RESOURCE","FORGE_SITE","FORGE_TENANT","FORGE_VPC","UCL_PROJECT","UCL_CLUSTER","CLOUD_TRUST","NVCF","CUOPT","SECRET","DATA_SERVICES","CHIPNEMO_INFERENCE","DGX_CLOUD","E2","PICASSO","MONAI","MET_SERVICE","MET_UI",]
+    ServiceEnum=["DATASET","JOB","WORKSPACE","CONTAINER","MODEL","MODELSCRIPT","HELM","ORG","TEAM","USER","ACE","EGX","COLLECTION","FLEET_COMMAND_LOCATION","FLEET_COMMAND_APPLICATION","FLEET_COMMAND_DEPLOYMENT","FLEET_COMMAND_DASHBOARD","NVAIE","BASE_COMMAND_BANNER","OMNIVERSE","RIVA_ENTERPRISE","PYM","TAO_STUDIO","CATALOG",]
     str(repr(ServiceEnum))  # Prevent optimizer removing enum
 
     def toDict(self):
         result = {}
         if self._accessLevels is not None:
             result["accessLevels"] = \
                 self._accessLevels
```

## Comparing `ngccli/data/api/StorageAccessInfo.py` & `organization/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,122 +14,118 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageAccessInfo(object):
-    """Describes the information required to access and mount the storage reso
-    urce"""
+class AzureMarketplaceSubscriptionTerm(object):
+    """Subscription Term Object in AzureMarketplace-webhook-event"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.mountPoint = (
+        self.chargeDuration = (
             None if not fromDict or propDict.get(
-                "mountPoint"
+                "chargeDuration"
             ) is None
-            else propDict["mountPoint"])
-        self.protocol = (
+            else propDict["chargeDuration"])
+        self.endDate = (
             None if not fromDict or propDict.get(
-                "protocol"
+                "endDate"
             ) is None
-            else propDict["protocol"])
-        self.shareHost = (
+            else propDict["endDate"])
+        self.startDate = (
             None if not fromDict or propDict.get(
-                "shareHost"
+                "startDate"
             ) is None
-            else propDict["shareHost"])
-        self.sharePath = (
+            else propDict["startDate"])
+        self.termUnit = (
             None if not fromDict or propDict.get(
-                "sharePath"
+                "termUnit"
             ) is None
-            else propDict["sharePath"])
+            else propDict["termUnit"])
 
     @property
-    def mountPoint(self):
-        """str: Path on the local system where the remote path will be mounted
-        """
-        return self._mountPoint
+    def chargeDuration(self):
+        """str: chargeDuration of the subscription"""
+        return self._chargeDuration
 
-    @mountPoint.setter
-    def mountPoint(self, value):
+    @chargeDuration.setter
+    def chargeDuration(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._mountPoint = value
+            self._chargeDuration = value
         else:
             raise TypeError(
-                'Property "mountPoint" of type "list<str>" set to wrong type'
+                'Property "chargeDuration" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def protocol(self):
-        """ """
-        return self._protocol
-
-    @protocol.setter
-    def protocol(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._protocol = value
+    def endDate(self):
+        """str: endDate timestamp id of the subscription"""
+        return self._endDate
+
+    @endDate.setter
+    def endDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._endDate = value
         else:
             raise TypeError(
-                'Property "protocol" of type "list<ProtocolEnum>" set to wron'
-                'g type'
+                'Property "endDate" of type "list<str>" set to wrong type'
             )
 
-    ProtocolEnum=["UNKNOWN","NFSV3","CEPH","LOCAL","LUSTRE","ZFS","YAROFS","PROXYFS",]
-    str(repr(ProtocolEnum))  # Prevent optimizer removing enum
-
     @property
-    def shareHost(self):
-        """str: IP address or host name or URL where the share is"""
-        return self._shareHost
+    def startDate(self):
+        """str: startDate timestamp of the subscription"""
+        return self._startDate
 
-    @shareHost.setter
-    def shareHost(self, value):
+    @startDate.setter
+    def startDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareHost = value
+            self._startDate = value
         else:
             raise TypeError(
-                'Property "shareHost" of type "list<str>" set to wrong type'
+                'Property "startDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sharePath(self):
-        """str: Path that should be used when mounting this storage end point
-        """
-        return self._sharePath
+    def termUnit(self):
+        """str: termUnit of the subscription"""
+        return self._termUnit
 
-    @sharePath.setter
-    def sharePath(self, value):
+    @termUnit.setter
+    def termUnit(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sharePath = value
+            self._termUnit = value
         else:
             raise TypeError(
-                'Property "sharePath" of type "list<str>" set to wrong type'
+                'Property "termUnit" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._mountPoint is not None:
-            result["mountPoint"] = \
-                self._mountPoint
-        if self._protocol is not None:
-            result["protocol"] = \
-                self._protocol
-        if self._shareHost is not None:
-            result["shareHost"] = \
-                self._shareHost
-        if self._sharePath is not None:
-            result["sharePath"] = \
-                self._sharePath
+        if self._chargeDuration is not None:
+            result["chargeDuration"] = \
+                self._chargeDuration
+        if self._endDate is not None:
+            result["endDate"] = \
+                self._endDate
+        if self._startDate is not None:
+            result["startDate"] = \
+                self._startDate
+        if self._termUnit is not None:
+            result["termUnit"] = \
+                self._termUnit
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/StorageAuthenticationResponse.py` & `organization/data/subscription_management_service/RelatedArtifact.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,184 +6,210 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
+from .MetaData import MetaData
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
+str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageAuthenticationResponse(object):
-    """Creating NGC Storage Service AuthN Client Credentials Response"""
+class RelatedArtifact(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "attributes"
             ) is None
-            else propDict["aceName"])
-        self.authClientId = (
+            else [ MetaData(i)
+            for i in propDict["attributes"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "authClientId"
+                "description"
             ) is None
-            else propDict["authClientId"])
-        self.authSecret = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "authSecret"
+                "displayName"
             ) is None
-            else propDict["authSecret"])
-        self.orgName = (
+            else propDict["displayName"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "labels"
             ) is None
-            else propDict["orgName"])
-        self.requestStatus = (
+            else propDict["labels"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "name"
             ) is None
-            else propDict["requestStatus"])
-        self.storageClusterUuid = (
+            else propDict["name"])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "storageClusterUuid"
+                "productName"
             ) is None
-            else propDict["storageClusterUuid"])
+            else propDict["productName"])
+        self.resourceType = (
+            None if not fromDict or propDict.get(
+                "resourceType"
+            ) is None
+            else propDict["resourceType"])
 
     @property
-    def aceName(self):
-        """str: ace name"""
-        return self._aceName
+    def attributes(self):
+        """ """
+        return self._attributes
 
-    @aceName.setter
-    def aceName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<MetaData>" set to wrong '
+                'type'
             )
 
     @property
-    def authClientId(self):
-        """str: AuthN client id"""
-        return self._authClientId
+    def description(self):
+        """str: shortDescription of the artifact"""
+        return self._description
 
-    @authClientId.setter
-    def authClientId(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authClientId = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "authClientId" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def authSecret(self):
-        """str: AuthN secret"""
-        return self._authSecret
+    def displayName(self):
+        """str: display name of the artifact"""
+        return self._displayName
 
-    @authSecret.setter
-    def authSecret(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authSecret = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "authSecret" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: org name"""
-        return self._orgName
+    def labels(self):
+        """ """
+        return self._labels
 
-    @orgName.setter
-    def orgName(self, value):
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
+        else:
+            raise TypeError(
+                'Property "labels" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def name(self):
+        """str: name of the artifact"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
+    def productName(self):
+        """str: product name of the artifact"""
+        return self._productName
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageClusterUuid(self):
-        """str: Storage cluster uuid"""
-        return self._storageClusterUuid
+    def resourceType(self):
+        """str: resource type of the artifact"""
+        return self._resourceType
 
-    @storageClusterUuid.setter
-    def storageClusterUuid(self, value):
+    @resourceType.setter
+    def resourceType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageClusterUuid = value
+            self._resourceType = value
         else:
             raise TypeError(
-                'Property "storageClusterUuid" of type "list<str>" set to wro'
-                'ng type'
+                'Property "resourceType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._authClientId is not None:
-            result["authClientId"] = \
-                self._authClientId
-        if self._authSecret is not None:
-            result["authSecret"] = \
-                self._authSecret
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._storageClusterUuid is not None:
-            result["storageClusterUuid"] = \
-                self._storageClusterUuid
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._resourceType is not None:
+            result["resourceType"] = \
+                self._resourceType
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageCephInfo.py` & `ngcbpc/data/registry/ImageDeleteRequest.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,75 +14,81 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageCephInfo(object):
-    """Describes the parameters required for mounting a CephFS path"""
+class ImageDeleteRequest(object):
+    """Defines delete image by tag request."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.shareClientId = (
+        self.actorClientId = (
             None if not fromDict or propDict.get(
-                "shareClientId"
+                "actorClientId"
             ) is None
-            else propDict["shareClientId"])
-        self.shareSecret = (
+            else propDict["actorClientId"])
+        self.userRequestSource = (
             None if not fromDict or propDict.get(
-                "shareSecret"
+                "userRequestSource"
             ) is None
-            else propDict["shareSecret"])
+            else propDict["userRequestSource"])
 
     @property
-    def shareClientId(self):
-        """str: Client id that should be used when mounting the CephFS path"""
-        return self._shareClientId
+    def actorClientId(self):
+        """str: Authn Client id of the user who requested delete operation"""
+        return self._actorClientId
 
-    @shareClientId.setter
-    def shareClientId(self, value):
+    @actorClientId.setter
+    def actorClientId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareClientId = value
+            self._actorClientId = value
         else:
             raise TypeError(
-                'Property "shareClientId" of type "list<str>" set to wrong ty'
+                'Property "actorClientId" of type "list<str>" set to wrong ty'
                 'pe'
             )
 
     @property
-    def shareSecret(self):
-        """str: Secret required to mount CephFS path"""
-        return self._shareSecret
+    def userRequestSource(self):
+        """str: IP address or Country Code from which request was issued"""
+        return self._userRequestSource
 
-    @shareSecret.setter
-    def shareSecret(self, value):
+    @userRequestSource.setter
+    def userRequestSource(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shareSecret = value
+            self._userRequestSource = value
         else:
             raise TypeError(
-                'Property "shareSecret" of type "list<str>" set to wrong type'
+                'Property "userRequestSource" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._shareClientId is not None:
-            result["shareClientId"] = \
-                self._shareClientId
-        if self._shareSecret is not None:
-            result["shareSecret"] = \
-                self._shareSecret
+        if self._actorClientId is not None:
+            result["actorClientId"] = \
+                self._actorClientId
+        if self._userRequestSource is not None:
+            result["userRequestSource"] = \
+                self._userRequestSource
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._actorClientId is None:
+            raise ValueError(
+                "ImageDeleteRequest.actorClientId doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/StorageClusterListResponse.py` & `basecommand/data/pym/ProjectSuccessResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,94 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
-from .RequestStatus import RequestStatus
+from .ProjectRequestStatus import ProjectRequestStatus
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
-str(repr(RequestStatus))
+str(repr(ProjectRequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageClusterListResponse(object):
-    """listing of all Storage Clusters under one ACE"""
+class ProjectSuccessResponse(object):
+    """Project Success Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.storageClusters = (
+        self.version = (
             None if not fromDict or propDict.get(
-                "storageClusters"
+                "version"
             ) is None
-            else [ StorageServiceConfigDetails(i)
-            for i in propDict["storageClusters"] ])
+            else propDict["version"])
 
     @property
     def requestStatus(self):
-        """ """
+        """ProjectRequestStatus: Project Request status"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
+        if value is not None and not isinstance(value, ProjectRequestStatus):
+            value = ProjectRequestStatus(value)
+        if (value is None) or isinstance(value, ProjectRequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "requestStatus" of type "list<ProjectRequestStatus>'
+                '" set to wrong type'
             )
 
     @property
-    def storageClusters(self):
-        """ """
-        return self._storageClusters
-
-    @storageClusters.setter
-    def storageClusters(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storageClusters = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "storageClusters" of type "list<StorageServiceConfi'
-                'gDetails>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._storageClusters:
-            result["storageClusters"] = [
-                i.toDict() for i in self._storageClusters 
-            ] if self._storageClusters else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._storageClusters is not None):
-            for obj in self._storageClusters:
-                if (obj is not None): obj.isValid()
+        if self._version is None:
+            raise ValueError(
+                "ProjectSuccessResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._requestStatus is None:
+            raise ValueError(
+                "ProjectSuccessResponse.requestStatus doesnt match requirement:" 
+                "required: True"
+            )
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageClusterResponse.py` & `organization/data/subscription_management_service/CreateOrderResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,40 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
+from .SubscriptionStatusEnum import SubscriptionStatusEnum
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
+str(repr(SubscriptionStatusEnum))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageClusterResponse(object):
-    """showing details of the ACE Storage Cluster"""
+class CreateOrderResponse(object):
+    """Response for create order API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.storageCluster = (
+        self.status = (
             None if not fromDict or propDict.get(
-                "storageCluster"
+                "status"
             ) is None
-            else propDict["storageCluster"])
+            else propDict["status"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -51,45 +51,42 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def storageCluster(self):
-        """ """
-        return self._storageCluster
-
-    @storageCluster.setter
-    def storageCluster(self, value):
-        if value is not None and not isinstance(value, StorageServiceConfigDetails):
-            value = StorageServiceConfigDetails(value)
-        if (value is None) or isinstance(value, StorageServiceConfigDetails):
-            self._storageCluster = value
+    def status(self):
+        """SubscriptionStatusEnum: All possible subscription status enums"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "storageCluster" of type "list<StorageServiceConfig'
-                'Details>" set to wrong type'
+                'Property "status" of type "list<SubscriptionStatusEnum>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._storageCluster:
-            result["storageCluster"] = \
-                self._storageCluster.toDict() if self._storageCluster is not None else None
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._storageCluster is not None): self._storageCluster.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageClusterUpdateRequest.py` & `ngcbpc/data/registry/AnchorePolicyBundle.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,285 +6,294 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageEngineTypeEnum import StorageEngineTypeEnum
+from .ImageSelectionRule import ImageSelectionRule
+from .MappingRule import MappingRule
+from .RuleSet import RuleSet
+from .Allowlist import Allowlist
 
 # Unused import over optimization prevention
-str(repr(StorageEngineTypeEnum))
+str(repr(MappingRule))
+str(repr(ImageSelectionRule))
+str(repr(Allowlist))
+str(repr(RuleSet))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageClusterUpdateRequest(object):
-    """object used to update information about the ACE Storage Cluster"""
+class AnchorePolicyBundle(object):
+    """A bundle containing a set of policies, allowlists, and rules for mappin
+    g them to specific images. https://app.swaggerhub.com/apis/anchore/anc
+    hore-engine/0.1.8#/PolicyBundleRecord"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.description = (
+        self.allowlisted_images = (
             None if not fromDict or propDict.get(
-                "description"
+                "allowlisted_images"
             ) is None
-            else propDict["description"])
-        self.destination = (
+            else [ ImageSelectionRule(i)
+            for i in propDict["allowlisted_images"] ])
+        self.allowlists = (
             None if not fromDict or propDict.get(
-                "destination"
+                "allowlists"
             ) is None
-            else propDict["destination"])
-        self.inboundHttpDisabled = (
+            else [ Allowlist(i)
+            for i in propDict["allowlists"] ])
+        self.denylisted_images = (
             None if not fromDict or propDict.get(
-                "inboundHttpDisabled"
+                "denylisted_images"
             ) is None
-            else propDict["inboundHttpDisabled"])
-        self.initialDefaultQuotaSizeGb = (
+            else [ ImageSelectionRule(i)
+            for i in propDict["denylisted_images"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "initialDefaultQuotaSizeGb"
+                "description"
             ) is None
-            else propDict["initialDefaultQuotaSizeGb"])
-        self.isDefault = (
+            else propDict["description"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "isDefault"
+                "id"
             ) is None
-            else propDict["isDefault"])
-        self.maxQuotaSizeGb = (
+            else propDict["id"])
+        self.mappings = (
             None if not fromDict or propDict.get(
-                "maxQuotaSizeGb"
+                "mappings"
             ) is None
-            else propDict["maxQuotaSizeGb"])
+            else [ MappingRule(i)
+            for i in propDict["mappings"] ])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.storageLocation = (
+        self.rule_sets = (
             None if not fromDict or propDict.get(
-                "storageLocation"
+                "rule_sets"
             ) is None
-            else propDict["storageLocation"])
-        self.storageMountPrefix = (
+            else [ RuleSet(i)
+            for i in propDict["rule_sets"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "storageMountPrefix"
+                "version"
             ) is None
-            else propDict["storageMountPrefix"])
-        self.type = (
-            None if not fromDict or propDict.get(
-                "type"
-            ) is None
-            else propDict["type"])
+            else propDict["version"])
 
     @property
-    def description(self):
-        """str: Full description about this storage cluster. eg. NetApp SJC4 .
-        .."""
-        return self._description
-
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    def allowlisted_images(self):
+        """list: List of mapping rules that define which images should always 
+        be passed (unless also on the denylist), regardless of policy 
+        result."""
+        return self._allowlisted_images
+
+    @allowlisted_images.setter
+    def allowlisted_images(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._allowlisted_images = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "allowlisted_images" of type "list<ImageSelectionRu'
+                'le>" set to wrong type'
             )
 
     @property
-    def destination(self):
-        """str: Storage Service URL fo this resource type"""
-        return self._destination
-
-    @destination.setter
-    def destination(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._destination = value
+    def allowlists(self):
+        """ """
+        return self._allowlists
+
+    @allowlists.setter
+    def allowlists(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._allowlists = value
         else:
             raise TypeError(
-                'Property "destination" of type "list<str>" set to wrong type'
+                'Property "allowlists" of type "list<Allowlist>" set to wrong'
+                ' type'
             )
 
     @property
-    def inboundHttpDisabled(self):
-        """bool: If set to true, all communication to FSS on this cluster will
-         be via kafka. This will be used in superPod"""
-        return self._inboundHttpDisabled
-
-    @inboundHttpDisabled.setter
-    def inboundHttpDisabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._inboundHttpDisabled = value
+    def denylisted_images(self):
+        """list: List of mapping rules that define which images should always 
+        result in a STOP/FAIL policy result regardless of policy conte
+        nt or presence in allowlisted_images"""
+        return self._denylisted_images
+
+    @denylisted_images.setter
+    def denylisted_images(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._denylisted_images = value
         else:
             raise TypeError(
-                'Property "inboundHttpDisabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "denylisted_images" of type "list<ImageSelectionRul'
+                'e>" set to wrong type'
             )
 
     @property
-    def initialDefaultQuotaSizeGb(self):
-        """long: When provisioning storage quota for new user, how much initia
-        l GB to be provisioned"""
-        return self._initialDefaultQuotaSizeGb
-
-    @initialDefaultQuotaSizeGb.setter
-    def initialDefaultQuotaSizeGb(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._initialDefaultQuotaSizeGb = value
+    def description(self):
+        """str: Description of the bundle, human readable"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "initialDefaultQuotaSizeGb" of type "list<long>" se'
-                't to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isDefault(self):
-        """bool: For multiple storage in an ACE, is this storage service the d
-        efault one"""
-        return self._isDefault
-
-    @isDefault.setter
-    def isDefault(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDefault = value
+    def id(self):
+        """str: Id of the bundle"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "isDefault" of type "list<bool>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maxQuotaSizeGb(self):
-        """long: Maximum quota allowed when increasing quota"""
-        return self._maxQuotaSizeGb
-
-    @maxQuotaSizeGb.setter
-    def maxQuotaSizeGb(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._maxQuotaSizeGb = value
+    def mappings(self):
+        """ """
+        return self._mappings
+
+    @mappings.setter
+    def mappings(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._mappings = value
         else:
             raise TypeError(
-                'Property "maxQuotaSizeGb" of type "list<long>" set to wrong '
-                'type'
+                'Property "mappings" of type "list<MappingRule>" set to wrong'
+                ' type'
             )
 
     @property
     def name(self):
-        """str: Human readable name for this storage cluster"""
+        """str: Human readable name for the bundle"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storageLocation(self):
-        """str: The IP of the storage locations"""
-        return self._storageLocation
-
-    @storageLocation.setter
-    def storageLocation(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._storageLocation = value
+    def rule_sets(self):
+        """ """
+        return self._rule_sets
+
+    @rule_sets.setter
+    def rule_sets(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._rule_sets = value
         else:
             raise TypeError(
-                'Property "storageLocation" of type "list<str>" set to wrong '
-                'type'
+                'Property "rule_sets" of type "list<RuleSet>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def storageMountPrefix(self):
-        """str: The prefix of the mount eg. 192.168.0.1:/vol where /vol is you
-        r prefix"""
-        return self._storageMountPrefix
+    def version(self):
+        """str: Version id for this bundle format"""
+        return self._version
 
-    @storageMountPrefix.setter
-    def storageMountPrefix(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageMountPrefix = value
-        else:
-            raise TypeError(
-                'Property "storageMountPrefix" of type "list<str>" set to wro'
-                'ng type'
-            )
-
-    @property
-    def type(self):
-        """StorageEngineTypeEnum: All possible storage engine type enums"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "type" of type "list<StorageEngineTypeEnum>" set to'
-                ' wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._allowlisted_images:
+            result["allowlisted_images"] = [
+                i.toDict() for i in self._allowlisted_images 
+            ] if self._allowlisted_images else []
+        if self._allowlists:
+            result["allowlists"] = [
+                i.toDict() for i in self._allowlists 
+            ] if self._allowlists else []
+        if self._denylisted_images:
+            result["denylisted_images"] = [
+                i.toDict() for i in self._denylisted_images 
+            ] if self._denylisted_images else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._destination is not None:
-            result["destination"] = \
-                self._destination
-        if self._inboundHttpDisabled is not None:
-            result["inboundHttpDisabled"] = \
-                self._inboundHttpDisabled
-        if self._initialDefaultQuotaSizeGb is not None:
-            result["initialDefaultQuotaSizeGb"] = \
-                self._initialDefaultQuotaSizeGb
-        if self._isDefault is not None:
-            result["isDefault"] = \
-                self._isDefault
-        if self._maxQuotaSizeGb is not None:
-            result["maxQuotaSizeGb"] = \
-                self._maxQuotaSizeGb
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._mappings:
+            result["mappings"] = [
+                i.toDict() for i in self._mappings 
+            ] if self._mappings else []
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._storageLocation is not None:
-            result["storageLocation"] = \
-                self._storageLocation
-        if self._storageMountPrefix is not None:
-            result["storageMountPrefix"] = \
-                self._storageMountPrefix
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._rule_sets:
+            result["rule_sets"] = [
+                i.toDict() for i in self._rule_sets 
+            ] if self._rule_sets else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._allowlists is not None):
+            for obj in self._allowlists:
+                if (obj is not None): obj.isValid()
+        if (self._rule_sets is not None):
+            for obj in self._rule_sets:
+                if (obj is not None): obj.isValid()
+        if (self._mappings is not None):
+            for obj in self._mappings:
+                if (obj is not None): obj.isValid()
+        if (self._allowlisted_images is not None):
+            for obj in self._allowlisted_images:
+                if (obj is not None): obj.isValid()
+        if (self._denylisted_images is not None):
+            for obj in self._denylisted_images:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageLocation.py` & `ngcbpc/data/uis/ApiKeyRequest.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,123 +6,159 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageLocationStorageTypeEnum import StorageLocationStorageTypeEnum
+from .ApiKeyPolicy import ApiKeyPolicy
+from .ApiKeyTypeEnum import ApiKeyTypeEnum
 
 # Unused import over optimization prevention
-str(repr(StorageLocationStorageTypeEnum))
+str(repr(ApiKeyPolicy))
+str(repr(ApiKeyTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageLocation(object):
-    """Storage location information for resources."""
+class ApiKeyRequest(object):
+    """Create api key request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.externalEndpointUri = (
+        self.expiryDate = (
             None if not fromDict or propDict.get(
-                "externalEndpointUri"
+                "expiryDate"
             ) is None
-            else propDict["externalEndpointUri"])
-        self.id = (
+            else propDict["expiryDate"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "id"
+                "name"
             ) is None
-            else propDict["id"])
-        self.storageType = (
+            else propDict["name"])
+        self.policies = (
             None if not fromDict or propDict.get(
-                "storageType"
+                "policies"
             ) is None
-            else propDict["storageType"])
+            else [ ApiKeyPolicy(i)
+            for i in propDict["policies"] ])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
 
     @property
-    def externalEndpointUri(self):
-        """str: Storage location endpoint URI."""
-        return self._externalEndpointUri
+    def expiryDate(self):
+        """str: Expiration date of the key"""
+        return self._expiryDate
 
-    @externalEndpointUri.setter
-    def externalEndpointUri(self, value):
+    @expiryDate.setter
+    def expiryDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._externalEndpointUri = value
+            self._expiryDate = value
         else:
             raise TypeError(
-                'Property "externalEndpointUri" of type "list<str>" set to wr'
-                'ong type'
+                'Property "expiryDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """str: Resource unique identifier (UUID)."""
-        return self._id
+    def name(self):
+        """str: Name of the key"""
+        return self._name
 
-    @id.setter
-    def id(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._id = value
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def policies(self):
+        """list: Access permissions of the key"""
+        return self._policies
+
+    @policies.setter
+    def policies(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._policies = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "policies" of type "list<ApiKeyPolicy>" set to wron'
+                'g type'
             )
 
     @property
-    def storageType(self):
-        """StorageLocationStorageTypeEnum: Indicates storage type of a storage
-         location."""
-        return self._storageType
+    def type(self):
+        """ApiKeyTypeEnum: Possible api key types"""
+        return self._type
 
-    @storageType.setter
-    def storageType(self, value):
+    @type.setter
+    def type(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._storageType = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "storageType" of type "list<StorageLocationStorageT'
-                'ypeEnum>" set to wrong type'
+                'Property "type" of type "list<ApiKeyTypeEnum>" set to wrong '
+                'type'
             )
 
     def toDict(self):
         result = {}
-        if self._externalEndpointUri is not None:
-            result["externalEndpointUri"] = \
-                self._externalEndpointUri
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._storageType is not None:
-            result["storageType"] = \
-                self._storageType
+        if self._expiryDate is not None:
+            result["expiryDate"] = \
+                self._expiryDate
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._policies:
+            result["policies"] = [
+                i.toDict() for i in self._policies 
+            ] if self._policies else []
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._id is None:
+        if self._name is None:
             raise ValueError(
-                "StorageLocation.id doesnt match requirement:" 
+                "ApiKeyRequest.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._id is not None
-            and
-            not re.match(
-                r"^(?![-_])[a-zA-Z0-9_-]{22}$",
-                 self._id)):
+        if self._type is None:
             raise ValueError(
-                "StorageLocation.id: " + str(self._id) + 
-                " doesnt match requirement: pattern: ^(?![-_])[a-zA-Z0-9_-]{2"
-                "2}$")
+                "ApiKeyRequest.type doesnt match requirement:" 
+                "required: True"
+            )
+        if self._expiryDate is None:
+            raise ValueError(
+                "ApiKeyRequest.expiryDate doesnt match requirement:" 
+                "required: True"
+            )
+        if self._policies is None:
+            raise ValueError(
+                "ApiKeyRequest.policies doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._policies is not None):
+            for obj in self._policies:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageLustreInfo.py` & `organization/data/subscription_management_service/CreateProductRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,61 +6,61 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Product import Product
 
 # Unused import over optimization prevention
+str(repr(Product))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageLustreInfo(object):
-    """Describes the parameters required for mounting a data volume exported v
-    ia Lustre"""
+class CreateProductRequest(object):
+    """Create product request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.LUSTRE_PLACEHOLDER = (
+        self.product = (
             None if not fromDict or propDict.get(
-                "LUSTRE_PLACEHOLDER"
+                "product"
             ) is None
-            else propDict["LUSTRE_PLACEHOLDER"])
+            else propDict["product"])
 
     @property
-    def LUSTRE_PLACEHOLDER(self):
-        """str: Placeholder for Lustre mount arguments. Delete this when you a
-        dd the actual parameters."""
-        return self._LUSTRE_PLACEHOLDER
-
-    @LUSTRE_PLACEHOLDER.setter
-    def LUSTRE_PLACEHOLDER(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._LUSTRE_PLACEHOLDER = value
+    def product(self):
+        """ """
+        return self._product
+
+    @product.setter
+    def product(self, value):
+        if value is not None and not isinstance(value, Product):
+            value = Product(value)
+        if (value is None) or isinstance(value, Product):
+            self._product = value
         else:
             raise TypeError(
-                'Property "LUSTRE_PLACEHOLDER" of type "list<str>" set to wro'
-                'ng type'
+                'Property "product" of type "list<Product>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._LUSTRE_PLACEHOLDER is not None:
-            result["LUSTRE_PLACEHOLDER"] = \
-                self._LUSTRE_PLACEHOLDER
+        if self._product:
+            result["product"] = \
+                self._product.toDict() if self._product is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._product is not None): self._product.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageNfsv3Info.py` & `ngcbpc/data/registry/BlobSum.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,48 +14,44 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageNfsv3Info(object):
-    """Describes the parameters required for mounting a data volume exported v
-    ia NFSv3"""
+class BlobSum(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.NFS_PLACEHOLDER = (
+        self.blobSum = (
             None if not fromDict or propDict.get(
-                "NFS_PLACEHOLDER"
+                "blobSum"
             ) is None
-            else propDict["NFS_PLACEHOLDER"])
+            else propDict["blobSum"])
 
     @property
-    def NFS_PLACEHOLDER(self):
-        """str: Placeholder for NFS mount arguments. Delete this when you add 
-        the actual parameters."""
-        return self._NFS_PLACEHOLDER
+    def blobSum(self):
+        """str: sha256 sum of the image"""
+        return self._blobSum
 
-    @NFS_PLACEHOLDER.setter
-    def NFS_PLACEHOLDER(self, value):
+    @blobSum.setter
+    def blobSum(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._NFS_PLACEHOLDER = value
+            self._blobSum = value
         else:
             raise TypeError(
-                'Property "NFS_PLACEHOLDER" of type "list<str>" set to wrong '
-                'type'
+                'Property "blobSum" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._NFS_PLACEHOLDER is not None:
-            result["NFS_PLACEHOLDER"] = \
-                self._NFS_PLACEHOLDER
+        if self._blobSum is not None:
+            result["blobSum"] = \
+                self._blobSum
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/StorageResource.py` & `ngcbpc/data/model/RecipeUpdateRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,520 +6,525 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageLocation import StorageLocation
-from .StorageResourceStatusEnum import StorageResourceStatusEnum
+from .ModelSimplified import ModelSimplified
+from .FrameworkType import FrameworkTypeEnum
+from .PrecisionType import PrecisionTypeEnum
+from .Dataset import Dataset
+from .ApplicationType import ApplicationTypeEnum
 
 # Unused import over optimization prevention
-str(repr(StorageLocation))
-str(repr(StorageResourceStatusEnum))
+str(repr(ModelSimplified))
+str(repr(PrecisionTypeEnum))
+str(repr(FrameworkTypeEnum))
+str(repr(ApplicationTypeEnum))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageResource(object):
-    """Generic Storage Resource for DL jobs."""
+class RecipeUpdateRequest(object):
+    """Request to create a new recipe"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.advanced = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "advanced"
             ) is None
-            else propDict["aceName"])
-        self.aceStorageServiceUrl = (
+            else propDict["advanced"])
+        self.application = (
             None if not fromDict or propDict.get(
-                "aceStorageServiceUrl"
+                "application"
             ) is None
-            else propDict["aceStorageServiceUrl"])
-        self.createdDate = (
+            else propDict["application"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "builtBy"
             ) is None
-            else propDict["createdDate"])
-        self.creatorUserId = (
-            None if not fromDict or propDict.get(
-                "creatorUserId"
-            ) is None
-            else propDict["creatorUserId"])
-        self.creatorUserName = (
-            None if not fromDict or propDict.get(
-                "creatorUserName"
-            ) is None
-            else propDict["creatorUserName"])
+            else propDict["builtBy"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.id = (
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "id"
+                "displayName"
             ) is None
-            else propDict["id"])
+            else propDict["displayName"])
         self.labels = (
             None if not fromDict or propDict.get(
                 "labels"
             ) is None
             else propDict["labels"])
-        self.name = (
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "name"
+                "labelsV2"
             ) is None
-            else propDict["name"])
-        self.orgName = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "logo"
             ) is None
-            else propDict["orgName"])
-        self.owned = (
+            else propDict["logo"])
+        self.modelFormat = (
             None if not fromDict or propDict.get(
-                "owned"
+                "modelFormat"
             ) is None
-            else propDict["owned"])
-        self.resourceNumericId = (
+            else propDict["modelFormat"])
+        self.performance = (
             None if not fromDict or propDict.get(
-                "resourceNumericId"
+                "performance"
             ) is None
-            else propDict["resourceNumericId"])
-        self.shared = (
+            else propDict["performance"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "shared"
+                "precision"
             ) is None
-            else propDict["shared"])
-        self.sharedWith = (
+            else propDict["precision"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "sharedWith"
+                "publicDatasetUsed"
             ) is None
-            else propDict["sharedWith"])
-        self.sizeInBytes = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "sizeInBytes"
+                "publisher"
             ) is None
-            else propDict["sizeInBytes"])
-        self.status = (
+            else propDict["publisher"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "status"
+                "quickStartGuide"
             ) is None
-            else propDict["status"])
-        self.storageLocations = (
+            else propDict["quickStartGuide"])
+        self.relatedModels = (
             None if not fromDict or propDict.get(
-                "storageLocations"
+                "relatedModels"
             ) is None
-            else [ StorageLocation(i)
-            for i in propDict["storageLocations"] ])
-        self.updatedDate = (
+            else [ ModelSimplified(i)
+            for i in propDict["relatedModels"] ])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "updatedDate"
+                "setup"
             ) is None
-            else propDict["updatedDate"])
-
-    @property
-    def aceName(self):
-        """str: Name of the ACE to which the resource is local."""
-        return self._aceName
-
-    @aceName.setter
-    def aceName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceName = value
-        else:
-            raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def aceStorageServiceUrl(self):
-        """str: URL of the storage service of given ACE"""
-        return self._aceStorageServiceUrl
-
-    @aceStorageServiceUrl.setter
-    def aceStorageServiceUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._aceStorageServiceUrl = value
-        else:
-            raise TypeError(
-                'Property "aceStorageServiceUrl" of type "list<str>" set to w'
-                'rong type'
-            )
+            else propDict["setup"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
+        self.trainingFramework = (
+            None if not fromDict or propDict.get(
+                "trainingFramework"
+            ) is None
+            else propDict["trainingFramework"])
 
     @property
-    def createdDate(self):
-        """str: Resource creation date in ISO-8601 format"""
-        return self._createdDate
+    def advanced(self):
+        """str: Text for describing advanced information"""
+        return self._advanced
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @advanced.setter
+    def advanced(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._advanced = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "advanced" of type "list<str>" set to wrong type'
             )
 
     @property
-    def creatorUserId(self):
-        """str: ID of the creator of the resource."""
-        return self._creatorUserId
+    def application(self):
+        """ """
+        return self._application
 
-    @creatorUserId.setter
-    def creatorUserId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._creatorUserId = value
+    @application.setter
+    def application(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._application = value
         else:
             raise TypeError(
-                'Property "creatorUserId" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "application" of type "list<ApplicationTypeEnum>" s'
+                'et to wrong type'
             )
 
     @property
-    def creatorUserName(self):
-        """str: Name of the creator of the resource."""
-        return self._creatorUserName
+    def builtBy(self):
+        """str: organization that built the recipe"""
+        return self._builtBy
 
-    @creatorUserName.setter
-    def creatorUserName(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._creatorUserName = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "creatorUserName" of type "list<str>" set to wrong '
-                'type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Resource description."""
+        """str: Description of the recipe"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """str: Resource unique identifier (UUID)."""
-        return self._id
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @id.setter
-    def id(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._id = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
     def labels(self):
-        """list: list of labels for this resource"""
+        """ """
         return self._labels
 
     @labels.setter
     def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
             self._labels = value
         else:
             raise TypeError(
                 'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the resource. Must not be a valid UUID or start with -
-         or _."""
-        return self._name
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Organization to which resource belongs."""
-        return self._orgName
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @orgName.setter
-    def orgName(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def owned(self):
-        """bool: Indicates whether the resource has been created by the curren
-        t user"""
-        return self._owned
+    def modelFormat(self):
+        """str: Format of the model this recipe produces"""
+        return self._modelFormat
 
-    @owned.setter
-    def owned(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._owned = value
+    @modelFormat.setter
+    def modelFormat(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._modelFormat = value
         else:
             raise TypeError(
-                'Property "owned" of type "list<bool>" set to wrong type'
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resourceNumericId(self):
-        """long: Resource unique identifier (LONG)."""
-        return self._resourceNumericId
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @resourceNumericId.setter
-    def resourceNumericId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._resourceNumericId = value
+    @performance.setter
+    def performance(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._performance = value
         else:
             raise TypeError(
-                'Property "resourceNumericId" of type "list<long>" set to wro'
-                'ng type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shared(self):
-        """bool: Indicates whether the resource is shared with any Org or Team
-        """
-        return self._shared
+    def precision(self):
+        """ """
+        return self._precision
 
-    @shared.setter
-    def shared(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._shared = value
+    @precision.setter
+    def precision(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._precision = value
         else:
             raise TypeError(
-                'Property "shared" of type "list<bool>" set to wrong type'
+                'Property "precision" of type "list<PrecisionTypeEnum>" set t'
+                'o wrong type'
             )
 
     @property
-    def sharedWith(self):
-        """list: List of teams this resource is shared with."""
-        return self._sharedWith
+    def publicDatasetUsed(self):
+        """ """
+        return self._publicDatasetUsed
 
-    @sharedWith.setter
-    def sharedWith(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._sharedWith = value
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "sharedWith" of type "list<str>" set to wrong type'
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
+                'wrong type'
             )
 
     @property
-    def sizeInBytes(self):
-        """long: Space used by the resource in bytes"""
-        return self._sizeInBytes
+    def publisher(self):
+        """str: organization that published the recipe"""
+        return self._publisher
 
-    @sizeInBytes.setter
-    def sizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._sizeInBytes = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
-                'e'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """StorageResourceStatusEnum: Indicates the current status of a storag
-        e resource (dataset,result, workspace)."""
-        return self._status
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "status" of type "list<StorageResourceStatusEnum>" '
-                'set to wrong type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def storageLocations(self):
-        """list: Storage locations of the storage resource"""
-        return self._storageLocations
+    def relatedModels(self):
+        """ """
+        return self._relatedModels
 
-    @storageLocations.setter
-    def storageLocations(self, value):
+    @relatedModels.setter
+    def relatedModels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._storageLocations = value
+            self._relatedModels = value
+        else:
+            raise TypeError(
+                'Property "relatedModels" of type "list<ModelSimplified>" set'
+                ' to wrong type'
+            )
+
+    @property
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
+
+    @setup.setter
+    def setup(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._setup = value
         else:
             raise TypeError(
-                'Property "storageLocations" of type "list<StorageLocation>" '
-                'set to wrong type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
-    def updatedDate(self):
-        """str: Resource update date in ISO-8601 format"""
-        return self._updatedDate
+    def shortDescription(self):
+        """str: Short description of the recipe"""
+        return self._shortDescription
 
-    @updatedDate.setter
-    def updatedDate(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
+            )
+
+    @property
+    def trainingFramework(self):
+        """ """
+        return self._trainingFramework
+
+    @trainingFramework.setter
+    def trainingFramework(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._trainingFramework = value
+        else:
+            raise TypeError(
+                'Property "trainingFramework" of type "list<FrameworkTypeEnum'
+                '>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._aceStorageServiceUrl is not None:
-            result["aceStorageServiceUrl"] = \
-                self._aceStorageServiceUrl
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._creatorUserId is not None:
-            result["creatorUserId"] = \
-                self._creatorUserId
-        if self._creatorUserName is not None:
-            result["creatorUserName"] = \
-                self._creatorUserName
+        if self._advanced is not None:
+            result["advanced"] = \
+                self._advanced
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._id is not None:
-            result["id"] = \
-                self._id
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
         if self._labels is not None:
             result["labels"] = \
                 self._labels
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._owned is not None:
-            result["owned"] = \
-                self._owned
-        if self._resourceNumericId is not None:
-            result["resourceNumericId"] = \
-                self._resourceNumericId
-        if self._shared is not None:
-            result["shared"] = \
-                self._shared
-        if self._sharedWith is not None:
-            result["sharedWith"] = \
-                self._sharedWith
-        if self._sizeInBytes is not None:
-            result["sizeInBytes"] = \
-                self._sizeInBytes
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._storageLocations:
-            result["storageLocations"] = [
-                i.toDict() for i in self._storageLocations 
-            ] if self._storageLocations else []
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._relatedModels:
+            result["relatedModels"] = [
+                i.toDict() for i in self._relatedModels 
+            ] if self._relatedModels else []
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._trainingFramework is not None:
+            result["trainingFramework"] = \
+                self._trainingFramework
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._id is not None
+        if (self._modelFormat is not None
+            and
+            len(self._modelFormat) > 255):
+            raise ValueError(
+                "RecipeUpdateRequest.modelFormat: " + str(self._modelFormat) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._shortDescription is not None
+            and
+            len(self._shortDescription) > 255):
+            raise ValueError(
+                "RecipeUpdateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
+            and
+            len(self._displayName) < 2):
+            raise ValueError(
+                "RecipeUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
             and
-            not re.match(
-                r"^(?![-_])[a-zA-Z0-9_-]{22}$",
-                 self._id)):
+            len(self._displayName) > 64):
             raise ValueError(
-                "StorageResource.id: " + str(self._id) + 
-                " doesnt match requirement: pattern: ^(?![-_])[a-zA-Z0-9_-]{2"
-                "2}$")
-        if (self._name is not None
+                "RecipeUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._logo is not None
             and
-            not re.match(
-                r"^(?![-_])(?![a-zA-Z0-9_-]{22}$)[a-zA-Z0-9_-]*$",
-                 self._name)):
+            len(self._logo) > 255):
             raise ValueError(
-                "StorageResource.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^(?![-_])(?![a-zA-Z0-9_-"
-                "]{22}$)[a-zA-Z0-9_-]*$")
-        if (self._createdDate is not None
+                "RecipeUpdateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._builtBy is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._builtBy) > 255):
             raise ValueError(
-                "StorageResource.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
+                "RecipeUpdateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
+            len(self._publisher) > 255):
             raise ValueError(
-                "StorageResource.updatedDate: " + str(self._updatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._storageLocations is not None):
-            for obj in self._storageLocations:
+                "RecipeUpdateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
+        if (self._relatedModels is not None):
+            for obj in self._relatedModels:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageServiceConfig.py` & `ngcbpc/data/model/CollectionPublishRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,144 +6,160 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageServiceConfigDetails import StorageServiceConfigDetails
+from .AccessTypeEnum import AccessTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
 
 # Unused import over optimization prevention
-str(repr(StorageServiceConfigDetails))
+str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageServiceConfig(object):
+class CollectionPublishRequest(object):
+    """Request to publish a collection"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.datasets = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "datasets"
+                "accessType"
             ) is None
-            else propDict["datasets"])
-        self.defaultConfig = (
+            else propDict["accessType"])
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "defaultConfig"
+                "canGuestPull"
             ) is None
-            else propDict["defaultConfig"])
-        self.resultsets = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "resultsets"
+                "canPublicList"
             ) is None
-            else propDict["resultsets"])
-        self.workspaces = (
+            else propDict["canPublicList"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "workspaces"
+                "isPublic"
             ) is None
-            else propDict["workspaces"])
+            else propDict["isPublic"])
+        self.productNames = (
+            None if not fromDict or propDict.get(
+                "productNames"
+            ) is None
+            else propDict["productNames"])
 
     @property
-    def datasets(self):
+    def accessType(self):
         """ """
-        return self._datasets
+        return self._accessType
 
-    @datasets.setter
-    def datasets(self, value):
-        if value is not None and not isinstance(value, StorageServiceConfigDetails):
-            value = StorageServiceConfigDetails(value)
-        if (value is None) or isinstance(value, StorageServiceConfigDetails):
-            self._datasets = value
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "datasets" of type "list<StorageServiceConfigDetail'
-                's>" set to wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def defaultConfig(self):
+    def canGuestPull(self):
         """ """
-        return self._defaultConfig
+        return self._canGuestPull
 
-    @defaultConfig.setter
-    def defaultConfig(self, value):
-        if value is not None and not isinstance(value, StorageServiceConfigDetails):
-            value = StorageServiceConfigDetails(value)
-        if (value is None) or isinstance(value, StorageServiceConfigDetails):
-            self._defaultConfig = value
+    @canGuestPull.setter
+    def canGuestPull(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "defaultConfig" of type "list<StorageServiceConfigD'
-                'etails>" set to wrong type'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def resultsets(self):
+    def canPublicList(self):
         """ """
-        return self._resultsets
+        return self._canPublicList
 
-    @resultsets.setter
-    def resultsets(self, value):
-        if value is not None and not isinstance(value, StorageServiceConfigDetails):
-            value = StorageServiceConfigDetails(value)
-        if (value is None) or isinstance(value, StorageServiceConfigDetails):
-            self._resultsets = value
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "resultsets" of type "list<StorageServiceConfigDeta'
-                'ils>" set to wrong type'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def workspaces(self):
+    def isPublic(self):
         """ """
-        return self._workspaces
+        return self._isPublic
+
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
+        else:
+            raise TypeError(
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
 
-    @workspaces.setter
-    def workspaces(self, value):
-        if value is not None and not isinstance(value, StorageServiceConfigDetails):
-            value = StorageServiceConfigDetails(value)
-        if (value is None) or isinstance(value, StorageServiceConfigDetails):
-            self._workspaces = value
+    @property
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
+
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "workspaces" of type "list<StorageServiceConfigDeta'
-                'ils>" set to wrong type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._datasets:
-            result["datasets"] = \
-                self._datasets.toDict() if self._datasets is not None else None
-        if self._defaultConfig:
-            result["defaultConfig"] = \
-                self._defaultConfig.toDict() if self._defaultConfig is not None else None
-        if self._resultsets:
-            result["resultsets"] = \
-                self._resultsets.toDict() if self._resultsets is not None else None
-        if self._workspaces:
-            result["workspaces"] = \
-                self._workspaces.toDict() if self._workspaces is not None else None
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._defaultConfig is None:
-            raise ValueError(
-                "StorageServiceConfig.defaultConfig doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._datasets is not None): self._datasets.isValid()
-        if (self._resultsets is not None): self._resultsets.isValid()
-        if (self._workspaces is not None): self._workspaces.isValid()
-        if (self._defaultConfig is not None): self._defaultConfig.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageServiceConfigDetails.py` & `ngcbpc/data/model/ModelVersionUpdateRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,398 +6,342 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StorageEngineTypeEnum import StorageEngineTypeEnum
+from .VersionStatusEnum import VersionStatusEnum
+from .CustomMetricGroup import CustomMetricGroup
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(StorageEngineTypeEnum))
+str(repr(CustomMetricGroup))
+str(repr(ArtifactAttribute))
+str(repr(VersionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageServiceConfigDetails(object):
+class ModelVersionUpdateRequest(object):
+    """Request to create a new model version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.apiPort = (
+        self.accuracyReached = (
             None if not fromDict or propDict.get(
-                "apiPort"
+                "accuracyReached"
             ) is None
-            else propDict["apiPort"])
-        self.description = (
-            None if not fromDict or propDict.get(
-                "description"
-            ) is None
-            else propDict["description"])
-        self.destination = (
-            None if not fromDict or propDict.get(
-                "destination"
-            ) is None
-            else propDict["destination"])
-        self.grpcPort = (
-            None if not fromDict or propDict.get(
-                "grpcPort"
-            ) is None
-            else propDict["grpcPort"])
-        self.inboundHttpDisabled = (
-            None if not fromDict or propDict.get(
-                "inboundHttpDisabled"
-            ) is None
-            else propDict["inboundHttpDisabled"])
-        self.initialDefaultQuotaSizeGb = (
+            else propDict["accuracyReached"])
+        self.batchSize = (
             None if not fromDict or propDict.get(
-                "initialDefaultQuotaSizeGb"
+                "batchSize"
             ) is None
-            else propDict["initialDefaultQuotaSizeGb"])
-        self.isDefault = (
+            else propDict["batchSize"])
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "isDefault"
+                "customMetrics"
             ) is None
-            else propDict["isDefault"])
-        self.maxQuotaSizeGb = (
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "maxQuotaSizeGb"
+                "description"
             ) is None
-            else propDict["maxQuotaSizeGb"])
-        self.name = (
+            else propDict["description"])
+        self.gpuModel = (
             None if not fromDict or propDict.get(
-                "name"
+                "gpuModel"
             ) is None
-            else propDict["name"])
-        self.sftpPort = (
+            else propDict["gpuModel"])
+        self.memoryFootprint = (
             None if not fromDict or propDict.get(
-                "sftpPort"
+                "memoryFootprint"
             ) is None
-            else propDict["sftpPort"])
-        self.storageClusterUuid = (
+            else propDict["memoryFootprint"])
+        self.numberOfEpochs = (
             None if not fromDict or propDict.get(
-                "storageClusterUuid"
+                "numberOfEpochs"
             ) is None
-            else propDict["storageClusterUuid"])
-        self.storageLocation = (
+            else propDict["numberOfEpochs"])
+        self.otherContents = (
             None if not fromDict or propDict.get(
-                "storageLocation"
+                "otherContents"
             ) is None
-            else propDict["storageLocation"])
-        self.storageMountPrefix = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["otherContents"] ])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "storageMountPrefix"
+                "ownerName"
             ) is None
-            else propDict["storageMountPrefix"])
-        self.type = (
+            else propDict["ownerName"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "type"
+                "status"
             ) is None
-            else propDict["type"])
-
-    @property
-    def apiPort(self):
-        """int: Port number for routing API traffic to the storage cluster."""
-        return self._apiPort
-
-    @apiPort.setter
-    def apiPort(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._apiPort = value
-        else:
-            raise TypeError(
-                'Property "apiPort" of type "list<int>" set to wrong type'
-            )
-
-    @property
-    def description(self):
-        """str: Full description about this storage cluster. eg. NetApp SJC4 .
-        .."""
-        return self._description
-
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
-        else:
-            raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
-            )
+            else propDict["status"])
 
     @property
-    def destination(self):
-        """str: Storage Service URL fo this resource type"""
-        return self._destination
+    def accuracyReached(self):
+        """float: Accuracy this model reached"""
+        return self._accuracyReached
 
-    @destination.setter
-    def destination(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._destination = value
+    @accuracyReached.setter
+    def accuracyReached(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._accuracyReached = value
         else:
             raise TypeError(
-                'Property "destination" of type "list<str>" set to wrong type'
+                'Property "accuracyReached" of type "list<float>" set to wron'
+                'g type'
             )
 
     @property
-    def grpcPort(self):
-        """int: Port number for routing GRPC traffic to the storage cluster.
-        """
-        return self._grpcPort
-
-    @grpcPort.setter
-    def grpcPort(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._grpcPort = value
-        else:
-            raise TypeError(
-                'Property "grpcPort" of type "list<int>" set to wrong type'
-            )
+    def batchSize(self):
+        """long: Batch size this model was trained with"""
+        return self._batchSize
 
-    @property
-    def inboundHttpDisabled(self):
-        """bool: If set to true, all communication to FSS on this cluster will
-         be via kafka. This will be used in superPod"""
-        return self._inboundHttpDisabled
-
-    @inboundHttpDisabled.setter
-    def inboundHttpDisabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._inboundHttpDisabled = value
-        else:
-            raise TypeError(
-                'Property "inboundHttpDisabled" of type "list<bool>" set to w'
-                'rong type'
-            )
-
-    @property
-    def initialDefaultQuotaSizeGb(self):
-        """long: When provisioning storage quota for new user, how much initia
-        l GB to be provisioned"""
-        return self._initialDefaultQuotaSizeGb
-
-    @initialDefaultQuotaSizeGb.setter
-    def initialDefaultQuotaSizeGb(self, value):
+    @batchSize.setter
+    def batchSize(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._initialDefaultQuotaSizeGb = value
+            self._batchSize = value
         else:
             raise TypeError(
-                'Property "initialDefaultQuotaSizeGb" of type "list<long>" se'
-                't to wrong type'
+                'Property "batchSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def isDefault(self):
-        """bool: For multiple storage in an ACE, is this storage service the d
-        efault one"""
-        return self._isDefault
-
-    @isDefault.setter
-    def isDefault(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isDefault = value
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
+
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
         else:
             raise TypeError(
-                'Property "isDefault" of type "list<bool>" set to wrong type'
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
             )
 
     @property
-    def maxQuotaSizeGb(self):
-        """long: Maximum quota allowed when increasing quota"""
-        return self._maxQuotaSizeGb
+    def description(self):
+        """str: Description of the model version"""
+        return self._description
 
-    @maxQuotaSizeGb.setter
-    def maxQuotaSizeGb(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._maxQuotaSizeGb = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "maxQuotaSizeGb" of type "list<long>" set to wrong '
-                'type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Human readable name for this storage cluster"""
-        return self._name
+    def gpuModel(self):
+        """str: GPU model and memory"""
+        return self._gpuModel
 
-    @name.setter
-    def name(self, value):
+    @gpuModel.setter
+    def gpuModel(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._gpuModel = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sftpPort(self):
-        """int: Port number for routing sftp traffic to the storage cluster.
-        """
-        return self._sftpPort
-
-    @sftpPort.setter
-    def sftpPort(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._sftpPort = value
+    def memoryFootprint(self):
+        """str: Model size/memory footprint for inference"""
+        return self._memoryFootprint
+
+    @memoryFootprint.setter
+    def memoryFootprint(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._memoryFootprint = value
         else:
             raise TypeError(
-                'Property "sftpPort" of type "list<int>" set to wrong type'
+                'Property "memoryFootprint" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def storageClusterUuid(self):
-        """str: Storage Cluster unique UUID."""
-        return self._storageClusterUuid
+    def numberOfEpochs(self):
+        """long: Number of epochs this model trained"""
+        return self._numberOfEpochs
 
-    @storageClusterUuid.setter
-    def storageClusterUuid(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._storageClusterUuid = value
+    @numberOfEpochs.setter
+    def numberOfEpochs(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._numberOfEpochs = value
         else:
             raise TypeError(
-                'Property "storageClusterUuid" of type "list<str>" set to wro'
-                'ng type'
+                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def storageLocation(self):
-        """str: The IP of the storage locations"""
-        return self._storageLocation
+    def otherContents(self):
+        """list: List of external contents"""
+        return self._otherContents
 
-    @storageLocation.setter
-    def storageLocation(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._storageLocation = value
+    @otherContents.setter
+    def otherContents(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._otherContents = value
         else:
             raise TypeError(
-                'Property "storageLocation" of type "list<str>" set to wrong '
-                'type'
+                'Property "otherContents" of type "list<ArtifactAttribute>" s'
+                'et to wrong type'
             )
 
     @property
-    def storageMountPrefix(self):
-        """str: The prefix of the mount eg. 192.168.0.1:/vol where /vol is you
-        r prefix"""
-        return self._storageMountPrefix
+    def ownerName(self):
+        """str: Name of the user who owns this version"""
+        return self._ownerName
 
-    @storageMountPrefix.setter
-    def storageMountPrefix(self, value):
+    @ownerName.setter
+    def ownerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageMountPrefix = value
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "storageMountPrefix" of type "list<str>" set to wro'
-                'ng type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """StorageEngineTypeEnum: All possible storage engine type enums"""
-        return self._type
+    def status(self):
+        """VersionStatusEnum: Version status"""
+        return self._status
 
-    @type.setter
-    def type(self, value):
+    @status.setter
+    def status(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+            self._status = value
         else:
             raise TypeError(
-                'Property "type" of type "list<StorageEngineTypeEnum>" set to'
-                ' wrong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
     def toDict(self):
         result = {}
-        if self._apiPort is not None:
-            result["apiPort"] = \
-                self._apiPort
+        if self._accuracyReached is not None:
+            result["accuracyReached"] = \
+                self._accuracyReached
+        if self._batchSize is not None:
+            result["batchSize"] = \
+                self._batchSize
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._destination is not None:
-            result["destination"] = \
-                self._destination
-        if self._grpcPort is not None:
-            result["grpcPort"] = \
-                self._grpcPort
-        if self._inboundHttpDisabled is not None:
-            result["inboundHttpDisabled"] = \
-                self._inboundHttpDisabled
-        if self._initialDefaultQuotaSizeGb is not None:
-            result["initialDefaultQuotaSizeGb"] = \
-                self._initialDefaultQuotaSizeGb
-        if self._isDefault is not None:
-            result["isDefault"] = \
-                self._isDefault
-        if self._maxQuotaSizeGb is not None:
-            result["maxQuotaSizeGb"] = \
-                self._maxQuotaSizeGb
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._sftpPort is not None:
-            result["sftpPort"] = \
-                self._sftpPort
-        if self._storageClusterUuid is not None:
-            result["storageClusterUuid"] = \
-                self._storageClusterUuid
-        if self._storageLocation is not None:
-            result["storageLocation"] = \
-                self._storageLocation
-        if self._storageMountPrefix is not None:
-            result["storageMountPrefix"] = \
-                self._storageMountPrefix
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._gpuModel is not None:
+            result["gpuModel"] = \
+                self._gpuModel
+        if self._memoryFootprint is not None:
+            result["memoryFootprint"] = \
+                self._memoryFootprint
+        if self._numberOfEpochs is not None:
+            result["numberOfEpochs"] = \
+                self._numberOfEpochs
+        if self._otherContents:
+            result["otherContents"] = [
+                i.toDict() for i in self._otherContents 
+            ] if self._otherContents else []
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._destination is None:
+        if (self._description is not None
+            and
+            len(self._description) > 255):
             raise ValueError(
-                "StorageServiceConfigDetails.destination doesnt match requirement:" 
-                "required: True"
-            )
-        if self._type is None:
+                "ModelVersionUpdateRequest.description: " + str(self._description) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._ownerName is not None
+            and
+            len(self._ownerName) > 255):
             raise ValueError(
-                "StorageServiceConfigDetails.type doesnt match requirement:" 
-                "required: True"
-            )
-        if self._storageLocation is None:
+                "ModelVersionUpdateRequest.ownerName: " + str(self._ownerName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached < 0):
             raise ValueError(
-                "StorageServiceConfigDetails.storageLocation doesnt match requirement:" 
-                "required: True"
-            )
+                "ModelVersionUpdateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached > 100):
+            raise ValueError(
+                "ModelVersionUpdateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: maximum: 100")
+        if (self._numberOfEpochs is not None
+            and
+            self._numberOfEpochs < 0):
+            raise ValueError(
+                "ModelVersionUpdateRequest.numberOfEpochs: " + str(self._numberOfEpochs) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._gpuModel is not None
+            and
+            len(self._gpuModel) > 255):
+            raise ValueError(
+                "ModelVersionUpdateRequest.gpuModel: " + str(self._gpuModel) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._batchSize is not None
+            and
+            self._batchSize < 0):
+            raise ValueError(
+                "ModelVersionUpdateRequest.batchSize: " + str(self._batchSize) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._memoryFootprint is not None
+            and
+            len(self._memoryFootprint) > 255):
+            raise ValueError(
+                "ModelVersionUpdateRequest.memoryFootprint: " + str(self._memoryFootprint) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
+                if (obj is not None): obj.isValid()
+        if (self._otherContents is not None):
+            for obj in self._otherContents:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/StorageYarofsInfo.py` & `ngcbpc/data/registry/PolicyRule.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,158 +6,163 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .AnchoreParameter import AnchoreParameter
 
 # Unused import over optimization prevention
+str(repr(AnchoreParameter))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class StorageYarofsInfo(object):
-    """Describes the arguments needed for mounting YaroFS volumes"""
+class PolicyRule(object):
+    """A rule that defines and decision value if the match is found true for a
+     given image."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.imageUrl = (
+        self.action = (
             None if not fromDict or propDict.get(
-                "imageUrl"
+                "action"
             ) is None
-            else propDict["imageUrl"])
-        self.useInnerRingCache = (
+            else propDict["action"])
+        self.gate = (
             None if not fromDict or propDict.get(
-                "useInnerRingCache"
+                "gate"
             ) is None
-            else propDict["useInnerRingCache"])
-        self.useYaroFSCache = (
+            else propDict["gate"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "useYaroFSCache"
+                "id"
             ) is None
-            else propDict["useYaroFSCache"])
-        self.yarofsCacheBcount = (
+            else propDict["id"])
+        self.params = (
             None if not fromDict or propDict.get(
-                "yarofsCacheBcount"
+                "params"
             ) is None
-            else propDict["yarofsCacheBcount"])
-        self.yarofsCacheBsize = (
+            else [ AnchoreParameter(i)
+            for i in propDict["params"] ])
+        self.trigger = (
             None if not fromDict or propDict.get(
-                "yarofsCacheBsize"
+                "trigger"
             ) is None
-            else propDict["yarofsCacheBsize"])
+            else propDict["trigger"])
 
     @property
-    def imageUrl(self):
-        """str: disk-image URL to be used for this dataset"""
-        return self._imageUrl
+    def action(self):
+        """ """
+        return self._action
 
-    @imageUrl.setter
-    def imageUrl(self, value):
+    @action.setter
+    def action(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._imageUrl = value
+            self._action = value
         else:
             raise TypeError(
-                'Property "imageUrl" of type "list<str>" set to wrong type'
+                'Property "action" of type "list<str>" set to wrong type'
             )
 
     @property
-    def useInnerRingCache(self):
-        """bool: Flag to use Inner ring cache"""
-        return self._useInnerRingCache
-
-    @useInnerRingCache.setter
-    def useInnerRingCache(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useInnerRingCache = value
+    def gate(self):
+        """ """
+        return self._gate
+
+    @gate.setter
+    def gate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gate = value
         else:
             raise TypeError(
-                'Property "useInnerRingCache" of type "list<bool>" set to wro'
-                'ng type'
+                'Property "gate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def useYaroFSCache(self):
-        """bool: Flag to use YaroFS memory cache"""
-        return self._useYaroFSCache
-
-    @useYaroFSCache.setter
-    def useYaroFSCache(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._useYaroFSCache = value
+    def id(self):
+        """ """
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "useYaroFSCache" of type "list<bool>" set to wrong '
-                'type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def yarofsCacheBcount(self):
-        """int: YaroFS Cache block count (useYaroFSCache must be true)"""
-        return self._yarofsCacheBcount
-
-    @yarofsCacheBcount.setter
-    def yarofsCacheBcount(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._yarofsCacheBcount = value
+    def params(self):
+        """ """
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._params = value
         else:
             raise TypeError(
-                'Property "yarofsCacheBcount" of type "list<int>" set to wron'
-                'g type'
+                'Property "params" of type "list<AnchoreParameter>" set to wr'
+                'ong type'
             )
 
     @property
-    def yarofsCacheBsize(self):
-        """int: YaroFS Cache block size (useYaroFSCache must be true)"""
-        return self._yarofsCacheBsize
-
-    @yarofsCacheBsize.setter
-    def yarofsCacheBsize(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._yarofsCacheBsize = value
+    def trigger(self):
+        """ """
+        return self._trigger
+
+    @trigger.setter
+    def trigger(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._trigger = value
         else:
             raise TypeError(
-                'Property "yarofsCacheBsize" of type "list<int>" set to wrong'
-                ' type'
+                'Property "trigger" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._imageUrl is not None:
-            result["imageUrl"] = \
-                self._imageUrl
-        if self._useInnerRingCache is not None:
-            result["useInnerRingCache"] = \
-                self._useInnerRingCache
-        if self._useYaroFSCache is not None:
-            result["useYaroFSCache"] = \
-                self._useYaroFSCache
-        if self._yarofsCacheBcount is not None:
-            result["yarofsCacheBcount"] = \
-                self._yarofsCacheBcount
-        if self._yarofsCacheBsize is not None:
-            result["yarofsCacheBsize"] = \
-                self._yarofsCacheBsize
+        if self._action is not None:
+            result["action"] = \
+                self._action
+        if self._gate is not None:
+            result["gate"] = \
+                self._gate
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._params:
+            result["params"] = [
+                i.toDict() for i in self._params 
+            ] if self._params else []
+        if self._trigger is not None:
+            result["trigger"] = \
+                self._trigger
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._params is not None):
+            for obj in self._params:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/SuggestedNamesResponse.py` & `ngcbpc/data/uis/GetUchIdByOrgResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -16,44 +16,28 @@
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SuggestedNamesResponse(object):
-    """Response containing a list of suggested names"""
+class GetUchIdByOrgResponse(object):
+    """Get uch Id by org response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.names = (
-            None if not fromDict or propDict.get(
-                "names"
-            ) is None
-            else propDict["names"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def names(self):
-        """list: list of suggested names"""
-        return self._names
-
-    @names.setter
-    def names(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._names = value
-        else:
-            raise TypeError(
-                'Property "names" of type "list<str>" set to wrong type'
-            )
+        self.uchId = (
+            None if not fromDict or propDict.get(
+                "uchId"
+            ) is None
+            else propDict["uchId"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -64,22 +48,38 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def uchId(self):
+        """ """
+        return self._uchId
+
+    @uchId.setter
+    def uchId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uchId = value
+        else:
+            raise TypeError(
+                'Property "uchId" of type "list<str>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._names is not None:
-            result["names"] = \
-                self._names
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._uchId is not None:
+            result["uchId"] = \
+                self._uchId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/SystemLabels.py` & `ngcbpc/data/model/HealthResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,58 +6,63 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Health import Health
 
 # Unused import over optimization prevention
+str(repr(Health))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class SystemLabels(object):
-    """System labels specified by admin"""
+class HealthResponse(object):
+    """This API is invoked by monitoring tools, other services and infrastruct
+    ure to retrieve health status the targeted service, this is unprotecte
+    d method"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.values = (
+        self.health = (
             None if not fromDict or propDict.get(
-                "values"
+                "health"
             ) is None
-            else propDict["values"])
+            else propDict["health"])
 
     @property
-    def values(self):
-        """list: An array of system labels that describe this job"""
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._values = value
+    def health(self):
+        """Health: object that describes health of the service"""
+        return self._health
+
+    @health.setter
+    def health(self, value):
+        if value is not None and not isinstance(value, Health):
+            value = Health(value)
+        if (value is None) or isinstance(value, Health):
+            self._health = value
         else:
             raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "health" of type "list<Health>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._health:
+            result["health"] = \
+                self._health.toDict() if self._health is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._health is not None): self._health.isValid()
         return True
```

## Comparing `ngccli/data/api/TargetSystemUserIdentifier.py` & `ngcbpc/data/uis/IdpLock.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,194 +14,214 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TargetSystemUserIdentifier(object):
-    """Information about the user who is attempting to run the job"""
+class IdpLock(object):
+    """Information about the IDP lock for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.gid = (
+        self.createdBy = (
             None if not fromDict or propDict.get(
-                "gid"
+                "createdBy"
             ) is None
-            else propDict["gid"])
-        self.orgName = (
+            else propDict["createdBy"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "createdDate"
             ) is None
-            else propDict["orgName"])
-        self.starfleetId = (
+            else propDict["createdDate"])
+        self.idpId = (
+            None if not fromDict or propDict.get(
+                "idpId"
+            ) is None
+            else propDict["idpId"])
+        self.locked = (
             None if not fromDict or propDict.get(
-                "starfleetId"
+                "locked"
             ) is None
-            else propDict["starfleetId"])
-        self.teamName = (
+            else propDict["locked"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "teamName"
+                "orgName"
             ) is None
-            else propDict["teamName"])
-        self.uid = (
+            else propDict["orgName"])
+        self.updatedBy = (
             None if not fromDict or propDict.get(
-                "uid"
+                "updatedBy"
             ) is None
-            else propDict["uid"])
-        self.userId = (
+            else propDict["updatedBy"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "userId"
+                "updatedDate"
             ) is None
-            else propDict["userId"])
+            else propDict["updatedDate"])
 
     @property
-    def gid(self):
-        """long: gid of the user on this team"""
-        return self._gid
+    def createdBy(self):
+        """str: Email of user creating the lock"""
+        return self._createdBy
 
-    @gid.setter
-    def gid(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._gid = value
+    @createdBy.setter
+    def createdBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdBy = value
         else:
             raise TypeError(
-                'Property "gid" of type "list<long>" set to wrong type'
+                'Property "createdBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: Org context for the job"""
-        return self._orgName
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @orgName.setter
-    def orgName(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def starfleetId(self):
-        """str: Starfleet ID of the user creating the job."""
-        return self._starfleetId
+    def idpId(self):
+        """str: Unique IDP ID"""
+        return self._idpId
 
-    @starfleetId.setter
-    def starfleetId(self, value):
+    @idpId.setter
+    def idpId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._starfleetId = value
+            self._idpId = value
         else:
             raise TypeError(
-                'Property "starfleetId" of type "list<str>" set to wrong type'
+                'Property "idpId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def teamName(self):
-        """str: Team context for the job"""
-        return self._teamName
+    def locked(self):
+        """bool: Indicates if the IDP is locked for the organization"""
+        return self._locked
 
-    @teamName.setter
-    def teamName(self, value):
+    @locked.setter
+    def locked(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._locked = value
+        else:
+            raise TypeError(
+                'Property "locked" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def orgName(self):
+        """str: Organization name"""
+        return self._orgName
+
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def uid(self):
-        """long: uid of the user on this team"""
-        return self._uid
+    def updatedBy(self):
+        """str: Email of user updating the lock"""
+        return self._updatedBy
 
-    @uid.setter
-    def uid(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._uid = value
+    @updatedBy.setter
+    def updatedBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedBy = value
         else:
             raise TypeError(
-                'Property "uid" of type "list<long>" set to wrong type'
+                'Property "updatedBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def userId(self):
-        """long: Unique ID of the user who submitted the job"""
-        return self._userId
+    def updatedDate(self):
+        """str: Update date in ISO-8601 format"""
+        return self._updatedDate
 
-    @userId.setter
-    def userId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._userId = value
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "userId" of type "list<long>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._gid is not None:
-            result["gid"] = \
-                self._gid
+        if self._createdBy is not None:
+            result["createdBy"] = \
+                self._createdBy
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._idpId is not None:
+            result["idpId"] = \
+                self._idpId
+        if self._locked is not None:
+            result["locked"] = \
+                self._locked
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
-        if self._starfleetId is not None:
-            result["starfleetId"] = \
-                self._starfleetId
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
-        if self._uid is not None:
-            result["uid"] = \
-                self._uid
-        if self._userId is not None:
-            result["userId"] = \
-                self._userId
+        if self._updatedBy is not None:
+            result["updatedBy"] = \
+                self._updatedBy
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._uid is not None
-            and
-            self._uid < 1):
+        if self._orgName is None:
             raise ValueError(
-                "TargetSystemUserIdentifier.uid: " + str(self._uid) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._uid is not None
-            and
-            self._uid > 4294967296):
+                "IdpLock.orgName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._idpId is None:
             raise ValueError(
-                "TargetSystemUserIdentifier.uid: " + str(self._uid) + 
-                " doesnt match requirement: maximum: 4294967296")
-        if (self._gid is not None
-            and
-            self._gid < 1):
+                "IdpLock.idpId doesnt match requirement:" 
+                "required: True"
+            )
+        if self._locked is None:
             raise ValueError(
-                "TargetSystemUserIdentifier.gid: " + str(self._gid) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._gid is not None
-            and
-            self._gid > 4294967296):
+                "IdpLock.locked doesnt match requirement:" 
+                "required: True"
+            )
+        if self._createdDate is None:
             raise ValueError(
-                "TargetSystemUserIdentifier.gid: " + str(self._gid) + 
-                " doesnt match requirement: maximum: 4294967296")
+                "IdpLock.createdDate doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/Team.py` & `ngcbpc/data/uis/Team.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/TeamCreateResponse.py` & `ngcbpc/data/model/ArtifactResponse.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,89 +6,90 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Team import Team
 from .RequestStatus import RequestStatus
+from .Artifact import Artifact
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Team))
+str(repr(Artifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TeamCreateResponse(object):
-    """response to an team creation request, includes unique team id"""
+class ArtifactResponse(object):
+    """Response to artifact request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.artifact = (
+            None if not fromDict or propDict.get(
+                "artifact"
+            ) is None
+            else propDict["artifact"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.team = (
-            None if not fromDict or propDict.get(
-                "team"
-            ) is None
-            else propDict["team"])
+
+    @property
+    def artifact(self):
+        """Artifact: Artifact object"""
+        return self._artifact
+
+    @artifact.setter
+    def artifact(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._artifact = value
+        else:
+            raise TypeError(
+                'Property "artifact" of type "list<Artifact>" set to wrong ty'
+                'pe'
+            )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def team(self):
-        """Team: Information about the team"""
-        return self._team
-
-    @team.setter
-    def team(self, value):
-        if value is not None and not isinstance(value, Team):
-            value = Team(value)
-        if (value is None) or isinstance(value, Team):
-            self._team = value
-        else:
-            raise TypeError(
-                'Property "team" of type "list<Team>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._artifact:
+            result["artifact"] = \
+                self._artifact.toDict() if self._artifact is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._team:
-            result["team"] = \
-                self._team.toDict() if self._team is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._team is not None): self._team.isValid()
+        if (self._artifact is not None): self._artifact.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/TeamCreatedEvent.py` & `ngcbpc/data/model/AssetSimplified.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,53 +14,53 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TeamCreatedEvent(object):
+class AssetSimplified(object):
+    """Asset object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.actorStarfleetId = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "actorStarfleetId"
+                "name"
             ) is None
-            else propDict["actorStarfleetId"])
+            else propDict["name"])
         self.orgName = (
             None if not fromDict or propDict.get(
                 "orgName"
             ) is None
             else propDict["orgName"])
         self.teamName = (
             None if not fromDict or propDict.get(
                 "teamName"
             ) is None
             else propDict["teamName"])
 
     @property
-    def actorStarfleetId(self):
-        """str: StarfleetId of actor"""
-        return self._actorStarfleetId
+    def name(self):
+        """str: Unique name of the asset"""
+        return self._name
 
-    @actorStarfleetId.setter
-    def actorStarfleetId(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._actorStarfleetId = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "actorStarfleetId" of type "list<str>" set to wrong'
-                ' type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
     def orgName(self):
-        """str: Unique identifier of the org"""
+        """str: Name of the org that the asset belongs to"""
         return self._orgName
 
     @orgName.setter
     def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -68,15 +68,15 @@
         else:
             raise TypeError(
                 'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
     def teamName(self):
-        """str: Unique identifier of the team"""
+        """str: Name of the team that the asset belongs to"""
         return self._teamName
 
     @teamName.setter
     def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -84,17 +84,17 @@
         else:
             raise TypeError(
                 'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._actorStarfleetId is not None:
-            result["actorStarfleetId"] = \
-                self._actorStarfleetId
+        if self._name is not None:
+            result["name"] = \
+                self._name
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
         if self._teamName is not None:
             result["teamName"] = \
                 self._teamName
         return result
@@ -102,10 +102,20 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "AssetSimplified.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._orgName is None:
+            raise ValueError(
+                "AssetSimplified.orgName doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/TeamListResponse.py` & `ngcbpc/data/uis/UserInvitationListResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -7,47 +7,64 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .Team import Team
 from .RequestStatus import RequestStatus
+from .UserInvitation import UserInvitation
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
 str(repr(PaginationInfo))
-str(repr(Team))
+str(repr(RequestStatus))
+str(repr(UserInvitation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TeamListResponse(object):
-    """listing of all teams"""
+class UserInvitationListResponse(object):
+    """Response for a list of user invitations."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.invitations = (
+            None if not fromDict or propDict.get(
+                "invitations"
+            ) is None
+            else [ UserInvitation(i)
+            for i in propDict["invitations"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.teams = (
-            None if not fromDict or propDict.get(
-                "teams"
-            ) is None
-            else [ Team(i)
-            for i in propDict["teams"] ])
+
+    @property
+    def invitations(self):
+        """list: List of invitations."""
+        return self._invitations
+
+    @invitations.setter
+    def invitations(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._invitations = value
+        else:
+            raise TypeError(
+                'Property "invitations" of type "list<UserInvitation>" set to'
+                ' wrong type'
+            )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
@@ -75,52 +92,36 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def teams(self):
-        """ """
-        return self._teams
-
-    @teams.setter
-    def teams(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._teams = value
-        else:
-            raise TypeError(
-                'Property "teams" of type "list<Team>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._invitations:
+            result["invitations"] = [
+                i.toDict() for i in self._invitations 
+            ] if self._invitations else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._teams:
-            result["teams"] = [
-                i.toDict() for i in self._teams 
-            ] if self._teams else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._teams is not None):
-            for obj in self._teams:
+        if (self._invitations is not None):
+            for obj in self._invitations:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/TeamResponse.py` & `ngcbpc/data/uis/ListRolesResponse.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,40 +6,38 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Team import Team
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TeamResponse(object):
-    """details about one team"""
+class ListRolesResponse(object):
+    """List roles for a user-org-team response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.team = (
+        self.roles = (
             None if not fromDict or propDict.get(
-                "team"
+                "roles"
             ) is None
-            else propDict["team"])
+            else propDict["roles"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -51,44 +49,44 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def team(self):
-        """Team: Information about the team"""
-        return self._team
-
-    @team.setter
-    def team(self, value):
-        if value is not None and not isinstance(value, Team):
-            value = Team(value)
-        if (value is None) or isinstance(value, Team):
-            self._team = value
+    def roles(self):
+        """list: A list of roles that belongs to the user in requesting user-o
+        rganization-team"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "team" of type "list<Team>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._team:
-            result["team"] = \
-                self._team.toDict() if self._team is not None else None
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._team is not None): self._team.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/TeamUpdateRequest.py` & `ngcbpc/data/uis/TeamUpdateRequest.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/TelemetryClientCreateResponse.py` & `ngcbpc/data/model/ArtifactDownloadResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -16,101 +16,105 @@
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TelemetryClientCreateResponse(object):
-    """Information about telemetry client"""
+class ArtifactDownloadResponse(object):
+    """Response body to download a single file of an artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.authClientId = (
+        self.filepath = (
             None if not fromDict or propDict.get(
-                "authClientId"
+                "filepath"
             ) is None
-            else propDict["authClientId"])
-        self.authSecret = (
-            None if not fromDict or propDict.get(
-                "authSecret"
-            ) is None
-            else propDict["authSecret"])
+            else propDict["filepath"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.url = (
+            None if not fromDict or propDict.get(
+                "url"
+            ) is None
+            else propDict["url"])
 
     @property
-    def authClientId(self):
-        """str: AuthN client id"""
-        return self._authClientId
-
-    @authClientId.setter
-    def authClientId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._authClientId = value
-        else:
-            raise TypeError(
-                'Property "authClientId" of type "list<str>" set to wrong typ'
-                'e'
-            )
-
-    @property
-    def authSecret(self):
-        """str: AuthN secret"""
-        return self._authSecret
+    def filepath(self):
+        """str: The filepath of the artifact"""
+        return self._filepath
 
-    @authSecret.setter
-    def authSecret(self, value):
+    @filepath.setter
+    def filepath(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._authSecret = value
+            self._filepath = value
         else:
             raise TypeError(
-                'Property "authSecret" of type "list<str>" set to wrong type'
+                'Property "filepath" of type "list<str>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def url(self):
+        """str: Presigned url for single file download"""
+        return self._url
+
+    @url.setter
+    def url(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._url = value
+        else:
+            raise TypeError(
+                'Property "url" of type "list<str>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._authClientId is not None:
-            result["authClientId"] = \
-                self._authClientId
-        if self._authSecret is not None:
-            result["authSecret"] = \
-                self._authSecret
+        if self._filepath is not None:
+            result["filepath"] = \
+                self._filepath
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._url is not None:
+            result["url"] = \
+                self._url
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._url is None:
+            raise ValueError(
+                "ArtifactDownloadResponse.url doesnt match requirement:" 
+                "required: True"
+            )
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/TokenResponse.py` & `ngcbpc/data/uis/IdpRuleResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,37 +7,55 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
+from .IdpRule import IdpRule
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
+str(repr(IdpRule))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TokenResponse(object):
-    """Token response"""
+class IdpRuleResponse(object):
+    """Response containing info about the IDP rule CRUD operation"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.idpRule = (
+            None if not fromDict or propDict.get(
+                "idpRule"
+            ) is None
+            else propDict["idpRule"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.token = (
-            None if not fromDict or propDict.get(
-                "token"
-            ) is None
-            else propDict["token"])
+
+    @property
+    def idpRule(self):
+        """IdpRule: Information about the IDP rule"""
+        return self._idpRule
+
+    @idpRule.setter
+    def idpRule(self, value):
+        if value is not None and not isinstance(value, IdpRule):
+            value = IdpRule(value)
+        if (value is None) or isinstance(value, IdpRule):
+            self._idpRule = value
+        else:
+            raise TypeError(
+                'Property "idpRule" of type "list<IdpRule>" set to wrong type'
+            )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -48,44 +66,39 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def token(self):
-        """str: The Identity token for the user"""
-        return self._token
-
-    @token.setter
-    def token(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._token = value
-        else:
-            raise TypeError(
-                'Property "token" of type "list<str>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._idpRule:
+            result["idpRule"] = \
+                self._idpRule.toDict() if self._idpRule is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._token is not None:
-            result["token"] = \
-                self._token
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._requestStatus is None:
+            raise ValueError(
+                "IdpRuleResponse.requestStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if self._idpRule is None:
+            raise ValueError(
+                "IdpRuleResponse.idpRule doesnt match requirement:" 
+                "required: True"
+            )
         if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._idpRule is not None): self._idpRule.isValid()
         return True
```

## Comparing `ngccli/data/api/UpdateAceRequest.py` & `organization/data/sms/SecretGetResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,62 +6,99 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AceUpdate import AceUpdate
+from .Secret import Secret
 
 # Unused import over optimization prevention
-str(repr(AceUpdate))
+str(repr(Secret))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateAceRequest(object):
-    """object used to update information about the ACE"""
+class SecretGetResponse(object):
+    """Secret Fetch Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceUpdate = (
+        self.secrets = (
             None if not fromDict or propDict.get(
-                "aceUpdate"
+                "secrets"
             ) is None
-            else propDict["aceUpdate"])
+            else [ Secret(i)
+            for i in propDict["secrets"] ])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def aceUpdate(self):
+    def secrets(self):
         """ """
-        return self._aceUpdate
+        return self._secrets
 
-    @aceUpdate.setter
-    def aceUpdate(self, value):
-        if value is not None and not isinstance(value, AceUpdate):
-            value = AceUpdate(value)
-        if (value is None) or isinstance(value, AceUpdate):
-            self._aceUpdate = value
+    @secrets.setter
+    def secrets(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._secrets = value
         else:
             raise TypeError(
-                'Property "aceUpdate" of type "list<AceUpdate>" set to wrong '
-                'type'
+                'Property "secrets" of type "list<Secret>" set to wrong type'
+            )
+
+    @property
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
+        else:
+            raise TypeError(
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceUpdate:
-            result["aceUpdate"] = \
-                self._aceUpdate.toDict() if self._aceUpdate is not None else None
+        if self._secrets:
+            result["secrets"] = [
+                i.toDict() for i in self._secrets 
+            ] if self._secrets else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._aceUpdate is not None): self._aceUpdate.isValid()
+        if self._version is None:
+            raise ValueError(
+                "SecretGetResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._secrets is None:
+            raise ValueError(
+                "SecretGetResponse.secrets doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._secrets is not None):
+            for obj in self._secrets:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/UpdateNodeRequest.py` & `organization/data/subscription_management_service/CreateSubscriptionsRequest.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,82 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Subscription import Subscription
 
 # Unused import over optimization prevention
+str(repr(Subscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateNodeRequest(object):
-    """object used to update node information"""
+class CreateSubscriptionsRequest(object):
+    """Request for create subscription admin API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.productSubscriptions = (
             None if not fromDict or propDict.get(
-                "name"
+                "productSubscriptions"
             ) is None
-            else propDict["name"])
+            else [ Subscription(i)
+            for i in propDict["productSubscriptions"] ])
 
     @property
-    def name(self):
-        """str: hostname for the node"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def productSubscriptions(self):
+        """ """
+        return self._productSubscriptions
+
+    @productSubscriptions.setter
+    def productSubscriptions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productSubscriptions = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "productSubscriptions" of type "list<Subscription>"'
+                ' set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._productSubscriptions:
+            result["productSubscriptions"] = [
+                i.toDict() for i in self._productSubscriptions 
+            ] if self._productSubscriptions else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "UpdateNodeRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._name is not None
-            and
-            len(self._name) > 255):
-            raise ValueError(
-                "UpdateNodeRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A"
-                "-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0"
-                "-9])$",
-                 self._name)):
-            raise ValueError(
-                "UpdateNodeRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^(([a-zA-Z0-9]|[a-zA-Z0-"
-                "9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9"
-                "]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])$")
+        if (self._productSubscriptions is not None):
+            for obj in self._productSubscriptions:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/User.py` & `ngcbpc/data/uis/User.py`

 * *Files 8% similar despite different names*

```diff
@@ -11,17 +11,17 @@
 import re
 from six import string_types
 from .UserRole import UserRole
 from .UserMetadata import UserMetadata
 from .UserStorageQuota import UserStorageQuota
 
 # Unused import over optimization prevention
-str(repr(UserStorageQuota))
-str(repr(UserRole))
 str(repr(UserMetadata))
+str(repr(UserRole))
+str(repr(UserStorageQuota))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class User(object):
@@ -39,14 +39,19 @@
             ) is None
             else propDict["createdDate"])
         self.email = (
             None if not fromDict or propDict.get(
                 "email"
             ) is None
             else propDict["email"])
+        self.externalId = (
+            None if not fromDict or propDict.get(
+                "externalId"
+            ) is None
+            else propDict["externalId"])
         self.firstLoginDate = (
             None if not fromDict or propDict.get(
                 "firstLoginDate"
             ) is None
             else propDict["firstLoginDate"])
         self.hasBetaAccess = (
             None if not fromDict or propDict.get(
@@ -124,14 +129,24 @@
             ) is None
             else propDict["hasSubscribedToEmail"])
         self.id = (
             None if not fromDict or propDict.get(
                 "id"
             ) is None
             else propDict["id"])
+        self.idpId = (
+            None if not fromDict or propDict.get(
+                "idpId"
+            ) is None
+            else propDict["idpId"])
+        self.idpName = (
+            None if not fromDict or propDict.get(
+                "idpName"
+            ) is None
+            else propDict["idpName"])
         self.idpType = (
             None if not fromDict or propDict.get(
                 "idpType"
             ) is None
             else propDict["idpType"])
         self.isActive = (
             None if not fromDict or propDict.get(
@@ -236,14 +251,31 @@
             self._email = value
         else:
             raise TypeError(
                 'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
+    def externalId(self):
+        """str: Unique identifier from external system (e.g. Active Directory)
+        """
+        return self._externalId
+
+    @externalId.setter
+    def externalId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._externalId = value
+        else:
+            raise TypeError(
+                'Property "externalId" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def firstLoginDate(self):
         """str: Last time the user logged in"""
         return self._firstLoginDate
 
     @firstLoginDate.setter
     def firstLoginDate(self, value):
         if value is not None and not isinstance(value, string_types):
@@ -534,14 +566,46 @@
             self._id = value
         else:
             raise TypeError(
                 'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
+    def idpId(self):
+        """str: unique Identity Provider ID"""
+        return self._idpId
+
+    @idpId.setter
+    def idpId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._idpId = value
+        else:
+            raise TypeError(
+                'Property "idpId" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def idpName(self):
+        """str: Identity Provider name"""
+        return self._idpName
+
+    @idpName.setter
+    def idpName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._idpName = value
+        else:
+            raise TypeError(
+                'Property "idpName" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def idpType(self):
         """IdpTypeEnum: Type of IDP, Identity Provider. Used for login."""
         return self._idpType
 
     @idpType.setter
     def idpType(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
@@ -742,14 +806,17 @@
                 self._clientId
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
         if self._email is not None:
             result["email"] = \
                 self._email
+        if self._externalId is not None:
+            result["externalId"] = \
+                self._externalId
         if self._firstLoginDate is not None:
             result["firstLoginDate"] = \
                 self._firstLoginDate
         if self._hasBetaAccess is not None:
             result["hasBetaAccess"] = \
                 self._hasBetaAccess
         if self._hasSignedBaseCommandEULA is not None:
@@ -793,14 +860,20 @@
                 self._hasSignedThirdPartyRegistryShareEULA
         if self._hasSubscribedToEmail is not None:
             result["hasSubscribedToEmail"] = \
                 self._hasSubscribedToEmail
         if self._id is not None:
             result["id"] = \
                 self._id
+        if self._idpId is not None:
+            result["idpId"] = \
+                self._idpId
+        if self._idpName is not None:
+            result["idpName"] = \
+                self._idpName
         if self._idpType is not None:
             result["idpType"] = \
                 self._idpType
         if self._isActive is not None:
             result["isActive"] = \
                 self._isActive
         if self._isDeleted is not None:
```

## Comparing `ngccli/data/api/UserCreatedEvent.py` & `ngcbpc/data/uis/UserRoleDefinition.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,83 +6,89 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ServiceAccess import ServiceAccess
 
 # Unused import over optimization prevention
+str(repr(ServiceAccess))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserCreatedEvent(object):
-    """This event in the queue means an user should be created/updated in thir
-    d party CRM"""
+class UserRoleDefinition(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgName = (
+        self.allowedActions = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "allowedActions"
             ) is None
-            else propDict["orgName"])
-        self.userId = (
+            else [ ServiceAccess(i)
+            for i in propDict["allowedActions"] ])
+        self.name = (
             None if not fromDict or propDict.get(
-                "userId"
+                "name"
             ) is None
-            else propDict["userId"])
+            else propDict["name"])
 
     @property
-    def orgName(self):
-        """str: org name that the user should belong to"""
-        return self._orgName
-
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    def allowedActions(self):
+        """list: List of actions that this role allows"""
+        return self._allowedActions
+
+    @allowedActions.setter
+    def allowedActions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._allowedActions = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "allowedActions" of type "list<ServiceAccess>" set '
+                'to wrong type'
             )
 
     @property
-    def userId(self):
-        """long: Unique identifier of the user."""
-        return self._userId
-
-    @userId.setter
-    def userId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._userId = value
+    def name(self):
+        """str: Name of the role"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "userId" of type "list<long>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._userId is not None:
-            result["userId"] = \
-                self._userId
+        if self._allowedActions:
+            result["allowedActions"] = [
+                i.toDict() for i in self._allowedActions 
+            ] if self._allowedActions else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._allowedActions is not None):
+            for obj in self._allowedActions:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/UserInvitation.py` & `ngcbpc/data/uis/SendTemplatedEmailRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,299 +6,296 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RoleType import RoleTypeEnum
+from .MetaData import MetaData
+from .EmailTemplateDataSourceEnum import EmailTemplateDataSourceEnum
+from .EmailTemplateTypeEnum import EmailTemplateTypeEnum
 
 # Unused import over optimization prevention
-str(repr(RoleTypeEnum))
+str(repr(MetaData))
+str(repr(EmailTemplateTypeEnum))
+str(repr(EmailTemplateDataSourceEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserInvitation(object):
-    """User invitation to an NGC org or team"""
+class SendTemplatedEmailRequest(object):
+    """Send templated email request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.createdDate = (
+        self.bccAddresses = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "bccAddresses"
             ) is None
-            else propDict["createdDate"])
-        self.email = (
+            else propDict["bccAddresses"])
+        self.ccAddresses = (
             None if not fromDict or propDict.get(
-                "email"
+                "ccAddresses"
             ) is None
-            else propDict["email"])
-        self.id = (
+            else propDict["ccAddresses"])
+        self.dataSource = (
             None if not fromDict or propDict.get(
-                "id"
+                "dataSource"
             ) is None
-            else propDict["id"])
-        self.isProcessed = (
+            else propDict["dataSource"])
+        self.fromAddress = (
             None if not fromDict or propDict.get(
-                "isProcessed"
+                "fromAddress"
             ) is None
-            else propDict["isProcessed"])
-        self.name = (
+            else propDict["fromAddress"])
+        self.metaData = (
             None if not fromDict or propDict.get(
-                "name"
+                "metaData"
             ) is None
-            else propDict["name"])
-        self.org = (
+            else [ MetaData(i)
+            for i in propDict["metaData"] ])
+        self.subject = (
             None if not fromDict or propDict.get(
-                "org"
+                "subject"
             ) is None
-            else propDict["org"])
-        self.roles = (
+            else propDict["subject"])
+        self.templateContent = (
             None if not fromDict or propDict.get(
-                "roles"
+                "templateContent"
             ) is None
-            else propDict["roles"])
-        self.team = (
+            else propDict["templateContent"])
+        self.templateName = (
             None if not fromDict or propDict.get(
-                "team"
+                "templateName"
             ) is None
-            else propDict["team"])
-        self.type = (
+            else propDict["templateName"])
+        self.title = (
             None if not fromDict or propDict.get(
-                "type"
+                "title"
             ) is None
-            else propDict["type"])
+            else propDict["title"])
+        self.toAddresses = (
+            None if not fromDict or propDict.get(
+                "toAddresses"
+            ) is None
+            else propDict["toAddresses"])
 
     @property
-    def createdDate(self):
-        """str: Date on which the invitation was created. (ISO-8601 format)"""
-        return self._createdDate
+    def bccAddresses(self):
+        """list: bcc Email of the receivers"""
+        return self._bccAddresses
 
-    @createdDate.setter
-    def createdDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+    @bccAddresses.setter
+    def bccAddresses(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._bccAddresses = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "bccAddresses" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def email(self):
-        """str: Email address of the user."""
-        return self._email
+    def ccAddresses(self):
+        """list: cc Email of the receivers"""
+        return self._ccAddresses
 
-    @email.setter
-    def email(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._email = value
+    @ccAddresses.setter
+    def ccAddresses(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._ccAddresses = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "ccAddresses" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Unique invitation ID"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    def dataSource(self):
+        """EmailTemplateDataSourceEnum: Possible email template data source"""
+        return self._dataSource
+
+    @dataSource.setter
+    def dataSource(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._dataSource = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "dataSource" of type "list<EmailTemplateDataSourceE'
+                'num>" set to wrong type'
             )
 
     @property
-    def isProcessed(self):
-        """bool: Flag indicating if the invitation has already been accepted b
-        y the user."""
-        return self._isProcessed
-
-    @isProcessed.setter
-    def isProcessed(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isProcessed = value
+    def fromAddress(self):
+        """str: Email of the sender"""
+        return self._fromAddress
+
+    @fromAddress.setter
+    def fromAddress(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._fromAddress = value
         else:
             raise TypeError(
-                'Property "isProcessed" of type "list<bool>" set to wrong typ'
-                'e'
+                'Property "fromAddress" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def metaData(self):
+        """ """
+        return self._metaData
+
+    @metaData.setter
+    def metaData(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._metaData = value
+        else:
+            raise TypeError(
+                'Property "metaData" of type "list<MetaData>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def name(self):
-        """str: user name"""
-        return self._name
+    def subject(self):
+        """str: Subject of the email"""
+        return self._subject
 
-    @name.setter
-    def name(self, value):
+    @subject.setter
+    def subject(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._subject = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "subject" of type "list<str>" set to wrong type'
             )
 
     @property
-    def org(self):
-        """str: Org to which a user was invited."""
-        return self._org
+    def templateContent(self):
+        """str: Template content to include to the email"""
+        return self._templateContent
 
-    @org.setter
-    def org(self, value):
+    @templateContent.setter
+    def templateContent(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._org = value
+            self._templateContent = value
         else:
             raise TypeError(
-                'Property "org" of type "list<str>" set to wrong type'
+                'Property "templateContent" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def roles(self):
-        """list: List of roles that the user have."""
-        return self._roles
+    def templateName(self):
+        """EmailTemplateTypeEnum: Possible email template types"""
+        return self._templateName
 
-    @roles.setter
-    def roles(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._roles = value
+    @templateName.setter
+    def templateName(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._templateName = value
         else:
             raise TypeError(
-                'Property "roles" of type "list<RoleTypeEnum>" set to wrong t'
-                'ype'
+                'Property "templateName" of type "list<EmailTemplateTypeEnum>'
+                '" set to wrong type'
             )
 
     @property
-    def team(self):
-        """str: Team to which a user was invited."""
-        return self._team
+    def title(self):
+        """str: Title for the email"""
+        return self._title
 
-    @team.setter
-    def team(self, value):
+    @title.setter
+    def title(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._team = value
+            self._title = value
         else:
             raise TypeError(
-                'Property "team" of type "list<str>" set to wrong type'
+                'Property "title" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """TypeEnum: Type of invitation. The invitation is either to an organi
-        zation or to a team within organization."""
-        return self._type
+    def toAddresses(self):
+        """list: Email of the receiver"""
+        return self._toAddresses
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
+    @toAddresses.setter
+    def toAddresses(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._toAddresses = value
         else:
             raise TypeError(
-                'Property "type" of type "list<TypeEnum>" set to wrong type'
+                'Property "toAddresses" of type "list<str>" set to wrong type'
             )
 
-    TypeEnum=["ORGANIZATION","TEAM",]
-    str(repr(TypeEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._email is not None:
-            result["email"] = \
-                self._email
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._isProcessed is not None:
-            result["isProcessed"] = \
-                self._isProcessed
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._org is not None:
-            result["org"] = \
-                self._org
-        if self._roles is not None:
-            result["roles"] = \
-                self._roles
-        if self._team is not None:
-            result["team"] = \
-                self._team
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._bccAddresses is not None:
+            result["bccAddresses"] = \
+                self._bccAddresses
+        if self._ccAddresses is not None:
+            result["ccAddresses"] = \
+                self._ccAddresses
+        if self._dataSource is not None:
+            result["dataSource"] = \
+                self._dataSource
+        if self._fromAddress is not None:
+            result["fromAddress"] = \
+                self._fromAddress
+        if self._metaData:
+            result["metaData"] = [
+                i.toDict() for i in self._metaData 
+            ] if self._metaData else []
+        if self._subject is not None:
+            result["subject"] = \
+                self._subject
+        if self._templateContent is not None:
+            result["templateContent"] = \
+                self._templateContent
+        if self._templateName is not None:
+            result["templateName"] = \
+                self._templateName
+        if self._title is not None:
+            result["title"] = \
+                self._title
+        if self._toAddresses is not None:
+            result["toAddresses"] = \
+                self._toAddresses
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._email is not None
-            and
-            len(self._email) < 7):
-            raise ValueError(
-                "UserInvitation.email: " + str(self._email) + 
-                " doesnt match requirement: minLength: 7")
-        if (self._email is not None
-            and
-            len(self._email) > 128):
+        if self._templateName is None:
             raise ValueError(
-                "UserInvitation.email: " + str(self._email) + 
-                " doesnt match requirement: maxLength: 128")
-        if (self._email is not None
-            and
-            not re.match(
-                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
-                 self._email)):
-            raise ValueError(
-                "UserInvitation.email: " + str(self._email) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
-                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "UserInvitation.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._name is not None
-            and
-            len(self._name) > 64):
-            raise ValueError(
-                "UserInvitation.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._createdDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+                "SendTemplatedEmailRequest.templateName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._templateContent is None:
             raise ValueError(
-                "UserInvitation.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "SendTemplatedEmailRequest.templateContent doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._metaData is not None):
+            for obj in self._metaData:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/UserInvitationListResponse.py` & `ngcbpc/data/registry/RepositoryImageDetailsList.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,64 +6,63 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .RepositoryImageDetails import RepositoryImageDetails
 from .PaginationInfo import PaginationInfo
-from .UserInvitation import UserInvitation
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(RepositoryImageDetails))
 str(repr(RequestStatus))
 str(repr(PaginationInfo))
-str(repr(UserInvitation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserInvitationListResponse(object):
-    """Response for a list of user invitations."""
+class RepositoryImageDetailsList(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.invitations = (
+        self.images = (
             None if not fromDict or propDict.get(
-                "invitations"
+                "images"
             ) is None
-            else [ UserInvitation(i)
-            for i in propDict["invitations"] ])
+            else [ RepositoryImageDetails(i)
+            for i in propDict["images"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def invitations(self):
-        """list: List of invitations."""
-        return self._invitations
+    def images(self):
+        """list: list of images in given repository"""
+        return self._images
 
-    @invitations.setter
-    def invitations(self, value):
+    @images.setter
+    def images(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._invitations = value
+            self._images = value
         else:
             raise TypeError(
-                'Property "invitations" of type "list<UserInvitation>" set to'
-                ' wrong type'
+                'Property "images" of type "list<RepositoryImageDetails>" set'
+                ' to wrong type'
             )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
@@ -94,18 +93,18 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._invitations:
-            result["invitations"] = [
-                i.toDict() for i in self._invitations 
-            ] if self._invitations else []
+        if self._images:
+            result["images"] = [
+                i.toDict() for i in self._images 
+            ] if self._images else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -113,15 +112,15 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._invitations is not None):
-            for obj in self._invitations:
+        if (self._images is not None):
+            for obj in self._images:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserInvitationResponse.py` & `organization/data/subscription_management_service/RelatedArtifactsResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,55 +6,57 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .UserInvitation import UserInvitation
+from .RelatedArtifact import RelatedArtifact
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(UserInvitation))
+str(repr(RelatedArtifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserInvitationResponse(object):
+class RelatedArtifactsResponse(object):
+    """Response for list related artifacts API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.invitation = (
+        self.relatedArtifacts = (
             None if not fromDict or propDict.get(
-                "invitation"
+                "relatedArtifacts"
             ) is None
-            else propDict["invitation"])
+            else [ RelatedArtifact(i)
+            for i in propDict["relatedArtifacts"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def invitation(self):
-        """UserInvitation: User invitation to an NGC org or team"""
-        return self._invitation
-
-    @invitation.setter
-    def invitation(self, value):
-        if value is not None and not isinstance(value, UserInvitation):
-            value = UserInvitation(value)
-        if (value is None) or isinstance(value, UserInvitation):
-            self._invitation = value
+    def relatedArtifacts(self):
+        """list: array of related artifact objects"""
+        return self._relatedArtifacts
+
+    @relatedArtifacts.setter
+    def relatedArtifacts(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._relatedArtifacts = value
         else:
             raise TypeError(
-                'Property "invitation" of type "list<UserInvitation>" set to '
-                'wrong type'
+                'Property "relatedArtifacts" of type "list<RelatedArtifact>" '
+                'set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -68,27 +70,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._invitation:
-            result["invitation"] = \
-                self._invitation.toDict() if self._invitation is not None else None
+        if self._relatedArtifacts:
+            result["relatedArtifacts"] = [
+                i.toDict() for i in self._relatedArtifacts 
+            ] if self._relatedArtifacts else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._invitation is not None): self._invitation.isValid()
+        if (self._relatedArtifacts is not None):
+            for obj in self._relatedArtifacts:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserKeyResponse.py` & `ngcbpc/data/uis/UserKeyResponse.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/UserLabels.py` & `ngcbpc/data/registry/HistoryLayer.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,45 +14,45 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserLabels(object):
-    """User labels specified by the user or admin"""
+class HistoryLayer(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.values = (
+        self.v1Compatibility = (
             None if not fromDict or propDict.get(
-                "values"
+                "v1Compatibility"
             ) is None
-            else propDict["values"])
+            else propDict["v1Compatibility"])
 
     @property
-    def values(self):
-        """list: An array of user defined labels that describe this job"""
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._values = value
+    def v1Compatibility(self):
+        """str: Layer description in v1 API format"""
+        return self._v1Compatibility
+
+    @v1Compatibility.setter
+    def v1Compatibility(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._v1Compatibility = value
         else:
             raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "v1Compatibility" of type "list<str>" set to wrong '
+                'type'
             )
 
     def toDict(self):
         result = {}
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._v1Compatibility is not None:
+            result["v1Compatibility"] = \
+                self._v1Compatibility
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/UserListResponse.py` & `ngcbpc/data/uis/ListUserRolesResponse.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,47 +7,47 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
-from .User import User
+from .UserRoles import UserRoles
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(User))
-str(repr(RequestStatus))
 str(repr(PaginationInfo))
+str(repr(UserRoles))
+str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserListResponse(object):
-    """Response for List User reponse"""
+class ListUserRolesResponse(object):
+    """List all UserRoles in given org & team response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.users = (
+        self.userRolesList = (
             None if not fromDict or propDict.get(
-                "users"
+                "userRolesList"
             ) is None
-            else [ User(i)
-            for i in propDict["users"] ])
+            else [ UserRoles(i)
+            for i in propDict["userRolesList"] ])
 
     @property
     def paginationInfo(self):
         """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
@@ -76,51 +76,53 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def users(self):
-        """list: information about the user"""
-        return self._users
+    def userRolesList(self):
+        """list: A list of UserRoles that belongs to requesting organization a
+        nd team combination"""
+        return self._userRolesList
 
-    @users.setter
-    def users(self, value):
+    @userRolesList.setter
+    def userRolesList(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._users = value
+            self._userRolesList = value
         else:
             raise TypeError(
-                'Property "users" of type "list<User>" set to wrong type'
+                'Property "userRolesList" of type "list<UserRoles>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._users:
-            result["users"] = [
-                i.toDict() for i in self._users 
-            ] if self._users else []
+        if self._userRolesList:
+            result["userRolesList"] = [
+                i.toDict() for i in self._userRolesList 
+            ] if self._userRolesList else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._users is not None):
-            for obj in self._users:
+        if (self._userRolesList is not None):
+            for obj in self._userRolesList:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserMetadata.py` & `ngcbpc/data/uis/UserMetadata.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/UserOrgRegisterRequest.py` & `organization/data/subscription_management_service/SubscriptionRequestHistory.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,288 +6,256 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SubscriptionRequestActionEnum import SubscriptionRequestActionEnum
+from .SubscriptionRequestActionStatusEnum import SubscriptionRequestActionStatusEnum
 
 # Unused import over optimization prevention
+str(repr(SubscriptionRequestActionStatusEnum))
+str(repr(SubscriptionRequestActionEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserOrgRegisterRequest(object):
-    """object used to activate the user and org during user registration"""
+class SubscriptionRequestHistory(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.action = (
             None if not fromDict or propDict.get(
-                "name"
+                "action"
             ) is None
-            else propDict["name"])
-        self.orgCountry = (
+            else propDict["action"])
+        self.actionDetails = (
             None if not fromDict or propDict.get(
-                "orgCountry"
+                "actionDetails"
             ) is None
-            else propDict["orgCountry"])
-        self.orgDesc = (
+            else propDict["actionDetails"])
+        self.actionStatus = (
             None if not fromDict or propDict.get(
-                "orgDesc"
+                "actionStatus"
             ) is None
-            else propDict["orgDesc"])
-        self.orgIndustry = (
+            else propDict["actionStatus"])
+        self.performedDate = (
             None if not fromDict or propDict.get(
-                "orgIndustry"
+                "performedDate"
             ) is None
-            else propDict["orgIndustry"])
-        self.orgName = (
+            else propDict["performedDate"])
+        self.performerId = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "performerId"
             ) is None
-            else propDict["orgName"])
-        self.userEmailOptIn = (
+            else propDict["performerId"])
+        self.performerName = (
             None if not fromDict or propDict.get(
-                "userEmailOptIn"
+                "performerName"
             ) is None
-            else propDict["userEmailOptIn"])
-        self.userJobTitle = (
+            else propDict["performerName"])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "userJobTitle"
+                "productName"
             ) is None
-            else propDict["userJobTitle"])
-        self.userName = (
+            else propDict["productName"])
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "userName"
+                "requestId"
             ) is None
-            else propDict["userName"])
+            else propDict["requestId"])
+        self.retailer = (
+            None if not fromDict or propDict.get(
+                "retailer"
+            ) is None
+            else propDict["retailer"])
 
     @property
-    def name(self):
-        """str: DEPRECATED - please use orgName"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def action(self):
+        """SubscriptionRequestActionEnum: All possible action enums for subscr
+        iption request"""
+        return self._action
+
+    @action.setter
+    def action(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._action = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "action" of type "list<SubscriptionRequestActionEnu'
+                'm>" set to wrong type'
             )
 
     @property
-    def orgCountry(self):
-        """str: user country"""
-        return self._orgCountry
+    def actionDetails(self):
+        """str: detailed explanation of the action"""
+        return self._actionDetails
 
-    @orgCountry.setter
-    def orgCountry(self, value):
+    @actionDetails.setter
+    def actionDetails(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgCountry = value
+            self._actionDetails = value
         else:
             raise TypeError(
-                'Property "orgCountry" of type "list<str>" set to wrong type'
+                'Property "actionDetails" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def orgDesc(self):
-        """str: Company or Organization name or description"""
-        return self._orgDesc
+    def actionStatus(self):
+        """SubscriptionRequestActionStatusEnum: All possible status enums for 
+        subscription request action"""
+        return self._actionStatus
+
+    @actionStatus.setter
+    def actionStatus(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._actionStatus = value
+        else:
+            raise TypeError(
+                'Property "actionStatus" of type "list<SubscriptionRequestAct'
+                'ionStatusEnum>" set to wrong type'
+            )
+
+    @property
+    def performedDate(self):
+        """str: timestamp of the request modification"""
+        return self._performedDate
 
-    @orgDesc.setter
-    def orgDesc(self, value):
+    @performedDate.setter
+    def performedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgDesc = value
+            self._performedDate = value
         else:
             raise TypeError(
-                'Property "orgDesc" of type "list<str>" set to wrong type'
+                'Property "performedDate" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def orgIndustry(self):
-        """str: industry of the company"""
-        return self._orgIndustry
+    def performerId(self):
+        """str: starfleet id of the user who are doing the modification"""
+        return self._performerId
 
-    @orgIndustry.setter
-    def orgIndustry(self, value):
+    @performerId.setter
+    def performerId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgIndustry = value
+            self._performerId = value
         else:
             raise TypeError(
-                'Property "orgIndustry" of type "list<str>" set to wrong type'
+                'Property "performerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """str: org name"""
-        return self._orgName
+    def performerName(self):
+        """str: name of the user who are doing the modification"""
+        return self._performerName
 
-    @orgName.setter
-    def orgName(self, value):
+    @performerName.setter
+    def performerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._performerName = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "performerName" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def userEmailOptIn(self):
-        """bool: indicates if user has opt in to nvidia emails"""
-        return self._userEmailOptIn
-
-    @userEmailOptIn.setter
-    def userEmailOptIn(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._userEmailOptIn = value
+    def productName(self):
+        """str: name of the NGC product"""
+        return self._productName
+
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
         else:
             raise TypeError(
-                'Property "userEmailOptIn" of type "list<bool>" set to wrong '
-                'type'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def userJobTitle(self):
-        """str: job title of the customer"""
-        return self._userJobTitle
+    def requestId(self):
+        """str: id of the subscription request"""
+        return self._requestId
 
-    @userJobTitle.setter
-    def userJobTitle(self, value):
+    @requestId.setter
+    def requestId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._userJobTitle = value
+            self._requestId = value
         else:
             raise TypeError(
-                'Property "userJobTitle" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "requestId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def userName(self):
-        """str: user name"""
-        return self._userName
+    def retailer(self):
+        """str: name of the retailer"""
+        return self._retailer
 
-    @userName.setter
-    def userName(self, value):
+    @retailer.setter
+    def retailer(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._userName = value
+            self._retailer = value
         else:
             raise TypeError(
-                'Property "userName" of type "list<str>" set to wrong type'
+                'Property "retailer" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgCountry is not None:
-            result["orgCountry"] = \
-                self._orgCountry
-        if self._orgDesc is not None:
-            result["orgDesc"] = \
-                self._orgDesc
-        if self._orgIndustry is not None:
-            result["orgIndustry"] = \
-                self._orgIndustry
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._userEmailOptIn is not None:
-            result["userEmailOptIn"] = \
-                self._userEmailOptIn
-        if self._userJobTitle is not None:
-            result["userJobTitle"] = \
-                self._userJobTitle
-        if self._userName is not None:
-            result["userName"] = \
-                self._userName
+        if self._action is not None:
+            result["action"] = \
+                self._action
+        if self._actionDetails is not None:
+            result["actionDetails"] = \
+                self._actionDetails
+        if self._actionStatus is not None:
+            result["actionStatus"] = \
+                self._actionStatus
+        if self._performedDate is not None:
+            result["performedDate"] = \
+                self._performedDate
+        if self._performerId is not None:
+            result["performerId"] = \
+                self._performerId
+        if self._performerName is not None:
+            result["performerName"] = \
+                self._performerName
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._retailer is not None:
+            result["retailer"] = \
+                self._retailer
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) < 8):
-            raise ValueError(
-                "UserOrgRegisterRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 8")
-        if (self._name is not None
-            and
-            len(self._name) > 64):
-            raise ValueError(
-                "UserOrgRegisterRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._name is not None
-            and
-            not re.match(
-                r"(?=.*?\d.*\d)[a-z][a-z\d_-]+",
-                 self._name)):
-            raise ValueError(
-                "UserOrgRegisterRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: (?=.*?\d.*\d)[a-z][a-z\d"
-                "_-]+")
-        if (self._orgName is not None
-            and
-            len(self._orgName) < 8):
-            raise ValueError(
-                "UserOrgRegisterRequest.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: minLength: 8")
-        if (self._orgName is not None
-            and
-            len(self._orgName) > 64):
-            raise ValueError(
-                "UserOrgRegisterRequest.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._orgName is not None
-            and
-            not re.match(
-                r"(?=.*?\d.*\d)[a-z][a-z\d_-]+",
-                 self._orgName)):
-            raise ValueError(
-                "UserOrgRegisterRequest.orgName: " + str(self._orgName) + 
-                " doesnt match requirement: pattern: (?=.*?\d.*\d)[a-z][a-z\d"
-                "_-]+")
-        if (self._orgDesc is not None
-            and
-            len(self._orgDesc) > 512):
-            raise ValueError(
-                "UserOrgRegisterRequest.orgDesc: " + str(self._orgDesc) + 
-                " doesnt match requirement: maxLength: 512")
-        if (self._userName is not None
-            and
-            len(self._userName) < 1):
-            raise ValueError(
-                "UserOrgRegisterRequest.userName: " + str(self._userName) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._userName is not None
-            and
-            len(self._userName) > 64):
-            raise ValueError(
-                "UserOrgRegisterRequest.userName: " + str(self._userName) + 
-                " doesnt match requirement: maxLength: 64")
         return True
```

## Comparing `ngccli/data/api/UserRegisterRequest.py` & `ngcbpc/data/model/MultipartUploadCreateRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,193 +14,221 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserRegisterRequest(object):
-    """object used to register an user for user sign up"""
+class MultipartUploadCreateRequest(object):
+    """Request body for creating a multipart upload for artifacts"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.consentedToShareInfo = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "consentedToShareInfo"
+                "artifactType"
             ) is None
-            else propDict["consentedToShareInfo"])
-        self.email = (
+            else propDict["artifactType"])
+        self.filePath = (
             None if not fromDict or propDict.get(
-                "email"
+                "filePath"
             ) is None
-            else propDict["email"])
-        self.hasEmailOptIn = (
-            None if not fromDict or propDict.get(
-                "hasEmailOptIn"
-            ) is None
-            else propDict["hasEmailOptIn"])
+            else propDict["filePath"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.nvidiaAccountEulaAccepted = (
+        self.partNumberList = (
+            None if not fromDict or propDict.get(
+                "partNumberList"
+            ) is None
+            else propDict["partNumberList"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
+        self.uploadID = (
             None if not fromDict or propDict.get(
-                "nvidiaAccountEulaAccepted"
+                "uploadID"
             ) is None
-            else propDict["nvidiaAccountEulaAccepted"])
+            else propDict["uploadID"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def consentedToShareInfo(self):
-        """bool: indicates if user has consented to share their registration i
-        nfo with other parties"""
-        return self._consentedToShareInfo
+    def artifactType(self):
+        """str: Type of artifact"""
+        return self._artifactType
 
-    @consentedToShareInfo.setter
-    def consentedToShareInfo(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._consentedToShareInfo = value
+    @artifactType.setter
+    def artifactType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "consentedToShareInfo" of type "list<bool>" set to '
-                'wrong type'
+                'Property "artifactType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def email(self):
-        """str: Email address of the user. This should be unique."""
-        return self._email
+    def filePath(self):
+        """str: The file path for the artifact upload"""
+        return self._filePath
 
-    @email.setter
-    def email(self, value):
+    @filePath.setter
+    def filePath(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._email = value
+            self._filePath = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "filePath" of type "list<str>" set to wrong type'
             )
 
     @property
-    def hasEmailOptIn(self):
-        """bool: indicates if user has opt in to nvidia emails"""
-        return self._hasEmailOptIn
+    def name(self):
+        """str: Name of the artifact"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
 
-    @hasEmailOptIn.setter
-    def hasEmailOptIn(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._hasEmailOptIn = value
+    @property
+    def partNumberList(self):
+        """list: List of parts to re-generate urls for"""
+        return self._partNumberList
+
+    @partNumberList.setter
+    def partNumberList(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._partNumberList = value
         else:
             raise TypeError(
-                'Property "hasEmailOptIn" of type "list<bool>" set to wrong t'
+                'Property "partNumberList" of type "list<int>" set to wrong t'
                 'ype'
             )
 
     @property
-    def name(self):
-        """str: user name"""
-        return self._name
+    def size(self):
+        """long: size of the artifact, in bytes"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
+        else:
+            raise TypeError(
+                'Property "size" of type "list<long>" set to wrong type'
+            )
 
-    @name.setter
-    def name(self, value):
+    @property
+    def uploadID(self):
+        """str: Upload id of an already initiated Multipart upload"""
+        return self._uploadID
+
+    @uploadID.setter
+    def uploadID(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._uploadID = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "uploadID" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nvidiaAccountEulaAccepted(self):
-        """bool: indicates if user has accepted NVIDIA account EULA"""
-        return self._nvidiaAccountEulaAccepted
-
-    @nvidiaAccountEulaAccepted.setter
-    def nvidiaAccountEulaAccepted(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._nvidiaAccountEulaAccepted = value
+    def version(self):
+        """str: Artifact version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "nvidiaAccountEulaAccepted" of type "list<bool>" se'
-                't to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._consentedToShareInfo is not None:
-            result["consentedToShareInfo"] = \
-                self._consentedToShareInfo
-        if self._email is not None:
-            result["email"] = \
-                self._email
-        if self._hasEmailOptIn is not None:
-            result["hasEmailOptIn"] = \
-                self._hasEmailOptIn
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._filePath is not None:
+            result["filePath"] = \
+                self._filePath
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._nvidiaAccountEulaAccepted is not None:
-            result["nvidiaAccountEulaAccepted"] = \
-                self._nvidiaAccountEulaAccepted
+        if self._partNumberList is not None:
+            result["partNumberList"] = \
+                self._partNumberList
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._uploadID is not None:
+            result["uploadID"] = \
+                self._uploadID
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "UserRegisterRequest.name doesnt match requirement:" 
+                "MultipartUploadCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "UserRegisterRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._name is not None
-            and
-            len(self._name) > 64):
-            raise ValueError(
-                "UserRegisterRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 64")
-        if self._email is None:
+        if self._version is None:
             raise ValueError(
-                "UserRegisterRequest.email doesnt match requirement:" 
+                "MultipartUploadCreateRequest.version doesnt match requirement:" 
                 "required: True"
             )
-        if (self._email is not None
-            and
-            len(self._email) < 6):
+        if self._artifactType is None:
             raise ValueError(
-                "UserRegisterRequest.email: " + str(self._email) + 
-                " doesnt match requirement: minLength: 6")
-        if (self._email is not None
-            and
-            len(self._email) > 128):
+                "MultipartUploadCreateRequest.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._filePath is None:
             raise ValueError(
-                "UserRegisterRequest.email: " + str(self._email) + 
-                " doesnt match requirement: maxLength: 128")
-        if (self._email is not None
-            and
-            not re.match(
-                r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)",
-                 self._email)):
+                "MultipartUploadCreateRequest.filePath doesnt match requirement:" 
+                "required: True"
+            )
+        if self._size is None:
             raise ValueError(
-                "UserRegisterRequest.email: " + str(self._email) + 
-                " doesnt match requirement: pattern: (^[a-zA-Z0-9_.+-]+@[a-zA"
-                "-Z0-9-]+\.[a-zA-Z0-9-.]+$)")
+                "MultipartUploadCreateRequest.size doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/UserResponse.py` & `ngcbpc/data/uis/UserResponse.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .UserRole import UserRole
-from .User import User
 from .RequestStatus import RequestStatus
+from .User import User
 
 # Unused import over optimization prevention
-str(repr(User))
 str(repr(RequestStatus))
 str(repr(UserRole))
+str(repr(User))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserResponse(object):
```

## Comparing `ngccli/data/api/UserRole.py` & `ngcbpc/data/uis/UserRole.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -6,24 +6,24 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RoleType import RoleTypeEnum
 from .Team import Team
-from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
 from .Organization import Organization
+from .TargetSystemUserIdentifier import TargetSystemUserIdentifier
+from .RoleType import RoleTypeEnum
 
 # Unused import over optimization prevention
 str(repr(Organization))
+str(repr(Team))
 str(repr(TargetSystemUserIdentifier))
 str(repr(RoleTypeEnum))
-str(repr(Team))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class UserRole(object):
```

## Comparing `ngccli/data/api/UserRoleDefinition.py` & `registry/data/publishing/Artifact.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,166 +6,167 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RoleProduct import RoleProduct
-from .ServiceAccess import ServiceAccess
 
 # Unused import over optimization prevention
-str(repr(ServiceAccess))
-str(repr(RoleProduct))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserRoleDefinition(object):
+class Artifact(object):
+    """NGC Artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowedActions = (
+        self.environmentUri = (
             None if not fromDict or propDict.get(
-                "allowedActions"
+                "environmentUri"
             ) is None
-            else [ ServiceAccess(i)
-            for i in propDict["allowedActions"] ])
-        self.displayName = (
-            None if not fromDict or propDict.get(
-                "displayName"
-            ) is None
-            else propDict["displayName"])
+            else propDict["environmentUri"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.product = (
+        self.org = (
             None if not fromDict or propDict.get(
-                "product"
+                "org"
             ) is None
-            else propDict["product"])
-        self.shortDisplayName = (
+            else propDict["org"])
+        self.team = (
             None if not fromDict or propDict.get(
-                "shortDisplayName"
+                "team"
             ) is None
-            else propDict["shortDisplayName"])
-
-    @property
-    def allowedActions(self):
-        """list: List of actions that this role allows"""
-        return self._allowedActions
-
-    @allowedActions.setter
-    def allowedActions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._allowedActions = value
-        else:
-            raise TypeError(
-                'Property "allowedActions" of type "list<ServiceAccess>" set '
-                'to wrong type'
-            )
+            else propDict["team"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def displayName(self):
-        """str: Display Name of the role"""
-        return self._displayName
+    def environmentUri(self):
+        """str: Environment and microservice URI artifact is from. Examples: h
+        ttps://models.ngc.nvidia.com, https://nvcr.io, etc."""
+        return self._environmentUri
 
-    @displayName.setter
-    def displayName(self, value):
+    @environmentUri.setter
+    def environmentUri(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._environmentUri = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "environmentUri" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
     def name(self):
-        """str: Name of the role"""
+        """str: Name of the NGC artifact unique to the org or team"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def product(self):
-        """RoleProduct: Product information of the role"""
-        return self._product
-
-    @product.setter
-    def product(self, value):
-        if value is not None and not isinstance(value, RoleProduct):
-            value = RoleProduct(value)
-        if (value is None) or isinstance(value, RoleProduct):
-            self._product = value
+    def org(self):
+        """str: Name of the NGC org that owns the artifact"""
+        return self._org
+
+    @org.setter
+    def org(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._org = value
+        else:
+            raise TypeError(
+                'Property "org" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def team(self):
+        """str: (Optional) Name of the NGC team under the specified org that o
+        wns the artifact"""
+        return self._team
+
+    @team.setter
+    def team(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._team = value
         else:
             raise TypeError(
-                'Property "product" of type "list<RoleProduct>" set to wrong '
-                'type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shortDisplayName(self):
-        """str: Short Display Name of the role"""
-        return self._shortDisplayName
+    def version(self):
+        """str: Version/Tag of the NGC artifact"""
+        return self._version
 
-    @shortDisplayName.setter
-    def shortDisplayName(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shortDisplayName = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "shortDisplayName" of type "list<str>" set to wrong'
-                ' type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowedActions:
-            result["allowedActions"] = [
-                i.toDict() for i in self._allowedActions 
-            ] if self._allowedActions else []
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
+        if self._environmentUri is not None:
+            result["environmentUri"] = \
+                self._environmentUri
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._product:
-            result["product"] = \
-                self._product.toDict() if self._product is not None else None
-        if self._shortDisplayName is not None:
-            result["shortDisplayName"] = \
-                self._shortDisplayName
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._team is not None:
+            result["team"] = \
+                self._team
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._product is not None): self._product.isValid()
-        if (self._allowedActions is not None):
-            for obj in self._allowedActions:
-                if (obj is not None): obj.isValid()
+        if self._org is None:
+            raise ValueError(
+                "Artifact.org doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
+            raise ValueError(
+                "Artifact.name doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/UserRoleDefinitionsResponse.py` & `ngcbpc/data/model/CollectionResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,95 +6,90 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .UserRoleDefinition import UserRoleDefinition
+from .Collection import Collection
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(Collection))
 str(repr(RequestStatus))
-str(repr(UserRoleDefinition))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserRoleDefinitionsResponse(object):
-    """Response containing all the roles defined in NGC and their allowed acti
-    ons"""
+class CollectionResponse(object):
+    """Response to create collection request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.collection = (
+            None if not fromDict or propDict.get(
+                "collection"
+            ) is None
+            else propDict["collection"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.roles = (
-            None if not fromDict or propDict.get(
-                "roles"
-            ) is None
-            else [ UserRoleDefinition(i)
-            for i in propDict["roles"] ])
+
+    @property
+    def collection(self):
+        """Collection: Collection object"""
+        return self._collection
+
+    @collection.setter
+    def collection(self, value):
+        if value is not None and not isinstance(value, Collection):
+            value = Collection(value)
+        if (value is None) or isinstance(value, Collection):
+            self._collection = value
+        else:
+            raise TypeError(
+                'Property "collection" of type "list<Collection>" set to wron'
+                'g type'
+            )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def roles(self):
-        """list: List of roles"""
-        return self._roles
-
-    @roles.setter
-    def roles(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._roles = value
-        else:
-            raise TypeError(
-                'Property "roles" of type "list<UserRoleDefinition>" set to w'
-                'rong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._collection:
+            result["collection"] = \
+                self._collection.toDict() if self._collection is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._roles:
-            result["roles"] = [
-                i.toDict() for i in self._roles 
-            ] if self._roles else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._roles is not None):
-            for obj in self._roles:
-                if (obj is not None): obj.isValid()
+        if (self._collection is not None): self._collection.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserSession.py` & `organization/data/subscription_management_service/RelatedItem.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,46 +14,68 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserSession(object):
-    """object returned after successful authentication"""
+class RelatedItem(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.sessionToken = (
+        self.ref = (
             None if not fromDict or propDict.get(
-                "sessionToken"
+                "ref"
             ) is None
-            else propDict["sessionToken"])
+            else propDict["ref"])
+        self.type = (
+            None if not fromDict or propDict.get(
+                "type"
+            ) is None
+            else propDict["type"])
+
+    @property
+    def ref(self):
+        """str: any related references to identify the related artifact"""
+        return self._ref
+
+    @ref.setter
+    def ref(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ref = value
+        else:
+            raise TypeError(
+                'Property "ref" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def sessionToken(self):
-        """ """
-        return self._sessionToken
+    def type(self):
+        """str: type of the attribute"""
+        return self._type
 
-    @sessionToken.setter
-    def sessionToken(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sessionToken = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "sessionToken" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._sessionToken is not None:
-            result["sessionToken"] = \
-                self._sessionToken
+        if self._ref is not None:
+            result["ref"] = \
+                self._ref
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/api/UserSessionResponse.py` & `ngcbpc/data/uis/UserProfileGetResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,39 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .UserSession import UserSession
+from .UserProfile import UserProfile
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(UserSession))
 str(repr(RequestStatus))
+str(repr(UserProfile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserSessionResponse(object):
+class UserProfileGetResponse(object):
+    """Response for Get User Profile"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.userSession = (
+        self.userProfile = (
             None if not fromDict or propDict.get(
-                "userSession"
+                "userProfile"
             ) is None
-            else propDict["userSession"])
+            else propDict["userProfile"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -50,45 +51,45 @@
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     @property
-    def userSession(self):
-        """UserSession: object returned after successful authentication"""
-        return self._userSession
-
-    @userSession.setter
-    def userSession(self, value):
-        if value is not None and not isinstance(value, UserSession):
-            value = UserSession(value)
-        if (value is None) or isinstance(value, UserSession):
-            self._userSession = value
+    def userProfile(self):
+        """UserProfile: The profile of user."""
+        return self._userProfile
+
+    @userProfile.setter
+    def userProfile(self, value):
+        if value is not None and not isinstance(value, UserProfile):
+            value = UserProfile(value)
+        if (value is None) or isinstance(value, UserProfile):
+            self._userProfile = value
         else:
             raise TypeError(
-                'Property "userSession" of type "list<UserSession>" set to wr'
+                'Property "userProfile" of type "list<UserProfile>" set to wr'
                 'ong type'
             )
 
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._userSession:
-            result["userSession"] = \
-                self._userSession.toDict() if self._userSession is not None else None
+        if self._userProfile:
+            result["userProfile"] = \
+                self._userProfile.toDict() if self._userProfile is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._userSession is not None): self._userSession.isValid()
+        if (self._userProfile is not None): self._userProfile.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserStorageClusterUpdateRequest.py` & `basecommand/data/pym/ClusterComponentModifyParams.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,173 +6,178 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Env import Env
 
 # Unused import over optimization prevention
+str(repr(Env))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserStorageClusterUpdateRequest(object):
-    """Object used to update/create user storage cluster mapping. When dataset
-    , resultset, workspace not provided, will use the default"""
+class ClusterComponentModifyParams(object):
+    """Common modification parameters for scheduler and worker"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.dashboardAddress = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "dashboardAddress"
             ) is None
-            else propDict["aceName"])
-        self.datasetStorageClusterUuid = (
+            else propDict["dashboardAddress"])
+        self.envVariables = (
             None if not fromDict or propDict.get(
-                "datasetStorageClusterUuid"
+                "envVariables"
             ) is None
-            else propDict["datasetStorageClusterUuid"])
-        self.defaultStorageClusterUuid = (
+            else [ Env(i)
+            for i in propDict["envVariables"] ])
+        self.gpuReserved = (
             None if not fromDict or propDict.get(
-                "defaultStorageClusterUuid"
+                "gpuReserved"
             ) is None
-            else propDict["defaultStorageClusterUuid"])
-        self.resultsetStorageClusterUuid = (
+            else propDict["gpuReserved"])
+        self.instanceType = (
             None if not fromDict or propDict.get(
-                "resultsetStorageClusterUuid"
+                "instanceType"
             ) is None
-            else propDict["resultsetStorageClusterUuid"])
-        self.workspaceStorageClusterUuid = (
+            else propDict["instanceType"])
+        self.startupScript = (
             None if not fromDict or propDict.get(
-                "workspaceStorageClusterUuid"
+                "startupScript"
             ) is None
-            else propDict["workspaceStorageClusterUuid"])
+            else propDict["startupScript"])
 
     @property
-    def aceName(self):
-        """str: ace name"""
-        return self._aceName
+    def dashboardAddress(self):
+        """str: Dashboard address"""
+        return self._dashboardAddress
 
-    @aceName.setter
-    def aceName(self, value):
+    @dashboardAddress.setter
+    def dashboardAddress(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._dashboardAddress = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "dashboardAddress" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def datasetStorageClusterUuid(self):
-        """str: Storage Cluster Uuid that will be mapped to this user's datase
-        t"""
-        return self._datasetStorageClusterUuid
-
-    @datasetStorageClusterUuid.setter
-    def datasetStorageClusterUuid(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._datasetStorageClusterUuid = value
+    def envVariables(self):
+        """list: List of all environment variables to prefix the scheduler or 
+        worker command"""
+        return self._envVariables
+
+    @envVariables.setter
+    def envVariables(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._envVariables = value
         else:
             raise TypeError(
-                'Property "datasetStorageClusterUuid" of type "list<str>" set'
-                ' to wrong type'
+                'Property "envVariables" of type "list<Env>" set to wrong typ'
+                'e'
             )
 
     @property
-    def defaultStorageClusterUuid(self):
-        """str: The default Storage Cluster Uuid that will be used for this us
-        er"""
-        return self._defaultStorageClusterUuid
-
-    @defaultStorageClusterUuid.setter
-    def defaultStorageClusterUuid(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._defaultStorageClusterUuid = value
+    def gpuReserved(self):
+        """int: Number of GPU reserved"""
+        return self._gpuReserved
+
+    @gpuReserved.setter
+    def gpuReserved(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._gpuReserved = value
         else:
             raise TypeError(
-                'Property "defaultStorageClusterUuid" of type "list<str>" set'
-                ' to wrong type'
+                'Property "gpuReserved" of type "list<int>" set to wrong type'
             )
 
     @property
-    def resultsetStorageClusterUuid(self):
-        """str: Storage Cluster Uuid that will be mapped to this user's result
-        set"""
-        return self._resultsetStorageClusterUuid
+    def instanceType(self):
+        """str: Instance type"""
+        return self._instanceType
 
-    @resultsetStorageClusterUuid.setter
-    def resultsetStorageClusterUuid(self, value):
+    @instanceType.setter
+    def instanceType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resultsetStorageClusterUuid = value
+            self._instanceType = value
         else:
             raise TypeError(
-                'Property "resultsetStorageClusterUuid" of type "list<str>" s'
-                'et to wrong type'
+                'Property "instanceType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def workspaceStorageClusterUuid(self):
-        """str: Storage Cluster Uuid that will be mapped to this user's worksp
-        ace"""
-        return self._workspaceStorageClusterUuid
+    def startupScript(self):
+        """str: Startup script"""
+        return self._startupScript
 
-    @workspaceStorageClusterUuid.setter
-    def workspaceStorageClusterUuid(self, value):
+    @startupScript.setter
+    def startupScript(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._workspaceStorageClusterUuid = value
+            self._startupScript = value
         else:
             raise TypeError(
-                'Property "workspaceStorageClusterUuid" of type "list<str>" s'
-                'et to wrong type'
+                'Property "startupScript" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._datasetStorageClusterUuid is not None:
-            result["datasetStorageClusterUuid"] = \
-                self._datasetStorageClusterUuid
-        if self._defaultStorageClusterUuid is not None:
-            result["defaultStorageClusterUuid"] = \
-                self._defaultStorageClusterUuid
-        if self._resultsetStorageClusterUuid is not None:
-            result["resultsetStorageClusterUuid"] = \
-                self._resultsetStorageClusterUuid
-        if self._workspaceStorageClusterUuid is not None:
-            result["workspaceStorageClusterUuid"] = \
-                self._workspaceStorageClusterUuid
+        if self._dashboardAddress is not None:
+            result["dashboardAddress"] = \
+                self._dashboardAddress
+        if self._envVariables:
+            result["envVariables"] = [
+                i.toDict() for i in self._envVariables 
+            ] if self._envVariables else []
+        if self._gpuReserved is not None:
+            result["gpuReserved"] = \
+                self._gpuReserved
+        if self._instanceType is not None:
+            result["instanceType"] = \
+                self._instanceType
+        if self._startupScript is not None:
+            result["startupScript"] = \
+                self._startupScript
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceName is None:
+        if (self._instanceType is not None
+            and
+            len(self._instanceType) < 1):
             raise ValueError(
-                "UserStorageClusterUpdateRequest.aceName doesnt match requirement:" 
-                "required: True"
-            )
-        if self._defaultStorageClusterUuid is None:
+                "ClusterComponentModifyParams.instanceType: " + str(self._instanceType) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._gpuReserved is not None
+            and
+            self._gpuReserved < 0):
             raise ValueError(
-                "UserStorageClusterUpdateRequest.defaultStorageClusterUuid doesnt match requirement:" 
-                "required: True"
-            )
+                "ClusterComponentModifyParams.gpuReserved: " + str(self._gpuReserved) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._envVariables is not None):
+            for obj in self._envVariables:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/UserStorageQuota.py` & `ngcbpc/data/uis/UserStorageQuota.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/api/UserStorageQuotaListResponse.py` & `basecommand/data/pym/ClusterComponentParams.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,172 +6,195 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .RequestStatus import RequestStatus
-from .UserStorageQuota import UserStorageQuota
+from .Env import Env
 
 # Unused import over optimization prevention
-str(repr(UserStorageQuota))
-str(repr(RequestStatus))
-str(repr(PaginationInfo))
+str(repr(Env))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserStorageQuotaListResponse(object):
-    """listing of user storage quota on all aces that contain user's datasets
-    """
+class ClusterComponentParams(object):
+    """Common parameters for scheduler and worker"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.paginationInfo = (
+        self.dashboardAddress = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "dashboardAddress"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["dashboardAddress"])
+        self.envVariables = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "envVariables"
             ) is None
-            else propDict["requestStatus"])
-        self.totalAllocated = (
+            else [ Env(i)
+            for i in propDict["envVariables"] ])
+        self.gpuReserved = (
             None if not fromDict or propDict.get(
-                "totalAllocated"
+                "gpuReserved"
             ) is None
-            else propDict["totalAllocated"])
-        self.totalUsed = (
+            else propDict["gpuReserved"])
+        self.instanceType = (
             None if not fromDict or propDict.get(
-                "totalUsed"
+                "instanceType"
             ) is None
-            else propDict["totalUsed"])
-        self.userStorageQuotas = (
+            else propDict["instanceType"])
+        self.startupScript = (
             None if not fromDict or propDict.get(
-                "userStorageQuotas"
+                "startupScript"
             ) is None
-            else [ UserStorageQuota(i)
-            for i in propDict["userStorageQuotas"] ])
+            else propDict["startupScript"])
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def dashboardAddress(self):
+        """str: Dashboard address"""
+        return self._dashboardAddress
+
+    @dashboardAddress.setter
+    def dashboardAddress(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._dashboardAddress = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "dashboardAddress" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def envVariables(self):
+        """list: List of environment variables to prefix the scheduler or work
+        er command"""
+        return self._envVariables
+
+    @envVariables.setter
+    def envVariables(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._envVariables = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "envVariables" of type "list<Env>" set to wrong typ'
+                'e'
             )
 
     @property
-    def totalAllocated(self):
-        """long: total storage allocated in bytes"""
-        return self._totalAllocated
-
-    @totalAllocated.setter
-    def totalAllocated(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalAllocated = value
+    def gpuReserved(self):
+        """int: Number of GPU reserved"""
+        return self._gpuReserved
+
+    @gpuReserved.setter
+    def gpuReserved(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._gpuReserved = value
         else:
             raise TypeError(
-                'Property "totalAllocated" of type "list<long>" set to wrong '
-                'type'
+                'Property "gpuReserved" of type "list<int>" set to wrong type'
             )
 
     @property
-    def totalUsed(self):
-        """long: total storage used in bytes"""
-        return self._totalUsed
-
-    @totalUsed.setter
-    def totalUsed(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalUsed = value
+    def instanceType(self):
+        """str: Instance type"""
+        return self._instanceType
+
+    @instanceType.setter
+    def instanceType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._instanceType = value
         else:
             raise TypeError(
-                'Property "totalUsed" of type "list<long>" set to wrong type'
+                'Property "instanceType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def userStorageQuotas(self):
-        """ """
-        return self._userStorageQuotas
-
-    @userStorageQuotas.setter
-    def userStorageQuotas(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._userStorageQuotas = value
+    def startupScript(self):
+        """str: Startup script"""
+        return self._startupScript
+
+    @startupScript.setter
+    def startupScript(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._startupScript = value
         else:
             raise TypeError(
-                'Property "userStorageQuotas" of type "list<UserStorageQuota>'
-                '" set to wrong type'
+                'Property "startupScript" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._totalAllocated is not None:
-            result["totalAllocated"] = \
-                self._totalAllocated
-        if self._totalUsed is not None:
-            result["totalUsed"] = \
-                self._totalUsed
-        if self._userStorageQuotas:
-            result["userStorageQuotas"] = [
-                i.toDict() for i in self._userStorageQuotas 
-            ] if self._userStorageQuotas else []
+        if self._dashboardAddress is not None:
+            result["dashboardAddress"] = \
+                self._dashboardAddress
+        if self._envVariables:
+            result["envVariables"] = [
+                i.toDict() for i in self._envVariables 
+            ] if self._envVariables else []
+        if self._gpuReserved is not None:
+            result["gpuReserved"] = \
+                self._gpuReserved
+        if self._instanceType is not None:
+            result["instanceType"] = \
+                self._instanceType
+        if self._startupScript is not None:
+            result["startupScript"] = \
+                self._startupScript
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._userStorageQuotas is not None):
-            for obj in self._userStorageQuotas:
+        if (self._dashboardAddress is not None
+            and
+            len(self._dashboardAddress) < 1):
+            raise ValueError(
+                "ClusterComponentParams.dashboardAddress: " + str(self._dashboardAddress) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._startupScript is not None
+            and
+            len(self._startupScript) < 1):
+            raise ValueError(
+                "ClusterComponentParams.startupScript: " + str(self._startupScript) + 
+                " doesnt match requirement: minLength: 1")
+        if self._instanceType is None:
+            raise ValueError(
+                "ClusterComponentParams.instanceType doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._instanceType is not None
+            and
+            len(self._instanceType) < 1):
+            raise ValueError(
+                "ClusterComponentParams.instanceType: " + str(self._instanceType) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._gpuReserved is not None
+            and
+            self._gpuReserved < 0):
+            raise ValueError(
+                "ClusterComponentParams.gpuReserved: " + str(self._gpuReserved) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._envVariables is not None):
+            for obj in self._envVariables:
                 if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserStorageQuotaResponse.py` & `organization/data/subscription_management_service/CreateProductOfferResponse.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,40 +6,58 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProductOffer import ProductOffer
 from .RequestStatus import RequestStatus
-from .UserStorageQuota import UserStorageQuota
 
 # Unused import over optimization prevention
-str(repr(UserStorageQuota))
+str(repr(ProductOffer))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserStorageQuotaResponse(object):
-    """response to a request to get user storage quota on an ACE"""
+class CreateProductOfferResponse(object):
+    """Create product offer response object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.offers = (
+            None if not fromDict or propDict.get(
+                "offers"
+            ) is None
+            else [ ProductOffer(i)
+            for i in propDict["offers"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.userStorageQuota = (
-            None if not fromDict or propDict.get(
-                "userStorageQuota"
-            ) is None
-            else propDict["userStorageQuota"])
+
+    @property
+    def offers(self):
+        """list: product offers"""
+        return self._offers
+
+    @offers.setter
+    def offers(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._offers = value
+        else:
+            raise TypeError(
+                'Property "offers" of type "list<ProductOffer>" set to wrong '
+                'type'
+            )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -50,47 +68,32 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def userStorageQuota(self):
-        """UserStorageQuota: represents user storage quota for a given ace and
-         available unused storage"""
-        return self._userStorageQuota
-
-    @userStorageQuota.setter
-    def userStorageQuota(self, value):
-        if value is not None and not isinstance(value, UserStorageQuota):
-            value = UserStorageQuota(value)
-        if (value is None) or isinstance(value, UserStorageQuota):
-            self._userStorageQuota = value
-        else:
-            raise TypeError(
-                'Property "userStorageQuota" of type "list<UserStorageQuota>"'
-                ' set to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._offers:
+            result["offers"] = [
+                i.toDict() for i in self._offers 
+            ] if self._offers else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._userStorageQuota:
-            result["userStorageQuota"] = \
-                self._userStorageQuota.toDict() if self._userStorageQuota is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._userStorageQuota is not None): self._userStorageQuota.isValid()
+        if (self._offers is not None):
+            for obj in self._offers:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/UserStorageQuotaUpdateRequest.py` & `organization/data/sms/SecretModifyRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,118 +6,148 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .KV import KV
 
 # Unused import over optimization prevention
+str(repr(KV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserStorageQuotaUpdateRequest(object):
-    """object used to request user storage quota update"""
+class SecretModifyRequest(object):
+    """Secret modify request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "description"
             ) is None
-            else propDict["aceName"])
-        self.quota = (
+            else propDict["description"])
+        self.disabled = (
             None if not fromDict or propDict.get(
-                "quota"
+                "disabled"
             ) is None
-            else propDict["quota"])
-        self.storageClusterUuid = (
+            else propDict["disabled"])
+        self.kv = (
             None if not fromDict or propDict.get(
-                "storageClusterUuid"
+                "kv"
             ) is None
-            else propDict["storageClusterUuid"])
+            else [ KV(i)
+            for i in propDict["kv"] ])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def aceName(self):
-        """str: ace name"""
-        return self._aceName
+    def description(self):
+        """str: Secret description"""
+        return self._description
 
-    @aceName.setter
-    def aceName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def quota(self):
-        """int: target total storage quota in GB"""
-        return self._quota
-
-    @quota.setter
-    def quota(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._quota = value
+    def disabled(self):
+        """bool: Secret enabled/disabled"""
+        return self._disabled
+
+    @disabled.setter
+    def disabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._disabled = value
         else:
             raise TypeError(
-                'Property "quota" of type "list<int>" set to wrong type'
+                'Property "disabled" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def storageClusterUuid(self):
-        """str: Identifier to this storage cluster. If not provided, will defa
-        ult to the default storage cluster"""
-        return self._storageClusterUuid
+    def kv(self):
+        """ """
+        return self._kv
+
+    @kv.setter
+    def kv(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._kv = value
+        else:
+            raise TypeError(
+                'Property "kv" of type "list<KV>" set to wrong type'
+            )
 
-    @storageClusterUuid.setter
-    def storageClusterUuid(self, value):
+    @property
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._storageClusterUuid = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "storageClusterUuid" of type "list<str>" set to wro'
-                'ng type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._quota is not None:
-            result["quota"] = \
-                self._quota
-        if self._storageClusterUuid is not None:
-            result["storageClusterUuid"] = \
-                self._storageClusterUuid
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._disabled is not None:
+            result["disabled"] = \
+                self._disabled
+        if self._kv:
+            result["kv"] = [
+                i.toDict() for i in self._kv 
+            ] if self._kv else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceName is None:
+        if self._version is None:
             raise ValueError(
-                "UserStorageQuotaUpdateRequest.aceName doesnt match requirement:" 
+                "SecretModifyRequest.version doesnt match requirement:" 
                 "required: True"
             )
-        if self._quota is None:
+        if (self._description is not None
+            and
+            len(self._description) < 1):
             raise ValueError(
-                "UserStorageQuotaUpdateRequest.quota doesnt match requirement:" 
-                "required: True"
-            )
+                "SecretModifyRequest.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._kv is not None):
+            for obj in self._kv:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/UserTopicEvent.py` & `ngcbpc/data/model/DeploymentArtifactParameters.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,113 +6,130 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactTypeEnum import ArtifactTypeEnum
 
 # Unused import over optimization prevention
+str(repr(ArtifactTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UserTopicEvent(object):
-    """User topic event."""
+class DeploymentArtifactParameters(object):
+    """Deployment Artifact Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.actionBy = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "actionBy"
+                "artifactType"
             ) is None
-            else propDict["actionBy"])
-        self.clientId = (
+            else propDict["artifactType"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "clientId"
+                "displayName"
             ) is None
-            else propDict["clientId"])
-        self.email = (
+            else propDict["displayName"])
+        self.filePath = (
             None if not fromDict or propDict.get(
-                "email"
+                "filePath"
             ) is None
-            else propDict["email"])
+            else propDict["filePath"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
         self.orgName = (
             None if not fromDict or propDict.get(
                 "orgName"
             ) is None
             else propDict["orgName"])
         self.teamName = (
             None if not fromDict or propDict.get(
                 "teamName"
             ) is None
             else propDict["teamName"])
-        self.type = (
-            None if not fromDict or propDict.get(
-                "type"
-            ) is None
-            else propDict["type"])
-        self.userId = (
+        self.versionId = (
             None if not fromDict or propDict.get(
-                "userId"
+                "versionId"
             ) is None
-            else propDict["userId"])
+            else propDict["versionId"])
+
+    @property
+    def artifactType(self):
+        """ArtifactTypeEnum: Artifact type"""
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
+        else:
+            raise TypeError(
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
+            )
 
     @property
-    def actionBy(self):
-        """str: Auth client ID of the user who performed the action"""
-        return self._actionBy
+    def displayName(self):
+        """str: Display name of the artifact"""
+        return self._displayName
 
-    @actionBy.setter
-    def actionBy(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._actionBy = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "actionBy" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def clientId(self):
-        """str: Unique authentication ID of the user."""
-        return self._clientId
+    def filePath(self):
+        """str: Path to a file in an artifact version"""
+        return self._filePath
 
-    @clientId.setter
-    def clientId(self, value):
+    @filePath.setter
+    def filePath(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._clientId = value
+            self._filePath = value
         else:
             raise TypeError(
-                'Property "clientId" of type "list<str>" set to wrong type'
+                'Property "filePath" of type "list<str>" set to wrong type'
             )
 
     @property
-    def email(self):
-        """str: Email of the user"""
-        return self._email
+    def name(self):
+        """str: Unique name of the artifact"""
+        return self._name
 
-    @email.setter
-    def email(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._email = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
     def orgName(self):
-        """str: Name of the user's organization."""
+        """str: Name of the org that the artifact belongs to"""
         return self._orgName
 
     @orgName.setter
     def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -120,89 +137,82 @@
         else:
             raise TypeError(
                 'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
     def teamName(self):
-        """str: Name of the user's team (optional)."""
+        """str: Name of the team that the artifact belongs to"""
         return self._teamName
 
     @teamName.setter
     def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._teamName = value
         else:
             raise TypeError(
                 'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def versionId(self):
+        """str: ID of the version or tag"""
+        return self._versionId
 
-    @type.setter
-    def type(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._type = value
-        else:
-            raise TypeError(
-                'Property "type" of type "list<TypeEnum>" set to wrong type'
-            )
-
-    TypeEnum=["CREATED","REMOVED","PURGED",]
-    str(repr(TypeEnum))  # Prevent optimizer removing enum
-
-    @property
-    def userId(self):
-        """long: Unique ID of the user."""
-        return self._userId
-
-    @userId.setter
-    def userId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._userId = value
+    @versionId.setter
+    def versionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._versionId = value
         else:
             raise TypeError(
-                'Property "userId" of type "list<long>" set to wrong type'
+                'Property "versionId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._actionBy is not None:
-            result["actionBy"] = \
-                self._actionBy
-        if self._clientId is not None:
-            result["clientId"] = \
-                self._clientId
-        if self._email is not None:
-            result["email"] = \
-                self._email
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._filePath is not None:
+            result["filePath"] = \
+                self._filePath
+        if self._name is not None:
+            result["name"] = \
+                self._name
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
         if self._teamName is not None:
             result["teamName"] = \
                 self._teamName
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._userId is not None:
-            result["userId"] = \
-                self._userId
+        if self._versionId is not None:
+            result["versionId"] = \
+                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "DeploymentArtifactParameters.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._orgName is None:
+            raise ValueError(
+                "DeploymentArtifactParameters.orgName doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/api/UserUpdateRequest.py` & `ngcbpc/data/uis/UserUpdateRequest.py`

 * *Files 17% similar despite different names*

```diff
@@ -20,14 +20,24 @@
     long = int
     unicode = str
 
 class UserUpdateRequest(object):
     """object used to request user update"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.externalId = (
+            None if not fromDict or propDict.get(
+                "externalId"
+            ) is None
+            else propDict["externalId"])
+        self.firstLoginTime = (
+            None if not fromDict or propDict.get(
+                "firstLoginTime"
+            ) is None
+            else propDict["firstLoginTime"])
         self.hasEmailOptIn = (
             None if not fromDict or propDict.get(
                 "hasEmailOptIn"
             ) is None
             else propDict["hasEmailOptIn"])
         self.hasSignedBaseCommandEULA = (
             None if not fromDict or propDict.get(
@@ -90,26 +100,85 @@
             ) is None
             else propDict["hasSignedPrivacyPolicy"])
         self.hasSignedThirdPartyRegistryShareEULA = (
             None if not fromDict or propDict.get(
                 "hasSignedThirdPartyRegistryShareEULA"
             ) is None
             else propDict["hasSignedThirdPartyRegistryShareEULA"])
+        self.idpId = (
+            None if not fromDict or propDict.get(
+                "idpId"
+            ) is None
+            else propDict["idpId"])
+        self.idpName = (
+            None if not fromDict or propDict.get(
+                "idpName"
+            ) is None
+            else propDict["idpName"])
+        self.lastLoginTime = (
+            None if not fromDict or propDict.get(
+                "lastLoginTime"
+            ) is None
+            else propDict["lastLoginTime"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
+        self.starfleetId = (
+            None if not fromDict or propDict.get(
+                "starfleetId"
+            ) is None
+            else propDict["starfleetId"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
         self.userMetadata = (
             None if not fromDict or propDict.get(
                 "userMetadata"
             ) is None
             else propDict["userMetadata"])
 
     @property
+    def externalId(self):
+        """str: Unique identifier from external system (e.g. Active Directory)
+        """
+        return self._externalId
+
+    @externalId.setter
+    def externalId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._externalId = value
+        else:
+            raise TypeError(
+                'Property "externalId" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def firstLoginTime(self):
+        """str: First login time into NGC"""
+        return self._firstLoginTime
+
+    @firstLoginTime.setter
+    def firstLoginTime(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._firstLoginTime = value
+        else:
+            raise TypeError(
+                'Property "firstLoginTime" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
     def hasEmailOptIn(self):
         """bool: indicates if user has opt in to nvidia emails"""
         return self._hasEmailOptIn
 
     @hasEmailOptIn.setter
     def hasEmailOptIn(self, value):
         if value is not None and not isinstance(value, bool):
@@ -347,14 +416,63 @@
         else:
             raise TypeError(
                 'Property "hasSignedThirdPartyRegistryShareEULA" of type "lis'
                 't<bool>" set to wrong type'
             )
 
     @property
+    def idpId(self):
+        """str: IDP id"""
+        return self._idpId
+
+    @idpId.setter
+    def idpId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._idpId = value
+        else:
+            raise TypeError(
+                'Property "idpId" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def idpName(self):
+        """str: IDP name"""
+        return self._idpName
+
+    @idpName.setter
+    def idpName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._idpName = value
+        else:
+            raise TypeError(
+                'Property "idpName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def lastLoginTime(self):
+        """str: Last login time into NGC"""
+        return self._lastLoginTime
+
+    @lastLoginTime.setter
+    def lastLoginTime(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._lastLoginTime = value
+        else:
+            raise TypeError(
+                'Property "lastLoginTime" of type "list<str>" set to wrong ty'
+                'pe'
+            )
+
+    @property
     def name(self):
         """str: user name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
@@ -363,14 +481,46 @@
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
+    def starfleetId(self):
+        """str: Unique identifier from Starfleet"""
+        return self._starfleetId
+
+    @starfleetId.setter
+    def starfleetId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._starfleetId = value
+        else:
+            raise TypeError(
+                'Property "starfleetId" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def updatedDate(self):
+        """str: Date when user record was last time updated"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
+        else:
+            raise TypeError(
+                'Property "updatedDate" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def userMetadata(self):
         """UserMetadata: Metadata information about the user."""
         return self._userMetadata
 
     @userMetadata.setter
     def userMetadata(self, value):
         if value is not None and not isinstance(value, UserMetadata):
@@ -381,14 +531,20 @@
             raise TypeError(
                 'Property "userMetadata" of type "list<UserMetadata>" set to '
                 'wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._externalId is not None:
+            result["externalId"] = \
+                self._externalId
+        if self._firstLoginTime is not None:
+            result["firstLoginTime"] = \
+                self._firstLoginTime
         if self._hasEmailOptIn is not None:
             result["hasEmailOptIn"] = \
                 self._hasEmailOptIn
         if self._hasSignedBaseCommandEULA is not None:
             result["hasSignedBaseCommandEULA"] = \
                 self._hasSignedBaseCommandEULA
         if self._hasSignedBioNeMoEULA is not None:
@@ -423,17 +579,32 @@
                 self._hasSignedOmniverseEULA
         if self._hasSignedPrivacyPolicy is not None:
             result["hasSignedPrivacyPolicy"] = \
                 self._hasSignedPrivacyPolicy
         if self._hasSignedThirdPartyRegistryShareEULA is not None:
             result["hasSignedThirdPartyRegistryShareEULA"] = \
                 self._hasSignedThirdPartyRegistryShareEULA
+        if self._idpId is not None:
+            result["idpId"] = \
+                self._idpId
+        if self._idpName is not None:
+            result["idpName"] = \
+                self._idpName
+        if self._lastLoginTime is not None:
+            result["lastLoginTime"] = \
+                self._lastLoginTime
         if self._name is not None:
             result["name"] = \
                 self._name
+        if self._starfleetId is not None:
+            result["starfleetId"] = \
+                self._starfleetId
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         if self._userMetadata:
             result["userMetadata"] = \
                 self._userMetadata.toDict() if self._userMetadata is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
```

## Comparing `ngccli/data/api/UsersInfo.py` & `organization/data/subscription_management_service/UpdateProductRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,58 +6,61 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Product import Product
 
 # Unused import over optimization prevention
+str(repr(Product))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UsersInfo(object):
-    """Users information."""
+class UpdateProductRequest(object):
+    """Update product request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.totalUsers = (
+        self.product = (
             None if not fromDict or propDict.get(
-                "totalUsers"
+                "product"
             ) is None
-            else propDict["totalUsers"])
+            else propDict["product"])
 
     @property
-    def totalUsers(self):
-        """long: Total number of users."""
-        return self._totalUsers
-
-    @totalUsers.setter
-    def totalUsers(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalUsers = value
+    def product(self):
+        """ """
+        return self._product
+
+    @product.setter
+    def product(self, value):
+        if value is not None and not isinstance(value, Product):
+            value = Product(value)
+        if (value is None) or isinstance(value, Product):
+            self._product = value
         else:
             raise TypeError(
-                'Property "totalUsers" of type "list<long>" set to wrong type'
+                'Property "product" of type "list<Product>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._totalUsers is not None:
-            result["totalUsers"] = \
-                self._totalUsers
+        if self._product:
+            result["product"] = \
+                self._product.toDict() if self._product is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._product is not None): self._product.isValid()
         return True
```

## Comparing `ngccli/data/api/ValidateOrgQueryParams.py` & `ngcbpc/data/registry/Allowlist.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,134 +6,163 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .OrgOwner import OrgOwner
-from .ProductSubscription import ProductSubscription
+from .AllowlistItem import AllowlistItem
 
 # Unused import over optimization prevention
-str(repr(OrgOwner))
-str(repr(ProductSubscription))
+str(repr(AllowlistItem))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ValidateOrgQueryParams(object):
-    """Object for defining params to validate org."""
+class Allowlist(object):
+    """A collection of allowlist items to match a policy evaluation against.
+    """
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.orgOwner = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "orgOwner"
+                "description"
             ) is None
-            else propDict["orgOwner"])
-        self.pecSfdcId = (
+            else propDict["description"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "pecSfdcId"
+                "id"
             ) is None
-            else propDict["pecSfdcId"])
-        self.productSubscriptions = (
+            else propDict["id"])
+        self.items = (
             None if not fromDict or propDict.get(
-                "productSubscriptions"
+                "items"
             ) is None
-            else [ ProductSubscription(i)
-            for i in propDict["productSubscriptions"] ])
+            else [ AllowlistItem(i)
+            for i in propDict["items"] ])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def orgOwner(self):
-        """OrgOwner: Org owner."""
-        return self._orgOwner
-
-    @orgOwner.setter
-    def orgOwner(self, value):
-        if value is not None and not isinstance(value, OrgOwner):
-            value = OrgOwner(value)
-        if (value is None) or isinstance(value, OrgOwner):
-            self._orgOwner = value
+    def description(self):
+        """ """
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "orgOwner" of type "list<OrgOwner>" set to wrong ty'
-                'pe'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def pecSfdcId(self):
-        """str: Product end customer salesforce.com id (external customer id) 
-        for enterprise product."""
-        return self._pecSfdcId
+    def id(self):
+        """ """
+        return self._id
 
-    @pecSfdcId.setter
-    def pecSfdcId(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._pecSfdcId = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "pecSfdcId" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productSubscriptions(self):
-        """list: Product Subscriptions."""
-        return self._productSubscriptions
+    def items(self):
+        """ """
+        return self._items
 
-    @productSubscriptions.setter
-    def productSubscriptions(self, value):
+    @items.setter
+    def items(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._productSubscriptions = value
+            self._items = value
         else:
             raise TypeError(
-                'Property "productSubscriptions" of type "list<ProductSubscri'
-                'ption>" set to wrong type'
+                'Property "items" of type "list<AllowlistItem>" set to wrong '
+                'type'
+            )
+
+    @property
+    def name(self):
+        """ """
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def version(self):
+        """ """
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
+        else:
+            raise TypeError(
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._orgOwner:
-            result["orgOwner"] = \
-                self._orgOwner.toDict() if self._orgOwner is not None else None
-        if self._pecSfdcId is not None:
-            result["pecSfdcId"] = \
-                self._pecSfdcId
-        if self._productSubscriptions:
-            result["productSubscriptions"] = [
-                i.toDict() for i in self._productSubscriptions 
-            ] if self._productSubscriptions else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._items:
+            result["items"] = [
+                i.toDict() for i in self._items 
+            ] if self._items else []
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._orgOwner is None:
-            raise ValueError(
-                "ValidateOrgQueryParams.orgOwner doesnt match requirement:" 
-                "required: True"
-            )
-        if self._pecSfdcId is None:
-            raise ValueError(
-                "ValidateOrgQueryParams.pecSfdcId doesnt match requirement:" 
-                "required: True"
-            )
-        if self._productSubscriptions is None:
-            raise ValueError(
-                "ValidateOrgQueryParams.productSubscriptions doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._orgOwner is not None): self._orgOwner.isValid()
-        if (self._productSubscriptions is not None):
-            for obj in self._productSubscriptions:
+        if (self._items is not None):
+            for obj in self._items:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/VirtualNodeCreateRequest.py` & `ngcbpc/data/registry/ManifestV2Layer.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,78 +14,98 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class VirtualNodeCreateRequest(object):
+class ManifestV2Layer(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceId = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "aceId"
+                "digest"
             ) is None
-            else propDict["aceId"])
-        self.isParsec = (
+            else propDict["digest"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "isParsec"
+                "mediaType"
             ) is None
-            else propDict["isParsec"])
+            else propDict["mediaType"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
 
     @property
-    def aceId(self):
-        """long: The Id for the ACE."""
-        return self._aceId
+    def digest(self):
+        """str: Images sha256 digest"""
+        return self._digest
+
+    @digest.setter
+    def digest(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._digest = value
+        else:
+            raise TypeError(
+                'Property "digest" of type "list<str>" set to wrong type'
+            )
 
-    @aceId.setter
-    def aceId(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._aceId = value
+    @property
+    def mediaType(self):
+        """str: should be 'application/vnd.docker.image.rootfs.diff.tar.gzip'
+        """
+        return self._mediaType
+
+    @mediaType.setter
+    def mediaType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "aceId" of type "list<long>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isParsec(self):
-        """bool: Indicates if the node is managed by parsec"""
-        return self._isParsec
-
-    @isParsec.setter
-    def isParsec(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isParsec = value
+    def size(self):
+        """long: Layer size in bytes"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
         else:
             raise TypeError(
-                'Property "isParsec" of type "list<bool>" set to wrong type'
+                'Property "size" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceId is not None:
-            result["aceId"] = \
-                self._aceId
-        if self._isParsec is not None:
-            result["isParsec"] = \
-                self._isParsec
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._size is not None:
+            result["size"] = \
+                self._size
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._isParsec is None:
-            raise ValueError(
-                "VirtualNodeCreateRequest.isParsec doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/api/WebSocket.py` & `basecommand/data/pym/ProjectTemplateCreateRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,87 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectTemplateParams import ProjectTemplateParams
 
 # Unused import over optimization prevention
+str(repr(ProjectTemplateParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WebSocket(object):
-    """object used to show the status of the websocket between node and the cl
-    oud"""
+class ProjectTemplateCreateRequest(object):
+    """Project Template Create Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.connectionStatus = (
+        self.params = (
             None if not fromDict or propDict.get(
-                "connectionStatus"
+                "params"
             ) is None
-            else propDict["connectionStatus"])
-        self.lastEventDateTime = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "lastEventDateTime"
+                "version"
             ) is None
-            else propDict["lastEventDateTime"])
+            else propDict["version"])
 
     @property
-    def connectionStatus(self):
-        """ """
-        return self._connectionStatus
-
-    @connectionStatus.setter
-    def connectionStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._connectionStatus = value
+    def params(self):
+        """ProjectTemplateParams: Project template parameters"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectTemplateParams):
+            value = ProjectTemplateParams(value)
+        if (value is None) or isinstance(value, ProjectTemplateParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "connectionStatus" of type "list<ConnectionStatusEn'
-                'um>" set to wrong type'
+                'Property "params" of type "list<ProjectTemplateParams>" set '
+                'to wrong type'
             )
 
-    ConnectionStatusEnum=["UNKNOWN","CONNECTED","DISCONNECTED",]
-    str(repr(ConnectionStatusEnum))  # Prevent optimizer removing enum
-
     @property
-    def lastEventDateTime(self):
-        """str: ISO Date/time of last web socket event (connect or disconnect)
-        """
-        return self._lastEventDateTime
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @lastEventDateTime.setter
-    def lastEventDateTime(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastEventDateTime = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "lastEventDateTime" of type "list<str>" set to wron'
-                'g type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._connectionStatus is not None:
-            result["connectionStatus"] = \
-                self._connectionStatus
-        if self._lastEventDateTime is not None:
-            result["lastEventDateTime"] = \
-                self._lastEventDateTime
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "ProjectTemplateCreateRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
+            raise ValueError(
+                "ProjectTemplateCreateRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/api/WebSocketReceipt.py` & `basecommand/data/pym/ProjectTemplateListResponse.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,110 +6,100 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectTemplateListParams import ProjectTemplateListParams
 
 # Unused import over optimization prevention
+str(repr(ProjectTemplateListParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WebSocketReceipt(object):
-    """Receipt sent to WebSocket server from WebSocket client"""
+class ProjectTemplateListResponse(object):
+    """Project Template List Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deliverySuccess = (
+        self.templates = (
             None if not fromDict or propDict.get(
-                "deliverySuccess"
+                "templates"
             ) is None
-            else propDict["deliverySuccess"])
-        self.extraData = (
+            else [ ProjectTemplateListParams(i)
+            for i in propDict["templates"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "extraData"
+                "version"
             ) is None
-            else propDict["extraData"])
-        self.receiptNumber = (
-            None if not fromDict or propDict.get(
-                "receiptNumber"
-            ) is None
-            else propDict["receiptNumber"])
+            else propDict["version"])
 
     @property
-    def deliverySuccess(self):
-        """bool: boolean response indicating whether message send by WSS reach
-        ed client"""
-        return self._deliverySuccess
-
-    @deliverySuccess.setter
-    def deliverySuccess(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._deliverySuccess = value
+    def templates(self):
+        """ """
+        return self._templates
+
+    @templates.setter
+    def templates(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._templates = value
         else:
             raise TypeError(
-                'Property "deliverySuccess" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "templates" of type "list<ProjectTemplateListParams'
+                '>" set to wrong type'
             )
 
     @property
-    def extraData(self):
-        """str: Additional data sent by consumer of WebSocket client"""
-        return self._extraData
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @extraData.setter
-    def extraData(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._extraData = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "extraData" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def receiptNumber(self):
-        """str: Receipt number sent along with message wo be delivered by WebS
-        ocket server"""
-        return self._receiptNumber
-
-    @receiptNumber.setter
-    def receiptNumber(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._receiptNumber = value
-        else:
-            raise TypeError(
-                'Property "receiptNumber" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deliverySuccess is not None:
-            result["deliverySuccess"] = \
-                self._deliverySuccess
-        if self._extraData is not None:
-            result["extraData"] = \
-                self._extraData
-        if self._receiptNumber is not None:
-            result["receiptNumber"] = \
-                self._receiptNumber
+        if self._templates:
+            result["templates"] = [
+                i.toDict() for i in self._templates 
+            ] if self._templates else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "ProjectTemplateListResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._templates is None:
+            raise ValueError(
+                "ProjectTemplateListResponse.templates doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._templates is not None):
+            for obj in self._templates:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/api/Webhook.py` & `ngcbpc/data/registry/GetManifestByTagResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,288 +6,256 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .WebhookEventType import WebhookEventTypeEnum
-from .AlertAggregationType import AlertAggregationTypeEnum
-from .AlertDeliveryMode import AlertDeliveryMode
+from .HistoryLayer import HistoryLayer
+from .RequestStatus import RequestStatus
+from .ImageSignature import ImageSignature
+from .BlobSum import BlobSum
 
 # Unused import over optimization prevention
-str(repr(AlertAggregationTypeEnum))
-str(repr(WebhookEventTypeEnum))
-str(repr(AlertDeliveryMode))
+str(repr(ImageSignature))
+str(repr(HistoryLayer))
+str(repr(RequestStatus))
+str(repr(BlobSum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Webhook(object):
+class GetManifestByTagResponse(object):
+    """Image's manifest"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aggregationType = (
+        self.architecture = (
             None if not fromDict or propDict.get(
-                "aggregationType"
+                "architecture"
             ) is None
-            else propDict["aggregationType"])
-        self.createdDate = (
+            else propDict["architecture"])
+        self.fsLayers = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "fsLayers"
             ) is None
-            else propDict["createdDate"])
-        self.deliveryModes = (
+            else [ BlobSum(i)
+            for i in propDict["fsLayers"] ])
+        self.history = (
             None if not fromDict or propDict.get(
-                "deliveryModes"
+                "history"
             ) is None
-            else [ AlertDeliveryMode(i)
-            for i in propDict["deliveryModes"] ])
-        self.description = (
-            None if not fromDict or propDict.get(
-                "description"
-            ) is None
-            else propDict["description"])
-        self.enabled = (
+            else [ HistoryLayer(i)
+            for i in propDict["history"] ])
+        self.name = (
             None if not fromDict or propDict.get(
-                "enabled"
+                "name"
             ) is None
-            else propDict["enabled"])
-        self.eventTypes = (
+            else propDict["name"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "eventTypes"
+                "requestStatus"
             ) is None
-            else propDict["eventTypes"])
-        self.id = (
+            else propDict["requestStatus"])
+        self.schemaVersion = (
             None if not fromDict or propDict.get(
-                "id"
+                "schemaVersion"
             ) is None
-            else propDict["id"])
-        self.message = (
+            else propDict["schemaVersion"])
+        self.signatures = (
             None if not fromDict or propDict.get(
-                "message"
+                "signatures"
             ) is None
-            else propDict["message"])
-        self.name = (
+            else [ ImageSignature(i)
+            for i in propDict["signatures"] ])
+        self.tag = (
             None if not fromDict or propDict.get(
-                "name"
+                "tag"
             ) is None
-            else propDict["name"])
-        self.updatedDate = (
-            None if not fromDict or propDict.get(
-                "updatedDate"
-            ) is None
-            else propDict["updatedDate"])
-
-    @property
-    def aggregationType(self):
-        """AlertAggregationTypeEnum: Aggregation type for webhooks and alerts,
-         i.e. user only, team or org"""
-        return self._aggregationType
-
-    @aggregationType.setter
-    def aggregationType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._aggregationType = value
-        else:
-            raise TypeError(
-                'Property "aggregationType" of type "list<AlertAggregationTyp'
-                'eEnum>" set to wrong type'
-            )
+            else propDict["tag"])
 
     @property
-    def createdDate(self):
-        """str: Date at which this webhook was created"""
-        return self._createdDate
+    def architecture(self):
+        """str: Image architecture (e.g amd64)"""
+        return self._architecture
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @architecture.setter
+    def architecture(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._architecture = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "architecture" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def deliveryModes(self):
+    def fsLayers(self):
         """ """
-        return self._deliveryModes
+        return self._fsLayers
 
-    @deliveryModes.setter
-    def deliveryModes(self, value):
+    @fsLayers.setter
+    def fsLayers(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._deliveryModes = value
+            self._fsLayers = value
         else:
             raise TypeError(
-                'Property "deliveryModes" of type "list<AlertDeliveryMode>" s'
-                'et to wrong type'
+                'Property "fsLayers" of type "list<BlobSum>" set to wrong typ'
+                'e'
             )
 
     @property
-    def description(self):
-        """str: User defined description for this webhook"""
-        return self._description
+    def history(self):
+        """ """
+        return self._history
 
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    @history.setter
+    def history(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._history = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "history" of type "list<HistoryLayer>" set to wrong'
+                ' type'
             )
 
     @property
-    def enabled(self):
-        """bool: Specifies whether webhook is enabled or disabled. Webhooks ca
-        n be created disabled, by default they are enabled"""
-        return self._enabled
-
-    @enabled.setter
-    def enabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enabled = value
+    def name(self):
+        """str: full repository name with namespace"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "enabled" of type "list<bool>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventTypes(self):
+    def requestStatus(self):
         """ """
-        return self._eventTypes
+        return self._requestStatus
 
-    @eventTypes.setter
-    def eventTypes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._eventTypes = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "eventTypes" of type "list<WebhookEventTypeEnum>" s'
-                'et to wrong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     @property
-    def id(self):
-        """long: Unique identification for this webhook"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    def schemaVersion(self):
+        """int: Response schema version"""
+        return self._schemaVersion
+
+    @schemaVersion.setter
+    def schemaVersion(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schemaVersion = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "schemaVersion" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def message(self):
-        """str: Message generated for webhook, leave blank for custom message
-        """
-        return self._message
-
-    @message.setter
-    def message(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._message = value
-        else:
-            raise TypeError(
-                'Property "message" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def name(self):
-        """str: User defined webhook name"""
-        return self._name
+    def signatures(self):
+        """ """
+        return self._signatures
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @signatures.setter
+    def signatures(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._signatures = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "signatures" of type "list<ImageSignature>" set to '
+                'wrong type'
             )
 
     @property
-    def updatedDate(self):
-        """str: Date at which this webhook was updated"""
-        return self._updatedDate
+    def tag(self):
+        """str: image tag used to retrieve manifest"""
+        return self._tag
 
-    @updatedDate.setter
-    def updatedDate(self, value):
+    @tag.setter
+    def tag(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
+            self._tag = value
         else:
             raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aggregationType is not None:
-            result["aggregationType"] = \
-                self._aggregationType
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._deliveryModes:
-            result["deliveryModes"] = [
-                i.toDict() for i in self._deliveryModes 
-            ] if self._deliveryModes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._enabled is not None:
-            result["enabled"] = \
-                self._enabled
-        if self._eventTypes is not None:
-            result["eventTypes"] = \
-                self._eventTypes
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._message is not None:
-            result["message"] = \
-                self._message
+        if self._architecture is not None:
+            result["architecture"] = \
+                self._architecture
+        if self._fsLayers:
+            result["fsLayers"] = [
+                i.toDict() for i in self._fsLayers 
+            ] if self._fsLayers else []
+        if self._history:
+            result["history"] = [
+                i.toDict() for i in self._history 
+            ] if self._history else []
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._schemaVersion is not None:
+            result["schemaVersion"] = \
+                self._schemaVersion
+        if self._signatures:
+            result["signatures"] = [
+                i.toDict() for i in self._signatures 
+            ] if self._signatures else []
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._deliveryModes is not None):
-            for obj in self._deliveryModes:
+        if (self._fsLayers is not None):
+            for obj in self._fsLayers:
+                if (obj is not None): obj.isValid()
+        if (self._history is not None):
+            for obj in self._history:
+                if (obj is not None): obj.isValid()
+        if (self._signatures is not None):
+            for obj in self._signatures:
                 if (obj is not None): obj.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/WebhookListResponse.py` & `ngcbpc/data/model/CollectionListResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,52 +6,69 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .Webhook import Webhook
+from .Collection import Collection
 from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(Webhook))
+str(repr(Collection))
 str(repr(RequestStatus))
 str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WebhookListResponse(object):
-    """Response to show webhook response"""
+class CollectionListResponse(object):
+    """Response to list collections request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.collections = (
+            None if not fromDict or propDict.get(
+                "collections"
+            ) is None
+            else [ Collection(i)
+            for i in propDict["collections"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.webhooks = (
-            None if not fromDict or propDict.get(
-                "webhooks"
-            ) is None
-            else [ Webhook(i)
-            for i in propDict["webhooks"] ])
+
+    @property
+    def collections(self):
+        """ """
+        return self._collections
+
+    @collections.setter
+    def collections(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._collections = value
+        else:
+            raise TypeError(
+                'Property "collections" of type "list<Collection>" set to wro'
+                'ng type'
+            )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -60,68 +77,51 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def webhooks(self):
-        """ """
-        return self._webhooks
-
-    @webhooks.setter
-    def webhooks(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._webhooks = value
-        else:
-            raise TypeError(
-                'Property "webhooks" of type "list<Webhook>" set to wrong typ'
-                'e'
-            )
-
     def toDict(self):
         result = {}
+        if self._collections:
+            result["collections"] = [
+                i.toDict() for i in self._collections 
+            ] if self._collections else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._webhooks:
-            result["webhooks"] = [
-                i.toDict() for i in self._webhooks 
-            ] if self._webhooks else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._webhooks is not None):
-            for obj in self._webhooks:
+        if (self._collections is not None):
+            for obj in self._collections:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/WebhookResponse.py` & `ngcbpc/data/model/ModelResponse.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,89 +6,89 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Webhook import Webhook
 from .RequestStatus import RequestStatus
+from .Model import Model
 
 # Unused import over optimization prevention
-str(repr(Webhook))
 str(repr(RequestStatus))
+str(repr(Model))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WebhookResponse(object):
-    """Response to show webhook response"""
+class ModelResponse(object):
+    """Response to create model request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.model = (
+            None if not fromDict or propDict.get(
+                "model"
+            ) is None
+            else propDict["model"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.webhook = (
-            None if not fromDict or propDict.get(
-                "webhook"
-            ) is None
-            else propDict["webhook"])
+
+    @property
+    def model(self):
+        """Model: Model object"""
+        return self._model
+
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
+        else:
+            raise TypeError(
+                'Property "model" of type "list<Model>" set to wrong type'
+            )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def webhook(self):
-        """ """
-        return self._webhook
-
-    @webhook.setter
-    def webhook(self, value):
-        if value is not None and not isinstance(value, Webhook):
-            value = Webhook(value)
-        if (value is None) or isinstance(value, Webhook):
-            self._webhook = value
-        else:
-            raise TypeError(
-                'Property "webhook" of type "list<Webhook>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._webhook:
-            result["webhook"] = \
-                self._webhook.toDict() if self._webhook is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._webhook is not None): self._webhook.isValid()
+        if (self._model is not None): self._model.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/WorkspaceCreateRequest.py` & `organization/data/subscription_management_service/ReviewSubscriptionRequestRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,158 +6,157 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SubscriptionRequestActionEnum import SubscriptionRequestActionEnum
 
 # Unused import over optimization prevention
+str(repr(SubscriptionRequestActionEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WorkspaceCreateRequest(object):
-    """Workspace creation request."""
+class ReviewSubscriptionRequestRequest(object):
+    """Request for review SubscriptionRequest API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.aceName = (
+        self.action = (
             None if not fromDict or propDict.get(
-                "aceName"
+                "action"
             ) is None
-            else propDict["aceName"])
-        self.description = (
+            else propDict["action"])
+        self.performerId = (
             None if not fromDict or propDict.get(
-                "description"
+                "performerId"
             ) is None
-            else propDict["description"])
-        self.name = (
+            else propDict["performerId"])
+        self.performerName = (
             None if not fromDict or propDict.get(
-                "name"
+                "performerName"
             ) is None
-            else propDict["name"])
-        self.onBehalfOf = (
+            else propDict["performerName"])
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "onBehalfOf"
+                "requestId"
             ) is None
-            else propDict["onBehalfOf"])
+            else propDict["requestId"])
+        self.retailer = (
+            None if not fromDict or propDict.get(
+                "retailer"
+            ) is None
+            else propDict["retailer"])
+
+    @property
+    def action(self):
+        """SubscriptionRequestActionEnum: All possible action enums for subscr
+        iption request"""
+        return self._action
+
+    @action.setter
+    def action(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._action = value
+        else:
+            raise TypeError(
+                'Property "action" of type "list<SubscriptionRequestActionEnu'
+                'm>" set to wrong type'
+            )
 
     @property
-    def aceName(self):
-        """str: Name of the ACE to which the workspace will belong"""
-        return self._aceName
+    def performerId(self):
+        """str: Starfleet id of the people who are doing the review"""
+        return self._performerId
 
-    @aceName.setter
-    def aceName(self, value):
+    @performerId.setter
+    def performerId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._aceName = value
+            self._performerId = value
         else:
             raise TypeError(
-                'Property "aceName" of type "list<str>" set to wrong type'
+                'Property "performerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the workspace"""
-        return self._description
+    def performerName(self):
+        """str: name of the people who are doing the review"""
+        return self._performerName
 
-    @description.setter
-    def description(self, value):
+    @performerName.setter
+    def performerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._performerName = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "performerName" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def name(self):
-        """str: Name for the workspace. Must not be a valid UUID or start with
-         - or _."""
-        return self._name
+    def requestId(self):
+        """str: id of the subscription request"""
+        return self._requestId
 
-    @name.setter
-    def name(self, value):
+    @requestId.setter
+    def requestId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._requestId = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "requestId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def onBehalfOf(self):
-        """str: Auth client Id that we want to create this workspace on behalf
-         of. Only for workspace admins"""
-        return self._onBehalfOf
+    def retailer(self):
+        """str: name of the retailer"""
+        return self._retailer
 
-    @onBehalfOf.setter
-    def onBehalfOf(self, value):
+    @retailer.setter
+    def retailer(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._onBehalfOf = value
+            self._retailer = value
         else:
             raise TypeError(
-                'Property "onBehalfOf" of type "list<str>" set to wrong type'
+                'Property "retailer" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._aceName is not None:
-            result["aceName"] = \
-                self._aceName
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._onBehalfOf is not None:
-            result["onBehalfOf"] = \
-                self._onBehalfOf
+        if self._action is not None:
+            result["action"] = \
+                self._action
+        if self._performerId is not None:
+            result["performerId"] = \
+                self._performerId
+        if self._performerName is not None:
+            result["performerName"] = \
+                self._performerName
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._retailer is not None:
+            result["retailer"] = \
+                self._retailer
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._aceName is None:
-            raise ValueError(
-                "WorkspaceCreateRequest.aceName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._name is not None
-            and
-            len(self._name) < 2):
-            raise ValueError(
-                "WorkspaceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._name is not None
-            and
-            len(self._name) > 255):
-            raise ValueError(
-                "WorkspaceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^(?![-_])(?![a-zA-Z0-9_-]{22}$)[a-zA-Z0-9_-]*$",
-                 self._name)):
-            raise ValueError(
-                "WorkspaceCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^(?![-_])(?![a-zA-Z0-9_-"
-                "]{22}$)[a-zA-Z0-9_-]*$")
         return True
```

## Comparing `ngccli/data/api/WorkspaceListResponse.py` & `ngcbpc/data/model/RecipeVersionFileListResponse.py`

 * *Files 11% similar despite different names*

```diff
@@ -6,78 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
-from .StorageResource import StorageResource
 from .RequestStatus import RequestStatus
-from .MetaData import MetaData
+from .RecipeFile import RecipeFile
+from .RecipeVersion import RecipeVersion
+from .Recipe import Recipe
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(StorageResource))
-str(repr(RequestStatus))
 str(repr(PaginationInfo))
-str(repr(MetaData))
+str(repr(RecipeVersion))
+str(repr(RequestStatus))
+str(repr(Recipe))
+str(repr(RecipeFile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WorkspaceListResponse(object):
-    """listing of all workspaces under one team"""
+class RecipeVersionFileListResponse(object):
+    """Response to list files for recipe version request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filters = (
-            None if not fromDict or propDict.get(
-                "filters"
-            ) is None
-            else [ MetaData(i)
-            for i in propDict["filters"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
+        self.recipe = (
+            None if not fromDict or propDict.get(
+                "recipe"
+            ) is None
+            else propDict["recipe"])
+        self.recipeFiles = (
+            None if not fromDict or propDict.get(
+                "recipeFiles"
+            ) is None
+            else [ RecipeFile(i)
+            for i in propDict["recipeFiles"] ])
+        self.recipeVersion = (
+            None if not fromDict or propDict.get(
+                "recipeVersion"
+            ) is None
+            else propDict["recipeVersion"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.workspaces = (
-            None if not fromDict or propDict.get(
-                "workspaces"
-            ) is None
-            else [ StorageResource(i)
-            for i in propDict["workspaces"] ])
-
-    @property
-    def filters(self):
-        """list: array of key-value pairs applied as filters to generate this 
-        list"""
-        return self._filters
-
-    @filters.setter
-    def filters(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._filters = value
-        else:
-            raise TypeError(
-                'Property "filters" of type "list<MetaData>" set to wrong typ'
-                'e'
-            )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
+        """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -85,76 +73,110 @@
         else:
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def recipe(self):
+        """Recipe: Recipe object"""
+        return self._recipe
+
+    @recipe.setter
+    def recipe(self, value):
+        if value is not None and not isinstance(value, Recipe):
+            value = Recipe(value)
+        if (value is None) or isinstance(value, Recipe):
+            self._recipe = value
+        else:
+            raise TypeError(
+                'Property "recipe" of type "list<Recipe>" set to wrong type'
+            )
+
+    @property
+    def recipeFiles(self):
         """ """
+        return self._recipeFiles
+
+    @recipeFiles.setter
+    def recipeFiles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._recipeFiles = value
+        else:
+            raise TypeError(
+                'Property "recipeFiles" of type "list<RecipeFile>" set to wro'
+                'ng type'
+            )
+
+    @property
+    def recipeVersion(self):
+        """RecipeVersion: Recipe version object"""
+        return self._recipeVersion
+
+    @recipeVersion.setter
+    def recipeVersion(self, value):
+        if value is not None and not isinstance(value, RecipeVersion):
+            value = RecipeVersion(value)
+        if (value is None) or isinstance(value, RecipeVersion):
+            self._recipeVersion = value
+        else:
+            raise TypeError(
+                'Property "recipeVersion" of type "list<RecipeVersion>" set t'
+                'o wrong type'
+            )
+
+    @property
+    def requestStatus(self):
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def workspaces(self):
-        """ """
-        return self._workspaces
-
-    @workspaces.setter
-    def workspaces(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._workspaces = value
-        else:
-            raise TypeError(
-                'Property "workspaces" of type "list<StorageResource>" set to'
-                ' wrong type'
-            )
-
     def toDict(self):
         result = {}
-        if self._filters:
-            result["filters"] = [
-                i.toDict() for i in self._filters 
-            ] if self._filters else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._recipe:
+            result["recipe"] = \
+                self._recipe.toDict() if self._recipe is not None else None
+        if self._recipeFiles:
+            result["recipeFiles"] = [
+                i.toDict() for i in self._recipeFiles 
+            ] if self._recipeFiles else []
+        if self._recipeVersion:
+            result["recipeVersion"] = \
+                self._recipeVersion.toDict() if self._recipeVersion is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._workspaces:
-            result["workspaces"] = [
-                i.toDict() for i in self._workspaces 
-            ] if self._workspaces else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._workspaces is not None):
-            for obj in self._workspaces:
-                if (obj is not None): obj.isValid()
-        if (self._filters is not None):
-            for obj in self._filters:
+        if (self._recipe is not None): self._recipe.isValid()
+        if (self._recipeVersion is not None): self._recipeVersion.isValid()
+        if (self._recipeFiles is not None):
+            for obj in self._recipeFiles:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/api/WorkspaceResponse.py` & `ngcbpc/data/uis/IdpLockResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,39 +7,55 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .StorageResource import StorageResource
+from .IdpLock import IdpLock
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(StorageResource))
+str(repr(IdpLock))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class WorkspaceResponse(object):
-    """showing details of the workspace"""
+class IdpLockResponse(object):
+    """Response containing info about the IDP lock for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.idpLock = (
+            None if not fromDict or propDict.get(
+                "idpLock"
+            ) is None
+            else propDict["idpLock"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-        self.workspace = (
-            None if not fromDict or propDict.get(
-                "workspace"
-            ) is None
-            else propDict["workspace"])
+
+    @property
+    def idpLock(self):
+        """IdpLock: Information about the IDP lock for an organization"""
+        return self._idpLock
+
+    @idpLock.setter
+    def idpLock(self, value):
+        if value is not None and not isinstance(value, IdpLock):
+            value = IdpLock(value)
+        if (value is None) or isinstance(value, IdpLock):
+            self._idpLock = value
+        else:
+            raise TypeError(
+                'Property "idpLock" of type "list<IdpLock>" set to wrong type'
+            )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -50,46 +66,39 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
-    @property
-    def workspace(self):
-        """StorageResource: Generic Storage Resource for DL jobs."""
-        return self._workspace
-
-    @workspace.setter
-    def workspace(self, value):
-        if value is not None and not isinstance(value, StorageResource):
-            value = StorageResource(value)
-        if (value is None) or isinstance(value, StorageResource):
-            self._workspace = value
-        else:
-            raise TypeError(
-                'Property "workspace" of type "list<StorageResource>" set to '
-                'wrong type'
-            )
-
     def toDict(self):
         result = {}
+        if self._idpLock:
+            result["idpLock"] = \
+                self._idpLock.toDict() if self._idpLock is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._workspace:
-            result["workspace"] = \
-                self._workspace.toDict() if self._workspace is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._workspace is not None): self._workspace.isValid()
+        if self._requestStatus is None:
+            raise ValueError(
+                "IdpLockResponse.requestStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if self._idpLock is None:
+            raise ValueError(
+                "IdpLockResponse.idpLock doesnt match requirement:" 
+                "required: True"
+            )
         if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._idpLock is not None): self._idpLock.isValid()
         return True
```

## Comparing `ngccli/data/ecm/AdvancedStorage.py` & `ngcbpc/data/uis/RoleScopes.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,140 +14,116 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AdvancedStorage(object):
+class RoleScopes(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alias = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "alias"
+                "description"
             ) is None
-            else propDict["alias"])
-        self.available = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "available"
+                "displayName"
             ) is None
-            else propDict["available"])
-        self.mount = (
+            else propDict["displayName"])
+        self.role = (
             None if not fromDict or propDict.get(
-                "mount"
+                "role"
             ) is None
-            else propDict["mount"])
-        self.type = (
+            else propDict["role"])
+        self.scopes = (
             None if not fromDict or propDict.get(
-                "type"
+                "scopes"
             ) is None
-            else propDict["type"])
-        self.used = (
-            None if not fromDict or propDict.get(
-                "used"
-            ) is None
-            else propDict["used"])
+            else propDict["scopes"])
 
     @property
-    def alias(self):
-        """str: symlink name for data mount"""
-        return self._alias
+    def description(self):
+        """ """
+        return self._description
 
-    @alias.setter
-    def alias(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._alias = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "alias" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def available(self):
-        """str: storage available in Gb"""
-        return self._available
+    def displayName(self):
+        """ """
+        return self._displayName
 
-    @available.setter
-    def available(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._available = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "available" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def mount(self):
-        """str: data mount"""
-        return self._mount
+    def role(self):
+        """ """
+        return self._role
 
-    @mount.setter
-    def mount(self, value):
+    @role.setter
+    def role(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._mount = value
+            self._role = value
         else:
             raise TypeError(
-                'Property "mount" of type "list<str>" set to wrong type'
+                'Property "role" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """str: storage type"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._type = value
-        else:
-            raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def used(self):
-        """str: storage used in Gb"""
-        return self._used
-
-    @used.setter
-    def used(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._used = value
+    def scopes(self):
+        """list: List of scopes for the role"""
+        return self._scopes
+
+    @scopes.setter
+    def scopes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._scopes = value
         else:
             raise TypeError(
-                'Property "used" of type "list<str>" set to wrong type'
+                'Property "scopes" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._alias is not None:
-            result["alias"] = \
-                self._alias
-        if self._available is not None:
-            result["available"] = \
-                self._available
-        if self._mount is not None:
-            result["mount"] = \
-                self._mount
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._used is not None:
-            result["used"] = \
-                self._used
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._role is not None:
+            result["role"] = \
+                self._role
+        if self._scopes is not None:
+            result["scopes"] = \
+                self._scopes
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/AdvancedStorageResponse.py` & `ngcbpc/data/model/RequestStatus.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,144 +6,133 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AdvancedStorage import AdvancedStorage
-from .RequestStatus import RequestStatus
+from .StatusCode import StatusCodeEnum
 
 # Unused import over optimization prevention
-str(repr(AdvancedStorage))
-str(repr(RequestStatus))
+str(repr(StatusCodeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AdvancedStorageResponse(object):
-    """listing of advance storage object"""
+class RequestStatus(object):
+    """Request status information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.containerdStorage = (
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "containerdStorage"
+                "requestId"
             ) is None
-            else propDict["containerdStorage"])
-        self.requestStatus = (
+            else propDict["requestId"])
+        self.serverId = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "serverId"
             ) is None
-            else propDict["requestStatus"])
-        self.storages = (
+            else propDict["serverId"])
+        self.statusCode = (
             None if not fromDict or propDict.get(
-                "storages"
+                "statusCode"
             ) is None
-            else [ AdvancedStorage(i)
-            for i in propDict["storages"] ])
-        self.varlogStorage = (
+            else propDict["statusCode"])
+        self.statusDescription = (
             None if not fromDict or propDict.get(
-                "varlogStorage"
+                "statusDescription"
             ) is None
-            else propDict["varlogStorage"])
+            else propDict["statusDescription"])
 
     @property
-    def containerdStorage(self):
-        """str: containerd storage on the node"""
-        return self._containerdStorage
+    def requestId(self):
+        """str: Request ID"""
+        return self._requestId
 
-    @containerdStorage.setter
-    def containerdStorage(self, value):
+    @requestId.setter
+    def requestId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._containerdStorage = value
+            self._requestId = value
         else:
             raise TypeError(
-                'Property "containerdStorage" of type "list<str>" set to wron'
-                'g type'
+                'Property "requestId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def serverId(self):
+        """str: Server ID"""
+        return self._serverId
+
+    @serverId.setter
+    def serverId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._serverId = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "serverId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def storages(self):
-        """list: array of advance storage object"""
-        return self._storages
-
-    @storages.setter
-    def storages(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._storages = value
+    def statusCode(self):
+        """StatusCodeEnum: Describes response status reported by the server.
+        """
+        return self._statusCode
+
+    @statusCode.setter
+    def statusCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._statusCode = value
         else:
             raise TypeError(
-                'Property "storages" of type "list<AdvancedStorage>" set to w'
-                'rong type'
+                'Property "statusCode" of type "list<StatusCodeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def varlogStorage(self):
-        """str: varlog storage on the node"""
-        return self._varlogStorage
+    def statusDescription(self):
+        """str: Status description"""
+        return self._statusDescription
 
-    @varlogStorage.setter
-    def varlogStorage(self, value):
+    @statusDescription.setter
+    def statusDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._varlogStorage = value
+            self._statusDescription = value
         else:
             raise TypeError(
-                'Property "varlogStorage" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "statusDescription" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._containerdStorage is not None:
-            result["containerdStorage"] = \
-                self._containerdStorage
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._storages:
-            result["storages"] = [
-                i.toDict() for i in self._storages 
-            ] if self._storages else []
-        if self._varlogStorage is not None:
-            result["varlogStorage"] = \
-                self._varlogStorage
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._serverId is not None:
+            result["serverId"] = \
+                self._serverId
+        if self._statusCode is not None:
+            result["statusCode"] = \
+                self._statusCode
+        if self._statusDescription is not None:
+            result["statusDescription"] = \
+                self._statusDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._storages is not None):
-            for obj in self._storages:
-                if (obj is not None): obj.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Alert.py` & `organization/data/subscription_management_service/OrderSummary.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,155 +14,171 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Alert(object):
+class OrderSummary(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alertCriticalLevel = (
+        self.currency = (
             None if not fromDict or propDict.get(
-                "alertCriticalLevel"
+                "currency"
             ) is None
-            else propDict["alertCriticalLevel"])
-        self.alertCriticalMessage = (
+            else propDict["currency"])
+        self.refundAmount = (
             None if not fromDict or propDict.get(
-                "alertCriticalMessage"
+                "refundAmount"
             ) is None
-            else propDict["alertCriticalMessage"])
-        self.alertWarningLevel = (
+            else propDict["refundAmount"])
+        self.subtotal = (
             None if not fromDict or propDict.get(
-                "alertWarningLevel"
+                "subtotal"
             ) is None
-            else propDict["alertWarningLevel"])
-        self.alertWarningMessage = (
+            else propDict["subtotal"])
+        self.tax = (
             None if not fromDict or propDict.get(
-                "alertWarningMessage"
+                "tax"
             ) is None
-            else propDict["alertWarningMessage"])
-        self.key = (
+            else propDict["tax"])
+        self.taxExclusive = (
             None if not fromDict or propDict.get(
-                "key"
+                "taxExclusive"
             ) is None
-            else propDict["key"])
+            else propDict["taxExclusive"])
+        self.total = (
+            None if not fromDict or propDict.get(
+                "total"
+            ) is None
+            else propDict["total"])
 
     @property
-    def alertCriticalLevel(self):
-        """ """
-        return self._alertCriticalLevel
+    def currency(self):
+        """str: currency that the order was placed with"""
+        return self._currency
 
-    @alertCriticalLevel.setter
-    def alertCriticalLevel(self, value):
+    @currency.setter
+    def currency(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._alertCriticalLevel = value
+            self._currency = value
         else:
             raise TypeError(
-                'Property "alertCriticalLevel" of type "list<str>" set to wro'
-                'ng type'
+                'Property "currency" of type "list<str>" set to wrong type'
             )
 
     @property
-    def alertCriticalMessage(self):
-        """ """
-        return self._alertCriticalMessage
-
-    @alertCriticalMessage.setter
-    def alertCriticalMessage(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._alertCriticalMessage = value
+    def refundAmount(self):
+        """float: amount refunded in the order"""
+        return self._refundAmount
+
+    @refundAmount.setter
+    def refundAmount(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._refundAmount = value
         else:
             raise TypeError(
-                'Property "alertCriticalMessage" of type "list<str>" set to w'
-                'rong type'
+                'Property "refundAmount" of type "list<float>" set to wrong t'
+                'ype'
             )
 
     @property
-    def alertWarningLevel(self):
-        """ """
-        return self._alertWarningLevel
-
-    @alertWarningLevel.setter
-    def alertWarningLevel(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._alertWarningLevel = value
+    def subtotal(self):
+        """float: subtotal of the order"""
+        return self._subtotal
+
+    @subtotal.setter
+    def subtotal(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._subtotal = value
         else:
             raise TypeError(
-                'Property "alertWarningLevel" of type "list<str>" set to wron'
-                'g type'
+                'Property "subtotal" of type "list<float>" set to wrong type'
             )
 
     @property
-    def alertWarningMessage(self):
-        """ """
-        return self._alertWarningMessage
-
-    @alertWarningMessage.setter
-    def alertWarningMessage(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._alertWarningMessage = value
+    def tax(self):
+        """float: tax applied to the order"""
+        return self._tax
+
+    @tax.setter
+    def tax(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._tax = value
         else:
             raise TypeError(
-                'Property "alertWarningMessage" of type "list<str>" set to wr'
-                'ong type'
+                'Property "tax" of type "list<float>" set to wrong type'
             )
 
     @property
-    def key(self):
+    def taxExclusive(self):
         """ """
-        return self._key
+        return self._taxExclusive
 
-    @key.setter
-    def key(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._key = value
+    @taxExclusive.setter
+    def taxExclusive(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._taxExclusive = value
         else:
             raise TypeError(
-                'Property "key" of type "list<KeyEnum>" set to wrong type'
+                'Property "taxExclusive" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
-    KeyEnum=["CPU","MEM","DISK",]
-    str(repr(KeyEnum))  # Prevent optimizer removing enum
+    @property
+    def total(self):
+        """float: total cost of the order"""
+        return self._total
+
+    @total.setter
+    def total(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._total = value
+        else:
+            raise TypeError(
+                'Property "total" of type "list<float>" set to wrong type'
+            )
 
     def toDict(self):
         result = {}
-        if self._alertCriticalLevel is not None:
-            result["alertCriticalLevel"] = \
-                self._alertCriticalLevel
-        if self._alertCriticalMessage is not None:
-            result["alertCriticalMessage"] = \
-                self._alertCriticalMessage
-        if self._alertWarningLevel is not None:
-            result["alertWarningLevel"] = \
-                self._alertWarningLevel
-        if self._alertWarningMessage is not None:
-            result["alertWarningMessage"] = \
-                self._alertWarningMessage
-        if self._key is not None:
-            result["key"] = \
-                self._key
+        if self._currency is not None:
+            result["currency"] = \
+                self._currency
+        if self._refundAmount is not None:
+            result["refundAmount"] = \
+                self._refundAmount
+        if self._subtotal is not None:
+            result["subtotal"] = \
+                self._subtotal
+        if self._tax is not None:
+            result["tax"] = \
+                self._tax
+        if self._taxExclusive is not None:
+            result["taxExclusive"] = \
+                self._taxExclusive
+        if self._total is not None:
+            result["total"] = \
+                self._total
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._key is None:
-            raise ValueError(
-                "Alert.key doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/ecm/ApiKeyCreateRequest.py` & `ngcbpc/data/uis/SakCallerInfoRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,55 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApiKeyCreateRequest(object):
-    """Request to create a new api key"""
+class SakCallerInfoRequest(object):
+    """To get info about api key used and user request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.apiKey = (
+        self.credentials = (
             None if not fromDict or propDict.get(
-                "apiKey"
+                "credentials"
             ) is None
-            else propDict["apiKey"])
+            else propDict["credentials"])
 
     @property
-    def apiKey(self):
-        """str: API key"""
-        return self._apiKey
+    def credentials(self):
+        """str: API key value"""
+        return self._credentials
 
-    @apiKey.setter
-    def apiKey(self, value):
+    @credentials.setter
+    def credentials(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._apiKey = value
+            self._credentials = value
         else:
             raise TypeError(
-                'Property "apiKey" of type "list<str>" set to wrong type'
+                'Property "credentials" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._apiKey is not None:
-            result["apiKey"] = \
-                self._apiKey
+        if self._credentials is not None:
+            result["credentials"] = \
+                self._credentials
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._apiKey is None:
+        if self._credentials is None:
             raise ValueError(
-                "ApiKeyCreateRequest.apiKey doesnt match requirement:" 
+                "SakCallerInfoRequest.credentials doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/ecm/ApiKeyResponse.py` & `ngcbpc/data/model/Response.py`

 * *Files 10% similar despite different names*

```diff
@@ -16,49 +16,26 @@
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApiKeyResponse(object):
-    """Get api key response"""
+class Response(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.apiKey = (
-            None if not fromDict or propDict.get(
-                "apiKey"
-            ) is None
-            else propDict["apiKey"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def apiKey(self):
-        """str: Last 4 characters of API key if API key exists. Rest of charac
-        ters are marked as x"""
-        return self._apiKey
-
-    @apiKey.setter
-    def apiKey(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._apiKey = value
-        else:
-            raise TypeError(
-                'Property "apiKey" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -67,17 +44,14 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._apiKey is not None:
-            result["apiKey"] = \
-                self._apiKey
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
```

## Comparing `ngccli/data/ecm/AppConfigCreateRequest.py` & `ngcbpc/data/model/ArtifactDownloadAllRequest.py`

 * *Files 24% similar despite different names*

```diff
@@ -14,104 +14,114 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AppConfigCreateRequest(object):
+class ArtifactDownloadAllRequest(object):
+    """Request to download all files of an artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.artifactType = (
+            None if not fromDict or propDict.get(
+                "artifactType"
+            ) is None
+            else propDict["artifactType"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.values = (
+        self.version = (
             None if not fromDict or propDict.get(
-                "values"
+                "version"
             ) is None
-            else propDict["values"])
+            else propDict["version"])
+
+    @property
+    def artifactType(self):
+        """str: Type of artifact"""
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactType = value
+        else:
+            raise TypeError(
+                'Property "artifactType" of type "list<str>" set to wrong typ'
+                'e'
+            )
 
     @property
     def name(self):
-        """ """
+        """str: Name of the artifact"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def values(self):
-        """ """
-        return self._values
+    def version(self):
+        """str: Artifact version"""
+        return self._version
 
-    @values.setter
-    def values(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._values = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "AppConfigCreateRequest.name doesnt match requirement:" 
+                "ArtifactDownloadAllRequest.name doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "AppConfigCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._name is not None
-            and
-            len(self._name) > 53):
+        if self._version is None:
             raise ValueError(
-                "AppConfigCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
-            raise ValueError(
-                "AppConfigCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z0-9]([-a-z0-9]*[a-z"
-                "0-9])?$")
-        if self._values is None:
+                "ArtifactDownloadAllRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._artifactType is None:
             raise ValueError(
-                "AppConfigCreateRequest.values doesnt match requirement:" 
+                "ArtifactDownloadAllRequest.artifactType doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/ecm/AppConfigResponse.py` & `organization/data/sms/KV.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,90 +6,104 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AppConfigs import AppConfigs
-from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(AppConfigs))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AppConfigResponse(object):
-    """Information about an app config"""
+class KV(object):
+    """Definition of a  key value pair"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.appconfig = (
+        self.key = (
             None if not fromDict or propDict.get(
-                "appconfig"
+                "key"
             ) is None
-            else propDict["appconfig"])
-        self.requestStatus = (
+            else propDict["key"])
+        self.value = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "value"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["value"])
 
     @property
-    def appconfig(self):
-        """ """
-        return self._appconfig
-
-    @appconfig.setter
-    def appconfig(self, value):
-        if value is not None and not isinstance(value, AppConfigs):
-            value = AppConfigs(value)
-        if (value is None) or isinstance(value, AppConfigs):
-            self._appconfig = value
+    def key(self):
+        """str: Key"""
+        return self._key
+
+    @key.setter
+    def key(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._key = value
         else:
             raise TypeError(
-                'Property "appconfig" of type "list<AppConfigs>" set to wrong'
-                ' type'
+                'Property "key" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def value(self):
+        """str: Value"""
+        return self._value
+
+    @value.setter
+    def value(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._value = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._appconfig:
-            result["appconfig"] = \
-                self._appconfig.toDict() if self._appconfig is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._key is not None:
+            result["key"] = \
+                self._key
+        if self._value is not None:
+            result["value"] = \
+                self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._appconfig is not None): self._appconfig.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if self._key is None:
+            raise ValueError(
+                "KV.key doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._key is not None
+            and
+            len(self._key) < 1):
+            raise ValueError(
+                "KV.key: " + str(self._key) + 
+                " doesnt match requirement: minLength: 1")
+        if self._value is None:
+            raise ValueError(
+                "KV.value doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._value is not None
+            and
+            len(self._value) < 1):
+            raise ValueError(
+                "KV.value: " + str(self._value) + 
+                " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/ecm/AppConfigUpdateRequest.py` & `ngcbpc/data/model/DeploymentMemoryParametersMeta.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,62 +6,67 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .CountableResource import CountableResource
 
 # Unused import over optimization prevention
+str(repr(CountableResource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AppConfigUpdateRequest(object):
+class DeploymentMemoryParametersMeta(object):
+    """Cloud Service Provider Deployment Memory Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.values = (
+        self.capacityInGB = (
             None if not fromDict or propDict.get(
-                "values"
+                "capacityInGB"
             ) is None
-            else propDict["values"])
+            else propDict["capacityInGB"])
 
     @property
-    def values(self):
-        """ """
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._values = value
+    def capacityInGB(self):
+        """CountableResource: Countable Resource object"""
+        return self._capacityInGB
+
+    @capacityInGB.setter
+    def capacityInGB(self, value):
+        if value is not None and not isinstance(value, CountableResource):
+            value = CountableResource(value)
+        if (value is None) or isinstance(value, CountableResource):
+            self._capacityInGB = value
         else:
             raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "capacityInGB" of type "list<CountableResource>" se'
+                't to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._capacityInGB:
+            result["capacityInGB"] = \
+                self._capacityInGB.toDict() if self._capacityInGB is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._values is None:
+        if self._capacityInGB is None:
             raise ValueError(
-                "AppConfigUpdateRequest.values doesnt match requirement:" 
+                "DeploymentMemoryParametersMeta.capacityInGB doesnt match requirement:" 
                 "required: True"
             )
+        if (self._capacityInGB is not None): self._capacityInGB.isValid()
         return True
```

## Comparing `ngccli/data/ecm/AppConfigs.py` & `basecommand/data/pym/ClusterModifyRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,121 +6,102 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterModifyParams import ClusterModifyParams
 
 # Unused import over optimization prevention
+str(repr(ClusterModifyParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AppConfigs(object):
+class ClusterModifyRequest(object):
+    """Cluster Modify Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.creationTimestamp = (
+        self.params = (
             None if not fromDict or propDict.get(
-                "creationTimestamp"
+                "params"
             ) is None
-            else propDict["creationTimestamp"])
-        self.name = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "name"
+                "version"
             ) is None
-            else propDict["name"])
-        self.values = (
-            None if not fromDict or propDict.get(
-                "values"
-            ) is None
-            else propDict["values"])
+            else propDict["version"])
 
     @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
-
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
+    def params(self):
+        """ClusterModifyParams: Cluster modification params"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ClusterModifyParams):
+            value = ClusterModifyParams(value)
+        if (value is None) or isinstance(value, ClusterModifyParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
+                'Property "params" of type "list<ClusterModifyParams>" set to'
+                ' wrong type'
             )
 
     @property
-    def name(self):
-        """ """
-        return self._name
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @name.setter
-    def name(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def values(self):
-        """ """
-        return self._values
-
-    @values.setter
-    def values(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._values = value
-        else:
-            raise TypeError(
-                'Property "values" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._creationTimestamp is not None:
-            result["creationTimestamp"] = \
-                self._creationTimestamp
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._values is not None:
-            result["values"] = \
-                self._values
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) > 53):
+        if self._version is None:
             raise ValueError(
-                "AppConfigs.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
+                "ClusterModifyRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._version is not None
             and
-            not re.match(
-                r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
+            len(self._version) < 1):
             raise ValueError(
-                "AppConfigs.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z0-9]([-a-z0-9]*[a-z"
-                "0-9])?$")
+                "ClusterModifyRequest.version: " + str(self._version) + 
+                " doesnt match requirement: minLength: 1")
+        if self._params is None:
+            raise ValueError(
+                "ClusterModifyRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/ecm/AppConfigsResponse.py` & `organization/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,57 +6,56 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AppConfigs import AppConfigs
+from .Order import Order
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(AppConfigs))
+str(repr(Order))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AppConfigsResponse(object):
-    """listing of all app configs"""
+class RedeemPreviewSubscriptionResponse(object):
+    """Redeem preview susbcription response object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.appconfigs = (
+        self.order = (
             None if not fromDict or propDict.get(
-                "appconfigs"
+                "order"
             ) is None
-            else [ AppConfigs(i)
-            for i in propDict["appconfigs"] ])
+            else [ Order(i)
+            for i in propDict["order"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def appconfigs(self):
-        """list: array of object that describes app configs"""
-        return self._appconfigs
+    def order(self):
+        """list: orders"""
+        return self._order
 
-    @appconfigs.setter
-    def appconfigs(self, value):
+    @order.setter
+    def order(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._appconfigs = value
+            self._order = value
         else:
             raise TypeError(
-                'Property "appconfigs" of type "list<AppConfigs>" set to wron'
-                'g type'
+                'Property "order" of type "list<Order>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,30 +69,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._appconfigs:
-            result["appconfigs"] = [
-                i.toDict() for i in self._appconfigs 
-            ] if self._appconfigs else []
+        if self._order:
+            result["order"] = [
+                i.toDict() for i in self._order 
+            ] if self._order else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._appconfigs is not None):
-            for obj in self._appconfigs:
+        if (self._order is not None):
+            for obj in self._order:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Application.py` & `basecommand/data/pym/ProjectTemplateListParams.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,230 +6,191 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .GitApp import GitApp
+from .ClusterParams import ClusterParams
+from .ClusterTypeEnum import ClusterTypeEnum
+from .ClusterInstanceInfo import ClusterInstanceInfo
 
 # Unused import over optimization prevention
-str(repr(GitApp))
+str(repr(ClusterTypeEnum))
+str(repr(ClusterParams))
+str(repr(ClusterInstanceInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Application(object):
+class ProjectTemplateListParams(object):
+    """Project template list parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.canBeDeleted = (
+        self.clusterInstances = (
             None if not fromDict or propDict.get(
-                "canBeDeleted"
+                "clusterInstances"
             ) is None
-            else propDict["canBeDeleted"])
-        self.creationTimestamp = (
+            else [ ClusterInstanceInfo(i)
+            for i in propDict["clusterInstances"] ])
+        self.clusterParams = (
             None if not fromDict or propDict.get(
-                "creationTimestamp"
+                "clusterParams"
             ) is None
-            else propDict["creationTimestamp"])
+            else propDict["clusterParams"])
+        self.clusterType = (
+            None if not fromDict or propDict.get(
+                "clusterType"
+            ) is None
+            else propDict["clusterType"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.displayName = (
-            None if not fromDict or propDict.get(
-                "displayName"
-            ) is None
-            else propDict["displayName"])
-        self.gitApp = (
-            None if not fromDict or propDict.get(
-                "gitApp"
-            ) is None
-            else propDict["gitApp"])
-        self.helmChartName = (
-            None if not fromDict or propDict.get(
-                "helmChartName"
-            ) is None
-            else propDict["helmChartName"])
-        self.helmChartRepository = (
+        self.displayImageURL = (
             None if not fromDict or propDict.get(
-                "helmChartRepository"
+                "displayImageURL"
             ) is None
-            else propDict["helmChartRepository"])
-        self.helmChartVersion = (
+            else propDict["displayImageURL"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "helmChartVersion"
+                "id"
             ) is None
-            else propDict["helmChartVersion"])
-        self.icon = (
+            else propDict["id"])
+        self.isDefault = (
             None if not fromDict or propDict.get(
-                "icon"
+                "isDefault"
             ) is None
-            else propDict["icon"])
+            else propDict["isDefault"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
 
     @property
-    def canBeDeleted(self):
-        """bool: Application cannot be deleted if used in a deployment"""
-        return self._canBeDeleted
-
-    @canBeDeleted.setter
-    def canBeDeleted(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canBeDeleted = value
+    def clusterInstances(self):
+        """list: List of Cluster Instances"""
+        return self._clusterInstances
+
+    @clusterInstances.setter
+    def clusterInstances(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._clusterInstances = value
         else:
             raise TypeError(
-                'Property "canBeDeleted" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "clusterInstances" of type "list<ClusterInstanceInf'
+                'o>" set to wrong type'
             )
 
     @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
+    def clusterParams(self):
+        """ClusterParams: Cluster params"""
+        return self._clusterParams
+
+    @clusterParams.setter
+    def clusterParams(self, value):
+        if value is not None and not isinstance(value, ClusterParams):
+            value = ClusterParams(value)
+        if (value is None) or isinstance(value, ClusterParams):
+            self._clusterParams = value
+        else:
+            raise TypeError(
+                'Property "clusterParams" of type "list<ClusterParams>" set t'
+                'o wrong type'
+            )
 
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
+    @property
+    def clusterType(self):
+        """ClusterTypeEnum: All supported cluster types"""
+        return self._clusterType
+
+    @clusterType.setter
+    def clusterType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._clusterType = value
         else:
             raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
+                'Property "clusterType" of type "list<ClusterTypeEnum>" set t'
+                'o wrong type'
             )
 
     @property
     def description(self):
-        """ """
+        """str: Project template description"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """ """
-        return self._displayName
+    def displayImageURL(self):
+        """str: Display Image URL"""
+        return self._displayImageURL
 
-    @displayName.setter
-    def displayName(self, value):
+    @displayImageURL.setter
+    def displayImageURL(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._displayImageURL = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "displayImageURL" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def gitApp(self):
-        """ """
-        return self._gitApp
-
-    @gitApp.setter
-    def gitApp(self, value):
-        if value is not None and not isinstance(value, GitApp):
-            value = GitApp(value)
-        if (value is None) or isinstance(value, GitApp):
-            self._gitApp = value
-        else:
-            raise TypeError(
-                'Property "gitApp" of type "list<GitApp>" set to wrong type'
-            )
-
-    @property
-    def helmChartName(self):
-        """ """
-        return self._helmChartName
+    def id(self):
+        """str: Project template ID"""
+        return self._id
 
-    @helmChartName.setter
-    def helmChartName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._helmChartName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "helmChartName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def helmChartRepository(self):
-        """ """
-        return self._helmChartRepository
+    def isDefault(self):
+        """bool: Indicate if template is default"""
+        return self._isDefault
 
-    @helmChartRepository.setter
-    def helmChartRepository(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._helmChartRepository = value
-        else:
-            raise TypeError(
-                'Property "helmChartRepository" of type "list<str>" set to wr'
-                'ong type'
-            )
-
-    @property
-    def helmChartVersion(self):
-        """ """
-        return self._helmChartVersion
-
-    @helmChartVersion.setter
-    def helmChartVersion(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._helmChartVersion = value
-        else:
-            raise TypeError(
-                'Property "helmChartVersion" of type "list<str>" set to wrong'
-                ' type'
-            )
-
-    @property
-    def icon(self):
-        """ """
-        return self._icon
-
-    @icon.setter
-    def icon(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._icon = value
+    @isDefault.setter
+    def isDefault(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isDefault = value
         else:
             raise TypeError(
-                'Property "icon" of type "list<str>" set to wrong type'
+                'Property "isDefault" of type "list<bool>" set to wrong type'
             )
 
     @property
     def name(self):
-        """ """
+        """str: Project template name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -237,71 +198,68 @@
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._canBeDeleted is not None:
-            result["canBeDeleted"] = \
-                self._canBeDeleted
-        if self._creationTimestamp is not None:
-            result["creationTimestamp"] = \
-                self._creationTimestamp
+        if self._clusterInstances:
+            result["clusterInstances"] = [
+                i.toDict() for i in self._clusterInstances 
+            ] if self._clusterInstances else []
+        if self._clusterParams:
+            result["clusterParams"] = \
+                self._clusterParams.toDict() if self._clusterParams is not None else None
+        if self._clusterType is not None:
+            result["clusterType"] = \
+                self._clusterType
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._gitApp:
-            result["gitApp"] = \
-                self._gitApp.toDict() if self._gitApp is not None else None
-        if self._helmChartName is not None:
-            result["helmChartName"] = \
-                self._helmChartName
-        if self._helmChartRepository is not None:
-            result["helmChartRepository"] = \
-                self._helmChartRepository
-        if self._helmChartVersion is not None:
-            result["helmChartVersion"] = \
-                self._helmChartVersion
-        if self._icon is not None:
-            result["icon"] = \
-                self._icon
+        if self._displayImageURL is not None:
+            result["displayImageURL"] = \
+                self._displayImageURL
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._isDefault is not None:
+            result["isDefault"] = \
+                self._isDefault
         if self._name is not None:
             result["name"] = \
                 self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) > 53):
+        if self._id is None:
+            raise ValueError(
+                "ProjectTemplateListParams.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
             raise ValueError(
-                "Application.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
+                "ProjectTemplateListParams.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._description is None:
             raise ValueError(
-                "Application.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 254):
+                "ProjectTemplateListParams.description doesnt match requirement:" 
+                "required: True"
+            )
+        if self._displayImageURL is None:
             raise ValueError(
-                "Application.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 254")
-        if (self._gitApp is not None): self._gitApp.isValid()
+                "ProjectTemplateListParams.displayImageURL doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusterInstances is not None):
+            for obj in self._clusterInstances:
+                if (obj is not None): obj.isValid()
+        if (self._clusterParams is not None): self._clusterParams.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ApplicationRequest.py` & `organization/data/sms/HealthResponse.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,61 +6,93 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Application import Application
 
 # Unused import over optimization prevention
-str(repr(Application))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApplicationRequest(object):
+class HealthResponse(object):
+    """Health Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.application = (
+        self.serviceStatus = (
             None if not fromDict or propDict.get(
-                "application"
+                "serviceStatus"
             ) is None
-            else propDict["application"])
+            else propDict["serviceStatus"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def application(self):
-        """ """
-        return self._application
-
-    @application.setter
-    def application(self, value):
-        if value is not None and not isinstance(value, Application):
-            value = Application(value)
-        if (value is None) or isinstance(value, Application):
-            self._application = value
+    def serviceStatus(self):
+        """str: Status of the service"""
+        return self._serviceStatus
+
+    @serviceStatus.setter
+    def serviceStatus(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._serviceStatus = value
         else:
             raise TypeError(
-                'Property "application" of type "list<Application>" set to wr'
-                'ong type'
+                'Property "serviceStatus" of type "list<str>" set to wrong ty'
+                'pe'
+            )
+
+    @property
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
+        else:
+            raise TypeError(
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._application:
-            result["application"] = \
-                self._application.toDict() if self._application is not None else None
+        if self._serviceStatus is not None:
+            result["serviceStatus"] = \
+                self._serviceStatus
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._application is not None): self._application.isValid()
+        if self._version is None:
+            raise ValueError(
+                "HealthResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._serviceStatus is None:
+            raise ValueError(
+                "HealthResponse.serviceStatus doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/ApplicationResponse.py` & `organization/data/subscription_management_service/CreateSubscriptionsResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,57 +6,41 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Subscription import Subscription
 from .RequestStatus import RequestStatus
-from .Application import Application
 
 # Unused import over optimization prevention
-str(repr(Application))
 str(repr(RequestStatus))
+str(repr(Subscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApplicationResponse(object):
-    """Information about one application"""
+class CreateSubscriptionsResponse(object):
+    """Response for create subscriptions admin API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.application = (
-            None if not fromDict or propDict.get(
-                "application"
-            ) is None
-            else propDict["application"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def application(self):
-        """ """
-        return self._application
-
-    @application.setter
-    def application(self, value):
-        if value is not None and not isinstance(value, Application):
-            value = Application(value)
-        if (value is None) or isinstance(value, Application):
-            self._application = value
-        else:
-            raise TypeError(
-                'Property "application" of type "list<Application>" set to wr'
-                'ong type'
-            )
+        self.subscriptions = (
+            None if not fromDict or propDict.get(
+                "subscriptions"
+            ) is None
+            else [ Subscription(i)
+            for i in propDict["subscriptions"] ])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -67,29 +51,49 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscriptions(self):
+        """ """
+        return self._subscriptions
+
+    @subscriptions.setter
+    def subscriptions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._subscriptions = value
+        else:
+            raise TypeError(
+                'Property "subscriptions" of type "list<Subscription>" set to'
+                ' wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._application:
-            result["application"] = \
-                self._application.toDict() if self._application is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptions:
+            result["subscriptions"] = [
+                i.toDict() for i in self._subscriptions 
+            ] if self._subscriptions else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._application is not None): self._application.isValid()
+        if (self._subscriptions is not None):
+            for obj in self._subscriptions:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ApplicationUpdateRequest.py` & `organization/data/subscription_management_service/ListSubscriptionsResponse.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,61 +6,94 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Application import Application
+from .Subscription import Subscription
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Application))
+str(repr(RequestStatus))
+str(repr(Subscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApplicationUpdateRequest(object):
+class ListSubscriptionsResponse(object):
+    """Response for list subscriptions API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.application = (
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "application"
+                "requestStatus"
             ) is None
-            else propDict["application"])
+            else propDict["requestStatus"])
+        self.subscriptions = (
+            None if not fromDict or propDict.get(
+                "subscriptions"
+            ) is None
+            else [ Subscription(i)
+            for i in propDict["subscriptions"] ])
 
     @property
-    def application(self):
+    def requestStatus(self):
         """ """
-        return self._application
+        return self._requestStatus
 
-    @application.setter
-    def application(self, value):
-        if value is not None and not isinstance(value, Application):
-            value = Application(value)
-        if (value is None) or isinstance(value, Application):
-            self._application = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
+        else:
+            raise TypeError(
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
+            )
+
+    @property
+    def subscriptions(self):
+        """list: array of subscriptions objects"""
+        return self._subscriptions
+
+    @subscriptions.setter
+    def subscriptions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._subscriptions = value
         else:
             raise TypeError(
-                'Property "application" of type "list<Application>" set to wr'
-                'ong type'
+                'Property "subscriptions" of type "list<Subscription>" set to'
+                ' wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._application:
-            result["application"] = \
-                self._application.toDict() if self._application is not None else None
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptions:
+            result["subscriptions"] = [
+                i.toDict() for i in self._subscriptions 
+            ] if self._subscriptions else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._application is not None): self._application.isValid()
+        if (self._subscriptions is not None):
+            for obj in self._subscriptions:
+                if (obj is not None): obj.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ApplicationsResponse.py` & `organization/data/subscription_management_service/ListSubscriptionRequestsResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,68 +7,51 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .PaginationInfo import PaginationInfo
+from .SubscriptionRequest import SubscriptionRequest
 from .RequestStatus import RequestStatus
-from .Application import Application
 
 # Unused import over optimization prevention
-str(repr(Application))
-str(repr(PaginationInfo))
+str(repr(SubscriptionRequest))
 str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ApplicationsResponse(object):
-    """listing of all applications with filters applied"""
+class ListSubscriptionRequestsResponse(object):
+    """Response for list subscriptions requests API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.applications = (
-            None if not fromDict or propDict.get(
-                "applications"
-            ) is None
-            else [ Application(i)
-            for i in propDict["applications"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def applications(self):
-        """list: array of object that describes applications"""
-        return self._applications
-
-    @applications.setter
-    def applications(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._applications = value
-        else:
-            raise TypeError(
-                'Property "applications" of type "list<Application>" set to w'
-                'rong type'
-            )
+        self.subscriptionRequests = (
+            None if not fromDict or propDict.get(
+                "subscriptionRequests"
+            ) is None
+            else [ SubscriptionRequest(i)
+            for i in propDict["subscriptionRequests"] ])
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
+        """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -92,36 +75,53 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscriptionRequests(self):
+        """ """
+        return self._subscriptionRequests
+
+    @subscriptionRequests.setter
+    def subscriptionRequests(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._subscriptionRequests = value
+        else:
+            raise TypeError(
+                'Property "subscriptionRequests" of type "list<SubscriptionRe'
+                'quest>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._applications:
-            result["applications"] = [
-                i.toDict() for i in self._applications 
-            ] if self._applications else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptionRequests:
+            result["subscriptionRequests"] = [
+                i.toDict() for i in self._subscriptionRequests 
+            ] if self._subscriptionRequests else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._applications is not None):
-            for obj in self._applications:
+        if (self._subscriptionRequests is not None):
+            for obj in self._subscriptionRequests:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/BuildStatus.py` & `ngcbpc/data/registry/CatalogArtifactMetadata.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,126 +6,154 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .BuildStatusEnum import BuildStatusEnum
-from .ScanResultsStatusEnum import ScanResultsStatusEnum
+from .ProductNamesEnum import ProductNamesEnum
+from .AccessTypeEnum import AccessTypeEnum
 
 # Unused import over optimization prevention
-str(repr(BuildStatusEnum))
-str(repr(ScanResultsStatusEnum))
+str(repr(ProductNamesEnum))
+str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class BuildStatus(object):
+class CatalogArtifactMetadata(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.buildLog = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "buildLog"
+                "accessType"
             ) is None
-            else propDict["buildLog"])
-        self.buildStatus = (
+            else propDict["accessType"])
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "buildStatus"
+                "canGuestPull"
             ) is None
-            else propDict["buildStatus"])
-        self.scanResults = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "scanResults"
+                "canPublicList"
             ) is None
-            else propDict["scanResults"])
-        self.scanResultsStatus = (
+            else propDict["canPublicList"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "scanResultsStatus"
+                "isPublic"
             ) is None
-            else propDict["scanResultsStatus"])
+            else propDict["isPublic"])
+        self.productNames = (
+            None if not fromDict or propDict.get(
+                "productNames"
+            ) is None
+            else propDict["productNames"])
 
     @property
-    def buildLog(self):
+    def accessType(self):
         """ """
-        return self._buildLog
+        return self._accessType
 
-    @buildLog.setter
-    def buildLog(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._buildLog = value
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "buildLog" of type "list<str>" set to wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def buildStatus(self):
-        """BuildStatusEnum: All possible node status enums"""
-        return self._buildStatus
-
-    @buildStatus.setter
-    def buildStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._buildStatus = value
+    def canGuestPull(self):
+        """bool: Guest users can download from the Catalog registry"""
+        return self._canGuestPull
+
+    @canGuestPull.setter
+    def canGuestPull(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "buildStatus" of type "list<BuildStatusEnum>" set t'
-                'o wrong type'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def scanResults(self):
-        """str: The device name for the installer"""
-        return self._scanResults
-
-    @scanResults.setter
-    def scanResults(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._scanResults = value
+    def canPublicList(self):
+        """bool: Publicly listed/searchable in the Catalog registry"""
+        return self._canPublicList
+
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "scanResults" of type "list<str>" set to wrong type'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def scanResultsStatus(self):
-        """ScanResultsStatusEnum: All possible scan results status enums"""
-        return self._scanResultsStatus
+    def isPublic(self):
+        """bool: Publicly available in the Catalog registry"""
+        return self._isPublic
+
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
+        else:
+            raise TypeError(
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
 
-    @scanResultsStatus.setter
-    def scanResultsStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._scanResultsStatus = value
+    @property
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
+
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "scanResultsStatus" of type "list<ScanResultsStatus'
-                'Enum>" set to wrong type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._buildLog is not None:
-            result["buildLog"] = \
-                self._buildLog
-        if self._buildStatus is not None:
-            result["buildStatus"] = \
-                self._buildStatus
-        if self._scanResults is not None:
-            result["scanResults"] = \
-                self._scanResults
-        if self._scanResultsStatus is not None:
-            result["scanResultsStatus"] = \
-                self._scanResultsStatus
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/ComponentResponse.py` & `ngcbpc/data/model/DeploymentStorageParameters.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,45 +14,46 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ComponentResponse(object):
-    """Component names for an org"""
+class DeploymentStorageParameters(object):
+    """Deployment Storage Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.components = (
+        self.capacityInGB = (
             None if not fromDict or propDict.get(
-                "components"
+                "capacityInGB"
             ) is None
-            else propDict["components"])
+            else propDict["capacityInGB"])
 
     @property
-    def components(self):
-        """list: array of component names"""
-        return self._components
-
-    @components.setter
-    def components(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._components = value
+    def capacityInGB(self):
+        """long: Capacity in GB"""
+        return self._capacityInGB
+
+    @capacityInGB.setter
+    def capacityInGB(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._capacityInGB = value
         else:
             raise TypeError(
-                'Property "components" of type "list<str>" set to wrong type'
+                'Property "capacityInGB" of type "list<long>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._components is not None:
-            result["components"] = \
-                self._components
+        if self._capacityInGB is not None:
+            result["capacityInGB"] = \
+                self._capacityInGB
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/Console.py` & `ngcbpc/data/model/AssetUpdateRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,188 +6,216 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RemoteManagerStatusTypeEnum import RemoteManagerStatusTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(RemoteManagerStatusTypeEnum))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Console(object):
+class AssetUpdateRequest(object):
+    """Request to update an asset"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.consoleUrl = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "consoleUrl"
+                "attributes"
             ) is None
-            else propDict["consoleUrl"])
-        self.locationName = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.fileName = (
             None if not fromDict or propDict.get(
-                "locationName"
+                "fileName"
             ) is None
-            else propDict["locationName"])
-        self.nodeName = (
+            else propDict["fileName"])
+        self.mimeType = (
             None if not fromDict or propDict.get(
-                "nodeName"
+                "mimeType"
             ) is None
-            else propDict["nodeName"])
-        self.sessionRemainingTime = (
+            else propDict["mimeType"])
+        self.originUrl = (
             None if not fromDict or propDict.get(
-                "sessionRemainingTime"
+                "originUrl"
             ) is None
-            else propDict["sessionRemainingTime"])
-        self.status = (
+            else propDict["originUrl"])
+        self.owner = (
             None if not fromDict or propDict.get(
-                "status"
+                "owner"
             ) is None
-            else propDict["status"])
+            else propDict["owner"])
+        self.sizeInBytes = (
+            None if not fromDict or propDict.get(
+                "sizeInBytes"
+            ) is None
+            else propDict["sizeInBytes"])
+
+    @property
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
+        else:
+            raise TypeError(
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
+            )
 
     @property
-    def consoleUrl(self):
-        """ """
-        return self._consoleUrl
+    def fileName(self):
+        """str: Asset file name"""
+        return self._fileName
 
-    @consoleUrl.setter
-    def consoleUrl(self, value):
+    @fileName.setter
+    def fileName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._consoleUrl = value
+            self._fileName = value
         else:
             raise TypeError(
-                'Property "consoleUrl" of type "list<str>" set to wrong type'
+                'Property "fileName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def locationName(self):
-        """ """
-        return self._locationName
+    def mimeType(self):
+        """str: MIME type"""
+        return self._mimeType
 
-    @locationName.setter
-    def locationName(self, value):
+    @mimeType.setter
+    def mimeType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationName = value
+            self._mimeType = value
         else:
             raise TypeError(
-                'Property "locationName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "mimeType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nodeName(self):
-        """ """
-        return self._nodeName
+    def originUrl(self):
+        """str: Asset origin URL"""
+        return self._originUrl
 
-    @nodeName.setter
-    def nodeName(self, value):
+    @originUrl.setter
+    def originUrl(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nodeName = value
+            self._originUrl = value
         else:
             raise TypeError(
-                'Property "nodeName" of type "list<str>" set to wrong type'
+                'Property "originUrl" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sessionRemainingTime(self):
-        """int: Session remaining time in seconds. Formula: maxSessionDuration
-         - (now - sessionCreationTime)"""
-        return self._sessionRemainingTime
+    def owner(self):
+        """str: Owner of asset"""
+        return self._owner
 
-    @sessionRemainingTime.setter
-    def sessionRemainingTime(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._sessionRemainingTime = value
+    @owner.setter
+    def owner(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._owner = value
         else:
             raise TypeError(
-                'Property "sessionRemainingTime" of type "list<int>" set to w'
-                'rong type'
+                'Property "owner" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """RemoteManagerStatusTypeEnum: All possible remote manager status enu
-        ms"""
-        return self._status
-
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    def sizeInBytes(self):
+        """long: Size in bytes"""
+        return self._sizeInBytes
+
+    @sizeInBytes.setter
+    def sizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._sizeInBytes = value
         else:
             raise TypeError(
-                'Property "status" of type "list<RemoteManagerStatusTypeEnum>'
-                '" set to wrong type'
+                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._consoleUrl is not None:
-            result["consoleUrl"] = \
-                self._consoleUrl
-        if self._locationName is not None:
-            result["locationName"] = \
-                self._locationName
-        if self._nodeName is not None:
-            result["nodeName"] = \
-                self._nodeName
-        if self._sessionRemainingTime is not None:
-            result["sessionRemainingTime"] = \
-                self._sessionRemainingTime
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._fileName is not None:
+            result["fileName"] = \
+                self._fileName
+        if self._mimeType is not None:
+            result["mimeType"] = \
+                self._mimeType
+        if self._originUrl is not None:
+            result["originUrl"] = \
+                self._originUrl
+        if self._owner is not None:
+            result["owner"] = \
+                self._owner
+        if self._sizeInBytes is not None:
+            result["sizeInBytes"] = \
+                self._sizeInBytes
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._locationName is not None
+        if (self._originUrl is not None
             and
-            len(self._locationName) > 53):
+            len(self._originUrl) > 2000):
             raise ValueError(
-                "Console.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._locationName is not None
+                "AssetUpdateRequest.originUrl: " + str(self._originUrl) + 
+                " doesnt match requirement: maxLength: 2000")
+        if (self._originUrl is not None
             and
             not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._locationName)):
+                r"^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0"
+                "-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"
+                "+$",
+                 self._originUrl)):
             raise ValueError(
-                "Console.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._nodeName is not None
-            and
-            len(self._nodeName) > 53):
+                "AssetUpdateRequest.originUrl: " + str(self._originUrl) + 
+                " doesnt match requirement: pattern: ^https?:\/\/(www\.)?[-a-"
+                "zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,"
+                "6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)+$")
+        if self._fileName is None:
             raise ValueError(
-                "Console.nodeName: " + str(self._nodeName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._nodeName is not None
+                "AssetUpdateRequest.fileName doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._fileName is not None
             and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._nodeName)):
+            len(self._fileName) > 255):
             raise ValueError(
-                "Console.nodeName: " + str(self._nodeName) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
+                "AssetUpdateRequest.fileName: " + str(self._fileName) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ConsoleResponse.py` & `ngcbpc/data/uis/Response.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,57 +6,34 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Console import Console
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Console))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ConsoleResponse(object):
+class Response(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.console = (
-            None if not fromDict or propDict.get(
-                "console"
-            ) is None
-            else propDict["console"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def console(self):
-        """ """
-        return self._console
-
-    @console.setter
-    def console(self, value):
-        if value is not None and not isinstance(value, Console):
-            value = Console(value)
-        if (value is None) or isinstance(value, Console):
-            self._console = value
-        else:
-            raise TypeError(
-                'Property "console" of type "list<Console>" set to wrong type'
-            )
-
-    @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
@@ -67,27 +44,23 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._console:
-            result["console"] = \
-                self._console.toDict() if self._console is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._console is not None): self._console.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ConsolesResponse.py` & `organization/data/subscription_management_service/RedeemSubscriptionResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,57 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Console import Console
+from .SubscriptionStatusEnum import SubscriptionStatusEnum
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Console))
+str(repr(SubscriptionStatusEnum))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ConsolesResponse(object):
+class RedeemSubscriptionResponse(object):
+    """Redeem subscription response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.consoles = (
-            None if not fromDict or propDict.get(
-                "consoles"
-            ) is None
-            else [ Console(i)
-            for i in propDict["consoles"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def consoles(self):
-        """list: array of console object"""
-        return self._consoles
-
-    @consoles.setter
-    def consoles(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._consoles = value
-        else:
-            raise TypeError(
-                'Property "consoles" of type "list<Console>" set to wrong typ'
-                'e'
-            )
+        self.status = (
+            None if not fromDict or propDict.get(
+                "status"
+            ) is None
+            else propDict["status"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -67,32 +50,43 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def status(self):
+        """SubscriptionStatusEnum: All possible subscription status enums"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
+        else:
+            raise TypeError(
+                'Property "status" of type "list<SubscriptionStatusEnum>" set'
+                ' to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._consoles:
-            result["consoles"] = [
-                i.toDict() for i in self._consoles 
-            ] if self._consoles else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._consoles is not None):
-            for obj in self._consoles:
-                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/CreateCustomRootFsRequest.py` & `ngcbpc/data/uis/InfinityManagerSettings.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,83 +14,77 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreateCustomRootFsRequest(object):
+class InfinityManagerSettings(object):
+    """Infinity manager setting definition"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deviceType = (
+        self.enableTeamOverride = (
             None if not fromDict or propDict.get(
-                "deviceType"
+                "enableTeamOverride"
             ) is None
-            else propDict["deviceType"])
-        self.version = (
+            else propDict["enableTeamOverride"])
+        self.enabled = (
             None if not fromDict or propDict.get(
-                "version"
+                "enabled"
             ) is None
-            else propDict["version"])
+            else propDict["enabled"])
 
     @property
-    def deviceType(self):
-        """str: Device type for the custom root FS"""
-        return self._deviceType
-
-    @deviceType.setter
-    def deviceType(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._deviceType = value
+    def enableTeamOverride(self):
+        """bool: Allow override settings at team level. Only used in org level
+         object"""
+        return self._enableTeamOverride
+
+    @enableTeamOverride.setter
+    def enableTeamOverride(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._enableTeamOverride = value
         else:
             raise TypeError(
-                'Property "deviceType" of type "list<str>" set to wrong type'
+                'Property "enableTeamOverride" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def version(self):
-        """str: Version for the custom root FS"""
-        return self._version
-
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
+    def enabled(self):
+        """bool: Enable the infinity manager or not. Used both in org and team
+         level object"""
+        return self._enabled
+
+    @enabled.setter
+    def enabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._enabled = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "enabled" of type "list<bool>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deviceType is not None:
-            result["deviceType"] = \
-                self._deviceType
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._enableTeamOverride is not None:
+            result["enableTeamOverride"] = \
+                self._enableTeamOverride
+        if self._enabled is not None:
+            result["enabled"] = \
+                self._enabled
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._deviceType is None:
-            raise ValueError(
-                "CreateCustomRootFsRequest.deviceType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._version is None:
-            raise ValueError(
-                "CreateCustomRootFsRequest.version doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/ecm/CreateDeploymentRequest.py` & `ngcbpc/data/registry/RepositoryCreateRequest.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,372 +14,329 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreateDeploymentRequest(object):
+class RepositoryCreateRequest(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowAnyCapability = (
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "allowAnyCapability"
+                "builtBy"
             ) is None
-            else propDict["allowAnyCapability"])
-        self.allowAnyHostPath = (
+            else propDict["builtBy"])
+        self.categories = (
             None if not fromDict or propDict.get(
-                "allowAnyHostPath"
+                "categories"
             ) is None
-            else propDict["allowAnyHostPath"])
-        self.allowDevMount = (
+            else propDict["categories"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "allowDevMount"
+                "description"
             ) is None
-            else propDict["allowDevMount"])
-        self.allowHostNamespace = (
-            None if not fromDict or propDict.get(
-                "allowHostNamespace"
-            ) is None
-            else propDict["allowHostNamespace"])
-        self.allowHostPathPV = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "allowHostPathPV"
+                "displayName"
             ) is None
-            else propDict["allowHostPathPV"])
-        self.allowPrivileged = (
+            else propDict["displayName"])
+        self.isMultinodeEnabled = (
             None if not fromDict or propDict.get(
-                "allowPrivileged"
+                "isMultinodeEnabled"
             ) is None
-            else propDict["allowPrivileged"])
-        self.appConfigName = (
+            else propDict["isMultinodeEnabled"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "appConfigName"
+                "labels"
             ) is None
-            else propDict["appConfigName"])
-        self.appName = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "appName"
+                "labelsV2"
             ) is None
-            else propDict["appName"])
-        self.displayName = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "logo"
             ) is None
-            else propDict["displayName"])
-        self.locations = (
-            None if not fromDict or propDict.get(
-                "locations"
-            ) is None
-            else propDict["locations"])
+            else propDict["logo"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.targetNamespace = (
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "targetNamespace"
+                "publisher"
             ) is None
-            else propDict["targetNamespace"])
+            else propDict["publisher"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
 
     @property
-    def allowAnyCapability(self):
-        """bool: Allow Any Process Capability Flags to the Application Deploym
-        ent"""
-        return self._allowAnyCapability
+    def builtBy(self):
+        """str: organization that built the repository"""
+        return self._builtBy
 
-    @allowAnyCapability.setter
-    def allowAnyCapability(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyCapability = value
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "allowAnyCapability" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowAnyHostPath(self):
-        """bool: Allow Any System HostPath Access to the Application Deploymen
-        t"""
-        return self._allowAnyHostPath
+    def categories(self):
+        """list: list of categories the repository belongs to"""
+        return self._categories
 
-    @allowAnyHostPath.setter
-    def allowAnyHostPath(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyHostPath = value
+    @categories.setter
+    def categories(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._categories = value
         else:
             raise TypeError(
-                'Property "allowAnyHostPath" of type "list<bool>" set to wron'
-                'g type'
+                'Property "categories" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowDevMount(self):
-        """bool: Allow System Devices Access to the Application Deployment"""
-        return self._allowDevMount
+    def description(self):
+        """str: description of the repo"""
+        return self._description
 
-    @allowDevMount.setter
-    def allowDevMount(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowDevMount = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "allowDevMount" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowHostNamespace(self):
-        """bool: Allow System Process Access to the Application Deployment"""
-        return self._allowHostNamespace
+    def displayName(self):
+        """ """
+        return self._displayName
 
-    @allowHostNamespace.setter
-    def allowHostNamespace(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowHostNamespace = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "allowHostNamespace" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowHostPathPV(self):
-        """bool: Allow System HostPath Access for PersistentVolumes to the App
-        lication Deployment"""
-        return self._allowHostPathPV
+    def isMultinodeEnabled(self):
+        """bool: indicate if multinode job can be ran using the repo"""
+        return self._isMultinodeEnabled
 
-    @allowHostPathPV.setter
-    def allowHostPathPV(self, value):
+    @isMultinodeEnabled.setter
+    def isMultinodeEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowHostPathPV = value
+            self._isMultinodeEnabled = value
         else:
             raise TypeError(
-                'Property "allowHostPathPV" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "isMultinodeEnabled" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def allowPrivileged(self):
-        """bool: Allow Privileged Containers to the Application Deployment"""
-        return self._allowPrivileged
+    def labels(self):
+        """list: list of labels on the repository"""
+        return self._labels
 
-    @allowPrivileged.setter
-    def allowPrivileged(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowPrivileged = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "allowPrivileged" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def appConfigName(self):
-        """str: App config in the deployment"""
-        return self._appConfigName
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @appConfigName.setter
-    def appConfigName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._appConfigName = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "appConfigName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def appName(self):
-        """str: App in the deployment"""
-        return self._appName
+    def logo(self):
+        """str: url to repository logo"""
+        return self._logo
 
-    @appName.setter
-    def appName(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._appName = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "appName" of type "list<str>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the deployment"""
-        return self._displayName
+    def name(self):
+        """str: unique name of the repo"""
+        return self._name
 
-    @displayName.setter
-    def displayName(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
-        else:
-            raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def locations(self):
-        """list: App deploys in locations"""
-        return self._locations
-
-    @locations.setter
-    def locations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._locations = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "locations" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the deployment"""
-        return self._name
+    def publisher(self):
+        """str: organization that published the repository"""
+        return self._publisher
 
-    @name.setter
-    def name(self, value):
+    @publisher.setter
+    def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def targetNamespace(self):
-        """str: target namespace of the deployment"""
-        return self._targetNamespace
+    def shortDescription(self):
+        """str: short description of the repo"""
+        return self._shortDescription
 
-    @targetNamespace.setter
-    def targetNamespace(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._targetNamespace = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "targetNamespace" of type "list<str>" set to wrong '
-                'type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowAnyCapability is not None:
-            result["allowAnyCapability"] = \
-                self._allowAnyCapability
-        if self._allowAnyHostPath is not None:
-            result["allowAnyHostPath"] = \
-                self._allowAnyHostPath
-        if self._allowDevMount is not None:
-            result["allowDevMount"] = \
-                self._allowDevMount
-        if self._allowHostNamespace is not None:
-            result["allowHostNamespace"] = \
-                self._allowHostNamespace
-        if self._allowHostPathPV is not None:
-            result["allowHostPathPV"] = \
-                self._allowHostPathPV
-        if self._allowPrivileged is not None:
-            result["allowPrivileged"] = \
-                self._allowPrivileged
-        if self._appConfigName is not None:
-            result["appConfigName"] = \
-                self._appConfigName
-        if self._appName is not None:
-            result["appName"] = \
-                self._appName
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._categories is not None:
+            result["categories"] = \
+                self._categories
+        if self._description is not None:
+            result["description"] = \
+                self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._locations is not None:
-            result["locations"] = \
-                self._locations
+        if self._isMultinodeEnabled is not None:
+            result["isMultinodeEnabled"] = \
+                self._isMultinodeEnabled
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._targetNamespace is not None:
-            result["targetNamespace"] = \
-                self._targetNamespace
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "CreateDeploymentRequest.name doesnt match requirement:" 
+                "RepositoryCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
         if (self._name is not None
             and
-            len(self._name) > 53):
+            len(self._name) < 1):
             raise ValueError(
-                "CreateDeploymentRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
+                "RepositoryCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._name is not None
+            and
+            len(self._name) > 256):
+            raise ValueError(
+                "RepositoryCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 256")
         if (self._name is not None
             and
             not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
+                r"[a-z0-9]+(?:[._-][a-z0-9]+)*",
                  self._name)):
             raise ValueError(
-                "CreateDeploymentRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
+                "RepositoryCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: [a-z0-9]+(?:[._-][a-z0-9"
+                "]+)*")
         if (self._displayName is not None
             and
-            len(self._displayName) > 255):
-            raise ValueError(
-                "CreateDeploymentRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._appName is None:
-            raise ValueError(
-                "CreateDeploymentRequest.appName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._appName is not None
-            and
-            len(self._appName) > 53):
+            len(self._displayName) < 2):
             raise ValueError(
-                "CreateDeploymentRequest.appName: " + str(self._appName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._appConfigName is not None
+                "RepositoryCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
             and
-            len(self._appConfigName) > 53):
+            len(self._displayName) > 64):
             raise ValueError(
-                "CreateDeploymentRequest.appConfigName: " + str(self._appConfigName) + 
-                " doesnt match requirement: maxLength: 53")
-        if self._locations is None:
-            raise ValueError(
-                "CreateDeploymentRequest.locations doesnt match requirement:" 
-                "required: True"
-            )
+                "RepositoryCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
         return True
```

## Comparing `ngccli/data/ecm/CreateLocationRequest.py` & `ngcbpc/data/model/CollectionCreateRequest.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,119 +6,143 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .CollectionCategoryType import CollectionCategoryTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
+str(repr(ArtifactAttribute))
+str(repr(CollectionCategoryTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreateLocationRequest(object):
+class CollectionCreateRequest(object):
+    """Request to create a new collection"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.address = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "address"
+                "attributes"
             ) is None
-            else propDict["address"])
-        self.allowHighAvailability = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "allowHighAvailability"
+                "builtBy"
             ) is None
-            else propDict["allowHighAvailability"])
-        self.argoCDEnabled = (
+            else propDict["builtBy"])
+        self.category = (
             None if not fromDict or propDict.get(
-                "argoCDEnabled"
+                "category"
             ) is None
-            else propDict["argoCDEnabled"])
+            else propDict["category"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
+        self.labels = (
+            None if not fromDict or propDict.get(
+                "labels"
+            ) is None
+            else propDict["labels"])
+        self.labelsV2 = (
+            None if not fromDict or propDict.get(
+                "labelsV2"
+            ) is None
+            else propDict["labelsV2"])
+        self.logo = (
+            None if not fromDict or propDict.get(
+                "logo"
+            ) is None
+            else propDict["logo"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.signedContainersEnabled = (
+        self.ownerName = (
+            None if not fromDict or propDict.get(
+                "ownerName"
+            ) is None
+            else propDict["ownerName"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "signedContainersEnabled"
+                "publisher"
             ) is None
-            else propDict["signedContainersEnabled"])
-        self.version = (
+            else propDict["publisher"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "version"
+                "shortDescription"
             ) is None
-            else propDict["version"])
+            else propDict["shortDescription"])
 
     @property
-    def address(self):
-        """str: Address of the location"""
-        return self._address
-
-    @address.setter
-    def address(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._address = value
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "address" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def allowHighAvailability(self):
-        """bool: Location is HA or not"""
-        return self._allowHighAvailability
+    def builtBy(self):
+        """str: organization that built the collection"""
+        return self._builtBy
 
-    @allowHighAvailability.setter
-    def allowHighAvailability(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowHighAvailability = value
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "allowHighAvailability" of type "list<bool>" set to'
-                ' wrong type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def argoCDEnabled(self):
-        """bool: Location has ArgoCD deployments enabled or not"""
-        return self._argoCDEnabled
-
-    @argoCDEnabled.setter
-    def argoCDEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._argoCDEnabled = value
+    def category(self):
+        """ """
+        return self._category
+
+    @category.setter
+    def category(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._category = value
         else:
             raise TypeError(
-                'Property "argoCDEnabled" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "category" of type "list<CollectionCategoryTypeEnum'
+                '>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the location"""
+        """str: Description of the collection"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -126,144 +150,259 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """str: Display name of the location"""
+        """str: Display name"""
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
+    def labels(self):
+        """ """
+        return self._labels
+
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
+        else:
+            raise TypeError(
+                'Property "labels" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
+
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
+        else:
+            raise TypeError(
+                'Property "labelsV2" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
+
+    @logo.setter
+    def logo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._logo = value
+        else:
+            raise TypeError(
+                'Property "logo" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def name(self):
-        """str: Name of the location"""
+        """str: Unique name of the collection"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def signedContainersEnabled(self):
-        """bool: Location has signed containers required or not"""
-        return self._signedContainersEnabled
-
-    @signedContainersEnabled.setter
-    def signedContainersEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._signedContainersEnabled = value
+    def ownerName(self):
+        """str: Name of the user who owns this collection"""
+        return self._ownerName
+
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "signedContainersEnabled" of type "list<bool>" set '
-                'to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def publisher(self):
+        """str: organization that published the collection"""
+        return self._publisher
+
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
+        else:
+            raise TypeError(
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def version(self):
-        """str: Version for the location"""
-        return self._version
+    def shortDescription(self):
+        """str: Short description of the collection"""
+        return self._shortDescription
 
-    @version.setter
-    def version(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._address is not None:
-            result["address"] = \
-                self._address
-        if self._allowHighAvailability is not None:
-            result["allowHighAvailability"] = \
-                self._allowHighAvailability
-        if self._argoCDEnabled is not None:
-            result["argoCDEnabled"] = \
-                self._argoCDEnabled
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._category is not None:
+            result["category"] = \
+                self._category
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._signedContainersEnabled is not None:
-            result["signedContainersEnabled"] = \
-                self._signedContainersEnabled
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "CreateLocationRequest.name doesnt match requirement:" 
+                "CollectionCreateRequest.name doesnt match requirement:" 
                 "required: True"
             )
         if (self._name is not None
             and
-            len(self._name) > 53):
+            len(self._name) < 1):
             raise ValueError(
-                "CreateLocationRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
+                "CollectionCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._name is not None
+            and
+            len(self._name) > 64):
+            raise ValueError(
+                "CollectionCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
         if (self._name is not None
             and
             not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
+                r"^[a-z][a-z\d_-]*$",
                  self._name)):
             raise ValueError(
-                "CreateLocationRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
+                "CollectionCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: ^[a-z][a-z\d_-]*$")
+        if self._shortDescription is None:
+            raise ValueError(
+                "CollectionCreateRequest.shortDescription doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._shortDescription is not None
+            and
+            len(self._shortDescription) > 255):
+            raise ValueError(
+                "CollectionCreateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
         if (self._displayName is not None
             and
-            len(self._displayName) > 255):
+            len(self._displayName) < 2):
             raise ValueError(
-                "CreateLocationRequest.displayName: " + str(self._displayName) + 
+                "CollectionCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
+            and
+            len(self._displayName) > 64):
+            raise ValueError(
+                "CollectionCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if (self._ownerName is not None
+            and
+            len(self._ownerName) > 255):
+            raise ValueError(
+                "CollectionCreateRequest.ownerName: " + str(self._ownerName) + 
                 " doesnt match requirement: maxLength: 255")
-        if self._address is None:
+        if (self._logo is not None
+            and
+            len(self._logo) > 255):
             raise ValueError(
-                "CreateLocationRequest.address doesnt match requirement:" 
-                "required: True"
-            )
-        if self._description is None:
+                "CollectionCreateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
+            and
+            len(self._publisher) > 255):
+            raise ValueError(
+                "CollectionCreateRequest.publisher: " + str(self._publisher) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._category is None:
             raise ValueError(
-                "CreateLocationRequest.description doesnt match requirement:" 
+                "CollectionCreateRequest.category doesnt match requirement:" 
                 "required: True"
             )
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/CreateNodeRequest.py` & `basecommand/data/pym/ProjectTemplateInfoResponse.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,118 +6,105 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectTemplateParams import ProjectTemplateParams
+from .ClusterInstanceInfo import ClusterInstanceInfo
 
 # Unused import over optimization prevention
+str(repr(ProjectTemplateParams))
+str(repr(ClusterInstanceInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CreateNodeRequest(object):
+class ProjectTemplateInfoResponse(object):
+    """Project Template Info Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.description = (
+        self.clusterInstances = (
             None if not fromDict or propDict.get(
-                "description"
+                "clusterInstances"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else [ ClusterInstanceInfo(i)
+            for i in propDict["clusterInstances"] ])
+        self.id = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "id"
             ) is None
-            else propDict["displayName"])
-        self.name = (
+            else propDict["id"])
+        self.params = (
             None if not fromDict or propDict.get(
-                "name"
+                "params"
             ) is None
-            else propDict["name"])
-        self.type = (
-            None if not fromDict or propDict.get(
-                "type"
-            ) is None
-            else propDict["type"])
+            else propDict["params"])
         self.version = (
             None if not fromDict or propDict.get(
                 "version"
             ) is None
             else propDict["version"])
 
     @property
-    def description(self):
-        """str: Description of the node"""
-        return self._description
-
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    def clusterInstances(self):
+        """list: List of Cluster Instances"""
+        return self._clusterInstances
+
+    @clusterInstances.setter
+    def clusterInstances(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._clusterInstances = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "clusterInstances" of type "list<ClusterInstanceInf'
+                'o>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the node"""
-        return self._displayName
+    def id(self):
+        """str: Project template ID"""
+        return self._id
 
-    @displayName.setter
-    def displayName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the node"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def params(self):
+        """ProjectTemplateParams: Project template parameters"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectTemplateParams):
+            value = ProjectTemplateParams(value)
+        if (value is None) or isinstance(value, ProjectTemplateParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def type(self):
-        """str: Type of the node"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._type = value
-        else:
-            raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "params" of type "list<ProjectTemplateParams>" set '
+                'to wrong type'
             )
 
     @property
     def version(self):
-        """str: Version of the node"""
+        """str: Payload version"""
         return self._version
 
     @version.setter
     def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -125,65 +112,51 @@
         else:
             raise TypeError(
                 'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._clusterInstances:
+            result["clusterInstances"] = [
+                i.toDict() for i in self._clusterInstances 
+            ] if self._clusterInstances else []
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
         if self._version is not None:
             result["version"] = \
                 self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._version is None:
             raise ValueError(
-                "CreateNodeRequest.name doesnt match requirement:" 
+                "ProjectTemplateInfoResponse.version doesnt match requirement:" 
                 "required: True"
             )
-        if (self._name is not None
-            and
-            len(self._name) > 53):
-            raise ValueError(
-                "CreateNodeRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
-            raise ValueError(
-                "CreateNodeRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 255):
+        if self._id is None:
             raise ValueError(
-                "CreateNodeRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._description is None:
+                "ProjectTemplateInfoResponse.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
             raise ValueError(
-                "CreateNodeRequest.description doesnt match requirement:" 
+                "ProjectTemplateInfoResponse.params doesnt match requirement:" 
                 "required: True"
             )
+        if (self._params is not None): self._params.isValid()
+        if (self._clusterInstances is not None):
+            for obj in self._clusterInstances:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/CustomInstaller.py` & `ngcbpc/data/model/ArtifactDeploymentParameters.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,286 +6,254 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ValidationStatus import ValidationStatus
-from .BuildStatus import BuildStatus
+from .DeploymentArtifactParameters import DeploymentArtifactParameters
+from .DeploymentStorageParameters import DeploymentStorageParameters
+from .DeploymentGpuParameters import DeploymentGpuParameters
+from .DeploymentMemoryParameters import DeploymentMemoryParameters
+from .DeploymentCpuParameters import DeploymentCpuParameters
 
 # Unused import over optimization prevention
-str(repr(BuildStatus))
-str(repr(ValidationStatus))
+str(repr(DeploymentMemoryParameters))
+str(repr(DeploymentGpuParameters))
+str(repr(DeploymentCpuParameters))
+str(repr(DeploymentArtifactParameters))
+str(repr(DeploymentStorageParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CustomInstaller(object):
+class ArtifactDeploymentParameters(object):
+    """Artifact Deployment Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.buildStatus = (
+        self.container = (
             None if not fromDict or propDict.get(
-                "buildStatus"
+                "container"
             ) is None
-            else propDict["buildStatus"])
-        self.description = (
+            else propDict["container"])
+        self.cpu = (
             None if not fromDict or propDict.get(
-                "description"
+                "cpu"
             ) is None
-            else propDict["description"])
-        self.deviceName = (
+            else propDict["cpu"])
+        self.csp = (
             None if not fromDict or propDict.get(
-                "deviceName"
+                "csp"
             ) is None
-            else propDict["deviceName"])
-        self.installerImage = (
+            else propDict["csp"])
+        self.gpu = (
             None if not fromDict or propDict.get(
-                "installerImage"
+                "gpu"
             ) is None
-            else propDict["installerImage"])
-        self.otaRunnerImage = (
+            else propDict["gpu"])
+        self.memory = (
             None if not fromDict or propDict.get(
-                "otaRunnerImage"
+                "memory"
             ) is None
-            else propDict["otaRunnerImage"])
-        self.previousVersions = (
+            else propDict["memory"])
+        self.model = (
             None if not fromDict or propDict.get(
-                "previousVersions"
+                "model"
             ) is None
-            else propDict["previousVersions"])
-        self.rootfsImage = (
+            else propDict["model"])
+        self.resource = (
             None if not fromDict or propDict.get(
-                "rootfsImage"
+                "resource"
             ) is None
-            else propDict["rootfsImage"])
-        self.uploadedArtifacts = (
+            else propDict["resource"])
+        self.storage = (
             None if not fromDict or propDict.get(
-                "uploadedArtifacts"
+                "storage"
             ) is None
-            else propDict["uploadedArtifacts"])
-        self.validation = (
-            None if not fromDict or propDict.get(
-                "validation"
-            ) is None
-            else propDict["validation"])
-        self.version = (
-            None if not fromDict or propDict.get(
-                "version"
-            ) is None
-            else propDict["version"])
-
-    @property
-    def buildStatus(self):
-        """ """
-        return self._buildStatus
-
-    @buildStatus.setter
-    def buildStatus(self, value):
-        if value is not None and not isinstance(value, BuildStatus):
-            value = BuildStatus(value)
-        if (value is None) or isinstance(value, BuildStatus):
-            self._buildStatus = value
-        else:
-            raise TypeError(
-                'Property "buildStatus" of type "list<BuildStatus>" set to wr'
-                'ong type'
-            )
+            else propDict["storage"])
 
     @property
-    def description(self):
-        """str: Description of the custom build"""
-        return self._description
+    def container(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._container
 
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    @container.setter
+    def container(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._container = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "container" of type "list<DeploymentArtifactParamet'
+                'ers>" set to wrong type'
             )
 
     @property
-    def deviceName(self):
-        """str: The device name for the installer"""
-        return self._deviceName
+    def cpu(self):
+        """DeploymentCpuParameters: Deployment CPU Parameters object"""
+        return self._cpu
 
-    @deviceName.setter
-    def deviceName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._deviceName = value
+    @cpu.setter
+    def cpu(self, value):
+        if value is not None and not isinstance(value, DeploymentCpuParameters):
+            value = DeploymentCpuParameters(value)
+        if (value is None) or isinstance(value, DeploymentCpuParameters):
+            self._cpu = value
         else:
             raise TypeError(
-                'Property "deviceName" of type "list<str>" set to wrong type'
+                'Property "cpu" of type "list<DeploymentCpuParameters>" set t'
+                'o wrong type'
             )
 
     @property
-    def installerImage(self):
-        """str: URL of installer image"""
-        return self._installerImage
+    def csp(self):
+        """str: Cloud Service Provider name"""
+        return self._csp
 
-    @installerImage.setter
-    def installerImage(self, value):
+    @csp.setter
+    def csp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._installerImage = value
+            self._csp = value
         else:
             raise TypeError(
-                'Property "installerImage" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "csp" of type "list<str>" set to wrong type'
             )
 
     @property
-    def otaRunnerImage(self):
-        """str: URL of the runner image"""
-        return self._otaRunnerImage
+    def gpu(self):
+        """DeploymentGpuParameters: Deployment GPU Parameters object"""
+        return self._gpu
 
-    @otaRunnerImage.setter
-    def otaRunnerImage(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._otaRunnerImage = value
+    @gpu.setter
+    def gpu(self, value):
+        if value is not None and not isinstance(value, DeploymentGpuParameters):
+            value = DeploymentGpuParameters(value)
+        if (value is None) or isinstance(value, DeploymentGpuParameters):
+            self._gpu = value
         else:
             raise TypeError(
-                'Property "otaRunnerImage" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "gpu" of type "list<DeploymentGpuParameters>" set t'
+                'o wrong type'
             )
 
     @property
-    def previousVersions(self):
-        """list: List of strings that tell which previous versions will OTA di
-        rectly to this build"""
-        return self._previousVersions
-
-    @previousVersions.setter
-    def previousVersions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._previousVersions = value
+    def memory(self):
+        """DeploymentMemoryParameters: Deployment Memory Parameters object"""
+        return self._memory
+
+    @memory.setter
+    def memory(self, value):
+        if value is not None and not isinstance(value, DeploymentMemoryParameters):
+            value = DeploymentMemoryParameters(value)
+        if (value is None) or isinstance(value, DeploymentMemoryParameters):
+            self._memory = value
         else:
             raise TypeError(
-                'Property "previousVersions" of type "list<str>" set to wrong'
-                ' type'
+                'Property "memory" of type "list<DeploymentMemoryParameters>"'
+                ' set to wrong type'
             )
 
     @property
-    def rootfsImage(self):
-        """str: URL of the system image"""
-        return self._rootfsImage
+    def model(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._model
 
-    @rootfsImage.setter
-    def rootfsImage(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._rootfsImage = value
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._model = value
         else:
             raise TypeError(
-                'Property "rootfsImage" of type "list<str>" set to wrong type'
+                'Property "model" of type "list<DeploymentArtifactParameters>'
+                '" set to wrong type'
             )
 
     @property
-    def uploadedArtifacts(self):
-        """list: urls to uploaded artficats"""
-        return self._uploadedArtifacts
-
-    @uploadedArtifacts.setter
-    def uploadedArtifacts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._uploadedArtifacts = value
-        else:
-            raise TypeError(
-                'Property "uploadedArtifacts" of type "list<str>" set to wron'
-                'g type'
-            )
+    def resource(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._resource
 
-    @property
-    def validation(self):
-        """ """
-        return self._validation
-
-    @validation.setter
-    def validation(self, value):
-        if value is not None and not isinstance(value, ValidationStatus):
-            value = ValidationStatus(value)
-        if (value is None) or isinstance(value, ValidationStatus):
-            self._validation = value
+    @resource.setter
+    def resource(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._resource = value
         else:
             raise TypeError(
-                'Property "validation" of type "list<ValidationStatus>" set t'
-                'o wrong type'
+                'Property "resource" of type "list<DeploymentArtifactParamete'
+                'rs>" set to wrong type'
             )
 
     @property
-    def version(self):
-        """ """
-        return self._version
+    def storage(self):
+        """DeploymentStorageParameters: Deployment Storage Parameters object
+        """
+        return self._storage
 
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
+    @storage.setter
+    def storage(self, value):
+        if value is not None and not isinstance(value, DeploymentStorageParameters):
+            value = DeploymentStorageParameters(value)
+        if (value is None) or isinstance(value, DeploymentStorageParameters):
+            self._storage = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "storage" of type "list<DeploymentStorageParameters'
+                '>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._buildStatus:
-            result["buildStatus"] = \
-                self._buildStatus.toDict() if self._buildStatus is not None else None
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._deviceName is not None:
-            result["deviceName"] = \
-                self._deviceName
-        if self._installerImage is not None:
-            result["installerImage"] = \
-                self._installerImage
-        if self._otaRunnerImage is not None:
-            result["otaRunnerImage"] = \
-                self._otaRunnerImage
-        if self._previousVersions is not None:
-            result["previousVersions"] = \
-                self._previousVersions
-        if self._rootfsImage is not None:
-            result["rootfsImage"] = \
-                self._rootfsImage
-        if self._uploadedArtifacts is not None:
-            result["uploadedArtifacts"] = \
-                self._uploadedArtifacts
-        if self._validation:
-            result["validation"] = \
-                self._validation.toDict() if self._validation is not None else None
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._container:
+            result["container"] = \
+                self._container.toDict() if self._container is not None else None
+        if self._cpu:
+            result["cpu"] = \
+                self._cpu.toDict() if self._cpu is not None else None
+        if self._csp is not None:
+            result["csp"] = \
+                self._csp
+        if self._gpu:
+            result["gpu"] = \
+                self._gpu.toDict() if self._gpu is not None else None
+        if self._memory:
+            result["memory"] = \
+                self._memory.toDict() if self._memory is not None else None
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._resource:
+            result["resource"] = \
+                self._resource.toDict() if self._resource is not None else None
+        if self._storage:
+            result["storage"] = \
+                self._storage.toDict() if self._storage is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._validation is not None): self._validation.isValid()
-        if (self._buildStatus is not None): self._buildStatus.isValid()
+        if (self._cpu is not None): self._cpu.isValid()
+        if (self._gpu is not None): self._gpu.isValid()
+        if (self._memory is not None): self._memory.isValid()
+        if (self._storage is not None): self._storage.isValid()
+        if (self._container is not None): self._container.isValid()
+        if (self._model is not None): self._model.isValid()
+        if (self._resource is not None): self._resource.isValid()
         return True
```

## Comparing `ngccli/data/ecm/CustomRootFsCreationEvent.py` & `ngcbpc/data/model/AIPlaygroundCreateRequest.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,113 +14,124 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CustomRootFsCreationEvent(object):
-    """Custom rootFs creation event for Kafka"""
+class AIPlaygroundCreateRequest(object):
+    """Request to create a new AI Playground config"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deviceType = (
+        self.artifactName = (
             None if not fromDict or propDict.get(
-                "deviceType"
+                "artifactName"
             ) is None
-            else propDict["deviceType"])
-        self.orgName = (
+            else propDict["artifactName"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "attributes"
             ) is None
-            else propDict["orgName"])
-        self.version = (
+            else propDict["attributes"])
+        self.nvcfFunctionId = (
             None if not fromDict or propDict.get(
-                "version"
+                "nvcfFunctionId"
             ) is None
-            else propDict["version"])
+            else propDict["nvcfFunctionId"])
+        self.openAPISpec = (
+            None if not fromDict or propDict.get(
+                "openAPISpec"
+            ) is None
+            else propDict["openAPISpec"])
+
+    @property
+    def artifactName(self):
+        """str: Unique name of the model"""
+        return self._artifactName
+
+    @artifactName.setter
+    def artifactName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._artifactName = value
+        else:
+            raise TypeError(
+                'Property "artifactName" of type "list<str>" set to wrong typ'
+                'e'
+            )
 
     @property
-    def deviceType(self):
-        """str: Device type for the custom root FS"""
-        return self._deviceType
+    def attributes(self):
+        """str: Metadata json string"""
+        return self._attributes
 
-    @deviceType.setter
-    def deviceType(self, value):
+    @attributes.setter
+    def attributes(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._deviceType = value
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "deviceType" of type "list<str>" set to wrong type'
+                'Property "attributes" of type "list<str>" set to wrong type'
             )
 
     @property
-    def orgName(self):
-        """ """
-        return self._orgName
+    def nvcfFunctionId(self):
+        """str: NVCF function id for the model playground"""
+        return self._nvcfFunctionId
 
-    @orgName.setter
-    def orgName(self, value):
+    @nvcfFunctionId.setter
+    def nvcfFunctionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._nvcfFunctionId = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def version(self):
-        """str: Version for the custom root FS"""
-        return self._version
+    def openAPISpec(self):
+        """str: OpenAPI specification for this model"""
+        return self._openAPISpec
 
-    @version.setter
-    def version(self, value):
+    @openAPISpec.setter
+    def openAPISpec(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._openAPISpec = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "openAPISpec" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deviceType is not None:
-            result["deviceType"] = \
-                self._deviceType
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._artifactName is not None:
+            result["artifactName"] = \
+                self._artifactName
+        if self._attributes is not None:
+            result["attributes"] = \
+                self._attributes
+        if self._nvcfFunctionId is not None:
+            result["nvcfFunctionId"] = \
+                self._nvcfFunctionId
+        if self._openAPISpec is not None:
+            result["openAPISpec"] = \
+                self._openAPISpec
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._orgName is None:
-            raise ValueError(
-                "CustomRootFsCreationEvent.orgName doesnt match requirement:" 
-                "required: True"
-            )
-        if self._deviceType is None:
-            raise ValueError(
-                "CustomRootFsCreationEvent.deviceType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._version is None:
-            raise ValueError(
-                "CustomRootFsCreationEvent.version doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/ecm/Deployment.py` & `ngcbpc/data/model/RecipeCreateRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,600 +6,572 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RemoteAppDetail import RemoteAppDetail
-from .DeploymentLocation import DeploymentLocation
+from .PrecisionType import PrecisionTypeEnum
+from .FrameworkType import FrameworkTypeEnum
+from .ApplicationType import ApplicationTypeEnum
+from .Dataset import Dataset
 
 # Unused import over optimization prevention
-str(repr(DeploymentLocation))
-str(repr(RemoteAppDetail))
+str(repr(PrecisionTypeEnum))
+str(repr(ApplicationTypeEnum))
+str(repr(FrameworkTypeEnum))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Deployment(object):
+class RecipeCreateRequest(object):
+    """Request to create a new recipe"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowAnyCapability = (
+        self.advanced = (
             None if not fromDict or propDict.get(
-                "allowAnyCapability"
+                "advanced"
             ) is None
-            else propDict["allowAnyCapability"])
-        self.allowAnyHostPath = (
+            else propDict["advanced"])
+        self.application = (
             None if not fromDict or propDict.get(
-                "allowAnyHostPath"
+                "application"
             ) is None
-            else propDict["allowAnyHostPath"])
-        self.allowDevMount = (
+            else propDict["application"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "allowDevMount"
+                "builtBy"
             ) is None
-            else propDict["allowDevMount"])
-        self.allowHostNamespace = (
+            else propDict["builtBy"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "allowHostNamespace"
+                "description"
             ) is None
-            else propDict["allowHostNamespace"])
-        self.allowHostPathPV = (
-            None if not fromDict or propDict.get(
-                "allowHostPathPV"
-            ) is None
-            else propDict["allowHostPathPV"])
-        self.allowPrivileged = (
-            None if not fromDict or propDict.get(
-                "allowPrivileged"
-            ) is None
-            else propDict["allowPrivileged"])
-        self.app = (
+            else propDict["description"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "app"
+                "displayName"
             ) is None
-            else propDict["app"])
-        self.appConfig = (
+            else propDict["displayName"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "appConfig"
+                "labels"
             ) is None
-            else propDict["appConfig"])
-        self.appDisplayName = (
+            else propDict["labels"])
+        self.labelsV2 = (
             None if not fromDict or propDict.get(
-                "appDisplayName"
+                "labelsV2"
             ) is None
-            else propDict["appDisplayName"])
-        self.appSource = (
+            else propDict["labelsV2"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "appSource"
+                "logo"
             ) is None
-            else propDict["appSource"])
-        self.creationTimestamp = (
+            else propDict["logo"])
+        self.modelFormat = (
             None if not fromDict or propDict.get(
-                "creationTimestamp"
+                "modelFormat"
             ) is None
-            else propDict["creationTimestamp"])
-        self.displayName = (
+            else propDict["modelFormat"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "name"
             ) is None
-            else propDict["displayName"])
-        self.issues = (
+            else propDict["name"])
+        self.performance = (
             None if not fromDict or propDict.get(
-                "issues"
+                "performance"
             ) is None
-            else propDict["issues"])
-        self.lastDeployedTimestamp = (
+            else propDict["performance"])
+        self.precision = (
             None if not fromDict or propDict.get(
-                "lastDeployedTimestamp"
+                "precision"
             ) is None
-            else propDict["lastDeployedTimestamp"])
-        self.locations = (
+            else propDict["precision"])
+        self.publicDatasetUsed = (
             None if not fromDict or propDict.get(
-                "locations"
+                "publicDatasetUsed"
             ) is None
-            else [ DeploymentLocation(i)
-            for i in propDict["locations"] ])
-        self.logsUrl = (
+            else propDict["publicDatasetUsed"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "logsUrl"
+                "publisher"
             ) is None
-            else propDict["logsUrl"])
-        self.messages = (
+            else propDict["publisher"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "messages"
+                "quickStartGuide"
             ) is None
-            else propDict["messages"])
-        self.name = (
+            else propDict["quickStartGuide"])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "name"
+                "setup"
             ) is None
-            else propDict["name"])
-        self.remoteAppMessages = (
+            else propDict["setup"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "remoteAppMessages"
+                "shortDescription"
             ) is None
-            else [ RemoteAppDetail(i)
-            for i in propDict["remoteAppMessages"] ])
-        self.targetNamespace = (
+            else propDict["shortDescription"])
+        self.trainingFramework = (
             None if not fromDict or propDict.get(
-                "targetNamespace"
+                "trainingFramework"
             ) is None
-            else propDict["targetNamespace"])
+            else propDict["trainingFramework"])
 
     @property
-    def allowAnyCapability(self):
-        """bool: Allow Any Process Capability Flags to the Application Deploym
-        ent"""
-        return self._allowAnyCapability
+    def advanced(self):
+        """str: Text for describing advanced information"""
+        return self._advanced
 
-    @allowAnyCapability.setter
-    def allowAnyCapability(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyCapability = value
+    @advanced.setter
+    def advanced(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._advanced = value
         else:
             raise TypeError(
-                'Property "allowAnyCapability" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "advanced" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowAnyHostPath(self):
-        """bool: Allow Any System HostPath Access to the Application Deploymen
-        t"""
-        return self._allowAnyHostPath
+    def application(self):
+        """ """
+        return self._application
 
-    @allowAnyHostPath.setter
-    def allowAnyHostPath(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyHostPath = value
+    @application.setter
+    def application(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._application = value
         else:
             raise TypeError(
-                'Property "allowAnyHostPath" of type "list<bool>" set to wron'
-                'g type'
+                'Property "application" of type "list<ApplicationTypeEnum>" s'
+                'et to wrong type'
             )
 
     @property
-    def allowDevMount(self):
-        """bool: Allow System Devices Access to the Application Deployment"""
-        return self._allowDevMount
+    def builtBy(self):
+        """str: organization that built the recipe"""
+        return self._builtBy
 
-    @allowDevMount.setter
-    def allowDevMount(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowDevMount = value
+    @builtBy.setter
+    def builtBy(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "allowDevMount" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowHostNamespace(self):
-        """bool: Allow System Process Access to the Application Deployment"""
-        return self._allowHostNamespace
+    def description(self):
+        """str: Description of the recipe"""
+        return self._description
 
-    @allowHostNamespace.setter
-    def allowHostNamespace(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowHostNamespace = value
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "allowHostNamespace" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowHostPathPV(self):
-        """bool: Allow System HostPath Access for PersistentVolumes to the App
-        lication Deployment"""
-        return self._allowHostPathPV
-
-    @allowHostPathPV.setter
-    def allowHostPathPV(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowHostPathPV = value
-        else:
-            raise TypeError(
-                'Property "allowHostPathPV" of type "list<bool>" set to wrong'
-                ' type'
-            )
+    def displayName(self):
+        """str: Display name"""
+        return self._displayName
 
-    @property
-    def allowPrivileged(self):
-        """bool: Allow Privileged Containers to the Application Deployment"""
-        return self._allowPrivileged
-
-    @allowPrivileged.setter
-    def allowPrivileged(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowPrivileged = value
+    @displayName.setter
+    def displayName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "allowPrivileged" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def app(self):
-        """str: App in the deployment"""
-        return self._app
+    def labels(self):
+        """ """
+        return self._labels
 
-    @app.setter
-    def app(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._app = value
+    @labels.setter
+    def labels(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labels = value
         else:
             raise TypeError(
-                'Property "app" of type "list<str>" set to wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def appConfig(self):
-        """str: App config in the deployment"""
-        return self._appConfig
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @appConfig.setter
-    def appConfig(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._appConfig = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "appConfig" of type "list<str>" set to wrong type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def appDisplayName(self):
-        """str: App displayname in the deployment"""
-        return self._appDisplayName
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
 
-    @appDisplayName.setter
-    def appDisplayName(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._appDisplayName = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "appDisplayName" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def appSource(self):
-        """str: App source in the deployment"""
-        return self._appSource
+    def modelFormat(self):
+        """str: Format of the model this recipe produces"""
+        return self._modelFormat
 
-    @appSource.setter
-    def appSource(self, value):
+    @modelFormat.setter
+    def modelFormat(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._appSource = value
+            self._modelFormat = value
         else:
             raise TypeError(
-                'Property "appSource" of type "list<str>" set to wrong type'
+                'Property "modelFormat" of type "list<str>" set to wrong type'
             )
 
     @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
+    def name(self):
+        """str: Unique name of the recipe"""
+        return self._name
 
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the deployment"""
-        return self._displayName
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @displayName.setter
-    def displayName(self, value):
+    @performance.setter
+    def performance(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._performance = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def issues(self):
-        """list: Issues to show in the banner"""
-        return self._issues
+    def precision(self):
+        """ """
+        return self._precision
 
-    @issues.setter
-    def issues(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._issues = value
+    @precision.setter
+    def precision(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._precision = value
         else:
             raise TypeError(
-                'Property "issues" of type "list<str>" set to wrong type'
+                'Property "precision" of type "list<PrecisionTypeEnum>" set t'
+                'o wrong type'
             )
 
     @property
-    def lastDeployedTimestamp(self):
+    def publicDatasetUsed(self):
         """ """
-        return self._lastDeployedTimestamp
+        return self._publicDatasetUsed
 
-    @lastDeployedTimestamp.setter
-    def lastDeployedTimestamp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._lastDeployedTimestamp = value
+    @publicDatasetUsed.setter
+    def publicDatasetUsed(self, value):
+        if value is not None and not isinstance(value, Dataset):
+            value = Dataset(value)
+        if (value is None) or isinstance(value, Dataset):
+            self._publicDatasetUsed = value
         else:
             raise TypeError(
-                'Property "lastDeployedTimestamp" of type "list<str>" set to '
+                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
                 'wrong type'
             )
 
     @property
-    def locations(self):
-        """list: Deployment in the locations"""
-        return self._locations
-
-    @locations.setter
-    def locations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._locations = value
-        else:
-            raise TypeError(
-                'Property "locations" of type "list<DeploymentLocation>" set '
-                'to wrong type'
-            )
-
-    @property
-    def logsUrl(self):
-        """str: Logs url for deployment"""
-        return self._logsUrl
+    def publisher(self):
+        """str: organization that published the recipe"""
+        return self._publisher
 
-    @logsUrl.setter
-    def logsUrl(self, value):
+    @publisher.setter
+    def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logsUrl = value
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "logsUrl" of type "list<str>" set to wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def messages(self):
-        """list: Messages to show in the banner"""
-        return self._messages
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @messages.setter
-    def messages(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._messages = value
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "messages" of type "list<str>" set to wrong type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def name(self):
-        """str: Name of the deployment"""
-        return self._name
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
 
-    @name.setter
-    def name(self, value):
+    @setup.setter
+    def setup(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._setup = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
-    def remoteAppMessages(self):
-        """list: Array of remote app messages object to show in the banner"""
-        return self._remoteAppMessages
+    def shortDescription(self):
+        """str: Short description of the recipe"""
+        return self._shortDescription
 
-    @remoteAppMessages.setter
-    def remoteAppMessages(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._remoteAppMessages = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "remoteAppMessages" of type "list<RemoteAppDetail>"'
-                ' set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def targetNamespace(self):
-        """str: The namespace in the edge cluster that the application would b
-        e deployed into"""
-        return self._targetNamespace
+    def trainingFramework(self):
+        """ """
+        return self._trainingFramework
 
-    @targetNamespace.setter
-    def targetNamespace(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._targetNamespace = value
+    @trainingFramework.setter
+    def trainingFramework(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._trainingFramework = value
         else:
             raise TypeError(
-                'Property "targetNamespace" of type "list<str>" set to wrong '
-                'type'
+                'Property "trainingFramework" of type "list<FrameworkTypeEnum'
+                '>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowAnyCapability is not None:
-            result["allowAnyCapability"] = \
-                self._allowAnyCapability
-        if self._allowAnyHostPath is not None:
-            result["allowAnyHostPath"] = \
-                self._allowAnyHostPath
-        if self._allowDevMount is not None:
-            result["allowDevMount"] = \
-                self._allowDevMount
-        if self._allowHostNamespace is not None:
-            result["allowHostNamespace"] = \
-                self._allowHostNamespace
-        if self._allowHostPathPV is not None:
-            result["allowHostPathPV"] = \
-                self._allowHostPathPV
-        if self._allowPrivileged is not None:
-            result["allowPrivileged"] = \
-                self._allowPrivileged
-        if self._app is not None:
-            result["app"] = \
-                self._app
-        if self._appConfig is not None:
-            result["appConfig"] = \
-                self._appConfig
-        if self._appDisplayName is not None:
-            result["appDisplayName"] = \
-                self._appDisplayName
-        if self._appSource is not None:
-            result["appSource"] = \
-                self._appSource
-        if self._creationTimestamp is not None:
-            result["creationTimestamp"] = \
-                self._creationTimestamp
+        if self._advanced is not None:
+            result["advanced"] = \
+                self._advanced
+        if self._application is not None:
+            result["application"] = \
+                self._application
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._description is not None:
+            result["description"] = \
+                self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._issues is not None:
-            result["issues"] = \
-                self._issues
-        if self._lastDeployedTimestamp is not None:
-            result["lastDeployedTimestamp"] = \
-                self._lastDeployedTimestamp
-        if self._locations:
-            result["locations"] = [
-                i.toDict() for i in self._locations 
-            ] if self._locations else []
-        if self._logsUrl is not None:
-            result["logsUrl"] = \
-                self._logsUrl
-        if self._messages is not None:
-            result["messages"] = \
-                self._messages
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
+        if self._modelFormat is not None:
+            result["modelFormat"] = \
+                self._modelFormat
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._remoteAppMessages:
-            result["remoteAppMessages"] = [
-                i.toDict() for i in self._remoteAppMessages 
-            ] if self._remoteAppMessages else []
-        if self._targetNamespace is not None:
-            result["targetNamespace"] = \
-                self._targetNamespace
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._precision is not None:
+            result["precision"] = \
+                self._precision
+        if self._publicDatasetUsed:
+            result["publicDatasetUsed"] = \
+                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._trainingFramework is not None:
+            result["trainingFramework"] = \
+                self._trainingFramework
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "RecipeCreateRequest.name doesnt match requirement:" 
+                "required: True"
+            )
         if (self._name is not None
             and
-            len(self._name) > 53):
+            len(self._name) < 1):
             raise ValueError(
-                "Deployment.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
+                "RecipeCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._name is not None
+            and
+            len(self._name) > 64):
+            raise ValueError(
+                "RecipeCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: maxLength: 64")
         if (self._name is not None
             and
             not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
+                r"^[a-z][a-z\d_-]*$",
                  self._name)):
             raise ValueError(
-                "Deployment.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._app is not None
+                "RecipeCreateRequest.name: " + str(self._name) + 
+                " doesnt match requirement: pattern: ^[a-z][a-z\d_-]*$")
+        if self._trainingFramework is None:
+            raise ValueError(
+                "RecipeCreateRequest.trainingFramework doesnt match requirement:" 
+                "required: True"
+            )
+        if self._modelFormat is None:
+            raise ValueError(
+                "RecipeCreateRequest.modelFormat doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._modelFormat is not None
+            and
+            len(self._modelFormat) > 255):
+            raise ValueError(
+                "RecipeCreateRequest.modelFormat: " + str(self._modelFormat) + 
+                " doesnt match requirement: maxLength: 255")
+        if self._publicDatasetUsed is None:
+            raise ValueError(
+                "RecipeCreateRequest.publicDatasetUsed doesnt match requirement:" 
+                "required: True"
+            )
+        if self._shortDescription is None:
+            raise ValueError(
+                "RecipeCreateRequest.shortDescription doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._shortDescription is not None
             and
-            len(self._app) > 53):
+            len(self._shortDescription) > 255):
             raise ValueError(
-                "Deployment.app: " + str(self._app) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._app is not None
+                "RecipeCreateRequest.shortDescription: " + str(self._shortDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._displayName is not None
             and
-            not re.match(
-                r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
-                 self._app)):
+            len(self._displayName) < 2):
             raise ValueError(
-                "Deployment.app: " + str(self._app) + 
-                " doesnt match requirement: pattern: ^[a-z0-9]([-a-z0-9]*[a-z"
-                "0-9])?$")
-        if (self._appDisplayName is not None
+                "RecipeCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
             and
-            len(self._appDisplayName) > 254):
+            len(self._displayName) > 64):
             raise ValueError(
-                "Deployment.appDisplayName: " + str(self._appDisplayName) + 
-                " doesnt match requirement: maxLength: 254")
-        if (self._appConfig is not None
+                "RecipeCreateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
+        if self._precision is None:
+            raise ValueError(
+                "RecipeCreateRequest.precision doesnt match requirement:" 
+                "required: True"
+            )
+        if self._application is None:
+            raise ValueError(
+                "RecipeCreateRequest.application doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._logo is not None
             and
-            len(self._appConfig) > 53):
+            len(self._logo) > 255):
             raise ValueError(
-                "Deployment.appConfig: " + str(self._appConfig) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._appConfig is not None
+                "RecipeCreateRequest.logo: " + str(self._logo) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._builtBy is not None
             and
-            not re.match(
-                r"^[a-z0-9]([-a-z0-9]*[a-z0-9])?$",
-                 self._appConfig)):
+            len(self._builtBy) > 255):
             raise ValueError(
-                "Deployment.appConfig: " + str(self._appConfig) + 
-                " doesnt match requirement: pattern: ^[a-z0-9]([-a-z0-9]*[a-z"
-                "0-9])?$")
-        if (self._displayName is not None
+                "RecipeCreateRequest.builtBy: " + str(self._builtBy) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._publisher is not None
             and
-            len(self._displayName) > 255):
+            len(self._publisher) > 255):
             raise ValueError(
-                "Deployment.displayName: " + str(self._displayName) + 
+                "RecipeCreateRequest.publisher: " + str(self._publisher) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._locations is not None):
-            for obj in self._locations:
-                if (obj is not None): obj.isValid()
-        if (self._remoteAppMessages is not None):
-            for obj in self._remoteAppMessages:
-                if (obj is not None): obj.isValid()
+        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
         return True
```

## Comparing `ngccli/data/ecm/DeploymentLocation.py` & `organization/data/subscription_management_service/SubscriptionRequest.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,509 +6,521 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .LocationDeploymentStatusEnum import LocationDeploymentStatusEnum
-from .RemoteApp import RemoteApp
-from .LocationAvailabilityEnum import LocationAvailabilityEnum
-from .LocationStatusEnum import LocationStatusEnum
+from .SubscriptionRequestTermUnitEnum import SubscriptionRequestTermUnitEnum
+from .SubscriptionRequestStatusEnum import SubscriptionRequestStatusEnum
 
 # Unused import over optimization prevention
-str(repr(LocationAvailabilityEnum))
-str(repr(LocationDeploymentStatusEnum))
-str(repr(RemoteApp))
-str(repr(LocationStatusEnum))
+str(repr(SubscriptionRequestTermUnitEnum))
+str(repr(SubscriptionRequestStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentLocation(object):
+class SubscriptionRequest(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.address = (
+        self.autoRenew = (
             None if not fromDict or propDict.get(
-                "address"
+                "autoRenew"
             ) is None
-            else propDict["address"])
-        self.argoCDEnabled = (
+            else propDict["autoRenew"])
+        self.doesCallerHaveWriteAccess = (
             None if not fromDict or propDict.get(
-                "argoCDEnabled"
+                "doesCallerHaveWriteAccess"
             ) is None
-            else propDict["argoCDEnabled"])
-        self.availability = (
+            else propDict["doesCallerHaveWriteAccess"])
+        self.email = (
             None if not fromDict or propDict.get(
-                "availability"
+                "email"
             ) is None
-            else propDict["availability"])
-        self.deploymentStatus = (
+            else propDict["email"])
+        self.expirationDate = (
             None if not fromDict or propDict.get(
-                "deploymentStatus"
+                "expirationDate"
             ) is None
-            else propDict["deploymentStatus"])
-        self.description = (
+            else propDict["expirationDate"])
+        self.offerId = (
             None if not fromDict or propDict.get(
-                "description"
+                "offerId"
             ) is None
-            else propDict["description"])
-        self.gitAppHealthStatus = (
+            else propDict["offerId"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "gitAppHealthStatus"
+                "orgName"
             ) is None
-            else propDict["gitAppHealthStatus"])
-        self.gitAppSyncStatus = (
+            else propDict["orgName"])
+        self.planId = (
             None if not fromDict or propDict.get(
-                "gitAppSyncStatus"
+                "planId"
             ) is None
-            else propDict["gitAppSyncStatus"])
-        self.lastReportedStatus = (
+            else propDict["planId"])
+        self.productName = (
             None if not fromDict or propDict.get(
-                "lastReportedStatus"
+                "productName"
             ) is None
-            else propDict["lastReportedStatus"])
-        self.lastReportedStatusTime = (
+            else propDict["productName"])
+        self.quantity = (
             None if not fromDict or propDict.get(
-                "lastReportedStatusTime"
+                "quantity"
             ) is None
-            else propDict["lastReportedStatusTime"])
-        self.locationDisplayName = (
+            else propDict["quantity"])
+        self.requestDate = (
             None if not fromDict or propDict.get(
-                "locationDisplayName"
+                "requestDate"
             ) is None
-            else propDict["locationDisplayName"])
-        self.locationLastUpdatedTimestamp = (
+            else propDict["requestDate"])
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "locationLastUpdatedTimestamp"
+                "requestId"
             ) is None
-            else propDict["locationLastUpdatedTimestamp"])
-        self.locationName = (
+            else propDict["requestId"])
+        self.retailer = (
             None if not fromDict or propDict.get(
-                "locationName"
+                "retailer"
             ) is None
-            else propDict["locationName"])
-        self.locationStatus = (
+            else propDict["retailer"])
+        self.startDate = (
             None if not fromDict or propDict.get(
-                "locationStatus"
+                "startDate"
             ) is None
-            else propDict["locationStatus"])
-        self.locationVersion = (
+            else propDict["startDate"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "locationVersion"
+                "status"
             ) is None
-            else propDict["locationVersion"])
-        self.logsUrl = (
+            else propDict["status"])
+        self.subscriptionId = (
             None if not fromDict or propDict.get(
-                "logsUrl"
+                "subscriptionId"
             ) is None
-            else propDict["logsUrl"])
-        self.nodes = (
+            else propDict["subscriptionId"])
+        self.termUnit = (
             None if not fromDict or propDict.get(
-                "nodes"
+                "termUnit"
             ) is None
-            else propDict["nodes"])
-        self.remoteApps = (
+            else propDict["termUnit"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "remoteApps"
+                "updatedDate"
             ) is None
-            else [ RemoteApp(i)
-            for i in propDict["remoteApps"] ])
-        self.signedContainersEnabled = (
+            else propDict["updatedDate"])
+        self.updaterId = (
             None if not fromDict or propDict.get(
-                "signedContainersEnabled"
+                "updaterId"
             ) is None
-            else propDict["signedContainersEnabled"])
+            else propDict["updaterId"])
+        self.updaterName = (
+            None if not fromDict or propDict.get(
+                "updaterName"
+            ) is None
+            else propDict["updaterName"])
+        self.userId = (
+            None if not fromDict or propDict.get(
+                "userId"
+            ) is None
+            else propDict["userId"])
 
     @property
-    def address(self):
-        """str: Address of the location"""
-        return self._address
+    def autoRenew(self):
+        """bool: if the requested subscription is autoRenewable or not"""
+        return self._autoRenew
 
-    @address.setter
-    def address(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._address = value
+    @autoRenew.setter
+    def autoRenew(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._autoRenew = value
         else:
             raise TypeError(
-                'Property "address" of type "list<str>" set to wrong type'
+                'Property "autoRenew" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def argoCDEnabled(self):
-        """bool: Location has ArgoCD deployments enabled or not"""
-        return self._argoCDEnabled
+    def doesCallerHaveWriteAccess(self):
+        """bool: does caller has write permission for this subscription reques
+        t"""
+        return self._doesCallerHaveWriteAccess
 
-    @argoCDEnabled.setter
-    def argoCDEnabled(self, value):
+    @doesCallerHaveWriteAccess.setter
+    def doesCallerHaveWriteAccess(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._argoCDEnabled = value
+            self._doesCallerHaveWriteAccess = value
         else:
             raise TypeError(
-                'Property "argoCDEnabled" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "doesCallerHaveWriteAccess" of type "list<bool>" se'
+                't to wrong type'
             )
 
     @property
-    def availability(self):
-        """LocationAvailabilityEnum: All possible values for location availabi
-        lity"""
-        return self._availability
+    def email(self):
+        """str: email of the customer in CSP marketplace"""
+        return self._email
 
-    @availability.setter
-    def availability(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._availability = value
+    @email.setter
+    def email(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._email = value
         else:
             raise TypeError(
-                'Property "availability" of type "list<LocationAvailabilityEn'
-                'um>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def deploymentStatus(self):
-        """LocationDeploymentStatusEnum: All possible deployment status enums 
-        in location"""
-        return self._deploymentStatus
+    def expirationDate(self):
+        """str: expiration date timestamp for the requested subscription"""
+        return self._expirationDate
 
-    @deploymentStatus.setter
-    def deploymentStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._deploymentStatus = value
+    @expirationDate.setter
+    def expirationDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._expirationDate = value
         else:
             raise TypeError(
-                'Property "deploymentStatus" of type "list<LocationDeployment'
-                'StatusEnum>" set to wrong type'
+                'Property "expirationDate" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def description(self):
-        """str: Description of the location"""
-        return self._description
+    def offerId(self):
+        """str: id of the CSP marketplace offer"""
+        return self._offerId
 
-    @description.setter
-    def description(self, value):
+    @offerId.setter
+    def offerId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._offerId = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "offerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gitAppHealthStatus(self):
-        """GitAppHealthStatusEnum: git resource's health status"""
-        return self._gitAppHealthStatus
+    def orgName(self):
+        """str: name of the org this request belongs to"""
+        return self._orgName
 
-    @gitAppHealthStatus.setter
-    def gitAppHealthStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._gitAppHealthStatus = value
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "gitAppHealthStatus" of type "list<GitAppHealthStat'
-                'usEnum>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
-    GitAppHealthStatusEnum=["UNKNOWN","DEGRADED","HEALTHY","MISSING","PROGRESSING","SUSPENDED",]
-    str(repr(GitAppHealthStatusEnum))  # Prevent optimizer removing enum
-
     @property
-    def gitAppSyncStatus(self):
-        """GitAppSyncStatusEnum: git application's current sync status"""
-        return self._gitAppSyncStatus
+    def planId(self):
+        """str: plan id of the CSP marketplace offer"""
+        return self._planId
 
-    @gitAppSyncStatus.setter
-    def gitAppSyncStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._gitAppSyncStatus = value
+    @planId.setter
+    def planId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._planId = value
         else:
             raise TypeError(
-                'Property "gitAppSyncStatus" of type "list<GitAppSyncStatusEn'
-                'um>" set to wrong type'
+                'Property "planId" of type "list<str>" set to wrong type'
             )
 
-    GitAppSyncStatusEnum=["UNKNOWN","SYNCED","OUTOFSYNC",]
-    str(repr(GitAppSyncStatusEnum))  # Prevent optimizer removing enum
+    @property
+    def productName(self):
+        """str: name of the NGC product"""
+        return self._productName
+
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
+        else:
+            raise TypeError(
+                'Property "productName" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def lastReportedStatus(self):
-        """LocationStatusEnum: All possible location status enums"""
-        return self._lastReportedStatus
+    def quantity(self):
+        """int: quantity in the subscription request"""
+        return self._quantity
 
-    @lastReportedStatus.setter
-    def lastReportedStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._lastReportedStatus = value
+    @quantity.setter
+    def quantity(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._quantity = value
         else:
             raise TypeError(
-                'Property "lastReportedStatus" of type "list<LocationStatusEn'
-                'um>" set to wrong type'
+                'Property "quantity" of type "list<int>" set to wrong type'
             )
 
     @property
-    def lastReportedStatusTime(self):
-        """ """
-        return self._lastReportedStatusTime
+    def requestDate(self):
+        """str: request date timestamp of the subscription request"""
+        return self._requestDate
 
-    @lastReportedStatusTime.setter
-    def lastReportedStatusTime(self, value):
+    @requestDate.setter
+    def requestDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastReportedStatusTime = value
+            self._requestDate = value
         else:
             raise TypeError(
-                'Property "lastReportedStatusTime" of type "list<str>" set to'
-                ' wrong type'
+                'Property "requestDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def locationDisplayName(self):
-        """str: Display name of the location"""
-        return self._locationDisplayName
+    def requestId(self):
+        """str: id of the subscription request"""
+        return self._requestId
 
-    @locationDisplayName.setter
-    def locationDisplayName(self, value):
+    @requestId.setter
+    def requestId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationDisplayName = value
+            self._requestId = value
         else:
             raise TypeError(
-                'Property "locationDisplayName" of type "list<str>" set to wr'
-                'ong type'
+                'Property "requestId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def locationLastUpdatedTimestamp(self):
-        """ """
-        return self._locationLastUpdatedTimestamp
+    def retailer(self):
+        """str: name of the retailer"""
+        return self._retailer
 
-    @locationLastUpdatedTimestamp.setter
-    def locationLastUpdatedTimestamp(self, value):
+    @retailer.setter
+    def retailer(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationLastUpdatedTimestamp = value
+            self._retailer = value
         else:
             raise TypeError(
-                'Property "locationLastUpdatedTimestamp" of type "list<str>" '
-                'set to wrong type'
+                'Property "retailer" of type "list<str>" set to wrong type'
             )
 
     @property
-    def locationName(self):
-        """str: Name of the location"""
-        return self._locationName
+    def startDate(self):
+        """str: start date timestamp for the requested subscription"""
+        return self._startDate
 
-    @locationName.setter
-    def locationName(self, value):
+    @startDate.setter
+    def startDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationName = value
+            self._startDate = value
         else:
             raise TypeError(
-                'Property "locationName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "startDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def locationStatus(self):
-        """LocationStatusEnum: All possible location status enums"""
-        return self._locationStatus
+    def status(self):
+        """SubscriptionRequestStatusEnum: All possible status enums for subscr
+        iption request"""
+        return self._status
 
-    @locationStatus.setter
-    def locationStatus(self, value):
+    @status.setter
+    def status(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._locationStatus = value
+            self._status = value
         else:
             raise TypeError(
-                'Property "locationStatus" of type "list<LocationStatusEnum>"'
-                ' set to wrong type'
+                'Property "status" of type "list<SubscriptionRequestStatusEnu'
+                'm>" set to wrong type'
             )
 
     @property
-    def locationVersion(self):
-        """str: Location version"""
-        return self._locationVersion
+    def subscriptionId(self):
+        """str: id of ngc subscription which created from this request"""
+        return self._subscriptionId
 
-    @locationVersion.setter
-    def locationVersion(self, value):
+    @subscriptionId.setter
+    def subscriptionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationVersion = value
+            self._subscriptionId = value
         else:
             raise TypeError(
-                'Property "locationVersion" of type "list<str>" set to wrong '
-                'type'
+                'Property "subscriptionId" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def logsUrl(self):
-        """str: Logs url for deployment location"""
-        return self._logsUrl
+    def termUnit(self):
+        """SubscriptionRequestTermUnitEnum: All possible term unit enums for s
+        ubscription request"""
+        return self._termUnit
+
+    @termUnit.setter
+    def termUnit(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._termUnit = value
+        else:
+            raise TypeError(
+                'Property "termUnit" of type "list<SubscriptionRequestTermUni'
+                'tEnum>" set to wrong type'
+            )
 
-    @logsUrl.setter
-    def logsUrl(self, value):
+    @property
+    def updatedDate(self):
+        """str: last updated date timestamp of the subscription request"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logsUrl = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "logsUrl" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nodes(self):
-        """list: A list of node names"""
-        return self._nodes
+    def updaterId(self):
+        """str: user starfleet id of the updater"""
+        return self._updaterId
 
-    @nodes.setter
-    def nodes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._nodes = value
+    @updaterId.setter
+    def updaterId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updaterId = value
         else:
             raise TypeError(
-                'Property "nodes" of type "list<str>" set to wrong type'
+                'Property "updaterId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def remoteApps(self):
-        """list: array of remote apps that in the location"""
-        return self._remoteApps
+    def updaterName(self):
+        """str: user name of the updater"""
+        return self._updaterName
 
-    @remoteApps.setter
-    def remoteApps(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._remoteApps = value
+    @updaterName.setter
+    def updaterName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updaterName = value
         else:
             raise TypeError(
-                'Property "remoteApps" of type "list<RemoteApp>" set to wrong'
-                ' type'
+                'Property "updaterName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def signedContainersEnabled(self):
-        """bool: Location has signed containers required or not"""
-        return self._signedContainersEnabled
+    def userId(self):
+        """str: id of the customer in CSP marketplace"""
+        return self._userId
 
-    @signedContainersEnabled.setter
-    def signedContainersEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._signedContainersEnabled = value
+    @userId.setter
+    def userId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._userId = value
         else:
             raise TypeError(
-                'Property "signedContainersEnabled" of type "list<bool>" set '
-                'to wrong type'
+                'Property "userId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._address is not None:
-            result["address"] = \
-                self._address
-        if self._argoCDEnabled is not None:
-            result["argoCDEnabled"] = \
-                self._argoCDEnabled
-        if self._availability is not None:
-            result["availability"] = \
-                self._availability
-        if self._deploymentStatus is not None:
-            result["deploymentStatus"] = \
-                self._deploymentStatus
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._gitAppHealthStatus is not None:
-            result["gitAppHealthStatus"] = \
-                self._gitAppHealthStatus
-        if self._gitAppSyncStatus is not None:
-            result["gitAppSyncStatus"] = \
-                self._gitAppSyncStatus
-        if self._lastReportedStatus is not None:
-            result["lastReportedStatus"] = \
-                self._lastReportedStatus
-        if self._lastReportedStatusTime is not None:
-            result["lastReportedStatusTime"] = \
-                self._lastReportedStatusTime
-        if self._locationDisplayName is not None:
-            result["locationDisplayName"] = \
-                self._locationDisplayName
-        if self._locationLastUpdatedTimestamp is not None:
-            result["locationLastUpdatedTimestamp"] = \
-                self._locationLastUpdatedTimestamp
-        if self._locationName is not None:
-            result["locationName"] = \
-                self._locationName
-        if self._locationStatus is not None:
-            result["locationStatus"] = \
-                self._locationStatus
-        if self._locationVersion is not None:
-            result["locationVersion"] = \
-                self._locationVersion
-        if self._logsUrl is not None:
-            result["logsUrl"] = \
-                self._logsUrl
-        if self._nodes is not None:
-            result["nodes"] = \
-                self._nodes
-        if self._remoteApps:
-            result["remoteApps"] = [
-                i.toDict() for i in self._remoteApps 
-            ] if self._remoteApps else []
-        if self._signedContainersEnabled is not None:
-            result["signedContainersEnabled"] = \
-                self._signedContainersEnabled
+        if self._autoRenew is not None:
+            result["autoRenew"] = \
+                self._autoRenew
+        if self._doesCallerHaveWriteAccess is not None:
+            result["doesCallerHaveWriteAccess"] = \
+                self._doesCallerHaveWriteAccess
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._expirationDate is not None:
+            result["expirationDate"] = \
+                self._expirationDate
+        if self._offerId is not None:
+            result["offerId"] = \
+                self._offerId
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._planId is not None:
+            result["planId"] = \
+                self._planId
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
+        if self._requestDate is not None:
+            result["requestDate"] = \
+                self._requestDate
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._retailer is not None:
+            result["retailer"] = \
+                self._retailer
+        if self._startDate is not None:
+            result["startDate"] = \
+                self._startDate
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._subscriptionId is not None:
+            result["subscriptionId"] = \
+                self._subscriptionId
+        if self._termUnit is not None:
+            result["termUnit"] = \
+                self._termUnit
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
+        if self._updaterId is not None:
+            result["updaterId"] = \
+                self._updaterId
+        if self._updaterName is not None:
+            result["updaterName"] = \
+                self._updaterName
+        if self._userId is not None:
+            result["userId"] = \
+                self._userId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._locationName is not None
-            and
-            len(self._locationName) > 53):
-            raise ValueError(
-                "DeploymentLocation.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._locationName is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._locationName)):
-            raise ValueError(
-                "DeploymentLocation.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._locationDisplayName is not None
-            and
-            len(self._locationDisplayName) > 255):
-            raise ValueError(
-                "DeploymentLocation.locationDisplayName: " + str(self._locationDisplayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._remoteApps is not None):
-            for obj in self._remoteApps:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/DeploymentResponse.py` & `ngcbpc/data/model/AssetResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,60 +6,60 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Deployment import Deployment
 from .RequestStatus import RequestStatus
+from .Asset import Asset
 
 # Unused import over optimization prevention
-str(repr(Deployment))
 str(repr(RequestStatus))
+str(repr(Asset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentResponse(object):
+class AssetResponse(object):
+    """Response to asset request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deployment = (
+        self.asset = (
             None if not fromDict or propDict.get(
-                "deployment"
+                "asset"
             ) is None
-            else propDict["deployment"])
+            else propDict["asset"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def deployment(self):
-        """ """
-        return self._deployment
-
-    @deployment.setter
-    def deployment(self, value):
-        if value is not None and not isinstance(value, Deployment):
-            value = Deployment(value)
-        if (value is None) or isinstance(value, Deployment):
-            self._deployment = value
+    def asset(self):
+        """Asset: Asset object"""
+        return self._asset
+
+    @asset.setter
+    def asset(self, value):
+        if value is not None and not isinstance(value, Asset):
+            value = Asset(value)
+        if (value is None) or isinstance(value, Asset):
+            self._asset = value
         else:
             raise TypeError(
-                'Property "deployment" of type "list<Deployment>" set to wron'
-                'g type'
+                'Property "asset" of type "list<Asset>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -68,27 +68,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._deployment:
-            result["deployment"] = \
-                self._deployment.toDict() if self._deployment is not None else None
+        if self._asset:
+            result["asset"] = \
+                self._asset.toDict() if self._asset is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._deployment is not None): self._deployment.isValid()
+        if (self._asset is not None): self._asset.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/DeploymentsResponse.py` & `ngcbpc/data/uis/OrgOwnersResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,80 +6,62 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Deployment import Deployment
+from .OrgOwner import OrgOwner
 from .RequestStatus import RequestStatus
-from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
-str(repr(Deployment))
 str(repr(RequestStatus))
+str(repr(OrgOwner))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentsResponse(object):
+class OrgOwnersResponse(object):
+    """info about org owners for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.deployments = (
+        self.primaryOrgOwner = (
             None if not fromDict or propDict.get(
-                "deployments"
+                "primaryOrgOwner"
             ) is None
-            else [ Deployment(i)
-            for i in propDict["deployments"] ])
-        self.paginationInfo = (
-            None if not fromDict or propDict.get(
-                "paginationInfo"
-            ) is None
-            else propDict["paginationInfo"])
+            else propDict["primaryOrgOwner"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.secondaryOrgOwners = (
+            None if not fromDict or propDict.get(
+                "secondaryOrgOwners"
+            ) is None
+            else [ OrgOwner(i)
+            for i in propDict["secondaryOrgOwners"] ])
 
     @property
-    def deployments(self):
-        """list: array of deployments object"""
-        return self._deployments
-
-    @deployments.setter
-    def deployments(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._deployments = value
-        else:
-            raise TypeError(
-                'Property "deployments" of type "list<Deployment>" set to wro'
-                'ng type'
-            )
-
-    @property
-    def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def primaryOrgOwner(self):
+        """OrgOwner: Org owner"""
+        return self._primaryOrgOwner
+
+    @primaryOrgOwner.setter
+    def primaryOrgOwner(self, value):
+        if value is not None and not isinstance(value, OrgOwner):
+            value = OrgOwner(value)
+        if (value is None) or isinstance(value, OrgOwner):
+            self._primaryOrgOwner = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "primaryOrgOwner" of type "list<OrgOwner>" set to w'
+                'rong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -91,36 +73,53 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def secondaryOrgOwners(self):
+        """ """
+        return self._secondaryOrgOwners
+
+    @secondaryOrgOwners.setter
+    def secondaryOrgOwners(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._secondaryOrgOwners = value
+        else:
+            raise TypeError(
+                'Property "secondaryOrgOwners" of type "list<OrgOwner>" set t'
+                'o wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._deployments:
-            result["deployments"] = [
-                i.toDict() for i in self._deployments 
-            ] if self._deployments else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._primaryOrgOwner:
+            result["primaryOrgOwner"] = \
+                self._primaryOrgOwner.toDict() if self._primaryOrgOwner is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._secondaryOrgOwners:
+            result["secondaryOrgOwners"] = [
+                i.toDict() for i in self._secondaryOrgOwners 
+            ] if self._secondaryOrgOwners else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._deployments is not None):
-            for obj in self._deployments:
+        if (self._primaryOrgOwner is not None): self._primaryOrgOwner.isValid()
+        if (self._secondaryOrgOwners is not None):
+            for obj in self._secondaryOrgOwners:
                 if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/EmsMetaData.py` & `basecommand/data/pym/ProjectDetails.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,203 +6,234 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectParams import ProjectParams
 
 # Unused import over optimization prevention
+str(repr(ProjectParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class EmsMetaData(object):
+class ProjectDetails(object):
+    """Project Details"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
+        self.ace = (
+            None if not fromDict or propDict.get(
+                "ace"
+            ) is None
+            else propDict["ace"])
         self.creationTimestamp = (
             None if not fromDict or propDict.get(
                 "creationTimestamp"
             ) is None
             else propDict["creationTimestamp"])
-        self.icon = (
-            None if not fromDict or propDict.get(
-                "icon"
-            ) is None
-            else propDict["icon"])
-        self.name = (
+        self.id = (
             None if not fromDict or propDict.get(
-                "name"
+                "id"
             ) is None
-            else propDict["name"])
-        self.namespace = (
+            else propDict["id"])
+        self.org = (
             None if not fromDict or propDict.get(
-                "namespace"
+                "org"
             ) is None
-            else propDict["namespace"])
-        self.resourceVersion = (
+            else propDict["org"])
+        self.owner = (
             None if not fromDict or propDict.get(
-                "resourceVersion"
+                "owner"
             ) is None
-            else propDict["resourceVersion"])
-        self.selfLink = (
+            else propDict["owner"])
+        self.params = (
             None if not fromDict or propDict.get(
-                "selfLink"
+                "params"
             ) is None
-            else propDict["selfLink"])
-        self.uid = (
+            else propDict["params"])
+        self.team = (
             None if not fromDict or propDict.get(
-                "uid"
+                "team"
             ) is None
-            else propDict["uid"])
+            else propDict["team"])
 
     @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
+    def ace(self):
+        """str: ACE instance"""
+        return self._ace
 
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
+    @ace.setter
+    def ace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
+            self._ace = value
         else:
             raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
+                'Property "ace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def icon(self):
-        """ """
-        return self._icon
+    def creationTimestamp(self):
+        """str: Project creation date time in YYYY-MM-DDThh:mm:ssZ format"""
+        return self._creationTimestamp
 
-    @icon.setter
-    def icon(self, value):
+    @creationTimestamp.setter
+    def creationTimestamp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._icon = value
+            self._creationTimestamp = value
         else:
             raise TypeError(
-                'Property "icon" of type "list<str>" set to wrong type'
+                'Property "creationTimestamp" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def name(self):
-        """ """
-        return self._name
+    def id(self):
+        """str: Project ID"""
+        return self._id
 
-    @name.setter
-    def name(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def namespace(self):
-        """ """
-        return self._namespace
+    def org(self):
+        """str: Org name that the project belongs to (only used in LIST and IN
+        FO command responses)"""
+        return self._org
 
-    @namespace.setter
-    def namespace(self, value):
+    @org.setter
+    def org(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._namespace = value
+            self._org = value
         else:
             raise TypeError(
-                'Property "namespace" of type "list<str>" set to wrong type'
+                'Property "org" of type "list<str>" set to wrong type'
             )
 
     @property
-    def resourceVersion(self):
-        """ """
-        return self._resourceVersion
+    def owner(self):
+        """str: Project owner"""
+        return self._owner
 
-    @resourceVersion.setter
-    def resourceVersion(self, value):
+    @owner.setter
+    def owner(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._resourceVersion = value
+            self._owner = value
         else:
             raise TypeError(
-                'Property "resourceVersion" of type "list<str>" set to wrong '
-                'type'
+                'Property "owner" of type "list<str>" set to wrong type'
             )
 
     @property
-    def selfLink(self):
-        """ """
-        return self._selfLink
+    def params(self):
+        """ProjectParams: Project params"""
+        return self._params
 
-    @selfLink.setter
-    def selfLink(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._selfLink = value
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectParams):
+            value = ProjectParams(value)
+        if (value is None) or isinstance(value, ProjectParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "selfLink" of type "list<str>" set to wrong type'
+                'Property "params" of type "list<ProjectParams>" set to wrong'
+                ' type'
             )
 
     @property
-    def uid(self):
-        """ """
-        return self._uid
+    def team(self):
+        """str: Team name that the project belongs to (only used in LIST and I
+        NFO command responses)"""
+        return self._team
 
-    @uid.setter
-    def uid(self, value):
+    @team.setter
+    def team(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._uid = value
+            self._team = value
         else:
             raise TypeError(
-                'Property "uid" of type "list<str>" set to wrong type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
+        if self._ace is not None:
+            result["ace"] = \
+                self._ace
         if self._creationTimestamp is not None:
             result["creationTimestamp"] = \
                 self._creationTimestamp
-        if self._icon is not None:
-            result["icon"] = \
-                self._icon
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._namespace is not None:
-            result["namespace"] = \
-                self._namespace
-        if self._resourceVersion is not None:
-            result["resourceVersion"] = \
-                self._resourceVersion
-        if self._selfLink is not None:
-            result["selfLink"] = \
-                self._selfLink
-        if self._uid is not None:
-            result["uid"] = \
-                self._uid
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._org is not None:
+            result["org"] = \
+                self._org
+        if self._owner is not None:
+            result["owner"] = \
+                self._owner
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._team is not None:
+            result["team"] = \
+                self._team
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._ace is None:
+            raise ValueError(
+                "ProjectDetails.ace doesnt match requirement:" 
+                "required: True"
+            )
+        if self._owner is None:
+            raise ValueError(
+                "ProjectDetails.owner doesnt match requirement:" 
+                "required: True"
+            )
+        if self._id is None:
+            raise ValueError(
+                "ProjectDetails.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._creationTimestamp is None:
+            raise ValueError(
+                "ProjectDetails.creationTimestamp doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
+            raise ValueError(
+                "ProjectDetails.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/ecm/EmsResponse.py` & `ngcbpc/data/registry/EventRequest.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,162 +6,158 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .EmsMetaData import EmsMetaData
-from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(EmsMetaData))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class EmsResponse(object):
-    """EMS response object"""
+class EventRequest(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.apiVersion = (
+        self.addr = (
             None if not fromDict or propDict.get(
-                "apiVersion"
+                "addr"
             ) is None
-            else propDict["apiVersion"])
-        self.kind = (
+            else propDict["addr"])
+        self.host = (
             None if not fromDict or propDict.get(
-                "kind"
+                "host"
             ) is None
-            else propDict["kind"])
-        self.metadata = (
+            else propDict["host"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "metadata"
+                "id"
             ) is None
-            else propDict["metadata"])
-        self.requestStatus = (
+            else propDict["id"])
+        self.method = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "method"
             ) is None
-            else propDict["requestStatus"])
-        self.type = (
+            else propDict["method"])
+        self.useragent = (
             None if not fromDict or propDict.get(
-                "type"
+                "useragent"
             ) is None
-            else propDict["type"])
+            else propDict["useragent"])
 
     @property
-    def apiVersion(self):
-        """ """
-        return self._apiVersion
+    def addr(self):
+        """str: Addr contains the ip or hostname and possibly port of the clie
+        nt connection that initiated the event. This is the RemoteAddr
+         from the standard http request."""
+        return self._addr
 
-    @apiVersion.setter
-    def apiVersion(self, value):
+    @addr.setter
+    def addr(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._apiVersion = value
+            self._addr = value
         else:
             raise TypeError(
-                'Property "apiVersion" of type "list<str>" set to wrong type'
+                'Property "addr" of type "list<str>" set to wrong type'
             )
 
     @property
-    def kind(self):
-        """ """
-        return self._kind
+    def host(self):
+        """str: Host is the externally accessible host name of the registry in
+        stance, as specified by the http host header on incoming reque
+        sts."""
+        return self._host
 
-    @kind.setter
-    def kind(self, value):
+    @host.setter
+    def host(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._kind = value
+            self._host = value
         else:
             raise TypeError(
-                'Property "kind" of type "list<str>" set to wrong type'
+                'Property "host" of type "list<str>" set to wrong type'
             )
 
     @property
-    def metadata(self):
-        """ """
-        return self._metadata
-
-    @metadata.setter
-    def metadata(self, value):
-        if value is not None and not isinstance(value, EmsMetaData):
-            value = EmsMetaData(value)
-        if (value is None) or isinstance(value, EmsMetaData):
-            self._metadata = value
+    def id(self):
+        """str: ID uniquely identifies the request that initiated the event.
+        """
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "metadata" of type "list<EmsMetaData>" set to wrong'
-                ' type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def method(self):
+        """str: Method has the request method that generated the event."""
+        return self._method
+
+    @method.setter
+    def method(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._method = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "method" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """ """
-        return self._type
+    def useragent(self):
+        """str: UserAgent contains the user agent header of the request."""
+        return self._useragent
 
-    @type.setter
-    def type(self, value):
+    @useragent.setter
+    def useragent(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._type = value
+            self._useragent = value
         else:
             raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "useragent" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._apiVersion is not None:
-            result["apiVersion"] = \
-                self._apiVersion
-        if self._kind is not None:
-            result["kind"] = \
-                self._kind
-        if self._metadata:
-            result["metadata"] = \
-                self._metadata.toDict() if self._metadata is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._addr is not None:
+            result["addr"] = \
+                self._addr
+        if self._host is not None:
+            result["host"] = \
+                self._host
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._method is not None:
+            result["method"] = \
+                self._method
+        if self._useragent is not None:
+            result["useragent"] = \
+                self._useragent
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._metadata is not None): self._metadata.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ErrorResponse.py` & `registry/data/publishing/Response.py`

 * *Files 3% similar despite different names*

```diff
@@ -16,26 +16,26 @@
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ErrorResponse(object):
+class Response(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
```

## Comparing `ngccli/data/ecm/Git.py` & `ngcbpc/data/registry/MappingRule.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,207 +6,208 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ImageRef import ImageRef
 
 # Unused import over optimization prevention
+str(repr(ImageRef))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Git(object):
-    """represents the information required for connecting to a git repository
-    """
+class MappingRule(object):
+    """Mapping rules for defining which policy and allowlist(s) to apply to an
+     image based on a match of the image tag or id. Evaluated in order."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.enableLFSSupport = (
+        self.allowlist_ids = (
             None if not fromDict or propDict.get(
-                "enableLFSSupport"
+                "allowlist_ids"
             ) is None
-            else propDict["enableLFSSupport"])
-        self.password = (
+            else propDict["allowlist_ids"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "password"
+                "id"
             ) is None
-            else propDict["password"])
-        self.proxy = (
+            else propDict["id"])
+        self.image = (
             None if not fromDict or propDict.get(
-                "proxy"
+                "image"
             ) is None
-            else propDict["proxy"])
-        self.sshPrivateKey = (
+            else propDict["image"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "sshPrivateKey"
+                "name"
             ) is None
-            else propDict["sshPrivateKey"])
-        self.tLSClientCert = (
+            else propDict["name"])
+        self.registry = (
             None if not fromDict or propDict.get(
-                "tLSClientCert"
+                "registry"
             ) is None
-            else propDict["tLSClientCert"])
-        self.tlsClientCertKey = (
+            else propDict["registry"])
+        self.repository = (
             None if not fromDict or propDict.get(
-                "tlsClientCertKey"
+                "repository"
             ) is None
-            else propDict["tlsClientCertKey"])
-        self.username = (
+            else propDict["repository"])
+        self.rule_set_ids = (
             None if not fromDict or propDict.get(
-                "username"
+                "rule_set_ids"
             ) is None
-            else propDict["username"])
+            else propDict["rule_set_ids"])
 
     @property
-    def enableLFSSupport(self):
-        """bool: should be enabled if the repository uses Git LFS support"""
-        return self._enableLFSSupport
+    def allowlist_ids(self):
+        """ """
+        return self._allowlist_ids
 
-    @enableLFSSupport.setter
-    def enableLFSSupport(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enableLFSSupport = value
+    @allowlist_ids.setter
+    def allowlist_ids(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._allowlist_ids = value
         else:
             raise TypeError(
-                'Property "enableLFSSupport" of type "list<bool>" set to wron'
-                'g type'
+                'Property "allowlist_ids" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def password(self):
-        """str: the password to connect to the repository with (optional)"""
-        return self._password
+    def id(self):
+        """ """
+        return self._id
 
-    @password.setter
-    def password(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._password = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "password" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def proxy(self):
-        """str: Proxy is whether or not the repository"""
-        return self._proxy
+    def image(self):
+        """ImageRef: A reference to an image"""
+        return self._image
 
-    @proxy.setter
-    def proxy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._proxy = value
+    @image.setter
+    def image(self, value):
+        if value is not None and not isinstance(value, ImageRef):
+            value = ImageRef(value)
+        if (value is None) or isinstance(value, ImageRef):
+            self._image = value
         else:
             raise TypeError(
-                'Property "proxy" of type "list<str>" set to wrong type'
+                'Property "image" of type "list<ImageRef>" set to wrong type'
             )
 
     @property
-    def sshPrivateKey(self):
-        """str: the key for SSH"""
-        return self._sshPrivateKey
+    def name(self):
+        """ """
+        return self._name
 
-    @sshPrivateKey.setter
-    def sshPrivateKey(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sshPrivateKey = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "sshPrivateKey" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tLSClientCert(self):
-        """str: is the client certificate"""
-        return self._tLSClientCert
+    def registry(self):
+        """ """
+        return self._registry
 
-    @tLSClientCert.setter
-    def tLSClientCert(self, value):
+    @registry.setter
+    def registry(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tLSClientCert = value
+            self._registry = value
         else:
             raise TypeError(
-                'Property "tLSClientCert" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "registry" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tlsClientCertKey(self):
-        """str: the client certificate private key"""
-        return self._tlsClientCertKey
+    def repository(self):
+        """ """
+        return self._repository
 
-    @tlsClientCertKey.setter
-    def tlsClientCertKey(self, value):
+    @repository.setter
+    def repository(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tlsClientCertKey = value
+            self._repository = value
         else:
             raise TypeError(
-                'Property "tlsClientCertKey" of type "list<str>" set to wrong'
-                ' type'
+                'Property "repository" of type "list<str>" set to wrong type'
             )
 
     @property
-    def username(self):
-        """str: the user to connect to the repository with (optional)"""
-        return self._username
+    def rule_set_ids(self):
+        """list: List of ruleSetIds to evaluate in order, to completion"""
+        return self._rule_set_ids
 
-    @username.setter
-    def username(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._username = value
+    @rule_set_ids.setter
+    def rule_set_ids(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._rule_set_ids = value
         else:
             raise TypeError(
-                'Property "username" of type "list<str>" set to wrong type'
+                'Property "rule_set_ids" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._enableLFSSupport is not None:
-            result["enableLFSSupport"] = \
-                self._enableLFSSupport
-        if self._password is not None:
-            result["password"] = \
-                self._password
-        if self._proxy is not None:
-            result["proxy"] = \
-                self._proxy
-        if self._sshPrivateKey is not None:
-            result["sshPrivateKey"] = \
-                self._sshPrivateKey
-        if self._tLSClientCert is not None:
-            result["tLSClientCert"] = \
-                self._tLSClientCert
-        if self._tlsClientCertKey is not None:
-            result["tlsClientCertKey"] = \
-                self._tlsClientCertKey
-        if self._username is not None:
-            result["username"] = \
-                self._username
+        if self._allowlist_ids is not None:
+            result["allowlist_ids"] = \
+                self._allowlist_ids
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._image:
+            result["image"] = \
+                self._image.toDict() if self._image is not None else None
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._registry is not None:
+            result["registry"] = \
+                self._registry
+        if self._repository is not None:
+            result["repository"] = \
+                self._repository
+        if self._rule_set_ids is not None:
+            result["rule_set_ids"] = \
+                self._rule_set_ids
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._image is not None): self._image.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GitApp.py` & `organization/data/subscription_management_service/PurchaseOrder.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,96 +14,70 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitApp(object):
+class PurchaseOrder(object):
+    """Purchase Order."""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.path = (
+        self.entitlementId = (
             None if not fromDict or propDict.get(
-                "path"
+                "entitlementId"
             ) is None
-            else propDict["path"])
-        self.repoURL = (
+            else propDict["entitlementId"])
+        self.pkId = (
             None if not fromDict or propDict.get(
-                "repoURL"
+                "pkId"
             ) is None
-            else propDict["repoURL"])
-        self.targetRevision = (
-            None if not fromDict or propDict.get(
-                "targetRevision"
-            ) is None
-            else propDict["targetRevision"])
-
-    @property
-    def path(self):
-        """str: a directory path within the Git repository, and is only valid 
-        for applications sourced from Git"""
-        return self._path
-
-    @path.setter
-    def path(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._path = value
-        else:
-            raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
-            )
+            else propDict["pkId"])
 
     @property
-    def repoURL(self):
-        """str: the URL to the repository (Git or Helm) that contains the appl
-        ication manifests"""
-        return self._repoURL
+    def entitlementId(self):
+        """str: Entitlement identifier."""
+        return self._entitlementId
 
-    @repoURL.setter
-    def repoURL(self, value):
+    @entitlementId.setter
+    def entitlementId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._repoURL = value
+            self._entitlementId = value
         else:
             raise TypeError(
-                'Property "repoURL" of type "list<str>" set to wrong type'
+                'Property "entitlementId" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def targetRevision(self):
-        """str: defines the revision of the source to sync the application to
-        """
-        return self._targetRevision
+    def pkId(self):
+        """str: PAK (Product Activation Key) identifier."""
+        return self._pkId
 
-    @targetRevision.setter
-    def targetRevision(self, value):
+    @pkId.setter
+    def pkId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._targetRevision = value
+            self._pkId = value
         else:
             raise TypeError(
-                'Property "targetRevision" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "pkId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._path is not None:
-            result["path"] = \
-                self._path
-        if self._repoURL is not None:
-            result["repoURL"] = \
-                self._repoURL
-        if self._targetRevision is not None:
-            result["targetRevision"] = \
-                self._targetRevision
+        if self._entitlementId is not None:
+            result["entitlementId"] = \
+                self._entitlementId
+        if self._pkId is not None:
+            result["pkId"] = \
+                self._pkId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/GitRepositoriesResponse.py` & `basecommand/data/pym/ClusterTelemetry.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,93 +6,94 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .GitRepository import GitRepository
-from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(GitRepository))
-str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitRepositoriesResponse(object):
+class ClusterTelemetry(object):
+    """Cluster Telemetry"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.gitRepositories = (
+        self.gpuActiveTime = (
             None if not fromDict or propDict.get(
-                "gitRepositories"
+                "gpuActiveTime"
             ) is None
-            else [ GitRepository(i)
-            for i in propDict["gitRepositories"] ])
-        self.requestStatus = (
+            else propDict["gpuActiveTime"])
+        self.gpuUtilization = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "gpuUtilization"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["gpuUtilization"])
 
     @property
-    def gitRepositories(self):
-        """list: array of git repositories"""
-        return self._gitRepositories
-
-    @gitRepositories.setter
-    def gitRepositories(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._gitRepositories = value
+    def gpuActiveTime(self):
+        """float: Percentage of time the GPU was active"""
+        return self._gpuActiveTime
+
+    @gpuActiveTime.setter
+    def gpuActiveTime(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._gpuActiveTime = value
         else:
             raise TypeError(
-                'Property "gitRepositories" of type "list<GitRepository>" set'
-                ' to wrong type'
+                'Property "gpuActiveTime" of type "list<float>" set to wrong '
+                'type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def gpuUtilization(self):
+        """float: Percentage of GPU that was utilized"""
+        return self._gpuUtilization
+
+    @gpuUtilization.setter
+    def gpuUtilization(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._gpuUtilization = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "gpuUtilization" of type "list<float>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._gitRepositories:
-            result["gitRepositories"] = [
-                i.toDict() for i in self._gitRepositories 
-            ] if self._gitRepositories else []
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._gpuActiveTime is not None:
+            result["gpuActiveTime"] = \
+                self._gpuActiveTime
+        if self._gpuUtilization is not None:
+            result["gpuUtilization"] = \
+                self._gpuUtilization
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._gitRepositories is not None):
-            for obj in self._gitRepositories:
-                if (obj is not None): obj.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if self._gpuUtilization is None:
+            raise ValueError(
+                "ClusterTelemetry.gpuUtilization doesnt match requirement:" 
+                "required: True"
+            )
+        if self._gpuActiveTime is None:
+            raise ValueError(
+                "ClusterTelemetry.gpuActiveTime doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/GitRepository.py` & `registry/data/publishing/RequestStatus.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,135 +6,133 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Git import Git
+from .StatusCode import StatusCodeEnum
 
 # Unused import over optimization prevention
-str(repr(Git))
+str(repr(StatusCodeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitRepository(object):
-    """Repository represents a git or helm repository for an EGX application t
-    o be deployed from"""
+class RequestStatus(object):
+    """Request status information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.git = (
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "git"
+                "requestId"
             ) is None
-            else propDict["git"])
-        self.name = (
+            else propDict["requestId"])
+        self.serverId = (
             None if not fromDict or propDict.get(
-                "name"
+                "serverId"
             ) is None
-            else propDict["name"])
-        self.protocol = (
+            else propDict["serverId"])
+        self.statusCode = (
             None if not fromDict or propDict.get(
-                "protocol"
+                "statusCode"
             ) is None
-            else propDict["protocol"])
-        self.url = (
+            else propDict["statusCode"])
+        self.statusDescription = (
             None if not fromDict or propDict.get(
-                "url"
+                "statusDescription"
             ) is None
-            else propDict["url"])
+            else propDict["statusDescription"])
 
     @property
-    def git(self):
-        """Git: represents the information required for connecting to a git re
-        pository"""
-        return self._git
-
-    @git.setter
-    def git(self, value):
-        if value is not None and not isinstance(value, Git):
-            value = Git(value)
-        if (value is None) or isinstance(value, Git):
-            self._git = value
+    def requestId(self):
+        """str: Request ID"""
+        return self._requestId
+
+    @requestId.setter
+    def requestId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._requestId = value
         else:
             raise TypeError(
-                'Property "git" of type "list<Git>" set to wrong type'
+                'Property "requestId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: the unique identifying name of the repository"""
-        return self._name
+    def serverId(self):
+        """str: Server ID"""
+        return self._serverId
 
-    @name.setter
-    def name(self, value):
+    @serverId.setter
+    def serverId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._serverId = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "serverId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def protocol(self):
-        """str: determines whether it is an ssh or https based repository"""
-        return self._protocol
-
-    @protocol.setter
-    def protocol(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._protocol = value
+    def statusCode(self):
+        """StatusCodeEnum: Describes response status reported by the server.
+        """
+        return self._statusCode
+
+    @statusCode.setter
+    def statusCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._statusCode = value
         else:
             raise TypeError(
-                'Property "protocol" of type "list<str>" set to wrong type'
+                'Property "statusCode" of type "list<StatusCodeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def url(self):
-        """str: the unique identifying URL of the repository"""
-        return self._url
+    def statusDescription(self):
+        """str: Status description"""
+        return self._statusDescription
 
-    @url.setter
-    def url(self, value):
+    @statusDescription.setter
+    def statusDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._url = value
+            self._statusDescription = value
         else:
             raise TypeError(
-                'Property "url" of type "list<str>" set to wrong type'
+                'Property "statusDescription" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._git:
-            result["git"] = \
-                self._git.toDict() if self._git is not None else None
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._protocol is not None:
-            result["protocol"] = \
-                self._protocol
-        if self._url is not None:
-            result["url"] = \
-                self._url
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._serverId is not None:
+            result["serverId"] = \
+                self._serverId
+        if self._statusCode is not None:
+            result["statusCode"] = \
+                self._statusCode
+        if self._statusDescription is not None:
+            result["statusDescription"] = \
+                self._statusDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._git is not None): self._git.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GitRepositoryRequest.py` & `ngcbpc/data/model/DeploymentParameters.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,277 +6,254 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .DeploymentArtifactParameters import DeploymentArtifactParameters
+from .DeploymentStorageParameters import DeploymentStorageParameters
+from .DeploymentGpuParameters import DeploymentGpuParameters
+from .DeploymentMemoryParameters import DeploymentMemoryParameters
+from .DeploymentCpuParameters import DeploymentCpuParameters
 
 # Unused import over optimization prevention
+str(repr(DeploymentMemoryParameters))
+str(repr(DeploymentGpuParameters))
+str(repr(DeploymentCpuParameters))
+str(repr(DeploymentArtifactParameters))
+str(repr(DeploymentStorageParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitRepositoryRequest(object):
+class DeploymentParameters(object):
+    """Deployment Artifact Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.enableLFSSupport = (
+        self.container = (
             None if not fromDict or propDict.get(
-                "enableLFSSupport"
+                "container"
             ) is None
-            else propDict["enableLFSSupport"])
-        self.name = (
+            else propDict["container"])
+        self.cpu = (
             None if not fromDict or propDict.get(
-                "name"
+                "cpu"
             ) is None
-            else propDict["name"])
-        self.password = (
+            else propDict["cpu"])
+        self.csp = (
             None if not fromDict or propDict.get(
-                "password"
+                "csp"
             ) is None
-            else propDict["password"])
-        self.protocol = (
+            else propDict["csp"])
+        self.gpu = (
             None if not fromDict or propDict.get(
-                "protocol"
+                "gpu"
             ) is None
-            else propDict["protocol"])
-        self.proxy = (
+            else propDict["gpu"])
+        self.memory = (
             None if not fromDict or propDict.get(
-                "proxy"
+                "memory"
             ) is None
-            else propDict["proxy"])
-        self.sshPrivateKey = (
+            else propDict["memory"])
+        self.model = (
             None if not fromDict or propDict.get(
-                "sshPrivateKey"
+                "model"
             ) is None
-            else propDict["sshPrivateKey"])
-        self.tLSClientCert = (
+            else propDict["model"])
+        self.resource = (
             None if not fromDict or propDict.get(
-                "tLSClientCert"
+                "resource"
             ) is None
-            else propDict["tLSClientCert"])
-        self.tlsClientCertKey = (
+            else propDict["resource"])
+        self.storage = (
             None if not fromDict or propDict.get(
-                "tlsClientCertKey"
+                "storage"
             ) is None
-            else propDict["tlsClientCertKey"])
-        self.url = (
-            None if not fromDict or propDict.get(
-                "url"
-            ) is None
-            else propDict["url"])
-        self.username = (
-            None if not fromDict or propDict.get(
-                "username"
-            ) is None
-            else propDict["username"])
-
-    @property
-    def enableLFSSupport(self):
-        """bool: should be enabled if the repository uses Git LFS support"""
-        return self._enableLFSSupport
-
-    @enableLFSSupport.setter
-    def enableLFSSupport(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enableLFSSupport = value
-        else:
-            raise TypeError(
-                'Property "enableLFSSupport" of type "list<bool>" set to wron'
-                'g type'
-            )
+            else propDict["storage"])
 
     @property
-    def name(self):
-        """str: the unique identifying name of the repository"""
-        return self._name
+    def container(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._container
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @container.setter
+    def container(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._container = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "container" of type "list<DeploymentArtifactParamet'
+                'ers>" set to wrong type'
             )
 
     @property
-    def password(self):
-        """str: the password to connect to the repository with (optional)"""
-        return self._password
+    def cpu(self):
+        """DeploymentCpuParameters: Deployment CPU Parameters object"""
+        return self._cpu
 
-    @password.setter
-    def password(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._password = value
+    @cpu.setter
+    def cpu(self, value):
+        if value is not None and not isinstance(value, DeploymentCpuParameters):
+            value = DeploymentCpuParameters(value)
+        if (value is None) or isinstance(value, DeploymentCpuParameters):
+            self._cpu = value
         else:
             raise TypeError(
-                'Property "password" of type "list<str>" set to wrong type'
+                'Property "cpu" of type "list<DeploymentCpuParameters>" set t'
+                'o wrong type'
             )
 
     @property
-    def protocol(self):
-        """str: determines whether it is an ssh or https based repository"""
-        return self._protocol
+    def csp(self):
+        """str: Cloud Service Provider name"""
+        return self._csp
 
-    @protocol.setter
-    def protocol(self, value):
+    @csp.setter
+    def csp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._protocol = value
+            self._csp = value
         else:
             raise TypeError(
-                'Property "protocol" of type "list<str>" set to wrong type'
+                'Property "csp" of type "list<str>" set to wrong type'
             )
 
     @property
-    def proxy(self):
-        """str: Proxy is whether or not the repository"""
-        return self._proxy
+    def gpu(self):
+        """DeploymentGpuParameters: Deployment GPU Parameters object"""
+        return self._gpu
 
-    @proxy.setter
-    def proxy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._proxy = value
+    @gpu.setter
+    def gpu(self, value):
+        if value is not None and not isinstance(value, DeploymentGpuParameters):
+            value = DeploymentGpuParameters(value)
+        if (value is None) or isinstance(value, DeploymentGpuParameters):
+            self._gpu = value
         else:
             raise TypeError(
-                'Property "proxy" of type "list<str>" set to wrong type'
+                'Property "gpu" of type "list<DeploymentGpuParameters>" set t'
+                'o wrong type'
             )
 
     @property
-    def sshPrivateKey(self):
-        """str: the key for SSH"""
-        return self._sshPrivateKey
+    def memory(self):
+        """DeploymentMemoryParameters: Deployment Memory Parameters object"""
+        return self._memory
 
-    @sshPrivateKey.setter
-    def sshPrivateKey(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._sshPrivateKey = value
+    @memory.setter
+    def memory(self, value):
+        if value is not None and not isinstance(value, DeploymentMemoryParameters):
+            value = DeploymentMemoryParameters(value)
+        if (value is None) or isinstance(value, DeploymentMemoryParameters):
+            self._memory = value
         else:
             raise TypeError(
-                'Property "sshPrivateKey" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "memory" of type "list<DeploymentMemoryParameters>"'
+                ' set to wrong type'
             )
 
     @property
-    def tLSClientCert(self):
-        """str: is the client certificate"""
-        return self._tLSClientCert
+    def model(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._model
 
-    @tLSClientCert.setter
-    def tLSClientCert(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tLSClientCert = value
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._model = value
         else:
             raise TypeError(
-                'Property "tLSClientCert" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "model" of type "list<DeploymentArtifactParameters>'
+                '" set to wrong type'
             )
 
     @property
-    def tlsClientCertKey(self):
-        """str: the client certificate private key"""
-        return self._tlsClientCertKey
+    def resource(self):
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
+        return self._resource
 
-    @tlsClientCertKey.setter
-    def tlsClientCertKey(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tlsClientCertKey = value
+    @resource.setter
+    def resource(self, value):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
+            self._resource = value
         else:
             raise TypeError(
-                'Property "tlsClientCertKey" of type "list<str>" set to wrong'
-                ' type'
+                'Property "resource" of type "list<DeploymentArtifactParamete'
+                'rs>" set to wrong type'
             )
 
     @property
-    def url(self):
-        """str: the unique identifying URL of the repository"""
-        return self._url
+    def storage(self):
+        """DeploymentStorageParameters: Deployment Storage Parameters object
+        """
+        return self._storage
 
-    @url.setter
-    def url(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._url = value
-        else:
-            raise TypeError(
-                'Property "url" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def username(self):
-        """str: the user to connect to the repository with (optional)"""
-        return self._username
-
-    @username.setter
-    def username(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._username = value
+    @storage.setter
+    def storage(self, value):
+        if value is not None and not isinstance(value, DeploymentStorageParameters):
+            value = DeploymentStorageParameters(value)
+        if (value is None) or isinstance(value, DeploymentStorageParameters):
+            self._storage = value
         else:
             raise TypeError(
-                'Property "username" of type "list<str>" set to wrong type'
+                'Property "storage" of type "list<DeploymentStorageParameters'
+                '>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._enableLFSSupport is not None:
-            result["enableLFSSupport"] = \
-                self._enableLFSSupport
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._password is not None:
-            result["password"] = \
-                self._password
-        if self._protocol is not None:
-            result["protocol"] = \
-                self._protocol
-        if self._proxy is not None:
-            result["proxy"] = \
-                self._proxy
-        if self._sshPrivateKey is not None:
-            result["sshPrivateKey"] = \
-                self._sshPrivateKey
-        if self._tLSClientCert is not None:
-            result["tLSClientCert"] = \
-                self._tLSClientCert
-        if self._tlsClientCertKey is not None:
-            result["tlsClientCertKey"] = \
-                self._tlsClientCertKey
-        if self._url is not None:
-            result["url"] = \
-                self._url
-        if self._username is not None:
-            result["username"] = \
-                self._username
+        if self._container:
+            result["container"] = \
+                self._container.toDict() if self._container is not None else None
+        if self._cpu:
+            result["cpu"] = \
+                self._cpu.toDict() if self._cpu is not None else None
+        if self._csp is not None:
+            result["csp"] = \
+                self._csp
+        if self._gpu:
+            result["gpu"] = \
+                self._gpu.toDict() if self._gpu is not None else None
+        if self._memory:
+            result["memory"] = \
+                self._memory.toDict() if self._memory is not None else None
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._resource:
+            result["resource"] = \
+                self._resource.toDict() if self._resource is not None else None
+        if self._storage:
+            result["storage"] = \
+                self._storage.toDict() if self._storage is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._cpu is not None): self._cpu.isValid()
+        if (self._gpu is not None): self._gpu.isValid()
+        if (self._memory is not None): self._memory.isValid()
+        if (self._storage is not None): self._storage.isValid()
+        if (self._container is not None): self._container.isValid()
+        if (self._model is not None): self._model.isValid()
+        if (self._resource is not None): self._resource.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GitRepositoryResponse.py` & `ngcbpc/data/registry/RepositoryList.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,56 +6,80 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .GitRepository import GitRepository
+from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
+from .Repository import Repository
 
 # Unused import over optimization prevention
-str(repr(GitRepository))
 str(repr(RequestStatus))
+str(repr(Repository))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitRepositoryResponse(object):
+class RepositoryList(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.gitRepository = (
+        self.paginationInfo = (
             None if not fromDict or propDict.get(
-                "gitRepository"
+                "paginationInfo"
             ) is None
-            else propDict["gitRepository"])
+            else propDict["paginationInfo"])
+        self.repositories = (
+            None if not fromDict or propDict.get(
+                "repositories"
+            ) is None
+            else [ Repository(i)
+            for i in propDict["repositories"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def gitRepository(self):
-        """GitRepository: Repository represents a git or helm repository for a
-        n EGX application to be deployed from"""
-        return self._gitRepository
-
-    @gitRepository.setter
-    def gitRepository(self, value):
-        if value is not None and not isinstance(value, GitRepository):
-            value = GitRepository(value)
-        if (value is None) or isinstance(value, GitRepository):
-            self._gitRepository = value
+    def paginationInfo(self):
+        """PaginationInfo: object that describes the pagination information"""
+        return self._paginationInfo
+
+    @paginationInfo.setter
+    def paginationInfo(self, value):
+        if value is not None and not isinstance(value, PaginationInfo):
+            value = PaginationInfo(value)
+        if (value is None) or isinstance(value, PaginationInfo):
+            self._paginationInfo = value
         else:
             raise TypeError(
-                'Property "gitRepository" of type "list<GitRepository>" set t'
-                'o wrong type'
+                'Property "paginationInfo" of type "list<PaginationInfo>" set'
+                ' to wrong type'
+            )
+
+    @property
+    def repositories(self):
+        """list: list of repositories in given namespace"""
+        return self._repositories
+
+    @repositories.setter
+    def repositories(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._repositories = value
+        else:
+            raise TypeError(
+                'Property "repositories" of type "list<Repository>" set to wr'
+                'ong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -69,27 +93,34 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._gitRepository:
-            result["gitRepository"] = \
-                self._gitRepository.toDict() if self._gitRepository is not None else None
+        if self._paginationInfo:
+            result["paginationInfo"] = \
+                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._repositories:
+            result["repositories"] = [
+                i.toDict() for i in self._repositories 
+            ] if self._repositories else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._gitRepository is not None): self._gitRepository.isValid()
+        if (self._repositories is not None):
+            for obj in self._repositories:
+                if (obj is not None): obj.isValid()
+        if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GitRepositoryUpdateRequest.py` & `ngcbpc/data/uis/NvcfGpuUsage.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,240 +14,194 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GitRepositoryUpdateRequest(object):
+class NvcfGpuUsage(object):
+    """Information about the NVCF GPU usage for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.enableLFSSupport = (
+        self.cluster = (
             None if not fromDict or propDict.get(
-                "enableLFSSupport"
+                "cluster"
             ) is None
-            else propDict["enableLFSSupport"])
-        self.password = (
+            else propDict["cluster"])
+        self.currentInstances = (
             None if not fromDict or propDict.get(
-                "password"
+                "currentInstances"
             ) is None
-            else propDict["password"])
-        self.protocol = (
+            else propDict["currentInstances"])
+        self.gpuType = (
             None if not fromDict or propDict.get(
-                "protocol"
+                "gpuType"
             ) is None
-            else propDict["protocol"])
-        self.proxy = (
+            else propDict["gpuType"])
+        self.instanceType = (
             None if not fromDict or propDict.get(
-                "proxy"
+                "instanceType"
             ) is None
-            else propDict["proxy"])
-        self.sshPrivateKey = (
+            else propDict["instanceType"])
+        self.isAllowToRequest = (
             None if not fromDict or propDict.get(
-                "sshPrivateKey"
+                "isAllowToRequest"
             ) is None
-            else propDict["sshPrivateKey"])
-        self.tLSClientCert = (
+            else propDict["isAllowToRequest"])
+        self.maxInstances = (
             None if not fromDict or propDict.get(
-                "tLSClientCert"
+                "maxInstances"
             ) is None
-            else propDict["tLSClientCert"])
-        self.tlsClientCertKey = (
+            else propDict["maxInstances"])
+        self.requestedInstances = (
             None if not fromDict or propDict.get(
-                "tlsClientCertKey"
+                "requestedInstances"
             ) is None
-            else propDict["tlsClientCertKey"])
-        self.url = (
-            None if not fromDict or propDict.get(
-                "url"
-            ) is None
-            else propDict["url"])
-        self.username = (
-            None if not fromDict or propDict.get(
-                "username"
-            ) is None
-            else propDict["username"])
+            else propDict["requestedInstances"])
 
     @property
-    def enableLFSSupport(self):
-        """bool: should be enabled if the repository uses Git LFS support"""
-        return self._enableLFSSupport
+    def cluster(self):
+        """ """
+        return self._cluster
 
-    @enableLFSSupport.setter
-    def enableLFSSupport(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enableLFSSupport = value
-        else:
-            raise TypeError(
-                'Property "enableLFSSupport" of type "list<bool>" set to wron'
-                'g type'
-            )
-
-    @property
-    def password(self):
-        """str: the password to connect to the repository with (optional)"""
-        return self._password
-
-    @password.setter
-    def password(self, value):
+    @cluster.setter
+    def cluster(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._password = value
+            self._cluster = value
         else:
             raise TypeError(
-                'Property "password" of type "list<str>" set to wrong type'
+                'Property "cluster" of type "list<str>" set to wrong type'
             )
 
     @property
-    def protocol(self):
-        """str: determines whether it is an ssh or https based repository"""
-        return self._protocol
+    def currentInstances(self):
+        """ """
+        return self._currentInstances
 
-    @protocol.setter
-    def protocol(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._protocol = value
+    @currentInstances.setter
+    def currentInstances(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._currentInstances = value
         else:
             raise TypeError(
-                'Property "protocol" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def proxy(self):
-        """str: Proxy is whether or not the repository"""
-        return self._proxy
-
-    @proxy.setter
-    def proxy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._proxy = value
-        else:
-            raise TypeError(
-                'Property "proxy" of type "list<str>" set to wrong type'
+                'Property "currentInstances" of type "list<int>" set to wrong'
+                ' type'
             )
 
     @property
-    def sshPrivateKey(self):
-        """str: the key for SSH"""
-        return self._sshPrivateKey
+    def gpuType(self):
+        """ """
+        return self._gpuType
 
-    @sshPrivateKey.setter
-    def sshPrivateKey(self, value):
+    @gpuType.setter
+    def gpuType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sshPrivateKey = value
+            self._gpuType = value
         else:
             raise TypeError(
-                'Property "sshPrivateKey" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "gpuType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tLSClientCert(self):
-        """str: is the client certificate"""
-        return self._tLSClientCert
+    def instanceType(self):
+        """ """
+        return self._instanceType
 
-    @tLSClientCert.setter
-    def tLSClientCert(self, value):
+    @instanceType.setter
+    def instanceType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tLSClientCert = value
+            self._instanceType = value
         else:
             raise TypeError(
-                'Property "tLSClientCert" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "instanceType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def tlsClientCertKey(self):
-        """str: the client certificate private key"""
-        return self._tlsClientCertKey
+    def isAllowToRequest(self):
+        """ """
+        return self._isAllowToRequest
 
-    @tlsClientCertKey.setter
-    def tlsClientCertKey(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tlsClientCertKey = value
+    @isAllowToRequest.setter
+    def isAllowToRequest(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isAllowToRequest = value
         else:
             raise TypeError(
-                'Property "tlsClientCertKey" of type "list<str>" set to wrong'
-                ' type'
+                'Property "isAllowToRequest" of type "list<bool>" set to wron'
+                'g type'
             )
 
     @property
-    def url(self):
-        """str: the unique identifying URL of the repository"""
-        return self._url
+    def maxInstances(self):
+        """ """
+        return self._maxInstances
 
-    @url.setter
-    def url(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._url = value
+    @maxInstances.setter
+    def maxInstances(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._maxInstances = value
         else:
             raise TypeError(
-                'Property "url" of type "list<str>" set to wrong type'
+                'Property "maxInstances" of type "list<int>" set to wrong typ'
+                'e'
             )
 
     @property
-    def username(self):
-        """str: the user to connect to the repository with (optional)"""
-        return self._username
+    def requestedInstances(self):
+        """ """
+        return self._requestedInstances
 
-    @username.setter
-    def username(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._username = value
+    @requestedInstances.setter
+    def requestedInstances(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._requestedInstances = value
         else:
             raise TypeError(
-                'Property "username" of type "list<str>" set to wrong type'
+                'Property "requestedInstances" of type "list<int>" set to wro'
+                'ng type'
             )
 
     def toDict(self):
         result = {}
-        if self._enableLFSSupport is not None:
-            result["enableLFSSupport"] = \
-                self._enableLFSSupport
-        if self._password is not None:
-            result["password"] = \
-                self._password
-        if self._protocol is not None:
-            result["protocol"] = \
-                self._protocol
-        if self._proxy is not None:
-            result["proxy"] = \
-                self._proxy
-        if self._sshPrivateKey is not None:
-            result["sshPrivateKey"] = \
-                self._sshPrivateKey
-        if self._tLSClientCert is not None:
-            result["tLSClientCert"] = \
-                self._tLSClientCert
-        if self._tlsClientCertKey is not None:
-            result["tlsClientCertKey"] = \
-                self._tlsClientCertKey
-        if self._url is not None:
-            result["url"] = \
-                self._url
-        if self._username is not None:
-            result["username"] = \
-                self._username
+        if self._cluster is not None:
+            result["cluster"] = \
+                self._cluster
+        if self._currentInstances is not None:
+            result["currentInstances"] = \
+                self._currentInstances
+        if self._gpuType is not None:
+            result["gpuType"] = \
+                self._gpuType
+        if self._instanceType is not None:
+            result["instanceType"] = \
+                self._instanceType
+        if self._isAllowToRequest is not None:
+            result["isAllowToRequest"] = \
+                self._isAllowToRequest
+        if self._maxInstances is not None:
+            result["maxInstances"] = \
+                self._maxInstances
+        if self._requestedInstances is not None:
+            result["requestedInstances"] = \
+                self._requestedInstances
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/GpuInfo.py` & `ngcbpc/data/registry/ScanIssue.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,216 +6,230 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MigProfileInfo import MigProfileInfo
-from .MigStatusEnum import MigStatusEnum
+from .ScanIssueSeverity import ScanIssueSeverityEnum
 
 # Unused import over optimization prevention
-str(repr(MigStatusEnum))
-str(repr(MigProfileInfo))
+str(repr(ScanIssueSeverityEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GpuInfo(object):
-    """GPU information in a node"""
+class ScanIssue(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.availableMigProfiles = (
+        self.checkOutput = (
             None if not fromDict or propDict.get(
-                "availableMigProfiles"
+                "checkOutput"
             ) is None
-            else [ MigProfileInfo(i)
-            for i in propDict["availableMigProfiles"] ])
-        self.currentMigProfile = (
+            else propDict["checkOutput"])
+        self.cveUrl = (
             None if not fromDict or propDict.get(
-                "currentMigProfile"
+                "cveUrl"
             ) is None
-            else propDict["currentMigProfile"])
-        self.errorMessage = (
+            else propDict["cveUrl"])
+        self.gate = (
             None if not fromDict or propDict.get(
-                "errorMessage"
+                "gate"
             ) is None
-            else propDict["errorMessage"])
-        self.gpuDescription = (
+            else propDict["gate"])
+        self.gateAction = (
             None if not fromDict or propDict.get(
-                "gpuDescription"
+                "gateAction"
             ) is None
-            else propDict["gpuDescription"])
-        self.gpuId = (
+            else propDict["gateAction"])
+        self.issueSeverity = (
             None if not fromDict or propDict.get(
-                "gpuId"
+                "issueSeverity"
             ) is None
-            else propDict["gpuId"])
-        self.isMigSupportedInGpu = (
+            else propDict["issueSeverity"])
+        self.trigger = (
             None if not fromDict or propDict.get(
-                "isMigSupportedInGpu"
+                "trigger"
             ) is None
-            else propDict["isMigSupportedInGpu"])
-        self.migStatus = (
+            else propDict["trigger"])
+        self.triggerId = (
             None if not fromDict or propDict.get(
-                "migStatus"
+                "triggerId"
             ) is None
-            else propDict["migStatus"])
+            else propDict["triggerId"])
+        self.whitelisted = (
+            None if not fromDict or propDict.get(
+                "whitelisted"
+            ) is None
+            else propDict["whitelisted"])
 
     @property
-    def availableMigProfiles(self):
-        """ """
-        return self._availableMigProfiles
+    def checkOutput(self):
+        """str: Anchore engine output"""
+        return self._checkOutput
 
-    @availableMigProfiles.setter
-    def availableMigProfiles(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._availableMigProfiles = value
+    @checkOutput.setter
+    def checkOutput(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._checkOutput = value
         else:
             raise TypeError(
-                'Property "availableMigProfiles" of type "list<MigProfileInfo'
-                '>" set to wrong type'
+                'Property "checkOutput" of type "list<str>" set to wrong type'
             )
 
     @property
-    def currentMigProfile(self):
-        """ """
-        return self._currentMigProfile
+    def cveUrl(self):
+        """str: CVE url for vulnerabilities"""
+        return self._cveUrl
 
-    @currentMigProfile.setter
-    def currentMigProfile(self, value):
-        if value is not None and not isinstance(value, MigProfileInfo):
-            value = MigProfileInfo(value)
-        if (value is None) or isinstance(value, MigProfileInfo):
-            self._currentMigProfile = value
+    @cveUrl.setter
+    def cveUrl(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._cveUrl = value
         else:
             raise TypeError(
-                'Property "currentMigProfile" of type "list<MigProfileInfo>" '
-                'set to wrong type'
+                'Property "cveUrl" of type "list<str>" set to wrong type'
             )
 
     @property
-    def errorMessage(self):
-        """str: Error message to return to client"""
-        return self._errorMessage
+    def gate(self):
+        """str: A 'Gate' is a logical grouping of trigger definitions and prov
+        ides a broader context for the execution of triggers against i
+        mage analysis data."""
+        return self._gate
 
-    @errorMessage.setter
-    def errorMessage(self, value):
+    @gate.setter
+    def gate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._errorMessage = value
+            self._gate = value
         else:
             raise TypeError(
-                'Property "errorMessage" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "gate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpuDescription(self):
-        """str: Description of the GPU (e.g. A100-PCIE-40GB)"""
-        return self._gpuDescription
+    def gateAction(self):
+        """str: Action which should be taken"""
+        return self._gateAction
 
-    @gpuDescription.setter
-    def gpuDescription(self, value):
+    @gateAction.setter
+    def gateAction(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuDescription = value
+            self._gateAction = value
         else:
             raise TypeError(
-                'Property "gpuDescription" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "gateAction" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpuId(self):
-        """str: The unique identifier of a GPU"""
-        return self._gpuId
+    def issueSeverity(self):
+        """ScanIssueSeverityEnum: Image scan issue severity"""
+        return self._issueSeverity
 
-    @gpuId.setter
-    def gpuId(self, value):
+    @issueSeverity.setter
+    def issueSeverity(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._issueSeverity = value
+        else:
+            raise TypeError(
+                'Property "issueSeverity" of type "list<ScanIssueSeverityEnum'
+                '>" set to wrong type'
+            )
+
+    @property
+    def trigger(self):
+        """str: Triggers define a specific condition to check within the conte
+        xt of a gate, optionally with one or more input parameters."""
+        return self._trigger
+
+    @trigger.setter
+    def trigger(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuId = value
+            self._trigger = value
         else:
             raise TypeError(
-                'Property "gpuId" of type "list<str>" set to wrong type'
+                'Property "trigger" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isMigSupportedInGpu(self):
-        """bool: Is MIG supported in the gpu"""
-        return self._isMigSupportedInGpu
+    def triggerId(self):
+        """str: Unique identifier of the trigger associated with the issue"""
+        return self._triggerId
 
-    @isMigSupportedInGpu.setter
-    def isMigSupportedInGpu(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isMigSupportedInGpu = value
+    @triggerId.setter
+    def triggerId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._triggerId = value
         else:
             raise TypeError(
-                'Property "isMigSupportedInGpu" of type "list<bool>" set to w'
-                'rong type'
+                'Property "triggerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def migStatus(self):
-        """MigStatusEnum: Status of MIG on the GPU """
-        return self._migStatus
+    def whitelisted(self):
+        """bool: Whether image whitelisted"""
+        return self._whitelisted
 
-    @migStatus.setter
-    def migStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._migStatus = value
+    @whitelisted.setter
+    def whitelisted(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._whitelisted = value
         else:
             raise TypeError(
-                'Property "migStatus" of type "list<MigStatusEnum>" set to wr'
-                'ong type'
+                'Property "whitelisted" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._availableMigProfiles:
-            result["availableMigProfiles"] = [
-                i.toDict() for i in self._availableMigProfiles 
-            ] if self._availableMigProfiles else []
-        if self._currentMigProfile:
-            result["currentMigProfile"] = \
-                self._currentMigProfile.toDict() if self._currentMigProfile is not None else None
-        if self._errorMessage is not None:
-            result["errorMessage"] = \
-                self._errorMessage
-        if self._gpuDescription is not None:
-            result["gpuDescription"] = \
-                self._gpuDescription
-        if self._gpuId is not None:
-            result["gpuId"] = \
-                self._gpuId
-        if self._isMigSupportedInGpu is not None:
-            result["isMigSupportedInGpu"] = \
-                self._isMigSupportedInGpu
-        if self._migStatus is not None:
-            result["migStatus"] = \
-                self._migStatus
+        if self._checkOutput is not None:
+            result["checkOutput"] = \
+                self._checkOutput
+        if self._cveUrl is not None:
+            result["cveUrl"] = \
+                self._cveUrl
+        if self._gate is not None:
+            result["gate"] = \
+                self._gate
+        if self._gateAction is not None:
+            result["gateAction"] = \
+                self._gateAction
+        if self._issueSeverity is not None:
+            result["issueSeverity"] = \
+                self._issueSeverity
+        if self._trigger is not None:
+            result["trigger"] = \
+                self._trigger
+        if self._triggerId is not None:
+            result["triggerId"] = \
+                self._triggerId
+        if self._whitelisted is not None:
+            result["whitelisted"] = \
+                self._whitelisted
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._availableMigProfiles is not None):
-            for obj in self._availableMigProfiles:
-                if (obj is not None): obj.isValid()
-        if (self._currentMigProfile is not None): self._currentMigProfile.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GpuLogStorageUsageResponse.py` & `ngcbpc/data/model/ArtifactPublishRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,135 +6,160 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
+from .AccessTypeEnum import AccessTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
+str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GpuLogStorageUsageResponse(object):
+class ArtifactPublishRequest(object):
+    """Request to publish an artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.activeGpuCount = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "activeGpuCount"
+                "accessType"
             ) is None
-            else propDict["activeGpuCount"])
-        self.logStorage = (
+            else propDict["accessType"])
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "logStorage"
+                "canGuestPull"
             ) is None
-            else propDict["logStorage"])
-        self.maxGpuCount = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "maxGpuCount"
+                "canPublicList"
             ) is None
-            else propDict["maxGpuCount"])
-        self.requestStatus = (
+            else propDict["canPublicList"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "isPublic"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["isPublic"])
+        self.productNames = (
+            None if not fromDict or propDict.get(
+                "productNames"
+            ) is None
+            else propDict["productNames"])
 
     @property
-    def activeGpuCount(self):
-        """int: Active GPUs count in the org"""
-        return self._activeGpuCount
-
-    @activeGpuCount.setter
-    def activeGpuCount(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._activeGpuCount = value
+    def accessType(self):
+        """ """
+        return self._accessType
+
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "activeGpuCount" of type "list<int>" set to wrong t'
-                'ype'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def logStorage(self):
-        """float: Log storage usage in Gb"""
-        return self._logStorage
-
-    @logStorage.setter
-    def logStorage(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._logStorage = value
+    def canGuestPull(self):
+        """ """
+        return self._canGuestPull
+
+    @canGuestPull.setter
+    def canGuestPull(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "logStorage" of type "list<float>" set to wrong typ'
-                'e'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def maxGpuCount(self):
-        """int: Max monthly GPUs count in the org"""
-        return self._maxGpuCount
-
-    @maxGpuCount.setter
-    def maxGpuCount(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._maxGpuCount = value
+    def canPublicList(self):
+        """ """
+        return self._canPublicList
+
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "maxGpuCount" of type "list<int>" set to wrong type'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def requestStatus(self):
+    def isPublic(self):
         """ """
-        return self._requestStatus
+        return self._isPublic
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
+        else:
+            raise TypeError(
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
+
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._activeGpuCount is not None:
-            result["activeGpuCount"] = \
-                self._activeGpuCount
-        if self._logStorage is not None:
-            result["logStorage"] = \
-                self._logStorage
-        if self._maxGpuCount is not None:
-            result["maxGpuCount"] = \
-                self._maxGpuCount
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/GpuManagement.py` & `ngcbpc/data/model/MultipartUploadCompleteRequest.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,193 +6,211 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ManagedGpus import ManagedGpus
 
 # Unused import over optimization prevention
-str(repr(ManagedGpus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GpuManagement(object):
+class MultipartUploadCompleteRequest(object):
+    """Request body for completing a multipart upload for artifacts"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.locationName = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "locationName"
+                "artifactType"
             ) is None
-            else propDict["locationName"])
-        self.managedGpus = (
+            else propDict["artifactType"])
+        self.filePath = (
             None if not fromDict or propDict.get(
-                "managedGpus"
+                "filePath"
             ) is None
-            else [ ManagedGpus(i)
-            for i in propDict["managedGpus"] ])
-        self.nodeName = (
+            else propDict["filePath"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "nodeName"
+                "name"
             ) is None
-            else propDict["nodeName"])
-        self.systemType = (
+            else propDict["name"])
+        self.sha256 = (
             None if not fromDict or propDict.get(
-                "systemType"
+                "sha256"
             ) is None
-            else propDict["systemType"])
-        self.totalGpuCount = (
+            else propDict["sha256"])
+        self.uploadID = (
             None if not fromDict or propDict.get(
-                "totalGpuCount"
+                "uploadID"
             ) is None
-            else propDict["totalGpuCount"])
+            else propDict["uploadID"])
+        self.version = (
+            None if not fromDict or propDict.get(
+                "version"
+            ) is None
+            else propDict["version"])
 
     @property
-    def locationName(self):
-        """str: Name of the location"""
-        return self._locationName
+    def artifactType(self):
+        """str: Type of artifact"""
+        return self._artifactType
 
-    @locationName.setter
-    def locationName(self, value):
+    @artifactType.setter
+    def artifactType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._locationName = value
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "locationName" of type "list<str>" set to wrong typ'
+                'Property "artifactType" of type "list<str>" set to wrong typ'
                 'e'
             )
 
     @property
-    def managedGpus(self):
-        """ """
-        return self._managedGpus
+    def filePath(self):
+        """str: The file path for the artifact upload"""
+        return self._filePath
 
-    @managedGpus.setter
-    def managedGpus(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._managedGpus = value
+    @filePath.setter
+    def filePath(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._filePath = value
         else:
             raise TypeError(
-                'Property "managedGpus" of type "list<ManagedGpus>" set to wr'
-                'ong type'
+                'Property "filePath" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nodeName(self):
-        """str: Name of the node"""
-        return self._nodeName
+    def name(self):
+        """str: Name of the artifact"""
+        return self._name
 
-    @nodeName.setter
-    def nodeName(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nodeName = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "nodeName" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def systemType(self):
-        """str: Type of the system"""
-        return self._systemType
+    def sha256(self):
+        """str: Base64 encoded sha256 hash of file used by AWS to verify data 
+        integrity on the uploads"""
+        return self._sha256
 
-    @systemType.setter
-    def systemType(self, value):
+    @sha256.setter
+    def sha256(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._systemType = value
+            self._sha256 = value
         else:
             raise TypeError(
-                'Property "systemType" of type "list<str>" set to wrong type'
+                'Property "sha256" of type "list<str>" set to wrong type'
             )
 
     @property
-    def totalGpuCount(self):
-        """int: Total GPU count in the location and node"""
-        return self._totalGpuCount
+    def uploadID(self):
+        """str: The unique ID assigned by AWS for this multipart upload to ass
+        ociate all upload parts"""
+        return self._uploadID
 
-    @totalGpuCount.setter
-    def totalGpuCount(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._totalGpuCount = value
+    @uploadID.setter
+    def uploadID(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uploadID = value
         else:
             raise TypeError(
-                'Property "totalGpuCount" of type "list<int>" set to wrong ty'
-                'pe'
+                'Property "uploadID" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def version(self):
+        """str: Artifact version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
+        else:
+            raise TypeError(
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._locationName is not None:
-            result["locationName"] = \
-                self._locationName
-        if self._managedGpus:
-            result["managedGpus"] = [
-                i.toDict() for i in self._managedGpus 
-            ] if self._managedGpus else []
-        if self._nodeName is not None:
-            result["nodeName"] = \
-                self._nodeName
-        if self._systemType is not None:
-            result["systemType"] = \
-                self._systemType
-        if self._totalGpuCount is not None:
-            result["totalGpuCount"] = \
-                self._totalGpuCount
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._filePath is not None:
+            result["filePath"] = \
+                self._filePath
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._sha256 is not None:
+            result["sha256"] = \
+                self._sha256
+        if self._uploadID is not None:
+            result["uploadID"] = \
+                self._uploadID
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._locationName is not None
-            and
-            len(self._locationName) > 53):
-            raise ValueError(
-                "GpuManagement.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._locationName is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._locationName)):
-            raise ValueError(
-                "GpuManagement.locationName: " + str(self._locationName) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._nodeName is not None
-            and
-            len(self._nodeName) > 53):
-            raise ValueError(
-                "GpuManagement.nodeName: " + str(self._nodeName) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._nodeName is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._nodeName)):
-            raise ValueError(
-                "GpuManagement.nodeName: " + str(self._nodeName) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._managedGpus is not None):
-            for obj in self._managedGpus:
-                if (obj is not None): obj.isValid()
+        if self._name is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._version is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._artifactType is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._filePath is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.filePath doesnt match requirement:" 
+                "required: True"
+            )
+        if self._uploadID is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.uploadID doesnt match requirement:" 
+                "required: True"
+            )
+        if self._sha256 is None:
+            raise ValueError(
+                "MultipartUploadCompleteRequest.sha256 doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/GpuManagementResponse.py` & `ngcbpc/data/uis/RoleScopesResponse.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,58 +6,41 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .GpuManagement import GpuManagement
 from .RequestStatus import RequestStatus
+from .RoleScopes import RoleScopes
 
 # Unused import over optimization prevention
-str(repr(GpuManagement))
 str(repr(RequestStatus))
+str(repr(RoleScopes))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class GpuManagementResponse(object):
+class RoleScopesResponse(object):
+    """Role Scopes Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.gpuManagement = (
-            None if not fromDict or propDict.get(
-                "gpuManagement"
-            ) is None
-            else [ GpuManagement(i)
-            for i in propDict["gpuManagement"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def gpuManagement(self):
-        """list: array of gpu_management object that describes gpu management
-        """
-        return self._gpuManagement
-
-    @gpuManagement.setter
-    def gpuManagement(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._gpuManagement = value
-        else:
-            raise TypeError(
-                'Property "gpuManagement" of type "list<GpuManagement>" set t'
-                'o wrong type'
-            )
+        self.roleScopes = (
+            None if not fromDict or propDict.get(
+                "roleScopes"
+            ) is None
+            else [ RoleScopes(i)
+            for i in propDict["roleScopes"] ])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -68,32 +51,49 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def roleScopes(self):
+        """list: A list of role scopes"""
+        return self._roleScopes
+
+    @roleScopes.setter
+    def roleScopes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roleScopes = value
+        else:
+            raise TypeError(
+                'Property "roleScopes" of type "list<RoleScopes>" set to wron'
+                'g type'
+            )
+
     def toDict(self):
         result = {}
-        if self._gpuManagement:
-            result["gpuManagement"] = [
-                i.toDict() for i in self._gpuManagement 
-            ] if self._gpuManagement else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._roleScopes:
+            result["roleScopes"] = [
+                i.toDict() for i in self._roleScopes 
+            ] if self._roleScopes else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._gpuManagement is not None):
-            for obj in self._gpuManagement:
+        if (self._roleScopes is not None):
+            for obj in self._roleScopes:
                 if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Installer.py` & `ngcbpc/data/model/DeploymentMemoryParameters.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,68 +14,46 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Installer(object):
+class DeploymentMemoryParameters(object):
+    """Deployment Memory Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.command = (
+        self.capacityInGB = (
             None if not fromDict or propDict.get(
-                "command"
+                "capacityInGB"
             ) is None
-            else propDict["command"])
-        self.device = (
-            None if not fromDict or propDict.get(
-                "device"
-            ) is None
-            else propDict["device"])
-
-    @property
-    def command(self):
-        """str: The command of the installer"""
-        return self._command
-
-    @command.setter
-    def command(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._command = value
-        else:
-            raise TypeError(
-                'Property "command" of type "list<str>" set to wrong type'
-            )
+            else propDict["capacityInGB"])
 
     @property
-    def device(self):
-        """str: The device type of the installer"""
-        return self._device
-
-    @device.setter
-    def device(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._device = value
+    def capacityInGB(self):
+        """long: Capacity in GB"""
+        return self._capacityInGB
+
+    @capacityInGB.setter
+    def capacityInGB(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._capacityInGB = value
         else:
             raise TypeError(
-                'Property "device" of type "list<str>" set to wrong type'
+                'Property "capacityInGB" of type "list<long>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._command is not None:
-            result["command"] = \
-                self._command
-        if self._device is not None:
-            result["device"] = \
-                self._device
+        if self._capacityInGB is not None:
+            result["capacityInGB"] = \
+                self._capacityInGB
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/InstallersResponse.py` & `organization/data/subscription_management_service/Action.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,97 +6,105 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Installer import Installer
-from .CustomInstaller import CustomInstaller
 
 # Unused import over optimization prevention
-str(repr(CustomInstaller))
-str(repr(Installer))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class InstallersResponse(object):
+class Action(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.customInstallers = (
+        self.href = (
             None if not fromDict or propDict.get(
-                "customInstallers"
+                "href"
             ) is None
-            else [ CustomInstaller(i)
-            for i in propDict["customInstallers"] ])
-        self.installers = (
+            else propDict["href"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "installers"
+                "id"
             ) is None
-            else [ Installer(i)
-            for i in propDict["installers"] ])
+            else propDict["id"])
+        self.name = (
+            None if not fromDict or propDict.get(
+                "name"
+            ) is None
+            else propDict["name"])
+
+    @property
+    def href(self):
+        """str: action link"""
+        return self._href
+
+    @href.setter
+    def href(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._href = value
+        else:
+            raise TypeError(
+                'Property "href" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def customInstallers(self):
-        """list: Available custom installers"""
-        return self._customInstallers
-
-    @customInstallers.setter
-    def customInstallers(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._customInstallers = value
+    def id(self):
+        """str: action id"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "customInstallers" of type "list<CustomInstaller>" '
-                'set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def installers(self):
-        """list: Available FC installers"""
-        return self._installers
-
-    @installers.setter
-    def installers(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._installers = value
+    def name(self):
+        """str: display name of additional action for the product"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "installers" of type "list<Installer>" set to wrong'
-                ' type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._customInstallers:
-            result["customInstallers"] = [
-                i.toDict() for i in self._customInstallers 
-            ] if self._customInstallers else []
-        if self._installers:
-            result["installers"] = [
-                i.toDict() for i in self._installers 
-            ] if self._installers else []
+        if self._href is not None:
+            result["href"] = \
+                self._href
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._installers is not None):
-            for obj in self._installers:
-                if (obj is not None): obj.isValid()
-        if (self._customInstallers is not None):
-            for obj in self._customInstallers:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/InstallersValidationRequest.py` & `organization/data/subscription_management_service/PreviewOrderResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,61 +6,90 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ValidationStatus import ValidationStatus
+from .PreviewOrder import PreviewOrder
+from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(ValidationStatus))
+str(repr(RequestStatus))
+str(repr(PreviewOrder))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class InstallersValidationRequest(object):
+class PreviewOrderResponse(object):
+    """Response for preview order API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.validation = (
+        self.previewOrder = (
             None if not fromDict or propDict.get(
-                "validation"
+                "previewOrder"
             ) is None
-            else propDict["validation"])
+            else propDict["previewOrder"])
+        self.requestStatus = (
+            None if not fromDict or propDict.get(
+                "requestStatus"
+            ) is None
+            else propDict["requestStatus"])
+
+    @property
+    def previewOrder(self):
+        """ """
+        return self._previewOrder
+
+    @previewOrder.setter
+    def previewOrder(self, value):
+        if value is not None and not isinstance(value, PreviewOrder):
+            value = PreviewOrder(value)
+        if (value is None) or isinstance(value, PreviewOrder):
+            self._previewOrder = value
+        else:
+            raise TypeError(
+                'Property "previewOrder" of type "list<PreviewOrder>" set to '
+                'wrong type'
+            )
 
     @property
-    def validation(self):
+    def requestStatus(self):
         """ """
-        return self._validation
+        return self._requestStatus
 
-    @validation.setter
-    def validation(self, value):
-        if value is not None and not isinstance(value, ValidationStatus):
-            value = ValidationStatus(value)
-        if (value is None) or isinstance(value, ValidationStatus):
-            self._validation = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "validation" of type "list<ValidationStatus>" set t'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._validation:
-            result["validation"] = \
-                self._validation.toDict() if self._validation is not None else None
+        if self._previewOrder:
+            result["previewOrder"] = \
+                self._previewOrder.toDict() if self._previewOrder is not None else None
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._validation is not None): self._validation.isValid()
+        if (self._previewOrder is not None): self._previewOrder.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Iso.py` & `ngcbpc/data/registry/OciIndexManifest.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,117 +14,117 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Iso(object):
+class OciIndexManifest(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.checksum = (
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "checksum"
+                "artifactType"
             ) is None
-            else propDict["checksum"])
-        self.isoSourceCodeUrl = (
+            else propDict["artifactType"])
+        self.digest = (
             None if not fromDict or propDict.get(
-                "isoSourceCodeUrl"
+                "digest"
             ) is None
-            else propDict["isoSourceCodeUrl"])
-        self.isoUrl = (
+            else propDict["digest"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "isoUrl"
+                "mediaType"
             ) is None
-            else propDict["isoUrl"])
-        self.isoVersion = (
+            else propDict["mediaType"])
+        self.size = (
             None if not fromDict or propDict.get(
-                "isoVersion"
+                "size"
             ) is None
-            else propDict["isoVersion"])
+            else propDict["size"])
 
     @property
-    def checksum(self):
-        """str: SHA256 checksum"""
-        return self._checksum
+    def artifactType(self):
+        """str: Type of artifact"""
+        return self._artifactType
 
-    @checksum.setter
-    def checksum(self, value):
+    @artifactType.setter
+    def artifactType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._checksum = value
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "checksum" of type "list<str>" set to wrong type'
+                'Property "artifactType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def isoSourceCodeUrl(self):
-        """ """
-        return self._isoSourceCodeUrl
+    def digest(self):
+        """str: Images sha256 digest"""
+        return self._digest
 
-    @isoSourceCodeUrl.setter
-    def isoSourceCodeUrl(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._isoSourceCodeUrl = value
+            self._digest = value
         else:
             raise TypeError(
-                'Property "isoSourceCodeUrl" of type "list<str>" set to wrong'
-                ' type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isoUrl(self):
-        """ """
-        return self._isoUrl
+    def mediaType(self):
+        """str: should be 'application/vnd.oci.image.manifest.v1+json'"""
+        return self._mediaType
 
-    @isoUrl.setter
-    def isoUrl(self, value):
+    @mediaType.setter
+    def mediaType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._isoUrl = value
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "isoUrl" of type "list<str>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isoVersion(self):
-        """ """
-        return self._isoVersion
-
-    @isoVersion.setter
-    def isoVersion(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._isoVersion = value
+    def size(self):
+        """long: Layer size in bytes"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
         else:
             raise TypeError(
-                'Property "isoVersion" of type "list<str>" set to wrong type'
+                'Property "size" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._checksum is not None:
-            result["checksum"] = \
-                self._checksum
-        if self._isoSourceCodeUrl is not None:
-            result["isoSourceCodeUrl"] = \
-                self._isoSourceCodeUrl
-        if self._isoUrl is not None:
-            result["isoUrl"] = \
-                self._isoUrl
-        if self._isoVersion is not None:
-            result["isoVersion"] = \
-                self._isoVersion
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._size is not None:
+            result["size"] = \
+                self._size
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/Label.py` & `ngcbpc/data/registry/EventSource.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,68 +14,71 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Label(object):
+class EventSource(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.key = (
+        self.addr = (
             None if not fromDict or propDict.get(
-                "key"
+                "addr"
             ) is None
-            else propDict["key"])
-        self.value = (
+            else propDict["addr"])
+        self.instanceID = (
             None if not fromDict or propDict.get(
-                "value"
+                "instanceID"
             ) is None
-            else propDict["value"])
+            else propDict["instanceID"])
 
     @property
-    def key(self):
-        """ """
-        return self._key
+    def addr(self):
+        """str: Addr contains the ip or hostname and the port of the registry 
+        node that generated the event. Generally, this will be resolve
+        d by os.Hostname() along with the running port."""
+        return self._addr
 
-    @key.setter
-    def key(self, value):
+    @addr.setter
+    def addr(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._key = value
+            self._addr = value
         else:
             raise TypeError(
-                'Property "key" of type "list<str>" set to wrong type'
+                'Property "addr" of type "list<str>" set to wrong type'
             )
 
     @property
-    def value(self):
-        """ """
-        return self._value
+    def instanceID(self):
+        """str: InstanceID identifies a running instance of an application. Ch
+        anges after each restart."""
+        return self._instanceID
 
-    @value.setter
-    def value(self, value):
+    @instanceID.setter
+    def instanceID(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._value = value
+            self._instanceID = value
         else:
             raise TypeError(
-                'Property "value" of type "list<str>" set to wrong type'
+                'Property "instanceID" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._key is not None:
-            result["key"] = \
-                self._key
-        if self._value is not None:
-            result["value"] = \
-                self._value
+        if self._addr is not None:
+            result["addr"] = \
+                self._addr
+        if self._instanceID is not None:
+            result["instanceID"] = \
+                self._instanceID
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/ecm/LabelsResponse.py` & `ngcbpc/data/model/CloudServiceProviderListResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,62 +7,63 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .Label import Label
+from .CloudServiceProvider import CloudServiceProvider
 from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
-str(repr(Label))
 str(repr(RequestStatus))
+str(repr(CloudServiceProvider))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class LabelsResponse(object):
-    """listing of labels"""
+class CloudServiceProviderListResponse(object):
+    """Response to list Cloud Service Providers request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.labels = (
+        self.cloudServiceProviders = (
             None if not fromDict or propDict.get(
-                "labels"
+                "cloudServiceProviders"
             ) is None
-            else [ Label(i)
-            for i in propDict["labels"] ])
+            else [ CloudServiceProvider(i)
+            for i in propDict["cloudServiceProviders"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def labels(self):
-        """list: array of labels object"""
-        return self._labels
+    def cloudServiceProviders(self):
+        """ """
+        return self._cloudServiceProviders
 
-    @labels.setter
-    def labels(self, value):
+    @cloudServiceProviders.setter
+    def cloudServiceProviders(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._labels = value
+            self._cloudServiceProviders = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<Label>" set to wrong type'
+                'Property "cloudServiceProviders" of type "list<CloudServiceP'
+                'rovider>" set to wrong type'
             )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
@@ -76,15 +77,15 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """ """
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -93,18 +94,18 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._labels:
-            result["labels"] = [
-                i.toDict() for i in self._labels 
-            ] if self._labels else []
+        if self._cloudServiceProviders:
+            result["cloudServiceProviders"] = [
+                i.toDict() for i in self._cloudServiceProviders 
+            ] if self._cloudServiceProviders else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -112,15 +113,15 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._labels is not None):
-            for obj in self._labels:
+        if (self._cloudServiceProviders is not None):
+            for obj in self._cloudServiceProviders:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Location.py` & `ngcbpc/data/model/Artifact.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,291 +6,286 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .TypeVersions import TypeVersions
-from .UpdateStatusEnum import UpdateStatusEnum
-from .LocationHealthEnum import LocationHealthEnum
-from .LocationStatusEnum import LocationStatusEnum
-from .Node import Node
-from .LocationAvailabilityEnum import LocationAvailabilityEnum
+from .AccessTypeEnum import AccessTypeEnum
+from .ProductNamesEnum import ProductNamesEnum
+from .ArtifactTypeEnum import ArtifactTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(Node))
-str(repr(LocationStatusEnum))
-str(repr(LocationAvailabilityEnum))
-str(repr(TypeVersions))
-str(repr(LocationHealthEnum))
-str(repr(UpdateStatusEnum))
+str(repr(ArtifactAttribute))
+str(repr(AccessTypeEnum))
+str(repr(ArtifactTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Location(object):
+class Artifact(object):
+    """Artifact object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.address = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "address"
+                "accessType"
             ) is None
-            else propDict["address"])
-        self.allowHighAvailability = (
+            else propDict["accessType"])
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "allowHighAvailability"
+                "artifactType"
             ) is None
-            else propDict["allowHighAvailability"])
-        self.argoCDEnabled = (
+            else propDict["artifactType"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "argoCDEnabled"
+                "attributes"
             ) is None
-            else propDict["argoCDEnabled"])
-        self.availability = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.bias = (
             None if not fromDict or propDict.get(
-                "availability"
+                "bias"
             ) is None
-            else propDict["availability"])
-        self.canBeDeleted = (
+            else propDict["bias"])
+        self.builtBy = (
             None if not fromDict or propDict.get(
-                "canBeDeleted"
+                "builtBy"
             ) is None
-            else propDict["canBeDeleted"])
-        self.creationTimestamp = (
+            else propDict["builtBy"])
+        self.canGuestDownload = (
             None if not fromDict or propDict.get(
-                "creationTimestamp"
+                "canGuestDownload"
             ) is None
-            else propDict["creationTimestamp"])
-        self.currentLocationHealth = (
+            else propDict["canGuestDownload"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "currentLocationHealth"
+                "createdDate"
             ) is None
-            else propDict["currentLocationHealth"])
-        self.currentVersion = (
-            None if not fromDict or propDict.get(
-                "currentVersion"
-            ) is None
-            else propDict["currentVersion"])
+            else propDict["createdDate"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
-        self.issues = (
+        self.explainability = (
+            None if not fromDict or propDict.get(
+                "explainability"
+            ) is None
+            else propDict["explainability"])
+        self.isFavourite = (
+            None if not fromDict or propDict.get(
+                "isFavourite"
+            ) is None
+            else propDict["isFavourite"])
+        self.isPublic = (
             None if not fromDict or propDict.get(
-                "issues"
+                "isPublic"
             ) is None
-            else propDict["issues"])
-        self.lastReportedStatus = (
+            else propDict["isPublic"])
+        self.isReadOnly = (
             None if not fromDict or propDict.get(
-                "lastReportedStatus"
+                "isReadOnly"
             ) is None
-            else propDict["lastReportedStatus"])
-        self.lastReportedStatusTime = (
+            else propDict["isReadOnly"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "lastReportedStatusTime"
+                "labels"
             ) is None
-            else propDict["lastReportedStatusTime"])
-        self.lastUpdatedTimestamp = (
+            else propDict["labels"])
+        self.latestVersionId = (
             None if not fromDict or propDict.get(
-                "lastUpdatedTimestamp"
+                "latestVersionId"
             ) is None
-            else propDict["lastUpdatedTimestamp"])
-        self.logsUrl = (
+            else propDict["latestVersionId"])
+        self.latestVersionSizeInBytes = (
             None if not fromDict or propDict.get(
-                "logsUrl"
+                "latestVersionSizeInBytes"
             ) is None
-            else propDict["logsUrl"])
-        self.messages = (
+            else propDict["latestVersionSizeInBytes"])
+        self.logo = (
             None if not fromDict or propDict.get(
-                "messages"
+                "logo"
             ) is None
-            else propDict["messages"])
+            else propDict["logo"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.nextAvailableCustomVersions = (
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "nextAvailableCustomVersions"
+                "orgName"
             ) is None
-            else [ TypeVersions(i)
-            for i in propDict["nextAvailableCustomVersions"] ])
-        self.nextAvailableVersions = (
+            else propDict["orgName"])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "nextAvailableVersions"
+                "ownerName"
             ) is None
-            else propDict["nextAvailableVersions"])
-        self.nodes = (
+            else propDict["ownerName"])
+        self.privacy = (
             None if not fromDict or propDict.get(
-                "nodes"
+                "privacy"
             ) is None
-            else [ Node(i)
-            for i in propDict["nodes"] ])
-        self.signedContainersEnabled = (
+            else propDict["privacy"])
+        self.productNames = (
             None if not fromDict or propDict.get(
-                "signedContainersEnabled"
+                "productNames"
             ) is None
-            else propDict["signedContainersEnabled"])
-        self.status = (
+            else propDict["productNames"])
+        self.publisher = (
             None if not fromDict or propDict.get(
-                "status"
+                "publisher"
             ) is None
-            else propDict["status"])
-        self.updateStatus = (
+            else propDict["publisher"])
+        self.safetyAndSecurity = (
             None if not fromDict or propDict.get(
-                "updateStatus"
+                "safetyAndSecurity"
             ) is None
-            else propDict["updateStatus"])
-
-    @property
-    def address(self):
-        """str: Address of the location"""
-        return self._address
-
-    @address.setter
-    def address(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._address = value
-        else:
-            raise TypeError(
-                'Property "address" of type "list<str>" set to wrong type'
-            )
+            else propDict["safetyAndSecurity"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
+        self.teamName = (
+            None if not fromDict or propDict.get(
+                "teamName"
+            ) is None
+            else propDict["teamName"])
+        self.updatedDate = (
+            None if not fromDict or propDict.get(
+                "updatedDate"
+            ) is None
+            else propDict["updatedDate"])
 
     @property
-    def allowHighAvailability(self):
-        """bool: Location is HA or not"""
-        return self._allowHighAvailability
+    def accessType(self):
+        """ """
+        return self._accessType
 
-    @allowHighAvailability.setter
-    def allowHighAvailability(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowHighAvailability = value
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
         else:
             raise TypeError(
-                'Property "allowHighAvailability" of type "list<bool>" set to'
-                ' wrong type'
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def argoCDEnabled(self):
-        """bool: Location has ArgoCD deployments enabled or not"""
-        return self._argoCDEnabled
+    def artifactType(self):
+        """ArtifactTypeEnum: Artifact type"""
+        return self._artifactType
 
-    @argoCDEnabled.setter
-    def argoCDEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._argoCDEnabled = value
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "argoCDEnabled" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def availability(self):
-        """LocationAvailabilityEnum: All possible values for location availabi
-        lity"""
-        return self._availability
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
 
-    @availability.setter
-    def availability(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._availability = value
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "availability" of type "list<LocationAvailabilityEn'
-                'um>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def canBeDeleted(self):
-        """bool: Location cannot be used in deployment and can not have system
-        s/nodes"""
-        return self._canBeDeleted
+    def bias(self):
+        """str: Text describing bias in the artifact"""
+        return self._bias
 
-    @canBeDeleted.setter
-    def canBeDeleted(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canBeDeleted = value
+    @bias.setter
+    def bias(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._bias = value
         else:
             raise TypeError(
-                'Property "canBeDeleted" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "bias" of type "list<str>" set to wrong type'
             )
 
     @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
+    def builtBy(self):
+        """str: Organization that built the helm chart"""
+        return self._builtBy
 
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
+    @builtBy.setter
+    def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
+            self._builtBy = value
         else:
             raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
+                'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def currentLocationHealth(self):
-        """LocationHealthEnum: All possible location health enums"""
-        return self._currentLocationHealth
+    def canGuestDownload(self):
+        """bool: Indicates if a guest user can download"""
+        return self._canGuestDownload
 
-    @currentLocationHealth.setter
-    def currentLocationHealth(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._currentLocationHealth = value
+    @canGuestDownload.setter
+    def canGuestDownload(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canGuestDownload = value
         else:
             raise TypeError(
-                'Property "currentLocationHealth" of type "list<LocationHealt'
-                'hEnum>" set to wrong type'
+                'Property "canGuestDownload" of type "list<bool>" set to wron'
+                'g type'
             )
 
     @property
-    def currentVersion(self):
-        """ """
-        return self._currentVersion
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @currentVersion.setter
-    def currentVersion(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._currentVersion = value
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "currentVersion" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the location"""
+        """str: Description of the helm chart"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -298,343 +293,433 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """str: Display name of the location"""
+        """str: Display name"""
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def issues(self):
-        """list: Issues to show in the banner"""
-        return self._issues
+    def explainability(self):
+        """str: Text describing the explainability for this artifact"""
+        return self._explainability
+
+    @explainability.setter
+    def explainability(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._explainability = value
+        else:
+            raise TypeError(
+                'Property "explainability" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def isFavourite(self):
+        """bool: Flag indicating if helm chart is user's favorite"""
+        return self._isFavourite
+
+    @isFavourite.setter
+    def isFavourite(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isFavourite = value
+        else:
+            raise TypeError(
+                'Property "isFavourite" of type "list<bool>" set to wrong typ'
+                'e'
+            )
+
+    @property
+    def isPublic(self):
+        """bool: Determines if this helm chart is publicly accessible"""
+        return self._isPublic
+
+    @isPublic.setter
+    def isPublic(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isPublic = value
+        else:
+            raise TypeError(
+                'Property "isPublic" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def isReadOnly(self):
+        """bool: indicate if current user has read only permissions"""
+        return self._isReadOnly
+
+    @isReadOnly.setter
+    def isReadOnly(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isReadOnly = value
+        else:
+            raise TypeError(
+                'Property "isReadOnly" of type "list<bool>" set to wrong type'
+            )
+
+    @property
+    def labels(self):
+        """ """
+        return self._labels
 
-    @issues.setter
-    def issues(self, value):
+    @labels.setter
+    def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._issues = value
+            self._labels = value
         else:
             raise TypeError(
-                'Property "issues" of type "list<str>" set to wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def lastReportedStatus(self):
-        """LocationStatusEnum: All possible location status enums"""
-        return self._lastReportedStatus
+    def latestVersionId(self):
+        """str: ID of the latest version"""
+        return self._latestVersionId
 
-    @lastReportedStatus.setter
-    def lastReportedStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._lastReportedStatus = value
+    @latestVersionId.setter
+    def latestVersionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._latestVersionId = value
         else:
             raise TypeError(
-                'Property "lastReportedStatus" of type "list<LocationStatusEn'
-                'um>" set to wrong type'
+                'Property "latestVersionId" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def lastReportedStatusTime(self):
-        """ """
-        return self._lastReportedStatusTime
+    def latestVersionSizeInBytes(self):
+        """long: Size of the latest version in bytes"""
+        return self._latestVersionSizeInBytes
+
+    @latestVersionSizeInBytes.setter
+    def latestVersionSizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._latestVersionSizeInBytes = value
+        else:
+            raise TypeError(
+                'Property "latestVersionSizeInBytes" of type "list<long>" set'
+                ' to wrong type'
+            )
 
-    @lastReportedStatusTime.setter
-    def lastReportedStatusTime(self, value):
+    @property
+    def logo(self):
+        """str: URL for the logo image"""
+        return self._logo
+
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastReportedStatusTime = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "lastReportedStatusTime" of type "list<str>" set to'
-                ' wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def lastUpdatedTimestamp(self):
-        """ """
-        return self._lastUpdatedTimestamp
+    def name(self):
+        """str: Unique name of the helm chart"""
+        return self._name
 
-    @lastUpdatedTimestamp.setter
-    def lastUpdatedTimestamp(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastUpdatedTimestamp = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "lastUpdatedTimestamp" of type "list<str>" set to w'
-                'rong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logsUrl(self):
-        """str: Logs url for location"""
-        return self._logsUrl
+    def orgName(self):
+        """str: Name of the org that the helm chart belongs to"""
+        return self._orgName
 
-    @logsUrl.setter
-    def logsUrl(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logsUrl = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "logsUrl" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def messages(self):
-        """list: Messages to show in the banner"""
-        return self._messages
+    def ownerName(self):
+        """str: Name of the user who owns this version"""
+        return self._ownerName
 
-    @messages.setter
-    def messages(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._messages = value
+    @ownerName.setter
+    def ownerName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "messages" of type "list<str>" set to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the location"""
-        return self._name
+    def privacy(self):
+        """str: Text describing the privacy for this artifact"""
+        return self._privacy
 
-    @name.setter
-    def name(self, value):
+    @privacy.setter
+    def privacy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._privacy = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "privacy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nextAvailableCustomVersions(self):
-        """list: Next available system versions based on type"""
-        return self._nextAvailableCustomVersions
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
 
-    @nextAvailableCustomVersions.setter
-    def nextAvailableCustomVersions(self, value):
+    @productNames.setter
+    def productNames(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._nextAvailableCustomVersions = value
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "nextAvailableCustomVersions" of type "list<TypeVer'
-                'sions>" set to wrong type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def nextAvailableVersions(self):
-        """list: Next available versions in the location"""
-        return self._nextAvailableVersions
+    def publisher(self):
+        """str: Organization that published this helm chart"""
+        return self._publisher
 
-    @nextAvailableVersions.setter
-    def nextAvailableVersions(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._nextAvailableVersions = value
+    @publisher.setter
+    def publisher(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisher = value
         else:
             raise TypeError(
-                'Property "nextAvailableVersions" of type "list<str>" set to '
-                'wrong type'
+                'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nodes(self):
-        """list: array of nodes that in the location"""
-        return self._nodes
+    def safetyAndSecurity(self):
+        """str: Text for describing the safety and security in the artifact"""
+        return self._safetyAndSecurity
 
-    @nodes.setter
-    def nodes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._nodes = value
+    @safetyAndSecurity.setter
+    def safetyAndSecurity(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._safetyAndSecurity = value
         else:
             raise TypeError(
-                'Property "nodes" of type "list<Node>" set to wrong type'
+                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def signedContainersEnabled(self):
-        """bool: Location has signed containers required or not"""
-        return self._signedContainersEnabled
+    def shortDescription(self):
+        """str: Short description of the helm chart"""
+        return self._shortDescription
 
-    @signedContainersEnabled.setter
-    def signedContainersEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._signedContainersEnabled = value
+    @shortDescription.setter
+    def shortDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "signedContainersEnabled" of type "list<bool>" set '
-                'to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def status(self):
-        """LocationStatusEnum: All possible location status enums"""
-        return self._status
+    def teamName(self):
+        """str: Name of the team that the helm chart belongs to"""
+        return self._teamName
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @teamName.setter
+    def teamName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "status" of type "list<LocationStatusEnum>" set to '
-                'wrong type'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def updateStatus(self):
-        """UpdateStatusEnum: All possible update status enums"""
-        return self._updateStatus
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
 
-    @updateStatus.setter
-    def updateStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._updateStatus = value
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "updateStatus" of type "list<UpdateStatusEnum>" set'
-                ' to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._address is not None:
-            result["address"] = \
-                self._address
-        if self._allowHighAvailability is not None:
-            result["allowHighAvailability"] = \
-                self._allowHighAvailability
-        if self._argoCDEnabled is not None:
-            result["argoCDEnabled"] = \
-                self._argoCDEnabled
-        if self._availability is not None:
-            result["availability"] = \
-                self._availability
-        if self._canBeDeleted is not None:
-            result["canBeDeleted"] = \
-                self._canBeDeleted
-        if self._creationTimestamp is not None:
-            result["creationTimestamp"] = \
-                self._creationTimestamp
-        if self._currentLocationHealth is not None:
-            result["currentLocationHealth"] = \
-                self._currentLocationHealth
-        if self._currentVersion is not None:
-            result["currentVersion"] = \
-                self._currentVersion
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._bias is not None:
+            result["bias"] = \
+                self._bias
+        if self._builtBy is not None:
+            result["builtBy"] = \
+                self._builtBy
+        if self._canGuestDownload is not None:
+            result["canGuestDownload"] = \
+                self._canGuestDownload
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._issues is not None:
-            result["issues"] = \
-                self._issues
-        if self._lastReportedStatus is not None:
-            result["lastReportedStatus"] = \
-                self._lastReportedStatus
-        if self._lastReportedStatusTime is not None:
-            result["lastReportedStatusTime"] = \
-                self._lastReportedStatusTime
-        if self._lastUpdatedTimestamp is not None:
-            result["lastUpdatedTimestamp"] = \
-                self._lastUpdatedTimestamp
-        if self._logsUrl is not None:
-            result["logsUrl"] = \
-                self._logsUrl
-        if self._messages is not None:
-            result["messages"] = \
-                self._messages
+        if self._explainability is not None:
+            result["explainability"] = \
+                self._explainability
+        if self._isFavourite is not None:
+            result["isFavourite"] = \
+                self._isFavourite
+        if self._isPublic is not None:
+            result["isPublic"] = \
+                self._isPublic
+        if self._isReadOnly is not None:
+            result["isReadOnly"] = \
+                self._isReadOnly
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
+        if self._latestVersionId is not None:
+            result["latestVersionId"] = \
+                self._latestVersionId
+        if self._latestVersionSizeInBytes is not None:
+            result["latestVersionSizeInBytes"] = \
+                self._latestVersionSizeInBytes
+        if self._logo is not None:
+            result["logo"] = \
+                self._logo
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._nextAvailableCustomVersions:
-            result["nextAvailableCustomVersions"] = [
-                i.toDict() for i in self._nextAvailableCustomVersions 
-            ] if self._nextAvailableCustomVersions else []
-        if self._nextAvailableVersions is not None:
-            result["nextAvailableVersions"] = \
-                self._nextAvailableVersions
-        if self._nodes:
-            result["nodes"] = [
-                i.toDict() for i in self._nodes 
-            ] if self._nodes else []
-        if self._signedContainersEnabled is not None:
-            result["signedContainersEnabled"] = \
-                self._signedContainersEnabled
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._updateStatus is not None:
-            result["updateStatus"] = \
-                self._updateStatus
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._privacy is not None:
+            result["privacy"] = \
+                self._privacy
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
+        if self._publisher is not None:
+            result["publisher"] = \
+                self._publisher
+        if self._safetyAndSecurity is not None:
+            result["safetyAndSecurity"] = \
+                self._safetyAndSecurity
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) > 53):
-            raise ValueError(
-                "Location.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
+        if (self._createdDate is not None
             and
             not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "Location.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._displayName is not None
+                "Artifact.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
             and
-            len(self._displayName) > 255):
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
             raise ValueError(
-                "Location.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._nodes is not None):
-            for obj in self._nodes:
-                if (obj is not None): obj.isValid()
-        if (self._nextAvailableCustomVersions is not None):
-            for obj in self._nextAvailableCustomVersions:
+                "Artifact.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._attributes is not None):
+            for obj in self._attributes:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/LocationResponse.py` & `organization/data/subscription_management_service/RequestCreateSubscriptionResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,56 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Location import Location
+from .SubscriptionRequest import SubscriptionRequest
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Location))
+str(repr(SubscriptionRequest))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class LocationResponse(object):
+class RequestCreateSubscriptionResponse(object):
+    """Response of request to create subscriptions API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.location = (
-            None if not fromDict or propDict.get(
-                "location"
-            ) is None
-            else propDict["location"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def location(self):
-        """ """
-        return self._location
-
-    @location.setter
-    def location(self, value):
-        if value is not None and not isinstance(value, Location):
-            value = Location(value)
-        if (value is None) or isinstance(value, Location):
-            self._location = value
-        else:
-            raise TypeError(
-                'Property "location" of type "list<Location>" set to wrong ty'
-                'pe'
-            )
+        self.subscriptionRequest = (
+            None if not fromDict or propDict.get(
+                "subscriptionRequest"
+            ) is None
+            else propDict["subscriptionRequest"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -66,29 +50,46 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscriptionRequest(self):
+        """ """
+        return self._subscriptionRequest
+
+    @subscriptionRequest.setter
+    def subscriptionRequest(self, value):
+        if value is not None and not isinstance(value, SubscriptionRequest):
+            value = SubscriptionRequest(value)
+        if (value is None) or isinstance(value, SubscriptionRequest):
+            self._subscriptionRequest = value
+        else:
+            raise TypeError(
+                'Property "subscriptionRequest" of type "list<SubscriptionReq'
+                'uest>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._location:
-            result["location"] = \
-                self._location.toDict() if self._location is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptionRequest:
+            result["subscriptionRequest"] = \
+                self._subscriptionRequest.toDict() if self._subscriptionRequest is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._location is not None): self._location.isValid()
+        if (self._subscriptionRequest is not None): self._subscriptionRequest.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/LocationsResponse.py` & `ngcbpc/data/uis/RequestStatus.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,122 +6,132 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
-from .Location import Location
-from .PaginationInfo import PaginationInfo
+from .StatusCode import StatusCodeEnum
 
 # Unused import over optimization prevention
-str(repr(Location))
-str(repr(PaginationInfo))
-str(repr(RequestStatus))
+str(repr(StatusCodeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class LocationsResponse(object):
+class RequestStatus(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.locations = (
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "locations"
+                "requestId"
             ) is None
-            else [ Location(i)
-            for i in propDict["locations"] ])
-        self.paginationInfo = (
+            else propDict["requestId"])
+        self.serverId = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "serverId"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["serverId"])
+        self.statusCode = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "statusCode"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["statusCode"])
+        self.statusDescription = (
+            None if not fromDict or propDict.get(
+                "statusDescription"
+            ) is None
+            else propDict["statusDescription"])
 
     @property
-    def locations(self):
-        """list: array of locations object that describes locations, nodes and
-         updates"""
-        return self._locations
-
-    @locations.setter
-    def locations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._locations = value
+    def requestId(self):
+        """ """
+        return self._requestId
+
+    @requestId.setter
+    def requestId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._requestId = value
+        else:
+            raise TypeError(
+                'Property "requestId" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def serverId(self):
+        """ """
+        return self._serverId
+
+    @serverId.setter
+    def serverId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._serverId = value
         else:
             raise TypeError(
-                'Property "locations" of type "list<Location>" set to wrong t'
-                'ype'
+                'Property "serverId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def statusCode(self):
+        """StatusCodeEnum: Describes response status reported by the server.
+        """
+        return self._statusCode
+
+    @statusCode.setter
+    def statusCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._statusCode = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "statusCode" of type "list<StatusCodeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def statusDescription(self):
         """ """
-        return self._requestStatus
+        return self._statusDescription
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @statusDescription.setter
+    def statusDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._statusDescription = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "statusDescription" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._locations:
-            result["locations"] = [
-                i.toDict() for i in self._locations 
-            ] if self._locations else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._serverId is not None:
+            result["serverId"] = \
+                self._serverId
+        if self._statusCode is not None:
+            result["statusCode"] = \
+                self._statusCode
+        if self._statusDescription is not None:
+            result["statusDescription"] = \
+                self._statusDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._locations is not None):
-            for obj in self._locations:
-                if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Log.py` & `ngcbpc/data/registry/ManifestV2Config.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,115 +6,106 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .MetaData import MetaData
 
 # Unused import over optimization prevention
-str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Log(object):
-    """Log object includes log message, timestamp and a list of key-value pair
-    s (log details)"""
+class ManifestV2Config(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.logDetails = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "logDetails"
+                "digest"
             ) is None
-            else [ MetaData(i)
-            for i in propDict["logDetails"] ])
-        self.logMessage = (
+            else propDict["digest"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "logMessage"
+                "mediaType"
             ) is None
-            else propDict["logMessage"])
-        self.timestamp = (
+            else propDict["mediaType"])
+        self.size = (
             None if not fromDict or propDict.get(
-                "timestamp"
+                "size"
             ) is None
-            else propDict["timestamp"])
+            else propDict["size"])
 
     @property
-    def logDetails(self):
-        """list: A list of key value pairs to show log detail"""
-        return self._logDetails
-
-    @logDetails.setter
-    def logDetails(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._logDetails = value
+    def digest(self):
+        """str: Images sha256 digest"""
+        return self._digest
+
+    @digest.setter
+    def digest(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._digest = value
         else:
             raise TypeError(
-                'Property "logDetails" of type "list<MetaData>" set to wrong '
-                'type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logMessage(self):
-        """str: Log message"""
-        return self._logMessage
+    def mediaType(self):
+        """str: should point to v1 manifest type, 'application/vnd.docker.cont
+        ainer.image.v1+json'"""
+        return self._mediaType
 
-    @logMessage.setter
-    def logMessage(self, value):
+    @mediaType.setter
+    def mediaType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logMessage = value
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "logMessage" of type "list<str>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def timestamp(self):
-        """str: Log timestamp"""
-        return self._timestamp
-
-    @timestamp.setter
-    def timestamp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._timestamp = value
+    def size(self):
+        """long: Manifest size, bytes"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
         else:
             raise TypeError(
-                'Property "timestamp" of type "list<str>" set to wrong type'
+                'Property "size" of type "list<long>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._logDetails:
-            result["logDetails"] = [
-                i.toDict() for i in self._logDetails 
-            ] if self._logDetails else []
-        if self._logMessage is not None:
-            result["logMessage"] = \
-                self._logMessage
-        if self._timestamp is not None:
-            result["timestamp"] = \
-                self._timestamp
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._size is not None:
+            result["size"] = \
+                self._size
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._logDetails is not None):
-            for obj in self._logDetails:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/LogsResponse.py` & `ngcbpc/data/model/RecipeVersionListResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,65 +7,56 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .Log import Log
+from .RecipeVersion import RecipeVersion
+from .Recipe import Recipe
 from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
+str(repr(Recipe))
+str(repr(RecipeVersion))
 str(repr(RequestStatus))
-str(repr(Log))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class LogsResponse(object):
-    """Log details with query applied"""
+class RecipeVersionListResponse(object):
+    """Response to list recipe versions request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.logEntries = (
-            None if not fromDict or propDict.get(
-                "logEntries"
-            ) is None
-            else [ Log(i)
-            for i in propDict["logEntries"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
+        self.recipe = (
+            None if not fromDict or propDict.get(
+                "recipe"
+            ) is None
+            else propDict["recipe"])
+        self.recipeVersions = (
+            None if not fromDict or propDict.get(
+                "recipeVersions"
+            ) is None
+            else [ RecipeVersion(i)
+            for i in propDict["recipeVersions"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def logEntries(self):
-        """list: array of log object"""
-        return self._logEntries
-
-    @logEntries.setter
-    def logEntries(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._logEntries = value
-        else:
-            raise TypeError(
-                'Property "logEntries" of type "list<Log>" set to wrong type'
-            )
-
-    @property
     def paginationInfo(self):
         """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
@@ -75,16 +66,49 @@
         else:
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def recipe(self):
+        """Recipe: Recipe object"""
+        return self._recipe
+
+    @recipe.setter
+    def recipe(self, value):
+        if value is not None and not isinstance(value, Recipe):
+            value = Recipe(value)
+        if (value is None) or isinstance(value, Recipe):
+            self._recipe = value
+        else:
+            raise TypeError(
+                'Property "recipe" of type "list<Recipe>" set to wrong type'
+            )
+
+    @property
+    def recipeVersions(self):
         """ """
+        return self._recipeVersions
+
+    @recipeVersions.setter
+    def recipeVersions(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._recipeVersions = value
+        else:
+            raise TypeError(
+                'Property "recipeVersions" of type "list<RecipeVersion>" set '
+                'to wrong type'
+            )
+
+    @property
+    def requestStatus(self):
+        """RequestStatus: Request status information"""
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -93,34 +117,38 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._logEntries:
-            result["logEntries"] = [
-                i.toDict() for i in self._logEntries 
-            ] if self._logEntries else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._recipe:
+            result["recipe"] = \
+                self._recipe.toDict() if self._recipe is not None else None
+        if self._recipeVersions:
+            result["recipeVersions"] = [
+                i.toDict() for i in self._recipeVersions 
+            ] if self._recipeVersions else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._logEntries is not None):
-            for obj in self._logEntries:
+        if (self._recipe is not None): self._recipe.isValid()
+        if (self._recipeVersions is not None):
+            for obj in self._recipeVersions:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ManagedGpus.py` & `basecommand/data/pym/Dataset.py`

 * *Files 14% similar despite different names*

```diff
@@ -14,73 +14,90 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ManagedGpus(object):
+class Dataset(object):
+    """Dataset mount"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.count = (
+        self.id = (
             None if not fromDict or propDict.get(
-                "count"
+                "id"
             ) is None
-            else propDict["count"])
-        self.gpuType = (
+            else propDict["id"])
+        self.mountPoint = (
             None if not fromDict or propDict.get(
-                "gpuType"
+                "mountPoint"
             ) is None
-            else propDict["gpuType"])
+            else propDict["mountPoint"])
 
     @property
-    def count(self):
-        """int: GPU count for the GPU type"""
-        return self._count
-
-    @count.setter
-    def count(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._count = value
+    def id(self):
+        """long: Dataset id"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
         else:
             raise TypeError(
-                'Property "count" of type "list<int>" set to wrong type'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
-    def gpuType(self):
-        """str: GPU type"""
-        return self._gpuType
+    def mountPoint(self):
+        """str: Dataset mount point"""
+        return self._mountPoint
 
-    @gpuType.setter
-    def gpuType(self, value):
+    @mountPoint.setter
+    def mountPoint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuType = value
+            self._mountPoint = value
         else:
             raise TypeError(
-                'Property "gpuType" of type "list<str>" set to wrong type'
+                'Property "mountPoint" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._count is not None:
-            result["count"] = \
-                self._count
-        if self._gpuType is not None:
-            result["gpuType"] = \
-                self._gpuType
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._mountPoint is not None:
+            result["mountPoint"] = \
+                self._mountPoint
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._id is None:
+            raise ValueError(
+                "Dataset.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._mountPoint is None:
+            raise ValueError(
+                "Dataset.mountPoint doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._mountPoint is not None
+            and
+            len(self._mountPoint) < 1):
+            raise ValueError(
+                "Dataset.mountPoint: " + str(self._mountPoint) + 
+                " doesnt match requirement: minLength: 1")
         return True
```

## Comparing `ngccli/data/ecm/MetaData.py` & `ngcbpc/data/registry/ImageRef.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,42 +14,43 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MetaData(object):
+class ImageRef(object):
+    """A reference to an image"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.key = (
+        self.type = (
             None if not fromDict or propDict.get(
-                "key"
+                "type"
             ) is None
-            else propDict["key"])
+            else propDict["type"])
         self.value = (
             None if not fromDict or propDict.get(
                 "value"
             ) is None
             else propDict["value"])
 
     @property
-    def key(self):
+    def type(self):
         """ """
-        return self._key
+        return self._type
 
-    @key.setter
-    def key(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._key = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "key" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     @property
     def value(self):
         """ """
         return self._value
 
@@ -62,17 +63,17 @@
         else:
             raise TypeError(
                 'Property "value" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._key is not None:
-            result["key"] = \
-                self._key
+        if self._type is not None:
+            result["type"] = \
+                self._type
         if self._value is not None:
             result["value"] = \
                 self._value
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
```

## Comparing `ngccli/data/ecm/MetricQueryResponse.py` & `organization/data/subscription_management_service/Pricing.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,303 +6,231 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
+from .PriceFormatEnum import PriceFormatEnum
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
+str(repr(PriceFormatEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MetricQueryResponse(object):
+class Pricing(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.bucket = (
+        self.currency = (
             None if not fromDict or propDict.get(
-                "bucket"
+                "currency"
             ) is None
-            else propDict["bucket"])
-        self.field = (
+            else propDict["currency"])
+        self.discountAmount = (
             None if not fromDict or propDict.get(
-                "field"
+                "discountAmount"
             ) is None
-            else propDict["field"])
-        self.first = (
+            else propDict["discountAmount"])
+        self.discountPercentage = (
             None if not fromDict or propDict.get(
-                "first"
+                "discountPercentage"
             ) is None
-            else propDict["first"])
-        self.last = (
+            else propDict["discountPercentage"])
+        self.endingUnit = (
             None if not fromDict or propDict.get(
-                "last"
+                "endingUnit"
             ) is None
-            else propDict["last"])
-        self.locationName = (
+            else propDict["endingUnit"])
+        self.overagePrice = (
             None if not fromDict or propDict.get(
-                "locationName"
+                "overagePrice"
             ) is None
-            else propDict["locationName"])
-        self.maximum = (
+            else propDict["overagePrice"])
+        self.price = (
             None if not fromDict or propDict.get(
-                "maximum"
+                "price"
             ) is None
-            else propDict["maximum"])
-        self.mean = (
+            else propDict["price"])
+        self.priceFormat = (
             None if not fromDict or propDict.get(
-                "mean"
+                "priceFormat"
             ) is None
-            else propDict["mean"])
-        self.metric = (
+            else propDict["priceFormat"])
+        self.startingUnit = (
             None if not fromDict or propDict.get(
-                "metric"
+                "startingUnit"
             ) is None
-            else propDict["metric"])
-        self.minimum = (
-            None if not fromDict or propDict.get(
-                "minimum"
-            ) is None
-            else propDict["minimum"])
-        self.ninetyFivePercentile = (
-            None if not fromDict or propDict.get(
-                "ninetyFivePercentile"
-            ) is None
-            else propDict["ninetyFivePercentile"])
-        self.requestStatus = (
-            None if not fromDict or propDict.get(
-                "requestStatus"
-            ) is None
-            else propDict["requestStatus"])
-
-    @property
-    def bucket(self):
-        """str: Name of the bucket"""
-        return self._bucket
-
-    @bucket.setter
-    def bucket(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._bucket = value
-        else:
-            raise TypeError(
-                'Property "bucket" of type "list<str>" set to wrong type'
-            )
+            else propDict["startingUnit"])
 
     @property
-    def field(self):
-        """str: Value of the field"""
-        return self._field
+    def currency(self):
+        """str: the currency that the price is displayed in"""
+        return self._currency
 
-    @field.setter
-    def field(self, value):
+    @currency.setter
+    def currency(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._field = value
+            self._currency = value
         else:
             raise TypeError(
-                'Property "field" of type "list<str>" set to wrong type'
+                'Property "currency" of type "list<str>" set to wrong type'
             )
 
     @property
-    def first(self):
-        """str: First value of the metric in the range"""
-        return self._first
+    def discountAmount(self):
+        """float: the amount discounted from the price"""
+        return self._discountAmount
 
-    @first.setter
-    def first(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._first = value
+    @discountAmount.setter
+    def discountAmount(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._discountAmount = value
         else:
             raise TypeError(
-                'Property "first" of type "list<str>" set to wrong type'
+                'Property "discountAmount" of type "list<float>" set to wrong'
+                ' type'
             )
 
     @property
-    def last(self):
-        """str: Last value of the metric in the range"""
-        return self._last
+    def discountPercentage(self):
+        """float: the percentage discount on the price"""
+        return self._discountPercentage
 
-    @last.setter
-    def last(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._last = value
+    @discountPercentage.setter
+    def discountPercentage(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._discountPercentage = value
         else:
             raise TypeError(
-                'Property "last" of type "list<str>" set to wrong type'
+                'Property "discountPercentage" of type "list<float>" set to w'
+                'rong type'
             )
 
     @property
-    def locationName(self):
-        """str: Name of the location"""
-        return self._locationName
-
-    @locationName.setter
-    def locationName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._locationName = value
+    def endingUnit(self):
+        """float: the ending unit of the price"""
+        return self._endingUnit
+
+    @endingUnit.setter
+    def endingUnit(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._endingUnit = value
         else:
             raise TypeError(
-                'Property "locationName" of type "list<str>" set to wrong typ'
+                'Property "endingUnit" of type "list<float>" set to wrong typ'
                 'e'
             )
 
     @property
-    def maximum(self):
-        """str: maximum value of the metric in the range"""
-        return self._maximum
-
-    @maximum.setter
-    def maximum(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._maximum = value
-        else:
-            raise TypeError(
-                'Property "maximum" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def mean(self):
-        """str: mean value of the metric in the range"""
-        return self._mean
-
-    @mean.setter
-    def mean(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._mean = value
-        else:
-            raise TypeError(
-                'Property "mean" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def metric(self):
-        """str: Name of the metric"""
-        return self._metric
+    def overagePrice(self):
+        """float: the overage price being charged"""
+        return self._overagePrice
 
-    @metric.setter
-    def metric(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._metric = value
+    @overagePrice.setter
+    def overagePrice(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._overagePrice = value
         else:
             raise TypeError(
-                'Property "metric" of type "list<str>" set to wrong type'
+                'Property "overagePrice" of type "list<float>" set to wrong t'
+                'ype'
             )
 
     @property
-    def minimum(self):
-        """str: Minimum value of the metric in the range"""
-        return self._minimum
+    def price(self):
+        """float: the price being charged"""
+        return self._price
 
-    @minimum.setter
-    def minimum(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._minimum = value
+    @price.setter
+    def price(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._price = value
         else:
             raise TypeError(
-                'Property "minimum" of type "list<str>" set to wrong type'
+                'Property "price" of type "list<float>" set to wrong type'
             )
 
     @property
-    def ninetyFivePercentile(self):
-        """str: ninetyFivePercentile value of the metric in the range"""
-        return self._ninetyFivePercentile
+    def priceFormat(self):
+        """PriceFormatEnum: All possible price format types"""
+        return self._priceFormat
 
-    @ninetyFivePercentile.setter
-    def ninetyFivePercentile(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._ninetyFivePercentile = value
+    @priceFormat.setter
+    def priceFormat(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._priceFormat = value
         else:
             raise TypeError(
-                'Property "ninetyFivePercentile" of type "list<str>" set to w'
-                'rong type'
+                'Property "priceFormat" of type "list<PriceFormatEnum>" set t'
+                'o wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def startingUnit(self):
+        """float: the starting unit of the price"""
+        return self._startingUnit
+
+    @startingUnit.setter
+    def startingUnit(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._startingUnit = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "startingUnit" of type "list<float>" set to wrong t'
+                'ype'
             )
 
     def toDict(self):
         result = {}
-        if self._bucket is not None:
-            result["bucket"] = \
-                self._bucket
-        if self._field is not None:
-            result["field"] = \
-                self._field
-        if self._first is not None:
-            result["first"] = \
-                self._first
-        if self._last is not None:
-            result["last"] = \
-                self._last
-        if self._locationName is not None:
-            result["locationName"] = \
-                self._locationName
-        if self._maximum is not None:
-            result["maximum"] = \
-                self._maximum
-        if self._mean is not None:
-            result["mean"] = \
-                self._mean
-        if self._metric is not None:
-            result["metric"] = \
-                self._metric
-        if self._minimum is not None:
-            result["minimum"] = \
-                self._minimum
-        if self._ninetyFivePercentile is not None:
-            result["ninetyFivePercentile"] = \
-                self._ninetyFivePercentile
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._currency is not None:
+            result["currency"] = \
+                self._currency
+        if self._discountAmount is not None:
+            result["discountAmount"] = \
+                self._discountAmount
+        if self._discountPercentage is not None:
+            result["discountPercentage"] = \
+                self._discountPercentage
+        if self._endingUnit is not None:
+            result["endingUnit"] = \
+                self._endingUnit
+        if self._overagePrice is not None:
+            result["overagePrice"] = \
+                self._overagePrice
+        if self._price is not None:
+            result["price"] = \
+                self._price
+        if self._priceFormat is not None:
+            result["priceFormat"] = \
+                self._priceFormat
+        if self._startingUnit is not None:
+            result["startingUnit"] = \
+                self._startingUnit
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/Metrics.py` & `ngcbpc/data/uis/NvcfOrgUpdateRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,81 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .NvcfCluster import NvcfCluster
 
 # Unused import over optimization prevention
+str(repr(NvcfCluster))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Metrics(object):
+class NvcfOrgUpdateRequest(object):
+    """NVCF Organization Configuration Update Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.fields = (
+        self.clusters = (
             None if not fromDict or propDict.get(
-                "fields"
+                "clusters"
             ) is None
-            else propDict["fields"])
-        self.name = (
-            None if not fromDict or propDict.get(
-                "name"
-            ) is None
-            else propDict["name"])
+            else [ NvcfCluster(i)
+            for i in propDict["clusters"] ])
 
     @property
-    def fields(self):
-        """list: List of fields in the metric"""
-        return self._fields
+    def clusters(self):
+        """ """
+        return self._clusters
 
-    @fields.setter
-    def fields(self, value):
+    @clusters.setter
+    def clusters(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._fields = value
-        else:
-            raise TypeError(
-                'Property "fields" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def name(self):
-        """str: Name of the metric"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._clusters = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "clusters" of type "list<NvcfCluster>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._fields is not None:
-            result["fields"] = \
-                self._fields
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._clusters:
+            result["clusters"] = [
+                i.toDict() for i in self._clusters 
+            ] if self._clusters else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._clusters is not None):
+            for obj in self._clusters:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/MetricsBucketsResponse.py` & `basecommand/data/pym/ProjectTemplateSuccessResponse.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,85 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
+from .ProjectTemplateRequestStatus import ProjectTemplateRequestStatus
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
+str(repr(ProjectTemplateRequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MetricsBucketsResponse(object):
+class ProjectTemplateSuccessResponse(object):
+    """Project Template Success Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.buckets = (
+        self.templateStatus = (
             None if not fromDict or propDict.get(
-                "buckets"
+                "templateStatus"
             ) is None
-            else propDict["buckets"])
-        self.requestStatus = (
+            else propDict["templateStatus"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "version"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["version"])
 
     @property
-    def buckets(self):
-        """list: buckets list"""
-        return self._buckets
-
-    @buckets.setter
-    def buckets(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._buckets = value
+    def templateStatus(self):
+        """ProjectTemplateRequestStatus: Project Template Request status"""
+        return self._templateStatus
+
+    @templateStatus.setter
+    def templateStatus(self, value):
+        if value is not None and not isinstance(value, ProjectTemplateRequestStatus):
+            value = ProjectTemplateRequestStatus(value)
+        if (value is None) or isinstance(value, ProjectTemplateRequestStatus):
+            self._templateStatus = value
         else:
             raise TypeError(
-                'Property "buckets" of type "list<str>" set to wrong type'
+                'Property "templateStatus" of type "list<ProjectTemplateReque'
+                'stStatus>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._buckets is not None:
-            result["buckets"] = \
-                self._buckets
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._templateStatus:
+            result["templateStatus"] = \
+                self._templateStatus.toDict() if self._templateStatus is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if self._version is None:
+            raise ValueError(
+                "ProjectTemplateSuccessResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._templateStatus is None:
+            raise ValueError(
+                "ProjectTemplateSuccessResponse.templateStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._templateStatus is not None): self._templateStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/MetricsListResponse.py` & `organization/data/subscription_management_service/RequestStatus.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,116 +6,132 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Metrics import Metrics
-from .RequestStatus import RequestStatus
+from .StatusCode import StatusCodeEnum
 
 # Unused import over optimization prevention
-str(repr(Metrics))
-str(repr(RequestStatus))
+str(repr(StatusCodeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MetricsListResponse(object):
+class RequestStatus(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.bucket = (
+        self.requestId = (
             None if not fromDict or propDict.get(
-                "bucket"
+                "requestId"
             ) is None
-            else propDict["bucket"])
-        self.metrics = (
+            else propDict["requestId"])
+        self.serverId = (
             None if not fromDict or propDict.get(
-                "metrics"
+                "serverId"
             ) is None
-            else [ Metrics(i)
-            for i in propDict["metrics"] ])
-        self.requestStatus = (
+            else propDict["serverId"])
+        self.statusCode = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "statusCode"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["statusCode"])
+        self.statusDescription = (
+            None if not fromDict or propDict.get(
+                "statusDescription"
+            ) is None
+            else propDict["statusDescription"])
+
+    @property
+    def requestId(self):
+        """ """
+        return self._requestId
+
+    @requestId.setter
+    def requestId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._requestId = value
+        else:
+            raise TypeError(
+                'Property "requestId" of type "list<str>" set to wrong type'
+            )
 
     @property
-    def bucket(self):
-        """str: Name of the bucket"""
-        return self._bucket
+    def serverId(self):
+        """ """
+        return self._serverId
 
-    @bucket.setter
-    def bucket(self, value):
+    @serverId.setter
+    def serverId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._bucket = value
+            self._serverId = value
         else:
             raise TypeError(
-                'Property "bucket" of type "list<str>" set to wrong type'
+                'Property "serverId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def metrics(self):
-        """list: metrics list with field names"""
-        return self._metrics
-
-    @metrics.setter
-    def metrics(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._metrics = value
+    def statusCode(self):
+        """StatusCodeEnum: Describes response status reported by the server.
+        """
+        return self._statusCode
+
+    @statusCode.setter
+    def statusCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._statusCode = value
         else:
             raise TypeError(
-                'Property "metrics" of type "list<Metrics>" set to wrong type'
+                'Property "statusCode" of type "list<StatusCodeEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def statusDescription(self):
         """ """
-        return self._requestStatus
+        return self._statusDescription
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @statusDescription.setter
+    def statusDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._statusDescription = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "statusDescription" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._bucket is not None:
-            result["bucket"] = \
-                self._bucket
-        if self._metrics:
-            result["metrics"] = [
-                i.toDict() for i in self._metrics 
-            ] if self._metrics else []
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._requestId is not None:
+            result["requestId"] = \
+                self._requestId
+        if self._serverId is not None:
+            result["serverId"] = \
+                self._serverId
+        if self._statusCode is not None:
+            result["statusCode"] = \
+                self._statusCode
+        if self._statusDescription is not None:
+            result["statusDescription"] = \
+                self._statusDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._metrics is not None):
-            for obj in self._metrics:
-                if (obj is not None): obj.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/MigProfileInfo.py` & `ngcbpc/data/model/CollectionPatchRequest.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,82 +6,72 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .CollectionOperation import CollectionOperation
 
 # Unused import over optimization prevention
+str(repr(CollectionOperation))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MigProfileInfo(object):
+class CollectionPatchRequest(object):
+    """Request to patch a collection"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.instanceCount = (
+        self.operations = (
             None if not fromDict or propDict.get(
-                "instanceCount"
+                "operations"
             ) is None
-            else propDict["instanceCount"])
-        self.name = (
-            None if not fromDict or propDict.get(
-                "name"
-            ) is None
-            else propDict["name"])
-
-    @property
-    def instanceCount(self):
-        """int: count of the GPU"""
-        return self._instanceCount
-
-    @instanceCount.setter
-    def instanceCount(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._instanceCount = value
-        else:
-            raise TypeError(
-                'Property "instanceCount" of type "list<int>" set to wrong ty'
-                'pe'
-            )
+            else [ CollectionOperation(i)
+            for i in propDict["operations"] ])
 
     @property
-    def name(self):
-        """str: The unique identifer of a GPU"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def operations(self):
+        """ """
+        return self._operations
+
+    @operations.setter
+    def operations(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._operations = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "operations" of type "list<CollectionOperation>" se'
+                't to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._instanceCount is not None:
-            result["instanceCount"] = \
-                self._instanceCount
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._operations:
+            result["operations"] = [
+                i.toDict() for i in self._operations 
+            ] if self._operations else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._operations is not None
+            and
+            len(self._operations) > 100):
+            raise ValueError(
+                "CollectionPatchRequest.operations: " + str(self._operations) + 
+                " doesnt match requirement: maxItems: 100")
+        if (self._operations is not None):
+            for obj in self._operations:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/NetworkInfo.py` & `organization/data/subscription_management_service/Charge.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,244 +6,236 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NetworkInterface import NetworkInterface
+from .Pricing import Pricing
 
 # Unused import over optimization prevention
-str(repr(NetworkInterface))
+str(repr(Pricing))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NetworkInfo(object):
-    """Describes advanced networking information for a node"""
+class Charge(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.defaultGateway = (
+        self.billCycleType = (
             None if not fromDict or propDict.get(
-                "defaultGateway"
+                "billCycleType"
             ) is None
-            else propDict["defaultGateway"])
-        self.defaultInterface = (
+            else propDict["billCycleType"])
+        self.billingDay = (
             None if not fromDict or propDict.get(
-                "defaultInterface"
+                "billingDay"
             ) is None
-            else propDict["defaultInterface"])
-        self.hostName = (
+            else propDict["billingDay"])
+        self.billingPeriod = (
             None if not fromDict or propDict.get(
-                "hostName"
+                "billingPeriod"
             ) is None
-            else propDict["hostName"])
-        self.httpProxy = (
+            else propDict["billingPeriod"])
+        self.chargeName = (
             None if not fromDict or propDict.get(
-                "httpProxy"
+                "chargeName"
             ) is None
-            else propDict["httpProxy"])
-        self.httpsProxy = (
+            else propDict["chargeName"])
+        self.chargeType = (
             None if not fromDict or propDict.get(
-                "httpsProxy"
+                "chargeType"
             ) is None
-            else propDict["httpsProxy"])
-        self.networkInterfaces = (
+            else propDict["chargeType"])
+        self.pricing = (
             None if not fromDict or propDict.get(
-                "networkInterfaces"
+                "pricing"
             ) is None
-            else [ NetworkInterface(i)
-            for i in propDict["networkInterfaces"] ])
-        self.noProxy = (
+            else [ Pricing(i)
+            for i in propDict["pricing"] ])
+        self.productRatePlanChargeSku = (
             None if not fromDict or propDict.get(
-                "noProxy"
+                "productRatePlanChargeSku"
             ) is None
-            else propDict["noProxy"])
-        self.systemType = (
+            else propDict["productRatePlanChargeSku"])
+        self.unitOfMeasure = (
             None if not fromDict or propDict.get(
-                "systemType"
+                "unitOfMeasure"
             ) is None
-            else propDict["systemType"])
+            else propDict["unitOfMeasure"])
 
     @property
-    def defaultGateway(self):
-        """str: Describes the default gateway of a node"""
-        return self._defaultGateway
+    def billCycleType(self):
+        """ """
+        return self._billCycleType
 
-    @defaultGateway.setter
-    def defaultGateway(self, value):
+    @billCycleType.setter
+    def billCycleType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._defaultGateway = value
+            self._billCycleType = value
         else:
             raise TypeError(
-                'Property "defaultGateway" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "billCycleType" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def defaultInterface(self):
-        """str: Describes the default network interface of a node"""
-        return self._defaultInterface
+    def billingDay(self):
+        """ """
+        return self._billingDay
 
-    @defaultInterface.setter
-    def defaultInterface(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._defaultInterface = value
+    @billingDay.setter
+    def billingDay(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._billingDay = value
         else:
             raise TypeError(
-                'Property "defaultInterface" of type "list<str>" set to wrong'
-                ' type'
+                'Property "billingDay" of type "list<int>" set to wrong type'
             )
 
     @property
-    def hostName(self):
-        """str: Describes the hostname for the node, domain name assigned to a
-         computer."""
-        return self._hostName
+    def billingPeriod(self):
+        """ """
+        return self._billingPeriod
 
-    @hostName.setter
-    def hostName(self, value):
+    @billingPeriod.setter
+    def billingPeriod(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._hostName = value
+            self._billingPeriod = value
         else:
             raise TypeError(
-                'Property "hostName" of type "list<str>" set to wrong type'
+                'Property "billingPeriod" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def httpProxy(self):
-        """str: Describes the HTTP_PROXY environment variable for the node. Th
-        is variable should contain the URLs of the proxies for HTTP co
-        nnections."""
-        return self._httpProxy
+    def chargeName(self):
+        """ """
+        return self._chargeName
 
-    @httpProxy.setter
-    def httpProxy(self, value):
+    @chargeName.setter
+    def chargeName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._httpProxy = value
+            self._chargeName = value
         else:
             raise TypeError(
-                'Property "httpProxy" of type "list<str>" set to wrong type'
+                'Property "chargeName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def httpsProxy(self):
-        """str: Describes the HTTPS_PROXY environment variable for the node. T
-        his variable should contain the URLs of the proxies for HTTPS 
-        connections."""
-        return self._httpsProxy
+    def chargeType(self):
+        """ """
+        return self._chargeType
 
-    @httpsProxy.setter
-    def httpsProxy(self, value):
+    @chargeType.setter
+    def chargeType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._httpsProxy = value
+            self._chargeType = value
         else:
             raise TypeError(
-                'Property "httpsProxy" of type "list<str>" set to wrong type'
+                'Property "chargeType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def networkInterfaces(self):
-        """list: Describes a list of all the physical network interfaces on th
-        e node"""
-        return self._networkInterfaces
+    def pricing(self):
+        """ """
+        return self._pricing
 
-    @networkInterfaces.setter
-    def networkInterfaces(self, value):
+    @pricing.setter
+    def pricing(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._networkInterfaces = value
+            self._pricing = value
         else:
             raise TypeError(
-                'Property "networkInterfaces" of type "list<NetworkInterface>'
-                '" set to wrong type'
+                'Property "pricing" of type "list<Pricing>" set to wrong type'
             )
 
     @property
-    def noProxy(self):
-        """str: Describes the NO_PROXY environment variable for the node. This
-         variable should contain a comma-separated list of domain exte
-        nsions proxy should not be used for."""
-        return self._noProxy
+    def productRatePlanChargeSku(self):
+        """ """
+        return self._productRatePlanChargeSku
 
-    @noProxy.setter
-    def noProxy(self, value):
+    @productRatePlanChargeSku.setter
+    def productRatePlanChargeSku(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._noProxy = value
+            self._productRatePlanChargeSku = value
         else:
             raise TypeError(
-                'Property "noProxy" of type "list<str>" set to wrong type'
+                'Property "productRatePlanChargeSku" of type "list<str>" set '
+                'to wrong type'
             )
 
     @property
-    def systemType(self):
-        """str: Describes the type of system architecture of the node"""
-        return self._systemType
+    def unitOfMeasure(self):
+        """ """
+        return self._unitOfMeasure
 
-    @systemType.setter
-    def systemType(self, value):
+    @unitOfMeasure.setter
+    def unitOfMeasure(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._systemType = value
+            self._unitOfMeasure = value
         else:
             raise TypeError(
-                'Property "systemType" of type "list<str>" set to wrong type'
+                'Property "unitOfMeasure" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._defaultGateway is not None:
-            result["defaultGateway"] = \
-                self._defaultGateway
-        if self._defaultInterface is not None:
-            result["defaultInterface"] = \
-                self._defaultInterface
-        if self._hostName is not None:
-            result["hostName"] = \
-                self._hostName
-        if self._httpProxy is not None:
-            result["httpProxy"] = \
-                self._httpProxy
-        if self._httpsProxy is not None:
-            result["httpsProxy"] = \
-                self._httpsProxy
-        if self._networkInterfaces:
-            result["networkInterfaces"] = [
-                i.toDict() for i in self._networkInterfaces 
-            ] if self._networkInterfaces else []
-        if self._noProxy is not None:
-            result["noProxy"] = \
-                self._noProxy
-        if self._systemType is not None:
-            result["systemType"] = \
-                self._systemType
+        if self._billCycleType is not None:
+            result["billCycleType"] = \
+                self._billCycleType
+        if self._billingDay is not None:
+            result["billingDay"] = \
+                self._billingDay
+        if self._billingPeriod is not None:
+            result["billingPeriod"] = \
+                self._billingPeriod
+        if self._chargeName is not None:
+            result["chargeName"] = \
+                self._chargeName
+        if self._chargeType is not None:
+            result["chargeType"] = \
+                self._chargeType
+        if self._pricing:
+            result["pricing"] = [
+                i.toDict() for i in self._pricing 
+            ] if self._pricing else []
+        if self._productRatePlanChargeSku is not None:
+            result["productRatePlanChargeSku"] = \
+                self._productRatePlanChargeSku
+        if self._unitOfMeasure is not None:
+            result["unitOfMeasure"] = \
+                self._unitOfMeasure
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._networkInterfaces is not None):
-            for obj in self._networkInterfaces:
+        if (self._pricing is not None):
+            for obj in self._pricing:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/NetworkInfoResponse.py` & `ngcbpc/data/uis/ListApiKeysResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -7,56 +7,55 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .RequestStatus import RequestStatus
-from .NetworkInfo import NetworkInfo
+from .ApiKey import ApiKey
 
 # Unused import over optimization prevention
-str(repr(NetworkInfo))
 str(repr(RequestStatus))
+str(repr(ApiKey))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NetworkInfoResponse(object):
-    """Describes response containing network information for a node"""
+class ListApiKeysResponse(object):
+    """List api keys response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.networkInfo = (
+        self.apiKeys = (
             None if not fromDict or propDict.get(
-                "networkInfo"
+                "apiKeys"
             ) is None
-            else propDict["networkInfo"])
+            else [ ApiKey(i)
+            for i in propDict["apiKeys"] ])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def networkInfo(self):
-        """NetworkInfo: Describes advanced networking information for a node
-        """
-        return self._networkInfo
-
-    @networkInfo.setter
-    def networkInfo(self, value):
-        if value is not None and not isinstance(value, NetworkInfo):
-            value = NetworkInfo(value)
-        if (value is None) or isinstance(value, NetworkInfo):
-            self._networkInfo = value
+    def apiKeys(self):
+        """list: array of api keys"""
+        return self._apiKeys
+
+    @apiKeys.setter
+    def apiKeys(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._apiKeys = value
         else:
             raise TypeError(
-                'Property "networkInfo" of type "list<NetworkInfo>" set to wr'
-                'ong type'
+                'Property "apiKeys" of type "list<ApiKey>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -70,27 +69,30 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._networkInfo:
-            result["networkInfo"] = \
-                self._networkInfo.toDict() if self._networkInfo is not None else None
+        if self._apiKeys:
+            result["apiKeys"] = [
+                i.toDict() for i in self._apiKeys 
+            ] if self._apiKeys else []
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._networkInfo is not None): self._networkInfo.isValid()
+        if (self._apiKeys is not None):
+            for obj in self._apiKeys:
+                if (obj is not None): obj.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/NetworkInterface.py` & `organization/data/sms/SecretRequestStatus.py`

 * *Files 18% similar despite different names*

```diff
@@ -14,74 +14,109 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NetworkInterface(object):
-    """Describes a physical network interface on the node"""
+class SecretRequestStatus(object):
+    """Secret Request status"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.ipAddresses = (
+        self.additionalInfo = (
             None if not fromDict or propDict.get(
-                "ipAddresses"
+                "additionalInfo"
             ) is None
-            else propDict["ipAddresses"])
+            else propDict["additionalInfo"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
+        self.namespace = (
+            None if not fromDict or propDict.get(
+                "namespace"
+            ) is None
+            else propDict["namespace"])
 
     @property
-    def ipAddresses(self):
-        """list: Describes the IP addresses of the network interface"""
-        return self._ipAddresses
-
-    @ipAddresses.setter
-    def ipAddresses(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._ipAddresses = value
+    def additionalInfo(self):
+        """str: Any other pertinent information on the status"""
+        return self._additionalInfo
+
+    @additionalInfo.setter
+    def additionalInfo(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._additionalInfo = value
         else:
             raise TypeError(
-                'Property "ipAddresses" of type "list<str>" set to wrong type'
+                'Property "additionalInfo" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
     def name(self):
-        """str: Describes the name of the network interface"""
+        """str: Secret name"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
+    @property
+    def namespace(self):
+        """str: Secret namespace"""
+        return self._namespace
+
+    @namespace.setter
+    def namespace(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._namespace = value
+        else:
+            raise TypeError(
+                'Property "namespace" of type "list<str>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._ipAddresses is not None:
-            result["ipAddresses"] = \
-                self._ipAddresses
+        if self._additionalInfo is not None:
+            result["additionalInfo"] = \
+                self._additionalInfo
         if self._name is not None:
             result["name"] = \
                 self._name
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._namespace is None:
+            raise ValueError(
+                "SecretRequestStatus.namespace doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
+            raise ValueError(
+                "SecretRequestStatus.name doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/Node.py` & `organization/data/subscription_management_service/Product.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,617 +6,626 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .NodeHealthEnum import NodeHealthEnum
-from .NodeConnectionEnum import NodeConnectionEnum
-from .NodeStatusEnum import NodeStatusEnum
-from .Console import Console
+from .MetaData import MetaData
+from .Action import Action
+from .RelatedItem import RelatedItem
+from .Tou import Tou
+from .Tab import Tab
 
 # Unused import over optimization prevention
-str(repr(Console))
-str(repr(NodeStatusEnum))
-str(repr(NodeConnectionEnum))
-str(repr(NodeHealthEnum))
+str(repr(Action))
+str(repr(MetaData))
+str(repr(RelatedItem))
+str(repr(Tab))
+str(repr(Tou))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Node(object):
+class Product(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.addresses = (
+        self.actions = (
             None if not fromDict or propDict.get(
-                "addresses"
+                "actions"
             ) is None
-            else propDict["addresses"])
-        self.canBeDeleted = (
+            else [ Action(i)
+            for i in propDict["actions"] ])
+        self.allowCreditCard = (
             None if not fromDict or propDict.get(
-                "canBeDeleted"
+                "allowCreditCard"
             ) is None
-            else propDict["canBeDeleted"])
-        self.connection = (
+            else propDict["allowCreditCard"])
+        self.allowPurchaseOrder = (
             None if not fromDict or propDict.get(
-                "connection"
+                "allowPurchaseOrder"
             ) is None
-            else propDict["connection"])
-        self.console = (
+            else propDict["allowPurchaseOrder"])
+        self.allowTrials = (
             None if not fromDict or propDict.get(
-                "console"
+                "allowTrials"
             ) is None
-            else propDict["console"])
-        self.currentNodeHealth = (
+            else propDict["allowTrials"])
+        self.applicationType = (
             None if not fromDict or propDict.get(
-                "currentNodeHealth"
+                "applicationType"
             ) is None
-            else propDict["currentNodeHealth"])
-        self.description = (
+            else propDict["applicationType"])
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "description"
+                "attributes"
             ) is None
-            else propDict["description"])
+            else [ MetaData(i)
+            for i in propDict["attributes"] ])
+        self.category = (
+            None if not fromDict or propDict.get(
+                "category"
+            ) is None
+            else propDict["category"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
-        self.gnac = (
-            None if not fromDict or propDict.get(
-                "gnac"
-            ) is None
-            else propDict["gnac"])
-        self.ipAddress = (
+        self.imageUrl = (
             None if not fromDict or propDict.get(
-                "ipAddress"
+                "imageUrl"
             ) is None
-            else propDict["ipAddress"])
-        self.isQuarantined = (
+            else propDict["imageUrl"])
+        self.labels = (
             None if not fromDict or propDict.get(
-                "isQuarantined"
+                "labels"
             ) is None
-            else propDict["isQuarantined"])
-        self.issues = (
+            else propDict["labels"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "issues"
+                "name"
             ) is None
-            else propDict["issues"])
-        self.lastReportedConnection = (
+            else propDict["name"])
+        self.productFamily = (
             None if not fromDict or propDict.get(
-                "lastReportedConnection"
+                "productFamily"
             ) is None
-            else propDict["lastReportedConnection"])
-        self.lastReportedStatus = (
+            else propDict["productFamily"])
+        self.productIcon = (
             None if not fromDict or propDict.get(
-                "lastReportedStatus"
+                "productIcon"
             ) is None
-            else propDict["lastReportedStatus"])
-        self.lastReportedStatusTime = (
+            else propDict["productIcon"])
+        self.productSku = (
             None if not fromDict or propDict.get(
-                "lastReportedStatusTime"
+                "productSku"
             ) is None
-            else propDict["lastReportedStatusTime"])
-        self.logsUrl = (
+            else propDict["productSku"])
+        self.productTier = (
             None if not fromDict or propDict.get(
-                "logsUrl"
+                "productTier"
             ) is None
-            else propDict["logsUrl"])
-        self.markedForDelete = (
+            else propDict["productTier"])
+        self.productType = (
             None if not fromDict or propDict.get(
-                "markedForDelete"
+                "productType"
             ) is None
-            else propDict["markedForDelete"])
-        self.messages = (
+            else propDict["productType"])
+        self.purchasable = (
             None if not fromDict or propDict.get(
-                "messages"
+                "purchasable"
             ) is None
-            else propDict["messages"])
-        self.name = (
+            else propDict["purchasable"])
+        self.relatedItems = (
             None if not fromDict or propDict.get(
-                "name"
+                "relatedItems"
             ) is None
-            else propDict["name"])
-        self.role = (
+            else [ RelatedItem(i)
+            for i in propDict["relatedItems"] ])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "role"
+                "shortDescription"
             ) is None
-            else propDict["role"])
-        self.status = (
+            else propDict["shortDescription"])
+        self.tabs = (
             None if not fromDict or propDict.get(
-                "status"
+                "tabs"
             ) is None
-            else propDict["status"])
-        self.ttl = (
+            else [ Tab(i)
+            for i in propDict["tabs"] ])
+        self.tou = (
             None if not fromDict or propDict.get(
-                "ttl"
+                "tou"
             ) is None
-            else propDict["ttl"])
-        self.type = (
+            else propDict["tou"])
+        self.ucpDisplayName = (
             None if not fromDict or propDict.get(
-                "type"
+                "ucpDisplayName"
             ) is None
-            else propDict["type"])
-        self.version = (
+            else propDict["ucpDisplayName"])
+        self.usage = (
             None if not fromDict or propDict.get(
-                "version"
+                "usage"
             ) is None
-            else propDict["version"])
+            else propDict["usage"])
 
     @property
-    def addresses(self):
-        """list: addresses and ipAddress are the same fields"""
-        return self._addresses
+    def actions(self):
+        """ """
+        return self._actions
 
-    @addresses.setter
-    def addresses(self, value):
+    @actions.setter
+    def actions(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._addresses = value
+            self._actions = value
         else:
             raise TypeError(
-                'Property "addresses" of type "list<str>" set to wrong type'
+                'Property "actions" of type "list<Action>" set to wrong type'
             )
 
     @property
-    def canBeDeleted(self):
-        """bool: Master node cannot be deleted if worker nodes exist"""
-        return self._canBeDeleted
+    def allowCreditCard(self):
+        """ """
+        return self._allowCreditCard
 
-    @canBeDeleted.setter
-    def canBeDeleted(self, value):
+    @allowCreditCard.setter
+    def allowCreditCard(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._canBeDeleted = value
+            self._allowCreditCard = value
         else:
             raise TypeError(
-                'Property "canBeDeleted" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "allowCreditCard" of type "list<bool>" set to wrong'
+                ' type'
             )
 
     @property
-    def connection(self):
-        """NodeConnectionEnum: All possible values to know current node connec
-        tion status"""
-        return self._connection
+    def allowPurchaseOrder(self):
+        """ """
+        return self._allowPurchaseOrder
 
-    @connection.setter
-    def connection(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._connection = value
+    @allowPurchaseOrder.setter
+    def allowPurchaseOrder(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._allowPurchaseOrder = value
         else:
             raise TypeError(
-                'Property "connection" of type "list<NodeConnectionEnum>" set'
-                ' to wrong type'
+                'Property "allowPurchaseOrder" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def console(self):
+    def allowTrials(self):
         """ """
-        return self._console
+        return self._allowTrials
 
-    @console.setter
-    def console(self, value):
-        if value is not None and not isinstance(value, Console):
-            value = Console(value)
-        if (value is None) or isinstance(value, Console):
-            self._console = value
+    @allowTrials.setter
+    def allowTrials(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._allowTrials = value
         else:
             raise TypeError(
-                'Property "console" of type "list<Console>" set to wrong type'
+                'Property "allowTrials" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def currentNodeHealth(self):
-        """NodeHealthEnum: All possible node health enums"""
-        return self._currentNodeHealth
+    def applicationType(self):
+        """str: type of the industry of application"""
+        return self._applicationType
 
-    @currentNodeHealth.setter
-    def currentNodeHealth(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._currentNodeHealth = value
+    @applicationType.setter
+    def applicationType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._applicationType = value
         else:
             raise TypeError(
-                'Property "currentNodeHealth" of type "list<NodeHealthEnum>" '
-                'set to wrong type'
+                'Property "applicationType" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def description(self):
+    def attributes(self):
         """ """
-        return self._description
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
+        else:
+            raise TypeError(
+                'Property "attributes" of type "list<MetaData>" set to wrong '
+                'type'
+            )
+
+    @property
+    def category(self):
+        """str: category of the product"""
+        return self._category
 
-    @description.setter
-    def description(self, value):
+    @category.setter
+    def category(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._category = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "category" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """ """
+        """str: display name from user input"""
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gnac(self):
+    def imageUrl(self):
         """ """
-        return self._gnac
+        return self._imageUrl
 
-    @gnac.setter
-    def gnac(self, value):
+    @imageUrl.setter
+    def imageUrl(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gnac = value
+            self._imageUrl = value
         else:
             raise TypeError(
-                'Property "gnac" of type "list<str>" set to wrong type'
+                'Property "imageUrl" of type "list<str>" set to wrong type'
             )
 
     @property
-    def ipAddress(self):
-        """list: [DEPRECATED] use field addresses instead"""
-        return self._ipAddress
+    def labels(self):
+        """ """
+        return self._labels
 
-    @ipAddress.setter
-    def ipAddress(self, value):
+    @labels.setter
+    def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._ipAddress = value
+            self._labels = value
         else:
             raise TypeError(
-                'Property "ipAddress" of type "list<str>" set to wrong type'
+                'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isQuarantined(self):
-        """bool: Is node in quarantined"""
-        return self._isQuarantined
+    def name(self):
+        """str: name of the product"""
+        return self._name
 
-    @isQuarantined.setter
-    def isQuarantined(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isQuarantined = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "isQuarantined" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def issues(self):
-        """list: Issues to show in the banner"""
-        return self._issues
+    def productFamily(self):
+        """ """
+        return self._productFamily
 
-    @issues.setter
-    def issues(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._issues = value
+    @productFamily.setter
+    def productFamily(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productFamily = value
         else:
             raise TypeError(
-                'Property "issues" of type "list<str>" set to wrong type'
+                'Property "productFamily" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def lastReportedConnection(self):
+    def productIcon(self):
         """ """
-        return self._lastReportedConnection
+        return self._productIcon
 
-    @lastReportedConnection.setter
-    def lastReportedConnection(self, value):
+    @productIcon.setter
+    def productIcon(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastReportedConnection = value
+            self._productIcon = value
         else:
             raise TypeError(
-                'Property "lastReportedConnection" of type "list<str>" set to'
-                ' wrong type'
+                'Property "productIcon" of type "list<str>" set to wrong type'
             )
 
     @property
-    def lastReportedStatus(self):
-        """NodeStatusEnum: All possible node status enums"""
-        return self._lastReportedStatus
+    def productSku(self):
+        """str: product SKU of the product"""
+        return self._productSku
 
-    @lastReportedStatus.setter
-    def lastReportedStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._lastReportedStatus = value
+    @productSku.setter
+    def productSku(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productSku = value
         else:
             raise TypeError(
-                'Property "lastReportedStatus" of type "list<NodeStatusEnum>"'
-                ' set to wrong type'
+                'Property "productSku" of type "list<str>" set to wrong type'
             )
 
     @property
-    def lastReportedStatusTime(self):
+    def productTier(self):
         """ """
-        return self._lastReportedStatusTime
+        return self._productTier
 
-    @lastReportedStatusTime.setter
-    def lastReportedStatusTime(self, value):
+    @productTier.setter
+    def productTier(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._lastReportedStatusTime = value
+            self._productTier = value
         else:
             raise TypeError(
-                'Property "lastReportedStatusTime" of type "list<str>" set to'
-                ' wrong type'
+                'Property "productTier" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logsUrl(self):
-        """str: Logs url for node"""
-        return self._logsUrl
+    def productType(self):
+        """ """
+        return self._productType
 
-    @logsUrl.setter
-    def logsUrl(self, value):
+    @productType.setter
+    def productType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logsUrl = value
+            self._productType = value
         else:
             raise TypeError(
-                'Property "logsUrl" of type "list<str>" set to wrong type'
+                'Property "productType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def markedForDelete(self):
-        """bool: Mark a node to be deleted"""
-        return self._markedForDelete
+    def purchasable(self):
+        """ """
+        return self._purchasable
 
-    @markedForDelete.setter
-    def markedForDelete(self, value):
+    @purchasable.setter
+    def purchasable(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._markedForDelete = value
+            self._purchasable = value
         else:
             raise TypeError(
-                'Property "markedForDelete" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "purchasable" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def messages(self):
-        """list: Messages to show in the banner"""
-        return self._messages
+    def relatedItems(self):
+        """ """
+        return self._relatedItems
 
-    @messages.setter
-    def messages(self, value):
+    @relatedItems.setter
+    def relatedItems(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._messages = value
+            self._relatedItems = value
         else:
             raise TypeError(
-                'Property "messages" of type "list<str>" set to wrong type'
+                'Property "relatedItems" of type "list<RelatedItem>" set to w'
+                'rong type'
             )
 
     @property
-    def name(self):
-        """ """
-        return self._name
+    def shortDescription(self):
+        """str: short description of the product"""
+        return self._shortDescription
 
-    @name.setter
-    def name(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def role(self):
+    def tabs(self):
         """ """
-        return self._role
-
-    @role.setter
-    def role(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._role = value
-        else:
-            raise TypeError(
-                'Property "role" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def status(self):
-        """NodeStatusEnum: All possible node status enums"""
-        return self._status
+        return self._tabs
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @tabs.setter
+    def tabs(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._tabs = value
         else:
             raise TypeError(
-                'Property "status" of type "list<NodeStatusEnum>" set to wron'
-                'g type'
+                'Property "tabs" of type "list<Tab>" set to wrong type'
             )
 
     @property
-    def ttl(self):
+    def tou(self):
         """ """
-        return self._ttl
+        return self._tou
 
-    @ttl.setter
-    def ttl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._ttl = value
+    @tou.setter
+    def tou(self, value):
+        if value is not None and not isinstance(value, Tou):
+            value = Tou(value)
+        if (value is None) or isinstance(value, Tou):
+            self._tou = value
         else:
             raise TypeError(
-                'Property "ttl" of type "list<str>" set to wrong type'
+                'Property "tou" of type "list<Tou>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """str: Type of the node"""
-        return self._type
+    def ucpDisplayName(self):
+        """str: display name from UCP product catalog"""
+        return self._ucpDisplayName
 
-    @type.setter
-    def type(self, value):
+    @ucpDisplayName.setter
+    def ucpDisplayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._type = value
+            self._ucpDisplayName = value
         else:
             raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "ucpDisplayName" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def version(self):
-        """str: Version of the node"""
-        return self._version
+    def usage(self):
+        """ """
+        return self._usage
 
-    @version.setter
-    def version(self, value):
+    @usage.setter
+    def usage(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._usage = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "usage" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._addresses is not None:
-            result["addresses"] = \
-                self._addresses
-        if self._canBeDeleted is not None:
-            result["canBeDeleted"] = \
-                self._canBeDeleted
-        if self._connection is not None:
-            result["connection"] = \
-                self._connection
-        if self._console:
-            result["console"] = \
-                self._console.toDict() if self._console is not None else None
-        if self._currentNodeHealth is not None:
-            result["currentNodeHealth"] = \
-                self._currentNodeHealth
-        if self._description is not None:
-            result["description"] = \
-                self._description
+        if self._actions:
+            result["actions"] = [
+                i.toDict() for i in self._actions 
+            ] if self._actions else []
+        if self._allowCreditCard is not None:
+            result["allowCreditCard"] = \
+                self._allowCreditCard
+        if self._allowPurchaseOrder is not None:
+            result["allowPurchaseOrder"] = \
+                self._allowPurchaseOrder
+        if self._allowTrials is not None:
+            result["allowTrials"] = \
+                self._allowTrials
+        if self._applicationType is not None:
+            result["applicationType"] = \
+                self._applicationType
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._category is not None:
+            result["category"] = \
+                self._category
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._gnac is not None:
-            result["gnac"] = \
-                self._gnac
-        if self._ipAddress is not None:
-            result["ipAddress"] = \
-                self._ipAddress
-        if self._isQuarantined is not None:
-            result["isQuarantined"] = \
-                self._isQuarantined
-        if self._issues is not None:
-            result["issues"] = \
-                self._issues
-        if self._lastReportedConnection is not None:
-            result["lastReportedConnection"] = \
-                self._lastReportedConnection
-        if self._lastReportedStatus is not None:
-            result["lastReportedStatus"] = \
-                self._lastReportedStatus
-        if self._lastReportedStatusTime is not None:
-            result["lastReportedStatusTime"] = \
-                self._lastReportedStatusTime
-        if self._logsUrl is not None:
-            result["logsUrl"] = \
-                self._logsUrl
-        if self._markedForDelete is not None:
-            result["markedForDelete"] = \
-                self._markedForDelete
-        if self._messages is not None:
-            result["messages"] = \
-                self._messages
+        if self._imageUrl is not None:
+            result["imageUrl"] = \
+                self._imageUrl
+        if self._labels is not None:
+            result["labels"] = \
+                self._labels
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._role is not None:
-            result["role"] = \
-                self._role
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._ttl is not None:
-            result["ttl"] = \
-                self._ttl
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._productFamily is not None:
+            result["productFamily"] = \
+                self._productFamily
+        if self._productIcon is not None:
+            result["productIcon"] = \
+                self._productIcon
+        if self._productSku is not None:
+            result["productSku"] = \
+                self._productSku
+        if self._productTier is not None:
+            result["productTier"] = \
+                self._productTier
+        if self._productType is not None:
+            result["productType"] = \
+                self._productType
+        if self._purchasable is not None:
+            result["purchasable"] = \
+                self._purchasable
+        if self._relatedItems:
+            result["relatedItems"] = [
+                i.toDict() for i in self._relatedItems 
+            ] if self._relatedItems else []
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._tabs:
+            result["tabs"] = [
+                i.toDict() for i in self._tabs 
+            ] if self._tabs else []
+        if self._tou:
+            result["tou"] = \
+                self._tou.toDict() if self._tou is not None else None
+        if self._ucpDisplayName is not None:
+            result["ucpDisplayName"] = \
+                self._ucpDisplayName
+        if self._usage is not None:
+            result["usage"] = \
+                self._usage
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) > 53):
-            raise ValueError(
-                "Node.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 53")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-z]([-a-z0-9]*[a-z0-9])?$",
-                 self._name)):
-            raise ValueError(
-                "Node.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z]([-a-z0-9]*[a-z0-9"
-                "])?$")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 255):
-            raise ValueError(
-                "Node.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._console is not None): self._console.isValid()
+        if (self._tou is not None): self._tou.isValid()
+        if (self._relatedItems is not None):
+            for obj in self._relatedItems:
+                if (obj is not None): obj.isValid()
+        if (self._actions is not None):
+            for obj in self._actions:
+                if (obj is not None): obj.isValid()
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
+        if (self._tabs is not None):
+            for obj in self._tabs:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/NodeGpuInfoResponse.py` & `ngcbpc/data/model/File.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,168 +6,191 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .GpuInfo import GpuInfo
-from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(GpuInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeGpuInfoResponse(object):
+class File(object):
+    """File object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.errorMessages = (
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "errorMessages"
+                "createdDate"
             ) is None
-            else propDict["errorMessages"])
-        self.gpuInfoList = (
+            else propDict["createdDate"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "gpuInfoList"
+                "description"
             ) is None
-            else [ GpuInfo(i)
-            for i in propDict["gpuInfoList"] ])
-        self.isMigBackwardCompatible = (
+            else propDict["description"])
+        self.path = (
             None if not fromDict or propDict.get(
-                "isMigBackwardCompatible"
+                "path"
             ) is None
-            else propDict["isMigBackwardCompatible"])
-        self.isMigSupported = (
+            else propDict["path"])
+        self.sizeInBytes = (
             None if not fromDict or propDict.get(
-                "isMigSupported"
+                "sizeInBytes"
             ) is None
-            else propDict["isMigSupported"])
-        self.requestStatus = (
+            else propDict["sizeInBytes"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "updatedDate"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["updatedDate"])
 
     @property
-    def errorMessages(self):
-        """list: error messages"""
-        return self._errorMessages
-
-    @errorMessages.setter
-    def errorMessages(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._errorMessages = value
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
+
+    @createdDate.setter
+    def createdDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._createdDate = value
         else:
             raise TypeError(
-                'Property "errorMessages" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def gpuInfoList(self):
-        """list: array of GPU info object"""
-        return self._gpuInfoList
-
-    @gpuInfoList.setter
-    def gpuInfoList(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._gpuInfoList = value
+    def description(self):
+        """str: Description of the file"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "gpuInfoList" of type "list<GpuInfo>" set to wrong '
-                'type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isMigBackwardCompatible(self):
-        """bool: Is MIG backward compatible in the node"""
-        return self._isMigBackwardCompatible
-
-    @isMigBackwardCompatible.setter
-    def isMigBackwardCompatible(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isMigBackwardCompatible = value
+    def path(self):
+        """str: Relative file path from the root of the object"""
+        return self._path
+
+    @path.setter
+    def path(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._path = value
         else:
             raise TypeError(
-                'Property "isMigBackwardCompatible" of type "list<bool>" set '
-                'to wrong type'
+                'Property "path" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isMigSupported(self):
-        """bool: Is MIG supported in the node"""
-        return self._isMigSupported
-
-    @isMigSupported.setter
-    def isMigSupported(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isMigSupported = value
+    def sizeInBytes(self):
+        """long: Size of the file in bytes"""
+        return self._sizeInBytes
+
+    @sizeInBytes.setter
+    def sizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._sizeInBytes = value
         else:
             raise TypeError(
-                'Property "isMigSupported" of type "list<bool>" set to wrong '
-                'type'
+                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
+                'e'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def updatedDate(self):
+        """str: Updated date in ISO-8601 format"""
+        return self._updatedDate
+
+    @updatedDate.setter
+    def updatedDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._errorMessages is not None:
-            result["errorMessages"] = \
-                self._errorMessages
-        if self._gpuInfoList:
-            result["gpuInfoList"] = [
-                i.toDict() for i in self._gpuInfoList 
-            ] if self._gpuInfoList else []
-        if self._isMigBackwardCompatible is not None:
-            result["isMigBackwardCompatible"] = \
-                self._isMigBackwardCompatible
-        if self._isMigSupported is not None:
-            result["isMigSupported"] = \
-                self._isMigSupported
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._path is not None:
+            result["path"] = \
+                self._path
+        if self._sizeInBytes is not None:
+            result["sizeInBytes"] = \
+                self._sizeInBytes
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._gpuInfoList is not None):
-            for obj in self._gpuInfoList:
-                if (obj is not None): obj.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._path is not None
+            and
+            len(self._path) < 1):
+            raise ValueError(
+                "File.path: " + str(self._path) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._path is not None
+            and
+            len(self._path) > 1023):
+            raise ValueError(
+                "File.path: " + str(self._path) + 
+                " doesnt match requirement: maxLength: 1023")
+        if (self._sizeInBytes is not None
+            and
+            self._sizeInBytes < 0):
+            raise ValueError(
+                "File.sizeInBytes: " + str(self._sizeInBytes) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._createdDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
+            raise ValueError(
+                "File.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._updatedDate is not None
+            and
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._updatedDate)):
+            raise ValueError(
+                "File.updatedDate: " + str(self._updatedDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/ecm/NodeResponse.py` & `organization/data/subscription_management_service/Response.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,57 +6,34 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Node import Node
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(Node))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodeResponse(object):
+class Response(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.node = (
-            None if not fromDict or propDict.get(
-                "node"
-            ) is None
-            else propDict["node"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def node(self):
-        """ """
-        return self._node
-
-    @node.setter
-    def node(self, value):
-        if value is not None and not isinstance(value, Node):
-            value = Node(value)
-        if (value is None) or isinstance(value, Node):
-            self._node = value
-        else:
-            raise TypeError(
-                'Property "node" of type "list<Node>" set to wrong type'
-            )
-
-    @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
@@ -67,27 +44,23 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._node:
-            result["node"] = \
-                self._node.toDict() if self._node is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._node is not None): self._node.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/NodesResponse.py` & `basecommand/data/pym/HealthResponse.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,120 +6,125 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Node import Node
-from .RequestStatus import RequestStatus
-from .PaginationInfo import PaginationInfo
+from .HealthInfoItem import HealthInfoItem
 
 # Unused import over optimization prevention
-str(repr(Node))
-str(repr(PaginationInfo))
-str(repr(RequestStatus))
+str(repr(HealthInfoItem))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class NodesResponse(object):
+class HealthResponse(object):
+    """Health Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.nodes = (
+        self.healthInfo = (
             None if not fromDict or propDict.get(
-                "nodes"
+                "healthInfo"
             ) is None
-            else [ Node(i)
-            for i in propDict["nodes"] ])
-        self.paginationInfo = (
+            else [ HealthInfoItem(i)
+            for i in propDict["healthInfo"] ])
+        self.serviceStatus = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "serviceStatus"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["serviceStatus"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "version"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["version"])
 
     @property
-    def nodes(self):
-        """list: array of nodes object"""
-        return self._nodes
+    def healthInfo(self):
+        """list: Health Indicators"""
+        return self._healthInfo
 
-    @nodes.setter
-    def nodes(self, value):
+    @healthInfo.setter
+    def healthInfo(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._nodes = value
+            self._healthInfo = value
         else:
             raise TypeError(
-                'Property "nodes" of type "list<Node>" set to wrong type'
+                'Property "healthInfo" of type "list<HealthInfoItem>" set to '
+                'wrong type'
             )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def serviceStatus(self):
+        """str: Status of the service"""
+        return self._serviceStatus
+
+    @serviceStatus.setter
+    def serviceStatus(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._serviceStatus = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "serviceStatus" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def requestStatus(self):
-        """ """
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._nodes:
-            result["nodes"] = [
-                i.toDict() for i in self._nodes 
-            ] if self._nodes else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._healthInfo:
+            result["healthInfo"] = [
+                i.toDict() for i in self._healthInfo 
+            ] if self._healthInfo else []
+        if self._serviceStatus is not None:
+            result["serviceStatus"] = \
+                self._serviceStatus
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._nodes is not None):
-            for obj in self._nodes:
+        if self._version is None:
+            raise ValueError(
+                "HealthResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._serviceStatus is None:
+            raise ValueError(
+                "HealthResponse.serviceStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._healthInfo is not None):
+            for obj in self._healthInfo:
                 if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/PaginationInfo.py` & `organization/data/subscription_management_service/PaginationInfo.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class PaginationInfo(object):
-    """Pagination Information"""
+    """object that describes the pagination information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.index = (
             None if not fromDict or propDict.get(
                 "index"
             ) is None
             else propDict["index"])
```

## Comparing `ngccli/data/ecm/RemoteApp.py` & `ngcbpc/data/uis/IdpRuleRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,145 +14,142 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RemoteApp(object):
+class IdpRuleRequest(object):
+    """CRUD request for an IDP rule"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.appType = (
+        self.namespace = (
             None if not fromDict or propDict.get(
-                "appType"
+                "namespace"
             ) is None
-            else propDict["appType"])
-        self.displayName = (
+            else propDict["namespace"])
+        self.queryString = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "queryString"
             ) is None
-            else propDict["displayName"])
-        self.name = (
+            else propDict["queryString"])
+        self.roles = (
             None if not fromDict or propDict.get(
-                "name"
+                "roles"
             ) is None
-            else propDict["name"])
-        self.port = (
+            else propDict["roles"])
+        self.ruleName = (
             None if not fromDict or propDict.get(
-                "port"
+                "ruleName"
             ) is None
-            else propDict["port"])
-        self.targetNode = (
-            None if not fromDict or propDict.get(
-                "targetNode"
-            ) is None
-            else propDict["targetNode"])
+            else propDict["ruleName"])
 
     @property
-    def appType(self):
-        """ """
-        return self._appType
+    def namespace(self):
+        """str: Namespace to add users to if the rule applies"""
+        return self._namespace
 
-    @appType.setter
-    def appType(self, value):
+    @namespace.setter
+    def namespace(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._appType = value
+            self._namespace = value
         else:
             raise TypeError(
-                'Property "appType" of type "list<str>" set to wrong type'
+                'Property "namespace" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """ """
-        return self._displayName
+    def queryString(self):
+        """str: Query to use to determine if rule applies"""
+        return self._queryString
 
-    @displayName.setter
-    def displayName(self, value):
+    @queryString.setter
+    def queryString(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._queryString = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "queryString" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """ """
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def roles(self):
+        """list: A list of roles to be added"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     @property
-    def port(self):
-        """ """
-        return self._port
+    def ruleName(self):
+        """str: Rule name"""
+        return self._ruleName
 
-    @port.setter
-    def port(self, value):
+    @ruleName.setter
+    def ruleName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._port = value
+            self._ruleName = value
         else:
             raise TypeError(
-                'Property "port" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def targetNode(self):
-        """ """
-        return self._targetNode
-
-    @targetNode.setter
-    def targetNode(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._targetNode = value
-        else:
-            raise TypeError(
-                'Property "targetNode" of type "list<str>" set to wrong type'
+                'Property "ruleName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._appType is not None:
-            result["appType"] = \
-                self._appType
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._port is not None:
-            result["port"] = \
-                self._port
-        if self._targetNode is not None:
-            result["targetNode"] = \
-                self._targetNode
+        if self._namespace is not None:
+            result["namespace"] = \
+                self._namespace
+        if self._queryString is not None:
+            result["queryString"] = \
+                self._queryString
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
+        if self._ruleName is not None:
+            result["ruleName"] = \
+                self._ruleName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._ruleName is None:
+            raise ValueError(
+                "IdpRuleRequest.ruleName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._namespace is None:
+            raise ValueError(
+                "IdpRuleRequest.namespace doesnt match requirement:" 
+                "required: True"
+            )
+        if self._queryString is None:
+            raise ValueError(
+                "IdpRuleRequest.queryString doesnt match requirement:" 
+                "required: True"
+            )
+        if self._roles is None:
+            raise ValueError(
+                "IdpRuleRequest.roles doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/RemoteAppDetail.py` & `ngcbpc/data/model/ModelVersionFileListResponse.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,184 +6,177 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .RequestStatus import RequestStatus
+from .Model import Model
+from .ModelFile import ModelFile
+from .PaginationInfo import PaginationInfo
+from .ModelVersion import ModelVersion
 
 # Unused import over optimization prevention
+str(repr(PaginationInfo))
+str(repr(ModelFile))
+str(repr(RequestStatus))
+str(repr(ModelVersion))
+str(repr(Model))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RemoteAppDetail(object):
+class ModelVersionFileListResponse(object):
+    """Response to list files for model version request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.creationTimestamp = (
+        self.model = (
             None if not fromDict or propDict.get(
-                "creationTimestamp"
+                "model"
             ) is None
-            else propDict["creationTimestamp"])
-        self.locationName = (
+            else propDict["model"])
+        self.modelFiles = (
             None if not fromDict or propDict.get(
-                "locationName"
+                "modelFiles"
             ) is None
-            else propDict["locationName"])
-        self.remoteAppDisplayName = (
+            else [ ModelFile(i)
+            for i in propDict["modelFiles"] ])
+        self.modelVersion = (
             None if not fromDict or propDict.get(
-                "remoteAppDisplayName"
+                "modelVersion"
             ) is None
-            else propDict["remoteAppDisplayName"])
-        self.remoteAppName = (
+            else propDict["modelVersion"])
+        self.paginationInfo = (
             None if not fromDict or propDict.get(
-                "remoteAppName"
+                "paginationInfo"
             ) is None
-            else propDict["remoteAppName"])
-        self.remoteAppServiceUrl = (
+            else propDict["paginationInfo"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "remoteAppServiceUrl"
+                "requestStatus"
             ) is None
-            else propDict["remoteAppServiceUrl"])
-        self.remoteAppStatus = (
-            None if not fromDict or propDict.get(
-                "remoteAppStatus"
-            ) is None
-            else propDict["remoteAppStatus"])
-
-    @property
-    def creationTimestamp(self):
-        """ """
-        return self._creationTimestamp
-
-    @creationTimestamp.setter
-    def creationTimestamp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._creationTimestamp = value
-        else:
-            raise TypeError(
-                'Property "creationTimestamp" of type "list<str>" set to wron'
-                'g type'
-            )
+            else propDict["requestStatus"])
 
     @property
-    def locationName(self):
-        """ """
-        return self._locationName
+    def model(self):
+        """Model: Model object"""
+        return self._model
 
-    @locationName.setter
-    def locationName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._locationName = value
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
         else:
             raise TypeError(
-                'Property "locationName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "model" of type "list<Model>" set to wrong type'
             )
 
     @property
-    def remoteAppDisplayName(self):
+    def modelFiles(self):
         """ """
-        return self._remoteAppDisplayName
+        return self._modelFiles
 
-    @remoteAppDisplayName.setter
-    def remoteAppDisplayName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._remoteAppDisplayName = value
+    @modelFiles.setter
+    def modelFiles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._modelFiles = value
         else:
             raise TypeError(
-                'Property "remoteAppDisplayName" of type "list<str>" set to w'
-                'rong type'
+                'Property "modelFiles" of type "list<ModelFile>" set to wrong'
+                ' type'
             )
 
     @property
-    def remoteAppName(self):
-        """ """
-        return self._remoteAppName
+    def modelVersion(self):
+        """ModelVersion: Model version object"""
+        return self._modelVersion
 
-    @remoteAppName.setter
-    def remoteAppName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._remoteAppName = value
+    @modelVersion.setter
+    def modelVersion(self, value):
+        if value is not None and not isinstance(value, ModelVersion):
+            value = ModelVersion(value)
+        if (value is None) or isinstance(value, ModelVersion):
+            self._modelVersion = value
         else:
             raise TypeError(
-                'Property "remoteAppName" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "modelVersion" of type "list<ModelVersion>" set to '
+                'wrong type'
             )
 
     @property
-    def remoteAppServiceUrl(self):
-        """ """
-        return self._remoteAppServiceUrl
+    def paginationInfo(self):
+        """PaginationInfo: Pagination Information"""
+        return self._paginationInfo
 
-    @remoteAppServiceUrl.setter
-    def remoteAppServiceUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._remoteAppServiceUrl = value
+    @paginationInfo.setter
+    def paginationInfo(self, value):
+        if value is not None and not isinstance(value, PaginationInfo):
+            value = PaginationInfo(value)
+        if (value is None) or isinstance(value, PaginationInfo):
+            self._paginationInfo = value
         else:
             raise TypeError(
-                'Property "remoteAppServiceUrl" of type "list<str>" set to wr'
-                'ong type'
+                'Property "paginationInfo" of type "list<PaginationInfo>" set'
+                ' to wrong type'
             )
 
     @property
-    def remoteAppStatus(self):
-        """ """
-        return self._remoteAppStatus
+    def requestStatus(self):
+        """RequestStatus: Request status information"""
+        return self._requestStatus
 
-    @remoteAppStatus.setter
-    def remoteAppStatus(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._remoteAppStatus = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "remoteAppStatus" of type "list<RemoteAppStatusEnum'
-                '>" set to wrong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
-    RemoteAppStatusEnum=["UNKNOWN","CREATED","READY","IN_PROGRESS","NOT_READY","PENDING","TERMINATING","FAILED",]
-    str(repr(RemoteAppStatusEnum))  # Prevent optimizer removing enum
-
     def toDict(self):
         result = {}
-        if self._creationTimestamp is not None:
-            result["creationTimestamp"] = \
-                self._creationTimestamp
-        if self._locationName is not None:
-            result["locationName"] = \
-                self._locationName
-        if self._remoteAppDisplayName is not None:
-            result["remoteAppDisplayName"] = \
-                self._remoteAppDisplayName
-        if self._remoteAppName is not None:
-            result["remoteAppName"] = \
-                self._remoteAppName
-        if self._remoteAppServiceUrl is not None:
-            result["remoteAppServiceUrl"] = \
-                self._remoteAppServiceUrl
-        if self._remoteAppStatus is not None:
-            result["remoteAppStatus"] = \
-                self._remoteAppStatus
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._modelFiles:
+            result["modelFiles"] = [
+                i.toDict() for i in self._modelFiles 
+            ] if self._modelFiles else []
+        if self._modelVersion:
+            result["modelVersion"] = \
+                self._modelVersion.toDict() if self._modelVersion is not None else None
+        if self._paginationInfo:
+            result["paginationInfo"] = \
+                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._model is not None): self._model.isValid()
+        if (self._modelVersion is not None): self._modelVersion.isValid()
+        if (self._modelFiles is not None):
+            for obj in self._modelFiles:
+                if (obj is not None): obj.isValid()
+        if (self._paginationInfo is not None): self._paginationInfo.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/RemoteAppResponse.py` & `ngcbpc/data/uis/HealthResponse.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,55 +6,57 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RemoteAppDetail import RemoteAppDetail
 from .RequestStatus import RequestStatus
+from .Health import Health
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(RemoteAppDetail))
+str(repr(Health))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RemoteAppResponse(object):
+class HealthResponse(object):
+    """This API is invoked by monitoring tools, other services and infrastruct
+    ure to retrieve health status the targeted service, this is unprotecte
+    d method"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.remoteApp = (
+        self.health = (
             None if not fromDict or propDict.get(
-                "remoteApp"
+                "health"
             ) is None
-            else propDict["remoteApp"])
+            else propDict["health"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def remoteApp(self):
-        """ """
-        return self._remoteApp
-
-    @remoteApp.setter
-    def remoteApp(self, value):
-        if value is not None and not isinstance(value, RemoteAppDetail):
-            value = RemoteAppDetail(value)
-        if (value is None) or isinstance(value, RemoteAppDetail):
-            self._remoteApp = value
+    def health(self):
+        """Health: object that describes health of the service"""
+        return self._health
+
+    @health.setter
+    def health(self, value):
+        if value is not None and not isinstance(value, Health):
+            value = Health(value)
+        if (value is None) or isinstance(value, Health):
+            self._health = value
         else:
             raise TypeError(
-                'Property "remoteApp" of type "list<RemoteAppDetail>" set to '
-                'wrong type'
+                'Property "health" of type "list<Health>" set to wrong type'
             )
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
@@ -68,27 +70,27 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._remoteApp:
-            result["remoteApp"] = \
-                self._remoteApp.toDict() if self._remoteApp is not None else None
+        if self._health:
+            result["health"] = \
+                self._health.toDict() if self._health is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._remoteApp is not None): self._remoteApp.isValid()
+        if (self._health is not None): self._health.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/RemoteAppTunnelResponse.py` & `ngcbpc/data/uis/ApiKeyPolicy.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,151 +6,166 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Resource import Resource
 
 # Unused import over optimization prevention
+str(repr(Resource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RemoteAppTunnelResponse(object):
+class ApiKeyPolicy(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.caCertificate = (
+        self.product = (
             None if not fromDict or propDict.get(
-                "caCertificate"
+                "product"
             ) is None
-            else propDict["caCertificate"])
-        self.tlsCertificate = (
+            else propDict["product"])
+        self.resources = (
             None if not fromDict or propDict.get(
-                "tlsCertificate"
+                "resources"
             ) is None
-            else propDict["tlsCertificate"])
-        self.tlsKey = (
+            else [ Resource(i)
+            for i in propDict["resources"] ])
+        self.roles = (
             None if not fromDict or propDict.get(
-                "tlsKey"
+                "roles"
             ) is None
-            else propDict["tlsKey"])
-        self.webProxy = (
+            else propDict["roles"])
+        self.scopes = (
             None if not fromDict or propDict.get(
-                "webProxy"
+                "scopes"
             ) is None
-            else propDict["webProxy"])
+            else propDict["scopes"])
+        self.team = (
+            None if not fromDict or propDict.get(
+                "team"
+            ) is None
+            else propDict["team"])
 
     @property
-    def caCertificate(self):
-        """str: Ca certificate for remote app tunnel"""
-        return self._caCertificate
+    def product(self):
+        """str: Name of the service/product"""
+        return self._product
 
-    @caCertificate.setter
-    def caCertificate(self, value):
+    @product.setter
+    def product(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._caCertificate = value
+            self._product = value
         else:
             raise TypeError(
-                'Property "caCertificate" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "product" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tlsCertificate(self):
-        """str: Tls certificate for remote app tunnel"""
-        return self._tlsCertificate
-
-    @tlsCertificate.setter
-    def tlsCertificate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tlsCertificate = value
+    def resources(self):
+        """ """
+        return self._resources
+
+    @resources.setter
+    def resources(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._resources = value
         else:
             raise TypeError(
-                'Property "tlsCertificate" of type "list<str>" set to wrong t'
+                'Property "resources" of type "list<Resource>" set to wrong t'
                 'ype'
             )
 
     @property
-    def tlsKey(self):
-        """str: Tls key for remote app tunnel"""
-        return self._tlsKey
+    def roles(self):
+        """list: List of roles for the team/org context"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
+        else:
+            raise TypeError(
+                'Property "roles" of type "list<str>" set to wrong type'
+            )
 
-    @tlsKey.setter
-    def tlsKey(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._tlsKey = value
+    @property
+    def scopes(self):
+        """list: List of scopes"""
+        return self._scopes
+
+    @scopes.setter
+    def scopes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._scopes = value
         else:
             raise TypeError(
-                'Property "tlsKey" of type "list<str>" set to wrong type'
+                'Property "scopes" of type "list<str>" set to wrong type'
             )
 
     @property
-    def webProxy(self):
-        """str: web proxy URL for remote app tunnel"""
-        return self._webProxy
+    def team(self):
+        """ """
+        return self._team
 
-    @webProxy.setter
-    def webProxy(self, value):
+    @team.setter
+    def team(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._webProxy = value
+            self._team = value
         else:
             raise TypeError(
-                'Property "webProxy" of type "list<str>" set to wrong type'
+                'Property "team" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._caCertificate is not None:
-            result["caCertificate"] = \
-                self._caCertificate
-        if self._tlsCertificate is not None:
-            result["tlsCertificate"] = \
-                self._tlsCertificate
-        if self._tlsKey is not None:
-            result["tlsKey"] = \
-                self._tlsKey
-        if self._webProxy is not None:
-            result["webProxy"] = \
-                self._webProxy
+        if self._product is not None:
+            result["product"] = \
+                self._product
+        if self._resources:
+            result["resources"] = [
+                i.toDict() for i in self._resources 
+            ] if self._resources else []
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
+        if self._scopes is not None:
+            result["scopes"] = \
+                self._scopes
+        if self._team is not None:
+            result["team"] = \
+                self._team
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._tlsKey is None:
-            raise ValueError(
-                "RemoteAppTunnelResponse.tlsKey doesnt match requirement:" 
-                "required: True"
-            )
-        if self._tlsCertificate is None:
-            raise ValueError(
-                "RemoteAppTunnelResponse.tlsCertificate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._caCertificate is None:
-            raise ValueError(
-                "RemoteAppTunnelResponse.caCertificate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._webProxy is None:
+        if self._product is None:
             raise ValueError(
-                "RemoteAppTunnelResponse.webProxy doesnt match requirement:" 
+                "ApiKeyPolicy.product doesnt match requirement:" 
                 "required: True"
             )
+        if (self._resources is not None):
+            for obj in self._resources:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/RemoteConsoleSshResponse.py` & `ngcbpc/data/registry/ImageSelectionRule.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,151 +6,157 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ImageRef import ImageRef
 
 # Unused import over optimization prevention
+str(repr(ImageRef))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RemoteConsoleSshResponse(object):
+class ImageSelectionRule(object):
+    """Image selection rule"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.proxyUrl = (
+        self.id = (
             None if not fromDict or propDict.get(
-                "proxyUrl"
+                "id"
             ) is None
-            else propDict["proxyUrl"])
-        self.sshCertificate = (
+            else propDict["id"])
+        self.image = (
             None if not fromDict or propDict.get(
-                "sshCertificate"
+                "image"
             ) is None
-            else propDict["sshCertificate"])
-        self.tlsCertificate = (
+            else propDict["image"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "tlsCertificate"
+                "name"
             ) is None
-            else propDict["tlsCertificate"])
-        self.tlsKey = (
+            else propDict["name"])
+        self.registry = (
             None if not fromDict or propDict.get(
-                "tlsKey"
+                "registry"
             ) is None
-            else propDict["tlsKey"])
+            else propDict["registry"])
+        self.repository = (
+            None if not fromDict or propDict.get(
+                "repository"
+            ) is None
+            else propDict["repository"])
 
     @property
-    def proxyUrl(self):
-        """str: proxy URL for remote console ssh"""
-        return self._proxyUrl
+    def id(self):
+        """ """
+        return self._id
 
-    @proxyUrl.setter
-    def proxyUrl(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._proxyUrl = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "proxyUrl" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sshCertificate(self):
-        """str: SSH certificate for remote console ssh"""
-        return self._sshCertificate
+    def image(self):
+        """ImageRef: A reference to an image"""
+        return self._image
+
+    @image.setter
+    def image(self, value):
+        if value is not None and not isinstance(value, ImageRef):
+            value = ImageRef(value)
+        if (value is None) or isinstance(value, ImageRef):
+            self._image = value
+        else:
+            raise TypeError(
+                'Property "image" of type "list<ImageRef>" set to wrong type'
+            )
 
-    @sshCertificate.setter
-    def sshCertificate(self, value):
+    @property
+    def name(self):
+        """ """
+        return self._name
+
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._sshCertificate = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "sshCertificate" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tlsCertificate(self):
-        """str: Tls certificate for remote console ssh"""
-        return self._tlsCertificate
+    def registry(self):
+        """ """
+        return self._registry
 
-    @tlsCertificate.setter
-    def tlsCertificate(self, value):
+    @registry.setter
+    def registry(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tlsCertificate = value
+            self._registry = value
         else:
             raise TypeError(
-                'Property "tlsCertificate" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "registry" of type "list<str>" set to wrong type'
             )
 
     @property
-    def tlsKey(self):
-        """str: Tls key for remote console ssh"""
-        return self._tlsKey
+    def repository(self):
+        """ """
+        return self._repository
 
-    @tlsKey.setter
-    def tlsKey(self, value):
+    @repository.setter
+    def repository(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._tlsKey = value
+            self._repository = value
         else:
             raise TypeError(
-                'Property "tlsKey" of type "list<str>" set to wrong type'
+                'Property "repository" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._proxyUrl is not None:
-            result["proxyUrl"] = \
-                self._proxyUrl
-        if self._sshCertificate is not None:
-            result["sshCertificate"] = \
-                self._sshCertificate
-        if self._tlsCertificate is not None:
-            result["tlsCertificate"] = \
-                self._tlsCertificate
-        if self._tlsKey is not None:
-            result["tlsKey"] = \
-                self._tlsKey
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._image:
+            result["image"] = \
+                self._image.toDict() if self._image is not None else None
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._registry is not None:
+            result["registry"] = \
+                self._registry
+        if self._repository is not None:
+            result["repository"] = \
+                self._repository
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._tlsKey is None:
-            raise ValueError(
-                "RemoteConsoleSshResponse.tlsKey doesnt match requirement:" 
-                "required: True"
-            )
-        if self._tlsCertificate is None:
-            raise ValueError(
-                "RemoteConsoleSshResponse.tlsCertificate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._sshCertificate is None:
-            raise ValueError(
-                "RemoteConsoleSshResponse.sshCertificate doesnt match requirement:" 
-                "required: True"
-            )
-        if self._proxyUrl is None:
-            raise ValueError(
-                "RemoteConsoleSshResponse.proxyUrl doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._image is not None): self._image.isValid()
         return True
```

## Comparing `ngccli/data/ecm/RequestStatus.py` & `organization/data/subscription_management_service/UpdateAccountStatusGtsRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,132 +6,121 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .StatusCode import StatusCodeEnum
 
 # Unused import over optimization prevention
-str(repr(StatusCodeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RequestStatus(object):
+class UpdateAccountStatusGtsRequest(object):
+    """Request for updating account status for redemption from GTS"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.requestId = (
+        self.orderNo = (
             None if not fromDict or propDict.get(
-                "requestId"
+                "orderNo"
             ) is None
-            else propDict["requestId"])
-        self.serverId = (
+            else propDict["orderNo"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "serverId"
+                "status"
             ) is None
-            else propDict["serverId"])
+            else propDict["status"])
         self.statusCode = (
             None if not fromDict or propDict.get(
                 "statusCode"
             ) is None
             else propDict["statusCode"])
-        self.statusDescription = (
-            None if not fromDict or propDict.get(
-                "statusDescription"
-            ) is None
-            else propDict["statusDescription"])
 
     @property
-    def requestId(self):
+    def orderNo(self):
         """ """
-        return self._requestId
+        return self._orderNo
 
-    @requestId.setter
-    def requestId(self, value):
+    @orderNo.setter
+    def orderNo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._requestId = value
+            self._orderNo = value
         else:
             raise TypeError(
-                'Property "requestId" of type "list<str>" set to wrong type'
+                'Property "orderNo" of type "list<str>" set to wrong type'
             )
 
     @property
-    def serverId(self):
+    def status(self):
         """ """
-        return self._serverId
+        return self._status
 
-    @serverId.setter
-    def serverId(self, value):
+    @status.setter
+    def status(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._serverId = value
+            self._status = value
         else:
             raise TypeError(
-                'Property "serverId" of type "list<str>" set to wrong type'
+                'Property "status" of type "list<str>" set to wrong type'
             )
 
     @property
     def statusCode(self):
-        """StatusCodeEnum: Describes response status reported by the server.
-        """
+        """ """
         return self._statusCode
 
     @statusCode.setter
     def statusCode(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._statusCode = value
-        else:
-            raise TypeError(
-                'Property "statusCode" of type "list<StatusCodeEnum>" set to '
-                'wrong type'
-            )
-
-    @property
-    def statusDescription(self):
-        """ """
-        return self._statusDescription
-
-    @statusDescription.setter
-    def statusDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._statusDescription = value
+            self._statusCode = value
         else:
             raise TypeError(
-                'Property "statusDescription" of type "list<str>" set to wron'
-                'g type'
+                'Property "statusCode" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._requestId is not None:
-            result["requestId"] = \
-                self._requestId
-        if self._serverId is not None:
-            result["serverId"] = \
-                self._serverId
+        if self._orderNo is not None:
+            result["orderNo"] = \
+                self._orderNo
+        if self._status is not None:
+            result["status"] = \
+                self._status
         if self._statusCode is not None:
             result["statusCode"] = \
                 self._statusCode
-        if self._statusDescription is not None:
-            result["statusDescription"] = \
-                self._statusDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._orderNo is None:
+            raise ValueError(
+                "UpdateAccountStatusGtsRequest.orderNo doesnt match requirement:" 
+                "required: True"
+            )
+        if self._status is None:
+            raise ValueError(
+                "UpdateAccountStatusGtsRequest.status doesnt match requirement:" 
+                "required: True"
+            )
+        if self._statusCode is None:
+            raise ValueError(
+                "UpdateAccountStatusGtsRequest.statusCode doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/Response.py` & `organization/data/subscription_management_service/GetSubscriptionRequestResponse.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,32 +6,40 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .SubscriptionRequest import SubscriptionRequest
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
+str(repr(SubscriptionRequest))
 str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Response(object):
+class GetSubscriptionRequestResponse(object):
+    """Response for get subscriptions request API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
+        self.subscriptionRequest = (
+            None if not fromDict or propDict.get(
+                "subscriptionRequest"
+            ) is None
+            else propDict["subscriptionRequest"])
 
     @property
     def requestStatus(self):
         """ """
         return self._requestStatus
 
     @requestStatus.setter
@@ -42,25 +50,46 @@
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscriptionRequest(self):
+        """ """
+        return self._subscriptionRequest
+
+    @subscriptionRequest.setter
+    def subscriptionRequest(self, value):
+        if value is not None and not isinstance(value, SubscriptionRequest):
+            value = SubscriptionRequest(value)
+        if (value is None) or isinstance(value, SubscriptionRequest):
+            self._subscriptionRequest = value
+        else:
+            raise TypeError(
+                'Property "subscriptionRequest" of type "list<SubscriptionReq'
+                'uest>" set to wrong type'
+            )
+
     def toDict(self):
         result = {}
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscriptionRequest:
+            result["subscriptionRequest"] = \
+                self._subscriptionRequest.toDict() if self._subscriptionRequest is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._subscriptionRequest is not None): self._subscriptionRequest.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/ecm/TypeVersion.py` & `basecommand/data/pym/ClusterInfoResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,76 +6,59 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterInfo import ClusterInfo
 
 # Unused import over optimization prevention
+str(repr(ClusterInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TypeVersion(object):
+class ClusterInfoResponse(object):
+    """Cluster Info Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.imageUrl = (
+        self.clusterInfo = (
             None if not fromDict or propDict.get(
-                "imageUrl"
+                "clusterInfo"
             ) is None
-            else propDict["imageUrl"])
-        self.type = (
-            None if not fromDict or propDict.get(
-                "type"
-            ) is None
-            else propDict["type"])
+            else propDict["clusterInfo"])
         self.version = (
             None if not fromDict or propDict.get(
                 "version"
             ) is None
             else propDict["version"])
 
     @property
-    def imageUrl(self):
-        """str: URL of the image"""
-        return self._imageUrl
-
-    @imageUrl.setter
-    def imageUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._imageUrl = value
+    def clusterInfo(self):
+        """ClusterInfo: Cluster Information"""
+        return self._clusterInfo
+
+    @clusterInfo.setter
+    def clusterInfo(self, value):
+        if value is not None and not isinstance(value, ClusterInfo):
+            value = ClusterInfo(value)
+        if (value is None) or isinstance(value, ClusterInfo):
+            self._clusterInfo = value
         else:
             raise TypeError(
-                'Property "imageUrl" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def type(self):
-        """str: The type of the location/system"""
-        return self._type
-
-    @type.setter
-    def type(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._type = value
-        else:
-            raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "clusterInfo" of type "list<ClusterInfo>" set to wr'
+                'ong type'
             )
 
     @property
     def version(self):
-        """str: version of the location/system"""
+        """str: Payload version"""
         return self._version
 
     @version.setter
     def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -83,28 +66,36 @@
         else:
             raise TypeError(
                 'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._imageUrl is not None:
-            result["imageUrl"] = \
-                self._imageUrl
-        if self._type is not None:
-            result["type"] = \
-                self._type
+        if self._clusterInfo:
+            result["clusterInfo"] = \
+                self._clusterInfo.toDict() if self._clusterInfo is not None else None
         if self._version is not None:
             result["version"] = \
                 self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "ClusterInfoResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._clusterInfo is None:
+            raise ValueError(
+                "ClusterInfoResponse.clusterInfo doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusterInfo is not None): self._clusterInfo.isValid()
         return True
```

## Comparing `ngccli/data/ecm/TypeVersions.py` & `organization/data/subscription_management_service/UserSubscriptions.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,89 +6,81 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .TypeVersion import TypeVersion
 
 # Unused import over optimization prevention
-str(repr(TypeVersion))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class TypeVersions(object):
+class UserSubscriptions(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.type = (
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "type"
+                "orgName"
             ) is None
-            else propDict["type"])
-        self.versions = (
+            else propDict["orgName"])
+        self.products = (
             None if not fromDict or propDict.get(
-                "versions"
+                "products"
             ) is None
-            else [ TypeVersion(i)
-            for i in propDict["versions"] ])
+            else propDict["products"])
 
     @property
-    def type(self):
-        """str: The type of the location/system"""
-        return self._type
+    def orgName(self):
+        """str: name of the org"""
+        return self._orgName
 
-    @type.setter
-    def type(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._type = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def versions(self):
-        """list: Available versions of the location/system"""
-        return self._versions
+    def products(self):
+        """list: list of the product"""
+        return self._products
 
-    @versions.setter
-    def versions(self, value):
+    @products.setter
+    def products(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._versions = value
+            self._products = value
         else:
             raise TypeError(
-                'Property "versions" of type "list<TypeVersion>" set to wrong'
-                ' type'
+                'Property "products" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._versions:
-            result["versions"] = [
-                i.toDict() for i in self._versions 
-            ] if self._versions else []
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._products is not None:
+            result["products"] = \
+                self._products
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._versions is not None):
-            for obj in self._versions:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/UpdateDeploymentRequest.py` & `registry/data/publishing/PublishingRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,295 +6,293 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .AccessTypeEnum import AccessTypeEnum
+from .ArtifactType import ArtifactTypeEnum
+from .Artifact import Artifact
+from .ProductNamesEnum import ProductNamesEnum
 
 # Unused import over optimization prevention
+str(repr(Artifact))
+str(repr(AccessTypeEnum))
+str(repr(ArtifactTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateDeploymentRequest(object):
+class PublishingRequest(object):
+    """Request to publish an artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.allowAnyCapability = (
+        self.accessType = (
             None if not fromDict or propDict.get(
-                "allowAnyCapability"
+                "accessType"
             ) is None
-            else propDict["allowAnyCapability"])
-        self.allowAnyHostPath = (
+            else propDict["accessType"])
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "allowAnyHostPath"
+                "artifactType"
             ) is None
-            else propDict["allowAnyHostPath"])
-        self.allowDevMount = (
+            else propDict["artifactType"])
+        self.productNames = (
             None if not fromDict or propDict.get(
-                "allowDevMount"
+                "productNames"
             ) is None
-            else propDict["allowDevMount"])
-        self.allowHostNamespace = (
+            else propDict["productNames"])
+        self.publishAsListedToPublic = (
             None if not fromDict or propDict.get(
-                "allowHostNamespace"
+                "publishAsListedToPublic"
             ) is None
-            else propDict["allowHostNamespace"])
-        self.allowHostPathPV = (
+            else propDict["publishAsListedToPublic"])
+        self.publishAssetsToCdn = (
             None if not fromDict or propDict.get(
-                "allowHostPathPV"
+                "publishAssetsToCdn"
             ) is None
-            else propDict["allowHostPathPV"])
-        self.allowPrivileged = (
+            else propDict["publishAssetsToCdn"])
+        self.publishToPublic = (
             None if not fromDict or propDict.get(
-                "allowPrivileged"
+                "publishToPublic"
             ) is None
-            else propDict["allowPrivileged"])
-        self.appConfigName = (
+            else propDict["publishToPublic"])
+        self.publishWithGuestAccess = (
             None if not fromDict or propDict.get(
-                "appConfigName"
+                "publishWithGuestAccess"
             ) is None
-            else propDict["appConfigName"])
-        self.appName = (
+            else propDict["publishWithGuestAccess"])
+        self.sign = (
             None if not fromDict or propDict.get(
-                "appName"
+                "sign"
             ) is None
-            else propDict["appName"])
-        self.displayName = (
+            else propDict["sign"])
+        self.sourceArtifact = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "sourceArtifact"
             ) is None
-            else propDict["displayName"])
-        self.locations = (
+            else propDict["sourceArtifact"])
+        self.targetArtifact = (
             None if not fromDict or propDict.get(
-                "locations"
+                "targetArtifact"
             ) is None
-            else propDict["locations"])
+            else propDict["targetArtifact"])
 
     @property
-    def allowAnyCapability(self):
-        """bool: Allow Any Process Capability Flags to the Application Deploym
-        ent"""
-        return self._allowAnyCapability
+    def accessType(self):
+        """ """
+        return self._accessType
+
+    @accessType.setter
+    def accessType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._accessType = value
+        else:
+            raise TypeError(
+                'Property "accessType" of type "list<AccessTypeEnum>" set to '
+                'wrong type'
+            )
 
-    @allowAnyCapability.setter
-    def allowAnyCapability(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyCapability = value
+    @property
+    def artifactType(self):
+        """ """
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "allowAnyCapability" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def allowAnyHostPath(self):
-        """bool: Allow Any System HostPath Access to the Application Deploymen
-        t"""
-        return self._allowAnyHostPath
+    def productNames(self):
+        """list: Product names"""
+        return self._productNames
 
-    @allowAnyHostPath.setter
-    def allowAnyHostPath(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowAnyHostPath = value
+    @productNames.setter
+    def productNames(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._productNames = value
         else:
             raise TypeError(
-                'Property "allowAnyHostPath" of type "list<bool>" set to wron'
-                'g type'
+                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def allowDevMount(self):
-        """bool: Allow System Devices Access to the Application Deployment"""
-        return self._allowDevMount
+    def publishAsListedToPublic(self):
+        """bool: Enable public listings including: NGC Search. Default: true. 
+        Pre-req: publishToPublic set to true"""
+        return self._publishAsListedToPublic
 
-    @allowDevMount.setter
-    def allowDevMount(self, value):
+    @publishAsListedToPublic.setter
+    def publishAsListedToPublic(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowDevMount = value
+            self._publishAsListedToPublic = value
         else:
             raise TypeError(
-                'Property "allowDevMount" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "publishAsListedToPublic" of type "list<bool>" set '
+                'to wrong type'
             )
 
     @property
-    def allowHostNamespace(self):
-        """bool: Allow System Process Access to the Application Deployment"""
-        return self._allowHostNamespace
+    def publishAssetsToCdn(self):
+        """bool: Publish detected assets in the README `description` field of 
+        the asset to CDN"""
+        return self._publishAssetsToCdn
 
-    @allowHostNamespace.setter
-    def allowHostNamespace(self, value):
+    @publishAssetsToCdn.setter
+    def publishAssetsToCdn(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowHostNamespace = value
+            self._publishAssetsToCdn = value
         else:
             raise TypeError(
-                'Property "allowHostNamespace" of type "list<bool>" set to wr'
+                'Property "publishAssetsToCdn" of type "list<bool>" set to wr'
                 'ong type'
             )
 
     @property
-    def allowHostPathPV(self):
-        """bool: Allow System HostPath Access for PersistentVolumes to the App
-        lication Deployment"""
-        return self._allowHostPathPV
+    def publishToPublic(self):
+        """bool: Enable public access to artifact"""
+        return self._publishToPublic
 
-    @allowHostPathPV.setter
-    def allowHostPathPV(self, value):
+    @publishToPublic.setter
+    def publishToPublic(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowHostPathPV = value
+            self._publishToPublic = value
         else:
             raise TypeError(
-                'Property "allowHostPathPV" of type "list<bool>" set to wrong'
+                'Property "publishToPublic" of type "list<bool>" set to wrong'
                 ' type'
             )
 
     @property
-    def allowPrivileged(self):
-        """bool: Allow Privileged Containers to the Application Deployment"""
-        return self._allowPrivileged
+    def publishWithGuestAccess(self):
+        """bool: Enable public anonymous access to artifact. Pre-req: publishT
+        oPublic set to true"""
+        return self._publishWithGuestAccess
 
-    @allowPrivileged.setter
-    def allowPrivileged(self, value):
+    @publishWithGuestAccess.setter
+    def publishWithGuestAccess(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._allowPrivileged = value
+            self._publishWithGuestAccess = value
         else:
             raise TypeError(
-                'Property "allowPrivileged" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "publishWithGuestAccess" of type "list<bool>" set t'
+                'o wrong type'
             )
 
     @property
-    def appConfigName(self):
-        """str: App configurations in the deployment"""
-        return self._appConfigName
-
-    @appConfigName.setter
-    def appConfigName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._appConfigName = value
-        else:
-            raise TypeError(
-                'Property "appConfigName" of type "list<str>" set to wrong ty'
-                'pe'
-            )
+    def sign(self):
+        """bool: Sign the source container image with Nvidia key before publis
+        hing"""
+        return self._sign
 
-    @property
-    def appName(self):
-        """str: App in the deployment"""
-        return self._appName
-
-    @appName.setter
-    def appName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._appName = value
+    @sign.setter
+    def sign(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._sign = value
         else:
             raise TypeError(
-                'Property "appName" of type "list<str>" set to wrong type'
+                'Property "sign" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the deployment"""
-        return self._displayName
-
-    @displayName.setter
-    def displayName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+    def sourceArtifact(self):
+        """Artifact: NGC Artifact"""
+        return self._sourceArtifact
+
+    @sourceArtifact.setter
+    def sourceArtifact(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._sourceArtifact = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "sourceArtifact" of type "list<Artifact>" set to wr'
+                'ong type'
             )
 
     @property
-    def locations(self):
-        """list: App deploys in locations"""
-        return self._locations
-
-    @locations.setter
-    def locations(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._locations = value
+    def targetArtifact(self):
+        """Artifact: NGC Artifact"""
+        return self._targetArtifact
+
+    @targetArtifact.setter
+    def targetArtifact(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._targetArtifact = value
         else:
             raise TypeError(
-                'Property "locations" of type "list<str>" set to wrong type'
+                'Property "targetArtifact" of type "list<Artifact>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
-        if self._allowAnyCapability is not None:
-            result["allowAnyCapability"] = \
-                self._allowAnyCapability
-        if self._allowAnyHostPath is not None:
-            result["allowAnyHostPath"] = \
-                self._allowAnyHostPath
-        if self._allowDevMount is not None:
-            result["allowDevMount"] = \
-                self._allowDevMount
-        if self._allowHostNamespace is not None:
-            result["allowHostNamespace"] = \
-                self._allowHostNamespace
-        if self._allowHostPathPV is not None:
-            result["allowHostPathPV"] = \
-                self._allowHostPathPV
-        if self._allowPrivileged is not None:
-            result["allowPrivileged"] = \
-                self._allowPrivileged
-        if self._appConfigName is not None:
-            result["appConfigName"] = \
-                self._appConfigName
-        if self._appName is not None:
-            result["appName"] = \
-                self._appName
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._locations is not None:
-            result["locations"] = \
-                self._locations
+        if self._accessType is not None:
+            result["accessType"] = \
+                self._accessType
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._productNames is not None:
+            result["productNames"] = \
+                self._productNames
+        if self._publishAsListedToPublic is not None:
+            result["publishAsListedToPublic"] = \
+                self._publishAsListedToPublic
+        if self._publishAssetsToCdn is not None:
+            result["publishAssetsToCdn"] = \
+                self._publishAssetsToCdn
+        if self._publishToPublic is not None:
+            result["publishToPublic"] = \
+                self._publishToPublic
+        if self._publishWithGuestAccess is not None:
+            result["publishWithGuestAccess"] = \
+                self._publishWithGuestAccess
+        if self._sign is not None:
+            result["sign"] = \
+                self._sign
+        if self._sourceArtifact:
+            result["sourceArtifact"] = \
+                self._sourceArtifact.toDict() if self._sourceArtifact is not None else None
+        if self._targetArtifact:
+            result["targetArtifact"] = \
+                self._targetArtifact.toDict() if self._targetArtifact is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 255):
-            raise ValueError(
-                "UpdateDeploymentRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._appName is not None
-            and
-            len(self._appName) > 53):
-            raise ValueError(
-                "UpdateDeploymentRequest.appName: " + str(self._appName) + 
-                " doesnt match requirement: maxLength: 53")
+        if (self._sourceArtifact is not None): self._sourceArtifact.isValid()
+        if (self._targetArtifact is not None): self._targetArtifact.isValid()
         return True
```

## Comparing `ngccli/data/ecm/UpdateGpuInfo.py` & `ngcbpc/data/model/ArtifactVersionCreateRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,107 +6,119 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateGpuInfo(object):
-    """GPU information in a node"""
+class ArtifactVersionCreateRequest(object):
+    """Request to create a new artifact version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.enableMig = (
+        self.attributes = (
             None if not fromDict or propDict.get(
-                "enableMig"
+                "attributes"
             ) is None
-            else propDict["enableMig"])
-        self.gpuId = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["attributes"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "gpuId"
+                "description"
             ) is None
-            else propDict["gpuId"])
-        self.migProfileName = (
+            else propDict["description"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "migProfileName"
+                "id"
             ) is None
-            else propDict["migProfileName"])
+            else propDict["id"])
 
     @property
-    def enableMig(self):
-        """bool: enabled MIG on the GPU"""
-        return self._enableMig
-
-    @enableMig.setter
-    def enableMig(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._enableMig = value
+    def attributes(self):
+        """list: Attribute key/value pairs"""
+        return self._attributes
+
+    @attributes.setter
+    def attributes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._attributes = value
         else:
             raise TypeError(
-                'Property "enableMig" of type "list<bool>" set to wrong type'
+                'Property "attributes" of type "list<ArtifactAttribute>" set '
+                'to wrong type'
             )
 
     @property
-    def gpuId(self):
-        """str: The unique identifier of a GPU"""
-        return self._gpuId
+    def description(self):
+        """str: Description of the artifact version"""
+        return self._description
 
-    @gpuId.setter
-    def gpuId(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuId = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "gpuId" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def migProfileName(self):
-        """str: MIG profile name from available MIG profile"""
-        return self._migProfileName
+    def id(self):
+        """str: Unique ID of the version"""
+        return self._id
 
-    @migProfileName.setter
-    def migProfileName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._migProfileName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "migProfileName" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._enableMig is not None:
-            result["enableMig"] = \
-                self._enableMig
-        if self._gpuId is not None:
-            result["gpuId"] = \
-                self._gpuId
-        if self._migProfileName is not None:
-            result["migProfileName"] = \
-                self._migProfileName
+        if self._attributes:
+            result["attributes"] = [
+                i.toDict() for i in self._attributes 
+            ] if self._attributes else []
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._id is not None:
+            result["id"] = \
+                self._id
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._id is None:
+            raise ValueError(
+                "ArtifactVersionCreateRequest.id doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._attributes is not None):
+            for obj in self._attributes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/UpdateNodeGpuInfoRequest.py` & `basecommand/data/pym/ClusterInstanceTypesResponse.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,90 +6,101 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .UpdateGpuInfo import UpdateGpuInfo
+from .ClusterComponent import ClusterComponent
 
 # Unused import over optimization prevention
-str(repr(UpdateGpuInfo))
+str(repr(ClusterComponent))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateNodeGpuInfoRequest(object):
+class ClusterInstanceTypesResponse(object):
+    """List all the machine instance types available for the cluster component
+    s"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.gpuInfoList = (
+        self.clusterComponents = (
             None if not fromDict or propDict.get(
-                "gpuInfoList"
+                "clusterComponents"
             ) is None
-            else [ UpdateGpuInfo(i)
-            for i in propDict["gpuInfoList"] ])
-        self.isMigBackwardCompatible = (
+            else [ ClusterComponent(i)
+            for i in propDict["clusterComponents"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "isMigBackwardCompatible"
+                "version"
             ) is None
-            else propDict["isMigBackwardCompatible"])
+            else propDict["version"])
 
     @property
-    def gpuInfoList(self):
-        """list: array of GPU info object """
-        return self._gpuInfoList
+    def clusterComponents(self):
+        """ """
+        return self._clusterComponents
 
-    @gpuInfoList.setter
-    def gpuInfoList(self, value):
+    @clusterComponents.setter
+    def clusterComponents(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._gpuInfoList = value
+            self._clusterComponents = value
         else:
             raise TypeError(
-                'Property "gpuInfoList" of type "list<UpdateGpuInfo>" set to '
-                'wrong type'
+                'Property "clusterComponents" of type "list<ClusterComponent>'
+                '" set to wrong type'
             )
 
     @property
-    def isMigBackwardCompatible(self):
-        """bool: Is MIG backward compatible in the node"""
-        return self._isMigBackwardCompatible
-
-    @isMigBackwardCompatible.setter
-    def isMigBackwardCompatible(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isMigBackwardCompatible = value
+    def version(self):
+        """str: Payload version"""
+        return self._version
+
+    @version.setter
+    def version(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._version = value
         else:
             raise TypeError(
-                'Property "isMigBackwardCompatible" of type "list<bool>" set '
-                'to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._gpuInfoList:
-            result["gpuInfoList"] = [
-                i.toDict() for i in self._gpuInfoList 
-            ] if self._gpuInfoList else []
-        if self._isMigBackwardCompatible is not None:
-            result["isMigBackwardCompatible"] = \
-                self._isMigBackwardCompatible
+        if self._clusterComponents:
+            result["clusterComponents"] = [
+                i.toDict() for i in self._clusterComponents 
+            ] if self._clusterComponents else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._gpuInfoList is not None):
-            for obj in self._gpuInfoList:
+        if self._version is None:
+            raise ValueError(
+                "ClusterInstanceTypesResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._clusterComponents is None:
+            raise ValueError(
+                "ClusterInstanceTypesResponse.clusterComponents doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusterComponents is not None):
+            for obj in self._clusterComponents:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/ecm/UpdateNodeRequest.py` & `basecommand/data/pym/ProjectRequestStatus.py`

 * *Files 15% similar despite different names*

```diff
@@ -14,152 +14,139 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateNodeRequest(object):
+class ProjectRequestStatus(object):
+    """Project Request status"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.commands = (
+        self.additionalInfo = (
             None if not fromDict or propDict.get(
-                "commands"
+                "additionalInfo"
             ) is None
-            else propDict["commands"])
-        self.description = (
+            else propDict["additionalInfo"])
+        self.creationTimestamp = (
             None if not fromDict or propDict.get(
-                "description"
+                "creationTimestamp"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else propDict["creationTimestamp"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "id"
             ) is None
-            else propDict["displayName"])
-        self.initiateReboot = (
+            else propDict["id"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "initiateReboot"
+                "name"
             ) is None
-            else propDict["initiateReboot"])
-        self.remoteExec = (
-            None if not fromDict or propDict.get(
-                "remoteExec"
-            ) is None
-            else propDict["remoteExec"])
+            else propDict["name"])
 
     @property
-    def commands(self):
-        """str: Commands to execute on node"""
-        return self._commands
+    def additionalInfo(self):
+        """str: Any other pertinent information on the status"""
+        return self._additionalInfo
 
-    @commands.setter
-    def commands(self, value):
+    @additionalInfo.setter
+    def additionalInfo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._commands = value
+            self._additionalInfo = value
         else:
             raise TypeError(
-                'Property "commands" of type "list<str>" set to wrong type'
+                'Property "additionalInfo" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def description(self):
-        """str: Description of the node"""
-        return self._description
+    def creationTimestamp(self):
+        """str: Project creation date time in YYYY-MM-DDThh:mm:ssZ format"""
+        return self._creationTimestamp
 
-    @description.setter
-    def description(self, value):
+    @creationTimestamp.setter
+    def creationTimestamp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._creationTimestamp = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "creationTimestamp" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the node"""
-        return self._displayName
+    def id(self):
+        """str: Project ID"""
+        return self._id
 
-    @displayName.setter
-    def displayName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def initiateReboot(self):
-        """bool: Initiate node reboot"""
-        return self._initiateReboot
-
-    @initiateReboot.setter
-    def initiateReboot(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._initiateReboot = value
-        else:
-            raise TypeError(
-                'Property "initiateReboot" of type "list<bool>" set to wrong '
-                'type'
-            )
+    def name(self):
+        """str: Project name"""
+        return self._name
 
-    @property
-    def remoteExec(self):
-        """bool: Run command on node"""
-        return self._remoteExec
-
-    @remoteExec.setter
-    def remoteExec(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._remoteExec = value
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
         else:
             raise TypeError(
-                'Property "remoteExec" of type "list<bool>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._commands is not None:
-            result["commands"] = \
-                self._commands
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._initiateReboot is not None:
-            result["initiateReboot"] = \
-                self._initiateReboot
-        if self._remoteExec is not None:
-            result["remoteExec"] = \
-                self._remoteExec
+        if self._additionalInfo is not None:
+            result["additionalInfo"] = \
+                self._additionalInfo
+        if self._creationTimestamp is not None:
+            result["creationTimestamp"] = \
+                self._creationTimestamp
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 255):
+        if self._id is None:
+            raise ValueError(
+                "ProjectRequestStatus.id doesnt match requirement:" 
+                "required: True"
+            )
+        if self._name is None:
             raise ValueError(
-                "UpdateNodeRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 255")
+                "ProjectRequestStatus.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._creationTimestamp is None:
+            raise ValueError(
+                "ProjectRequestStatus.creationTimestamp doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/ecm/UpdateSettingsRequest.py` & `organization/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,301 +6,353 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Alert import Alert
+from .AzureMarketplaceSubscription import AzureMarketplaceSubscription
 
 # Unused import over optimization prevention
-str(repr(Alert))
+str(repr(AzureMarketplaceSubscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class UpdateSettingsRequest(object):
+class AzureMarketplaceSubscriptionNotificationEvent(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.alerts = (
+        self.action = (
             None if not fromDict or propDict.get(
-                "alerts"
+                "action"
             ) is None
-            else [ Alert(i)
-            for i in propDict["alerts"] ])
-        self.allowDevMount = (
+            else propDict["action"])
+        self.activityId = (
             None if not fromDict or propDict.get(
-                "allowDevMount"
+                "activityId"
             ) is None
-            else propDict["allowDevMount"])
-        self.allowSecurityOverrides = (
+            else propDict["activityId"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "allowSecurityOverrides"
+                "id"
             ) is None
-            else propDict["allowSecurityOverrides"])
-        self.loggingOptionsEnableApplicationLogs = (
+            else propDict["id"])
+        self.offerId = (
             None if not fromDict or propDict.get(
-                "loggingOptionsEnableApplicationLogs"
+                "offerId"
             ) is None
-            else propDict["loggingOptionsEnableApplicationLogs"])
-        self.loggingOptionsEnableFullSystemLogs = (
+            else propDict["offerId"])
+        self.operationRequestSource = (
             None if not fromDict or propDict.get(
-                "loggingOptionsEnableFullSystemLogs"
+                "operationRequestSource"
             ) is None
-            else propDict["loggingOptionsEnableFullSystemLogs"])
-        self.remoteAppIsEnabled = (
+            else propDict["operationRequestSource"])
+        self.planId = (
             None if not fromDict or propDict.get(
-                "remoteAppIsEnabled"
+                "planId"
             ) is None
-            else propDict["remoteAppIsEnabled"])
-        self.remoteAppMaxSessionDuration = (
+            else propDict["planId"])
+        self.publisherId = (
             None if not fromDict or propDict.get(
-                "remoteAppMaxSessionDuration"
+                "publisherId"
             ) is None
-            else propDict["remoteAppMaxSessionDuration"])
-        self.remoteManagementIsEnabled = (
+            else propDict["publisherId"])
+        self.purchaseToken = (
             None if not fromDict or propDict.get(
-                "remoteManagementIsEnabled"
+                "purchaseToken"
             ) is None
-            else propDict["remoteManagementIsEnabled"])
-        self.remoteManagementMaxSessionDuration = (
+            else propDict["purchaseToken"])
+        self.quantity = (
             None if not fromDict or propDict.get(
-                "remoteManagementMaxSessionDuration"
+                "quantity"
             ) is None
-            else propDict["remoteManagementMaxSessionDuration"])
-        self.remoteManagementMaxSessionIdle = (
+            else propDict["quantity"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "remoteManagementMaxSessionIdle"
+                "status"
             ) is None
-            else propDict["remoteManagementMaxSessionIdle"])
+            else propDict["status"])
+        self.subscription = (
+            None if not fromDict or propDict.get(
+                "subscription"
+            ) is None
+            else propDict["subscription"])
+        self.subscriptionId = (
+            None if not fromDict or propDict.get(
+                "subscriptionId"
+            ) is None
+            else propDict["subscriptionId"])
+        self.timeStamp = (
+            None if not fromDict or propDict.get(
+                "timeStamp"
+            ) is None
+            else propDict["timeStamp"])
 
     @property
-    def alerts(self):
-        """ """
-        return self._alerts
-
-    @alerts.setter
-    def alerts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._alerts = value
+    def action(self):
+        """str: action of the event"""
+        return self._action
+
+    @action.setter
+    def action(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._action = value
         else:
             raise TypeError(
-                'Property "alerts" of type "list<Alert>" set to wrong type'
+                'Property "action" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowDevMount(self):
-        """bool: allow users to access /dev in deployments"""
-        return self._allowDevMount
-
-    @allowDevMount.setter
-    def allowDevMount(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowDevMount = value
+    def activityId(self):
+        """str: id of the activity"""
+        return self._activityId
+
+    @activityId.setter
+    def activityId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._activityId = value
         else:
             raise TypeError(
-                'Property "allowDevMount" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "activityId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def allowSecurityOverrides(self):
-        """bool: allow users to override security options in deployments"""
-        return self._allowSecurityOverrides
-
-    @allowSecurityOverrides.setter
-    def allowSecurityOverrides(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._allowSecurityOverrides = value
+    def id(self):
+        """str: id of the event"""
+        return self._id
+
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._id = value
         else:
             raise TypeError(
-                'Property "allowSecurityOverrides" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def loggingOptionsEnableApplicationLogs(self):
-        """ """
-        return self._loggingOptionsEnableApplicationLogs
-
-    @loggingOptionsEnableApplicationLogs.setter
-    def loggingOptionsEnableApplicationLogs(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._loggingOptionsEnableApplicationLogs = value
+    def offerId(self):
+        """str: id of the Azure marketplace offer"""
+        return self._offerId
+
+    @offerId.setter
+    def offerId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._offerId = value
         else:
             raise TypeError(
-                'Property "loggingOptionsEnableApplicationLogs" of type "list'
-                '<bool>" set to wrong type'
+                'Property "offerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def loggingOptionsEnableFullSystemLogs(self):
-        """ """
-        return self._loggingOptionsEnableFullSystemLogs
+    def operationRequestSource(self):
+        """str: source of the operation"""
+        return self._operationRequestSource
+
+    @operationRequestSource.setter
+    def operationRequestSource(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._operationRequestSource = value
+        else:
+            raise TypeError(
+                'Property "operationRequestSource" of type "list<str>" set to'
+                ' wrong type'
+            )
 
-    @loggingOptionsEnableFullSystemLogs.setter
-    def loggingOptionsEnableFullSystemLogs(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._loggingOptionsEnableFullSystemLogs = value
+    @property
+    def planId(self):
+        """str: plan id of the Azure marketplace offer"""
+        return self._planId
+
+    @planId.setter
+    def planId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._planId = value
         else:
             raise TypeError(
-                'Property "loggingOptionsEnableFullSystemLogs" of type "list<'
-                'bool>" set to wrong type'
+                'Property "planId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def remoteAppIsEnabled(self):
-        """ """
-        return self._remoteAppIsEnabled
+    def publisherId(self):
+        """str: id of the Azure marketplace publisher"""
+        return self._publisherId
+
+    @publisherId.setter
+    def publisherId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._publisherId = value
+        else:
+            raise TypeError(
+                'Property "publisherId" of type "list<str>" set to wrong type'
+            )
 
-    @remoteAppIsEnabled.setter
-    def remoteAppIsEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._remoteAppIsEnabled = value
+    @property
+    def purchaseToken(self):
+        """str: purchase token"""
+        return self._purchaseToken
+
+    @purchaseToken.setter
+    def purchaseToken(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._purchaseToken = value
         else:
             raise TypeError(
-                'Property "remoteAppIsEnabled" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "purchaseToken" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def remoteAppMaxSessionDuration(self):
-        """int: Max session duration in seconds"""
-        return self._remoteAppMaxSessionDuration
+    def quantity(self):
+        """int: quantity in the Azure marketplace subscription"""
+        return self._quantity
 
-    @remoteAppMaxSessionDuration.setter
-    def remoteAppMaxSessionDuration(self, value):
+    @quantity.setter
+    def quantity(self, value):
         if value is not None and not isinstance(value, int):
             value = int(value)
         if (value is None) or isinstance(value, int):
-            self._remoteAppMaxSessionDuration = value
+            self._quantity = value
         else:
             raise TypeError(
-                'Property "remoteAppMaxSessionDuration" of type "list<int>" s'
-                'et to wrong type'
+                'Property "quantity" of type "list<int>" set to wrong type'
             )
 
     @property
-    def remoteManagementIsEnabled(self):
-        """ """
-        return self._remoteManagementIsEnabled
-
-    @remoteManagementIsEnabled.setter
-    def remoteManagementIsEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._remoteManagementIsEnabled = value
+    def status(self):
+        """str: status of the action"""
+        return self._status
+
+    @status.setter
+    def status(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._status = value
         else:
             raise TypeError(
-                'Property "remoteManagementIsEnabled" of type "list<bool>" se'
-                't to wrong type'
+                'Property "status" of type "list<str>" set to wrong type'
             )
 
     @property
-    def remoteManagementMaxSessionDuration(self):
-        """int: Max session duration in seconds"""
-        return self._remoteManagementMaxSessionDuration
-
-    @remoteManagementMaxSessionDuration.setter
-    def remoteManagementMaxSessionDuration(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._remoteManagementMaxSessionDuration = value
+    def subscription(self):
+        """AzureMarketplaceSubscription: Subscription Object in AzureMarketpla
+        ce-webhook-event"""
+        return self._subscription
+
+    @subscription.setter
+    def subscription(self, value):
+        if value is not None and not isinstance(value, AzureMarketplaceSubscription):
+            value = AzureMarketplaceSubscription(value)
+        if (value is None) or isinstance(value, AzureMarketplaceSubscription):
+            self._subscription = value
         else:
             raise TypeError(
-                'Property "remoteManagementMaxSessionDuration" of type "list<'
-                'int>" set to wrong type'
+                'Property "subscription" of type "list<AzureMarketplaceSubscr'
+                'iption>" set to wrong type'
             )
 
     @property
-    def remoteManagementMaxSessionIdle(self):
-        """int: Max session idle in seconds"""
-        return self._remoteManagementMaxSessionIdle
+    def subscriptionId(self):
+        """str: id of the subscription in Azure marketplace"""
+        return self._subscriptionId
+
+    @subscriptionId.setter
+    def subscriptionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._subscriptionId = value
+        else:
+            raise TypeError(
+                'Property "subscriptionId" of type "list<str>" set to wrong t'
+                'ype'
+            )
 
-    @remoteManagementMaxSessionIdle.setter
-    def remoteManagementMaxSessionIdle(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._remoteManagementMaxSessionIdle = value
+    @property
+    def timeStamp(self):
+        """str: timestamp of the event"""
+        return self._timeStamp
+
+    @timeStamp.setter
+    def timeStamp(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._timeStamp = value
         else:
             raise TypeError(
-                'Property "remoteManagementMaxSessionIdle" of type "list<int>'
-                '" set to wrong type'
+                'Property "timeStamp" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._alerts:
-            result["alerts"] = [
-                i.toDict() for i in self._alerts 
-            ] if self._alerts else []
-        if self._allowDevMount is not None:
-            result["allowDevMount"] = \
-                self._allowDevMount
-        if self._allowSecurityOverrides is not None:
-            result["allowSecurityOverrides"] = \
-                self._allowSecurityOverrides
-        if self._loggingOptionsEnableApplicationLogs is not None:
-            result["loggingOptionsEnableApplicationLogs"] = \
-                self._loggingOptionsEnableApplicationLogs
-        if self._loggingOptionsEnableFullSystemLogs is not None:
-            result["loggingOptionsEnableFullSystemLogs"] = \
-                self._loggingOptionsEnableFullSystemLogs
-        if self._remoteAppIsEnabled is not None:
-            result["remoteAppIsEnabled"] = \
-                self._remoteAppIsEnabled
-        if self._remoteAppMaxSessionDuration is not None:
-            result["remoteAppMaxSessionDuration"] = \
-                self._remoteAppMaxSessionDuration
-        if self._remoteManagementIsEnabled is not None:
-            result["remoteManagementIsEnabled"] = \
-                self._remoteManagementIsEnabled
-        if self._remoteManagementMaxSessionDuration is not None:
-            result["remoteManagementMaxSessionDuration"] = \
-                self._remoteManagementMaxSessionDuration
-        if self._remoteManagementMaxSessionIdle is not None:
-            result["remoteManagementMaxSessionIdle"] = \
-                self._remoteManagementMaxSessionIdle
+        if self._action is not None:
+            result["action"] = \
+                self._action
+        if self._activityId is not None:
+            result["activityId"] = \
+                self._activityId
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._offerId is not None:
+            result["offerId"] = \
+                self._offerId
+        if self._operationRequestSource is not None:
+            result["operationRequestSource"] = \
+                self._operationRequestSource
+        if self._planId is not None:
+            result["planId"] = \
+                self._planId
+        if self._publisherId is not None:
+            result["publisherId"] = \
+                self._publisherId
+        if self._purchaseToken is not None:
+            result["purchaseToken"] = \
+                self._purchaseToken
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._subscription:
+            result["subscription"] = \
+                self._subscription.toDict() if self._subscription is not None else None
+        if self._subscriptionId is not None:
+            result["subscriptionId"] = \
+                self._subscriptionId
+        if self._timeStamp is not None:
+            result["timeStamp"] = \
+                self._timeStamp
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._remoteManagementMaxSessionIdle is not None
-            and
-            self._remoteManagementMaxSessionIdle < 60):
-            raise ValueError(
-                "UpdateSettingsRequest.remoteManagementMaxSessionIdle: " + str(self._remoteManagementMaxSessionIdle) + 
-                " doesnt match requirement: minimum: 60")
-        if (self._remoteManagementMaxSessionIdle is not None
-            and
-            self._remoteManagementMaxSessionIdle > 3540):
-            raise ValueError(
-                "UpdateSettingsRequest.remoteManagementMaxSessionIdle: " + str(self._remoteManagementMaxSessionIdle) + 
-                " doesnt match requirement: maximum: 3540")
-        if (self._alerts is not None):
-            for obj in self._alerts:
-                if (obj is not None): obj.isValid()
+        if (self._subscription is not None): self._subscription.isValid()
         return True
```

## Comparing `ngccli/data/ecm/ValidationStatus.py` & `ngcbpc/data/model/ModelSimplified.py`

 * *Files 20% similar despite different names*

```diff
@@ -14,122 +14,108 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ValidationStatus(object):
+class ModelSimplified(object):
+    """Model object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.notes = (
+        self.name = (
             None if not fromDict or propDict.get(
-                "notes"
+                "name"
             ) is None
-            else propDict["notes"])
-        self.signedBy = (
+            else propDict["name"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "signedBy"
+                "orgName"
             ) is None
-            else propDict["signedBy"])
-        self.validated = (
+            else propDict["orgName"])
+        self.teamName = (
             None if not fromDict or propDict.get(
-                "validated"
+                "teamName"
             ) is None
-            else propDict["validated"])
-        self.validatedTime = (
-            None if not fromDict or propDict.get(
-                "validatedTime"
-            ) is None
-            else propDict["validatedTime"])
+            else propDict["teamName"])
 
     @property
-    def notes(self):
-        """ """
-        return self._notes
+    def name(self):
+        """str: Unique name of the model"""
+        return self._name
 
-    @notes.setter
-    def notes(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._notes = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "notes" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def signedBy(self):
-        """ """
-        return self._signedBy
+    def orgName(self):
+        """str: Name of the org that the model belongs to"""
+        return self._orgName
 
-    @signedBy.setter
-    def signedBy(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._signedBy = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "signedBy" of type "list<str>" set to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def validated(self):
-        """ """
-        return self._validated
-
-    @validated.setter
-    def validated(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._validated = value
-        else:
-            raise TypeError(
-                'Property "validated" of type "list<bool>" set to wrong type'
-            )
+    def teamName(self):
+        """str: Name of the team that the model belongs to"""
+        return self._teamName
 
-    @property
-    def validatedTime(self):
-        """ """
-        return self._validatedTime
-
-    @validatedTime.setter
-    def validatedTime(self, value):
+    @teamName.setter
+    def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._validatedTime = value
+            self._teamName = value
         else:
             raise TypeError(
-                'Property "validatedTime" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "teamName" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._notes is not None:
-            result["notes"] = \
-                self._notes
-        if self._signedBy is not None:
-            result["signedBy"] = \
-                self._signedBy
-        if self._validated is not None:
-            result["validated"] = \
-                self._validated
-        if self._validatedTime is not None:
-            result["validatedTime"] = \
-                self._validatedTime
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._teamName is not None:
+            result["teamName"] = \
+                self._teamName
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._name is None:
+            raise ValueError(
+                "ModelSimplified.name doesnt match requirement:" 
+                "required: True"
+            )
+        if self._orgName is None:
+            raise ValueError(
+                "ModelSimplified.orgName doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/model/AIFoundationModel.py` & `basecommand/data/pym/ProjectTemplateModifyParams.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,222 +6,201 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterModifyParams import ClusterModifyParams
 
 # Unused import over optimization prevention
+str(repr(ClusterModifyParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AIFoundationModel(object):
-    """Get AI Playground Response"""
+class ProjectTemplateModifyParams(object):
+    """Project template modification parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactName = (
+        self.clusterParams = (
             None if not fromDict or propDict.get(
-                "artifactName"
+                "clusterParams"
             ) is None
-            else propDict["artifactName"])
-        self.attributes = (
+            else propDict["clusterParams"])
+        self.clusterType = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "clusterType"
             ) is None
-            else propDict["attributes"])
-        self.createdDate = (
+            else propDict["clusterType"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "description"
             ) is None
-            else propDict["createdDate"])
-        self.namespace = (
+            else propDict["description"])
+        self.displayImageURL = (
             None if not fromDict or propDict.get(
-                "namespace"
+                "displayImageURL"
             ) is None
-            else propDict["namespace"])
-        self.nvcfFunctionId = (
+            else propDict["displayImageURL"])
+        self.isDefault = (
             None if not fromDict or propDict.get(
-                "nvcfFunctionId"
+                "isDefault"
             ) is None
-            else propDict["nvcfFunctionId"])
-        self.openAPISpec = (
+            else propDict["isDefault"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "openAPISpec"
+                "name"
             ) is None
-            else propDict["openAPISpec"])
-        self.updatedDate = (
-            None if not fromDict or propDict.get(
-                "updatedDate"
-            ) is None
-            else propDict["updatedDate"])
-
-    @property
-    def artifactName(self):
-        """str: Unique name of the model"""
-        return self._artifactName
-
-    @artifactName.setter
-    def artifactName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._artifactName = value
-        else:
-            raise TypeError(
-                'Property "artifactName" of type "list<str>" set to wrong typ'
-                'e'
-            )
+            else propDict["name"])
 
     @property
-    def attributes(self):
-        """str: Metadata json string"""
-        return self._attributes
+    def clusterParams(self):
+        """ClusterModifyParams: Cluster modification params"""
+        return self._clusterParams
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._attributes = value
+    @clusterParams.setter
+    def clusterParams(self, value):
+        if value is not None and not isinstance(value, ClusterModifyParams):
+            value = ClusterModifyParams(value)
+        if (value is None) or isinstance(value, ClusterModifyParams):
+            self._clusterParams = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<str>" set to wrong type'
+                'Property "clusterParams" of type "list<ClusterModifyParams>"'
+                ' set to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """str: Creation date in ISO-8601 format"""
-        return self._createdDate
+    def clusterType(self):
+        """ """
+        return self._clusterType
 
-    @createdDate.setter
-    def createdDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+    @clusterType.setter
+    def clusterType(self, value):
+        if value is not None and not isinstance(value, str):
+            value = str(value)
+        if (value is None) or isinstance(value, str):
+            self._clusterType = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "clusterType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def namespace(self):
-        """str: org/team of the model"""
-        return self._namespace
+    def description(self):
+        """str: Project template description"""
+        return self._description
 
-    @namespace.setter
-    def namespace(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._namespace = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "namespace" of type "list<str>" set to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def nvcfFunctionId(self):
-        """str: NVCF function id for the model playground"""
-        return self._nvcfFunctionId
+    def displayImageURL(self):
+        """str: Display Image URL"""
+        return self._displayImageURL
 
-    @nvcfFunctionId.setter
-    def nvcfFunctionId(self, value):
+    @displayImageURL.setter
+    def displayImageURL(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._nvcfFunctionId = value
+            self._displayImageURL = value
         else:
             raise TypeError(
-                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "displayImageURL" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def openAPISpec(self):
-        """str: OpenAPI specification for this model"""
-        return self._openAPISpec
+    def isDefault(self):
+        """bool: Indicate if template is default"""
+        return self._isDefault
 
-    @openAPISpec.setter
-    def openAPISpec(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._openAPISpec = value
+    @isDefault.setter
+    def isDefault(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isDefault = value
         else:
             raise TypeError(
-                'Property "openAPISpec" of type "list<str>" set to wrong type'
+                'Property "isDefault" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def updatedDate(self):
-        """str: Updated date in ISO-8601 format"""
-        return self._updatedDate
+    def name(self):
+        """str: Project template name"""
+        return self._name
 
-    @updatedDate.setter
-    def updatedDate(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactName is not None:
-            result["artifactName"] = \
-                self._artifactName
-        if self._attributes is not None:
-            result["attributes"] = \
-                self._attributes
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._namespace is not None:
-            result["namespace"] = \
-                self._namespace
-        if self._nvcfFunctionId is not None:
-            result["nvcfFunctionId"] = \
-                self._nvcfFunctionId
-        if self._openAPISpec is not None:
-            result["openAPISpec"] = \
-                self._openAPISpec
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
+        if self._clusterParams:
+            result["clusterParams"] = \
+                self._clusterParams.toDict() if self._clusterParams is not None else None
+        if self._clusterType is not None:
+            result["clusterType"] = \
+                self._clusterType
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._displayImageURL is not None:
+            result["displayImageURL"] = \
+                self._displayImageURL
+        if self._isDefault is not None:
+            result["isDefault"] = \
+                self._isDefault
+        if self._name is not None:
+            result["name"] = \
+                self._name
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._createdDate is not None
+        if (self._name is not None
+            and
+            len(self._name) < 1):
+            raise ValueError(
+                "ProjectTemplateModifyParams.name: " + str(self._name) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._description is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._description) < 1):
             raise ValueError(
-                "AIFoundationModel.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
+                "ProjectTemplateModifyParams.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._displayImageURL is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
+            len(self._displayImageURL) < 1):
             raise ValueError(
-                "AIFoundationModel.updatedDate: " + str(self._updatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "ProjectTemplateModifyParams.displayImageURL: " + str(self._displayImageURL) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._clusterParams is not None): self._clusterParams.isValid()
         return True
```

## Comparing `ngccli/data/model/AIPlaygroundCreateRequest.py` & `organization/data/sms/SecretCreateRequest.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,132 +6,158 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .KV import KV
 
 # Unused import over optimization prevention
+str(repr(KV))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AIPlaygroundCreateRequest(object):
-    """Request to create a new AI Playground config"""
+class SecretCreateRequest(object):
+    """Secret create request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactName = (
+        self.description = (
             None if not fromDict or propDict.get(
-                "artifactName"
+                "description"
             ) is None
-            else propDict["artifactName"])
-        self.attributes = (
+            else propDict["description"])
+        self.disabled = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "disabled"
             ) is None
-            else propDict["attributes"])
-        self.nvcfFunctionId = (
+            else propDict["disabled"])
+        self.kv = (
             None if not fromDict or propDict.get(
-                "nvcfFunctionId"
+                "kv"
             ) is None
-            else propDict["nvcfFunctionId"])
-        self.openAPISpec = (
+            else [ KV(i)
+            for i in propDict["kv"] ])
+        self.version = (
             None if not fromDict or propDict.get(
-                "openAPISpec"
+                "version"
             ) is None
-            else propDict["openAPISpec"])
+            else propDict["version"])
 
     @property
-    def artifactName(self):
-        """str: Unique name of the model"""
-        return self._artifactName
+    def description(self):
+        """str: Secret description"""
+        return self._description
 
-    @artifactName.setter
-    def artifactName(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._artifactName = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "artifactName" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def attributes(self):
-        """str: Metadata json string"""
-        return self._attributes
-
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._attributes = value
+    def disabled(self):
+        """bool: Secret enabled/disabled (default: enabled)"""
+        return self._disabled
+
+    @disabled.setter
+    def disabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._disabled = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<str>" set to wrong type'
+                'Property "disabled" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def nvcfFunctionId(self):
-        """str: NVCF function id for the model playground"""
-        return self._nvcfFunctionId
-
-    @nvcfFunctionId.setter
-    def nvcfFunctionId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._nvcfFunctionId = value
+    def kv(self):
+        """ """
+        return self._kv
+
+    @kv.setter
+    def kv(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._kv = value
         else:
             raise TypeError(
-                'Property "nvcfFunctionId" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "kv" of type "list<KV>" set to wrong type'
             )
 
     @property
-    def openAPISpec(self):
-        """str: OpenAPI specification for this model"""
-        return self._openAPISpec
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @openAPISpec.setter
-    def openAPISpec(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._openAPISpec = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "openAPISpec" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactName is not None:
-            result["artifactName"] = \
-                self._artifactName
-        if self._attributes is not None:
-            result["attributes"] = \
-                self._attributes
-        if self._nvcfFunctionId is not None:
-            result["nvcfFunctionId"] = \
-                self._nvcfFunctionId
-        if self._openAPISpec is not None:
-            result["openAPISpec"] = \
-                self._openAPISpec
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._disabled is not None:
+            result["disabled"] = \
+                self._disabled
+        if self._kv:
+            result["kv"] = [
+                i.toDict() for i in self._kv 
+            ] if self._kv else []
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._version is None:
+            raise ValueError(
+                "SecretCreateRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._description is None:
+            raise ValueError(
+                "SecretCreateRequest.description doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._description is not None
+            and
+            len(self._description) < 1):
+            raise ValueError(
+                "SecretCreateRequest.description: " + str(self._description) + 
+                " doesnt match requirement: minLength: 1")
+        if self._kv is None:
+            raise ValueError(
+                "SecretCreateRequest.kv doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._kv is not None):
+            for obj in self._kv:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ApplicationType.py` & `ngcbpc/data/model/ApplicationType.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/model/Artifact.py` & `ngcbpc/data/model/Collection.py`

 * *Files 20% similar despite different names*

```diff
@@ -7,64 +7,59 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .AccessTypeEnum import AccessTypeEnum
-from .ArtifactAttribute import ArtifactAttribute
+from .CollectionCategoryType import CollectionCategoryTypeEnum
 from .ProductNamesEnum import ProductNamesEnum
-from .ArtifactTypeEnum import ArtifactTypeEnum
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(ArtifactTypeEnum))
 str(repr(ArtifactAttribute))
-str(repr(ProductNamesEnum))
 str(repr(AccessTypeEnum))
+str(repr(ProductNamesEnum))
+str(repr(CollectionCategoryTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Artifact(object):
-    """Artifact object"""
+class Collection(object):
+    """Collection object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.accessType = (
             None if not fromDict or propDict.get(
                 "accessType"
             ) is None
             else propDict["accessType"])
-        self.artifactType = (
-            None if not fromDict or propDict.get(
-                "artifactType"
-            ) is None
-            else propDict["artifactType"])
         self.attributes = (
             None if not fromDict or propDict.get(
                 "attributes"
             ) is None
             else [ ArtifactAttribute(i)
             for i in propDict["attributes"] ])
-        self.bias = (
-            None if not fromDict or propDict.get(
-                "bias"
-            ) is None
-            else propDict["bias"])
         self.builtBy = (
             None if not fromDict or propDict.get(
                 "builtBy"
             ) is None
             else propDict["builtBy"])
         self.canGuestDownload = (
             None if not fromDict or propDict.get(
                 "canGuestDownload"
             ) is None
             else propDict["canGuestDownload"])
+        self.category = (
+            None if not fromDict or propDict.get(
+                "category"
+            ) is None
+            else propDict["category"])
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
         self.description = (
             None if not fromDict or propDict.get(
@@ -72,24 +67,14 @@
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
-        self.explainability = (
-            None if not fromDict or propDict.get(
-                "explainability"
-            ) is None
-            else propDict["explainability"])
-        self.isFavourite = (
-            None if not fromDict or propDict.get(
-                "isFavourite"
-            ) is None
-            else propDict["isFavourite"])
         self.isPublic = (
             None if not fromDict or propDict.get(
                 "isPublic"
             ) is None
             else propDict["isPublic"])
         self.isReadOnly = (
             None if not fromDict or propDict.get(
@@ -97,24 +82,14 @@
             ) is None
             else propDict["isReadOnly"])
         self.labels = (
             None if not fromDict or propDict.get(
                 "labels"
             ) is None
             else propDict["labels"])
-        self.latestVersionId = (
-            None if not fromDict or propDict.get(
-                "latestVersionId"
-            ) is None
-            else propDict["latestVersionId"])
-        self.latestVersionSizeInBytes = (
-            None if not fromDict or propDict.get(
-                "latestVersionSizeInBytes"
-            ) is None
-            else propDict["latestVersionSizeInBytes"])
         self.logo = (
             None if not fromDict or propDict.get(
                 "logo"
             ) is None
             else propDict["logo"])
         self.name = (
             None if not fromDict or propDict.get(
@@ -127,39 +102,34 @@
             ) is None
             else propDict["orgName"])
         self.ownerName = (
             None if not fromDict or propDict.get(
                 "ownerName"
             ) is None
             else propDict["ownerName"])
-        self.privacy = (
-            None if not fromDict or propDict.get(
-                "privacy"
-            ) is None
-            else propDict["privacy"])
         self.productNames = (
             None if not fromDict or propDict.get(
                 "productNames"
             ) is None
             else propDict["productNames"])
         self.publisher = (
             None if not fromDict or propDict.get(
                 "publisher"
             ) is None
             else propDict["publisher"])
-        self.safetyAndSecurity = (
-            None if not fromDict or propDict.get(
-                "safetyAndSecurity"
-            ) is None
-            else propDict["safetyAndSecurity"])
         self.shortDescription = (
             None if not fromDict or propDict.get(
                 "shortDescription"
             ) is None
             else propDict["shortDescription"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
         self.teamName = (
             None if not fromDict or propDict.get(
                 "teamName"
             ) is None
             else propDict["teamName"])
         self.updatedDate = (
             None if not fromDict or propDict.get(
@@ -179,29 +149,14 @@
         else:
             raise TypeError(
                 'Property "accessType" of type "list<AccessTypeEnum>" set to '
                 'wrong type'
             )
 
     @property
-    def artifactType(self):
-        """ArtifactTypeEnum: Artifact type"""
-        return self._artifactType
-
-    @artifactType.setter
-    def artifactType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._artifactType = value
-        else:
-            raise TypeError(
-                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
-                ' to wrong type'
-            )
-
-    @property
     def attributes(self):
         """list: Attribute key/value pairs"""
         return self._attributes
 
     @attributes.setter
     def attributes(self, value):
         if value is not None and not isinstance(value, list):
@@ -211,32 +166,16 @@
         else:
             raise TypeError(
                 'Property "attributes" of type "list<ArtifactAttribute>" set '
                 'to wrong type'
             )
 
     @property
-    def bias(self):
-        """str: Text describing bias in the artifact"""
-        return self._bias
-
-    @bias.setter
-    def bias(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._bias = value
-        else:
-            raise TypeError(
-                'Property "bias" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def builtBy(self):
-        """str: Organization that built the helm chart"""
+        """str: Organization that built the collection"""
         return self._builtBy
 
     @builtBy.setter
     def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -260,14 +199,29 @@
         else:
             raise TypeError(
                 'Property "canGuestDownload" of type "list<bool>" set to wron'
                 'g type'
             )
 
     @property
+    def category(self):
+        """ """
+        return self._category
+
+    @category.setter
+    def category(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._category = value
+        else:
+            raise TypeError(
+                'Property "category" of type "list<CollectionCategoryTypeEnum'
+                '>" set to wrong type'
+            )
+
+    @property
     def createdDate(self):
         """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
     def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
@@ -277,15 +231,15 @@
         else:
             raise TypeError(
                 'Property "createdDate" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the helm chart"""
+        """str: Description of the collection"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -308,50 +262,16 @@
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def explainability(self):
-        """str: Text describing the explainability for this artifact"""
-        return self._explainability
-
-    @explainability.setter
-    def explainability(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._explainability = value
-        else:
-            raise TypeError(
-                'Property "explainability" of type "list<str>" set to wrong t'
-                'ype'
-            )
-
-    @property
-    def isFavourite(self):
-        """bool: Flag indicating if helm chart is user's favorite"""
-        return self._isFavourite
-
-    @isFavourite.setter
-    def isFavourite(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isFavourite = value
-        else:
-            raise TypeError(
-                'Property "isFavourite" of type "list<bool>" set to wrong typ'
-                'e'
-            )
-
-    @property
     def isPublic(self):
-        """bool: Determines if this helm chart is publicly accessible"""
+        """bool: Determines if this collection is publicly accessible"""
         return self._isPublic
 
     @isPublic.setter
     def isPublic(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
@@ -390,48 +310,14 @@
             self._labels = value
         else:
             raise TypeError(
                 'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def latestVersionId(self):
-        """str: ID of the latest version"""
-        return self._latestVersionId
-
-    @latestVersionId.setter
-    def latestVersionId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._latestVersionId = value
-        else:
-            raise TypeError(
-                'Property "latestVersionId" of type "list<str>" set to wrong '
-                'type'
-            )
-
-    @property
-    def latestVersionSizeInBytes(self):
-        """long: Size of the latest version in bytes"""
-        return self._latestVersionSizeInBytes
-
-    @latestVersionSizeInBytes.setter
-    def latestVersionSizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._latestVersionSizeInBytes = value
-        else:
-            raise TypeError(
-                'Property "latestVersionSizeInBytes" of type "list<long>" set'
-                ' to wrong type'
-            )
-
-    @property
     def logo(self):
         """str: URL for the logo image"""
         return self._logo
 
     @logo.setter
     def logo(self, value):
         if value is not None and not isinstance(value, string_types):
@@ -441,15 +327,15 @@
         else:
             raise TypeError(
                 'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Unique name of the helm chart"""
+        """str: Unique name of the collection"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -457,15 +343,15 @@
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
     def orgName(self):
-        """str: Name of the org that the helm chart belongs to"""
+        """str: Name of the org that the collection belongs to"""
         return self._orgName
 
     @orgName.setter
     def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -488,30 +374,14 @@
             self._ownerName = value
         else:
             raise TypeError(
                 'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def privacy(self):
-        """str: Text describing the privacy for this artifact"""
-        return self._privacy
-
-    @privacy.setter
-    def privacy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._privacy = value
-        else:
-            raise TypeError(
-                'Property "privacy" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def productNames(self):
         """list: Product names"""
         return self._productNames
 
     @productNames.setter
     def productNames(self, value):
         if value is not None and not isinstance(value, list):
@@ -522,48 +392,31 @@
             raise TypeError(
                 'Property "productNames" of type "list<ProductNamesEnum>" set'
                 ' to wrong type'
             )
 
     @property
     def publisher(self):
-        """str: Organization that published this helm chart"""
+        """str: Organization that published this collection"""
         return self._publisher
 
     @publisher.setter
     def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._publisher = value
         else:
             raise TypeError(
                 'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def safetyAndSecurity(self):
-        """str: Text for describing the safety and security in the artifact"""
-        return self._safetyAndSecurity
-
-    @safetyAndSecurity.setter
-    def safetyAndSecurity(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._safetyAndSecurity = value
-        else:
-            raise TypeError(
-                'Property "safetyAndSecurity" of type "list<str>" set to wron'
-                'g type'
-            )
-
-    @property
     def shortDescription(self):
-        """str: Short description of the helm chart"""
+        """str: Short description of the collection"""
         return self._shortDescription
 
     @shortDescription.setter
     def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -571,16 +424,32 @@
         else:
             raise TypeError(
                 'Property "shortDescription" of type "list<str>" set to wrong'
                 ' type'
             )
 
     @property
+    def size(self):
+        """long: Total count of collection items"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
+        else:
+            raise TypeError(
+                'Property "size" of type "list<long>" set to wrong type'
+            )
+
+    @property
     def teamName(self):
-        """str: Name of the team that the helm chart belongs to"""
+        """str: Name of the team that the collection belongs to"""
         return self._teamName
 
     @teamName.setter
     def teamName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -607,87 +476,69 @@
             )
 
     def toDict(self):
         result = {}
         if self._accessType is not None:
             result["accessType"] = \
                 self._accessType
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
         if self._attributes:
             result["attributes"] = [
                 i.toDict() for i in self._attributes 
             ] if self._attributes else []
-        if self._bias is not None:
-            result["bias"] = \
-                self._bias
         if self._builtBy is not None:
             result["builtBy"] = \
                 self._builtBy
         if self._canGuestDownload is not None:
             result["canGuestDownload"] = \
                 self._canGuestDownload
+        if self._category is not None:
+            result["category"] = \
+                self._category
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
-        if self._explainability is not None:
-            result["explainability"] = \
-                self._explainability
-        if self._isFavourite is not None:
-            result["isFavourite"] = \
-                self._isFavourite
         if self._isPublic is not None:
             result["isPublic"] = \
                 self._isPublic
         if self._isReadOnly is not None:
             result["isReadOnly"] = \
                 self._isReadOnly
         if self._labels is not None:
             result["labels"] = \
                 self._labels
-        if self._latestVersionId is not None:
-            result["latestVersionId"] = \
-                self._latestVersionId
-        if self._latestVersionSizeInBytes is not None:
-            result["latestVersionSizeInBytes"] = \
-                self._latestVersionSizeInBytes
         if self._logo is not None:
             result["logo"] = \
                 self._logo
         if self._name is not None:
             result["name"] = \
                 self._name
         if self._orgName is not None:
             result["orgName"] = \
                 self._orgName
         if self._ownerName is not None:
             result["ownerName"] = \
                 self._ownerName
-        if self._privacy is not None:
-            result["privacy"] = \
-                self._privacy
         if self._productNames is not None:
             result["productNames"] = \
                 self._productNames
         if self._publisher is not None:
             result["publisher"] = \
                 self._publisher
-        if self._safetyAndSecurity is not None:
-            result["safetyAndSecurity"] = \
-                self._safetyAndSecurity
         if self._shortDescription is not None:
             result["shortDescription"] = \
                 self._shortDescription
+        if self._size is not None:
+            result["size"] = \
+                self._size
         if self._teamName is not None:
             result["teamName"] = \
                 self._teamName
         if self._updatedDate is not None:
             result["updatedDate"] = \
                 self._updatedDate
         return result
@@ -701,25 +552,30 @@
     def isValid(self):
         if (self._createdDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._createdDate)):
             raise ValueError(
-                "Artifact.createdDate: " + str(self._createdDate) + 
+                "Collection.createdDate: " + str(self._createdDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         if (self._updatedDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._updatedDate)):
             raise ValueError(
-                "Artifact.updatedDate: " + str(self._updatedDate) + 
+                "Collection.updatedDate: " + str(self._updatedDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if self._category is None:
+            raise ValueError(
+                "Collection.category doesnt match requirement:" 
+                "required: True"
+            )
         if (self._attributes is not None):
             for obj in self._attributes:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactAttribute.py` & `ngcbpc/data/model/DeploymentGpuParametersMeta.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,102 +6,95 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .CountableResource import CountableResource
+from .EnumerableResource import EnumerableResource
 
 # Unused import over optimization prevention
+str(repr(CountableResource))
+str(repr(EnumerableResource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactAttribute(object):
-    """Attribute on the artifact"""
+class DeploymentGpuParametersMeta(object):
+    """Cloud Service Provider Deployment GPU Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.key = (
+        self.count = (
             None if not fromDict or propDict.get(
-                "key"
+                "count"
             ) is None
-            else propDict["key"])
-        self.value = (
+            else propDict["count"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "value"
+                "type"
             ) is None
-            else propDict["value"])
+            else propDict["type"])
 
     @property
-    def key(self):
-        """ """
-        return self._key
-
-    @key.setter
-    def key(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._key = value
+    def count(self):
+        """CountableResource: Countable Resource object"""
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, CountableResource):
+            value = CountableResource(value)
+        if (value is None) or isinstance(value, CountableResource):
+            self._count = value
         else:
             raise TypeError(
-                'Property "key" of type "list<str>" set to wrong type'
+                'Property "count" of type "list<CountableResource>" set to wr'
+                'ong type'
             )
 
     @property
-    def value(self):
-        """ """
-        return self._value
-
-    @value.setter
-    def value(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._value = value
+    def type(self):
+        """EnumerableResource: Enumerable Resource object"""
+        return self._type
+
+    @type.setter
+    def type(self, value):
+        if value is not None and not isinstance(value, EnumerableResource):
+            value = EnumerableResource(value)
+        if (value is None) or isinstance(value, EnumerableResource):
+            self._type = value
         else:
             raise TypeError(
-                'Property "value" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<EnumerableResource>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
-        if self._key is not None:
-            result["key"] = \
-                self._key
-        if self._value is not None:
-            result["value"] = \
-                self._value
+        if self._count:
+            result["count"] = \
+                self._count.toDict() if self._count is not None else None
+        if self._type:
+            result["type"] = \
+                self._type.toDict() if self._type is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._key is not None
-            and
-            len(self._key) > 255):
+        if self._type is None:
             raise ValueError(
-                "ArtifactAttribute.key: " + str(self._key) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._key is not None
-            and
-            not re.match(
-                r"[a-zA-Z0-9]+",
-                 self._key)):
-            raise ValueError(
-                "ArtifactAttribute.key: " + str(self._key) + 
-                " doesnt match requirement: pattern: [a-zA-Z0-9]+")
-        if (self._value is not None
-            and
-            len(self._value) > 255):
-            raise ValueError(
-                "ArtifactAttribute.value: " + str(self._value) + 
-                " doesnt match requirement: maxLength: 255")
+                "DeploymentGpuParametersMeta.type doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._count is not None): self._count.isValid()
+        if (self._type is not None): self._type.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactCatalogFlags.py` & `ngcbpc/data/model/ArtifactCatalogFlags.py`

 * *Files identical despite different names*

## Comparing `ngccli/data/model/ArtifactCreateRequest.py` & `organization/data/subscription_management_service/AzureMarketplaceSubscription.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,447 +6,483 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
+from .AzureMarketplaceSubscriptionTerm import AzureMarketplaceSubscriptionTerm
+from .AzureMarketplaceSubscriptionUser import AzureMarketplaceSubscriptionUser
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
+str(repr(AzureMarketplaceSubscriptionTerm))
+str(repr(AzureMarketplaceSubscriptionUser))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactCreateRequest(object):
-    """Request to create a new artifact"""
+class AzureMarketplaceSubscription(object):
+    """Subscription Object in AzureMarketplace-webhook-event"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.allowedCustomerOperations = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "allowedCustomerOperations"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.bias = (
+            else propDict["allowedCustomerOperations"])
+        self.autoRenew = (
             None if not fromDict or propDict.get(
-                "bias"
+                "autoRenew"
             ) is None
-            else propDict["bias"])
-        self.builtBy = (
+            else propDict["autoRenew"])
+        self.beneficiary = (
             None if not fromDict or propDict.get(
-                "builtBy"
+                "beneficiary"
             ) is None
-            else propDict["builtBy"])
-        self.description = (
+            else propDict["beneficiary"])
+        self.created = (
             None if not fromDict or propDict.get(
-                "description"
+                "created"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else propDict["created"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "id"
             ) is None
-            else propDict["displayName"])
-        self.explainability = (
+            else propDict["id"])
+        self.isFreeTrial = (
             None if not fromDict or propDict.get(
-                "explainability"
+                "isFreeTrial"
             ) is None
-            else propDict["explainability"])
-        self.labels = (
+            else propDict["isFreeTrial"])
+        self.isTest = (
             None if not fromDict or propDict.get(
-                "labels"
+                "isTest"
             ) is None
-            else propDict["labels"])
-        self.labelsV2 = (
+            else propDict["isTest"])
+        self.lastModified = (
             None if not fromDict or propDict.get(
-                "labelsV2"
+                "lastModified"
             ) is None
-            else propDict["labelsV2"])
-        self.logo = (
-            None if not fromDict or propDict.get(
-                "logo"
-            ) is None
-            else propDict["logo"])
+            else propDict["lastModified"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.privacy = (
+        self.offerId = (
+            None if not fromDict or propDict.get(
+                "offerId"
+            ) is None
+            else propDict["offerId"])
+        self.planId = (
+            None if not fromDict or propDict.get(
+                "planId"
+            ) is None
+            else propDict["planId"])
+        self.publisherId = (
+            None if not fromDict or propDict.get(
+                "publisherId"
+            ) is None
+            else propDict["publisherId"])
+        self.purchaser = (
+            None if not fromDict or propDict.get(
+                "purchaser"
+            ) is None
+            else propDict["purchaser"])
+        self.quantity = (
+            None if not fromDict or propDict.get(
+                "quantity"
+            ) is None
+            else propDict["quantity"])
+        self.saasSubscriptionStatus = (
             None if not fromDict or propDict.get(
-                "privacy"
+                "saasSubscriptionStatus"
             ) is None
-            else propDict["privacy"])
-        self.publisher = (
+            else propDict["saasSubscriptionStatus"])
+        self.sandboxType = (
             None if not fromDict or propDict.get(
-                "publisher"
+                "sandboxType"
             ) is None
-            else propDict["publisher"])
-        self.safetyAndSecurity = (
+            else propDict["sandboxType"])
+        self.sessionMode = (
             None if not fromDict or propDict.get(
-                "safetyAndSecurity"
+                "sessionMode"
             ) is None
-            else propDict["safetyAndSecurity"])
-        self.shortDescription = (
+            else propDict["sessionMode"])
+        self.term = (
             None if not fromDict or propDict.get(
-                "shortDescription"
+                "term"
             ) is None
-            else propDict["shortDescription"])
+            else propDict["term"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def allowedCustomerOperations(self):
+        """list: array of allowed customer operations"""
+        return self._allowedCustomerOperations
 
-    @attributes.setter
-    def attributes(self, value):
+    @allowedCustomerOperations.setter
+    def allowedCustomerOperations(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._attributes = value
+            self._allowedCustomerOperations = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "allowedCustomerOperations" of type "list<str>" set'
+                ' to wrong type'
             )
 
     @property
-    def bias(self):
-        """str: Text describing bias in the model"""
-        return self._bias
+    def autoRenew(self):
+        """bool: is auto-renew or not"""
+        return self._autoRenew
 
-    @bias.setter
-    def bias(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._bias = value
+    @autoRenew.setter
+    def autoRenew(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._autoRenew = value
         else:
             raise TypeError(
-                'Property "bias" of type "list<str>" set to wrong type'
+                'Property "autoRenew" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def builtBy(self):
-        """str: organization that built the artifact"""
-        return self._builtBy
+    def beneficiary(self):
+        """AzureMarketplaceSubscriptionUser: Subscription User Object in Azure
+        Marketplace-webhook-event"""
+        return self._beneficiary
 
-    @builtBy.setter
-    def builtBy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._builtBy = value
+    @beneficiary.setter
+    def beneficiary(self, value):
+        if value is not None and not isinstance(value, AzureMarketplaceSubscriptionUser):
+            value = AzureMarketplaceSubscriptionUser(value)
+        if (value is None) or isinstance(value, AzureMarketplaceSubscriptionUser):
+            self._beneficiary = value
         else:
             raise TypeError(
-                'Property "builtBy" of type "list<str>" set to wrong type'
+                'Property "beneficiary" of type "list<AzureMarketplaceSubscri'
+                'ptionUser>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the artifact"""
-        return self._description
+    def created(self):
+        """str: creation timestamp of the subscription"""
+        return self._created
 
-    @description.setter
-    def description(self, value):
+    @created.setter
+    def created(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._created = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "created" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name"""
-        return self._displayName
+    def id(self):
+        """str: id of the azure subscription"""
+        return self._id
 
-    @displayName.setter
-    def displayName(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def explainability(self):
-        """str: Text describing explainability for this model"""
-        return self._explainability
+    def isFreeTrial(self):
+        """bool: is free trial or not"""
+        return self._isFreeTrial
 
-    @explainability.setter
-    def explainability(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._explainability = value
+    @isFreeTrial.setter
+    def isFreeTrial(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isFreeTrial = value
         else:
             raise TypeError(
-                'Property "explainability" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "isFreeTrial" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def labels(self):
-        """ """
-        return self._labels
+    def isTest(self):
+        """bool: is test subscription or not"""
+        return self._isTest
 
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labels = value
+    @isTest.setter
+    def isTest(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isTest = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
+                'Property "isTest" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def labelsV2(self):
-        """ """
-        return self._labelsV2
+    def lastModified(self):
+        """str: last modified timestamp of the subscription"""
+        return self._lastModified
 
-    @labelsV2.setter
-    def labelsV2(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labelsV2 = value
-        else:
-            raise TypeError(
-                'Property "labelsV2" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
-
-    @logo.setter
-    def logo(self, value):
+    @lastModified.setter
+    def lastModified(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logo = value
+            self._lastModified = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "lastModified" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
     def name(self):
-        """str: Unique name of the artifact"""
+        """str: name of the azure subscription"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def privacy(self):
-        """str: Text describing the privacy for this model"""
-        return self._privacy
+    def offerId(self):
+        """str: id of the Azure marketplace offer"""
+        return self._offerId
 
-    @privacy.setter
-    def privacy(self, value):
+    @offerId.setter
+    def offerId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._privacy = value
+            self._offerId = value
         else:
             raise TypeError(
-                'Property "privacy" of type "list<str>" set to wrong type'
+                'Property "offerId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def publisher(self):
-        """str: organization that published the artifact"""
-        return self._publisher
+    def planId(self):
+        """str: plan id of the Azure marketplace offer"""
+        return self._planId
 
-    @publisher.setter
-    def publisher(self, value):
+    @planId.setter
+    def planId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._publisher = value
+            self._planId = value
         else:
             raise TypeError(
-                'Property "publisher" of type "list<str>" set to wrong type'
+                'Property "planId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def safetyAndSecurity(self):
-        """str: Text for describing the safety and security in the model"""
-        return self._safetyAndSecurity
+    def publisherId(self):
+        """str: publisher id of the azure subscription in Azure marketplace"""
+        return self._publisherId
 
-    @safetyAndSecurity.setter
-    def safetyAndSecurity(self, value):
+    @publisherId.setter
+    def publisherId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._safetyAndSecurity = value
+            self._publisherId = value
         else:
             raise TypeError(
-                'Property "safetyAndSecurity" of type "list<str>" set to wron'
-                'g type'
+                'Property "publisherId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shortDescription(self):
-        """str: Short description of the artifact"""
-        return self._shortDescription
+    def purchaser(self):
+        """AzureMarketplaceSubscriptionUser: Subscription User Object in Azure
+        Marketplace-webhook-event"""
+        return self._purchaser
 
-    @shortDescription.setter
-    def shortDescription(self, value):
+    @purchaser.setter
+    def purchaser(self, value):
+        if value is not None and not isinstance(value, AzureMarketplaceSubscriptionUser):
+            value = AzureMarketplaceSubscriptionUser(value)
+        if (value is None) or isinstance(value, AzureMarketplaceSubscriptionUser):
+            self._purchaser = value
+        else:
+            raise TypeError(
+                'Property "purchaser" of type "list<AzureMarketplaceSubscript'
+                'ionUser>" set to wrong type'
+            )
+
+    @property
+    def quantity(self):
+        """int: quantity in the azure subscription"""
+        return self._quantity
+
+    @quantity.setter
+    def quantity(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._quantity = value
+        else:
+            raise TypeError(
+                'Property "quantity" of type "list<int>" set to wrong type'
+            )
+
+    @property
+    def saasSubscriptionStatus(self):
+        """str: status of the Azure Marketplace SaaS subscription"""
+        return self._saasSubscriptionStatus
+
+    @saasSubscriptionStatus.setter
+    def saasSubscriptionStatus(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._saasSubscriptionStatus = value
+        else:
+            raise TypeError(
+                'Property "saasSubscriptionStatus" of type "list<str>" set to'
+                ' wrong type'
+            )
+
+    @property
+    def sandboxType(self):
+        """str: sandboxType"""
+        return self._sandboxType
+
+    @sandboxType.setter
+    def sandboxType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shortDescription = value
+            self._sandboxType = value
+        else:
+            raise TypeError(
+                'Property "sandboxType" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def sessionMode(self):
+        """str: sessionMode"""
+        return self._sessionMode
+
+    @sessionMode.setter
+    def sessionMode(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._sessionMode = value
+        else:
+            raise TypeError(
+                'Property "sessionMode" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def term(self):
+        """AzureMarketplaceSubscriptionTerm: Subscription Term Object in Azure
+        Marketplace-webhook-event"""
+        return self._term
+
+    @term.setter
+    def term(self, value):
+        if value is not None and not isinstance(value, AzureMarketplaceSubscriptionTerm):
+            value = AzureMarketplaceSubscriptionTerm(value)
+        if (value is None) or isinstance(value, AzureMarketplaceSubscriptionTerm):
+            self._term = value
         else:
             raise TypeError(
-                'Property "shortDescription" of type "list<str>" set to wrong'
-                ' type'
+                'Property "term" of type "list<AzureMarketplaceSubscriptionTe'
+                'rm>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._bias is not None:
-            result["bias"] = \
-                self._bias
-        if self._builtBy is not None:
-            result["builtBy"] = \
-                self._builtBy
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._explainability is not None:
-            result["explainability"] = \
-                self._explainability
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._labelsV2 is not None:
-            result["labelsV2"] = \
-                self._labelsV2
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
+        if self._allowedCustomerOperations is not None:
+            result["allowedCustomerOperations"] = \
+                self._allowedCustomerOperations
+        if self._autoRenew is not None:
+            result["autoRenew"] = \
+                self._autoRenew
+        if self._beneficiary:
+            result["beneficiary"] = \
+                self._beneficiary.toDict() if self._beneficiary is not None else None
+        if self._created is not None:
+            result["created"] = \
+                self._created
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._isFreeTrial is not None:
+            result["isFreeTrial"] = \
+                self._isFreeTrial
+        if self._isTest is not None:
+            result["isTest"] = \
+                self._isTest
+        if self._lastModified is not None:
+            result["lastModified"] = \
+                self._lastModified
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._privacy is not None:
-            result["privacy"] = \
-                self._privacy
-        if self._publisher is not None:
-            result["publisher"] = \
-                self._publisher
-        if self._safetyAndSecurity is not None:
-            result["safetyAndSecurity"] = \
-                self._safetyAndSecurity
-        if self._shortDescription is not None:
-            result["shortDescription"] = \
-                self._shortDescription
+        if self._offerId is not None:
+            result["offerId"] = \
+                self._offerId
+        if self._planId is not None:
+            result["planId"] = \
+                self._planId
+        if self._publisherId is not None:
+            result["publisherId"] = \
+                self._publisherId
+        if self._purchaser:
+            result["purchaser"] = \
+                self._purchaser.toDict() if self._purchaser is not None else None
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
+        if self._saasSubscriptionStatus is not None:
+            result["saasSubscriptionStatus"] = \
+                self._saasSubscriptionStatus
+        if self._sandboxType is not None:
+            result["sandboxType"] = \
+                self._sandboxType
+        if self._sessionMode is not None:
+            result["sessionMode"] = \
+                self._sessionMode
+        if self._term:
+            result["term"] = \
+                self._term.toDict() if self._term is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "ArtifactCreateRequest.name doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._name is not None
-            and
-            len(self._name) < 1):
-            raise ValueError(
-                "ArtifactCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._name is not None
-            and
-            len(self._name) > 64):
-            raise ValueError(
-                "ArtifactCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._name is not None
-            and
-            not re.match(
-                r"^[a-z][a-z\d_-]*$",
-                 self._name)):
-            raise ValueError(
-                "ArtifactCreateRequest.name: " + str(self._name) + 
-                " doesnt match requirement: pattern: ^[a-z][a-z\d_-]*$")
-        if self._shortDescription is None:
-            raise ValueError(
-                "ArtifactCreateRequest.shortDescription doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._shortDescription is not None
-            and
-            len(self._shortDescription) > 255):
-            raise ValueError(
-                "ArtifactCreateRequest.shortDescription: " + str(self._shortDescription) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._displayName is not None
-            and
-            len(self._displayName) < 2):
-            raise ValueError(
-                "ArtifactCreateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 64):
-            raise ValueError(
-                "ArtifactCreateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._logo is not None
-            and
-            len(self._logo) > 255):
-            raise ValueError(
-                "ArtifactCreateRequest.logo: " + str(self._logo) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._builtBy is not None
-            and
-            len(self._builtBy) > 255):
-            raise ValueError(
-                "ArtifactCreateRequest.builtBy: " + str(self._builtBy) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._publisher is not None
-            and
-            len(self._publisher) > 255):
-            raise ValueError(
-                "ArtifactCreateRequest.publisher: " + str(self._publisher) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
+        if (self._beneficiary is not None): self._beneficiary.isValid()
+        if (self._purchaser is not None): self._purchaser.isValid()
+        if (self._term is not None): self._term.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactDeploymentParameters.py` & `ngcbpc/data/model/DeploymentParametersUpdateRequest.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,51 +6,46 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DeploymentMemoryParameters import DeploymentMemoryParameters
 from .DeploymentArtifactParameters import DeploymentArtifactParameters
 from .DeploymentStorageParameters import DeploymentStorageParameters
-from .DeploymentCpuParameters import DeploymentCpuParameters
 from .DeploymentGpuParameters import DeploymentGpuParameters
+from .DeploymentMemoryParameters import DeploymentMemoryParameters
+from .DeploymentCpuParameters import DeploymentCpuParameters
 
 # Unused import over optimization prevention
-str(repr(DeploymentArtifactParameters))
-str(repr(DeploymentGpuParameters))
 str(repr(DeploymentMemoryParameters))
-str(repr(DeploymentStorageParameters))
+str(repr(DeploymentGpuParameters))
 str(repr(DeploymentCpuParameters))
+str(repr(DeploymentArtifactParameters))
+str(repr(DeploymentStorageParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactDeploymentParameters(object):
-    """Artifact Deployment Parameters object"""
+class DeploymentParametersUpdateRequest(object):
+    """Request to update existing deployment parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.container = (
             None if not fromDict or propDict.get(
                 "container"
             ) is None
             else propDict["container"])
         self.cpu = (
             None if not fromDict or propDict.get(
                 "cpu"
             ) is None
             else propDict["cpu"])
-        self.csp = (
-            None if not fromDict or propDict.get(
-                "csp"
-            ) is None
-            else propDict["csp"])
         self.gpu = (
             None if not fromDict or propDict.get(
                 "gpu"
             ) is None
             else propDict["gpu"])
         self.memory = (
             None if not fromDict or propDict.get(
@@ -105,30 +100,14 @@
         else:
             raise TypeError(
                 'Property "cpu" of type "list<DeploymentCpuParameters>" set t'
                 'o wrong type'
             )
 
     @property
-    def csp(self):
-        """str: Cloud Service Provider name"""
-        return self._csp
-
-    @csp.setter
-    def csp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._csp = value
-        else:
-            raise TypeError(
-                'Property "csp" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def gpu(self):
         """DeploymentGpuParameters: Deployment GPU Parameters object"""
         return self._gpu
 
     @gpu.setter
     def gpu(self, value):
         if value is not None and not isinstance(value, DeploymentGpuParameters):
@@ -216,17 +195,14 @@
         result = {}
         if self._container:
             result["container"] = \
                 self._container.toDict() if self._container is not None else None
         if self._cpu:
             result["cpu"] = \
                 self._cpu.toDict() if self._cpu is not None else None
-        if self._csp is not None:
-            result["csp"] = \
-                self._csp
         if self._gpu:
             result["gpu"] = \
                 self._gpu.toDict() if self._gpu is not None else None
         if self._memory:
             result["memory"] = \
                 self._memory.toDict() if self._memory is not None else None
         if self._model:
```

## Comparing `ngccli/data/model/ArtifactDownloadAllRequest.py` & `ngcbpc/data/model/ArtifactDownloadRequest.py`

 * *Files 16% similar despite different names*

```diff
@@ -14,23 +14,28 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactDownloadAllRequest(object):
-    """Request to download all files of an artifact"""
+class ArtifactDownloadRequest(object):
+    """Request to download a single file of an artifact"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.artifactType = (
             None if not fromDict or propDict.get(
                 "artifactType"
             ) is None
             else propDict["artifactType"])
+        self.filePath = (
+            None if not fromDict or propDict.get(
+                "filePath"
+            ) is None
+            else propDict["filePath"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
         self.version = (
             None if not fromDict or propDict.get(
@@ -52,14 +57,30 @@
         else:
             raise TypeError(
                 'Property "artifactType" of type "list<str>" set to wrong typ'
                 'e'
             )
 
     @property
+    def filePath(self):
+        """str: The file path of the artifact"""
+        return self._filePath
+
+    @filePath.setter
+    def filePath(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._filePath = value
+        else:
+            raise TypeError(
+                'Property "filePath" of type "list<str>" set to wrong type'
+            )
+
+    @property
     def name(self):
         """str: Name of the artifact"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
@@ -88,14 +109,17 @@
             )
 
     def toDict(self):
         result = {}
         if self._artifactType is not None:
             result["artifactType"] = \
                 self._artifactType
+        if self._filePath is not None:
+            result["filePath"] = \
+                self._filePath
         if self._name is not None:
             result["name"] = \
                 self._name
         if self._version is not None:
             result["version"] = \
                 self._version
         return result
@@ -105,23 +129,28 @@
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if self._name is None:
             raise ValueError(
-                "ArtifactDownloadAllRequest.name doesnt match requirement:" 
+                "ArtifactDownloadRequest.name doesnt match requirement:" 
                 "required: True"
             )
         if self._version is None:
             raise ValueError(
-                "ArtifactDownloadAllRequest.version doesnt match requirement:" 
+                "ArtifactDownloadRequest.version doesnt match requirement:" 
                 "required: True"
             )
         if self._artifactType is None:
             raise ValueError(
-                "ArtifactDownloadAllRequest.artifactType doesnt match requirement:" 
+                "ArtifactDownloadRequest.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._filePath is None:
+            raise ValueError(
+                "ArtifactDownloadRequest.filePath doesnt match requirement:" 
                 "required: True"
             )
         return True
```

## Comparing `ngccli/data/model/ArtifactDownloadAllResponse.py` & `ngcbpc/data/model/ArtifactDownloadAllResponse.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -6,16 +6,16 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
 str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
```

## Comparing `ngccli/data/model/ArtifactDownloadRequest.py` & `organization/data/subscription_management_service/ProductOffer.py`

 * *Files 17% similar despite different names*

```diff
@@ -14,143 +14,146 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactDownloadRequest(object):
-    """Request to download a single file of an artifact"""
+class ProductOffer(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactType = (
+        self.canRedeem = (
             None if not fromDict or propDict.get(
-                "artifactType"
+                "canRedeem"
             ) is None
-            else propDict["artifactType"])
-        self.filePath = (
+            else propDict["canRedeem"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "filePath"
+                "displayName"
             ) is None
-            else propDict["filePath"])
+            else propDict["displayName"])
+        self.imageUrl = (
+            None if not fromDict or propDict.get(
+                "imageUrl"
+            ) is None
+            else propDict["imageUrl"])
         self.name = (
             None if not fromDict or propDict.get(
                 "name"
             ) is None
             else propDict["name"])
-        self.version = (
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "version"
+                "shortDescription"
             ) is None
-            else propDict["version"])
+            else propDict["shortDescription"])
 
     @property
-    def artifactType(self):
-        """str: Type of artifact"""
-        return self._artifactType
+    def canRedeem(self):
+        """ """
+        return self._canRedeem
+
+    @canRedeem.setter
+    def canRedeem(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canRedeem = value
+        else:
+            raise TypeError(
+                'Property "canRedeem" of type "list<bool>" set to wrong type'
+            )
 
-    @artifactType.setter
-    def artifactType(self, value):
+    @property
+    def displayName(self):
+        """str: display name of the product offer"""
+        return self._displayName
+
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._artifactType = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "artifactType" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def filePath(self):
-        """str: The file path of the artifact"""
-        return self._filePath
+    def imageUrl(self):
+        """str: link of the image for the offer"""
+        return self._imageUrl
 
-    @filePath.setter
-    def filePath(self, value):
+    @imageUrl.setter
+    def imageUrl(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._filePath = value
+            self._imageUrl = value
         else:
             raise TypeError(
-                'Property "filePath" of type "list<str>" set to wrong type'
+                'Property "imageUrl" of type "list<str>" set to wrong type'
             )
 
     @property
     def name(self):
-        """str: Name of the artifact"""
+        """str: name of the product offer"""
         return self._name
 
     @name.setter
     def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._name = value
         else:
             raise TypeError(
                 'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def version(self):
-        """str: Artifact version"""
-        return self._version
+    def shortDescription(self):
+        """str: short description of the product offer"""
+        return self._shortDescription
 
-    @version.setter
-    def version(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
-        if self._filePath is not None:
-            result["filePath"] = \
-                self._filePath
+        if self._canRedeem is not None:
+            result["canRedeem"] = \
+                self._canRedeem
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._imageUrl is not None:
+            result["imageUrl"] = \
+                self._imageUrl
         if self._name is not None:
             result["name"] = \
                 self._name
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "ArtifactDownloadRequest.name doesnt match requirement:" 
-                "required: True"
-            )
-        if self._version is None:
-            raise ValueError(
-                "ArtifactDownloadRequest.version doesnt match requirement:" 
-                "required: True"
-            )
-        if self._artifactType is None:
-            raise ValueError(
-                "ArtifactDownloadRequest.artifactType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._filePath is None:
-            raise ValueError(
-                "ArtifactDownloadRequest.filePath doesnt match requirement:" 
-                "required: True"
-            )
         return True
```

## Comparing `ngccli/data/model/ArtifactDownloadResponse.py` & `basecommand/data/pym/ClusterSuccessResponse.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,115 +6,96 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .RequestStatus import RequestStatus
+from .ClusterRequestStatus import ClusterRequestStatus
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
+str(repr(ClusterRequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactDownloadResponse(object):
-    """Response body to download a single file of an artifact"""
+class ClusterSuccessResponse(object):
+    """Cluster Success Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.filepath = (
+        self.clusterStatus = (
             None if not fromDict or propDict.get(
-                "filepath"
+                "clusterStatus"
             ) is None
-            else propDict["filepath"])
-        self.requestStatus = (
+            else propDict["clusterStatus"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "version"
             ) is None
-            else propDict["requestStatus"])
-        self.url = (
-            None if not fromDict or propDict.get(
-                "url"
-            ) is None
-            else propDict["url"])
-
-    @property
-    def filepath(self):
-        """str: The filepath of the artifact"""
-        return self._filepath
-
-    @filepath.setter
-    def filepath(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._filepath = value
-        else:
-            raise TypeError(
-                'Property "filepath" of type "list<str>" set to wrong type'
-            )
+            else propDict["version"])
 
     @property
-    def requestStatus(self):
-        """RequestStatus: Request status information"""
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def clusterStatus(self):
+        """ClusterRequestStatus: Cluster Request status"""
+        return self._clusterStatus
+
+    @clusterStatus.setter
+    def clusterStatus(self, value):
+        if value is not None and not isinstance(value, ClusterRequestStatus):
+            value = ClusterRequestStatus(value)
+        if (value is None) or isinstance(value, ClusterRequestStatus):
+            self._clusterStatus = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "clusterStatus" of type "list<ClusterRequestStatus>'
+                '" set to wrong type'
             )
 
     @property
-    def url(self):
-        """str: Presigned url for single file download"""
-        return self._url
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @url.setter
-    def url(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._url = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "url" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._filepath is not None:
-            result["filepath"] = \
-                self._filepath
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._url is not None:
-            result["url"] = \
-                self._url
+        if self._clusterStatus:
+            result["clusterStatus"] = \
+                self._clusterStatus.toDict() if self._clusterStatus is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._url is None:
+        if self._version is None:
+            raise ValueError(
+                "ClusterSuccessResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._clusterStatus is None:
             raise ValueError(
-                "ArtifactDownloadResponse.url doesnt match requirement:" 
+                "ClusterSuccessResponse.clusterStatus doesnt match requirement:" 
                 "required: True"
             )
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._clusterStatus is not None): self._clusterStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactEvent.py` & `ngcbpc/data/registry/ManifestListByTagV2Response.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,166 +6,144 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactTypeEnum import ArtifactTypeEnum
+from .PlatformManifest import PlatformManifest
 
 # Unused import over optimization prevention
-str(repr(ArtifactTypeEnum))
+str(repr(PlatformManifest))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactEvent(object):
-    """This event in the topic means that some change happened to the artifact
-    """
+class ManifestListByTagV2Response(object):
+    """Multi-CPU architecture v2 manifest list. Media type: application/vnd.do
+    cker.distribution.manifest.list.v2+json. See: https://github.com/docke
+    r/distribution/blob/master/docs/spec/manifest-v2-2.md"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactType = (
+        self.digest = (
             None if not fromDict or propDict.get(
-                "artifactType"
+                "digest"
             ) is None
-            else propDict["artifactType"])
-        self.eventType = (
+            else propDict["digest"])
+        self.manifests = (
             None if not fromDict or propDict.get(
-                "eventType"
+                "manifests"
             ) is None
-            else propDict["eventType"])
-        self.name = (
+            else [ PlatformManifest(i)
+            for i in propDict["manifests"] ])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "name"
+                "mediaType"
             ) is None
-            else propDict["name"])
-        self.namespace = (
+            else propDict["mediaType"])
+        self.schemaVersion = (
             None if not fromDict or propDict.get(
-                "namespace"
+                "schemaVersion"
             ) is None
-            else propDict["namespace"])
+            else propDict["schemaVersion"])
 
     @property
-    def artifactType(self):
-        """ArtifactTypeEnum: Artifact type"""
-        return self._artifactType
-
-    @artifactType.setter
-    def artifactType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._artifactType = value
+    def digest(self):
+        """str: Digest of the manifest. Note: this field is not part the appli
+        cation/vnd.docker.distribution.manifest.list.v2+json schema de
+        finition"""
+        return self._digest
+
+    @digest.setter
+    def digest(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._digest = value
         else:
             raise TypeError(
-                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
-                ' to wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def eventType(self):
-        """EventTypeEnum: Artifact event type"""
-        return self._eventType
-
-    @eventType.setter
-    def eventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._eventType = value
+    def manifests(self):
+        """ """
+        return self._manifests
+
+    @manifests.setter
+    def manifests(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._manifests = value
         else:
             raise TypeError(
-                'Property "eventType" of type "list<EventTypeEnum>" set to wr'
-                'ong type'
+                'Property "manifests" of type "list<PlatformManifest>" set to'
+                ' wrong type'
             )
 
-    EventTypeEnum=["CREATED","UPDATED","DELETED","UNPUBLISHED",]
-    str(repr(EventTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def name(self):
-        """str: Artifact name"""
-        return self._name
+    def mediaType(self):
+        """str: defines version. must be 'application/vnd.docker.distribution.
+        manifest.list.v2+json'"""
+        return self._mediaType
 
-    @name.setter
-    def name(self, value):
+    @mediaType.setter
+    def mediaType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def namespace(self):
-        """str: Artifact namespace"""
-        return self._namespace
-
-    @namespace.setter
-    def namespace(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._namespace = value
+    def schemaVersion(self):
+        """int: Response schema version"""
+        return self._schemaVersion
+
+    @schemaVersion.setter
+    def schemaVersion(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schemaVersion = value
         else:
             raise TypeError(
-                'Property "namespace" of type "list<str>" set to wrong type'
+                'Property "schemaVersion" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
-        if self._eventType is not None:
-            result["eventType"] = \
-                self._eventType
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._namespace is not None:
-            result["namespace"] = \
-                self._namespace
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._manifests:
+            result["manifests"] = [
+                i.toDict() for i in self._manifests 
+            ] if self._manifests else []
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._schemaVersion is not None:
+            result["schemaVersion"] = \
+                self._schemaVersion
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._namespace is None:
-            raise ValueError(
-                "ArtifactEvent.namespace doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._namespace is not None
-            and
-            len(self._namespace) > 255):
-            raise ValueError(
-                "ArtifactEvent.namespace: " + str(self._namespace) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._name is None:
-            raise ValueError(
-                "ArtifactEvent.name doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._name is not None
-            and
-            len(self._name) > 255):
-            raise ValueError(
-                "ArtifactEvent.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
-        if self._artifactType is None:
-            raise ValueError(
-                "ArtifactEvent.artifactType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._eventType is None:
-            raise ValueError(
-                "ArtifactEvent.eventType doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._manifests is not None):
+            for obj in self._manifests:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactListResponse.py` & `organization/data/subscription_management_service/PreviewOrderRequest.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,122 +6,117 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Artifact import Artifact
-from .PaginationInfo import PaginationInfo
-from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(Artifact))
-str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactListResponse(object):
-    """Response to list artifacts request"""
+class PreviewOrderRequest(object):
+    """Preview order request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifacts = (
+        self.productName = (
             None if not fromDict or propDict.get(
-                "artifacts"
+                "productName"
             ) is None
-            else [ Artifact(i)
-            for i in propDict["artifacts"] ])
-        self.paginationInfo = (
+            else propDict["productName"])
+        self.productRatePlanSku = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "productRatePlanSku"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["productRatePlanSku"])
+        self.quantity = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "quantity"
             ) is None
-            else propDict["requestStatus"])
+            else propDict["quantity"])
 
     @property
-    def artifacts(self):
-        """ """
-        return self._artifacts
-
-    @artifacts.setter
-    def artifacts(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._artifacts = value
+    def productName(self):
+        """str: name of the product"""
+        return self._productName
+
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
         else:
             raise TypeError(
-                'Property "artifacts" of type "list<Artifact>" set to wrong t'
-                'ype'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def productRatePlanSku(self):
+        """str: product rate plan sku of the product"""
+        return self._productRatePlanSku
+
+    @productRatePlanSku.setter
+    def productRatePlanSku(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productRatePlanSku = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "productRatePlanSku" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def requestStatus(self):
-        """RequestStatus: Request status information"""
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def quantity(self):
+        """int: quantity selected for quantity based products"""
+        return self._quantity
+
+    @quantity.setter
+    def quantity(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._quantity = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "quantity" of type "list<int>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifacts:
-            result["artifacts"] = [
-                i.toDict() for i in self._artifacts 
-            ] if self._artifacts else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._productRatePlanSku is not None:
+            result["productRatePlanSku"] = \
+                self._productRatePlanSku
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._artifacts is not None):
-            for obj in self._artifacts:
-                if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if self._productName is None:
+            raise ValueError(
+                "PreviewOrderRequest.productName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._productRatePlanSku is None:
+            raise ValueError(
+                "PreviewOrderRequest.productRatePlanSku doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/model/ArtifactPublishRequest.py` & `ngcbpc/data/model/DeploymentUrlResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,160 +6,139 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AccessTypeEnum import AccessTypeEnum
-from .ProductNamesEnum import ProductNamesEnum
+from .RequestStatus import RequestStatus
+from .DeploymentParameters import DeploymentParameters
 
 # Unused import over optimization prevention
-str(repr(ProductNamesEnum))
-str(repr(AccessTypeEnum))
+str(repr(RequestStatus))
+str(repr(DeploymentParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactPublishRequest(object):
-    """Request to publish an artifact"""
+class DeploymentUrlResponse(object):
+    """Response to create a new deployment url"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accessType = (
+        self.csp = (
             None if not fromDict or propDict.get(
-                "accessType"
+                "csp"
             ) is None
-            else propDict["accessType"])
-        self.canGuestPull = (
+            else propDict["csp"])
+        self.deploymentParameters = (
             None if not fromDict or propDict.get(
-                "canGuestPull"
+                "deploymentParameters"
             ) is None
-            else propDict["canGuestPull"])
-        self.canPublicList = (
+            else propDict["deploymentParameters"])
+        self.deploymentUrl = (
             None if not fromDict or propDict.get(
-                "canPublicList"
+                "deploymentUrl"
             ) is None
-            else propDict["canPublicList"])
-        self.isPublic = (
+            else propDict["deploymentUrl"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "isPublic"
+                "requestStatus"
             ) is None
-            else propDict["isPublic"])
-        self.productNames = (
-            None if not fromDict or propDict.get(
-                "productNames"
-            ) is None
-            else propDict["productNames"])
+            else propDict["requestStatus"])
 
     @property
-    def accessType(self):
-        """ """
-        return self._accessType
-
-    @accessType.setter
-    def accessType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._accessType = value
+    def csp(self):
+        """str: Cloud Service Provider name"""
+        return self._csp
+
+    @csp.setter
+    def csp(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._csp = value
         else:
             raise TypeError(
-                'Property "accessType" of type "list<AccessTypeEnum>" set to '
-                'wrong type'
+                'Property "csp" of type "list<str>" set to wrong type'
             )
 
     @property
-    def canGuestPull(self):
-        """ """
-        return self._canGuestPull
-
-    @canGuestPull.setter
-    def canGuestPull(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canGuestPull = value
+    def deploymentParameters(self):
+        """DeploymentParameters: Deployment Artifact Parameters object"""
+        return self._deploymentParameters
+
+    @deploymentParameters.setter
+    def deploymentParameters(self, value):
+        if value is not None and not isinstance(value, DeploymentParameters):
+            value = DeploymentParameters(value)
+        if (value is None) or isinstance(value, DeploymentParameters):
+            self._deploymentParameters = value
         else:
             raise TypeError(
-                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "deploymentParameters" of type "list<DeploymentPara'
+                'meters>" set to wrong type'
             )
 
     @property
-    def canPublicList(self):
-        """ """
-        return self._canPublicList
-
-    @canPublicList.setter
-    def canPublicList(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canPublicList = value
+    def deploymentUrl(self):
+        """str: Deployment URL"""
+        return self._deploymentUrl
+
+    @deploymentUrl.setter
+    def deploymentUrl(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._deploymentUrl = value
         else:
             raise TypeError(
-                'Property "canPublicList" of type "list<bool>" set to wrong t'
-                'ype'
-            )
-
-    @property
-    def isPublic(self):
-        """ """
-        return self._isPublic
-
-    @isPublic.setter
-    def isPublic(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isPublic = value
-        else:
-            raise TypeError(
-                'Property "isPublic" of type "list<bool>" set to wrong type'
+                'Property "deploymentUrl" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def productNames(self):
-        """list: Product names"""
-        return self._productNames
-
-    @productNames.setter
-    def productNames(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productNames = value
+    def requestStatus(self):
+        """RequestStatus: Request status information"""
+        return self._requestStatus
+
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "productNames" of type "list<ProductNamesEnum>" set'
-                ' to wrong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accessType is not None:
-            result["accessType"] = \
-                self._accessType
-        if self._canGuestPull is not None:
-            result["canGuestPull"] = \
-                self._canGuestPull
-        if self._canPublicList is not None:
-            result["canPublicList"] = \
-                self._canPublicList
-        if self._isPublic is not None:
-            result["isPublic"] = \
-                self._isPublic
-        if self._productNames is not None:
-            result["productNames"] = \
-                self._productNames
+        if self._csp is not None:
+            result["csp"] = \
+                self._csp
+        if self._deploymentParameters:
+            result["deploymentParameters"] = \
+                self._deploymentParameters.toDict() if self._deploymentParameters is not None else None
+        if self._deploymentUrl is not None:
+            result["deploymentUrl"] = \
+                self._deploymentUrl
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._deploymentParameters is not None): self._deploymentParameters.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactResponse.py` & `ngcbpc/data/uis/RoleScopesRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,90 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Artifact import Artifact
-from .RequestStatus import RequestStatus
+from .RoleScopes import RoleScopes
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(Artifact))
+str(repr(RoleScopes))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactResponse(object):
-    """Response to artifact request"""
+class RoleScopesRequest(object):
+    """Role Scopes Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifact = (
+        self.roleScopes = (
             None if not fromDict or propDict.get(
-                "artifact"
+                "roleScopes"
             ) is None
-            else propDict["artifact"])
-        self.requestStatus = (
-            None if not fromDict or propDict.get(
-                "requestStatus"
-            ) is None
-            else propDict["requestStatus"])
-
-    @property
-    def artifact(self):
-        """Artifact: Artifact object"""
-        return self._artifact
-
-    @artifact.setter
-    def artifact(self, value):
-        if value is not None and not isinstance(value, Artifact):
-            value = Artifact(value)
-        if (value is None) or isinstance(value, Artifact):
-            self._artifact = value
-        else:
-            raise TypeError(
-                'Property "artifact" of type "list<Artifact>" set to wrong ty'
-                'pe'
-            )
+            else [ RoleScopes(i)
+            for i in propDict["roleScopes"] ])
 
     @property
-    def requestStatus(self):
-        """RequestStatus: Request status information"""
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def roleScopes(self):
+        """list: A list of role scopes"""
+        return self._roleScopes
+
+    @roleScopes.setter
+    def roleScopes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roleScopes = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "roleScopes" of type "list<RoleScopes>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifact:
-            result["artifact"] = \
-                self._artifact.toDict() if self._artifact is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._roleScopes:
+            result["roleScopes"] = [
+                i.toDict() for i in self._roleScopes 
+            ] if self._roleScopes else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._artifact is not None): self._artifact.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._roleScopes is not None):
+            for obj in self._roleScopes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactUpdateRequest.py` & `ngcbpc/data/model/ModelVersion.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,393 +6,457 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .VersionStatusEnum import VersionStatusEnum
+from .CustomMetricGroup import CustomMetricGroup
 from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
+str(repr(CustomMetricGroup))
 str(repr(ArtifactAttribute))
+str(repr(VersionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactUpdateRequest(object):
-    """Request to update a artifact"""
+class ModelVersion(object):
+    """Model version object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.accuracyReached = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "accuracyReached"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.bias = (
+            else propDict["accuracyReached"])
+        self.batchSize = (
+            None if not fromDict or propDict.get(
+                "batchSize"
+            ) is None
+            else propDict["batchSize"])
+        self.createdByUser = (
+            None if not fromDict or propDict.get(
+                "createdByUser"
+            ) is None
+            else propDict["createdByUser"])
+        self.createdDate = (
             None if not fromDict or propDict.get(
-                "bias"
+                "createdDate"
             ) is None
-            else propDict["bias"])
-        self.builtBy = (
+            else propDict["createdDate"])
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "builtBy"
+                "customMetrics"
             ) is None
-            else propDict["builtBy"])
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.displayName = (
+        self.gpuModel = (
+            None if not fromDict or propDict.get(
+                "gpuModel"
+            ) is None
+            else propDict["gpuModel"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "id"
             ) is None
-            else propDict["displayName"])
-        self.explainability = (
+            else propDict["id"])
+        self.memoryFootprint = (
             None if not fromDict or propDict.get(
-                "explainability"
+                "memoryFootprint"
             ) is None
-            else propDict["explainability"])
-        self.labels = (
+            else propDict["memoryFootprint"])
+        self.numberOfEpochs = (
             None if not fromDict or propDict.get(
-                "labels"
+                "numberOfEpochs"
             ) is None
-            else propDict["labels"])
-        self.labelsV2 = (
+            else propDict["numberOfEpochs"])
+        self.otherContents = (
             None if not fromDict or propDict.get(
-                "labelsV2"
+                "otherContents"
             ) is None
-            else propDict["labelsV2"])
-        self.logo = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["otherContents"] ])
+        self.ownerName = (
             None if not fromDict or propDict.get(
-                "logo"
+                "ownerName"
             ) is None
-            else propDict["logo"])
-        self.privacy = (
+            else propDict["ownerName"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "privacy"
+                "status"
             ) is None
-            else propDict["privacy"])
-        self.publisher = (
+            else propDict["status"])
+        self.totalFileCount = (
             None if not fromDict or propDict.get(
-                "publisher"
+                "totalFileCount"
             ) is None
-            else propDict["publisher"])
-        self.safetyAndSecurity = (
+            else propDict["totalFileCount"])
+        self.totalSizeInBytes = (
             None if not fromDict or propDict.get(
-                "safetyAndSecurity"
+                "totalSizeInBytes"
             ) is None
-            else propDict["safetyAndSecurity"])
-        self.shortDescription = (
+            else propDict["totalSizeInBytes"])
+        self.versionId = (
             None if not fromDict or propDict.get(
-                "shortDescription"
+                "versionId"
             ) is None
-            else propDict["shortDescription"])
+            else propDict["versionId"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def accuracyReached(self):
+        """float: Accuracy this model reached"""
+        return self._accuracyReached
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    @accuracyReached.setter
+    def accuracyReached(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._accuracyReached = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "accuracyReached" of type "list<float>" set to wron'
+                'g type'
             )
 
     @property
-    def bias(self):
-        """str: Text describing bias in the model"""
-        return self._bias
+    def batchSize(self):
+        """long: Batch size this model was trained with"""
+        return self._batchSize
 
-    @bias.setter
-    def bias(self, value):
+    @batchSize.setter
+    def batchSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._batchSize = value
+        else:
+            raise TypeError(
+                'Property "batchSize" of type "list<long>" set to wrong type'
+            )
+
+    @property
+    def createdByUser(self):
+        """str: Id of the user who created this model"""
+        return self._createdByUser
+
+    @createdByUser.setter
+    def createdByUser(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._bias = value
+            self._createdByUser = value
         else:
             raise TypeError(
-                'Property "bias" of type "list<str>" set to wrong type'
+                'Property "createdByUser" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def builtBy(self):
-        """str: organization that built the artifact"""
-        return self._builtBy
+    def createdDate(self):
+        """str: Creation date in ISO-8601 format"""
+        return self._createdDate
 
-    @builtBy.setter
-    def builtBy(self, value):
+    @createdDate.setter
+    def createdDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._builtBy = value
+            self._createdDate = value
+        else:
+            raise TypeError(
+                'Property "createdDate" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
+
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
         else:
             raise TypeError(
-                'Property "builtBy" of type "list<str>" set to wrong type'
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the artifact"""
+        """str: Description of the model version"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name"""
-        return self._displayName
+    def gpuModel(self):
+        """str: GPU model and memory"""
+        return self._gpuModel
 
-    @displayName.setter
-    def displayName(self, value):
+    @gpuModel.setter
+    def gpuModel(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._gpuModel = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def explainability(self):
-        """str: Text describing explainability for this model"""
-        return self._explainability
+    def id(self):
+        """long: Deprecated: Please use versionId instead. Unique ID of the ve
+        rsion"""
+        return self._id
 
-    @explainability.setter
-    def explainability(self, value):
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
+        else:
+            raise TypeError(
+                'Property "id" of type "list<long>" set to wrong type'
+            )
+
+    @property
+    def memoryFootprint(self):
+        """str: Model size/memory footprint for inference"""
+        return self._memoryFootprint
+
+    @memoryFootprint.setter
+    def memoryFootprint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._explainability = value
+            self._memoryFootprint = value
         else:
             raise TypeError(
-                'Property "explainability" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "memoryFootprint" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def labels(self):
-        """ """
-        return self._labels
+    def numberOfEpochs(self):
+        """long: Number of epochs this model trained"""
+        return self._numberOfEpochs
 
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labels = value
+    @numberOfEpochs.setter
+    def numberOfEpochs(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._numberOfEpochs = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
+                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def labelsV2(self):
-        """ """
-        return self._labelsV2
+    def otherContents(self):
+        """list: List of external contents"""
+        return self._otherContents
 
-    @labelsV2.setter
-    def labelsV2(self, value):
+    @otherContents.setter
+    def otherContents(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._labelsV2 = value
+            self._otherContents = value
         else:
             raise TypeError(
-                'Property "labelsV2" of type "list<str>" set to wrong type'
+                'Property "otherContents" of type "list<ArtifactAttribute>" s'
+                'et to wrong type'
             )
 
     @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
+    def ownerName(self):
+        """str: Name of the user who owns this version"""
+        return self._ownerName
 
-    @logo.setter
-    def logo(self, value):
+    @ownerName.setter
+    def ownerName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logo = value
+            self._ownerName = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "ownerName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def privacy(self):
-        """str: Text describing the privacy for this model"""
-        return self._privacy
+    def status(self):
+        """VersionStatusEnum: Version status"""
+        return self._status
 
-    @privacy.setter
-    def privacy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._privacy = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "privacy" of type "list<str>" set to wrong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
     @property
-    def publisher(self):
-        """str: organization that published the artifact"""
-        return self._publisher
+    def totalFileCount(self):
+        """long: Total file count"""
+        return self._totalFileCount
 
-    @publisher.setter
-    def publisher(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._publisher = value
+    @totalFileCount.setter
+    def totalFileCount(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalFileCount = value
         else:
             raise TypeError(
-                'Property "publisher" of type "list<str>" set to wrong type'
+                'Property "totalFileCount" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def safetyAndSecurity(self):
-        """str: Text for describing the safety and security in the model"""
-        return self._safetyAndSecurity
+    def totalSizeInBytes(self):
+        """long: Total size of the model in bytes"""
+        return self._totalSizeInBytes
 
-    @safetyAndSecurity.setter
-    def safetyAndSecurity(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._safetyAndSecurity = value
+    @totalSizeInBytes.setter
+    def totalSizeInBytes(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._totalSizeInBytes = value
         else:
             raise TypeError(
-                'Property "safetyAndSecurity" of type "list<str>" set to wron'
+                'Property "totalSizeInBytes" of type "list<long>" set to wron'
                 'g type'
             )
 
     @property
-    def shortDescription(self):
-        """str: Short description of the artifact"""
-        return self._shortDescription
+    def versionId(self):
+        """str: Unique version id. Please use this instead of 'id'"""
+        return self._versionId
 
-    @shortDescription.setter
-    def shortDescription(self, value):
+    @versionId.setter
+    def versionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shortDescription = value
+            self._versionId = value
         else:
             raise TypeError(
-                'Property "shortDescription" of type "list<str>" set to wrong'
-                ' type'
+                'Property "versionId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._bias is not None:
-            result["bias"] = \
-                self._bias
-        if self._builtBy is not None:
-            result["builtBy"] = \
-                self._builtBy
+        if self._accuracyReached is not None:
+            result["accuracyReached"] = \
+                self._accuracyReached
+        if self._batchSize is not None:
+            result["batchSize"] = \
+                self._batchSize
+        if self._createdByUser is not None:
+            result["createdByUser"] = \
+                self._createdByUser
+        if self._createdDate is not None:
+            result["createdDate"] = \
+                self._createdDate
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._explainability is not None:
-            result["explainability"] = \
-                self._explainability
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._labelsV2 is not None:
-            result["labelsV2"] = \
-                self._labelsV2
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
-        if self._privacy is not None:
-            result["privacy"] = \
-                self._privacy
-        if self._publisher is not None:
-            result["publisher"] = \
-                self._publisher
-        if self._safetyAndSecurity is not None:
-            result["safetyAndSecurity"] = \
-                self._safetyAndSecurity
-        if self._shortDescription is not None:
-            result["shortDescription"] = \
-                self._shortDescription
+        if self._gpuModel is not None:
+            result["gpuModel"] = \
+                self._gpuModel
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._memoryFootprint is not None:
+            result["memoryFootprint"] = \
+                self._memoryFootprint
+        if self._numberOfEpochs is not None:
+            result["numberOfEpochs"] = \
+                self._numberOfEpochs
+        if self._otherContents:
+            result["otherContents"] = [
+                i.toDict() for i in self._otherContents 
+            ] if self._otherContents else []
+        if self._ownerName is not None:
+            result["ownerName"] = \
+                self._ownerName
+        if self._status is not None:
+            result["status"] = \
+                self._status
+        if self._totalFileCount is not None:
+            result["totalFileCount"] = \
+                self._totalFileCount
+        if self._totalSizeInBytes is not None:
+            result["totalSizeInBytes"] = \
+                self._totalSizeInBytes
+        if self._versionId is not None:
+            result["versionId"] = \
+                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._shortDescription is not None
-            and
-            len(self._shortDescription) > 255):
-            raise ValueError(
-                "ArtifactUpdateRequest.shortDescription: " + str(self._shortDescription) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._displayName is not None
-            and
-            len(self._displayName) < 2):
-            raise ValueError(
-                "ArtifactUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._displayName is not None
+        if (self._versionId is not None
             and
-            len(self._displayName) > 64):
+            len(self._versionId) > 255):
             raise ValueError(
-                "ArtifactUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._logo is not None
-            and
-            len(self._logo) > 255):
-            raise ValueError(
-                "ArtifactUpdateRequest.logo: " + str(self._logo) + 
+                "ModelVersion.versionId: " + str(self._versionId) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._builtBy is not None
+        if (self._createdDate is not None
             and
-            len(self._builtBy) > 255):
+            not re.match(
+                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
+                 self._createdDate)):
             raise ValueError(
-                "ArtifactUpdateRequest.builtBy: " + str(self._builtBy) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._publisher is not None
-            and
-            len(self._publisher) > 255):
-            raise ValueError(
-                "ArtifactUpdateRequest.publisher: " + str(self._publisher) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
+                "ModelVersion.createdDate: " + str(self._createdDate) + 
+                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
+                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
+                if (obj is not None): obj.isValid()
+        if (self._otherContents is not None):
+            for obj in self._otherContents:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactVersion.py` & `ngcbpc/data/registry/RepositoryImageDetails.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,236 +6,297 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CustomMetricGroup import CustomMetricGroup
-from .ArtifactAttribute import ArtifactAttribute
-from .VersionStatusEnum import VersionStatusEnum
+from .ImageScanDetails import ImageScanDetails
+from .ImageArchitectureVariant import ImageArchitectureVariant
+from .ScanStatus import ScanStatusEnum
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(VersionStatusEnum))
-str(repr(CustomMetricGroup))
+str(repr(ImageScanDetails))
+str(repr(ImageArchitectureVariant))
+str(repr(ScanStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactVersion(object):
-    """Artifact version object"""
+class RepositoryImageDetails(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.architectureVariants = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "architectureVariants"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.createdByUser = (
+            else [ ImageArchitectureVariant(i)
+            for i in propDict["architectureVariants"] ])
+        self.description = (
             None if not fromDict or propDict.get(
-                "createdByUser"
+                "description"
             ) is None
-            else propDict["createdByUser"])
-        self.createdDate = (
+            else propDict["description"])
+        self.digest = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "digest"
             ) is None
-            else propDict["createdDate"])
-        self.customMetrics = (
+            else propDict["digest"])
+        self.isMultiArchitecture = (
             None if not fromDict or propDict.get(
-                "customMetrics"
+                "isMultiArchitecture"
             ) is None
-            else [ CustomMetricGroup(i)
-            for i in propDict["customMetrics"] ])
-        self.description = (
+            else propDict["isMultiArchitecture"])
+        self.isSigned = (
             None if not fromDict or propDict.get(
-                "description"
+                "isSigned"
             ) is None
-            else propDict["description"])
-        self.id = (
+            else propDict["isSigned"])
+        self.pushedDate = (
             None if not fromDict or propDict.get(
-                "id"
+                "pushedDate"
             ) is None
-            else propDict["id"])
-        self.status = (
+            else propDict["pushedDate"])
+        self.scanDate = (
             None if not fromDict or propDict.get(
-                "status"
+                "scanDate"
             ) is None
-            else propDict["status"])
-        self.totalFileCount = (
+            else propDict["scanDate"])
+        self.scanDetails = (
             None if not fromDict or propDict.get(
-                "totalFileCount"
+                "scanDetails"
             ) is None
-            else propDict["totalFileCount"])
-        self.totalSizeInBytes = (
+            else propDict["scanDetails"])
+        self.scanEnabled = (
             None if not fromDict or propDict.get(
-                "totalSizeInBytes"
+                "scanEnabled"
             ) is None
-            else propDict["totalSizeInBytes"])
+            else propDict["scanEnabled"])
+        self.scanStatus = (
+            None if not fromDict or propDict.get(
+                "scanStatus"
+            ) is None
+            else propDict["scanStatus"])
+        self.size = (
+            None if not fromDict or propDict.get(
+                "size"
+            ) is None
+            else propDict["size"])
+        self.tag = (
+            None if not fromDict or propDict.get(
+                "tag"
+            ) is None
+            else propDict["tag"])
         self.updatedDate = (
             None if not fromDict or propDict.get(
                 "updatedDate"
             ) is None
             else propDict["updatedDate"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def architectureVariants(self):
+        """ """
+        return self._architectureVariants
 
-    @attributes.setter
-    def attributes(self, value):
+    @architectureVariants.setter
+    def architectureVariants(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._attributes = value
+            self._architectureVariants = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "architectureVariants" of type "list<ImageArchitect'
+                'ureVariant>" set to wrong type'
             )
 
     @property
-    def createdByUser(self):
-        """str: Id of the user who created this version"""
-        return self._createdByUser
+    def description(self):
+        """str: Image tag description"""
+        return self._description
 
-    @createdByUser.setter
-    def createdByUser(self, value):
+    @description.setter
+    def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdByUser = value
+            self._description = value
         else:
             raise TypeError(
-                'Property "createdByUser" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def createdDate(self):
-        """str: Creation date in ISO-8601 format"""
-        return self._createdDate
+    def digest(self):
+        """str: Image digest"""
+        return self._digest
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._digest = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def customMetrics(self):
-        """list: Custom Metrics key/value pairs"""
-        return self._customMetrics
+    def isMultiArchitecture(self):
+        """bool: Flag indicating if this image supports multiple CPU platforms
+         and architectures"""
+        return self._isMultiArchitecture
+
+    @isMultiArchitecture.setter
+    def isMultiArchitecture(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isMultiArchitecture = value
+        else:
+            raise TypeError(
+                'Property "isMultiArchitecture" of type "list<bool>" set to w'
+                'rong type'
+            )
 
-    @customMetrics.setter
-    def customMetrics(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._customMetrics = value
+    @property
+    def isSigned(self):
+        """bool: whether the tag is signed"""
+        return self._isSigned
+
+    @isSigned.setter
+    def isSigned(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isSigned = value
         else:
             raise TypeError(
-                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
-                'et to wrong type'
+                'Property "isSigned" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the version"""
-        return self._description
+    def pushedDate(self):
+        """str: Image pushed date in ISO-8601 format"""
+        return self._pushedDate
 
-    @description.setter
-    def description(self, value):
+    @pushedDate.setter
+    def pushedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._pushedDate = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "pushedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """str: Unique ID of the version"""
-        return self._id
+    def scanDate(self):
+        """str: Image scan date in ISO-8601 format"""
+        return self._scanDate
 
-    @id.setter
-    def id(self, value):
+    @scanDate.setter
+    def scanDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._id = value
+            self._scanDate = value
+        else:
+            raise TypeError(
+                'Property "scanDate" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def scanDetails(self):
+        """ """
+        return self._scanDetails
+
+    @scanDetails.setter
+    def scanDetails(self, value):
+        if value is not None and not isinstance(value, ImageScanDetails):
+            value = ImageScanDetails(value)
+        if (value is None) or isinstance(value, ImageScanDetails):
+            self._scanDetails = value
+        else:
+            raise TypeError(
+                'Property "scanDetails" of type "list<ImageScanDetails>" set '
+                'to wrong type'
+            )
+
+    @property
+    def scanEnabled(self):
+        """bool: Whether scanning enabled for this image tag"""
+        return self._scanEnabled
+
+    @scanEnabled.setter
+    def scanEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._scanEnabled = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "scanEnabled" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def status(self):
-        """VersionStatusEnum: Version status"""
-        return self._status
+    def scanStatus(self):
+        """ScanStatusEnum: Image scan statuses"""
+        return self._scanStatus
 
-    @status.setter
-    def status(self, value):
+    @scanStatus.setter
+    def scanStatus(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+            self._scanStatus = value
         else:
             raise TypeError(
-                'Property "status" of type "list<VersionStatusEnum>" set to w'
-                'rong type'
+                'Property "scanStatus" of type "list<ScanStatusEnum>" set to '
+                'wrong type'
             )
 
     @property
-    def totalFileCount(self):
-        """long: Total file count"""
-        return self._totalFileCount
+    def size(self):
+        """long: Image size in bytes"""
+        return self._size
 
-    @totalFileCount.setter
-    def totalFileCount(self, value):
+    @size.setter
+    def size(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
-            self._totalFileCount = value
+            self._size = value
         else:
             raise TypeError(
-                'Property "totalFileCount" of type "list<long>" set to wrong '
-                'type'
+                'Property "size" of type "list<long>" set to wrong type'
             )
 
     @property
-    def totalSizeInBytes(self):
-        """long: Total size of the version in bytes"""
-        return self._totalSizeInBytes
+    def tag(self):
+        """str: Image tag"""
+        return self._tag
 
-    @totalSizeInBytes.setter
-    def totalSizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalSizeInBytes = value
+    @tag.setter
+    def tag(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._tag = value
         else:
             raise TypeError(
-                'Property "totalSizeInBytes" of type "list<long>" set to wron'
-                'g type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     @property
     def updatedDate(self):
-        """str: Updated date in ISO-8601 format"""
+        """str: Image update date in ISO-8601 format"""
         return self._updatedDate
 
     @updatedDate.setter
     def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -243,75 +304,63 @@
         else:
             raise TypeError(
                 'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._createdByUser is not None:
-            result["createdByUser"] = \
-                self._createdByUser
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._customMetrics:
-            result["customMetrics"] = [
-                i.toDict() for i in self._customMetrics 
-            ] if self._customMetrics else []
+        if self._architectureVariants:
+            result["architectureVariants"] = [
+                i.toDict() for i in self._architectureVariants 
+            ] if self._architectureVariants else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._status is not None:
-            result["status"] = \
-                self._status
-        if self._totalFileCount is not None:
-            result["totalFileCount"] = \
-                self._totalFileCount
-        if self._totalSizeInBytes is not None:
-            result["totalSizeInBytes"] = \
-                self._totalSizeInBytes
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._isMultiArchitecture is not None:
+            result["isMultiArchitecture"] = \
+                self._isMultiArchitecture
+        if self._isSigned is not None:
+            result["isSigned"] = \
+                self._isSigned
+        if self._pushedDate is not None:
+            result["pushedDate"] = \
+                self._pushedDate
+        if self._scanDate is not None:
+            result["scanDate"] = \
+                self._scanDate
+        if self._scanDetails:
+            result["scanDetails"] = \
+                self._scanDetails.toDict() if self._scanDetails is not None else None
+        if self._scanEnabled is not None:
+            result["scanEnabled"] = \
+                self._scanEnabled
+        if self._scanStatus is not None:
+            result["scanStatus"] = \
+                self._scanStatus
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
         if self._updatedDate is not None:
             result["updatedDate"] = \
                 self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._createdDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
-            raise ValueError(
-                "ArtifactVersion.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
-            raise ValueError(
-                "ArtifactVersion.updatedDate: " + str(self._updatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
-        if (self._customMetrics is not None):
-            for obj in self._customMetrics:
+        if (self._scanDetails is not None): self._scanDetails.isValid()
+        if (self._architectureVariants is not None):
+            for obj in self._architectureVariants:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactVersionCreateRequest.py` & `basecommand/data/pym/ProjectInfoResponse.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,119 +6,124 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
+from .ProjectDetails import ProjectDetails
+from .ClusterInfo import ClusterInfo
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
+str(repr(ClusterInfo))
+str(repr(ProjectDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactVersionCreateRequest(object):
-    """Request to create a new artifact version"""
+class ProjectInfoResponse(object):
+    """Project Info Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.clusterInfo = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "clusterInfo"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.description = (
+            else propDict["clusterInfo"])
+        self.projectInfo = (
             None if not fromDict or propDict.get(
-                "description"
+                "projectInfo"
             ) is None
-            else propDict["description"])
-        self.id = (
+            else propDict["projectInfo"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "id"
+                "version"
             ) is None
-            else propDict["id"])
+            else propDict["version"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
-
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    def clusterInfo(self):
+        """ClusterInfo: Cluster Information"""
+        return self._clusterInfo
+
+    @clusterInfo.setter
+    def clusterInfo(self, value):
+        if value is not None and not isinstance(value, ClusterInfo):
+            value = ClusterInfo(value)
+        if (value is None) or isinstance(value, ClusterInfo):
+            self._clusterInfo = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "clusterInfo" of type "list<ClusterInfo>" set to wr'
+                'ong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the artifact version"""
-        return self._description
-
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    def projectInfo(self):
+        """ProjectDetails: Project Details"""
+        return self._projectInfo
+
+    @projectInfo.setter
+    def projectInfo(self, value):
+        if value is not None and not isinstance(value, ProjectDetails):
+            value = ProjectDetails(value)
+        if (value is None) or isinstance(value, ProjectDetails):
+            self._projectInfo = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "projectInfo" of type "list<ProjectDetails>" set to'
+                ' wrong type'
             )
 
     @property
-    def id(self):
-        """str: Unique ID of the version"""
-        return self._id
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @id.setter
-    def id(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._id = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "id" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._id is not None:
-            result["id"] = \
-                self._id
+        if self._clusterInfo:
+            result["clusterInfo"] = \
+                self._clusterInfo.toDict() if self._clusterInfo is not None else None
+        if self._projectInfo:
+            result["projectInfo"] = \
+                self._projectInfo.toDict() if self._projectInfo is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._id is None:
+        if self._version is None:
+            raise ValueError(
+                "ProjectInfoResponse.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._projectInfo is None:
             raise ValueError(
-                "ArtifactVersionCreateRequest.id doesnt match requirement:" 
+                "ProjectInfoResponse.projectInfo doesnt match requirement:" 
                 "required: True"
             )
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
+        if (self._projectInfo is not None): self._projectInfo.isValid()
+        if (self._clusterInfo is not None): self._clusterInfo.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactVersionFileListResponse.py` & `ngcbpc/data/model/ArtifactVersionFileListResponse.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -6,26 +6,26 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactVersion import ArtifactVersion
+from .RequestStatus import RequestStatus
+from .Artifact import Artifact
 from .File import File
 from .PaginationInfo import PaginationInfo
-from .Artifact import Artifact
-from .RequestStatus import RequestStatus
-from .ArtifactVersion import ArtifactVersion
 
 # Unused import over optimization prevention
-str(repr(ArtifactVersion))
 str(repr(PaginationInfo))
 str(repr(File))
-str(repr(RequestStatus))
 str(repr(Artifact))
+str(repr(ArtifactVersion))
+str(repr(RequestStatus))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class ArtifactVersionFileListResponse(object):
```

## Comparing `ngccli/data/model/ArtifactVersionListResponse.py` & `ngcbpc/data/model/DeploymentParametersListResponse.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,88 +6,110 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactVersion import ArtifactVersion
-from .Artifact import Artifact
-from .PaginationInfo import PaginationInfo
+from .DeploymentArtifactParameters import DeploymentArtifactParameters
 from .RequestStatus import RequestStatus
+from .DeploymentParameters import DeploymentParameters
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
+str(repr(DeploymentArtifactParameters))
 str(repr(RequestStatus))
-str(repr(ArtifactVersion))
-str(repr(Artifact))
 str(repr(PaginationInfo))
+str(repr(DeploymentParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactVersionListResponse(object):
-    """Response to list artifact versions request"""
+class DeploymentParametersListResponse(object):
+    """Response to list deployment parameters request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.artifact = (
             None if not fromDict or propDict.get(
                 "artifact"
             ) is None
             else propDict["artifact"])
-        self.artifactVersions = (
+        self.csp = (
             None if not fromDict or propDict.get(
-                "artifactVersions"
+                "csp"
             ) is None
-            else [ ArtifactVersion(i)
-            for i in propDict["artifactVersions"] ])
+            else propDict["csp"])
+        self.deploymentParameters = (
+            None if not fromDict or propDict.get(
+                "deploymentParameters"
+            ) is None
+            else [ DeploymentParameters(i)
+            for i in propDict["deploymentParameters"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
     def artifact(self):
-        """Artifact: Artifact object"""
+        """DeploymentArtifactParameters: Deployment Artifact Parameters object
+        """
         return self._artifact
 
     @artifact.setter
     def artifact(self, value):
-        if value is not None and not isinstance(value, Artifact):
-            value = Artifact(value)
-        if (value is None) or isinstance(value, Artifact):
+        if value is not None and not isinstance(value, DeploymentArtifactParameters):
+            value = DeploymentArtifactParameters(value)
+        if (value is None) or isinstance(value, DeploymentArtifactParameters):
             self._artifact = value
         else:
             raise TypeError(
-                'Property "artifact" of type "list<Artifact>" set to wrong ty'
-                'pe'
+                'Property "artifact" of type "list<DeploymentArtifactParamete'
+                'rs>" set to wrong type'
+            )
+
+    @property
+    def csp(self):
+        """str: Cloud Service Provider name"""
+        return self._csp
+
+    @csp.setter
+    def csp(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._csp = value
+        else:
+            raise TypeError(
+                'Property "csp" of type "list<str>" set to wrong type'
             )
 
     @property
-    def artifactVersions(self):
+    def deploymentParameters(self):
         """ """
-        return self._artifactVersions
+        return self._deploymentParameters
 
-    @artifactVersions.setter
-    def artifactVersions(self, value):
+    @deploymentParameters.setter
+    def deploymentParameters(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._artifactVersions = value
+            self._deploymentParameters = value
         else:
             raise TypeError(
-                'Property "artifactVersions" of type "list<ArtifactVersion>" '
-                'set to wrong type'
+                'Property "deploymentParameters" of type "list<DeploymentPara'
+                'meters>" set to wrong type'
             )
 
     @property
     def paginationInfo(self):
         """PaginationInfo: Pagination Information"""
         return self._paginationInfo
 
@@ -121,18 +143,21 @@
             )
 
     def toDict(self):
         result = {}
         if self._artifact:
             result["artifact"] = \
                 self._artifact.toDict() if self._artifact is not None else None
-        if self._artifactVersions:
-            result["artifactVersions"] = [
-                i.toDict() for i in self._artifactVersions 
-            ] if self._artifactVersions else []
+        if self._csp is not None:
+            result["csp"] = \
+                self._csp
+        if self._deploymentParameters:
+            result["deploymentParameters"] = [
+                i.toDict() for i in self._deploymentParameters 
+            ] if self._deploymentParameters else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -141,15 +166,15 @@
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if (self._artifact is not None): self._artifact.isValid()
-        if (self._artifactVersions is not None):
-            for obj in self._artifactVersions:
+        if (self._deploymentParameters is not None):
+            for obj in self._deploymentParameters:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/ArtifactVersionResponse.py` & `ngcbpc/data/model/ArtifactVersionResponse.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -7,20 +7,20 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .ArtifactVersion import ArtifactVersion
-from .Artifact import Artifact
 from .RequestStatus import RequestStatus
+from .Artifact import Artifact
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
 str(repr(ArtifactVersion))
+str(repr(RequestStatus))
 str(repr(Artifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
```

## Comparing `ngccli/data/model/ArtifactVersionUpdateRequest.py` & `ngcbpc/data/uis/Health.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,121 +6,129 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
-from .VersionStatusEnum import VersionStatusEnum
+from .MetaData import MetaData
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(VersionStatusEnum))
+str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ArtifactVersionUpdateRequest(object):
-    """Request to create a new artifact version"""
+class Health(object):
+    """object that describes health of the service"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.healthCode = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "healthCode"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.description = (
+            else propDict["healthCode"])
+        self.healthCodeDescription = (
             None if not fromDict or propDict.get(
-                "description"
+                "healthCodeDescription"
             ) is None
-            else propDict["description"])
-        self.status = (
+            else propDict["healthCodeDescription"])
+        self.metaData = (
             None if not fromDict or propDict.get(
-                "status"
+                "metaData"
             ) is None
-            else propDict["status"])
+            else [ MetaData(i)
+            for i in propDict["metaData"] ])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def healthCode(self):
+        """HealthCodeEnum: Enum that describes health of the service"""
+        return self._healthCode
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    @healthCode.setter
+    def healthCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._healthCode = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "healthCode" of type "list<HealthCodeEnum>" set to '
+                'wrong type'
             )
 
+    HealthCodeEnum=["UNKNOWN","OK","UNDER_MAINTENANCE","WARNING","FAILED",]
+    str(repr(HealthCodeEnum))  # Prevent optimizer removing enum
+
     @property
-    def description(self):
-        """str: Description of the artifact version"""
-        return self._description
+    def healthCodeDescription(self):
+        """str: Human readable description"""
+        return self._healthCodeDescription
 
-    @description.setter
-    def description(self, value):
+    @healthCodeDescription.setter
+    def healthCodeDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._healthCodeDescription = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "healthCodeDescription" of type "list<str>" set to '
+                'wrong type'
             )
 
     @property
-    def status(self):
-        """VersionStatusEnum: Version status"""
-        return self._status
+    def metaData(self):
+        """ """
+        return self._metaData
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @metaData.setter
+    def metaData(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._metaData = value
         else:
             raise TypeError(
-                'Property "status" of type "list<VersionStatusEnum>" set to w'
-                'rong type'
+                'Property "metaData" of type "list<MetaData>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._status is not None:
-            result["status"] = \
-                self._status
+        if self._healthCode is not None:
+            result["healthCode"] = \
+                self._healthCode
+        if self._healthCodeDescription is not None:
+            result["healthCodeDescription"] = \
+                self._healthCodeDescription
+        if self._metaData:
+            result["metaData"] = [
+                i.toDict() for i in self._metaData 
+            ] if self._metaData else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._description is not None
+        if (self._healthCodeDescription is not None
+            and
+            len(self._healthCodeDescription) < 1):
+            raise ValueError(
+                "Health.healthCodeDescription: " + str(self._healthCodeDescription) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._healthCodeDescription is not None
             and
-            len(self._description) > 255):
+            len(self._healthCodeDescription) > 255):
             raise ValueError(
-                "ArtifactVersionUpdateRequest.description: " + str(self._description) + 
+                "Health.healthCodeDescription: " + str(self._healthCodeDescription) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
+        if (self._metaData is not None):
+            for obj in self._metaData:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/AssetResponse.py` & `organization/data/subscription_management_service/RenewSubscriptionResponse.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,89 +6,90 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Asset import Asset
+from .Subscription import Subscription
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Asset))
+str(repr(Subscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AssetResponse(object):
-    """Response to asset request"""
+class RenewSubscriptionResponse(object):
+    """Response for renew subscription API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.asset = (
-            None if not fromDict or propDict.get(
-                "asset"
-            ) is None
-            else propDict["asset"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def asset(self):
-        """Asset: Asset object"""
-        return self._asset
-
-    @asset.setter
-    def asset(self, value):
-        if value is not None and not isinstance(value, Asset):
-            value = Asset(value)
-        if (value is None) or isinstance(value, Asset):
-            self._asset = value
-        else:
-            raise TypeError(
-                'Property "asset" of type "list<Asset>" set to wrong type'
-            )
+        self.subscription = (
+            None if not fromDict or propDict.get(
+                "subscription"
+            ) is None
+            else propDict["subscription"])
 
     @property
     def requestStatus(self):
-        """RequestStatus: Request status information"""
+        """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscription(self):
+        """ """
+        return self._subscription
+
+    @subscription.setter
+    def subscription(self, value):
+        if value is not None and not isinstance(value, Subscription):
+            value = Subscription(value)
+        if (value is None) or isinstance(value, Subscription):
+            self._subscription = value
+        else:
+            raise TypeError(
+                'Property "subscription" of type "list<Subscription>" set to '
+                'wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._asset:
-            result["asset"] = \
-                self._asset.toDict() if self._asset is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscription:
+            result["subscription"] = \
+                self._subscription.toDict() if self._subscription is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._asset is not None): self._asset.isValid()
+        if (self._subscription is not None): self._subscription.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/AssetSimplified.py` & `basecommand/data/pym/ClusterInstanceInfo.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,116 +6,103 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterInstance import ClusterInstance
 
 # Unused import over optimization prevention
+str(repr(ClusterInstance))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AssetSimplified(object):
-    """Asset object"""
+class ClusterInstanceInfo(object):
+    """Cluster Instance Info"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.clusterInstanceType = (
             None if not fromDict or propDict.get(
-                "name"
+                "clusterInstanceType"
             ) is None
-            else propDict["name"])
-        self.orgName = (
+            else propDict["clusterInstanceType"])
+        self.count = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "count"
             ) is None
-            else propDict["orgName"])
-        self.teamName = (
-            None if not fromDict or propDict.get(
-                "teamName"
-            ) is None
-            else propDict["teamName"])
-
-    @property
-    def name(self):
-        """str: Unique name of the asset"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
-        else:
-            raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
+            else propDict["count"])
 
     @property
-    def orgName(self):
-        """str: Name of the org that the asset belongs to"""
-        return self._orgName
-
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    def clusterInstanceType(self):
+        """ClusterInstance: Machine instance type"""
+        return self._clusterInstanceType
+
+    @clusterInstanceType.setter
+    def clusterInstanceType(self, value):
+        if value is not None and not isinstance(value, ClusterInstance):
+            value = ClusterInstance(value)
+        if (value is None) or isinstance(value, ClusterInstance):
+            self._clusterInstanceType = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "clusterInstanceType" of type "list<ClusterInstance'
+                '>" set to wrong type'
             )
 
     @property
-    def teamName(self):
-        """str: Name of the team that the asset belongs to"""
-        return self._teamName
-
-    @teamName.setter
-    def teamName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+    def count(self):
+        """int: Number of instances"""
+        return self._count
+
+    @count.setter
+    def count(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._count = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "count" of type "list<int>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
+        if self._clusterInstanceType:
+            result["clusterInstanceType"] = \
+                self._clusterInstanceType.toDict() if self._clusterInstanceType is not None else None
+        if self._count is not None:
+            result["count"] = \
+                self._count
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._count is None:
             raise ValueError(
-                "AssetSimplified.name doesnt match requirement:" 
+                "ClusterInstanceInfo.count doesnt match requirement:" 
                 "required: True"
             )
-        if self._orgName is None:
+        if (self._count is not None
+            and
+            self._count < 1):
             raise ValueError(
-                "AssetSimplified.orgName doesnt match requirement:" 
-                "required: True"
-            )
+                "ClusterInstanceInfo.count: " + str(self._count) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._count is not None
+            and
+            self._count > 65535):
+            raise ValueError(
+                "ClusterInstanceInfo.count: " + str(self._count) + 
+                " doesnt match requirement: maximum: 65535")
+        if (self._clusterInstanceType is not None): self._clusterInstanceType.isValid()
         return True
```

## Comparing `ngccli/data/model/AssetStorageEvent.py` & `organization/data/subscription_management_service/Health.py`

 * *Files 21% similar despite different names*

```diff
@@ -6,136 +6,129 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Asset import Asset
+from .MetaData import MetaData
 
 # Unused import over optimization prevention
-str(repr(Asset))
+str(repr(MetaData))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AssetStorageEvent(object):
-    """This event in the topic means that some change happened to the asset st
-    orage object"""
+class Health(object):
+    """object that describes health of the service"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.asset = (
+        self.healthCode = (
             None if not fromDict or propDict.get(
-                "asset"
+                "healthCode"
             ) is None
-            else propDict["asset"])
-        self.eventType = (
+            else propDict["healthCode"])
+        self.healthCodeDescription = (
             None if not fromDict or propDict.get(
-                "eventType"
+                "healthCodeDescription"
             ) is None
-            else propDict["eventType"])
-        self.timestamp = (
+            else propDict["healthCodeDescription"])
+        self.metaData = (
             None if not fromDict or propDict.get(
-                "timestamp"
+                "metaData"
             ) is None
-            else propDict["timestamp"])
+            else [ MetaData(i)
+            for i in propDict["metaData"] ])
 
     @property
-    def asset(self):
-        """Asset: Asset object"""
-        return self._asset
-
-    @asset.setter
-    def asset(self, value):
-        if value is not None and not isinstance(value, Asset):
-            value = Asset(value)
-        if (value is None) or isinstance(value, Asset):
-            self._asset = value
+    def healthCode(self):
+        """HealthCodeEnum: Enum that describes health of the service"""
+        return self._healthCode
+
+    @healthCode.setter
+    def healthCode(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._healthCode = value
         else:
             raise TypeError(
-                'Property "asset" of type "list<Asset>" set to wrong type'
+                'Property "healthCode" of type "list<HealthCodeEnum>" set to '
+                'wrong type'
             )
 
-    @property
-    def eventType(self):
-        """EventTypeEnum: Asset storage event type"""
-        return self._eventType
+    HealthCodeEnum=["UNKNOWN","OK","UNDER_MAINTENANCE","WARNING","FAILED",]
+    str(repr(HealthCodeEnum))  # Prevent optimizer removing enum
 
-    @eventType.setter
-    def eventType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._eventType = value
+    @property
+    def healthCodeDescription(self):
+        """str: Human readable description"""
+        return self._healthCodeDescription
+
+    @healthCodeDescription.setter
+    def healthCodeDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._healthCodeDescription = value
         else:
             raise TypeError(
-                'Property "eventType" of type "list<EventTypeEnum>" set to wr'
-                'ong type'
+                'Property "healthCodeDescription" of type "list<str>" set to '
+                'wrong type'
             )
 
-    EventTypeEnum=["ASSET_OBJECT_CREATED","ASSET_OBJECT_DELETED",]
-    str(repr(EventTypeEnum))  # Prevent optimizer removing enum
-
     @property
-    def timestamp(self):
-        """str: Timestamp in ISO-8601 format"""
-        return self._timestamp
-
-    @timestamp.setter
-    def timestamp(self, value):
-        if value is not None and not isinstance(value, str):
-            value = str(value)
-        if (value is None) or isinstance(value, str):
-            self._timestamp = value
+    def metaData(self):
+        """ """
+        return self._metaData
+
+    @metaData.setter
+    def metaData(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._metaData = value
         else:
             raise TypeError(
-                'Property "timestamp" of type "list<str>" set to wrong type'
+                'Property "metaData" of type "list<MetaData>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._asset:
-            result["asset"] = \
-                self._asset.toDict() if self._asset is not None else None
-        if self._eventType is not None:
-            result["eventType"] = \
-                self._eventType
-        if self._timestamp is not None:
-            result["timestamp"] = \
-                self._timestamp
+        if self._healthCode is not None:
+            result["healthCode"] = \
+                self._healthCode
+        if self._healthCodeDescription is not None:
+            result["healthCodeDescription"] = \
+                self._healthCodeDescription
+        if self._metaData:
+            result["metaData"] = [
+                i.toDict() for i in self._metaData 
+            ] if self._metaData else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._asset is None:
-            raise ValueError(
-                "AssetStorageEvent.asset doesnt match requirement:" 
-                "required: True"
-            )
-        if self._timestamp is None:
-            raise ValueError(
-                "AssetStorageEvent.timestamp doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._timestamp is not None
+        if (self._healthCodeDescription is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._timestamp)):
+            len(self._healthCodeDescription) < 1):
             raise ValueError(
-                "AssetStorageEvent.timestamp: " + str(self._timestamp) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if self._eventType is None:
+                "Health.healthCodeDescription: " + str(self._healthCodeDescription) + 
+                " doesnt match requirement: minLength: 1")
+        if (self._healthCodeDescription is not None
+            and
+            len(self._healthCodeDescription) > 255):
             raise ValueError(
-                "AssetStorageEvent.eventType doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._asset is not None): self._asset.isValid()
+                "Health.healthCodeDescription: " + str(self._healthCodeDescription) + 
+                " doesnt match requirement: maxLength: 255")
+        if (self._metaData is not None):
+            for obj in self._metaData:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/AssetUpdateRequest.py` & `ngcbpc/data/registry/AnchorePolicyBundleRecord.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,216 +6,211 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
+from .AnchorePolicyBundle import AnchorePolicyBundle
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
+str(repr(AnchorePolicyBundle))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class AssetUpdateRequest(object):
-    """Request to update an asset"""
+class AnchorePolicyBundleRecord(object):
+    """A policy bundle plus some metadata"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.active = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "active"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.fileName = (
+            else propDict["active"])
+        self.created_at = (
             None if not fromDict or propDict.get(
-                "fileName"
+                "created_at"
             ) is None
-            else propDict["fileName"])
-        self.mimeType = (
+            else propDict["created_at"])
+        self.last_updated = (
             None if not fromDict or propDict.get(
-                "mimeType"
+                "last_updated"
             ) is None
-            else propDict["mimeType"])
-        self.originUrl = (
+            else propDict["last_updated"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "originUrl"
+                "name"
             ) is None
-            else propDict["originUrl"])
-        self.owner = (
+            else propDict["name"])
+        self.policyId = (
             None if not fromDict or propDict.get(
-                "owner"
+                "policyId"
             ) is None
-            else propDict["owner"])
-        self.sizeInBytes = (
+            else propDict["policyId"])
+        self.policy_source = (
             None if not fromDict or propDict.get(
-                "sizeInBytes"
+                "policy_source"
             ) is None
-            else propDict["sizeInBytes"])
+            else propDict["policy_source"])
+        self.policybundle = (
+            None if not fromDict or propDict.get(
+                "policybundle"
+            ) is None
+            else propDict["policybundle"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def active(self):
+        """bool: Whether the policy is active"""
+        return self._active
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    @active.setter
+    def active(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._active = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "active" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def fileName(self):
-        """str: Asset file name"""
-        return self._fileName
+    def created_at(self):
+        """str: Policy create date in ISO-8601 format"""
+        return self._created_at
 
-    @fileName.setter
-    def fileName(self, value):
+    @created_at.setter
+    def created_at(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._fileName = value
+            self._created_at = value
         else:
             raise TypeError(
-                'Property "fileName" of type "list<str>" set to wrong type'
+                'Property "created_at" of type "list<str>" set to wrong type'
             )
 
     @property
-    def mimeType(self):
-        """str: MIME type"""
-        return self._mimeType
+    def last_updated(self):
+        """str: Policy updated date in ISO-8601 format"""
+        return self._last_updated
 
-    @mimeType.setter
-    def mimeType(self, value):
+    @last_updated.setter
+    def last_updated(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._mimeType = value
+            self._last_updated = value
         else:
             raise TypeError(
-                'Property "mimeType" of type "list<str>" set to wrong type'
+                'Property "last_updated" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def originUrl(self):
-        """str: Asset origin URL"""
-        return self._originUrl
+    def name(self):
+        """str: Policy name"""
+        return self._name
 
-    @originUrl.setter
-    def originUrl(self, value):
+    @name.setter
+    def name(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._originUrl = value
+            self._name = value
         else:
             raise TypeError(
-                'Property "originUrl" of type "list<str>" set to wrong type'
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def owner(self):
-        """str: Owner of asset"""
-        return self._owner
+    def policyId(self):
+        """str: Policy unique identifier in anchore engine"""
+        return self._policyId
 
-    @owner.setter
-    def owner(self, value):
+    @policyId.setter
+    def policyId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._owner = value
+            self._policyId = value
         else:
             raise TypeError(
-                'Property "owner" of type "list<str>" set to wrong type'
+                'Property "policyId" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sizeInBytes(self):
-        """long: Size in bytes"""
-        return self._sizeInBytes
+    def policy_source(self):
+        """str: The policy source"""
+        return self._policy_source
 
-    @sizeInBytes.setter
-    def sizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._sizeInBytes = value
+    @policy_source.setter
+    def policy_source(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._policy_source = value
         else:
             raise TypeError(
-                'Property "sizeInBytes" of type "list<long>" set to wrong typ'
-                'e'
+                'Property "policy_source" of type "list<str>" set to wrong ty'
+                'pe'
+            )
+
+    @property
+    def policybundle(self):
+        """AnchorePolicyBundle: A bundle containing a set of policies, allowli
+        sts, and rules for mapping them to specific images. https://ap
+        p.swaggerhub.com/apis/anchore/anchore-engine/0.1.8#/PolicyBundleRecord
+        """
+        return self._policybundle
+
+    @policybundle.setter
+    def policybundle(self, value):
+        if value is not None and not isinstance(value, AnchorePolicyBundle):
+            value = AnchorePolicyBundle(value)
+        if (value is None) or isinstance(value, AnchorePolicyBundle):
+            self._policybundle = value
+        else:
+            raise TypeError(
+                'Property "policybundle" of type "list<AnchorePolicyBundle>" '
+                'set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._fileName is not None:
-            result["fileName"] = \
-                self._fileName
-        if self._mimeType is not None:
-            result["mimeType"] = \
-                self._mimeType
-        if self._originUrl is not None:
-            result["originUrl"] = \
-                self._originUrl
-        if self._owner is not None:
-            result["owner"] = \
-                self._owner
-        if self._sizeInBytes is not None:
-            result["sizeInBytes"] = \
-                self._sizeInBytes
+        if self._active is not None:
+            result["active"] = \
+                self._active
+        if self._created_at is not None:
+            result["created_at"] = \
+                self._created_at
+        if self._last_updated is not None:
+            result["last_updated"] = \
+                self._last_updated
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._policyId is not None:
+            result["policyId"] = \
+                self._policyId
+        if self._policy_source is not None:
+            result["policy_source"] = \
+                self._policy_source
+        if self._policybundle:
+            result["policybundle"] = \
+                self._policybundle.toDict() if self._policybundle is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._originUrl is not None
-            and
-            len(self._originUrl) > 2000):
-            raise ValueError(
-                "AssetUpdateRequest.originUrl: " + str(self._originUrl) + 
-                " doesnt match requirement: maxLength: 2000")
-        if (self._originUrl is not None
-            and
-            not re.match(
-                r"^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0"
-                "-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)"
-                "+$",
-                 self._originUrl)):
-            raise ValueError(
-                "AssetUpdateRequest.originUrl: " + str(self._originUrl) + 
-                " doesnt match requirement: pattern: ^https?:\/\/(www\.)?[-a-"
-                "zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,"
-                "6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)+$")
-        if self._fileName is None:
-            raise ValueError(
-                "AssetUpdateRequest.fileName doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._fileName is not None
-            and
-            len(self._fileName) > 255):
-            raise ValueError(
-                "AssetUpdateRequest.fileName: " + str(self._fileName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
+        if (self._policybundle is not None): self._policybundle.isValid()
         return True
```

## Comparing `ngccli/data/model/CatalogArtifactMetadata.py` & `organization/data/subscription_management_service/PreviewOrder.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,159 +6,166 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AccessTypeEnum import AccessTypeEnum
-from .ProductNamesEnum import ProductNamesEnum
+from .LineItem import LineItem
+from .OrderSummary import OrderSummary
+from .SubscriptionStatusEnum import SubscriptionStatusEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNamesEnum))
-str(repr(AccessTypeEnum))
+str(repr(OrderSummary))
+str(repr(SubscriptionStatusEnum))
+str(repr(LineItem))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CatalogArtifactMetadata(object):
+class PreviewOrder(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accessType = (
+        self.lineItems = (
             None if not fromDict or propDict.get(
-                "accessType"
+                "lineItems"
             ) is None
-            else propDict["accessType"])
-        self.canGuestPull = (
+            else [ LineItem(i)
+            for i in propDict["lineItems"] ])
+        self.orderDate = (
             None if not fromDict or propDict.get(
-                "canGuestPull"
+                "orderDate"
             ) is None
-            else propDict["canGuestPull"])
-        self.canPublicList = (
+            else propDict["orderDate"])
+        self.orderSummary = (
             None if not fromDict or propDict.get(
-                "canPublicList"
+                "orderSummary"
             ) is None
-            else propDict["canPublicList"])
-        self.isPublic = (
+            else propDict["orderSummary"])
+        self.renewalDate = (
             None if not fromDict or propDict.get(
-                "isPublic"
+                "renewalDate"
             ) is None
-            else propDict["isPublic"])
-        self.productNames = (
+            else propDict["renewalDate"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "productNames"
+                "status"
             ) is None
-            else propDict["productNames"])
+            else propDict["status"])
 
     @property
-    def accessType(self):
+    def lineItems(self):
         """ """
-        return self._accessType
+        return self._lineItems
 
-    @accessType.setter
-    def accessType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._accessType = value
+    @lineItems.setter
+    def lineItems(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._lineItems = value
         else:
             raise TypeError(
-                'Property "accessType" of type "list<AccessTypeEnum>" set to '
-                'wrong type'
+                'Property "lineItems" of type "list<LineItem>" set to wrong t'
+                'ype'
             )
 
     @property
-    def canGuestPull(self):
-        """bool: Guest users can download from the Catalog registry"""
-        return self._canGuestPull
-
-    @canGuestPull.setter
-    def canGuestPull(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canGuestPull = value
+    def orderDate(self):
+        """str: order date for the product"""
+        return self._orderDate
+
+    @orderDate.setter
+    def orderDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orderDate = value
         else:
             raise TypeError(
-                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
-                'pe'
+                'Property "orderDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def canPublicList(self):
-        """bool: Publicly listed/searchable in the Catalog registry"""
-        return self._canPublicList
-
-    @canPublicList.setter
-    def canPublicList(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canPublicList = value
+    def orderSummary(self):
+        """ """
+        return self._orderSummary
+
+    @orderSummary.setter
+    def orderSummary(self, value):
+        if value is not None and not isinstance(value, OrderSummary):
+            value = OrderSummary(value)
+        if (value is None) or isinstance(value, OrderSummary):
+            self._orderSummary = value
         else:
             raise TypeError(
-                'Property "canPublicList" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "orderSummary" of type "list<OrderSummary>" set to '
+                'wrong type'
             )
 
     @property
-    def isPublic(self):
-        """bool: Publicly available in the Catalog registry"""
-        return self._isPublic
-
-    @isPublic.setter
-    def isPublic(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isPublic = value
+    def renewalDate(self):
+        """str: renewal date for the product subscription"""
+        return self._renewalDate
+
+    @renewalDate.setter
+    def renewalDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._renewalDate = value
         else:
             raise TypeError(
-                'Property "isPublic" of type "list<bool>" set to wrong type'
+                'Property "renewalDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def productNames(self):
-        """list: Product names"""
-        return self._productNames
+    def status(self):
+        """SubscriptionStatusEnum: All possible subscription status enums"""
+        return self._status
 
-    @productNames.setter
-    def productNames(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productNames = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "productNames" of type "list<ProductNamesEnum>" set'
+                'Property "status" of type "list<SubscriptionStatusEnum>" set'
                 ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accessType is not None:
-            result["accessType"] = \
-                self._accessType
-        if self._canGuestPull is not None:
-            result["canGuestPull"] = \
-                self._canGuestPull
-        if self._canPublicList is not None:
-            result["canPublicList"] = \
-                self._canPublicList
-        if self._isPublic is not None:
-            result["isPublic"] = \
-                self._isPublic
-        if self._productNames is not None:
-            result["productNames"] = \
-                self._productNames
+        if self._lineItems:
+            result["lineItems"] = [
+                i.toDict() for i in self._lineItems 
+            ] if self._lineItems else []
+        if self._orderDate is not None:
+            result["orderDate"] = \
+                self._orderDate
+        if self._orderSummary:
+            result["orderSummary"] = \
+                self._orderSummary.toDict() if self._orderSummary is not None else None
+        if self._renewalDate is not None:
+            result["renewalDate"] = \
+                self._renewalDate
+        if self._status is not None:
+            result["status"] = \
+                self._status
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._lineItems is not None):
+            for obj in self._lineItems:
+                if (obj is not None): obj.isValid()
+        if (self._orderSummary is not None): self._orderSummary.isValid()
         return True
```

## Comparing `ngccli/data/model/CloneArtifactVersionFilesRequest.py` & `ngcbpc/data/model/CloneArtifactVersionFilesRequest.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .CloneableArtifact import CloneableArtifact
 from .ArtifactTypeEnum import ArtifactTypeEnum
 
 # Unused import over optimization prevention
-str(repr(ArtifactTypeEnum))
 str(repr(CloneableArtifact))
+str(repr(ArtifactTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class CloneArtifactVersionFilesRequest(object):
```

## Comparing `ngccli/data/model/CloneableArtifact.py` & `registry/data/publishing/ArtifactToCollectionRequest.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,130 +6,128 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ArtifactType import ArtifactTypeEnum
+from .Artifact import Artifact
 
 # Unused import over optimization prevention
+str(repr(ArtifactTypeEnum))
+str(repr(Artifact))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CloneableArtifact(object):
-    """Cloneable Artifact Parameters object"""
+class ArtifactToCollectionRequest(object):
+    """Request to append Artifact to Collection"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.artifactDetails = (
             None if not fromDict or propDict.get(
-                "name"
+                "artifactDetails"
             ) is None
-            else propDict["name"])
-        self.org = (
+            else propDict["artifactDetails"])
+        self.artifactType = (
             None if not fromDict or propDict.get(
-                "org"
+                "artifactType"
             ) is None
-            else propDict["org"])
-        self.team = (
+            else propDict["artifactType"])
+        self.collectionDetails = (
             None if not fromDict or propDict.get(
-                "team"
+                "collectionDetails"
             ) is None
-            else propDict["team"])
-        self.version = (
-            None if not fromDict or propDict.get(
-                "version"
-            ) is None
-            else propDict["version"])
-
-    @property
-    def name(self):
-        """str: Unique name of the artifact"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
-        else:
-            raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
+            else propDict["collectionDetails"])
 
     @property
-    def org(self):
-        """str: Name of the org that the artifact belongs to"""
-        return self._org
-
-    @org.setter
-    def org(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._org = value
+    def artifactDetails(self):
+        """Artifact: NGC Artifact"""
+        return self._artifactDetails
+
+    @artifactDetails.setter
+    def artifactDetails(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._artifactDetails = value
         else:
             raise TypeError(
-                'Property "org" of type "list<str>" set to wrong type'
+                'Property "artifactDetails" of type "list<Artifact>" set to w'
+                'rong type'
             )
 
     @property
-    def team(self):
-        """str: Name of the team that the artifact belongs to"""
-        return self._team
-
-    @team.setter
-    def team(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._team = value
+    def artifactType(self):
+        """ """
+        return self._artifactType
+
+    @artifactType.setter
+    def artifactType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._artifactType = value
         else:
             raise TypeError(
-                'Property "team" of type "list<str>" set to wrong type'
+                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def version(self):
-        """str: ID of the version or tag"""
-        return self._version
-
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
+    def collectionDetails(self):
+        """Artifact: NGC Artifact"""
+        return self._collectionDetails
+
+    @collectionDetails.setter
+    def collectionDetails(self, value):
+        if value is not None and not isinstance(value, Artifact):
+            value = Artifact(value)
+        if (value is None) or isinstance(value, Artifact):
+            self._collectionDetails = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "collectionDetails" of type "list<Artifact>" set to'
+                ' wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._org is not None:
-            result["org"] = \
-                self._org
-        if self._team is not None:
-            result["team"] = \
-                self._team
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._artifactDetails:
+            result["artifactDetails"] = \
+                self._artifactDetails.toDict() if self._artifactDetails is not None else None
+        if self._artifactType is not None:
+            result["artifactType"] = \
+                self._artifactType
+        if self._collectionDetails:
+            result["collectionDetails"] = \
+                self._collectionDetails.toDict() if self._collectionDetails is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._artifactType is None:
+            raise ValueError(
+                "ArtifactToCollectionRequest.artifactType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._collectionDetails is None:
+            raise ValueError(
+                "ArtifactToCollectionRequest.collectionDetails doesnt match requirement:" 
+                "required: True"
+            )
+        if self._artifactDetails is None:
+            raise ValueError(
+                "ArtifactToCollectionRequest.artifactDetails doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._collectionDetails is not None): self._collectionDetails.isValid()
+        if (self._artifactDetails is not None): self._artifactDetails.isValid()
         return True
```

## Comparing `ngccli/data/model/CloudServiceProviderCreateRequest.py` & `ngcbpc/data/registry/ManifestByTagV2Response.py`

 * *Files 16% similar despite different names*

```diff
@@ -6,215 +6,226 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
+from .ManifestV2Config import ManifestV2Config
+from .RequestStatus import RequestStatus
+from .ManifestV2Layer import ManifestV2Layer
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
+str(repr(RequestStatus))
+str(repr(ManifestV2Layer))
+str(repr(ManifestV2Config))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CloudServiceProviderCreateRequest(object):
-    """Request to create a new Cloud Service Provider"""
+class ManifestByTagV2Response(object):
+    """Image's manifest of V2 API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.config = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "config"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.description = (
+            else propDict["config"])
+        self.imageDigest = (
             None if not fromDict or propDict.get(
-                "description"
+                "imageDigest"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else propDict["imageDigest"])
+        self.layers = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "layers"
             ) is None
-            else propDict["displayName"])
-        self.isEnabled = (
+            else [ ManifestV2Layer(i)
+            for i in propDict["layers"] ])
+        self.manifestSize = (
             None if not fromDict or propDict.get(
-                "isEnabled"
+                "manifestSize"
             ) is None
-            else propDict["isEnabled"])
-        self.labels = (
+            else propDict["manifestSize"])
+        self.mediaType = (
             None if not fromDict or propDict.get(
-                "labels"
+                "mediaType"
             ) is None
-            else propDict["labels"])
-        self.logo = (
+            else propDict["mediaType"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "logo"
+                "requestStatus"
             ) is None
-            else propDict["logo"])
-        self.name = (
+            else propDict["requestStatus"])
+        self.schemaVersion = (
             None if not fromDict or propDict.get(
-                "name"
+                "schemaVersion"
             ) is None
-            else propDict["name"])
+            else propDict["schemaVersion"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def config(self):
+        """ """
+        return self._config
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    @config.setter
+    def config(self, value):
+        if value is not None and not isinstance(value, ManifestV2Config):
+            value = ManifestV2Config(value)
+        if (value is None) or isinstance(value, ManifestV2Config):
+            self._config = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "config" of type "list<ManifestV2Config>" set to wr'
+                'ong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the Cloud Service Provider"""
-        return self._description
+    def imageDigest(self):
+        """str: Digest of the image. This links the tag to image digest. This 
+        digest should be deleted in order to delete image. Note: this 
+        field is not part the application/vnd.docker.distribution.manifest.v2+
+        json schema definition"""
+        return self._imageDigest
 
-    @description.setter
-    def description(self, value):
+    @imageDigest.setter
+    def imageDigest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._imageDigest = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "imageDigest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the Cloud Service Provider"""
-        return self._displayName
+    def layers(self):
+        """ """
+        return self._layers
 
-    @displayName.setter
-    def displayName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+    @layers.setter
+    def layers(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._layers = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "layers" of type "list<ManifestV2Layer>" set to wro'
+                'ng type'
             )
 
     @property
-    def isEnabled(self):
-        """bool: Determines if this Cloud Service Provider is enabled"""
-        return self._isEnabled
+    def manifestSize(self):
+        """int: Size of the manifest JSON content extracted from the registry 
+        response headers. Note: this field is not part the application
+        /vnd.docker.distribution.manifest.v2+json schema definition"""
+        return self._manifestSize
 
-    @isEnabled.setter
-    def isEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isEnabled = value
+    @manifestSize.setter
+    def manifestSize(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._manifestSize = value
         else:
             raise TypeError(
-                'Property "isEnabled" of type "list<bool>" set to wrong type'
+                'Property "manifestSize" of type "list<int>" set to wrong typ'
+                'e'
             )
 
     @property
-    def labels(self):
-        """list: Labels that are associated with the Cloud Service Provider"""
-        return self._labels
+    def mediaType(self):
+        """str: defines version. must be 'application/vnd.docker.distribution.
+        manifest.v2+json'"""
+        return self._mediaType
 
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labels = value
+    @mediaType.setter
+    def mediaType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._mediaType = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
+                'Property "mediaType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
+    def requestStatus(self):
+        """ """
+        return self._requestStatus
 
-    @logo.setter
-    def logo(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._logo = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     @property
-    def name(self):
-        """str: Unique name of the Cloud Service Provider"""
-        return self._name
+    def schemaVersion(self):
+        """int: Response schema version"""
+        return self._schemaVersion
 
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    @schemaVersion.setter
+    def schemaVersion(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._schemaVersion = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "schemaVersion" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._isEnabled is not None:
-            result["isEnabled"] = \
-                self._isEnabled
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._config:
+            result["config"] = \
+                self._config.toDict() if self._config is not None else None
+        if self._imageDigest is not None:
+            result["imageDigest"] = \
+                self._imageDigest
+        if self._layers:
+            result["layers"] = [
+                i.toDict() for i in self._layers 
+            ] if self._layers else []
+        if self._manifestSize is not None:
+            result["manifestSize"] = \
+                self._manifestSize
+        if self._mediaType is not None:
+            result["mediaType"] = \
+                self._mediaType
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._schemaVersion is not None:
+            result["schemaVersion"] = \
+                self._schemaVersion
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "CloudServiceProviderCreateRequest.name doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._attributes is not None):
-            for obj in self._attributes:
+        if (self._config is not None): self._config.isValid()
+        if (self._layers is not None):
+            for obj in self._layers:
                 if (obj is not None): obj.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/CloudServiceProviderListResponse.py` & `ngcbpc/data/uis/NvcfOrgResponse.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,69 +6,91 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CloudServiceProvider import CloudServiceProvider
+from .NvcfCluster import NvcfCluster
 from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(CloudServiceProvider))
 str(repr(PaginationInfo))
+str(repr(RequestStatus))
+str(repr(NvcfCluster))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CloudServiceProviderListResponse(object):
-    """Response to list Cloud Service Providers request"""
+class NvcfOrgResponse(object):
+    """NVCF Organization Configuration Response"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.cloudServiceProviders = (
+        self.billingAccountId = (
             None if not fromDict or propDict.get(
-                "cloudServiceProviders"
+                "billingAccountId"
             ) is None
-            else [ CloudServiceProvider(i)
-            for i in propDict["cloudServiceProviders"] ])
+            else propDict["billingAccountId"])
+        self.clusters = (
+            None if not fromDict or propDict.get(
+                "clusters"
+            ) is None
+            else [ NvcfCluster(i)
+            for i in propDict["clusters"] ])
         self.paginationInfo = (
             None if not fromDict or propDict.get(
                 "paginationInfo"
             ) is None
             else propDict["paginationInfo"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def cloudServiceProviders(self):
+    def billingAccountId(self):
+        """str: Billing account ID."""
+        return self._billingAccountId
+
+    @billingAccountId.setter
+    def billingAccountId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._billingAccountId = value
+        else:
+            raise TypeError(
+                'Property "billingAccountId" of type "list<str>" set to wrong'
+                ' type'
+            )
+
+    @property
+    def clusters(self):
         """ """
-        return self._cloudServiceProviders
+        return self._clusters
 
-    @cloudServiceProviders.setter
-    def cloudServiceProviders(self, value):
+    @clusters.setter
+    def clusters(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._cloudServiceProviders = value
+            self._clusters = value
         else:
             raise TypeError(
-                'Property "cloudServiceProviders" of type "list<CloudServiceP'
-                'rovider>" set to wrong type'
+                'Property "clusters" of type "list<NvcfCluster>" set to wrong'
+                ' type'
             )
 
     @property
     def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
+        """PaginationInfo: object that describes the pagination information"""
         return self._paginationInfo
 
     @paginationInfo.setter
     def paginationInfo(self, value):
         if value is not None and not isinstance(value, PaginationInfo):
             value = PaginationInfo(value)
         if (value is None) or isinstance(value, PaginationInfo):
@@ -77,15 +99,15 @@
             raise TypeError(
                 'Property "paginationInfo" of type "list<PaginationInfo>" set'
                 ' to wrong type'
             )
 
     @property
     def requestStatus(self):
-        """RequestStatus: Request status information"""
+        """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
@@ -94,18 +116,21 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._cloudServiceProviders:
-            result["cloudServiceProviders"] = [
-                i.toDict() for i in self._cloudServiceProviders 
-            ] if self._cloudServiceProviders else []
+        if self._billingAccountId is not None:
+            result["billingAccountId"] = \
+                self._billingAccountId
+        if self._clusters:
+            result["clusters"] = [
+                i.toDict() for i in self._clusters 
+            ] if self._clusters else []
         if self._paginationInfo:
             result["paginationInfo"] = \
                 self._paginationInfo.toDict() if self._paginationInfo is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
@@ -113,15 +138,15 @@
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._cloudServiceProviders is not None):
-            for obj in self._cloudServiceProviders:
+        if (self._clusters is not None):
+            for obj in self._clusters:
                 if (obj is not None): obj.isValid()
         if (self._paginationInfo is not None): self._paginationInfo.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/CloudServiceProviderUpdateRequest.py` & `ngcbpc/data/model/MultipartUploadCreateResponse.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,186 +6,178 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ArtifactAttribute import ArtifactAttribute
+from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
+str(repr(RequestStatus))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CloudServiceProviderUpdateRequest(object):
-    """Request to update existing Cloud Service Provider"""
+class MultipartUploadCreateResponse(object):
+    """Response body for creating a multipart upload for artifacts"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.paginationInfo = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "paginationInfo"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.description = (
+            else propDict["paginationInfo"])
+        self.partSize = (
             None if not fromDict or propDict.get(
-                "description"
+                "partSize"
             ) is None
-            else propDict["description"])
-        self.displayName = (
+            else propDict["partSize"])
+        self.requestStatus = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "requestStatus"
             ) is None
-            else propDict["displayName"])
-        self.isEnabled = (
+            else propDict["requestStatus"])
+        self.uploadID = (
             None if not fromDict or propDict.get(
-                "isEnabled"
+                "uploadID"
             ) is None
-            else propDict["isEnabled"])
-        self.labels = (
+            else propDict["uploadID"])
+        self.urls = (
             None if not fromDict or propDict.get(
-                "labels"
+                "urls"
             ) is None
-            else propDict["labels"])
-        self.logo = (
-            None if not fromDict or propDict.get(
-                "logo"
-            ) is None
-            else propDict["logo"])
+            else propDict["urls"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def paginationInfo(self):
+        """PaginationInfo: Pagination Information"""
+        return self._paginationInfo
 
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
+    @paginationInfo.setter
+    def paginationInfo(self, value):
+        if value is not None and not isinstance(value, PaginationInfo):
+            value = PaginationInfo(value)
+        if (value is None) or isinstance(value, PaginationInfo):
+            self._paginationInfo = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "paginationInfo" of type "list<PaginationInfo>" set'
+                ' to wrong type'
             )
 
     @property
-    def description(self):
-        """str: Description of the Cloud Service Provider"""
-        return self._description
+    def partSize(self):
+        """long: The size of each part upload in bytes"""
+        return self._partSize
 
-    @description.setter
-    def description(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._description = value
+    @partSize.setter
+    def partSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._partSize = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "partSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name of the Cloud Service Provider"""
-        return self._displayName
+    def requestStatus(self):
+        """RequestStatus: Request status information"""
+        return self._requestStatus
 
-    @displayName.setter
-    def displayName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+    @requestStatus.setter
+    def requestStatus(self, value):
+        if value is not None and not isinstance(value, RequestStatus):
+            value = RequestStatus(value)
+        if (value is None) or isinstance(value, RequestStatus):
+            self._requestStatus = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "requestStatus" of type "list<RequestStatus>" set t'
+                'o wrong type'
             )
 
     @property
-    def isEnabled(self):
-        """bool: Determines if this Cloud Service Provider is enabled"""
-        return self._isEnabled
-
-    @isEnabled.setter
-    def isEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isEnabled = value
+    def uploadID(self):
+        """str: The unique ID assigned by AWS for this multipart upload to ass
+        ociate all upload parts"""
+        return self._uploadID
+
+    @uploadID.setter
+    def uploadID(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._uploadID = value
         else:
             raise TypeError(
-                'Property "isEnabled" of type "list<bool>" set to wrong type'
+                'Property "uploadID" of type "list<str>" set to wrong type'
             )
 
     @property
-    def labels(self):
-        """list: Labels that are associated with the Cloud Service Provider"""
-        return self._labels
+    def urls(self):
+        """list: List of presigned urls for upload"""
+        return self._urls
 
-    @labels.setter
-    def labels(self, value):
+    @urls.setter
+    def urls(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._labels = value
-        else:
-            raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
-
-    @logo.setter
-    def logo(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._logo = value
+            self._urls = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "urls" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._isEnabled is not None:
-            result["isEnabled"] = \
-                self._isEnabled
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
+        if self._paginationInfo:
+            result["paginationInfo"] = \
+                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._partSize is not None:
+            result["partSize"] = \
+                self._partSize
+        if self._requestStatus:
+            result["requestStatus"] = \
+                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._uploadID is not None:
+            result["uploadID"] = \
+                self._uploadID
+        if self._urls is not None:
+            result["urls"] = \
+                self._urls
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
+        if self._uploadID is None:
+            raise ValueError(
+                "MultipartUploadCreateResponse.uploadID doesnt match requirement:" 
+                "required: True"
+            )
+        if self._partSize is None:
+            raise ValueError(
+                "MultipartUploadCreateResponse.partSize doesnt match requirement:" 
+                "required: True"
+            )
+        if self._urls is None:
+            raise ValueError(
+                "MultipartUploadCreateResponse.urls doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._paginationInfo is not None): self._paginationInfo.isValid()
+        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/Collection.py` & `ngcbpc/data/registry/RepositoryInfoUpdateRequest.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,140 +6,119 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AccessTypeEnum import AccessTypeEnum
-from .ArtifactAttribute import ArtifactAttribute
-from .CollectionCategoryType import CollectionCategoryTypeEnum
 from .ProductNamesEnum import ProductNamesEnum
+from .AccessTypeEnum import AccessTypeEnum
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(CollectionCategoryTypeEnum))
 str(repr(ProductNamesEnum))
 str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class Collection(object):
-    """Collection object"""
+class RepositoryInfoUpdateRequest(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.accessType = (
             None if not fromDict or propDict.get(
                 "accessType"
             ) is None
             else propDict["accessType"])
-        self.attributes = (
-            None if not fromDict or propDict.get(
-                "attributes"
-            ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
         self.builtBy = (
             None if not fromDict or propDict.get(
                 "builtBy"
             ) is None
             else propDict["builtBy"])
-        self.canGuestDownload = (
+        self.canGuestPull = (
             None if not fromDict or propDict.get(
-                "canGuestDownload"
+                "canGuestPull"
             ) is None
-            else propDict["canGuestDownload"])
-        self.category = (
+            else propDict["canGuestPull"])
+        self.canPublicList = (
             None if not fromDict or propDict.get(
-                "category"
+                "canPublicList"
             ) is None
-            else propDict["category"])
-        self.createdDate = (
+            else propDict["canPublicList"])
+        self.categories = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "categories"
             ) is None
-            else propDict["createdDate"])
+            else propDict["categories"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
         self.displayName = (
             None if not fromDict or propDict.get(
                 "displayName"
             ) is None
             else propDict["displayName"])
+        self.isMultinodeEnabled = (
+            None if not fromDict or propDict.get(
+                "isMultinodeEnabled"
+            ) is None
+            else propDict["isMultinodeEnabled"])
         self.isPublic = (
             None if not fromDict or propDict.get(
                 "isPublic"
             ) is None
             else propDict["isPublic"])
-        self.isReadOnly = (
-            None if not fromDict or propDict.get(
-                "isReadOnly"
-            ) is None
-            else propDict["isReadOnly"])
         self.labels = (
             None if not fromDict or propDict.get(
                 "labels"
             ) is None
             else propDict["labels"])
+        self.labelsV2 = (
+            None if not fromDict or propDict.get(
+                "labelsV2"
+            ) is None
+            else propDict["labelsV2"])
         self.logo = (
             None if not fromDict or propDict.get(
                 "logo"
             ) is None
             else propDict["logo"])
-        self.name = (
-            None if not fromDict or propDict.get(
-                "name"
-            ) is None
-            else propDict["name"])
-        self.orgName = (
-            None if not fromDict or propDict.get(
-                "orgName"
-            ) is None
-            else propDict["orgName"])
-        self.ownerName = (
-            None if not fromDict or propDict.get(
-                "ownerName"
-            ) is None
-            else propDict["ownerName"])
         self.productNames = (
             None if not fromDict or propDict.get(
                 "productNames"
             ) is None
             else propDict["productNames"])
         self.publisher = (
             None if not fromDict or propDict.get(
                 "publisher"
             ) is None
             else propDict["publisher"])
-        self.shortDescription = (
+        self.scanEnabled = (
             None if not fromDict or propDict.get(
-                "shortDescription"
+                "scanEnabled"
             ) is None
-            else propDict["shortDescription"])
-        self.size = (
+            else propDict["scanEnabled"])
+        self.sharedWithOrgs = (
             None if not fromDict or propDict.get(
-                "size"
+                "sharedWithOrgs"
             ) is None
-            else propDict["size"])
-        self.teamName = (
+            else propDict["sharedWithOrgs"])
+        self.sharedWithTeams = (
             None if not fromDict or propDict.get(
-                "teamName"
+                "sharedWithTeams"
             ) is None
-            else propDict["teamName"])
-        self.updatedDate = (
+            else propDict["sharedWithTeams"])
+        self.shortDescription = (
             None if not fromDict or propDict.get(
-                "updatedDate"
+                "shortDescription"
             ) is None
-            else propDict["updatedDate"])
+            else propDict["shortDescription"])
 
     @property
     def accessType(self):
         """ """
         return self._accessType
 
     @accessType.setter
@@ -149,97 +128,82 @@
         else:
             raise TypeError(
                 'Property "accessType" of type "list<AccessTypeEnum>" set to '
                 'wrong type'
             )
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
-
-    @attributes.setter
-    def attributes(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._attributes = value
-        else:
-            raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
-            )
-
-    @property
     def builtBy(self):
-        """str: Organization that built the collection"""
+        """str: organization that built the repository"""
         return self._builtBy
 
     @builtBy.setter
     def builtBy(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._builtBy = value
         else:
             raise TypeError(
                 'Property "builtBy" of type "list<str>" set to wrong type'
             )
 
     @property
-    def canGuestDownload(self):
-        """bool: Indicates if a guest user can download"""
-        return self._canGuestDownload
+    def canGuestPull(self):
+        """ """
+        return self._canGuestPull
 
-    @canGuestDownload.setter
-    def canGuestDownload(self, value):
+    @canGuestPull.setter
+    def canGuestPull(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._canGuestDownload = value
+            self._canGuestPull = value
         else:
             raise TypeError(
-                'Property "canGuestDownload" of type "list<bool>" set to wron'
-                'g type'
+                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def category(self):
+    def canPublicList(self):
         """ """
-        return self._category
+        return self._canPublicList
 
-    @category.setter
-    def category(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._category = value
+    @canPublicList.setter
+    def canPublicList(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canPublicList = value
         else:
             raise TypeError(
-                'Property "category" of type "list<CollectionCategoryTypeEnum'
-                '>" set to wrong type'
+                'Property "canPublicList" of type "list<bool>" set to wrong t'
+                'ype'
             )
 
     @property
-    def createdDate(self):
-        """str: Creation date in ISO-8601 format"""
-        return self._createdDate
+    def categories(self):
+        """list: list of categories the repository belongs to"""
+        return self._categories
 
-    @createdDate.setter
-    def createdDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+    @categories.setter
+    def categories(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._categories = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "categories" of type "list<str>" set to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the collection"""
+        """str: description of the repo"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -247,138 +211,107 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def displayName(self):
-        """str: Display name"""
+        """ """
         return self._displayName
 
     @displayName.setter
     def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._displayName = value
         else:
             raise TypeError(
                 'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isPublic(self):
-        """bool: Determines if this collection is publicly accessible"""
-        return self._isPublic
+    def isMultinodeEnabled(self):
+        """bool: indicate if multinode job can be ran using the repo"""
+        return self._isMultinodeEnabled
 
-    @isPublic.setter
-    def isPublic(self, value):
+    @isMultinodeEnabled.setter
+    def isMultinodeEnabled(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isPublic = value
+            self._isMultinodeEnabled = value
         else:
             raise TypeError(
-                'Property "isPublic" of type "list<bool>" set to wrong type'
+                'Property "isMultinodeEnabled" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def isReadOnly(self):
-        """bool: indicate if current user has read only permissions"""
-        return self._isReadOnly
+    def isPublic(self):
+        """ """
+        return self._isPublic
 
-    @isReadOnly.setter
-    def isReadOnly(self, value):
+    @isPublic.setter
+    def isPublic(self, value):
         if value is not None and not isinstance(value, bool):
             value = bool(value)
         if (value is None) or isinstance(value, bool):
-            self._isReadOnly = value
+            self._isPublic = value
         else:
             raise TypeError(
-                'Property "isReadOnly" of type "list<bool>" set to wrong type'
+                'Property "isPublic" of type "list<bool>" set to wrong type'
             )
 
     @property
     def labels(self):
-        """ """
+        """list: list of labels on the repository"""
         return self._labels
 
     @labels.setter
     def labels(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
             self._labels = value
         else:
             raise TypeError(
                 'Property "labels" of type "list<str>" set to wrong type'
             )
 
     @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
-
-    @logo.setter
-    def logo(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._logo = value
-        else:
-            raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def name(self):
-        """str: Unique name of the collection"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
-        else:
-            raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def orgName(self):
-        """str: Name of the org that the collection belongs to"""
-        return self._orgName
+    def labelsV2(self):
+        """ """
+        return self._labelsV2
 
-    @orgName.setter
-    def orgName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+    @labelsV2.setter
+    def labelsV2(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._labelsV2 = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "labelsV2" of type "list<str>" set to wrong type'
             )
 
     @property
-    def ownerName(self):
-        """str: Name of the user who owns this version"""
-        return self._ownerName
+    def logo(self):
+        """str: url to repository logo"""
+        return self._logo
 
-    @ownerName.setter
-    def ownerName(self, value):
+    @logo.setter
+    def logo(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._ownerName = value
+            self._logo = value
         else:
             raise TypeError(
-                'Property "ownerName" of type "list<str>" set to wrong type'
+                'Property "logo" of type "list<str>" set to wrong type'
             )
 
     @property
     def productNames(self):
         """list: Product names"""
         return self._productNames
 
@@ -392,190 +325,171 @@
             raise TypeError(
                 'Property "productNames" of type "list<ProductNamesEnum>" set'
                 ' to wrong type'
             )
 
     @property
     def publisher(self):
-        """str: Organization that published this collection"""
+        """str: organization that published the repository"""
         return self._publisher
 
     @publisher.setter
     def publisher(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._publisher = value
         else:
             raise TypeError(
                 'Property "publisher" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shortDescription(self):
-        """str: Short description of the collection"""
-        return self._shortDescription
+    def scanEnabled(self):
+        """bool: Deprecated. This field is determined by org/team settings now
+        ."""
+        return self._scanEnabled
 
-    @shortDescription.setter
-    def shortDescription(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._shortDescription = value
+    @scanEnabled.setter
+    def scanEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._scanEnabled = value
         else:
             raise TypeError(
-                'Property "shortDescription" of type "list<str>" set to wrong'
-                ' type'
+                'Property "scanEnabled" of type "list<bool>" set to wrong typ'
+                'e'
             )
 
     @property
-    def size(self):
-        """long: Total count of collection items"""
-        return self._size
+    def sharedWithOrgs(self):
+        """list: list org names with which this repository is shared"""
+        return self._sharedWithOrgs
 
-    @size.setter
-    def size(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._size = value
+    @sharedWithOrgs.setter
+    def sharedWithOrgs(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._sharedWithOrgs = value
         else:
             raise TypeError(
-                'Property "size" of type "list<long>" set to wrong type'
+                'Property "sharedWithOrgs" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def teamName(self):
-        """str: Name of the team that the collection belongs to"""
-        return self._teamName
+    def sharedWithTeams(self):
+        """list: list teams (in format 'org/team') with which this repository 
+        is shared"""
+        return self._sharedWithTeams
 
-    @teamName.setter
-    def teamName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+    @sharedWithTeams.setter
+    def sharedWithTeams(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._sharedWithTeams = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "sharedWithTeams" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def updatedDate(self):
-        """str: Updated date in ISO-8601 format"""
-        return self._updatedDate
+    def shortDescription(self):
+        """str: description of the repo"""
+        return self._shortDescription
 
-    @updatedDate.setter
-    def updatedDate(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     def toDict(self):
         result = {}
         if self._accessType is not None:
             result["accessType"] = \
                 self._accessType
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
         if self._builtBy is not None:
             result["builtBy"] = \
                 self._builtBy
-        if self._canGuestDownload is not None:
-            result["canGuestDownload"] = \
-                self._canGuestDownload
-        if self._category is not None:
-            result["category"] = \
-                self._category
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
+        if self._canGuestPull is not None:
+            result["canGuestPull"] = \
+                self._canGuestPull
+        if self._canPublicList is not None:
+            result["canPublicList"] = \
+                self._canPublicList
+        if self._categories is not None:
+            result["categories"] = \
+                self._categories
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._displayName is not None:
             result["displayName"] = \
                 self._displayName
+        if self._isMultinodeEnabled is not None:
+            result["isMultinodeEnabled"] = \
+                self._isMultinodeEnabled
         if self._isPublic is not None:
             result["isPublic"] = \
                 self._isPublic
-        if self._isReadOnly is not None:
-            result["isReadOnly"] = \
-                self._isReadOnly
         if self._labels is not None:
             result["labels"] = \
                 self._labels
+        if self._labelsV2 is not None:
+            result["labelsV2"] = \
+                self._labelsV2
         if self._logo is not None:
             result["logo"] = \
                 self._logo
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._ownerName is not None:
-            result["ownerName"] = \
-                self._ownerName
         if self._productNames is not None:
             result["productNames"] = \
                 self._productNames
         if self._publisher is not None:
             result["publisher"] = \
                 self._publisher
+        if self._scanEnabled is not None:
+            result["scanEnabled"] = \
+                self._scanEnabled
+        if self._sharedWithOrgs is not None:
+            result["sharedWithOrgs"] = \
+                self._sharedWithOrgs
+        if self._sharedWithTeams is not None:
+            result["sharedWithTeams"] = \
+                self._sharedWithTeams
         if self._shortDescription is not None:
             result["shortDescription"] = \
                 self._shortDescription
-        if self._size is not None:
-            result["size"] = \
-                self._size
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._createdDate is not None
+        if (self._displayName is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            len(self._displayName) < 2):
             raise ValueError(
-                "Collection.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
+                "RepositoryInfoUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: minLength: 2")
+        if (self._displayName is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
-            raise ValueError(
-                "Collection.updatedDate: " + str(self._updatedDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if self._category is None:
+            len(self._displayName) > 64):
             raise ValueError(
-                "Collection.category doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._attributes is not None):
-            for obj in self._attributes:
-                if (obj is not None): obj.isValid()
+                "RepositoryInfoUpdateRequest.displayName: " + str(self._displayName) + 
+                " doesnt match requirement: maxLength: 64")
         return True
```

## Comparing `ngccli/data/model/CollectionListResponse.py` & `ngcbpc/data/model/ModelVersionCreateResponse.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,81 +6,79 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Collection import Collection
-from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
+from .Model import Model
+from .ModelVersion import ModelVersion
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Collection))
-str(repr(PaginationInfo))
+str(repr(Model))
+str(repr(ModelVersion))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionListResponse(object):
-    """Response to list collections request"""
+class ModelVersionCreateResponse(object):
+    """DEPRECATED - use ModelVersionResponse"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.collections = (
+        self.model = (
             None if not fromDict or propDict.get(
-                "collections"
+                "model"
             ) is None
-            else [ Collection(i)
-            for i in propDict["collections"] ])
-        self.paginationInfo = (
+            else propDict["model"])
+        self.modelVersion = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "modelVersion"
             ) is None
-            else propDict["paginationInfo"])
+            else propDict["modelVersion"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def collections(self):
-        """ """
-        return self._collections
-
-    @collections.setter
-    def collections(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._collections = value
+    def model(self):
+        """Model: Model object"""
+        return self._model
+
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
         else:
             raise TypeError(
-                'Property "collections" of type "list<Collection>" set to wro'
-                'ng type'
+                'Property "model" of type "list<Model>" set to wrong type'
             )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: Pagination Information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def modelVersion(self):
+        """ModelVersion: Model version object"""
+        return self._modelVersion
+
+    @modelVersion.setter
+    def modelVersion(self, value):
+        if value is not None and not isinstance(value, ModelVersion):
+            value = ModelVersion(value)
+        if (value is None) or isinstance(value, ModelVersion):
+            self._modelVersion = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "modelVersion" of type "list<ModelVersion>" set to '
+                'wrong type'
             )
 
     @property
     def requestStatus(self):
         """RequestStatus: Request status information"""
         return self._requestStatus
 
@@ -94,34 +92,31 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._collections:
-            result["collections"] = [
-                i.toDict() for i in self._collections 
-            ] if self._collections else []
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._modelVersion:
+            result["modelVersion"] = \
+                self._modelVersion.toDict() if self._modelVersion is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._collections is not None):
-            for obj in self._collections:
-                if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
+        if (self._model is not None): self._model.isValid()
+        if (self._modelVersion is not None): self._modelVersion.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/CollectionOperation.py` & `basecommand/data/pym/ProjectTemplateModificationRequest.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,103 +6,97 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ProjectTemplateModifyParams import ProjectTemplateModifyParams
 
 # Unused import over optimization prevention
+str(repr(ProjectTemplateModifyParams))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionOperation(object):
-    """Collection operation object"""
+class ProjectTemplateModificationRequest(object):
+    """Project Template Modification Request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.operation = (
+        self.params = (
             None if not fromDict or propDict.get(
-                "operation"
+                "params"
             ) is None
-            else propDict["operation"])
-        self.path = (
+            else propDict["params"])
+        self.version = (
             None if not fromDict or propDict.get(
-                "path"
+                "version"
             ) is None
-            else propDict["path"])
+            else propDict["version"])
 
     @property
-    def operation(self):
-        """str: Collection operation"""
-        return self._operation
-
-    @operation.setter
-    def operation(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._operation = value
+    def params(self):
+        """ProjectTemplateModifyParams: Project template modification paramete
+        rs"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ProjectTemplateModifyParams):
+            value = ProjectTemplateModifyParams(value)
+        if (value is None) or isinstance(value, ProjectTemplateModifyParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "operation" of type "list<str>" set to wrong type'
+                'Property "params" of type "list<ProjectTemplateModifyParams>'
+                '" set to wrong type'
             )
 
     @property
-    def path(self):
-        """str: Path to a collection item in a scoped format"""
-        return self._path
+    def version(self):
+        """str: Payload version"""
+        return self._version
 
-    @path.setter
-    def path(self, value):
+    @version.setter
+    def version(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._path = value
+            self._version = value
         else:
             raise TypeError(
-                'Property "path" of type "list<str>" set to wrong type'
+                'Property "version" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._operation is not None:
-            result["operation"] = \
-                self._operation
-        if self._path is not None:
-            result["path"] = \
-                self._path
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._version is not None:
+            result["version"] = \
+                self._version
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._operation is not None
-            and
-            len(self._operation) > 255):
+        if self._version is None:
             raise ValueError(
-                "CollectionOperation.operation: " + str(self._operation) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._path is not None
-            and
-            len(self._path) > 255):
-            raise ValueError(
-                "CollectionOperation.path: " + str(self._path) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._path is not None
-            and
-            not re.match(
-                r"^(/(?!/)([\w- %\.(?!\.)])+)+$",
-                 self._path)):
+                "ProjectTemplateModificationRequest.version doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
             raise ValueError(
-                "CollectionOperation.path: " + str(self._path) + 
-                " doesnt match requirement: pattern: ^(/(?!/)([\w- %\.(?!\.)]"
-                ")+)+$")
+                "ProjectTemplateModificationRequest.params doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._params is not None): self._params.isValid()
         return True
```

## Comparing `ngccli/data/model/CollectionPatchRequest.py` & `ngcbpc/data/uis/NvcfGpuUsageRequest.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,72 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CollectionOperation import CollectionOperation
+from .NvcfGpuUsage import NvcfGpuUsage
 
 # Unused import over optimization prevention
-str(repr(CollectionOperation))
+str(repr(NvcfGpuUsage))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionPatchRequest(object):
-    """Request to patch a collection"""
+class NvcfGpuUsageRequest(object):
+    """NVCF GPU Usage request body"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.operations = (
+        self.gpuUsages = (
             None if not fromDict or propDict.get(
-                "operations"
+                "gpuUsages"
             ) is None
-            else [ CollectionOperation(i)
-            for i in propDict["operations"] ])
+            else [ NvcfGpuUsage(i)
+            for i in propDict["gpuUsages"] ])
 
     @property
-    def operations(self):
+    def gpuUsages(self):
         """ """
-        return self._operations
+        return self._gpuUsages
 
-    @operations.setter
-    def operations(self, value):
+    @gpuUsages.setter
+    def gpuUsages(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._operations = value
+            self._gpuUsages = value
         else:
             raise TypeError(
-                'Property "operations" of type "list<CollectionOperation>" se'
-                't to wrong type'
+                'Property "gpuUsages" of type "list<NvcfGpuUsage>" set to wro'
+                'ng type'
             )
 
     def toDict(self):
         result = {}
-        if self._operations:
-            result["operations"] = [
-                i.toDict() for i in self._operations 
-            ] if self._operations else []
+        if self._gpuUsages:
+            result["gpuUsages"] = [
+                i.toDict() for i in self._gpuUsages 
+            ] if self._gpuUsages else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._operations is not None
-            and
-            len(self._operations) > 100):
-            raise ValueError(
-                "CollectionPatchRequest.operations: " + str(self._operations) + 
-                " doesnt match requirement: maxItems: 100")
-        if (self._operations is not None):
-            for obj in self._operations:
+        if (self._gpuUsages is not None):
+            for obj in self._gpuUsages:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/CollectionPublishRequest.py` & `organization/data/subscription_management_service/CreateOrderRequest.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,160 +6,117 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AccessTypeEnum import AccessTypeEnum
-from .ProductNamesEnum import ProductNamesEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNamesEnum))
-str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionPublishRequest(object):
-    """Request to publish a collection"""
+class CreateOrderRequest(object):
+    """Create order request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accessType = (
+        self.productName = (
             None if not fromDict or propDict.get(
-                "accessType"
+                "productName"
             ) is None
-            else propDict["accessType"])
-        self.canGuestPull = (
+            else propDict["productName"])
+        self.productRatePlanSku = (
             None if not fromDict or propDict.get(
-                "canGuestPull"
+                "productRatePlanSku"
             ) is None
-            else propDict["canGuestPull"])
-        self.canPublicList = (
+            else propDict["productRatePlanSku"])
+        self.quantity = (
             None if not fromDict or propDict.get(
-                "canPublicList"
+                "quantity"
             ) is None
-            else propDict["canPublicList"])
-        self.isPublic = (
-            None if not fromDict or propDict.get(
-                "isPublic"
-            ) is None
-            else propDict["isPublic"])
-        self.productNames = (
-            None if not fromDict or propDict.get(
-                "productNames"
-            ) is None
-            else propDict["productNames"])
-
-    @property
-    def accessType(self):
-        """ """
-        return self._accessType
-
-    @accessType.setter
-    def accessType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._accessType = value
-        else:
-            raise TypeError(
-                'Property "accessType" of type "list<AccessTypeEnum>" set to '
-                'wrong type'
-            )
-
-    @property
-    def canGuestPull(self):
-        """ """
-        return self._canGuestPull
-
-    @canGuestPull.setter
-    def canGuestPull(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canGuestPull = value
-        else:
-            raise TypeError(
-                'Property "canGuestPull" of type "list<bool>" set to wrong ty'
-                'pe'
-            )
+            else propDict["quantity"])
 
     @property
-    def canPublicList(self):
-        """ """
-        return self._canPublicList
-
-    @canPublicList.setter
-    def canPublicList(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._canPublicList = value
+    def productName(self):
+        """str: name of the product"""
+        return self._productName
+
+    @productName.setter
+    def productName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productName = value
         else:
             raise TypeError(
-                'Property "canPublicList" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "productName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def isPublic(self):
-        """ """
-        return self._isPublic
-
-    @isPublic.setter
-    def isPublic(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isPublic = value
+    def productRatePlanSku(self):
+        """str: product rate plan sku of the product"""
+        return self._productRatePlanSku
+
+    @productRatePlanSku.setter
+    def productRatePlanSku(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._productRatePlanSku = value
         else:
             raise TypeError(
-                'Property "isPublic" of type "list<bool>" set to wrong type'
+                'Property "productRatePlanSku" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def productNames(self):
-        """list: Product names"""
-        return self._productNames
-
-    @productNames.setter
-    def productNames(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productNames = value
+    def quantity(self):
+        """int: quantity selected for quantity based products"""
+        return self._quantity
+
+    @quantity.setter
+    def quantity(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._quantity = value
         else:
             raise TypeError(
-                'Property "productNames" of type "list<ProductNamesEnum>" set'
-                ' to wrong type'
+                'Property "quantity" of type "list<int>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accessType is not None:
-            result["accessType"] = \
-                self._accessType
-        if self._canGuestPull is not None:
-            result["canGuestPull"] = \
-                self._canGuestPull
-        if self._canPublicList is not None:
-            result["canPublicList"] = \
-                self._canPublicList
-        if self._isPublic is not None:
-            result["isPublic"] = \
-                self._isPublic
-        if self._productNames is not None:
-            result["productNames"] = \
-                self._productNames
+        if self._productName is not None:
+            result["productName"] = \
+                self._productName
+        if self._productRatePlanSku is not None:
+            result["productRatePlanSku"] = \
+                self._productRatePlanSku
+        if self._quantity is not None:
+            result["quantity"] = \
+                self._quantity
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._productName is None:
+            raise ValueError(
+                "CreateOrderRequest.productName doesnt match requirement:" 
+                "required: True"
+            )
+        if self._productRatePlanSku is None:
+            raise ValueError(
+                "CreateOrderRequest.productRatePlanSku doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/model/CollectionResponse.py` & `ngcbpc/data/registry/SecurityRatingsResponse.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,90 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Collection import Collection
-from .RequestStatus import RequestStatus
+from .SecurityRatingDescription import SecurityRatingDescription
 
 # Unused import over optimization prevention
-str(repr(RequestStatus))
-str(repr(Collection))
+str(repr(SecurityRatingDescription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionResponse(object):
-    """Response to create collection request"""
+class SecurityRatingsResponse(object):
+    """Response listing security ratings and their descriptions"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.collection = (
+        self.ratings = (
             None if not fromDict or propDict.get(
-                "collection"
+                "ratings"
             ) is None
-            else propDict["collection"])
-        self.requestStatus = (
-            None if not fromDict or propDict.get(
-                "requestStatus"
-            ) is None
-            else propDict["requestStatus"])
-
-    @property
-    def collection(self):
-        """Collection: Collection object"""
-        return self._collection
-
-    @collection.setter
-    def collection(self, value):
-        if value is not None and not isinstance(value, Collection):
-            value = Collection(value)
-        if (value is None) or isinstance(value, Collection):
-            self._collection = value
-        else:
-            raise TypeError(
-                'Property "collection" of type "list<Collection>" set to wron'
-                'g type'
-            )
+            else [ SecurityRatingDescription(i)
+            for i in propDict["ratings"] ])
 
     @property
-    def requestStatus(self):
-        """RequestStatus: Request status information"""
-        return self._requestStatus
-
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    def ratings(self):
+        """ """
+        return self._ratings
+
+    @ratings.setter
+    def ratings(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._ratings = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "ratings" of type "list<SecurityRatingDescription>"'
+                ' set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._collection:
-            result["collection"] = \
-                self._collection.toDict() if self._collection is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._ratings:
+            result["ratings"] = [
+                i.toDict() for i in self._ratings 
+            ] if self._ratings else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._collection is not None): self._collection.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
+        if (self._ratings is not None):
+            for obj in self._ratings:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/CollectionUpdateRequest.py` & `ngcbpc/data/registry/MetaImageDetails.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,344 +6,383 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CollectionCategoryType import CollectionCategoryTypeEnum
-from .ArtifactAttribute import ArtifactAttribute
+from .ImageArchitectureVariant import ImageArchitectureVariant
+from .ScanStatus import ScanStatusEnum
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(CollectionCategoryTypeEnum))
+str(repr(ImageArchitectureVariant))
+str(repr(ScanStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CollectionUpdateRequest(object):
-    """Request to update a collection"""
+class MetaImageDetails(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.architectureVariants = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "architectureVariants"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["attributes"] ])
-        self.builtBy = (
+            else [ ImageArchitectureVariant(i)
+            for i in propDict["architectureVariants"] ])
+        self.baseImageName = (
             None if not fromDict or propDict.get(
-                "builtBy"
+                "baseImageName"
             ) is None
-            else propDict["builtBy"])
-        self.category = (
-            None if not fromDict or propDict.get(
-                "category"
-            ) is None
-            else propDict["category"])
+            else propDict["baseImageName"])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.displayName = (
+        self.digest = (
+            None if not fromDict or propDict.get(
+                "digest"
+            ) is None
+            else propDict["digest"])
+        self.isMultiArchitecture = (
+            None if not fromDict or propDict.get(
+                "isMultiArchitecture"
+            ) is None
+            else propDict["isMultiArchitecture"])
+        self.isSigned = (
+            None if not fromDict or propDict.get(
+                "isSigned"
+            ) is None
+            else propDict["isSigned"])
+        self.pushedDate = (
+            None if not fromDict or propDict.get(
+                "pushedDate"
+            ) is None
+            else propDict["pushedDate"])
+        self.scanDate = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "scanDate"
             ) is None
-            else propDict["displayName"])
-        self.labels = (
+            else propDict["scanDate"])
+        self.scanEnabled = (
             None if not fromDict or propDict.get(
-                "labels"
+                "scanEnabled"
             ) is None
-            else propDict["labels"])
-        self.labelsV2 = (
+            else propDict["scanEnabled"])
+        self.scanStatus = (
             None if not fromDict or propDict.get(
-                "labelsV2"
+                "scanStatus"
             ) is None
-            else propDict["labelsV2"])
-        self.logo = (
+            else propDict["scanStatus"])
+        self.size = (
             None if not fromDict or propDict.get(
-                "logo"
+                "size"
             ) is None
-            else propDict["logo"])
-        self.ownerName = (
+            else propDict["size"])
+        self.tag = (
             None if not fromDict or propDict.get(
-                "ownerName"
+                "tag"
             ) is None
-            else propDict["ownerName"])
-        self.publisher = (
+            else propDict["tag"])
+        self.updatedDate = (
             None if not fromDict or propDict.get(
-                "publisher"
+                "updatedDate"
             ) is None
-            else propDict["publisher"])
-        self.shortDescription = (
+            else propDict["updatedDate"])
+        self.user = (
             None if not fromDict or propDict.get(
-                "shortDescription"
+                "user"
             ) is None
-            else propDict["shortDescription"])
+            else propDict["user"])
 
     @property
-    def attributes(self):
-        """list: Attribute key/value pairs"""
-        return self._attributes
+    def architectureVariants(self):
+        """ """
+        return self._architectureVariants
 
-    @attributes.setter
-    def attributes(self, value):
+    @architectureVariants.setter
+    def architectureVariants(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._attributes = value
+            self._architectureVariants = value
         else:
             raise TypeError(
-                'Property "attributes" of type "list<ArtifactAttribute>" set '
-                'to wrong type'
+                'Property "architectureVariants" of type "list<ImageArchitect'
+                'ureVariant>" set to wrong type'
             )
 
     @property
-    def builtBy(self):
-        """str: organization that built the collection"""
-        return self._builtBy
+    def baseImageName(self):
+        """str: The base image name of this image"""
+        return self._baseImageName
 
-    @builtBy.setter
-    def builtBy(self, value):
+    @baseImageName.setter
+    def baseImageName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._builtBy = value
-        else:
-            raise TypeError(
-                'Property "builtBy" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def category(self):
-        """ """
-        return self._category
-
-    @category.setter
-    def category(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._category = value
+            self._baseImageName = value
         else:
             raise TypeError(
-                'Property "category" of type "list<CollectionCategoryTypeEnum'
-                '>" set to wrong type'
+                'Property "baseImageName" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
     def description(self):
-        """str: Description of the collection"""
+        """str: Image description, release notes, etc."""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name"""
-        return self._displayName
+    def digest(self):
+        """str: Image digest"""
+        return self._digest
 
-    @displayName.setter
-    def displayName(self, value):
+    @digest.setter
+    def digest(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._digest = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "digest" of type "list<str>" set to wrong type'
             )
 
     @property
-    def labels(self):
-        """ """
-        return self._labels
+    def isMultiArchitecture(self):
+        """bool: Flag indicating if this image supports multiple CPU platforms
+         and architectures"""
+        return self._isMultiArchitecture
 
-    @labels.setter
-    def labels(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labels = value
+    @isMultiArchitecture.setter
+    def isMultiArchitecture(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isMultiArchitecture = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
+                'Property "isMultiArchitecture" of type "list<bool>" set to w'
+                'rong type'
             )
 
     @property
-    def labelsV2(self):
-        """ """
-        return self._labelsV2
+    def isSigned(self):
+        """bool: whether the tag is signed"""
+        return self._isSigned
 
-    @labelsV2.setter
-    def labelsV2(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labelsV2 = value
+    @isSigned.setter
+    def isSigned(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isSigned = value
         else:
             raise TypeError(
-                'Property "labelsV2" of type "list<str>" set to wrong type'
+                'Property "isSigned" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
+    def pushedDate(self):
+        """str: Image pushed date in ISO-8601 format"""
+        return self._pushedDate
 
-    @logo.setter
-    def logo(self, value):
+    @pushedDate.setter
+    def pushedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logo = value
+            self._pushedDate = value
+        else:
+            raise TypeError(
+                'Property "pushedDate" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def scanDate(self):
+        """str: Deprecated: Use architectureVariants fields. Image scan date i
+        n ISO-8601 format"""
+        return self._scanDate
+
+    @scanDate.setter
+    def scanDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._scanDate = value
+        else:
+            raise TypeError(
+                'Property "scanDate" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def scanEnabled(self):
+        """bool: Whether image scanning is enabled"""
+        return self._scanEnabled
+
+    @scanEnabled.setter
+    def scanEnabled(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._scanEnabled = value
+        else:
+            raise TypeError(
+                'Property "scanEnabled" of type "list<bool>" set to wrong typ'
+                'e'
+            )
+
+    @property
+    def scanStatus(self):
+        """ScanStatusEnum: Image scan statuses"""
+        return self._scanStatus
+
+    @scanStatus.setter
+    def scanStatus(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._scanStatus = value
+        else:
+            raise TypeError(
+                'Property "scanStatus" of type "list<ScanStatusEnum>" set to '
+                'wrong type'
+            )
+
+    @property
+    def size(self):
+        """long: Image size in bytes"""
+        return self._size
+
+    @size.setter
+    def size(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._size = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "size" of type "list<long>" set to wrong type'
             )
 
     @property
-    def ownerName(self):
-        """str: Name of the user who owns this collection"""
-        return self._ownerName
+    def tag(self):
+        """str: Image tag"""
+        return self._tag
 
-    @ownerName.setter
-    def ownerName(self, value):
+    @tag.setter
+    def tag(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._ownerName = value
+            self._tag = value
         else:
             raise TypeError(
-                'Property "ownerName" of type "list<str>" set to wrong type'
+                'Property "tag" of type "list<str>" set to wrong type'
             )
 
     @property
-    def publisher(self):
-        """str: organization that published the collection"""
-        return self._publisher
+    def updatedDate(self):
+        """str: Image update date in ISO-8601 format"""
+        return self._updatedDate
 
-    @publisher.setter
-    def publisher(self, value):
+    @updatedDate.setter
+    def updatedDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._publisher = value
+            self._updatedDate = value
         else:
             raise TypeError(
-                'Property "publisher" of type "list<str>" set to wrong type'
+                'Property "updatedDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def shortDescription(self):
-        """str: Short description of the collection"""
-        return self._shortDescription
+    def user(self):
+        """str: Client id used to push the image"""
+        return self._user
 
-    @shortDescription.setter
-    def shortDescription(self, value):
+    @user.setter
+    def user(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._shortDescription = value
+            self._user = value
         else:
             raise TypeError(
-                'Property "shortDescription" of type "list<str>" set to wrong'
-                ' type'
+                'Property "user" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._builtBy is not None:
-            result["builtBy"] = \
-                self._builtBy
-        if self._category is not None:
-            result["category"] = \
-                self._category
+        if self._architectureVariants:
+            result["architectureVariants"] = [
+                i.toDict() for i in self._architectureVariants 
+            ] if self._architectureVariants else []
+        if self._baseImageName is not None:
+            result["baseImageName"] = \
+                self._baseImageName
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._labelsV2 is not None:
-            result["labelsV2"] = \
-                self._labelsV2
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
-        if self._ownerName is not None:
-            result["ownerName"] = \
-                self._ownerName
-        if self._publisher is not None:
-            result["publisher"] = \
-                self._publisher
-        if self._shortDescription is not None:
-            result["shortDescription"] = \
-                self._shortDescription
+        if self._digest is not None:
+            result["digest"] = \
+                self._digest
+        if self._isMultiArchitecture is not None:
+            result["isMultiArchitecture"] = \
+                self._isMultiArchitecture
+        if self._isSigned is not None:
+            result["isSigned"] = \
+                self._isSigned
+        if self._pushedDate is not None:
+            result["pushedDate"] = \
+                self._pushedDate
+        if self._scanDate is not None:
+            result["scanDate"] = \
+                self._scanDate
+        if self._scanEnabled is not None:
+            result["scanEnabled"] = \
+                self._scanEnabled
+        if self._scanStatus is not None:
+            result["scanStatus"] = \
+                self._scanStatus
+        if self._size is not None:
+            result["size"] = \
+                self._size
+        if self._tag is not None:
+            result["tag"] = \
+                self._tag
+        if self._updatedDate is not None:
+            result["updatedDate"] = \
+                self._updatedDate
+        if self._user is not None:
+            result["user"] = \
+                self._user
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._shortDescription is not None
-            and
-            len(self._shortDescription) > 255):
-            raise ValueError(
-                "CollectionUpdateRequest.shortDescription: " + str(self._shortDescription) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._displayName is not None
-            and
-            len(self._displayName) < 2):
-            raise ValueError(
-                "CollectionUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._displayName is not None
-            and
-            len(self._displayName) > 64):
-            raise ValueError(
-                "CollectionUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._logo is not None
-            and
-            len(self._logo) > 255):
-            raise ValueError(
-                "CollectionUpdateRequest.logo: " + str(self._logo) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._publisher is not None
-            and
-            len(self._publisher) > 255):
-            raise ValueError(
-                "CollectionUpdateRequest.publisher: " + str(self._publisher) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._ownerName is not None
-            and
-            len(self._ownerName) > 255):
-            raise ValueError(
-                "CollectionUpdateRequest.ownerName: " + str(self._ownerName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
+        if (self._architectureVariants is not None):
+            for obj in self._architectureVariants:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/CountableResource.py` & `organization/data/subscription_management_service/RequestCreateSubscriptionRequest.py`

 * *Files 21% similar despite different names*

```diff
@@ -14,95 +14,71 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CountableResource(object):
-    """Countable Resource object"""
+class RequestCreateSubscriptionRequest(object):
+    """Request of request to create subscription API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.defaultValue = (
+        self.retailer = (
             None if not fromDict or propDict.get(
-                "defaultValue"
+                "retailer"
             ) is None
-            else propDict["defaultValue"])
-        self.maxValue = (
+            else propDict["retailer"])
+        self.subscriptionToken = (
             None if not fromDict or propDict.get(
-                "maxValue"
+                "subscriptionToken"
             ) is None
-            else propDict["maxValue"])
-        self.minValue = (
-            None if not fromDict or propDict.get(
-                "minValue"
-            ) is None
-            else propDict["minValue"])
-
-    @property
-    def defaultValue(self):
-        """long: Deprecated: Default value. Please use actual CloudServiceProv
-        ider values instead"""
-        return self._defaultValue
-
-    @defaultValue.setter
-    def defaultValue(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._defaultValue = value
-        else:
-            raise TypeError(
-                'Property "defaultValue" of type "list<long>" set to wrong ty'
-                'pe'
-            )
+            else propDict["subscriptionToken"])
 
     @property
-    def maxValue(self):
-        """long: Maximum value"""
-        return self._maxValue
-
-    @maxValue.setter
-    def maxValue(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._maxValue = value
+    def retailer(self):
+        """str: name of the retailer"""
+        return self._retailer
+
+    @retailer.setter
+    def retailer(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._retailer = value
         else:
             raise TypeError(
-                'Property "maxValue" of type "list<long>" set to wrong type'
+                'Property "retailer" of type "list<str>" set to wrong type'
             )
 
     @property
-    def minValue(self):
-        """long: Minimum value"""
-        return self._minValue
-
-    @minValue.setter
-    def minValue(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._minValue = value
+    def subscriptionToken(self):
+        """str: a token which can be used to exchange subscription details fro
+        m CSP"""
+        return self._subscriptionToken
+
+    @subscriptionToken.setter
+    def subscriptionToken(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._subscriptionToken = value
         else:
             raise TypeError(
-                'Property "minValue" of type "list<long>" set to wrong type'
+                'Property "subscriptionToken" of type "list<str>" set to wron'
+                'g type'
             )
 
     def toDict(self):
         result = {}
-        if self._defaultValue is not None:
-            result["defaultValue"] = \
-                self._defaultValue
-        if self._maxValue is not None:
-            result["maxValue"] = \
-                self._maxValue
-        if self._minValue is not None:
-            result["minValue"] = \
-                self._minValue
+        if self._retailer is not None:
+            result["retailer"] = \
+                self._retailer
+        if self._subscriptionToken is not None:
+            result["subscriptionToken"] = \
+                self._subscriptionToken
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
```

## Comparing `ngccli/data/model/CustomMetricGroup.py` & `organization/data/subscription_management_service/CreateProductOfferRequest.py`

 * *Files 23% similar despite different names*

```diff
@@ -6,96 +6,71 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CustomMetric import CustomMetric
+from .ProductOffer import ProductOffer
 
 # Unused import over optimization prevention
-str(repr(CustomMetric))
+str(repr(ProductOffer))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class CustomMetricGroup(object):
-    """Defines the group of custom metrics."""
+class CreateProductOfferRequest(object):
+    """Create product offer request object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.attributes = (
+        self.offers = (
             None if not fromDict or propDict.get(
-                "attributes"
+                "offers"
             ) is None
-            else [ CustomMetric(i)
-            for i in propDict["attributes"] ])
-        self.name = (
-            None if not fromDict or propDict.get(
-                "name"
-            ) is None
-            else propDict["name"])
+            else [ ProductOffer(i)
+            for i in propDict["offers"] ])
 
     @property
-    def attributes(self):
-        """list: Custom Metric key/value pairs"""
-        return self._attributes
+    def offers(self):
+        """list: product offers"""
+        return self._offers
 
-    @attributes.setter
-    def attributes(self, value):
+    @offers.setter
+    def offers(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._attributes = value
-        else:
-            raise TypeError(
-                'Property "attributes" of type "list<CustomMetric>" set to wr'
-                'ong type'
-            )
-
-    @property
-    def name(self):
-        """ """
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._offers = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "offers" of type "list<ProductOffer>" set to wrong '
+                'type'
             )
 
     def toDict(self):
         result = {}
-        if self._attributes:
-            result["attributes"] = [
-                i.toDict() for i in self._attributes 
-            ] if self._attributes else []
-        if self._name is not None:
-            result["name"] = \
-                self._name
+        if self._offers:
+            result["offers"] = [
+                i.toDict() for i in self._offers 
+            ] if self._offers else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._name is not None
-            and
-            len(self._name) > 255):
+        if self._offers is None:
             raise ValueError(
-                "CustomMetricGroup.name: " + str(self._name) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._attributes is not None):
-            for obj in self._attributes:
+                "CreateProductOfferRequest.offers doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._offers is not None):
+            for obj in self._offers:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/DeploymentCpuParameters.py` & `ngcbpc/data/uis/AddRolesRequest.py`

 * *Files 23% similar despite different names*

```diff
@@ -14,50 +14,55 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentCpuParameters(object):
-    """Deployment CPU Parameters object"""
+class AddRolesRequest(object):
+    """Add roles to a given user request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.count = (
+        self.roles = (
             None if not fromDict or propDict.get(
-                "count"
+                "roles"
             ) is None
-            else propDict["count"])
+            else propDict["roles"])
 
     @property
-    def count(self):
-        """long: Total count of CPUs"""
-        return self._count
-
-    @count.setter
-    def count(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._count = value
+    def roles(self):
+        """list: A list of roles to be added"""
+        return self._roles
+
+    @roles.setter
+    def roles(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._roles = value
         else:
             raise TypeError(
-                'Property "count" of type "list<long>" set to wrong type'
+                'Property "roles" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._count is not None:
-            result["count"] = \
-                self._count
+        if self._roles is not None:
+            result["roles"] = \
+                self._roles
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if self._roles is None:
+            raise ValueError(
+                "AddRolesRequest.roles doesnt match requirement:" 
+                "required: True"
+            )
         return True
```

## Comparing `ngccli/data/model/DeploymentCpuParametersMeta.py` & `ngcbpc/data/model/DeploymentStorageParametersMeta.py`

 * *Files 21% similar despite different names*

```diff
@@ -16,57 +16,57 @@
 str(repr(CountableResource))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentCpuParametersMeta(object):
-    """Cloud Service Provider Deployment CPU Parameters object"""
+class DeploymentStorageParametersMeta(object):
+    """Cloud Service Provider Deployment Storage Parameters object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.count = (
+        self.capacityInGB = (
             None if not fromDict or propDict.get(
-                "count"
+                "capacityInGB"
             ) is None
-            else propDict["count"])
+            else propDict["capacityInGB"])
 
     @property
-    def count(self):
+    def capacityInGB(self):
         """CountableResource: Countable Resource object"""
-        return self._count
+        return self._capacityInGB
 
-    @count.setter
-    def count(self, value):
+    @capacityInGB.setter
+    def capacityInGB(self, value):
         if value is not None and not isinstance(value, CountableResource):
             value = CountableResource(value)
         if (value is None) or isinstance(value, CountableResource):
-            self._count = value
+            self._capacityInGB = value
         else:
             raise TypeError(
-                'Property "count" of type "list<CountableResource>" set to wr'
-                'ong type'
+                'Property "capacityInGB" of type "list<CountableResource>" se'
+                't to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._count:
-            result["count"] = \
-                self._count.toDict() if self._count is not None else None
+        if self._capacityInGB:
+            result["capacityInGB"] = \
+                self._capacityInGB.toDict() if self._capacityInGB is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._count is None:
+        if self._capacityInGB is None:
             raise ValueError(
-                "DeploymentCpuParametersMeta.count doesnt match requirement:" 
+                "DeploymentStorageParametersMeta.capacityInGB doesnt match requirement:" 
                 "required: True"
             )
-        if (self._count is not None): self._count.isValid()
+        if (self._capacityInGB is not None): self._capacityInGB.isValid()
         return True
```

## Comparing `ngccli/data/model/DeploymentParameters.py` & `ngcbpc/data/model/DeploymentParametersCreateRequest.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,51 +6,46 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DeploymentMemoryParameters import DeploymentMemoryParameters
 from .DeploymentArtifactParameters import DeploymentArtifactParameters
 from .DeploymentStorageParameters import DeploymentStorageParameters
-from .DeploymentCpuParameters import DeploymentCpuParameters
 from .DeploymentGpuParameters import DeploymentGpuParameters
+from .DeploymentMemoryParameters import DeploymentMemoryParameters
+from .DeploymentCpuParameters import DeploymentCpuParameters
 
 # Unused import over optimization prevention
-str(repr(DeploymentArtifactParameters))
-str(repr(DeploymentGpuParameters))
 str(repr(DeploymentMemoryParameters))
-str(repr(DeploymentStorageParameters))
+str(repr(DeploymentGpuParameters))
 str(repr(DeploymentCpuParameters))
+str(repr(DeploymentArtifactParameters))
+str(repr(DeploymentStorageParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentParameters(object):
-    """Deployment Artifact Parameters object"""
+class DeploymentParametersCreateRequest(object):
+    """Request to create a new deployment parameters"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.container = (
             None if not fromDict or propDict.get(
                 "container"
             ) is None
             else propDict["container"])
         self.cpu = (
             None if not fromDict or propDict.get(
                 "cpu"
             ) is None
             else propDict["cpu"])
-        self.csp = (
-            None if not fromDict or propDict.get(
-                "csp"
-            ) is None
-            else propDict["csp"])
         self.gpu = (
             None if not fromDict or propDict.get(
                 "gpu"
             ) is None
             else propDict["gpu"])
         self.memory = (
             None if not fromDict or propDict.get(
@@ -105,30 +100,14 @@
         else:
             raise TypeError(
                 'Property "cpu" of type "list<DeploymentCpuParameters>" set t'
                 'o wrong type'
             )
 
     @property
-    def csp(self):
-        """str: Cloud Service Provider name"""
-        return self._csp
-
-    @csp.setter
-    def csp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._csp = value
-        else:
-            raise TypeError(
-                'Property "csp" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def gpu(self):
         """DeploymentGpuParameters: Deployment GPU Parameters object"""
         return self._gpu
 
     @gpu.setter
     def gpu(self, value):
         if value is not None and not isinstance(value, DeploymentGpuParameters):
@@ -216,17 +195,14 @@
         result = {}
         if self._container:
             result["container"] = \
                 self._container.toDict() if self._container is not None else None
         if self._cpu:
             result["cpu"] = \
                 self._cpu.toDict() if self._cpu is not None else None
-        if self._csp is not None:
-            result["csp"] = \
-                self._csp
         if self._gpu:
             result["gpu"] = \
                 self._gpu.toDict() if self._gpu is not None else None
         if self._memory:
             result["memory"] = \
                 self._memory.toDict() if self._memory is not None else None
         if self._model:
```

## Comparing `ngccli/data/model/DeploymentParametersCreateRequest.py` & `ngcbpc/data/model/DeploymentUrlCreateRequest.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,34 +6,34 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DeploymentMemoryParameters import DeploymentMemoryParameters
 from .DeploymentArtifactParameters import DeploymentArtifactParameters
 from .DeploymentStorageParameters import DeploymentStorageParameters
-from .DeploymentCpuParameters import DeploymentCpuParameters
 from .DeploymentGpuParameters import DeploymentGpuParameters
+from .DeploymentMemoryParameters import DeploymentMemoryParameters
+from .DeploymentCpuParameters import DeploymentCpuParameters
 
 # Unused import over optimization prevention
-str(repr(DeploymentArtifactParameters))
-str(repr(DeploymentGpuParameters))
 str(repr(DeploymentMemoryParameters))
-str(repr(DeploymentStorageParameters))
+str(repr(DeploymentGpuParameters))
 str(repr(DeploymentCpuParameters))
+str(repr(DeploymentArtifactParameters))
+str(repr(DeploymentStorageParameters))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentParametersCreateRequest(object):
-    """Request to create a new deployment parameters"""
+class DeploymentUrlCreateRequest(object):
+    """Request to create a new deployment url"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.container = (
             None if not fromDict or propDict.get(
                 "container"
             ) is None
             else propDict["container"])
```

## Comparing `ngccli/data/model/DeploymentParametersMeta.py` & `ngcbpc/data/model/DeploymentParametersMeta.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,23 +7,23 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .DeploymentMemoryParametersMeta import DeploymentMemoryParametersMeta
+from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 from .DeploymentCpuParametersMeta import DeploymentCpuParametersMeta
 from .DeploymentStorageParametersMeta import DeploymentStorageParametersMeta
-from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 
 # Unused import over optimization prevention
+str(repr(DeploymentGpuParametersMeta))
 str(repr(DeploymentStorageParametersMeta))
 str(repr(DeploymentMemoryParametersMeta))
 str(repr(DeploymentCpuParametersMeta))
-str(repr(DeploymentGpuParametersMeta))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DeploymentParametersMeta(object):
```

## Comparing `ngccli/data/model/DeploymentParametersMetaCreateRequest.py` & `ngcbpc/data/model/DeploymentParametersMetaCreateRequest.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,23 +7,23 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .DeploymentMemoryParametersMeta import DeploymentMemoryParametersMeta
+from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 from .DeploymentCpuParametersMeta import DeploymentCpuParametersMeta
 from .DeploymentStorageParametersMeta import DeploymentStorageParametersMeta
-from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 
 # Unused import over optimization prevention
+str(repr(DeploymentGpuParametersMeta))
 str(repr(DeploymentStorageParametersMeta))
 str(repr(DeploymentMemoryParametersMeta))
 str(repr(DeploymentCpuParametersMeta))
-str(repr(DeploymentGpuParametersMeta))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DeploymentParametersMetaCreateRequest(object):
```

## Comparing `ngccli/data/model/DeploymentParametersMetaListResponse.py` & `ngcbpc/data/model/DeploymentParametersMetaListResponse.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .DeploymentParametersMeta import DeploymentParametersMeta
-from .PaginationInfo import PaginationInfo
 from .RequestStatus import RequestStatus
+from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(PaginationInfo))
 str(repr(DeploymentParametersMeta))
+str(repr(PaginationInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DeploymentParametersMetaListResponse(object):
```

## Comparing `ngccli/data/model/DeploymentParametersMetaUpdateRequest.py` & `ngcbpc/data/model/DeploymentParametersMetaUpdateRequest.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,23 +7,23 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .DeploymentMemoryParametersMeta import DeploymentMemoryParametersMeta
+from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 from .DeploymentCpuParametersMeta import DeploymentCpuParametersMeta
 from .DeploymentStorageParametersMeta import DeploymentStorageParametersMeta
-from .DeploymentGpuParametersMeta import DeploymentGpuParametersMeta
 
 # Unused import over optimization prevention
+str(repr(DeploymentGpuParametersMeta))
 str(repr(DeploymentStorageParametersMeta))
 str(repr(DeploymentMemoryParametersMeta))
 str(repr(DeploymentCpuParametersMeta))
-str(repr(DeploymentGpuParametersMeta))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DeploymentParametersMetaUpdateRequest(object):
```

## Comparing `ngccli/data/model/DeploymentStorageParameters.py` & `ngcbpc/data/uis/UserProfileUpdateRequest.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,59 +6,62 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .UserProfile import UserProfile
 
 # Unused import over optimization prevention
+str(repr(UserProfile))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentStorageParameters(object):
-    """Deployment Storage Parameters object"""
+class UserProfileUpdateRequest(object):
+    """Request for Update User Profile"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.capacityInGB = (
+        self.userProfile = (
             None if not fromDict or propDict.get(
-                "capacityInGB"
+                "userProfile"
             ) is None
-            else propDict["capacityInGB"])
+            else propDict["userProfile"])
 
     @property
-    def capacityInGB(self):
-        """long: Capacity in GB"""
-        return self._capacityInGB
-
-    @capacityInGB.setter
-    def capacityInGB(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._capacityInGB = value
+    def userProfile(self):
+        """UserProfile: The profile of user."""
+        return self._userProfile
+
+    @userProfile.setter
+    def userProfile(self, value):
+        if value is not None and not isinstance(value, UserProfile):
+            value = UserProfile(value)
+        if (value is None) or isinstance(value, UserProfile):
+            self._userProfile = value
         else:
             raise TypeError(
-                'Property "capacityInGB" of type "list<long>" set to wrong ty'
-                'pe'
+                'Property "userProfile" of type "list<UserProfile>" set to wr'
+                'ong type'
             )
 
     def toDict(self):
         result = {}
-        if self._capacityInGB is not None:
-            result["capacityInGB"] = \
-                self._capacityInGB
+        if self._userProfile:
+            result["userProfile"] = \
+                self._userProfile.toDict() if self._userProfile is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._userProfile is not None): self._userProfile.isValid()
         return True
```

## Comparing `ngccli/data/model/DeploymentUrlResponse.py` & `ngcbpc/data/model/ModelVersionResponse.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,99 +6,79 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .DeploymentParameters import DeploymentParameters
 from .RequestStatus import RequestStatus
+from .Model import Model
+from .ModelVersion import ModelVersion
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(DeploymentParameters))
+str(repr(Model))
+str(repr(ModelVersion))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class DeploymentUrlResponse(object):
-    """Response to create a new deployment url"""
+class ModelVersionResponse(object):
+    """Response to create a model version request"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.csp = (
+        self.model = (
             None if not fromDict or propDict.get(
-                "csp"
+                "model"
             ) is None
-            else propDict["csp"])
-        self.deploymentParameters = (
+            else propDict["model"])
+        self.modelVersion = (
             None if not fromDict or propDict.get(
-                "deploymentParameters"
+                "modelVersion"
             ) is None
-            else propDict["deploymentParameters"])
-        self.deploymentUrl = (
-            None if not fromDict or propDict.get(
-                "deploymentUrl"
-            ) is None
-            else propDict["deploymentUrl"])
+            else propDict["modelVersion"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
 
     @property
-    def csp(self):
-        """str: Cloud Service Provider name"""
-        return self._csp
-
-    @csp.setter
-    def csp(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._csp = value
-        else:
-            raise TypeError(
-                'Property "csp" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def deploymentParameters(self):
-        """DeploymentParameters: Deployment Artifact Parameters object"""
-        return self._deploymentParameters
-
-    @deploymentParameters.setter
-    def deploymentParameters(self, value):
-        if value is not None and not isinstance(value, DeploymentParameters):
-            value = DeploymentParameters(value)
-        if (value is None) or isinstance(value, DeploymentParameters):
-            self._deploymentParameters = value
+    def model(self):
+        """Model: Model object"""
+        return self._model
+
+    @model.setter
+    def model(self, value):
+        if value is not None and not isinstance(value, Model):
+            value = Model(value)
+        if (value is None) or isinstance(value, Model):
+            self._model = value
         else:
             raise TypeError(
-                'Property "deploymentParameters" of type "list<DeploymentPara'
-                'meters>" set to wrong type'
+                'Property "model" of type "list<Model>" set to wrong type'
             )
 
     @property
-    def deploymentUrl(self):
-        """str: Deployment URL"""
-        return self._deploymentUrl
-
-    @deploymentUrl.setter
-    def deploymentUrl(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._deploymentUrl = value
+    def modelVersion(self):
+        """ModelVersion: Model version object"""
+        return self._modelVersion
+
+    @modelVersion.setter
+    def modelVersion(self, value):
+        if value is not None and not isinstance(value, ModelVersion):
+            value = ModelVersion(value)
+        if (value is None) or isinstance(value, ModelVersion):
+            self._modelVersion = value
         else:
             raise TypeError(
-                'Property "deploymentUrl" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "modelVersion" of type "list<ModelVersion>" set to '
+                'wrong type'
             )
 
     @property
     def requestStatus(self):
         """RequestStatus: Request status information"""
         return self._requestStatus
 
@@ -112,33 +92,31 @@
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._csp is not None:
-            result["csp"] = \
-                self._csp
-        if self._deploymentParameters:
-            result["deploymentParameters"] = \
-                self._deploymentParameters.toDict() if self._deploymentParameters is not None else None
-        if self._deploymentUrl is not None:
-            result["deploymentUrl"] = \
-                self._deploymentUrl
+        if self._model:
+            result["model"] = \
+                self._model.toDict() if self._model is not None else None
+        if self._modelVersion:
+            result["modelVersion"] = \
+                self._modelVersion.toDict() if self._modelVersion is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._deploymentParameters is not None): self._deploymentParameters.isValid()
+        if (self._model is not None): self._model.isValid()
+        if (self._modelVersion is not None): self._modelVersion.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/File.py` & `ngcbpc/data/model/RecipeFile.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,16 +14,16 @@
 # Unused import over optimization prevention
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class File(object):
-    """File object"""
+class RecipeFile(object):
+    """Recipe file object"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.createdDate = (
             None if not fromDict or propDict.get(
                 "createdDate"
             ) is None
             else propDict["createdDate"])
@@ -38,19 +38,14 @@
             ) is None
             else propDict["path"])
         self.sizeInBytes = (
             None if not fromDict or propDict.get(
                 "sizeInBytes"
             ) is None
             else propDict["sizeInBytes"])
-        self.updatedDate = (
-            None if not fromDict or propDict.get(
-                "updatedDate"
-            ) is None
-            else propDict["updatedDate"])
 
     @property
     def createdDate(self):
         """str: Creation date in ISO-8601 format"""
         return self._createdDate
 
     @createdDate.setter
@@ -78,15 +73,15 @@
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
     def path(self):
-        """str: Relative file path from the root of the object"""
+        """str: Relative file path from the root of the recipe"""
         return self._path
 
     @path.setter
     def path(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -109,88 +104,60 @@
             self._sizeInBytes = value
         else:
             raise TypeError(
                 'Property "sizeInBytes" of type "list<long>" set to wrong typ'
                 'e'
             )
 
-    @property
-    def updatedDate(self):
-        """str: Updated date in ISO-8601 format"""
-        return self._updatedDate
-
-    @updatedDate.setter
-    def updatedDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._updatedDate = value
-        else:
-            raise TypeError(
-                'Property "updatedDate" of type "list<str>" set to wrong type'
-            )
-
     def toDict(self):
         result = {}
         if self._createdDate is not None:
             result["createdDate"] = \
                 self._createdDate
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._path is not None:
             result["path"] = \
                 self._path
         if self._sizeInBytes is not None:
             result["sizeInBytes"] = \
                 self._sizeInBytes
-        if self._updatedDate is not None:
-            result["updatedDate"] = \
-                self._updatedDate
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
         if (self._path is not None
             and
             len(self._path) < 1):
             raise ValueError(
-                "File.path: " + str(self._path) + 
+                "RecipeFile.path: " + str(self._path) + 
                 " doesnt match requirement: minLength: 1")
         if (self._path is not None
             and
             len(self._path) > 1023):
             raise ValueError(
-                "File.path: " + str(self._path) + 
+                "RecipeFile.path: " + str(self._path) + 
                 " doesnt match requirement: maxLength: 1023")
         if (self._sizeInBytes is not None
             and
             self._sizeInBytes < 0):
             raise ValueError(
-                "File.sizeInBytes: " + str(self._sizeInBytes) + 
+                "RecipeFile.sizeInBytes: " + str(self._sizeInBytes) + 
                 " doesnt match requirement: minimum: 0")
         if (self._createdDate is not None
             and
             not re.match(
                 r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
                  self._createdDate)):
             raise ValueError(
-                "File.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._updatedDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._updatedDate)):
-            raise ValueError(
-                "File.updatedDate: " + str(self._updatedDate) + 
+                "RecipeFile.createdDate: " + str(self._createdDate) + 
                 " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
                 "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
         return True
```

## Comparing `ngccli/data/model/HelmChartMaintainer.py` & `ngcbpc/data/uis/OrgOwnerUpdateRequest.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,105 +6,92 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .OrgOwner import OrgOwner
 
 # Unused import over optimization prevention
+str(repr(OrgOwner))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class HelmChartMaintainer(object):
+class OrgOwnerUpdateRequest(object):
+    """update org owners for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.email = (
+        self.primaryOrgOwner = (
             None if not fromDict or propDict.get(
-                "email"
+                "primaryOrgOwner"
             ) is None
-            else propDict["email"])
-        self.name = (
+            else propDict["primaryOrgOwner"])
+        self.secondaryOrgOwners = (
             None if not fromDict or propDict.get(
-                "name"
+                "secondaryOrgOwners"
             ) is None
-            else propDict["name"])
-        self.url = (
-            None if not fromDict or propDict.get(
-                "url"
-            ) is None
-            else propDict["url"])
-
-    @property
-    def email(self):
-        """str: The maintainer's email (optional for each maintainer)"""
-        return self._email
-
-    @email.setter
-    def email(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._email = value
-        else:
-            raise TypeError(
-                'Property "email" of type "list<str>" set to wrong type'
-            )
+            else [ OrgOwner(i)
+            for i in propDict["secondaryOrgOwners"] ])
 
     @property
-    def name(self):
-        """str: The maintainer's name (required for each maintainer)"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
+    def primaryOrgOwner(self):
+        """OrgOwner: Org owner"""
+        return self._primaryOrgOwner
+
+    @primaryOrgOwner.setter
+    def primaryOrgOwner(self, value):
+        if value is not None and not isinstance(value, OrgOwner):
+            value = OrgOwner(value)
+        if (value is None) or isinstance(value, OrgOwner):
+            self._primaryOrgOwner = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "primaryOrgOwner" of type "list<OrgOwner>" set to w'
+                'rong type'
             )
 
     @property
-    def url(self):
-        """str: A URL for the maintainer (optional for each maintainer)"""
-        return self._url
-
-    @url.setter
-    def url(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._url = value
+    def secondaryOrgOwners(self):
+        """ """
+        return self._secondaryOrgOwners
+
+    @secondaryOrgOwners.setter
+    def secondaryOrgOwners(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._secondaryOrgOwners = value
         else:
             raise TypeError(
-                'Property "url" of type "list<str>" set to wrong type'
+                'Property "secondaryOrgOwners" of type "list<OrgOwner>" set t'
+                'o wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._email is not None:
-            result["email"] = \
-                self._email
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._url is not None:
-            result["url"] = \
-                self._url
+        if self._primaryOrgOwner:
+            result["primaryOrgOwner"] = \
+                self._primaryOrgOwner.toDict() if self._primaryOrgOwner is not None else None
+        if self._secondaryOrgOwners:
+            result["secondaryOrgOwners"] = [
+                i.toDict() for i in self._secondaryOrgOwners 
+            ] if self._secondaryOrgOwners else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
+        if (self._primaryOrgOwner is not None): self._primaryOrgOwner.isValid()
+        if (self._secondaryOrgOwners is not None):
+            for obj in self._secondaryOrgOwners:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/HelmChartVersion.py` & `organization/data/subscription_management_service/BusinessContact.py`

 * *Files 22% similar despite different names*

```diff
@@ -6,388 +6,420 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .HelmChartDependency import HelmChartDependency
-from .HelmChartMaintainer import HelmChartMaintainer
 
 # Unused import over optimization prevention
-str(repr(HelmChartMaintainer))
-str(repr(HelmChartDependency))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class HelmChartVersion(object):
-    """Helm chart version object"""
+class BusinessContact(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.apiVersion = (
+        self.addressLine1 = (
             None if not fromDict or propDict.get(
-                "apiVersion"
+                "addressLine1"
             ) is None
-            else propDict["apiVersion"])
-        self.appVersion = (
+            else propDict["addressLine1"])
+        self.addressLine2 = (
             None if not fromDict or propDict.get(
-                "appVersion"
+                "addressLine2"
             ) is None
-            else propDict["appVersion"])
-        self.dependencies = (
+            else propDict["addressLine2"])
+        self.city = (
             None if not fromDict or propDict.get(
-                "dependencies"
+                "city"
             ) is None
-            else [ HelmChartDependency(i)
-            for i in propDict["dependencies"] ])
-        self.deprecated = (
+            else propDict["city"])
+        self.companyName = (
             None if not fromDict or propDict.get(
-                "deprecated"
+                "companyName"
             ) is None
-            else propDict["deprecated"])
-        self.description = (
+            else propDict["companyName"])
+        self.countryISO = (
             None if not fromDict or propDict.get(
-                "description"
+                "countryISO"
             ) is None
-            else propDict["description"])
-        self.home = (
+            else propDict["countryISO"])
+        self.countryName = (
             None if not fromDict or propDict.get(
-                "home"
+                "countryName"
             ) is None
-            else propDict["home"])
-        self.icon = (
+            else propDict["countryName"])
+        self.email = (
             None if not fromDict or propDict.get(
-                "icon"
+                "email"
             ) is None
-            else propDict["icon"])
-        self.keywords = (
+            else propDict["email"])
+        self.firstName = (
             None if not fromDict or propDict.get(
-                "keywords"
+                "firstName"
             ) is None
-            else propDict["keywords"])
-        self.kubeVersion = (
+            else propDict["firstName"])
+        self.industry = (
             None if not fromDict or propDict.get(
-                "kubeVersion"
+                "industry"
             ) is None
-            else propDict["kubeVersion"])
-        self.maintainers = (
+            else propDict["industry"])
+        self.isSystemIntegrator = (
             None if not fromDict or propDict.get(
-                "maintainers"
+                "isSystemIntegrator"
             ) is None
-            else [ HelmChartMaintainer(i)
-            for i in propDict["maintainers"] ])
-        self.name = (
+            else propDict["isSystemIntegrator"])
+        self.lastName = (
             None if not fromDict or propDict.get(
-                "name"
+                "lastName"
             ) is None
-            else propDict["name"])
-        self.sources = (
+            else propDict["lastName"])
+        self.phoneNumber = (
             None if not fromDict or propDict.get(
-                "sources"
+                "phoneNumber"
             ) is None
-            else propDict["sources"])
-        self.type = (
+            else propDict["phoneNumber"])
+        self.role = (
             None if not fromDict or propDict.get(
-                "type"
+                "role"
             ) is None
-            else propDict["type"])
-        self.version = (
+            else propDict["role"])
+        self.state = (
             None if not fromDict or propDict.get(
-                "version"
+                "state"
             ) is None
-            else propDict["version"])
+            else propDict["state"])
+        self.zipCode = (
+            None if not fromDict or propDict.get(
+                "zipCode"
+            ) is None
+            else propDict["zipCode"])
 
     @property
-    def apiVersion(self):
-        """str: The chart API version (required)"""
-        return self._apiVersion
+    def addressLine1(self):
+        """ """
+        return self._addressLine1
 
-    @apiVersion.setter
-    def apiVersion(self, value):
+    @addressLine1.setter
+    def addressLine1(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._apiVersion = value
+            self._addressLine1 = value
         else:
             raise TypeError(
-                'Property "apiVersion" of type "list<str>" set to wrong type'
+                'Property "addressLine1" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def appVersion(self):
-        """str: The version of the app that this contains (optional). This nee
-        dn't be SemVer."""
-        return self._appVersion
+    def addressLine2(self):
+        """ """
+        return self._addressLine2
 
-    @appVersion.setter
-    def appVersion(self, value):
+    @addressLine2.setter
+    def addressLine2(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._appVersion = value
+            self._addressLine2 = value
         else:
             raise TypeError(
-                'Property "appVersion" of type "list<str>" set to wrong type'
+                'Property "addressLine2" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def dependencies(self):
-        """list: A list of the chart requirements (optional)"""
-        return self._dependencies
+    def city(self):
+        """ """
+        return self._city
 
-    @dependencies.setter
-    def dependencies(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._dependencies = value
+    @city.setter
+    def city(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._city = value
         else:
             raise TypeError(
-                'Property "dependencies" of type "list<HelmChartDependency>" '
-                'set to wrong type'
+                'Property "city" of type "list<str>" set to wrong type'
             )
 
     @property
-    def deprecated(self):
-        """bool: Whether this chart is deprecated (optional, boolean)"""
-        return self._deprecated
+    def companyName(self):
+        """ """
+        return self._companyName
 
-    @deprecated.setter
-    def deprecated(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._deprecated = value
+    @companyName.setter
+    def companyName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._companyName = value
         else:
             raise TypeError(
-                'Property "deprecated" of type "list<bool>" set to wrong type'
+                'Property "companyName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def description(self):
-        """str: A single-sentence description of this project (optional)"""
-        return self._description
+    def countryISO(self):
+        """ """
+        return self._countryISO
 
-    @description.setter
-    def description(self, value):
+    @countryISO.setter
+    def countryISO(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._countryISO = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "countryISO" of type "list<str>" set to wrong type'
             )
 
     @property
-    def home(self):
-        """str: The URL of this project's home page (optional)"""
-        return self._home
+    def countryName(self):
+        """ """
+        return self._countryName
 
-    @home.setter
-    def home(self, value):
+    @countryName.setter
+    def countryName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._home = value
+            self._countryName = value
         else:
             raise TypeError(
-                'Property "home" of type "list<str>" set to wrong type'
+                'Property "countryName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def icon(self):
-        """str: A URL to an SVG or PNG image to be used as an icon (optional).
-        """
-        return self._icon
+    def email(self):
+        """ """
+        return self._email
 
-    @icon.setter
-    def icon(self, value):
+    @email.setter
+    def email(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._icon = value
+            self._email = value
         else:
             raise TypeError(
-                'Property "icon" of type "list<str>" set to wrong type'
+                'Property "email" of type "list<str>" set to wrong type'
             )
 
     @property
-    def keywords(self):
-        """list: A list of keywords about this project (optional)"""
-        return self._keywords
+    def firstName(self):
+        """ """
+        return self._firstName
 
-    @keywords.setter
-    def keywords(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._keywords = value
+    @firstName.setter
+    def firstName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._firstName = value
         else:
             raise TypeError(
-                'Property "keywords" of type "list<str>" set to wrong type'
+                'Property "firstName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def kubeVersion(self):
-        """str: A SemVer range of compatible Kubernetes versions (optional)"""
-        return self._kubeVersion
+    def industry(self):
+        """ """
+        return self._industry
 
-    @kubeVersion.setter
-    def kubeVersion(self, value):
+    @industry.setter
+    def industry(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._kubeVersion = value
+            self._industry = value
         else:
             raise TypeError(
-                'Property "kubeVersion" of type "list<str>" set to wrong type'
+                'Property "industry" of type "list<str>" set to wrong type'
             )
 
     @property
-    def maintainers(self):
+    def isSystemIntegrator(self):
         """ """
-        return self._maintainers
+        return self._isSystemIntegrator
 
-    @maintainers.setter
-    def maintainers(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._maintainers = value
+    @isSystemIntegrator.setter
+    def isSystemIntegrator(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isSystemIntegrator = value
         else:
             raise TypeError(
-                'Property "maintainers" of type "list<HelmChartMaintainer>" s'
-                'et to wrong type'
+                'Property "isSystemIntegrator" of type "list<bool>" set to wr'
+                'ong type'
             )
 
     @property
-    def name(self):
-        """str: The name of the chart (required)"""
-        return self._name
+    def lastName(self):
+        """ """
+        return self._lastName
 
-    @name.setter
-    def name(self, value):
+    @lastName.setter
+    def lastName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._lastName = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "lastName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sources(self):
-        """list: A list of URLs to source code for this project (optional)"""
-        return self._sources
+    def phoneNumber(self):
+        """ """
+        return self._phoneNumber
 
-    @sources.setter
-    def sources(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._sources = value
+    @phoneNumber.setter
+    def phoneNumber(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._phoneNumber = value
         else:
             raise TypeError(
-                'Property "sources" of type "list<str>" set to wrong type'
+                'Property "phoneNumber" of type "list<str>" set to wrong type'
             )
 
     @property
-    def type(self):
-        """str: It is the type of chart (optional)"""
-        return self._type
+    def role(self):
+        """ """
+        return self._role
 
-    @type.setter
-    def type(self, value):
+    @role.setter
+    def role(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._type = value
+            self._role = value
         else:
             raise TypeError(
-                'Property "type" of type "list<str>" set to wrong type'
+                'Property "role" of type "list<str>" set to wrong type'
             )
 
     @property
-    def version(self):
-        """str: A SemVer 2 version (required)"""
-        return self._version
+    def state(self):
+        """ """
+        return self._state
+
+    @state.setter
+    def state(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._state = value
+        else:
+            raise TypeError(
+                'Property "state" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def zipCode(self):
+        """ """
+        return self._zipCode
 
-    @version.setter
-    def version(self, value):
+    @zipCode.setter
+    def zipCode(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._zipCode = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "zipCode" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._apiVersion is not None:
-            result["apiVersion"] = \
-                self._apiVersion
-        if self._appVersion is not None:
-            result["appVersion"] = \
-                self._appVersion
-        if self._dependencies:
-            result["dependencies"] = [
-                i.toDict() for i in self._dependencies 
-            ] if self._dependencies else []
-        if self._deprecated is not None:
-            result["deprecated"] = \
-                self._deprecated
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._home is not None:
-            result["home"] = \
-                self._home
-        if self._icon is not None:
-            result["icon"] = \
-                self._icon
-        if self._keywords is not None:
-            result["keywords"] = \
-                self._keywords
-        if self._kubeVersion is not None:
-            result["kubeVersion"] = \
-                self._kubeVersion
-        if self._maintainers:
-            result["maintainers"] = [
-                i.toDict() for i in self._maintainers 
-            ] if self._maintainers else []
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._sources is not None:
-            result["sources"] = \
-                self._sources
-        if self._type is not None:
-            result["type"] = \
-                self._type
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._addressLine1 is not None:
+            result["addressLine1"] = \
+                self._addressLine1
+        if self._addressLine2 is not None:
+            result["addressLine2"] = \
+                self._addressLine2
+        if self._city is not None:
+            result["city"] = \
+                self._city
+        if self._companyName is not None:
+            result["companyName"] = \
+                self._companyName
+        if self._countryISO is not None:
+            result["countryISO"] = \
+                self._countryISO
+        if self._countryName is not None:
+            result["countryName"] = \
+                self._countryName
+        if self._email is not None:
+            result["email"] = \
+                self._email
+        if self._firstName is not None:
+            result["firstName"] = \
+                self._firstName
+        if self._industry is not None:
+            result["industry"] = \
+                self._industry
+        if self._isSystemIntegrator is not None:
+            result["isSystemIntegrator"] = \
+                self._isSystemIntegrator
+        if self._lastName is not None:
+            result["lastName"] = \
+                self._lastName
+        if self._phoneNumber is not None:
+            result["phoneNumber"] = \
+                self._phoneNumber
+        if self._role is not None:
+            result["role"] = \
+                self._role
+        if self._state is not None:
+            result["state"] = \
+                self._state
+        if self._zipCode is not None:
+            result["zipCode"] = \
+                self._zipCode
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._dependencies is not None):
-            for obj in self._dependencies:
-                if (obj is not None): obj.isValid()
-        if (self._maintainers is not None):
-            for obj in self._maintainers:
-                if (obj is not None): obj.isValid()
+        if (self._companyName is not None
+            and
+            not re.match(
+                r"^[^\\\"\\\[]*$",
+                 self._companyName)):
+            raise ValueError(
+                "BusinessContact.companyName: " + str(self._companyName) + 
+                " doesnt match requirement: pattern: ^[^\\\"\\\[]*$")
+        if (self._firstName is not None
+            and
+            not re.match(
+                r"(^[a-zA-Z'\-]*$)",
+                 self._firstName)):
+            raise ValueError(
+                "BusinessContact.firstName: " + str(self._firstName) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z'\-]*$)")
+        if (self._lastName is not None
+            and
+            not re.match(
+                r"(^[a-zA-Z'\-]*$)",
+                 self._lastName)):
+            raise ValueError(
+                "BusinessContact.lastName: " + str(self._lastName) + 
+                " doesnt match requirement: pattern: (^[a-zA-Z'\-]*$)")
         return True
```

## Comparing `ngccli/data/model/ModelResponse.py` & `organization/data/subscription_management_service/SubscriptionResponse.py`

 * *Files 24% similar despite different names*

```diff
@@ -6,89 +6,90 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Subscription import Subscription
 from .RequestStatus import RequestStatus
-from .Model import Model
 
 # Unused import over optimization prevention
 str(repr(RequestStatus))
-str(repr(Model))
+str(repr(Subscription))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ModelResponse(object):
-    """Response to create model request"""
+class SubscriptionResponse(object):
+    """Response for get subscription API"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.model = (
-            None if not fromDict or propDict.get(
-                "model"
-            ) is None
-            else propDict["model"])
         self.requestStatus = (
             None if not fromDict or propDict.get(
                 "requestStatus"
             ) is None
             else propDict["requestStatus"])
-
-    @property
-    def model(self):
-        """Model: Model object"""
-        return self._model
-
-    @model.setter
-    def model(self, value):
-        if value is not None and not isinstance(value, Model):
-            value = Model(value)
-        if (value is None) or isinstance(value, Model):
-            self._model = value
-        else:
-            raise TypeError(
-                'Property "model" of type "list<Model>" set to wrong type'
-            )
+        self.subscription = (
+            None if not fromDict or propDict.get(
+                "subscription"
+            ) is None
+            else propDict["subscription"])
 
     @property
     def requestStatus(self):
-        """RequestStatus: Request status information"""
+        """ """
         return self._requestStatus
 
     @requestStatus.setter
     def requestStatus(self, value):
         if value is not None and not isinstance(value, RequestStatus):
             value = RequestStatus(value)
         if (value is None) or isinstance(value, RequestStatus):
             self._requestStatus = value
         else:
             raise TypeError(
                 'Property "requestStatus" of type "list<RequestStatus>" set t'
                 'o wrong type'
             )
 
+    @property
+    def subscription(self):
+        """ """
+        return self._subscription
+
+    @subscription.setter
+    def subscription(self, value):
+        if value is not None and not isinstance(value, Subscription):
+            value = Subscription(value)
+        if (value is None) or isinstance(value, Subscription):
+            self._subscription = value
+        else:
+            raise TypeError(
+                'Property "subscription" of type "list<Subscription>" set to '
+                'wrong type'
+            )
+
     def toDict(self):
         result = {}
-        if self._model:
-            result["model"] = \
-                self._model.toDict() if self._model is not None else None
         if self._requestStatus:
             result["requestStatus"] = \
                 self._requestStatus.toDict() if self._requestStatus is not None else None
+        if self._subscription:
+            result["subscription"] = \
+                self._subscription.toDict() if self._subscription is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._model is not None): self._model.isValid()
+        if (self._subscription is not None): self._subscription.isValid()
         if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngccli/data/model/ModelSimplified.py` & `basecommand/data/pym/ClusterComponent.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,116 +6,108 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .ClusterInstance import ClusterInstance
 
 # Unused import over optimization prevention
+str(repr(ClusterInstance))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ModelSimplified(object):
-    """Model object"""
+class ClusterComponent(object):
+    """Cluster Component"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.name = (
+        self.componentName = (
             None if not fromDict or propDict.get(
-                "name"
+                "componentName"
             ) is None
-            else propDict["name"])
-        self.orgName = (
+            else propDict["componentName"])
+        self.instanceTypes = (
             None if not fromDict or propDict.get(
-                "orgName"
+                "instanceTypes"
             ) is None
-            else propDict["orgName"])
-        self.teamName = (
-            None if not fromDict or propDict.get(
-                "teamName"
-            ) is None
-            else propDict["teamName"])
-
-    @property
-    def name(self):
-        """str: Unique name of the model"""
-        return self._name
-
-    @name.setter
-    def name(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._name = value
-        else:
-            raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
-            )
+            else [ ClusterInstance(i)
+            for i in propDict["instanceTypes"] ])
 
     @property
-    def orgName(self):
-        """str: Name of the org that the model belongs to"""
-        return self._orgName
+    def componentName(self):
+        """str: The cluster component for which these instance types are appli
+        cable"""
+        return self._componentName
 
-    @orgName.setter
-    def orgName(self, value):
+    @componentName.setter
+    def componentName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._orgName = value
+            self._componentName = value
         else:
             raise TypeError(
-                'Property "orgName" of type "list<str>" set to wrong type'
+                'Property "componentName" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def teamName(self):
-        """str: Name of the team that the model belongs to"""
-        return self._teamName
-
-    @teamName.setter
-    def teamName(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._teamName = value
+    def instanceTypes(self):
+        """ """
+        return self._instanceTypes
+
+    @instanceTypes.setter
+    def instanceTypes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._instanceTypes = value
         else:
             raise TypeError(
-                'Property "teamName" of type "list<str>" set to wrong type'
+                'Property "instanceTypes" of type "list<ClusterInstance>" set'
+                ' to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._orgName is not None:
-            result["orgName"] = \
-                self._orgName
-        if self._teamName is not None:
-            result["teamName"] = \
-                self._teamName
+        if self._componentName is not None:
+            result["componentName"] = \
+                self._componentName
+        if self._instanceTypes:
+            result["instanceTypes"] = [
+                i.toDict() for i in self._instanceTypes 
+            ] if self._instanceTypes else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
+        if self._componentName is None:
             raise ValueError(
-                "ModelSimplified.name doesnt match requirement:" 
+                "ClusterComponent.componentName doesnt match requirement:" 
                 "required: True"
             )
-        if self._orgName is None:
+        if (self._componentName is not None
+            and
+            len(self._componentName) < 1):
+            raise ValueError(
+                "ClusterComponent.componentName: " + str(self._componentName) + 
+                " doesnt match requirement: minLength: 1")
+        if self._instanceTypes is None:
             raise ValueError(
-                "ModelSimplified.orgName doesnt match requirement:" 
+                "ClusterComponent.instanceTypes doesnt match requirement:" 
                 "required: True"
             )
+        if (self._instanceTypes is not None):
+            for obj in self._instanceTypes:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ModelUpdateRequest.py` & `ngcbpc/data/model/RecipeVersionCreateRequest.py`

 * *Files 19% similar despite different names*

```diff
@@ -6,589 +6,446 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Dataset import Dataset
+from .CustomMetricGroup import CustomMetricGroup
+from .ArtifactAttribute import ArtifactAttribute
 
 # Unused import over optimization prevention
-str(repr(Dataset))
+str(repr(CustomMetricGroup))
+str(repr(ArtifactAttribute))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ModelUpdateRequest(object):
-    """Request to create a new model"""
+class RecipeVersionCreateRequest(object):
+    """Request to create a new recipe version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.application = (
+        self.accuracyReached = (
             None if not fromDict or propDict.get(
-                "application"
+                "accuracyReached"
             ) is None
-            else propDict["application"])
-        self.bias = (
+            else propDict["accuracyReached"])
+        self.batchSize = (
             None if not fromDict or propDict.get(
-                "bias"
+                "batchSize"
             ) is None
-            else propDict["bias"])
-        self.builtBy = (
+            else propDict["batchSize"])
+        self.customMetrics = (
             None if not fromDict or propDict.get(
-                "builtBy"
+                "customMetrics"
             ) is None
-            else propDict["builtBy"])
+            else [ CustomMetricGroup(i)
+            for i in propDict["customMetrics"] ])
         self.description = (
             None if not fromDict or propDict.get(
                 "description"
             ) is None
             else propDict["description"])
-        self.displayName = (
+        self.gpuModel = (
             None if not fromDict or propDict.get(
-                "displayName"
+                "gpuModel"
             ) is None
-            else propDict["displayName"])
-        self.explainability = (
+            else propDict["gpuModel"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "explainability"
+                "id"
             ) is None
-            else propDict["explainability"])
-        self.framework = (
+            else propDict["id"])
+        self.memoryFootprint = (
             None if not fromDict or propDict.get(
-                "framework"
+                "memoryFootprint"
             ) is None
-            else propDict["framework"])
-        self.hasPlayground = (
+            else propDict["memoryFootprint"])
+        self.numberOfEpochs = (
             None if not fromDict or propDict.get(
-                "hasPlayground"
+                "numberOfEpochs"
             ) is None
-            else propDict["hasPlayground"])
-        self.isPlaygroundEnabled = (
+            else propDict["numberOfEpochs"])
+        self.otherContents = (
             None if not fromDict or propDict.get(
-                "isPlaygroundEnabled"
+                "otherContents"
             ) is None
-            else propDict["isPlaygroundEnabled"])
-        self.labels = (
+            else [ ArtifactAttribute(i)
+            for i in propDict["otherContents"] ])
+        self.performance = (
             None if not fromDict or propDict.get(
-                "labels"
+                "performance"
             ) is None
-            else propDict["labels"])
-        self.labelsV2 = (
+            else propDict["performance"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "labelsV2"
+                "quickStartGuide"
             ) is None
-            else propDict["labelsV2"])
-        self.logo = (
+            else propDict["quickStartGuide"])
+        self.releaseNotes = (
             None if not fromDict or propDict.get(
-                "logo"
+                "releaseNotes"
             ) is None
-            else propDict["logo"])
-        self.modelFormat = (
+            else propDict["releaseNotes"])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "modelFormat"
+                "setup"
             ) is None
-            else propDict["modelFormat"])
-        self.ownerName = (
+            else propDict["setup"])
+        self.versionId = (
             None if not fromDict or propDict.get(
-                "ownerName"
+                "versionId"
             ) is None
-            else propDict["ownerName"])
-        self.precision = (
-            None if not fromDict or propDict.get(
-                "precision"
-            ) is None
-            else propDict["precision"])
-        self.privacy = (
-            None if not fromDict or propDict.get(
-                "privacy"
-            ) is None
-            else propDict["privacy"])
-        self.publicDatasetUsed = (
-            None if not fromDict or propDict.get(
-                "publicDatasetUsed"
-            ) is None
-            else propDict["publicDatasetUsed"])
-        self.publisher = (
-            None if not fromDict or propDict.get(
-                "publisher"
-            ) is None
-            else propDict["publisher"])
-        self.safetyAndSecurity = (
-            None if not fromDict or propDict.get(
-                "safetyAndSecurity"
-            ) is None
-            else propDict["safetyAndSecurity"])
-        self.shortDescription = (
-            None if not fromDict or propDict.get(
-                "shortDescription"
-            ) is None
-            else propDict["shortDescription"])
+            else propDict["versionId"])
 
     @property
-    def application(self):
-        """str: Application of the model"""
-        return self._application
+    def accuracyReached(self):
+        """float: Accuracy this recipe reached"""
+        return self._accuracyReached
 
-    @application.setter
-    def application(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._application = value
+    @accuracyReached.setter
+    def accuracyReached(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._accuracyReached = value
         else:
             raise TypeError(
-                'Property "application" of type "list<str>" set to wrong type'
+                'Property "accuracyReached" of type "list<float>" set to wron'
+                'g type'
             )
 
     @property
-    def bias(self):
-        """str: Text describing bias in the model"""
-        return self._bias
+    def batchSize(self):
+        """long: Batch size this recipe was trained with"""
+        return self._batchSize
 
-    @bias.setter
-    def bias(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._bias = value
+    @batchSize.setter
+    def batchSize(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._batchSize = value
         else:
             raise TypeError(
-                'Property "bias" of type "list<str>" set to wrong type'
+                'Property "batchSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def builtBy(self):
-        """str: organization that built the repository"""
-        return self._builtBy
+    def customMetrics(self):
+        """list: Custom Metrics key/value pairs"""
+        return self._customMetrics
 
-    @builtBy.setter
-    def builtBy(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._builtBy = value
+    @customMetrics.setter
+    def customMetrics(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._customMetrics = value
         else:
             raise TypeError(
-                'Property "builtBy" of type "list<str>" set to wrong type'
+                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
+                'et to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the model"""
+        """str: Description of the recipe version"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
             self._description = value
         else:
             raise TypeError(
                 'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def displayName(self):
-        """str: Display name"""
-        return self._displayName
+    def gpuModel(self):
+        """str: GPU model and memory"""
+        return self._gpuModel
 
-    @displayName.setter
-    def displayName(self, value):
+    @gpuModel.setter
+    def gpuModel(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._displayName = value
+            self._gpuModel = value
         else:
             raise TypeError(
-                'Property "displayName" of type "list<str>" set to wrong type'
+                'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def explainability(self):
-        """str: Text describing explainability for this model"""
-        return self._explainability
+    def id(self):
+        """long: Deprecated: Please use version instead. Unique ID of the vers
+        ion"""
+        return self._id
 
-    @explainability.setter
-    def explainability(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._explainability = value
+    @id.setter
+    def id(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._id = value
         else:
             raise TypeError(
-                'Property "explainability" of type "list<str>" set to wrong t'
-                'ype'
+                'Property "id" of type "list<long>" set to wrong type'
             )
 
     @property
-    def framework(self):
-        """str: Framework used to train this model"""
-        return self._framework
+    def memoryFootprint(self):
+        """str: Recipe size/memory footprint for inference"""
+        return self._memoryFootprint
 
-    @framework.setter
-    def framework(self, value):
+    @memoryFootprint.setter
+    def memoryFootprint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._framework = value
-        else:
-            raise TypeError(
-                'Property "framework" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def hasPlayground(self):
-        """bool: indicate if the Model has AI Playground configured"""
-        return self._hasPlayground
-
-    @hasPlayground.setter
-    def hasPlayground(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._hasPlayground = value
+            self._memoryFootprint = value
         else:
             raise TypeError(
-                'Property "hasPlayground" of type "list<bool>" set to wrong t'
-                'ype'
+                'Property "memoryFootprint" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def isPlaygroundEnabled(self):
-        """bool: indicate if AI Playground is enabled in the catalog"""
-        return self._isPlaygroundEnabled
+    def numberOfEpochs(self):
+        """long: Number of epochs this recipe trained"""
+        return self._numberOfEpochs
 
-    @isPlaygroundEnabled.setter
-    def isPlaygroundEnabled(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._isPlaygroundEnabled = value
+    @numberOfEpochs.setter
+    def numberOfEpochs(self, value):
+        if value is not None and not isinstance(value, long):
+            value = long(value)
+        if (value is None) or isinstance(value, long):
+            self._numberOfEpochs = value
         else:
             raise TypeError(
-                'Property "isPlaygroundEnabled" of type "list<bool>" set to w'
-                'rong type'
+                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'type'
             )
 
     @property
-    def labels(self):
-        """ """
-        return self._labels
+    def otherContents(self):
+        """list: List of external contents"""
+        return self._otherContents
 
-    @labels.setter
-    def labels(self, value):
+    @otherContents.setter
+    def otherContents(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._labels = value
+            self._otherContents = value
         else:
             raise TypeError(
-                'Property "labels" of type "list<str>" set to wrong type'
+                'Property "otherContents" of type "list<ArtifactAttribute>" s'
+                'et to wrong type'
             )
 
     @property
-    def labelsV2(self):
-        """ """
-        return self._labelsV2
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @labelsV2.setter
-    def labelsV2(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._labelsV2 = value
-        else:
-            raise TypeError(
-                'Property "labelsV2" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def logo(self):
-        """str: URL for the logo image"""
-        return self._logo
-
-    @logo.setter
-    def logo(self, value):
+    @performance.setter
+    def performance(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._logo = value
+            self._performance = value
         else:
             raise TypeError(
-                'Property "logo" of type "list<str>" set to wrong type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def modelFormat(self):
-        """str: Format of the model"""
-        return self._modelFormat
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @modelFormat.setter
-    def modelFormat(self, value):
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._modelFormat = value
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "modelFormat" of type "list<str>" set to wrong type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def ownerName(self):
-        """str: Name of the user who owns this model"""
-        return self._ownerName
+    def releaseNotes(self):
+        """str: Text describing this release"""
+        return self._releaseNotes
 
-    @ownerName.setter
-    def ownerName(self, value):
+    @releaseNotes.setter
+    def releaseNotes(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._ownerName = value
+            self._releaseNotes = value
         else:
             raise TypeError(
-                'Property "ownerName" of type "list<str>" set to wrong type'
+                'Property "releaseNotes" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def precision(self):
-        """str: Precision this model was trained with"""
-        return self._precision
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
 
-    @precision.setter
-    def precision(self, value):
+    @setup.setter
+    def setup(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._precision = value
+            self._setup = value
         else:
             raise TypeError(
-                'Property "precision" of type "list<str>" set to wrong type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
-    def privacy(self):
-        """str: Text describing the privacy for this model"""
-        return self._privacy
+    def versionId(self):
+        """str: Unique version id. Please use this instead of 'id'"""
+        return self._versionId
 
-    @privacy.setter
-    def privacy(self, value):
+    @versionId.setter
+    def versionId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._privacy = value
+            self._versionId = value
         else:
             raise TypeError(
-                'Property "privacy" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def publicDatasetUsed(self):
-        """ """
-        return self._publicDatasetUsed
-
-    @publicDatasetUsed.setter
-    def publicDatasetUsed(self, value):
-        if value is not None and not isinstance(value, Dataset):
-            value = Dataset(value)
-        if (value is None) or isinstance(value, Dataset):
-            self._publicDatasetUsed = value
-        else:
-            raise TypeError(
-                'Property "publicDatasetUsed" of type "list<Dataset>" set to '
-                'wrong type'
-            )
-
-    @property
-    def publisher(self):
-        """str: organization that published the repository"""
-        return self._publisher
-
-    @publisher.setter
-    def publisher(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._publisher = value
-        else:
-            raise TypeError(
-                'Property "publisher" of type "list<str>" set to wrong type'
-            )
-
-    @property
-    def safetyAndSecurity(self):
-        """str: Text for describing the safety and security in the model"""
-        return self._safetyAndSecurity
-
-    @safetyAndSecurity.setter
-    def safetyAndSecurity(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._safetyAndSecurity = value
-        else:
-            raise TypeError(
-                'Property "safetyAndSecurity" of type "list<str>" set to wron'
-                'g type'
-            )
-
-    @property
-    def shortDescription(self):
-        """str: Short description of the model"""
-        return self._shortDescription
-
-    @shortDescription.setter
-    def shortDescription(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._shortDescription = value
-        else:
-            raise TypeError(
-                'Property "shortDescription" of type "list<str>" set to wrong'
-                ' type'
+                'Property "versionId" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._application is not None:
-            result["application"] = \
-                self._application
-        if self._bias is not None:
-            result["bias"] = \
-                self._bias
-        if self._builtBy is not None:
-            result["builtBy"] = \
-                self._builtBy
+        if self._accuracyReached is not None:
+            result["accuracyReached"] = \
+                self._accuracyReached
+        if self._batchSize is not None:
+            result["batchSize"] = \
+                self._batchSize
+        if self._customMetrics:
+            result["customMetrics"] = [
+                i.toDict() for i in self._customMetrics 
+            ] if self._customMetrics else []
         if self._description is not None:
             result["description"] = \
                 self._description
-        if self._displayName is not None:
-            result["displayName"] = \
-                self._displayName
-        if self._explainability is not None:
-            result["explainability"] = \
-                self._explainability
-        if self._framework is not None:
-            result["framework"] = \
-                self._framework
-        if self._hasPlayground is not None:
-            result["hasPlayground"] = \
-                self._hasPlayground
-        if self._isPlaygroundEnabled is not None:
-            result["isPlaygroundEnabled"] = \
-                self._isPlaygroundEnabled
-        if self._labels is not None:
-            result["labels"] = \
-                self._labels
-        if self._labelsV2 is not None:
-            result["labelsV2"] = \
-                self._labelsV2
-        if self._logo is not None:
-            result["logo"] = \
-                self._logo
-        if self._modelFormat is not None:
-            result["modelFormat"] = \
-                self._modelFormat
-        if self._ownerName is not None:
-            result["ownerName"] = \
-                self._ownerName
-        if self._precision is not None:
-            result["precision"] = \
-                self._precision
-        if self._privacy is not None:
-            result["privacy"] = \
-                self._privacy
-        if self._publicDatasetUsed:
-            result["publicDatasetUsed"] = \
-                self._publicDatasetUsed.toDict() if self._publicDatasetUsed is not None else None
-        if self._publisher is not None:
-            result["publisher"] = \
-                self._publisher
-        if self._safetyAndSecurity is not None:
-            result["safetyAndSecurity"] = \
-                self._safetyAndSecurity
-        if self._shortDescription is not None:
-            result["shortDescription"] = \
-                self._shortDescription
+        if self._gpuModel is not None:
+            result["gpuModel"] = \
+                self._gpuModel
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._memoryFootprint is not None:
+            result["memoryFootprint"] = \
+                self._memoryFootprint
+        if self._numberOfEpochs is not None:
+            result["numberOfEpochs"] = \
+                self._numberOfEpochs
+        if self._otherContents:
+            result["otherContents"] = [
+                i.toDict() for i in self._otherContents 
+            ] if self._otherContents else []
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._releaseNotes is not None:
+            result["releaseNotes"] = \
+                self._releaseNotes
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
+        if self._versionId is not None:
+            result["versionId"] = \
+                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._ownerName is not None
+        if (self._id is not None
             and
-            len(self._ownerName) > 255):
+            self._id < 1):
             raise ValueError(
-                "ModelUpdateRequest.ownerName: " + str(self._ownerName) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._framework is not None
+                "RecipeVersionCreateRequest.id: " + str(self._id) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._id is not None
             and
-            len(self._framework) > 255):
+            self._id > 2147483647):
             raise ValueError(
-                "ModelUpdateRequest.framework: " + str(self._framework) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._modelFormat is not None
-            and
-            len(self._modelFormat) > 255):
-            raise ValueError(
-                "ModelUpdateRequest.modelFormat: " + str(self._modelFormat) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._shortDescription is not None
+                "RecipeVersionCreateRequest.id: " + str(self._id) + 
+                " doesnt match requirement: maximum: 2147483647")
+        if (self._versionId is not None
             and
-            len(self._shortDescription) > 255):
+            len(self._versionId) > 255):
             raise ValueError(
-                "ModelUpdateRequest.shortDescription: " + str(self._shortDescription) + 
+                "RecipeVersionCreateRequest.versionId: " + str(self._versionId) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._displayName is not None
+        if (self._accuracyReached is not None
             and
-            len(self._displayName) < 2):
+            self._accuracyReached < 0):
             raise ValueError(
-                "ModelUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: minLength: 2")
-        if (self._displayName is not None
+                "RecipeVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._accuracyReached is not None
             and
-            len(self._displayName) > 64):
+            self._accuracyReached > 100):
             raise ValueError(
-                "ModelUpdateRequest.displayName: " + str(self._displayName) + 
-                " doesnt match requirement: maxLength: 64")
-        if (self._precision is not None
+                "RecipeVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: maximum: 100")
+        if (self._numberOfEpochs is not None
             and
-            len(self._precision) > 255):
+            self._numberOfEpochs < 0):
             raise ValueError(
-                "ModelUpdateRequest.precision: " + str(self._precision) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._application is not None
+                "RecipeVersionCreateRequest.numberOfEpochs: " + str(self._numberOfEpochs) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._gpuModel is not None
             and
-            len(self._application) > 255):
+            len(self._gpuModel) > 255):
             raise ValueError(
-                "ModelUpdateRequest.application: " + str(self._application) + 
+                "RecipeVersionCreateRequest.gpuModel: " + str(self._gpuModel) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._logo is not None
+        if (self._batchSize is not None
             and
-            len(self._logo) > 255):
+            self._batchSize < 0):
             raise ValueError(
-                "ModelUpdateRequest.logo: " + str(self._logo) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._builtBy is not None
-            and
-            len(self._builtBy) > 255):
-            raise ValueError(
-                "ModelUpdateRequest.builtBy: " + str(self._builtBy) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._publisher is not None
+                "RecipeVersionCreateRequest.batchSize: " + str(self._batchSize) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._memoryFootprint is not None
             and
-            len(self._publisher) > 255):
+            len(self._memoryFootprint) > 255):
             raise ValueError(
-                "ModelUpdateRequest.publisher: " + str(self._publisher) + 
+                "RecipeVersionCreateRequest.memoryFootprint: " + str(self._memoryFootprint) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._publicDatasetUsed is not None): self._publicDatasetUsed.isValid()
+        if (self._customMetrics is not None):
+            for obj in self._customMetrics:
+                if (obj is not None): obj.isValid()
+        if (self._otherContents is not None):
+            for obj in self._otherContents:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/ModelVersion.py` & `ngcbpc/data/model/RecipeVersionUpdateRequest.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,52 +6,42 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .VersionStatusEnum import VersionStatusEnum
 from .CustomMetricGroup import CustomMetricGroup
 from .ArtifactAttribute import ArtifactAttribute
-from .VersionStatusEnum import VersionStatusEnum
 
 # Unused import over optimization prevention
+str(repr(CustomMetricGroup))
 str(repr(ArtifactAttribute))
 str(repr(VersionStatusEnum))
-str(repr(CustomMetricGroup))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ModelVersion(object):
-    """Model version object"""
+class RecipeVersionUpdateRequest(object):
+    """Request to create a new recipe version"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
         self.accuracyReached = (
             None if not fromDict or propDict.get(
                 "accuracyReached"
             ) is None
             else propDict["accuracyReached"])
         self.batchSize = (
             None if not fromDict or propDict.get(
                 "batchSize"
             ) is None
             else propDict["batchSize"])
-        self.createdByUser = (
-            None if not fromDict or propDict.get(
-                "createdByUser"
-            ) is None
-            else propDict["createdByUser"])
-        self.createdDate = (
-            None if not fromDict or propDict.get(
-                "createdDate"
-            ) is None
-            else propDict["createdDate"])
         self.customMetrics = (
             None if not fromDict or propDict.get(
                 "customMetrics"
             ) is None
             else [ CustomMetricGroup(i)
             for i in propDict["customMetrics"] ])
         self.description = (
@@ -60,19 +50,14 @@
             ) is None
             else propDict["description"])
         self.gpuModel = (
             None if not fromDict or propDict.get(
                 "gpuModel"
             ) is None
             else propDict["gpuModel"])
-        self.id = (
-            None if not fromDict or propDict.get(
-                "id"
-            ) is None
-            else propDict["id"])
         self.memoryFootprint = (
             None if not fromDict or propDict.get(
                 "memoryFootprint"
             ) is None
             else propDict["memoryFootprint"])
         self.numberOfEpochs = (
             None if not fromDict or propDict.get(
@@ -81,43 +66,43 @@
             else propDict["numberOfEpochs"])
         self.otherContents = (
             None if not fromDict or propDict.get(
                 "otherContents"
             ) is None
             else [ ArtifactAttribute(i)
             for i in propDict["otherContents"] ])
-        self.ownerName = (
+        self.performance = (
             None if not fromDict or propDict.get(
-                "ownerName"
+                "performance"
             ) is None
-            else propDict["ownerName"])
-        self.status = (
+            else propDict["performance"])
+        self.quickStartGuide = (
             None if not fromDict or propDict.get(
-                "status"
+                "quickStartGuide"
             ) is None
-            else propDict["status"])
-        self.totalFileCount = (
+            else propDict["quickStartGuide"])
+        self.releaseNotes = (
             None if not fromDict or propDict.get(
-                "totalFileCount"
+                "releaseNotes"
             ) is None
-            else propDict["totalFileCount"])
-        self.totalSizeInBytes = (
+            else propDict["releaseNotes"])
+        self.setup = (
             None if not fromDict or propDict.get(
-                "totalSizeInBytes"
+                "setup"
             ) is None
-            else propDict["totalSizeInBytes"])
-        self.versionId = (
+            else propDict["setup"])
+        self.status = (
             None if not fromDict or propDict.get(
-                "versionId"
+                "status"
             ) is None
-            else propDict["versionId"])
+            else propDict["status"])
 
     @property
     def accuracyReached(self):
-        """float: Accuracy this model reached"""
+        """float: Accuracy this recipe reached"""
         return self._accuracyReached
 
     @accuracyReached.setter
     def accuracyReached(self, value):
         if value is not None and not isinstance(value, float):
             value = float(value)
         if (value is None) or isinstance(value, float):
@@ -126,62 +111,29 @@
             raise TypeError(
                 'Property "accuracyReached" of type "list<float>" set to wron'
                 'g type'
             )
 
     @property
     def batchSize(self):
-        """long: Batch size this model was trained with"""
+        """long: Batch size this recipe was trained with"""
         return self._batchSize
 
     @batchSize.setter
     def batchSize(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
             self._batchSize = value
         else:
             raise TypeError(
                 'Property "batchSize" of type "list<long>" set to wrong type'
             )
 
     @property
-    def createdByUser(self):
-        """str: Id of the user who created this model"""
-        return self._createdByUser
-
-    @createdByUser.setter
-    def createdByUser(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdByUser = value
-        else:
-            raise TypeError(
-                'Property "createdByUser" of type "list<str>" set to wrong ty'
-                'pe'
-            )
-
-    @property
-    def createdDate(self):
-        """str: Creation date in ISO-8601 format"""
-        return self._createdDate
-
-    @createdDate.setter
-    def createdDate(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
-        else:
-            raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
-            )
-
-    @property
     def customMetrics(self):
         """list: Custom Metrics key/value pairs"""
         return self._customMetrics
 
     @customMetrics.setter
     def customMetrics(self, value):
         if value is not None and not isinstance(value, list):
@@ -192,15 +144,15 @@
             raise TypeError(
                 'Property "customMetrics" of type "list<CustomMetricGroup>" s'
                 'et to wrong type'
             )
 
     @property
     def description(self):
-        """str: Description of the model version"""
+        """str: Description of the recipe version"""
         return self._description
 
     @description.setter
     def description(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -223,33 +175,16 @@
             self._gpuModel = value
         else:
             raise TypeError(
                 'Property "gpuModel" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Deprecated: Please use versionId instead. Unique ID of the ve
-        rsion"""
-        return self._id
-
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
-        else:
-            raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
-            )
-
-    @property
     def memoryFootprint(self):
-        """str: Model size/memory footprint for inference"""
+        """str: Recipe size/memory footprint for inference"""
         return self._memoryFootprint
 
     @memoryFootprint.setter
     def memoryFootprint(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
@@ -258,15 +193,15 @@
             raise TypeError(
                 'Property "memoryFootprint" of type "list<str>" set to wrong '
                 'type'
             )
 
     @property
     def numberOfEpochs(self):
-        """long: Number of epochs this model trained"""
+        """long: Number of epochs this recipe trained"""
         return self._numberOfEpochs
 
     @numberOfEpochs.setter
     def numberOfEpochs(self, value):
         if value is not None and not isinstance(value, long):
             value = long(value)
         if (value is None) or isinstance(value, long):
@@ -291,170 +226,182 @@
         else:
             raise TypeError(
                 'Property "otherContents" of type "list<ArtifactAttribute>" s'
                 'et to wrong type'
             )
 
     @property
-    def ownerName(self):
-        """str: Name of the user who owns this version"""
-        return self._ownerName
+    def performance(self):
+        """str: Text describing performance of the recipe results"""
+        return self._performance
 
-    @ownerName.setter
-    def ownerName(self, value):
+    @performance.setter
+    def performance(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._ownerName = value
+            self._performance = value
         else:
             raise TypeError(
-                'Property "ownerName" of type "list<str>" set to wrong type'
+                'Property "performance" of type "list<str>" set to wrong type'
             )
 
     @property
-    def status(self):
-        """VersionStatusEnum: Version status"""
-        return self._status
+    def quickStartGuide(self):
+        """str: Text with a guide to getting started"""
+        return self._quickStartGuide
 
-    @status.setter
-    def status(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._status = value
+    @quickStartGuide.setter
+    def quickStartGuide(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._quickStartGuide = value
         else:
             raise TypeError(
-                'Property "status" of type "list<VersionStatusEnum>" set to w'
-                'rong type'
+                'Property "quickStartGuide" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def totalFileCount(self):
-        """long: Total file count"""
-        return self._totalFileCount
+    def releaseNotes(self):
+        """str: Text describing this release"""
+        return self._releaseNotes
 
-    @totalFileCount.setter
-    def totalFileCount(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalFileCount = value
+    @releaseNotes.setter
+    def releaseNotes(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._releaseNotes = value
         else:
             raise TypeError(
-                'Property "totalFileCount" of type "list<long>" set to wrong '
-                'type'
+                'Property "releaseNotes" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def totalSizeInBytes(self):
-        """long: Total size of the model in bytes"""
-        return self._totalSizeInBytes
+    def setup(self):
+        """str: Text describing recipe setup"""
+        return self._setup
 
-    @totalSizeInBytes.setter
-    def totalSizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalSizeInBytes = value
+    @setup.setter
+    def setup(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._setup = value
         else:
             raise TypeError(
-                'Property "totalSizeInBytes" of type "list<long>" set to wron'
-                'g type'
+                'Property "setup" of type "list<str>" set to wrong type'
             )
 
     @property
-    def versionId(self):
-        """str: Unique version id. Please use this instead of 'id'"""
-        return self._versionId
+    def status(self):
+        """VersionStatusEnum: Version status"""
+        return self._status
 
-    @versionId.setter
-    def versionId(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._versionId = value
+    @status.setter
+    def status(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._status = value
         else:
             raise TypeError(
-                'Property "versionId" of type "list<str>" set to wrong type'
+                'Property "status" of type "list<VersionStatusEnum>" set to w'
+                'rong type'
             )
 
     def toDict(self):
         result = {}
         if self._accuracyReached is not None:
             result["accuracyReached"] = \
                 self._accuracyReached
         if self._batchSize is not None:
             result["batchSize"] = \
                 self._batchSize
-        if self._createdByUser is not None:
-            result["createdByUser"] = \
-                self._createdByUser
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
         if self._customMetrics:
             result["customMetrics"] = [
                 i.toDict() for i in self._customMetrics 
             ] if self._customMetrics else []
         if self._description is not None:
             result["description"] = \
                 self._description
         if self._gpuModel is not None:
             result["gpuModel"] = \
                 self._gpuModel
-        if self._id is not None:
-            result["id"] = \
-                self._id
         if self._memoryFootprint is not None:
             result["memoryFootprint"] = \
                 self._memoryFootprint
         if self._numberOfEpochs is not None:
             result["numberOfEpochs"] = \
                 self._numberOfEpochs
         if self._otherContents:
             result["otherContents"] = [
                 i.toDict() for i in self._otherContents 
             ] if self._otherContents else []
-        if self._ownerName is not None:
-            result["ownerName"] = \
-                self._ownerName
+        if self._performance is not None:
+            result["performance"] = \
+                self._performance
+        if self._quickStartGuide is not None:
+            result["quickStartGuide"] = \
+                self._quickStartGuide
+        if self._releaseNotes is not None:
+            result["releaseNotes"] = \
+                self._releaseNotes
+        if self._setup is not None:
+            result["setup"] = \
+                self._setup
         if self._status is not None:
             result["status"] = \
                 self._status
-        if self._totalFileCount is not None:
-            result["totalFileCount"] = \
-                self._totalFileCount
-        if self._totalSizeInBytes is not None:
-            result["totalSizeInBytes"] = \
-                self._totalSizeInBytes
-        if self._versionId is not None:
-            result["versionId"] = \
-                self._versionId
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._versionId is not None
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached < 0):
+            raise ValueError(
+                "RecipeVersionUpdateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._accuracyReached is not None
+            and
+            self._accuracyReached > 100):
+            raise ValueError(
+                "RecipeVersionUpdateRequest.accuracyReached: " + str(self._accuracyReached) + 
+                " doesnt match requirement: maximum: 100")
+        if (self._numberOfEpochs is not None
             and
-            len(self._versionId) > 255):
+            self._numberOfEpochs < 0):
             raise ValueError(
-                "ModelVersion.versionId: " + str(self._versionId) + 
+                "RecipeVersionUpdateRequest.numberOfEpochs: " + str(self._numberOfEpochs) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._gpuModel is not None
+            and
+            len(self._gpuModel) > 255):
+            raise ValueError(
+                "RecipeVersionUpdateRequest.gpuModel: " + str(self._gpuModel) + 
                 " doesnt match requirement: maxLength: 255")
-        if (self._createdDate is not None
+        if (self._batchSize is not None
             and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
+            self._batchSize < 0):
             raise ValueError(
-                "ModelVersion.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
+                "RecipeVersionUpdateRequest.batchSize: " + str(self._batchSize) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._memoryFootprint is not None
+            and
+            len(self._memoryFootprint) > 255):
+            raise ValueError(
+                "RecipeVersionUpdateRequest.memoryFootprint: " + str(self._memoryFootprint) + 
+                " doesnt match requirement: maxLength: 255")
         if (self._customMetrics is not None):
             for obj in self._customMetrics:
                 if (obj is not None): obj.isValid()
         if (self._otherContents is not None):
             for obj in self._otherContents:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/MultipartUploadAbortRequest.py` & `ngcbpc/data/registry/RegistryEvent.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,181 +6,217 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .EventTarget import EventTarget
+from .EventSource import EventSource
+from .Actor import Actor
+from .EventRequest import EventRequest
 
 # Unused import over optimization prevention
+str(repr(EventTarget))
+str(repr(EventSource))
+str(repr(EventRequest))
+str(repr(Actor))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MultipartUploadAbortRequest(object):
-    """Request body for aborting a multipart upload for artifacts"""
+class RegistryEvent(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactType = (
+        self.action = (
             None if not fromDict or propDict.get(
-                "artifactType"
+                "action"
             ) is None
-            else propDict["artifactType"])
-        self.filePath = (
+            else propDict["action"])
+        self.actor = (
             None if not fromDict or propDict.get(
-                "filePath"
+                "actor"
             ) is None
-            else propDict["filePath"])
-        self.name = (
+            else propDict["actor"])
+        self.id = (
             None if not fromDict or propDict.get(
-                "name"
+                "id"
             ) is None
-            else propDict["name"])
-        self.uploadID = (
+            else propDict["id"])
+        self.request = (
             None if not fromDict or propDict.get(
-                "uploadID"
+                "request"
             ) is None
-            else propDict["uploadID"])
-        self.version = (
+            else propDict["request"])
+        self.source = (
             None if not fromDict or propDict.get(
-                "version"
+                "source"
             ) is None
-            else propDict["version"])
+            else propDict["source"])
+        self.target = (
+            None if not fromDict or propDict.get(
+                "target"
+            ) is None
+            else propDict["target"])
+        self.timestamp = (
+            None if not fromDict or propDict.get(
+                "timestamp"
+            ) is None
+            else propDict["timestamp"])
 
     @property
-    def artifactType(self):
-        """str: Type of artifact"""
-        return self._artifactType
+    def action(self):
+        """str: Action indicates what action encompasses the provided event.
+        """
+        return self._action
 
-    @artifactType.setter
-    def artifactType(self, value):
+    @action.setter
+    def action(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._artifactType = value
+            self._action = value
         else:
             raise TypeError(
-                'Property "artifactType" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "action" of type "list<str>" set to wrong type'
             )
 
     @property
-    def filePath(self):
-        """str: The file path for the artifact upload"""
-        return self._filePath
-
-    @filePath.setter
-    def filePath(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._filePath = value
+    def actor(self):
+        """ """
+        return self._actor
+
+    @actor.setter
+    def actor(self, value):
+        if value is not None and not isinstance(value, Actor):
+            value = Actor(value)
+        if (value is None) or isinstance(value, Actor):
+            self._actor = value
         else:
             raise TypeError(
-                'Property "filePath" of type "list<str>" set to wrong type'
+                'Property "actor" of type "list<Actor>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the artifact"""
-        return self._name
+    def id(self):
+        """str: ID provides a unique identifier for the event."""
+        return self._id
 
-    @name.setter
-    def name(self, value):
+    @id.setter
+    def id(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._id = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "id" of type "list<str>" set to wrong type'
             )
 
     @property
-    def uploadID(self):
-        """str: The unique ID assigned by AWS for this multipart upload to ass
-        ociate all upload parts"""
-        return self._uploadID
+    def request(self):
+        """ """
+        return self._request
+
+    @request.setter
+    def request(self, value):
+        if value is not None and not isinstance(value, EventRequest):
+            value = EventRequest(value)
+        if (value is None) or isinstance(value, EventRequest):
+            self._request = value
+        else:
+            raise TypeError(
+                'Property "request" of type "list<EventRequest>" set to wrong'
+                ' type'
+            )
 
-    @uploadID.setter
-    def uploadID(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._uploadID = value
+    @property
+    def source(self):
+        """ """
+        return self._source
+
+    @source.setter
+    def source(self, value):
+        if value is not None and not isinstance(value, EventSource):
+            value = EventSource(value)
+        if (value is None) or isinstance(value, EventSource):
+            self._source = value
+        else:
+            raise TypeError(
+                'Property "source" of type "list<EventSource>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def target(self):
+        """EventTarget: Target uniquely describes the target of the event."""
+        return self._target
+
+    @target.setter
+    def target(self, value):
+        if value is not None and not isinstance(value, EventTarget):
+            value = EventTarget(value)
+        if (value is None) or isinstance(value, EventTarget):
+            self._target = value
         else:
             raise TypeError(
-                'Property "uploadID" of type "list<str>" set to wrong type'
+                'Property "target" of type "list<EventTarget>" set to wrong t'
+                'ype'
             )
 
     @property
-    def version(self):
-        """str: Artifact version"""
-        return self._version
+    def timestamp(self):
+        """str: Timestamp is the time at which the event occurred."""
+        return self._timestamp
 
-    @version.setter
-    def version(self, value):
+    @timestamp.setter
+    def timestamp(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._version = value
+            self._timestamp = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "timestamp" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
-        if self._filePath is not None:
-            result["filePath"] = \
-                self._filePath
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._uploadID is not None:
-            result["uploadID"] = \
-                self._uploadID
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._action is not None:
+            result["action"] = \
+                self._action
+        if self._actor:
+            result["actor"] = \
+                self._actor.toDict() if self._actor is not None else None
+        if self._id is not None:
+            result["id"] = \
+                self._id
+        if self._request:
+            result["request"] = \
+                self._request.toDict() if self._request is not None else None
+        if self._source:
+            result["source"] = \
+                self._source.toDict() if self._source is not None else None
+        if self._target:
+            result["target"] = \
+                self._target.toDict() if self._target is not None else None
+        if self._timestamp is not None:
+            result["timestamp"] = \
+                self._timestamp
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "MultipartUploadAbortRequest.name doesnt match requirement:" 
-                "required: True"
-            )
-        if self._version is None:
-            raise ValueError(
-                "MultipartUploadAbortRequest.version doesnt match requirement:" 
-                "required: True"
-            )
-        if self._artifactType is None:
-            raise ValueError(
-                "MultipartUploadAbortRequest.artifactType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._filePath is None:
-            raise ValueError(
-                "MultipartUploadAbortRequest.filePath doesnt match requirement:" 
-                "required: True"
-            )
-        if self._uploadID is None:
-            raise ValueError(
-                "MultipartUploadAbortRequest.uploadID doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._target is not None): self._target.isValid()
+        if (self._request is not None): self._request.isValid()
+        if (self._actor is not None): self._actor.isValid()
+        if (self._source is not None): self._source.isValid()
         return True
```

## Comparing `ngccli/data/model/MultipartUploadCompleteRequest.py` & `organization/data/subscription_management_service/Order.py`

 * *Files 18% similar despite different names*

```diff
@@ -6,211 +6,212 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
+from .Product import Product
 
 # Unused import over optimization prevention
+str(repr(Product))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class MultipartUploadCompleteRequest(object):
-    """Request body for completing a multipart upload for artifacts"""
+class Order(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.artifactType = (
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "artifactType"
+                "orgName"
             ) is None
-            else propDict["artifactType"])
-        self.filePath = (
+            else propDict["orgName"])
+        self.products = (
             None if not fromDict or propDict.get(
-                "filePath"
+                "products"
             ) is None
-            else propDict["filePath"])
-        self.name = (
+            else [ Product(i)
+            for i in propDict["products"] ])
+        self.term = (
             None if not fromDict or propDict.get(
-                "name"
+                "term"
             ) is None
-            else propDict["name"])
-        self.sha256 = (
+            else propDict["term"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "sha256"
+                "type"
             ) is None
-            else propDict["sha256"])
-        self.uploadID = (
+            else propDict["type"])
+        self.unverifiedCodes = (
             None if not fromDict or propDict.get(
-                "uploadID"
+                "unverifiedCodes"
             ) is None
-            else propDict["uploadID"])
-        self.version = (
+            else propDict["unverifiedCodes"])
+        self.unverifiedCodesCount = (
             None if not fromDict or propDict.get(
-                "version"
+                "unverifiedCodesCount"
             ) is None
-            else propDict["version"])
+            else propDict["unverifiedCodesCount"])
+        self.verifiedCodesCount = (
+            None if not fromDict or propDict.get(
+                "verifiedCodesCount"
+            ) is None
+            else propDict["verifiedCodesCount"])
 
     @property
-    def artifactType(self):
-        """str: Type of artifact"""
-        return self._artifactType
+    def orgName(self):
+        """str: name of the org"""
+        return self._orgName
 
-    @artifactType.setter
-    def artifactType(self, value):
+    @orgName.setter
+    def orgName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._artifactType = value
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "artifactType" of type "list<str>" set to wrong typ'
+                'Property "orgName" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def products(self):
+        """ """
+        return self._products
+
+    @products.setter
+    def products(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._products = value
+        else:
+            raise TypeError(
+                'Property "products" of type "list<Product>" set to wrong typ'
                 'e'
             )
 
     @property
-    def filePath(self):
-        """str: The file path for the artifact upload"""
-        return self._filePath
+    def term(self):
+        """str: term of the order, e.g. 5 Years, Monthly, Yearly, etc"""
+        return self._term
 
-    @filePath.setter
-    def filePath(self, value):
+    @term.setter
+    def term(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._filePath = value
+            self._term = value
         else:
             raise TypeError(
-                'Property "filePath" of type "list<str>" set to wrong type'
+                'Property "term" of type "list<str>" set to wrong type'
             )
 
     @property
-    def name(self):
-        """str: Name of the artifact"""
-        return self._name
+    def type(self):
+        """str: type of order, e.g. H100"""
+        return self._type
 
-    @name.setter
-    def name(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._name = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "name" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     @property
-    def sha256(self):
-        """str: Base64 encoded sha256 hash of file used by AWS to verify data 
-        integrity on the uploads"""
-        return self._sha256
+    def unverifiedCodes(self):
+        """ """
+        return self._unverifiedCodes
 
-    @sha256.setter
-    def sha256(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._sha256 = value
+    @unverifiedCodes.setter
+    def unverifiedCodes(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._unverifiedCodes = value
         else:
             raise TypeError(
-                'Property "sha256" of type "list<str>" set to wrong type'
+                'Property "unverifiedCodes" of type "list<str>" set to wrong '
+                'type'
             )
 
     @property
-    def uploadID(self):
-        """str: The unique ID assigned by AWS for this multipart upload to ass
-        ociate all upload parts"""
-        return self._uploadID
+    def unverifiedCodesCount(self):
+        """int: count of unverified codes"""
+        return self._unverifiedCodesCount
 
-    @uploadID.setter
-    def uploadID(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._uploadID = value
+    @unverifiedCodesCount.setter
+    def unverifiedCodesCount(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._unverifiedCodesCount = value
         else:
             raise TypeError(
-                'Property "uploadID" of type "list<str>" set to wrong type'
+                'Property "unverifiedCodesCount" of type "list<int>" set to w'
+                'rong type'
             )
 
     @property
-    def version(self):
-        """str: Artifact version"""
-        return self._version
+    def verifiedCodesCount(self):
+        """int: count of verified codes"""
+        return self._verifiedCodesCount
 
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
+    @verifiedCodesCount.setter
+    def verifiedCodesCount(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._verifiedCodesCount = value
         else:
             raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "verifiedCodesCount" of type "list<int>" set to wro'
+                'ng type'
             )
 
     def toDict(self):
         result = {}
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
-        if self._filePath is not None:
-            result["filePath"] = \
-                self._filePath
-        if self._name is not None:
-            result["name"] = \
-                self._name
-        if self._sha256 is not None:
-            result["sha256"] = \
-                self._sha256
-        if self._uploadID is not None:
-            result["uploadID"] = \
-                self._uploadID
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._products:
+            result["products"] = [
+                i.toDict() for i in self._products 
+            ] if self._products else []
+        if self._term is not None:
+            result["term"] = \
+                self._term
+        if self._type is not None:
+            result["type"] = \
+                self._type
+        if self._unverifiedCodes is not None:
+            result["unverifiedCodes"] = \
+                self._unverifiedCodes
+        if self._unverifiedCodesCount is not None:
+            result["unverifiedCodesCount"] = \
+                self._unverifiedCodesCount
+        if self._verifiedCodesCount is not None:
+            result["verifiedCodesCount"] = \
+                self._verifiedCodesCount
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._name is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.name doesnt match requirement:" 
-                "required: True"
-            )
-        if self._version is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.version doesnt match requirement:" 
-                "required: True"
-            )
-        if self._artifactType is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.artifactType doesnt match requirement:" 
-                "required: True"
-            )
-        if self._filePath is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.filePath doesnt match requirement:" 
-                "required: True"
-            )
-        if self._uploadID is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.uploadID doesnt match requirement:" 
-                "required: True"
-            )
-        if self._sha256 is None:
-            raise ValueError(
-                "MultipartUploadCompleteRequest.sha256 doesnt match requirement:" 
-                "required: True"
-            )
+        if (self._products is not None):
+            for obj in self._products:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/RecipeVersion.py` & `organization/data/subscription_management_service/Subscription.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,531 +6,572 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CustomMetricGroup import CustomMetricGroup
-from .ArtifactAttribute import ArtifactAttribute
-from .VersionStatusEnum import VersionStatusEnum
+from .SubscriptionStatusEnum import SubscriptionStatusEnum
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(VersionStatusEnum))
-str(repr(CustomMetricGroup))
+str(repr(SubscriptionStatusEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RecipeVersion(object):
-    """Recipe version object"""
+class Subscription(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accuracyReached = (
+        self.autoRenew = (
             None if not fromDict or propDict.get(
-                "accuracyReached"
+                "autoRenew"
             ) is None
-            else propDict["accuracyReached"])
-        self.batchSize = (
+            else propDict["autoRenew"])
+        self.canCancel = (
             None if not fromDict or propDict.get(
-                "batchSize"
+                "canCancel"
             ) is None
-            else propDict["batchSize"])
-        self.createdByUser = (
+            else propDict["canCancel"])
+        self.canRenew = (
             None if not fromDict or propDict.get(
-                "createdByUser"
+                "canRenew"
             ) is None
-            else propDict["createdByUser"])
-        self.createdDate = (
+            else propDict["canRenew"])
+        self.createdByStarfleetId = (
             None if not fromDict or propDict.get(
-                "createdDate"
+                "createdByStarfleetId"
             ) is None
-            else propDict["createdDate"])
-        self.customMetrics = (
+            else propDict["createdByStarfleetId"])
+        self.displayName = (
             None if not fromDict or propDict.get(
-                "customMetrics"
+                "displayName"
             ) is None
-            else [ CustomMetricGroup(i)
-            for i in propDict["customMetrics"] ])
-        self.description = (
+            else propDict["displayName"])
+        self.entitlementId = (
             None if not fromDict or propDict.get(
-                "description"
+                "entitlementId"
             ) is None
-            else propDict["description"])
-        self.gpuModel = (
+            else propDict["entitlementId"])
+        self.expirationDate = (
             None if not fromDict or propDict.get(
-                "gpuModel"
+                "expirationDate"
             ) is None
-            else propDict["gpuModel"])
-        self.id = (
+            else propDict["expirationDate"])
+        self.imageUrl = (
             None if not fromDict or propDict.get(
-                "id"
+                "imageUrl"
             ) is None
-            else propDict["id"])
-        self.memoryFootprint = (
+            else propDict["imageUrl"])
+        self.isAlreadyTaken = (
             None if not fromDict or propDict.get(
-                "memoryFootprint"
+                "isAlreadyTaken"
             ) is None
-            else propDict["memoryFootprint"])
-        self.numberOfEpochs = (
+            else propDict["isAlreadyTaken"])
+        self.isRedemption = (
             None if not fromDict or propDict.get(
-                "numberOfEpochs"
+                "isRedemption"
             ) is None
-            else propDict["numberOfEpochs"])
-        self.otherContents = (
+            else propDict["isRedemption"])
+        self.lifecycleManager = (
             None if not fromDict or propDict.get(
-                "otherContents"
+                "lifecycleManager"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["otherContents"] ])
-        self.performance = (
+            else propDict["lifecycleManager"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "performance"
+                "name"
             ) is None
-            else propDict["performance"])
-        self.quickStartGuide = (
+            else propDict["name"])
+        self.orderDate = (
             None if not fromDict or propDict.get(
-                "quickStartGuide"
+                "orderDate"
             ) is None
-            else propDict["quickStartGuide"])
-        self.releaseNotes = (
+            else propDict["orderDate"])
+        self.orgName = (
             None if not fromDict or propDict.get(
-                "releaseNotes"
+                "orgName"
             ) is None
-            else propDict["releaseNotes"])
-        self.setup = (
+            else propDict["orgName"])
+        self.productIcon = (
             None if not fromDict or propDict.get(
-                "setup"
+                "productIcon"
             ) is None
-            else propDict["setup"])
+            else propDict["productIcon"])
+        self.productRatePlanSku = (
+            None if not fromDict or propDict.get(
+                "productRatePlanSku"
+            ) is None
+            else propDict["productRatePlanSku"])
+        self.productTier = (
+            None if not fromDict or propDict.get(
+                "productTier"
+            ) is None
+            else propDict["productTier"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
         self.status = (
             None if not fromDict or propDict.get(
                 "status"
             ) is None
             else propDict["status"])
-        self.totalFileCount = (
+        self.statusDetails = (
             None if not fromDict or propDict.get(
-                "totalFileCount"
+                "statusDetails"
             ) is None
-            else propDict["totalFileCount"])
-        self.totalSizeInBytes = (
+            else propDict["statusDetails"])
+        self.subscriptionId = (
             None if not fromDict or propDict.get(
-                "totalSizeInBytes"
+                "subscriptionId"
             ) is None
-            else propDict["totalSizeInBytes"])
-        self.versionId = (
+            else propDict["subscriptionId"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "versionId"
+                "type"
             ) is None
-            else propDict["versionId"])
+            else propDict["type"])
+
+    @property
+    def autoRenew(self):
+        """bool: auto renew subscription is allowed or not"""
+        return self._autoRenew
+
+    @autoRenew.setter
+    def autoRenew(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._autoRenew = value
+        else:
+            raise TypeError(
+                'Property "autoRenew" of type "list<bool>" set to wrong type'
+            )
 
     @property
-    def accuracyReached(self):
-        """float: Accuracy this recipe reached"""
-        return self._accuracyReached
+    def canCancel(self):
+        """bool: cancel subscription is allowed or not"""
+        return self._canCancel
 
-    @accuracyReached.setter
-    def accuracyReached(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._accuracyReached = value
+    @canCancel.setter
+    def canCancel(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canCancel = value
         else:
             raise TypeError(
-                'Property "accuracyReached" of type "list<float>" set to wron'
-                'g type'
+                'Property "canCancel" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def batchSize(self):
-        """long: Batch size this recipe was trained with"""
-        return self._batchSize
+    def canRenew(self):
+        """bool: renew subscription is allowed or not"""
+        return self._canRenew
 
-    @batchSize.setter
-    def batchSize(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._batchSize = value
+    @canRenew.setter
+    def canRenew(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._canRenew = value
         else:
             raise TypeError(
-                'Property "batchSize" of type "list<long>" set to wrong type'
+                'Property "canRenew" of type "list<bool>" set to wrong type'
             )
 
     @property
-    def createdByUser(self):
-        """str: Id of the user who created this recipe"""
-        return self._createdByUser
+    def createdByStarfleetId(self):
+        """ """
+        return self._createdByStarfleetId
 
-    @createdByUser.setter
-    def createdByUser(self, value):
+    @createdByStarfleetId.setter
+    def createdByStarfleetId(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdByUser = value
+            self._createdByStarfleetId = value
         else:
             raise TypeError(
-                'Property "createdByUser" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "createdByStarfleetId" of type "list<str>" set to w'
+                'rong type'
             )
 
     @property
-    def createdDate(self):
-        """str: Creation date in ISO-8601 format"""
-        return self._createdDate
+    def displayName(self):
+        """str: name of the product from UCP product catalog"""
+        return self._displayName
 
-    @createdDate.setter
-    def createdDate(self, value):
+    @displayName.setter
+    def displayName(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._createdDate = value
+            self._displayName = value
         else:
             raise TypeError(
-                'Property "createdDate" of type "list<str>" set to wrong type'
+                'Property "displayName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def customMetrics(self):
-        """list: Custom Metrics key/value pairs"""
-        return self._customMetrics
+    def entitlementId(self):
+        """ """
+        return self._entitlementId
 
-    @customMetrics.setter
-    def customMetrics(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._customMetrics = value
+    @entitlementId.setter
+    def entitlementId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._entitlementId = value
         else:
             raise TypeError(
-                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
-                'et to wrong type'
+                'Property "entitlementId" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def description(self):
-        """str: Description of the recipe version"""
-        return self._description
+    def expirationDate(self):
+        """str: expiry date of the subscription"""
+        return self._expirationDate
 
-    @description.setter
-    def description(self, value):
+    @expirationDate.setter
+    def expirationDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._expirationDate = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "expirationDate" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def gpuModel(self):
-        """str: GPU model and memory"""
-        return self._gpuModel
+    def imageUrl(self):
+        """ """
+        return self._imageUrl
 
-    @gpuModel.setter
-    def gpuModel(self, value):
+    @imageUrl.setter
+    def imageUrl(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuModel = value
+            self._imageUrl = value
         else:
             raise TypeError(
-                'Property "gpuModel" of type "list<str>" set to wrong type'
+                'Property "imageUrl" of type "list<str>" set to wrong type'
             )
 
     @property
-    def id(self):
-        """long: Deprecated: Please use versionId instead. Unique ID of the ve
-        rsion"""
-        return self._id
+    def isAlreadyTaken(self):
+        """bool: if entitlement is already taken by an org or not"""
+        return self._isAlreadyTaken
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @isAlreadyTaken.setter
+    def isAlreadyTaken(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isAlreadyTaken = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "isAlreadyTaken" of type "list<bool>" set to wrong '
+                'type'
             )
 
     @property
-    def memoryFootprint(self):
-        """str: recipe size/memory footprint for inference"""
-        return self._memoryFootprint
+    def isRedemption(self):
+        """bool: if the subscription is redeemed/purchased"""
+        return self._isRedemption
+
+    @isRedemption.setter
+    def isRedemption(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._isRedemption = value
+        else:
+            raise TypeError(
+                'Property "isRedemption" of type "list<bool>" set to wrong ty'
+                'pe'
+            )
+
+    @property
+    def lifecycleManager(self):
+        """ """
+        return self._lifecycleManager
 
-    @memoryFootprint.setter
-    def memoryFootprint(self, value):
+    @lifecycleManager.setter
+    def lifecycleManager(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._memoryFootprint = value
+            self._lifecycleManager = value
         else:
             raise TypeError(
-                'Property "memoryFootprint" of type "list<str>" set to wrong '
-                'type'
+                'Property "lifecycleManager" of type "list<str>" set to wrong'
+                ' type'
+            )
+
+    @property
+    def name(self):
+        """str: name of the product"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
             )
 
     @property
-    def numberOfEpochs(self):
-        """long: Number of epochs this recipe trained"""
-        return self._numberOfEpochs
-
-    @numberOfEpochs.setter
-    def numberOfEpochs(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._numberOfEpochs = value
+    def orderDate(self):
+        """str: order date of the subscription"""
+        return self._orderDate
+
+    @orderDate.setter
+    def orderDate(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orderDate = value
         else:
             raise TypeError(
-                'Property "numberOfEpochs" of type "list<long>" set to wrong '
-                'type'
+                'Property "orderDate" of type "list<str>" set to wrong type'
             )
 
     @property
-    def otherContents(self):
-        """list: List of external contents"""
-        return self._otherContents
+    def orgName(self):
+        """str: name of the org"""
+        return self._orgName
 
-    @otherContents.setter
-    def otherContents(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._otherContents = value
+    @orgName.setter
+    def orgName(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._orgName = value
         else:
             raise TypeError(
-                'Property "otherContents" of type "list<ArtifactAttribute>" s'
-                'et to wrong type'
+                'Property "orgName" of type "list<str>" set to wrong type'
             )
 
     @property
-    def performance(self):
-        """str: Text describing performance of the recipe results"""
-        return self._performance
+    def productIcon(self):
+        """ """
+        return self._productIcon
 
-    @performance.setter
-    def performance(self, value):
+    @productIcon.setter
+    def productIcon(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._performance = value
+            self._productIcon = value
         else:
             raise TypeError(
-                'Property "performance" of type "list<str>" set to wrong type'
+                'Property "productIcon" of type "list<str>" set to wrong type'
             )
 
     @property
-    def quickStartGuide(self):
-        """str: Text with a guide to getting started"""
-        return self._quickStartGuide
+    def productRatePlanSku(self):
+        """str: product rate plan sku of the subscription"""
+        return self._productRatePlanSku
 
-    @quickStartGuide.setter
-    def quickStartGuide(self, value):
+    @productRatePlanSku.setter
+    def productRatePlanSku(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._quickStartGuide = value
+            self._productRatePlanSku = value
         else:
             raise TypeError(
-                'Property "quickStartGuide" of type "list<str>" set to wrong '
-                'type'
+                'Property "productRatePlanSku" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def releaseNotes(self):
-        """str: Text describing this release"""
-        return self._releaseNotes
+    def productTier(self):
+        """ """
+        return self._productTier
 
-    @releaseNotes.setter
-    def releaseNotes(self, value):
+    @productTier.setter
+    def productTier(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._releaseNotes = value
+            self._productTier = value
         else:
             raise TypeError(
-                'Property "releaseNotes" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "productTier" of type "list<str>" set to wrong type'
             )
 
     @property
-    def setup(self):
-        """str: Text describing recipe setup"""
-        return self._setup
+    def shortDescription(self):
+        """str: short description of the product"""
+        return self._shortDescription
 
-    @setup.setter
-    def setup(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._setup = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "setup" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
     def status(self):
-        """VersionStatusEnum: Version status"""
+        """SubscriptionStatusEnum: All possible subscription status enums"""
         return self._status
 
     @status.setter
     def status(self, value):
         if (value is None) or isinstance(value, str) or isinstance(value, unicode):
             self._status = value
         else:
             raise TypeError(
-                'Property "status" of type "list<VersionStatusEnum>" set to w'
-                'rong type'
+                'Property "status" of type "list<SubscriptionStatusEnum>" set'
+                ' to wrong type'
             )
 
     @property
-    def totalFileCount(self):
-        """long: Total file count"""
-        return self._totalFileCount
-
-    @totalFileCount.setter
-    def totalFileCount(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalFileCount = value
+    def statusDetails(self):
+        """ """
+        return self._statusDetails
+
+    @statusDetails.setter
+    def statusDetails(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._statusDetails = value
         else:
             raise TypeError(
-                'Property "totalFileCount" of type "list<long>" set to wrong '
-                'type'
+                'Property "statusDetails" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def totalSizeInBytes(self):
-        """long: Total size of the recipe in bytes"""
-        return self._totalSizeInBytes
+    def subscriptionId(self):
+        """str: subscription id for the subscription"""
+        return self._subscriptionId
 
-    @totalSizeInBytes.setter
-    def totalSizeInBytes(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._totalSizeInBytes = value
+    @subscriptionId.setter
+    def subscriptionId(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._subscriptionId = value
         else:
             raise TypeError(
-                'Property "totalSizeInBytes" of type "list<long>" set to wron'
-                'g type'
+                'Property "subscriptionId" of type "list<str>" set to wrong t'
+                'ype'
             )
 
     @property
-    def versionId(self):
-        """str: Unique version id. Please use this instead of 'id'"""
-        return self._versionId
+    def type(self):
+        """ """
+        return self._type
 
-    @versionId.setter
-    def versionId(self, value):
+    @type.setter
+    def type(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._versionId = value
+            self._type = value
         else:
             raise TypeError(
-                'Property "versionId" of type "list<str>" set to wrong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accuracyReached is not None:
-            result["accuracyReached"] = \
-                self._accuracyReached
-        if self._batchSize is not None:
-            result["batchSize"] = \
-                self._batchSize
-        if self._createdByUser is not None:
-            result["createdByUser"] = \
-                self._createdByUser
-        if self._createdDate is not None:
-            result["createdDate"] = \
-                self._createdDate
-        if self._customMetrics:
-            result["customMetrics"] = [
-                i.toDict() for i in self._customMetrics 
-            ] if self._customMetrics else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._gpuModel is not None:
-            result["gpuModel"] = \
-                self._gpuModel
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._memoryFootprint is not None:
-            result["memoryFootprint"] = \
-                self._memoryFootprint
-        if self._numberOfEpochs is not None:
-            result["numberOfEpochs"] = \
-                self._numberOfEpochs
-        if self._otherContents:
-            result["otherContents"] = [
-                i.toDict() for i in self._otherContents 
-            ] if self._otherContents else []
-        if self._performance is not None:
-            result["performance"] = \
-                self._performance
-        if self._quickStartGuide is not None:
-            result["quickStartGuide"] = \
-                self._quickStartGuide
-        if self._releaseNotes is not None:
-            result["releaseNotes"] = \
-                self._releaseNotes
-        if self._setup is not None:
-            result["setup"] = \
-                self._setup
+        if self._autoRenew is not None:
+            result["autoRenew"] = \
+                self._autoRenew
+        if self._canCancel is not None:
+            result["canCancel"] = \
+                self._canCancel
+        if self._canRenew is not None:
+            result["canRenew"] = \
+                self._canRenew
+        if self._createdByStarfleetId is not None:
+            result["createdByStarfleetId"] = \
+                self._createdByStarfleetId
+        if self._displayName is not None:
+            result["displayName"] = \
+                self._displayName
+        if self._entitlementId is not None:
+            result["entitlementId"] = \
+                self._entitlementId
+        if self._expirationDate is not None:
+            result["expirationDate"] = \
+                self._expirationDate
+        if self._imageUrl is not None:
+            result["imageUrl"] = \
+                self._imageUrl
+        if self._isAlreadyTaken is not None:
+            result["isAlreadyTaken"] = \
+                self._isAlreadyTaken
+        if self._isRedemption is not None:
+            result["isRedemption"] = \
+                self._isRedemption
+        if self._lifecycleManager is not None:
+            result["lifecycleManager"] = \
+                self._lifecycleManager
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._orderDate is not None:
+            result["orderDate"] = \
+                self._orderDate
+        if self._orgName is not None:
+            result["orgName"] = \
+                self._orgName
+        if self._productIcon is not None:
+            result["productIcon"] = \
+                self._productIcon
+        if self._productRatePlanSku is not None:
+            result["productRatePlanSku"] = \
+                self._productRatePlanSku
+        if self._productTier is not None:
+            result["productTier"] = \
+                self._productTier
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
         if self._status is not None:
             result["status"] = \
                 self._status
-        if self._totalFileCount is not None:
-            result["totalFileCount"] = \
-                self._totalFileCount
-        if self._totalSizeInBytes is not None:
-            result["totalSizeInBytes"] = \
-                self._totalSizeInBytes
-        if self._versionId is not None:
-            result["versionId"] = \
-                self._versionId
+        if self._statusDetails is not None:
+            result["statusDetails"] = \
+                self._statusDetails
+        if self._subscriptionId is not None:
+            result["subscriptionId"] = \
+                self._subscriptionId
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._versionId is not None
-            and
-            len(self._versionId) > 255):
-            raise ValueError(
-                "RecipeVersion.versionId: " + str(self._versionId) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._createdDate is not None
-            and
-            not re.match(
-                r"\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+Z",
-                 self._createdDate)):
-            raise ValueError(
-                "RecipeVersion.createdDate: " + str(self._createdDate) + 
-                " doesnt match requirement: pattern: \d{4}-[01]\d-[0-3]\dT[0-"
-                "2]\d:[0-5]\d:[0-5]\d\.\d+Z")
-        if (self._customMetrics is not None):
-            for obj in self._customMetrics:
-                if (obj is not None): obj.isValid()
-        if (self._otherContents is not None):
-            for obj in self._otherContents:
-                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/model/RecipeVersionCreateRequest.py` & `organization/data/subscription_management_service/ProductPlan.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,446 +6,461 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .CustomMetricGroup import CustomMetricGroup
-from .ArtifactAttribute import ArtifactAttribute
+from .Pricing import Pricing
 
 # Unused import over optimization prevention
-str(repr(ArtifactAttribute))
-str(repr(CustomMetricGroup))
+str(repr(Pricing))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class RecipeVersionCreateRequest(object):
-    """Request to create a new recipe version"""
+class ProductPlan(object):
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accuracyReached = (
+        self.allowMultipleQuantities = (
             None if not fromDict or propDict.get(
-                "accuracyReached"
+                "allowMultipleQuantities"
             ) is None
-            else propDict["accuracyReached"])
-        self.batchSize = (
+            else propDict["allowMultipleQuantities"])
+        self.downgradeSkus = (
             None if not fromDict or propDict.get(
-                "batchSize"
+                "downgradeSkus"
             ) is None
-            else propDict["batchSize"])
-        self.customMetrics = (
+            else propDict["downgradeSkus"])
+        self.effectiveEndDate = (
             None if not fromDict or propDict.get(
-                "customMetrics"
+                "effectiveEndDate"
             ) is None
-            else [ CustomMetricGroup(i)
-            for i in propDict["customMetrics"] ])
-        self.description = (
+            else propDict["effectiveEndDate"])
+        self.effectiveStartDate = (
             None if not fromDict or propDict.get(
-                "description"
+                "effectiveStartDate"
             ) is None
-            else propDict["description"])
-        self.gpuModel = (
+            else propDict["effectiveStartDate"])
+        self.initialPeriod = (
             None if not fromDict or propDict.get(
-                "gpuModel"
+                "initialPeriod"
             ) is None
-            else propDict["gpuModel"])
-        self.id = (
+            else propDict["initialPeriod"])
+        self.initialPeriodType = (
             None if not fromDict or propDict.get(
-                "id"
+                "initialPeriodType"
             ) is None
-            else propDict["id"])
-        self.memoryFootprint = (
+            else propDict["initialPeriodType"])
+        self.longDescription = (
             None if not fromDict or propDict.get(
-                "memoryFootprint"
+                "longDescription"
             ) is None
-            else propDict["memoryFootprint"])
-        self.numberOfEpochs = (
+            else propDict["longDescription"])
+        self.name = (
             None if not fromDict or propDict.get(
-                "numberOfEpochs"
+                "name"
             ) is None
-            else propDict["numberOfEpochs"])
-        self.otherContents = (
+            else propDict["name"])
+        self.pricing = (
             None if not fromDict or propDict.get(
-                "otherContents"
+                "pricing"
             ) is None
-            else [ ArtifactAttribute(i)
-            for i in propDict["otherContents"] ])
-        self.performance = (
+            else [ Pricing(i)
+            for i in propDict["pricing"] ])
+        self.productRatePlanSku = (
             None if not fromDict or propDict.get(
-                "performance"
+                "productRatePlanSku"
             ) is None
-            else propDict["performance"])
-        self.quickStartGuide = (
+            else propDict["productRatePlanSku"])
+        self.productRatePlanType = (
             None if not fromDict or propDict.get(
-                "quickStartGuide"
+                "productRatePlanType"
             ) is None
-            else propDict["quickStartGuide"])
-        self.releaseNotes = (
+            else propDict["productRatePlanType"])
+        self.renewalPeriodType = (
             None if not fromDict or propDict.get(
-                "releaseNotes"
+                "renewalPeriodType"
             ) is None
-            else propDict["releaseNotes"])
-        self.setup = (
+            else propDict["renewalPeriodType"])
+        self.renewalSetting = (
             None if not fromDict or propDict.get(
-                "setup"
+                "renewalSetting"
             ) is None
-            else propDict["setup"])
-        self.versionId = (
+            else propDict["renewalSetting"])
+        self.renewalTermsPeriod = (
             None if not fromDict or propDict.get(
-                "versionId"
+                "renewalTermsPeriod"
             ) is None
-            else propDict["versionId"])
-
-    @property
-    def accuracyReached(self):
-        """float: Accuracy this recipe reached"""
-        return self._accuracyReached
-
-    @accuracyReached.setter
-    def accuracyReached(self, value):
-        if value is not None and not isinstance(value, float):
-            value = float(value)
-        if (value is None) or isinstance(value, float):
-            self._accuracyReached = value
-        else:
-            raise TypeError(
-                'Property "accuracyReached" of type "list<float>" set to wron'
-                'g type'
-            )
+            else propDict["renewalTermsPeriod"])
+        self.shortDescription = (
+            None if not fromDict or propDict.get(
+                "shortDescription"
+            ) is None
+            else propDict["shortDescription"])
+        self.termType = (
+            None if not fromDict or propDict.get(
+                "termType"
+            ) is None
+            else propDict["termType"])
+        self.upgradeSkus = (
+            None if not fromDict or propDict.get(
+                "upgradeSkus"
+            ) is None
+            else propDict["upgradeSkus"])
 
     @property
-    def batchSize(self):
-        """long: Batch size this recipe was trained with"""
-        return self._batchSize
+    def allowMultipleQuantities(self):
+        """ """
+        return self._allowMultipleQuantities
 
-    @batchSize.setter
-    def batchSize(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._batchSize = value
+    @allowMultipleQuantities.setter
+    def allowMultipleQuantities(self, value):
+        if value is not None and not isinstance(value, bool):
+            value = bool(value)
+        if (value is None) or isinstance(value, bool):
+            self._allowMultipleQuantities = value
         else:
             raise TypeError(
-                'Property "batchSize" of type "list<long>" set to wrong type'
+                'Property "allowMultipleQuantities" of type "list<bool>" set '
+                'to wrong type'
             )
 
     @property
-    def customMetrics(self):
-        """list: Custom Metrics key/value pairs"""
-        return self._customMetrics
+    def downgradeSkus(self):
+        """ """
+        return self._downgradeSkus
 
-    @customMetrics.setter
-    def customMetrics(self, value):
+    @downgradeSkus.setter
+    def downgradeSkus(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._customMetrics = value
+            self._downgradeSkus = value
         else:
             raise TypeError(
-                'Property "customMetrics" of type "list<CustomMetricGroup>" s'
-                'et to wrong type'
+                'Property "downgradeSkus" of type "list<str>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def description(self):
-        """str: Description of the recipe version"""
-        return self._description
+    def effectiveEndDate(self):
+        """ """
+        return self._effectiveEndDate
 
-    @description.setter
-    def description(self, value):
+    @effectiveEndDate.setter
+    def effectiveEndDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._description = value
+            self._effectiveEndDate = value
         else:
             raise TypeError(
-                'Property "description" of type "list<str>" set to wrong type'
+                'Property "effectiveEndDate" of type "list<str>" set to wrong'
+                ' type'
             )
 
     @property
-    def gpuModel(self):
-        """str: GPU model and memory"""
-        return self._gpuModel
+    def effectiveStartDate(self):
+        """ """
+        return self._effectiveStartDate
 
-    @gpuModel.setter
-    def gpuModel(self, value):
+    @effectiveStartDate.setter
+    def effectiveStartDate(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._gpuModel = value
+            self._effectiveStartDate = value
         else:
             raise TypeError(
-                'Property "gpuModel" of type "list<str>" set to wrong type'
+                'Property "effectiveStartDate" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def id(self):
-        """long: Deprecated: Please use version instead. Unique ID of the vers
-        ion"""
-        return self._id
+    def initialPeriod(self):
+        """ """
+        return self._initialPeriod
 
-    @id.setter
-    def id(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._id = value
+    @initialPeriod.setter
+    def initialPeriod(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._initialPeriod = value
         else:
             raise TypeError(
-                'Property "id" of type "list<long>" set to wrong type'
+                'Property "initialPeriod" of type "list<int>" set to wrong ty'
+                'pe'
             )
 
     @property
-    def memoryFootprint(self):
-        """str: Recipe size/memory footprint for inference"""
-        return self._memoryFootprint
+    def initialPeriodType(self):
+        """ """
+        return self._initialPeriodType
 
-    @memoryFootprint.setter
-    def memoryFootprint(self, value):
+    @initialPeriodType.setter
+    def initialPeriodType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._memoryFootprint = value
+            self._initialPeriodType = value
         else:
             raise TypeError(
-                'Property "memoryFootprint" of type "list<str>" set to wrong '
-                'type'
+                'Property "initialPeriodType" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def numberOfEpochs(self):
-        """long: Number of epochs this recipe trained"""
-        return self._numberOfEpochs
-
-    @numberOfEpochs.setter
-    def numberOfEpochs(self, value):
-        if value is not None and not isinstance(value, long):
-            value = long(value)
-        if (value is None) or isinstance(value, long):
-            self._numberOfEpochs = value
+    def longDescription(self):
+        """str: long description of the rate plan"""
+        return self._longDescription
+
+    @longDescription.setter
+    def longDescription(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._longDescription = value
         else:
             raise TypeError(
-                'Property "numberOfEpochs" of type "list<long>" set to wrong '
+                'Property "longDescription" of type "list<str>" set to wrong '
                 'type'
             )
 
     @property
-    def otherContents(self):
-        """list: List of external contents"""
-        return self._otherContents
+    def name(self):
+        """str: name of the rate plan"""
+        return self._name
+
+    @name.setter
+    def name(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._name = value
+        else:
+            raise TypeError(
+                'Property "name" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def pricing(self):
+        """ """
+        return self._pricing
 
-    @otherContents.setter
-    def otherContents(self, value):
+    @pricing.setter
+    def pricing(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._otherContents = value
+            self._pricing = value
         else:
             raise TypeError(
-                'Property "otherContents" of type "list<ArtifactAttribute>" s'
-                'et to wrong type'
+                'Property "pricing" of type "list<Pricing>" set to wrong type'
             )
 
     @property
-    def performance(self):
-        """str: Text describing performance of the recipe results"""
-        return self._performance
+    def productRatePlanSku(self):
+        """ """
+        return self._productRatePlanSku
 
-    @performance.setter
-    def performance(self, value):
+    @productRatePlanSku.setter
+    def productRatePlanSku(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._performance = value
+            self._productRatePlanSku = value
         else:
             raise TypeError(
-                'Property "performance" of type "list<str>" set to wrong type'
+                'Property "productRatePlanSku" of type "list<str>" set to wro'
+                'ng type'
             )
 
     @property
-    def quickStartGuide(self):
-        """str: Text with a guide to getting started"""
-        return self._quickStartGuide
+    def productRatePlanType(self):
+        """ """
+        return self._productRatePlanType
 
-    @quickStartGuide.setter
-    def quickStartGuide(self, value):
+    @productRatePlanType.setter
+    def productRatePlanType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._quickStartGuide = value
+            self._productRatePlanType = value
         else:
             raise TypeError(
-                'Property "quickStartGuide" of type "list<str>" set to wrong '
-                'type'
+                'Property "productRatePlanType" of type "list<str>" set to wr'
+                'ong type'
             )
 
     @property
-    def releaseNotes(self):
-        """str: Text describing this release"""
-        return self._releaseNotes
+    def renewalPeriodType(self):
+        """ """
+        return self._renewalPeriodType
 
-    @releaseNotes.setter
-    def releaseNotes(self, value):
+    @renewalPeriodType.setter
+    def renewalPeriodType(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._releaseNotes = value
+            self._renewalPeriodType = value
         else:
             raise TypeError(
-                'Property "releaseNotes" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "renewalPeriodType" of type "list<str>" set to wron'
+                'g type'
             )
 
     @property
-    def setup(self):
-        """str: Text describing recipe setup"""
-        return self._setup
+    def renewalSetting(self):
+        """ """
+        return self._renewalSetting
 
-    @setup.setter
-    def setup(self, value):
+    @renewalSetting.setter
+    def renewalSetting(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._setup = value
+            self._renewalSetting = value
+        else:
+            raise TypeError(
+                'Property "renewalSetting" of type "list<str>" set to wrong t'
+                'ype'
+            )
+
+    @property
+    def renewalTermsPeriod(self):
+        """ """
+        return self._renewalTermsPeriod
+
+    @renewalTermsPeriod.setter
+    def renewalTermsPeriod(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._renewalTermsPeriod = value
         else:
             raise TypeError(
-                'Property "setup" of type "list<str>" set to wrong type'
+                'Property "renewalTermsPeriod" of type "list<int>" set to wro'
+                'ng type'
             )
 
     @property
-    def versionId(self):
-        """str: Unique version id. Please use this instead of 'id'"""
-        return self._versionId
+    def shortDescription(self):
+        """str: short description of the rate plan"""
+        return self._shortDescription
 
-    @versionId.setter
-    def versionId(self, value):
+    @shortDescription.setter
+    def shortDescription(self, value):
         if value is not None and not isinstance(value, string_types):
             value = repr(value)
         if (value is None) or isinstance(value, string_types):
-            self._versionId = value
+            self._shortDescription = value
         else:
             raise TypeError(
-                'Property "versionId" of type "list<str>" set to wrong type'
+                'Property "shortDescription" of type "list<str>" set to wrong'
+                ' type'
+            )
+
+    @property
+    def termType(self):
+        """ """
+        return self._termType
+
+    @termType.setter
+    def termType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._termType = value
+        else:
+            raise TypeError(
+                'Property "termType" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def upgradeSkus(self):
+        """ """
+        return self._upgradeSkus
+
+    @upgradeSkus.setter
+    def upgradeSkus(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._upgradeSkus = value
+        else:
+            raise TypeError(
+                'Property "upgradeSkus" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accuracyReached is not None:
-            result["accuracyReached"] = \
-                self._accuracyReached
-        if self._batchSize is not None:
-            result["batchSize"] = \
-                self._batchSize
-        if self._customMetrics:
-            result["customMetrics"] = [
-                i.toDict() for i in self._customMetrics 
-            ] if self._customMetrics else []
-        if self._description is not None:
-            result["description"] = \
-                self._description
-        if self._gpuModel is not None:
-            result["gpuModel"] = \
-                self._gpuModel
-        if self._id is not None:
-            result["id"] = \
-                self._id
-        if self._memoryFootprint is not None:
-            result["memoryFootprint"] = \
-                self._memoryFootprint
-        if self._numberOfEpochs is not None:
-            result["numberOfEpochs"] = \
-                self._numberOfEpochs
-        if self._otherContents:
-            result["otherContents"] = [
-                i.toDict() for i in self._otherContents 
-            ] if self._otherContents else []
-        if self._performance is not None:
-            result["performance"] = \
-                self._performance
-        if self._quickStartGuide is not None:
-            result["quickStartGuide"] = \
-                self._quickStartGuide
-        if self._releaseNotes is not None:
-            result["releaseNotes"] = \
-                self._releaseNotes
-        if self._setup is not None:
-            result["setup"] = \
-                self._setup
-        if self._versionId is not None:
-            result["versionId"] = \
-                self._versionId
+        if self._allowMultipleQuantities is not None:
+            result["allowMultipleQuantities"] = \
+                self._allowMultipleQuantities
+        if self._downgradeSkus is not None:
+            result["downgradeSkus"] = \
+                self._downgradeSkus
+        if self._effectiveEndDate is not None:
+            result["effectiveEndDate"] = \
+                self._effectiveEndDate
+        if self._effectiveStartDate is not None:
+            result["effectiveStartDate"] = \
+                self._effectiveStartDate
+        if self._initialPeriod is not None:
+            result["initialPeriod"] = \
+                self._initialPeriod
+        if self._initialPeriodType is not None:
+            result["initialPeriodType"] = \
+                self._initialPeriodType
+        if self._longDescription is not None:
+            result["longDescription"] = \
+                self._longDescription
+        if self._name is not None:
+            result["name"] = \
+                self._name
+        if self._pricing:
+            result["pricing"] = [
+                i.toDict() for i in self._pricing 
+            ] if self._pricing else []
+        if self._productRatePlanSku is not None:
+            result["productRatePlanSku"] = \
+                self._productRatePlanSku
+        if self._productRatePlanType is not None:
+            result["productRatePlanType"] = \
+                self._productRatePlanType
+        if self._renewalPeriodType is not None:
+            result["renewalPeriodType"] = \
+                self._renewalPeriodType
+        if self._renewalSetting is not None:
+            result["renewalSetting"] = \
+                self._renewalSetting
+        if self._renewalTermsPeriod is not None:
+            result["renewalTermsPeriod"] = \
+                self._renewalTermsPeriod
+        if self._shortDescription is not None:
+            result["shortDescription"] = \
+                self._shortDescription
+        if self._termType is not None:
+            result["termType"] = \
+                self._termType
+        if self._upgradeSkus is not None:
+            result["upgradeSkus"] = \
+                self._upgradeSkus
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._id is not None
-            and
-            self._id < 1):
-            raise ValueError(
-                "RecipeVersionCreateRequest.id: " + str(self._id) + 
-                " doesnt match requirement: minimum: 1")
-        if (self._id is not None
-            and
-            self._id > 2147483647):
-            raise ValueError(
-                "RecipeVersionCreateRequest.id: " + str(self._id) + 
-                " doesnt match requirement: maximum: 2147483647")
-        if (self._versionId is not None
-            and
-            len(self._versionId) > 255):
-            raise ValueError(
-                "RecipeVersionCreateRequest.versionId: " + str(self._versionId) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._accuracyReached is not None
-            and
-            self._accuracyReached < 0):
-            raise ValueError(
-                "RecipeVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._accuracyReached is not None
-            and
-            self._accuracyReached > 100):
-            raise ValueError(
-                "RecipeVersionCreateRequest.accuracyReached: " + str(self._accuracyReached) + 
-                " doesnt match requirement: maximum: 100")
-        if (self._numberOfEpochs is not None
-            and
-            self._numberOfEpochs < 0):
-            raise ValueError(
-                "RecipeVersionCreateRequest.numberOfEpochs: " + str(self._numberOfEpochs) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._gpuModel is not None
-            and
-            len(self._gpuModel) > 255):
-            raise ValueError(
-                "RecipeVersionCreateRequest.gpuModel: " + str(self._gpuModel) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._batchSize is not None
-            and
-            self._batchSize < 0):
-            raise ValueError(
-                "RecipeVersionCreateRequest.batchSize: " + str(self._batchSize) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._memoryFootprint is not None
-            and
-            len(self._memoryFootprint) > 255):
-            raise ValueError(
-                "RecipeVersionCreateRequest.memoryFootprint: " + str(self._memoryFootprint) + 
-                " doesnt match requirement: maxLength: 255")
-        if (self._customMetrics is not None):
-            for obj in self._customMetrics:
-                if (obj is not None): obj.isValid()
-        if (self._otherContents is not None):
-            for obj in self._otherContents:
+        if (self._pricing is not None):
+            for obj in self._pricing:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/publishing/BatchPublishingRequest.py` & `registry/data/publishing/BatchPublishingRequest.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -7,23 +7,23 @@
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
 from .AccessTypeEnum import AccessTypeEnum
+from .ArtifactType import ArtifactTypeEnum
 from .ArtifactBatch import ArtifactBatch
 from .ProductNamesEnum import ProductNamesEnum
-from .ArtifactType import ArtifactTypeEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNamesEnum))
-str(repr(ArtifactTypeEnum))
 str(repr(ArtifactBatch))
 str(repr(AccessTypeEnum))
+str(repr(ArtifactTypeEnum))
+str(repr(ProductNamesEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class BatchPublishingRequest(object):
```

## Comparing `ngccli/data/publishing/PublishingRequest.py` & `basecommand/data/pym/ClusterInstance.py`

 * *Files 17% similar despite different names*

```diff
@@ -6,293 +6,283 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .AccessTypeEnum import AccessTypeEnum
-from .ProductNamesEnum import ProductNamesEnum
-from .Artifact import Artifact
-from .ArtifactType import ArtifactTypeEnum
 
 # Unused import over optimization prevention
-str(repr(ProductNamesEnum))
-str(repr(Artifact))
-str(repr(ArtifactTypeEnum))
-str(repr(AccessTypeEnum))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class PublishingRequest(object):
-    """Request to publish an artifact"""
+class ClusterInstance(object):
+    """Machine instance type"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.accessType = (
+        self.cpuCores = (
             None if not fromDict or propDict.get(
-                "accessType"
+                "cpuCores"
             ) is None
-            else propDict["accessType"])
-        self.artifactType = (
+            else propDict["cpuCores"])
+        self.description = (
             None if not fromDict or propDict.get(
-                "artifactType"
+                "description"
             ) is None
-            else propDict["artifactType"])
-        self.productNames = (
+            else propDict["description"])
+        self.gpuMemory = (
             None if not fromDict or propDict.get(
-                "productNames"
+                "gpuMemory"
             ) is None
-            else propDict["productNames"])
-        self.publishAsListedToPublic = (
+            else propDict["gpuMemory"])
+        self.gpus = (
             None if not fromDict or propDict.get(
-                "publishAsListedToPublic"
+                "gpus"
             ) is None
-            else propDict["publishAsListedToPublic"])
-        self.publishAssetsToCdn = (
+            else propDict["gpus"])
+        self.machineType = (
             None if not fromDict or propDict.get(
-                "publishAssetsToCdn"
+                "machineType"
             ) is None
-            else propDict["publishAssetsToCdn"])
-        self.publishToPublic = (
+            else propDict["machineType"])
+        self.systemMemory = (
             None if not fromDict or propDict.get(
-                "publishToPublic"
+                "systemMemory"
             ) is None
-            else propDict["publishToPublic"])
-        self.publishWithGuestAccess = (
+            else propDict["systemMemory"])
+        self.type = (
             None if not fromDict or propDict.get(
-                "publishWithGuestAccess"
+                "type"
             ) is None
-            else propDict["publishWithGuestAccess"])
-        self.sign = (
-            None if not fromDict or propDict.get(
-                "sign"
-            ) is None
-            else propDict["sign"])
-        self.sourceArtifact = (
-            None if not fromDict or propDict.get(
-                "sourceArtifact"
-            ) is None
-            else propDict["sourceArtifact"])
-        self.targetArtifact = (
-            None if not fromDict or propDict.get(
-                "targetArtifact"
-            ) is None
-            else propDict["targetArtifact"])
-
-    @property
-    def accessType(self):
-        """ """
-        return self._accessType
-
-    @accessType.setter
-    def accessType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._accessType = value
-        else:
-            raise TypeError(
-                'Property "accessType" of type "list<AccessTypeEnum>" set to '
-                'wrong type'
-            )
+            else propDict["type"])
 
     @property
-    def artifactType(self):
-        """ """
-        return self._artifactType
-
-    @artifactType.setter
-    def artifactType(self, value):
-        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
-            self._artifactType = value
+    def cpuCores(self):
+        """float: Number of CPU cores for a job, user can specify 1.5 cores he
+        re"""
+        return self._cpuCores
+
+    @cpuCores.setter
+    def cpuCores(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._cpuCores = value
         else:
             raise TypeError(
-                'Property "artifactType" of type "list<ArtifactTypeEnum>" set'
-                ' to wrong type'
+                'Property "cpuCores" of type "list<float>" set to wrong type'
             )
 
     @property
-    def productNames(self):
-        """list: Product names"""
-        return self._productNames
-
-    @productNames.setter
-    def productNames(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._productNames = value
+    def description(self):
+        """str: Machine characteristics"""
+        return self._description
+
+    @description.setter
+    def description(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._description = value
         else:
             raise TypeError(
-                'Property "productNames" of type "list<ProductNamesEnum>" set'
-                ' to wrong type'
+                'Property "description" of type "list<str>" set to wrong type'
             )
 
     @property
-    def publishAsListedToPublic(self):
-        """bool: Enable public listings including: NGC Search. Default: true. 
-        Pre-req: publishToPublic set to true"""
-        return self._publishAsListedToPublic
-
-    @publishAsListedToPublic.setter
-    def publishAsListedToPublic(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._publishAsListedToPublic = value
+    def gpuMemory(self):
+        """float: gpu memory in MB"""
+        return self._gpuMemory
+
+    @gpuMemory.setter
+    def gpuMemory(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._gpuMemory = value
         else:
             raise TypeError(
-                'Property "publishAsListedToPublic" of type "list<bool>" set '
-                'to wrong type'
+                'Property "gpuMemory" of type "list<float>" set to wrong type'
             )
 
     @property
-    def publishAssetsToCdn(self):
-        """bool: Publish detected assets in the README `description` field of 
-        the asset to CDN"""
-        return self._publishAssetsToCdn
-
-    @publishAssetsToCdn.setter
-    def publishAssetsToCdn(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._publishAssetsToCdn = value
+    def gpus(self):
+        """int: number of GPUs for a job"""
+        return self._gpus
+
+    @gpus.setter
+    def gpus(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._gpus = value
         else:
             raise TypeError(
-                'Property "publishAssetsToCdn" of type "list<bool>" set to wr'
-                'ong type'
+                'Property "gpus" of type "list<int>" set to wrong type'
             )
 
     @property
-    def publishToPublic(self):
-        """bool: Enable public access to artifact"""
-        return self._publishToPublic
-
-    @publishToPublic.setter
-    def publishToPublic(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._publishToPublic = value
+    def machineType(self):
+        """str: Machine instance short name"""
+        return self._machineType
+
+    @machineType.setter
+    def machineType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._machineType = value
         else:
             raise TypeError(
-                'Property "publishToPublic" of type "list<bool>" set to wrong'
-                ' type'
+                'Property "machineType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def publishWithGuestAccess(self):
-        """bool: Enable public anonymous access to artifact. Pre-req: publishT
-        oPublic set to true"""
-        return self._publishWithGuestAccess
-
-    @publishWithGuestAccess.setter
-    def publishWithGuestAccess(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._publishWithGuestAccess = value
+    def systemMemory(self):
+        """float: system memory in MB"""
+        return self._systemMemory
+
+    @systemMemory.setter
+    def systemMemory(self, value):
+        if value is not None and not isinstance(value, float):
+            value = float(value)
+        if (value is None) or isinstance(value, float):
+            self._systemMemory = value
         else:
             raise TypeError(
-                'Property "publishWithGuestAccess" of type "list<bool>" set t'
-                'o wrong type'
+                'Property "systemMemory" of type "list<float>" set to wrong t'
+                'ype'
             )
 
     @property
-    def sign(self):
-        """bool: Sign the source container image with Nvidia key before publis
-        hing"""
-        return self._sign
-
-    @sign.setter
-    def sign(self, value):
-        if value is not None and not isinstance(value, bool):
-            value = bool(value)
-        if (value is None) or isinstance(value, bool):
-            self._sign = value
+    def type(self):
+        """str: The type of instance that will be running the job, GPU, CPU or
+         MIG"""
+        return self._type
+
+    @type.setter
+    def type(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._type = value
         else:
             raise TypeError(
-                'Property "sign" of type "list<bool>" set to wrong type'
-            )
-
-    @property
-    def sourceArtifact(self):
-        """Artifact: NGC Artifact"""
-        return self._sourceArtifact
-
-    @sourceArtifact.setter
-    def sourceArtifact(self, value):
-        if value is not None and not isinstance(value, Artifact):
-            value = Artifact(value)
-        if (value is None) or isinstance(value, Artifact):
-            self._sourceArtifact = value
-        else:
-            raise TypeError(
-                'Property "sourceArtifact" of type "list<Artifact>" set to wr'
-                'ong type'
-            )
-
-    @property
-    def targetArtifact(self):
-        """Artifact: NGC Artifact"""
-        return self._targetArtifact
-
-    @targetArtifact.setter
-    def targetArtifact(self, value):
-        if value is not None and not isinstance(value, Artifact):
-            value = Artifact(value)
-        if (value is None) or isinstance(value, Artifact):
-            self._targetArtifact = value
-        else:
-            raise TypeError(
-                'Property "targetArtifact" of type "list<Artifact>" set to wr'
-                'ong type'
+                'Property "type" of type "list<str>" set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._accessType is not None:
-            result["accessType"] = \
-                self._accessType
-        if self._artifactType is not None:
-            result["artifactType"] = \
-                self._artifactType
-        if self._productNames is not None:
-            result["productNames"] = \
-                self._productNames
-        if self._publishAsListedToPublic is not None:
-            result["publishAsListedToPublic"] = \
-                self._publishAsListedToPublic
-        if self._publishAssetsToCdn is not None:
-            result["publishAssetsToCdn"] = \
-                self._publishAssetsToCdn
-        if self._publishToPublic is not None:
-            result["publishToPublic"] = \
-                self._publishToPublic
-        if self._publishWithGuestAccess is not None:
-            result["publishWithGuestAccess"] = \
-                self._publishWithGuestAccess
-        if self._sign is not None:
-            result["sign"] = \
-                self._sign
-        if self._sourceArtifact:
-            result["sourceArtifact"] = \
-                self._sourceArtifact.toDict() if self._sourceArtifact is not None else None
-        if self._targetArtifact:
-            result["targetArtifact"] = \
-                self._targetArtifact.toDict() if self._targetArtifact is not None else None
+        if self._cpuCores is not None:
+            result["cpuCores"] = \
+                self._cpuCores
+        if self._description is not None:
+            result["description"] = \
+                self._description
+        if self._gpuMemory is not None:
+            result["gpuMemory"] = \
+                self._gpuMemory
+        if self._gpus is not None:
+            result["gpus"] = \
+                self._gpus
+        if self._machineType is not None:
+            result["machineType"] = \
+                self._machineType
+        if self._systemMemory is not None:
+            result["systemMemory"] = \
+                self._systemMemory
+        if self._type is not None:
+            result["type"] = \
+                self._type
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._sourceArtifact is not None): self._sourceArtifact.isValid()
-        if (self._targetArtifact is not None): self._targetArtifact.isValid()
+        if self._machineType is None:
+            raise ValueError(
+                "ClusterInstance.machineType doesnt match requirement:" 
+                "required: True"
+            )
+        if self._description is None:
+            raise ValueError(
+                "ClusterInstance.description doesnt match requirement:" 
+                "required: True"
+            )
+        if self._cpuCores is None:
+            raise ValueError(
+                "ClusterInstance.cpuCores doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._cpuCores is not None
+            and
+            self._cpuCores < 1):
+            raise ValueError(
+                "ClusterInstance.cpuCores: " + str(self._cpuCores) + 
+                " doesnt match requirement: minimum: 1")
+        if (self._cpuCores is not None
+            and
+            self._cpuCores > 240):
+            raise ValueError(
+                "ClusterInstance.cpuCores: " + str(self._cpuCores) + 
+                " doesnt match requirement: maximum: 240")
+        if self._gpus is None:
+            raise ValueError(
+                "ClusterInstance.gpus doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._gpus is not None
+            and
+            self._gpus < 0):
+            raise ValueError(
+                "ClusterInstance.gpus: " + str(self._gpus) + 
+                " doesnt match requirement: minimum: 0")
+        if (self._gpus is not None
+            and
+            self._gpus > 16):
+            raise ValueError(
+                "ClusterInstance.gpus: " + str(self._gpus) + 
+                " doesnt match requirement: maximum: 16")
+        if self._gpuMemory is None:
+            raise ValueError(
+                "ClusterInstance.gpuMemory doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._gpuMemory is not None
+            and
+            self._gpuMemory < 1024):
+            raise ValueError(
+                "ClusterInstance.gpuMemory: " + str(self._gpuMemory) + 
+                " doesnt match requirement: minimum: 1024")
+        if (self._gpuMemory is not None
+            and
+            self._gpuMemory > 1474560):
+            raise ValueError(
+                "ClusterInstance.gpuMemory: " + str(self._gpuMemory) + 
+                " doesnt match requirement: maximum: 1474560")
+        if self._systemMemory is None:
+            raise ValueError(
+                "ClusterInstance.systemMemory doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._systemMemory is not None
+            and
+            self._systemMemory < 1024):
+            raise ValueError(
+                "ClusterInstance.systemMemory: " + str(self._systemMemory) + 
+                " doesnt match requirement: minimum: 1024")
+        if (self._systemMemory is not None
+            and
+            self._systemMemory > 1474560):
+            raise ValueError(
+                "ClusterInstance.systemMemory: " + str(self._systemMemory) + 
+                " doesnt match requirement: maximum: 1474560")
         return True
```

## Comparing `ngccli/data/pym/ClusterComponentModifyParams.py` & `basecommand/data/pym/ClusterInfo.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,178 +6,223 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .Env import Env
+from .ClusterTelemetry import ClusterTelemetry
+from .ClusterParams import ClusterParams
+from .ClusterTypeEnum import ClusterTypeEnum
+from .ClusterRequestStatus import ClusterRequestStatus
+from .ClusterURLs import ClusterURLs
+from .ClusterInstanceInfo import ClusterInstanceInfo
 
 # Unused import over optimization prevention
-str(repr(Env))
+str(repr(ClusterURLs))
+str(repr(ClusterParams))
+str(repr(ClusterTelemetry))
+str(repr(ClusterRequestStatus))
+str(repr(ClusterTypeEnum))
+str(repr(ClusterInstanceInfo))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ClusterComponentModifyParams(object):
-    """Common modification parameters for scheduler and worker"""
+class ClusterInfo(object):
+    """Cluster Information"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.dashboardAddress = (
+        self.URLs = (
             None if not fromDict or propDict.get(
-                "dashboardAddress"
+                "URLs"
             ) is None
-            else propDict["dashboardAddress"])
-        self.envVariables = (
+            else propDict["URLs"])
+        self.clusterInstances = (
             None if not fromDict or propDict.get(
-                "envVariables"
+                "clusterInstances"
             ) is None
-            else [ Env(i)
-            for i in propDict["envVariables"] ])
-        self.gpuReserved = (
+            else [ ClusterInstanceInfo(i)
+            for i in propDict["clusterInstances"] ])
+        self.clusterStatus = (
             None if not fromDict or propDict.get(
-                "gpuReserved"
+                "clusterStatus"
             ) is None
-            else propDict["gpuReserved"])
-        self.instanceType = (
+            else propDict["clusterStatus"])
+        self.clusterType = (
             None if not fromDict or propDict.get(
-                "instanceType"
+                "clusterType"
             ) is None
-            else propDict["instanceType"])
-        self.startupScript = (
+            else propDict["clusterType"])
+        self.params = (
             None if not fromDict or propDict.get(
-                "startupScript"
+                "params"
             ) is None
-            else propDict["startupScript"])
+            else propDict["params"])
+        self.telemetry = (
+            None if not fromDict or propDict.get(
+                "telemetry"
+            ) is None
+            else propDict["telemetry"])
 
     @property
-    def dashboardAddress(self):
-        """str: Dashboard address"""
-        return self._dashboardAddress
-
-    @dashboardAddress.setter
-    def dashboardAddress(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._dashboardAddress = value
+    def URLs(self):
+        """ClusterURLs: Cluster URLs"""
+        return self._URLs
+
+    @URLs.setter
+    def URLs(self, value):
+        if value is not None and not isinstance(value, ClusterURLs):
+            value = ClusterURLs(value)
+        if (value is None) or isinstance(value, ClusterURLs):
+            self._URLs = value
         else:
             raise TypeError(
-                'Property "dashboardAddress" of type "list<str>" set to wrong'
-                ' type'
+                'Property "URLs" of type "list<ClusterURLs>" set to wrong typ'
+                'e'
             )
 
     @property
-    def envVariables(self):
-        """list: List of all environment variables to prefix the scheduler or 
-        worker command"""
-        return self._envVariables
+    def clusterInstances(self):
+        """list: List of Cluster Instances"""
+        return self._clusterInstances
 
-    @envVariables.setter
-    def envVariables(self, value):
+    @clusterInstances.setter
+    def clusterInstances(self, value):
         if value is not None and not isinstance(value, list):
             value = list(value)
         if (value is None) or isinstance(value, list):
-            self._envVariables = value
+            self._clusterInstances = value
         else:
             raise TypeError(
-                'Property "envVariables" of type "list<Env>" set to wrong typ'
-                'e'
+                'Property "clusterInstances" of type "list<ClusterInstanceInf'
+                'o>" set to wrong type'
             )
 
     @property
-    def gpuReserved(self):
-        """int: Number of GPU reserved"""
-        return self._gpuReserved
-
-    @gpuReserved.setter
-    def gpuReserved(self, value):
-        if value is not None and not isinstance(value, int):
-            value = int(value)
-        if (value is None) or isinstance(value, int):
-            self._gpuReserved = value
+    def clusterStatus(self):
+        """ClusterRequestStatus: Cluster Request status"""
+        return self._clusterStatus
+
+    @clusterStatus.setter
+    def clusterStatus(self, value):
+        if value is not None and not isinstance(value, ClusterRequestStatus):
+            value = ClusterRequestStatus(value)
+        if (value is None) or isinstance(value, ClusterRequestStatus):
+            self._clusterStatus = value
         else:
             raise TypeError(
-                'Property "gpuReserved" of type "list<int>" set to wrong type'
+                'Property "clusterStatus" of type "list<ClusterRequestStatus>'
+                '" set to wrong type'
             )
 
     @property
-    def instanceType(self):
-        """str: Instance type"""
-        return self._instanceType
+    def clusterType(self):
+        """ClusterTypeEnum: All supported cluster types"""
+        return self._clusterType
+
+    @clusterType.setter
+    def clusterType(self, value):
+        if (value is None) or isinstance(value, str) or isinstance(value, unicode):
+            self._clusterType = value
+        else:
+            raise TypeError(
+                'Property "clusterType" of type "list<ClusterTypeEnum>" set t'
+                'o wrong type'
+            )
 
-    @instanceType.setter
-    def instanceType(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._instanceType = value
+    @property
+    def params(self):
+        """ClusterParams: Cluster params"""
+        return self._params
+
+    @params.setter
+    def params(self, value):
+        if value is not None and not isinstance(value, ClusterParams):
+            value = ClusterParams(value)
+        if (value is None) or isinstance(value, ClusterParams):
+            self._params = value
         else:
             raise TypeError(
-                'Property "instanceType" of type "list<str>" set to wrong typ'
-                'e'
+                'Property "params" of type "list<ClusterParams>" set to wrong'
+                ' type'
             )
 
     @property
-    def startupScript(self):
-        """str: Startup script"""
-        return self._startupScript
-
-    @startupScript.setter
-    def startupScript(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._startupScript = value
+    def telemetry(self):
+        """ClusterTelemetry: Cluster Telemetry"""
+        return self._telemetry
+
+    @telemetry.setter
+    def telemetry(self, value):
+        if value is not None and not isinstance(value, ClusterTelemetry):
+            value = ClusterTelemetry(value)
+        if (value is None) or isinstance(value, ClusterTelemetry):
+            self._telemetry = value
         else:
             raise TypeError(
-                'Property "startupScript" of type "list<str>" set to wrong ty'
-                'pe'
+                'Property "telemetry" of type "list<ClusterTelemetry>" set to'
+                ' wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._dashboardAddress is not None:
-            result["dashboardAddress"] = \
-                self._dashboardAddress
-        if self._envVariables:
-            result["envVariables"] = [
-                i.toDict() for i in self._envVariables 
-            ] if self._envVariables else []
-        if self._gpuReserved is not None:
-            result["gpuReserved"] = \
-                self._gpuReserved
-        if self._instanceType is not None:
-            result["instanceType"] = \
-                self._instanceType
-        if self._startupScript is not None:
-            result["startupScript"] = \
-                self._startupScript
+        if self._URLs:
+            result["URLs"] = \
+                self._URLs.toDict() if self._URLs is not None else None
+        if self._clusterInstances:
+            result["clusterInstances"] = [
+                i.toDict() for i in self._clusterInstances 
+            ] if self._clusterInstances else []
+        if self._clusterStatus:
+            result["clusterStatus"] = \
+                self._clusterStatus.toDict() if self._clusterStatus is not None else None
+        if self._clusterType is not None:
+            result["clusterType"] = \
+                self._clusterType
+        if self._params:
+            result["params"] = \
+                self._params.toDict() if self._params is not None else None
+        if self._telemetry:
+            result["telemetry"] = \
+                self._telemetry.toDict() if self._telemetry is not None else None
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._instanceType is not None
-            and
-            len(self._instanceType) < 1):
+        if self._clusterStatus is None:
             raise ValueError(
-                "ClusterComponentModifyParams.instanceType: " + str(self._instanceType) + 
-                " doesnt match requirement: minLength: 1")
-        if (self._gpuReserved is not None
-            and
-            self._gpuReserved < 0):
+                "ClusterInfo.clusterStatus doesnt match requirement:" 
+                "required: True"
+            )
+        if self._params is None:
             raise ValueError(
-                "ClusterComponentModifyParams.gpuReserved: " + str(self._gpuReserved) + 
-                " doesnt match requirement: minimum: 0")
-        if (self._envVariables is not None):
-            for obj in self._envVariables:
+                "ClusterInfo.params doesnt match requirement:" 
+                "required: True"
+            )
+        if self._URLs is None:
+            raise ValueError(
+                "ClusterInfo.URLs doesnt match requirement:" 
+                "required: True"
+            )
+        if self._telemetry is None:
+            raise ValueError(
+                "ClusterInfo.telemetry doesnt match requirement:" 
+                "required: True"
+            )
+        if (self._clusterStatus is not None): self._clusterStatus.isValid()
+        if (self._params is not None): self._params.isValid()
+        if (self._URLs is not None): self._URLs.isValid()
+        if (self._telemetry is not None): self._telemetry.isValid()
+        if (self._clusterInstances is not None):
+            for obj in self._clusterInstances:
                 if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/pym/ClusterInfoResponse.py` & `ngcbpc/data/registry/BaseImagesDetailResponse.py`

 * *Files 25% similar despite different names*

```diff
@@ -6,96 +6,66 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .ClusterInfo import ClusterInfo
+from .BaseImageDetails import BaseImageDetails
 
 # Unused import over optimization prevention
-str(repr(ClusterInfo))
+str(repr(BaseImageDetails))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ClusterInfoResponse(object):
-    """Cluster Info Response"""
+class BaseImagesDetailResponse(object):
+    """Details of all base images"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.clusterInfo = (
+        self.baseImageDetails = (
             None if not fromDict or propDict.get(
-                "clusterInfo"
+                "baseImageDetails"
             ) is None
-            else propDict["clusterInfo"])
-        self.version = (
-            None if not fromDict or propDict.get(
-                "version"
-            ) is None
-            else propDict["version"])
+            else [ BaseImageDetails(i)
+            for i in propDict["baseImageDetails"] ])
 
     @property
-    def clusterInfo(self):
-        """ClusterInfo: Cluster Information"""
-        return self._clusterInfo
-
-    @clusterInfo.setter
-    def clusterInfo(self, value):
-        if value is not None and not isinstance(value, ClusterInfo):
-            value = ClusterInfo(value)
-        if (value is None) or isinstance(value, ClusterInfo):
-            self._clusterInfo = value
+    def baseImageDetails(self):
+        """ """
+        return self._baseImageDetails
+
+    @baseImageDetails.setter
+    def baseImageDetails(self, value):
+        if value is not None and not isinstance(value, list):
+            value = list(value)
+        if (value is None) or isinstance(value, list):
+            self._baseImageDetails = value
         else:
             raise TypeError(
-                'Property "clusterInfo" of type "list<ClusterInfo>" set to wr'
-                'ong type'
-            )
-
-    @property
-    def version(self):
-        """str: Payload version"""
-        return self._version
-
-    @version.setter
-    def version(self, value):
-        if value is not None and not isinstance(value, string_types):
-            value = repr(value)
-        if (value is None) or isinstance(value, string_types):
-            self._version = value
-        else:
-            raise TypeError(
-                'Property "version" of type "list<str>" set to wrong type'
+                'Property "baseImageDetails" of type "list<BaseImageDetails>"'
+                ' set to wrong type'
             )
 
     def toDict(self):
         result = {}
-        if self._clusterInfo:
-            result["clusterInfo"] = \
-                self._clusterInfo.toDict() if self._clusterInfo is not None else None
-        if self._version is not None:
-            result["version"] = \
-                self._version
+        if self._baseImageDetails:
+            result["baseImageDetails"] = [
+                i.toDict() for i in self._baseImageDetails 
+            ] if self._baseImageDetails else []
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if self._version is None:
-            raise ValueError(
-                "ClusterInfoResponse.version doesnt match requirement:" 
-                "required: True"
-            )
-        if self._clusterInfo is None:
-            raise ValueError(
-                "ClusterInfoResponse.clusterInfo doesnt match requirement:" 
-                "required: True"
-            )
-        if (self._clusterInfo is not None): self._clusterInfo.isValid()
+        if (self._baseImageDetails is not None):
+            for obj in self._baseImageDetails:
+                if (obj is not None): obj.isValid()
         return True
```

## Comparing `ngccli/data/pym/DataInput.py` & `basecommand/data/pym/DataInput.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -10,16 +10,16 @@
 import sys
 import re
 from six import string_types
 from .Dataset import Dataset
 from .Workspace import Workspace
 
 # Unused import over optimization prevention
-str(repr(Dataset))
 str(repr(Workspace))
+str(repr(Dataset))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
 class DataInput(object):
```

## Comparing `ngccli/data/subscription_management_service/ListSubscriptionRequestsResponse.py` & `ngcbpc/data/uis/NvcfCluster.py`

 * *Files 26% similar despite different names*

```diff
@@ -6,122 +6,157 @@
 </auto-generated>
 ------------------------------------------------------------------------------
 """
 import json
 import sys
 import re
 from six import string_types
-from .SubscriptionRequest import SubscriptionRequest
-from .RequestStatus import RequestStatus
-from .PaginationInfo import PaginationInfo
 
 # Unused import over optimization prevention
-str(repr(PaginationInfo))
-str(repr(RequestStatus))
-str(repr(SubscriptionRequest))
 
 
 if sys.version_info > (3,):
     long = int
     unicode = str
 
-class ListSubscriptionRequestsResponse(object):
-    """Response for list subscriptions requests API"""
+class NvcfCluster(object):
+    """Information about the NVCF Clusters for an organization"""
     def __init__(self, propDict=None):
         fromDict = propDict is not None and isinstance(propDict, dict)
-        self.paginationInfo = (
+        self.cluster = (
             None if not fromDict or propDict.get(
-                "paginationInfo"
+                "cluster"
             ) is None
-            else propDict["paginationInfo"])
-        self.requestStatus = (
+            else propDict["cluster"])
+        self.currentInstances = (
             None if not fromDict or propDict.get(
-                "requestStatus"
+                "currentInstances"
             ) is None
-            else propDict["requestStatus"])
-        self.subscriptionRequests = (
+            else propDict["currentInstances"])
+        self.gpuType = (
             None if not fromDict or propDict.get(
-                "subscriptionRequests"
+                "gpuType"
             ) is None
-            else [ SubscriptionRequest(i)
-            for i in propDict["subscriptionRequests"] ])
+            else propDict["gpuType"])
+        self.instanceType = (
+            None if not fromDict or propDict.get(
+                "instanceType"
+            ) is None
+            else propDict["instanceType"])
+        self.maxInstances = (
+            None if not fromDict or propDict.get(
+                "maxInstances"
+            ) is None
+            else propDict["maxInstances"])
+
+    @property
+    def cluster(self):
+        """ """
+        return self._cluster
+
+    @cluster.setter
+    def cluster(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._cluster = value
+        else:
+            raise TypeError(
+                'Property "cluster" of type "list<str>" set to wrong type'
+            )
+
+    @property
+    def currentInstances(self):
+        """ """
+        return self._currentInstances
+
+    @currentInstances.setter
+    def currentInstances(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._currentInstances = value
+        else:
+            raise TypeError(
+                'Property "currentInstances" of type "list<int>" set to wrong'
+                ' type'
+            )
 
     @property
-    def paginationInfo(self):
-        """PaginationInfo: object that describes the pagination information"""
-        return self._paginationInfo
-
-    @paginationInfo.setter
-    def paginationInfo(self, value):
-        if value is not None and not isinstance(value, PaginationInfo):
-            value = PaginationInfo(value)
-        if (value is None) or isinstance(value, PaginationInfo):
-            self._paginationInfo = value
+    def gpuType(self):
+        """ """
+        return self._gpuType
+
+    @gpuType.setter
+    def gpuType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._gpuType = value
         else:
             raise TypeError(
-                'Property "paginationInfo" of type "list<PaginationInfo>" set'
-                ' to wrong type'
+                'Property "gpuType" of type "list<str>" set to wrong type'
             )
 
     @property
-    def requestStatus(self):
+    def instanceType(self):
         """ """
-        return self._requestStatus
+        return self._instanceType
 
-    @requestStatus.setter
-    def requestStatus(self, value):
-        if value is not None and not isinstance(value, RequestStatus):
-            value = RequestStatus(value)
-        if (value is None) or isinstance(value, RequestStatus):
-            self._requestStatus = value
+    @instanceType.setter
+    def instanceType(self, value):
+        if value is not None and not isinstance(value, string_types):
+            value = repr(value)
+        if (value is None) or isinstance(value, string_types):
+            self._instanceType = value
         else:
             raise TypeError(
-                'Property "requestStatus" of type "list<RequestStatus>" set t'
-                'o wrong type'
+                'Property "instanceType" of type "list<str>" set to wrong typ'
+                'e'
             )
 
     @property
-    def subscriptionRequests(self):
+    def maxInstances(self):
         """ """
-        return self._subscriptionRequests
+        return self._maxInstances
 
-    @subscriptionRequests.setter
-    def subscriptionRequests(self, value):
-        if value is not None and not isinstance(value, list):
-            value = list(value)
-        if (value is None) or isinstance(value, list):
-            self._subscriptionRequests = value
+    @maxInstances.setter
+    def maxInstances(self, value):
+        if value is not None and not isinstance(value, int):
+            value = int(value)
+        if (value is None) or isinstance(value, int):
+            self._maxInstances = value
         else:
             raise TypeError(
-                'Property "subscriptionRequests" of type "list<SubscriptionRe'
-                'quest>" set to wrong type'
+                'Property "maxInstances" of type "list<int>" set to wrong typ'
+                'e'
             )
 
     def toDict(self):
         result = {}
-        if self._paginationInfo:
-            result["paginationInfo"] = \
-                self._paginationInfo.toDict() if self._paginationInfo is not None else None
-        if self._requestStatus:
-            result["requestStatus"] = \
-                self._requestStatus.toDict() if self._requestStatus is not None else None
-        if self._subscriptionRequests:
-            result["subscriptionRequests"] = [
-                i.toDict() for i in self._subscriptionRequests 
-            ] if self._subscriptionRequests else []
+        if self._cluster is not None:
+            result["cluster"] = \
+                self._cluster
+        if self._currentInstances is not None:
+            result["currentInstances"] = \
+                self._currentInstances
+        if self._gpuType is not None:
+            result["gpuType"] = \
+                self._gpuType
+        if self._instanceType is not None:
+            result["instanceType"] = \
+                self._instanceType
+        if self._maxInstances is not None:
+            result["maxInstances"] = \
+                self._maxInstances
         return result
 
     def toJSON(self, pretty=False):
         if pretty:
             return json.dumps(self.toDict(), sort_keys=True, indent=4)
         else:
             return json.dumps(self.toDict(), sort_keys=True)
 
     def isValid(self):
-        if (self._subscriptionRequests is not None):
-            for obj in self._subscriptionRequests:
-                if (obj is not None): obj.isValid()
-        if (self._paginationInfo is not None): self._paginationInfo.isValid()
-        if (self._requestStatus is not None): self._requestStatus.isValid()
         return True
```

## Comparing `ngcsdk-3.41.4.dist-info/RECORD` & `ngcsdk-3.42.0.dist-info/RECORD`

 * *Files 24% similar despite different names*

```diff
@@ -1,64 +1,113 @@
 basecommand/api/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-basecommand/api/aces.py,sha256=6mhICxLEfPH4W8KUgc8taeVPUsmWYmz4Oam3-pqfUGg,5054
+basecommand/api/aces.py,sha256=hZiyeOMLR-dg3g9yIRe4wHmgDpvDAwUvb2XKepYaXjw,5054
 basecommand/api/basecommand.py,sha256=VdGGJ7VMJrP1YR_vrpmAGd_iuXGV4WHY348XZtFqsy8,3013
 basecommand/api/datamover.py,sha256=N5q822OuyxVRyiPsWokA0zr4vMWjfOYLNTSL4sjqBeI,17648
-basecommand/api/dataset.py,sha256=0ndQRfN66YJeO2ckRm1knTTSWqSVRkqrYxid7ZgeSis,37715
+basecommand/api/dataset.py,sha256=kscGOHf0OyA3yC-GcAd0gNShmXSDI3EykeCSgB9hdTo,37721
 basecommand/api/dockerwrappers.py,sha256=iowN3lm763lC69YxahAe_QT32dumDsiBErLX7Po3cu0,10766
-basecommand/api/jobs.py,sha256=cRBNvmkF0DuIEU1vCBBR7gKHQvHZq4P1461jOsY-jZ8,35840
+basecommand/api/jobs.py,sha256=mcs9RQia65vBHCrXiukowVnWQ4qJ1uzuHM_8pt8nN-U,35840
 basecommand/api/kubewrappers.py,sha256=UGJU9ok6ChbRRQDCOpWEdm5fYkzE5qBAUdp31ouUgG8,3348
-basecommand/api/measurements.py,sha256=zxJv3V2SrmouxaqIA90RSPeuEwFW7M1SN1lmrfjl_wc,6847
+basecommand/api/measurements.py,sha256=Ee0Nj9EruCwtwpabrMoneKZGCM-DMDicBZG4p6by6mg,6847
 basecommand/api/quickstart.py,sha256=-E1zkvNm9_GiZkUOU2H9AFmX9XOSwZ49db1y4U16vBs,1902
-basecommand/api/quickstart_cluster.py,sha256=1kEMusRi3gayvcMzhEoPBzNrOoq0-fMEOi4EEachHUM,36723
-basecommand/api/quickstart_project.py,sha256=q2XqC6x_w4vGSuihyEZEReJQUvwWSJMqMGJNEUzbeMQ,21025
-basecommand/api/resource.py,sha256=QRyn7gt-uZ1UinhkFJx6Tuivxj8R2nFIxX16m3BCUcs,21946
-basecommand/api/resultset.py,sha256=jIXP3RGoIfw01ztILW4NAjE3_NTuWOFgGGnD5jayvzc,14101
-basecommand/api/search.py,sha256=v5TT8pfqFmMK6NJkFXtgrp98Owt-jkU4qbWiFi9fdJY,3845
-basecommand/api/utils.py,sha256=1ZSPYDIGApPw9UyPXuWzdiT26eOor2VlP8lEbN0fQ_o,11345
-basecommand/api/workspace.py,sha256=ZGgVmjXTY14epOwTbu2NGVwc1yyhROjWNC_k7zk_nTE,29537
+basecommand/api/quickstart_cluster.py,sha256=sHAANO9VicUipRFZfGheD5RwvictEgf-VZT-S9qPBlQ,36782
+basecommand/api/quickstart_project.py,sha256=wDC0v7xDz3IhmcOXnx5QKTe1E6ZWUGqwfG3P1y5kQkI,21034
+basecommand/api/resource.py,sha256=leAoqcuo85YnOlnkuOIAXB6kB0tFfjftG-JbFrpfvRI,21946
+basecommand/api/resultset.py,sha256=PbL0YoUoSwaXiCsaBbXdj1c1Klf4pguRJ5d5mj15FdI,14101
+basecommand/api/search.py,sha256=qVUVyEsWUWuGcGCzdXjRbdWQOtuqiad_C7OCkpcWao4,3845
+basecommand/api/utils.py,sha256=xkWJuKKWRkVtk0-q3aQQR4ofn0K0EJxkDFqErKDAvBM,11345
+basecommand/api/workspace.py,sha256=F4AAdHkppK-1cq4JbxzQVQPLuQQsZu_83rCFDQ2HFgs,29665
 basecommand/command/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 basecommand/command/aces.py,sha256=akQl3MXtj_fgZ0ixD5pBGADWngORbigEcIa20oQWKMk,4173
 basecommand/command/all_commands.py,sha256=-UMqbJKA-Kzq5PAy72RMBk4WJy-knhFL1z8A4HY4ZZY,1318
-basecommand/command/args_validation.py,sha256=Iq41JTRRkfgCMMBnGg5zheGIR0NndWAKnEDJK9DqcY8,16025
+basecommand/command/args_validation.py,sha256=gig247zIAxdD3jOFtvuR09X6KaWDkmWuc-jo0mxM1ek,16025
 basecommand/command/base_command.py,sha256=yo94t3q9yIbyR6EkT3ClV1jOqrmzjBevaJ7EQ8FtdjE,680
-basecommand/command/batch.py,sha256=2nVLLip46kT21LNlIsFkMvEWwksEKau3TeEHl79fC24,51055
+basecommand/command/batch.py,sha256=l7cLb_5I3SDRf10Y0547VWpOckFWg-I9DbZqxcTo26U,51055
 basecommand/command/completers.py,sha256=kjOvcghHh-SP-75J0wkmbdQ8hvMr8gyOGiYb3ZaaYJU,1786
-basecommand/command/data.py,sha256=Vi3i0eCdCfmidI77iPUL08PvO_nmvaR3xBILn3Xo2n0,16949
+basecommand/command/data.py,sha256=0hXThCgYiAGbLYJKMUJIdHib_OmMXHHxU9dp4iBxlxo,16949
 basecommand/command/datamover/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 basecommand/command/datamover/export_dataset.py,sha256=CxEVB6DaJSdRB8o-7wFjO02BbDtZnYw5rgCtc_b98H4,8911
 basecommand/command/datamover/export_workspace.py,sha256=e4DWVTc-A2eR5ZaD6yE1OpZvobEW15lWScGkqW9ehWY,8976
 basecommand/command/datamover/import_dataset.py,sha256=mlPixDp6GGXrOj71ftafvQrPOkHM31LXl6oMUIEwffg,11086
 basecommand/command/datamover/import_workspace.py,sha256=8xb53ltWxvmBUf-1ucs50oZzl2hmEwzmSrU3b6yTRuI,10720
-basecommand/command/datamover/utils.py,sha256=HVRhCP-SFvh-3JYRIGwrgkvtzym5qxAJxxWK5C3X75s,22299
+basecommand/command/datamover/utils.py,sha256=aulKT4sWgc8052kF_z9YJZCL8yEu3STuvtplgQ0OdUE,22299
 basecommand/command/datamover_command.py,sha256=SIJVsEi5v6D_wjX5prGEkd60sPuC4EQkkQNqOWQj_IY,21705
 basecommand/command/quickstart.py,sha256=RjODnZ0N-_M8ZH7i2gG63GJLzs2InGx4xwg1EJs2tGE,1127
-basecommand/command/quickstart_cluster.py,sha256=Qvsr84_BBxCF-iyrn7Bf445vSf5ee0lNOz5QMEcI8JA,30285
-basecommand/command/quickstart_project.py,sha256=Svg0fQTyG7oH8Ibg4RUYPVe_znHJXZWM24IpDF3OpPs,44566
-basecommand/command/resource.py,sha256=2UNRpSHufCcgdhDd-ZT15D_MONYcqmj8GotmaqboSpI,11402
-basecommand/command/result.py,sha256=OtD-9n_j7IL9W4HdZHvkqjkQqwoeydekO6uU2Ru5Y3s,7684
+basecommand/command/quickstart_cluster.py,sha256=all8Y4jw6YPDmP66kWwXyz3h16ZnTNrUGGJnisKFGRg,30309
+basecommand/command/quickstart_project.py,sha256=bUaPAm5TWcJ7XQ8HKbxPLDktc0KOC6750DEUyrAEb9A,44630
+basecommand/command/resource.py,sha256=xVhrEn-mUZRWcbHdtd5K7xE6XW_sqf5f0w2hOd0iWnw,11402
+basecommand/command/result.py,sha256=2uBF4ChPgCDRRs_BIq3G1_iYDiY34B3Pba9mSXZWRE8,7684
 basecommand/command/workspace.py,sha256=xCLBZYU9Sn6u8fY3bZwyNNIc-iKNf64qBzHxvCppb5I,21896
 basecommand/constants.py,sha256=GmpXm0Oi8ugq20s-WFQmbnGzoDG6r614XyP2RQ5z-Vo,3864
+basecommand/data/pym/AdditionalOpenPortURLs.py,sha256=fav2pRiuuIHKxxMCjotOx4p-P_7EZldBYM5GHqIpKoo,3174
+basecommand/data/pym/ClusterComponent.py,sha256=cIAXMQInpCAREo1dsUvKsnElWmC3CQSes_cwDCtZvG4,3633
+basecommand/data/pym/ClusterComponentModifyParams.py,sha256=TBXyNGfmTBjTxlfpC4S3zZmMzIz9Dj1grYyaidUs0JI,6010
+basecommand/data/pym/ClusterComponentParams.py,sha256=yXSsUG8cmMD5SitHBqKHxj6LYjfzJoK8v1HIoYgCKlk,6742
+basecommand/data/pym/ClusterCreateRequest.py,sha256=ZPX-ueilvY0nrHH4e6me5KMWPq3IeGr_gG0tyqnW4qg,3019
+basecommand/data/pym/ClusterInfo.py,sha256=o50e4vemdAc-f8JtFZkMixyURex4COEhOgqip-UYeKU,7701
+basecommand/data/pym/ClusterInfoResponse.py,sha256=UYf8frpLy5zc-zeBinXGXhhayw4hlOtKCzGZX9flQ9w,3089
+basecommand/data/pym/ClusterInstance.py,sha256=RSzJ7vryDor8tTIi8oORVZsU1QE6cA7UQk31F0iqGWc,9539
+basecommand/data/pym/ClusterInstanceInfo.py,sha256=i762VtO07il1pcLWr7WgPWAzMI-zTewalEnPqkyRDAs,3490
+basecommand/data/pym/ClusterInstanceTypesResponse.py,sha256=75G1gIMlTlkyMFDMDPy94GO9jQG8bxRWlGyiE8oXm88,3365
+basecommand/data/pym/ClusterListResponse.py,sha256=x3_xzXDcDBp2yE6G7Weem1VgP4Ym3Ss7jX4Jad7m2ZM,3149
+basecommand/data/pym/ClusterModifyParams.py,sha256=eRlJnqRKGDKEco7Wl69Enmqt5nPsWEDjhLd6ZIh0cP8,30037
+basecommand/data/pym/ClusterModifyRequest.py,sha256=DCwfbJCpb1oLInu_PZprRPifXICFLPYiY1wPj7ApEKI,3333
+basecommand/data/pym/ClusterParams.py,sha256=5gpOTDMpydgzfLyv7hasAzksBs2eqBOXKIgHblIBeu4,30984
+basecommand/data/pym/ClusterPortMapping.py,sha256=G8JkKDiYuGUlft_vLUYGh0qVTVP2TMBX-AhL_e7yY98,6221
+basecommand/data/pym/ClusterRequestStatus.py,sha256=sAnqWfVf5HFfi8WyMhr8ER4v1M6_jjZ4HeAgJPGp1Kw,12789
+basecommand/data/pym/ClusterStatusEnum.py,sha256=6w_HVEae6jn5mFHjHya1GM02Lk5nuH7FGg8Mr__tiZg,191
+basecommand/data/pym/ClusterSuccessResponse.py,sha256=qlD-Nd7usYkvrcpWz9HVmHM9Sy2_odsi-w0lGTh_ex4,3210
+basecommand/data/pym/ClusterTelemetry.py,sha256=OEZrSEZFxxSS7nmLVAFccwx20jVE0YtC5-SFvGOj-kQ,3048
+basecommand/data/pym/ClusterTypeEnum.py,sha256=ehd4L61cnZDGQ7-bRE6hSrPJUKqBV9hJaCfAPSumcnU,102
+basecommand/data/pym/ClusterURLs.py,sha256=osI0n4--piPn2RMOP9q2x-eRxZ9zQYnHhGUXTJZv6hQ,5293
+basecommand/data/pym/DataInput.py,sha256=Z_KkufMN9BVf3kdGmel1-qsE-i2pZ6ns8HHjexFQov8,3188
+basecommand/data/pym/Dataset.py,sha256=-XxRw_O-I-d7mxllOLIvPAkyaOa_gIIrUt7Ll1zHwJU,2982
+basecommand/data/pym/Env.py,sha256=8c5CRDwwkncFV9D6-2EJRNGWZaLzEOsGTUCM6hNNITw,2943
+basecommand/data/pym/HealthInfoItem.py,sha256=iXLqb3VLaemvDiaNnqpUawHeScXTeEHFp75DgjpsD78,4484
+basecommand/data/pym/HealthResponse.py,sha256=O_K748m65eLOp6YCBfol2dbmzkWW38_H2Bp8S3VSZAY,4004
+basecommand/data/pym/ProjectCreateRequest.py,sha256=HY0z6lwjk7-tordhm6CqcLmP6JimmEU1-8vJSWZv4ak,5276
+basecommand/data/pym/ProjectDetails.py,sha256=YxddnQn3pny2j6SbBBPdjf1sGYxevjjh2HiuM8OhvH8,7374
+basecommand/data/pym/ProjectInfoResponse.py,sha256=5Dnaj5i5bSbQUXS1Zc1HRunU15tP-cEC9mq12VHsWnE,4120
+basecommand/data/pym/ProjectListResponse.py,sha256=5MIvkzvEWdQxcPHobxSlJLgGNuQjj9h4RbUstbXi9Zg,3119
+basecommand/data/pym/ProjectModifyParams.py,sha256=7T4MF_M-dXr8OsIDYSns45RCTlzdrPKgntfVfTwugac,2976
+basecommand/data/pym/ProjectModifyRequest.py,sha256=PyATR1goWT2Wa34YgQTtgl9RwQcEYYSrzyvPHmM2VpU,3080
+basecommand/data/pym/ProjectParams.py,sha256=6k-YgqLkAVwdSg_hcAKyqhi4Z41h1lDo--tnyF7Bf18,3303
+basecommand/data/pym/ProjectRequestStatus.py,sha256=6yCMJ99YzH1cqiNEEicuoJiwq_uL12hHG04WqjKID_0,4714
+basecommand/data/pym/ProjectSuccessResponse.py,sha256=SJgOiHFWCDe3GJX1Eud4u4-HGB0_1RDvmW_Tbu68lDQ,3210
+basecommand/data/pym/ProjectTemplateCreateRequest.py,sha256=Txxy4MsvYjXqv_MqVLRijzRFZjE8FldHii5yNR_81po,3129
+basecommand/data/pym/ProjectTemplateInfoResponse.py,sha256=m7tghW5xFq_AW58jHZ7l25qWbj_T9oj5clfmKIy5x5A,5220
+basecommand/data/pym/ProjectTemplateListParams.py,sha256=TeeMmwIdxhy5tgaVZx1BX0ZxEzWNF_JNl50x5FUKX1c,8708
+basecommand/data/pym/ProjectTemplateListResponse.py,sha256=ZLObvbOENieaY8AqXAzrUuTSb98XBD4FuTWjAZV6ppo,3224
+basecommand/data/pym/ProjectTemplateModificationRequest.py,sha256=ECH4dY2JWqVSgS6R3d0R1_jk81-VQN4emAe9aC3i9wk,3223
+basecommand/data/pym/ProjectTemplateModifyParams.py,sha256=l2iq3VoHqK1Eppb5GuMqskGylEMppirhcc1fAGTB9_M,6830
+basecommand/data/pym/ProjectTemplateParams.py,sha256=LV5VkAx97lkn0sZGqqxgbAqGsxtvXQQNXoL9cRmylwY,7106
+basecommand/data/pym/ProjectTemplateParamsDeprecated.py,sha256=12iamYAikpEZDSVYmUc94PkasSjJIsbZnVwIAUEvJA8,17506
+basecommand/data/pym/ProjectTemplateRequestStatus.py,sha256=4EoKaXGhyBcRVfPEPRs9TGXyxUL13vNJJIQIl7gVb6M,2752
+basecommand/data/pym/ProjectTemplateSuccessResponse.py,sha256=7g-XddLcdD-IuMbWvFsE-lkMLe3jLrqxquS-T_6hDfM,3333
+basecommand/data/pym/SecretKeySpec.py,sha256=sx4TtaePGrif_2rHMMox4T4Ml_inytfE__T7R6W2VaM,3314
+basecommand/data/pym/SecretSpec.py,sha256=XZte7OZwv9uEkMF6e6P1OjAf7viF8MuhApdcM7MUWTg,4057
+basecommand/data/pym/Workspace.py,sha256=lyDA-dC30KJ39lWfzzlFp55rIqYxGCgjzQd377thx_E,4074
+basecommand/data/pym/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
 basecommand/environ.py,sha256=2oNsrks2nCH3Sp3PoPBWT_qheCEZbueR7E-Q7g8AigU,724
 basecommand/errors.py,sha256=fOPSw1x1pCy-sNT7Fc7Zci4PiGnRXoLMwTNsttvj8Uo,567
 basecommand/model/dataset.py,sha256=-sqRlXOg-RQWr2T7lcpWjOwfbMdmeLMRLVfUsDA3qys,1695
 basecommand/printer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 basecommand/printer/aces.py,sha256=ICN7tbVJTRVARhSA2wJPa2dR0t9lXusGonXLq0Pz1QA,10016
 basecommand/printer/batch.py,sha256=QokKMePtYAiRkFSF1bymbalhXQh7xhuLi4EpQglLUqM,29561
 basecommand/printer/datamover.py,sha256=pTa6MxeT4xkjTcTXQlCb5h-fYMbWICKgAJTqh1O0dLE,12360
 basecommand/printer/dataset.py,sha256=T_8zFXdVvZ0_AzopWV34hrcayDaEBzlmDGf9EsnfnOo,4500
 basecommand/printer/quickstart_cluster.py,sha256=nNGLtdFEahEy3jkoaYzkvDNh2lnygxKg545W6ly8txE,11250
 basecommand/printer/quickstart_project.py,sha256=3hCDrvKjETP_z-Iz0znUvaZDJYvhQKK7LcXvAWN9J78,8756
 basecommand/printer/resource.py,sha256=klHcWfeT0DbF1Lo2-4PjleXhwcUIQDWdEfgm9V0wix4,9465
 basecommand/printer/result.py,sha256=cU76zl5h_fOOXaaC64R1zkB9mwq26aepvhbmOI_FLe8,2334
 basecommand/printer/workspace.py,sha256=V5F7hovervlcVsXvYB-w1ol4QQ6n0Ta58AjbftxhgBE,4736
 basecommand/transfer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-basecommand/transfer/upload_manager.py,sha256=kzDvl5b55ozLZNw2Ie792KOLsNq5KHzWC0exSy2Fnww,22031
+basecommand/transfer/upload_manager.py,sha256=hMoZpbakp4tJVm763XpRPUWoLj0A780THnWlAiCBO5A,22031
 basecommand/transformer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-basecommand/transformer/dataset.py,sha256=L6NYJPT7PMA41GZMqIO2zCWRcald6OaAMzC-zVKb1qI,1055
-basecommand/transformer/workspace.py,sha256=U9urwBj2ZPACUUuC9ob1V0_2txEdMJggTBXGXEAby6M,1045
+basecommand/transformer/dataset.py,sha256=c46wKfdGCdI2DvlU6EP6JiH7zr0rXT2vCrB21h-_KK8,1055
+basecommand/transformer/workspace.py,sha256=sPzdqWY0KmvGzRQwdS77EW431CATq84-C7NCXhy-oR0,1045
 forge/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 forge/api/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 forge/api/allocation.py,sha256=LITuUi4Qf3afMWKNidK_HlIhVhfwZoQgCdeFQeGxjAs,8749
 forge/api/constraint.py,sha256=SjCqUp3a1TImmOaItz2wWgQvIFYWovM8yyYD4tDPagg,3769
 forge/api/forge.py,sha256=8bDPboUq8QTGshRotheBWsYp9wuFMBgLCHrQuJeEZnM,6931
 forge/api/infiniband.py,sha256=OvoTEImkkBnR3WwtedxIMrfhy6iSSMRehyVzKSPkYKY,4287
 forge/api/instance.py,sha256=8IrFxEqjAmF4bkrF2VAHwEPM_M3HBDAJsguhCd1pYAQ,5927
@@ -101,256 +150,256 @@
 forge/printer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 forge/printer/allocation.py,sha256=y1WEm5WNypVfDIlIGXXxljQ9Y4D8BhXRwXgf9Fq2QuA,6520
 forge/printer/constraint.py,sha256=a0VJbbjUJ6GneQLLJX6ml2lEwysD8oo0z4QNtVRhSrE,3765
 forge/printer/infiniband.py,sha256=COxsa2J_THlLkScnpb71bw9ZQVugBrZ6SzLXnJemSh4,6016
 forge/printer/instance.py,sha256=U31wMupPNiDNNR9xYjKTCU8qz-nl46-Q4IVGL1TARIw,14131
 forge/printer/instance_type.py,sha256=w_Ik4i8phOO4saNuo7C6kBJP9ooMEVH9tT6TG0Eh-8Y,9778
 forge/printer/ipblock.py,sha256=-yCMsiaQhtysRxr3gRPbjz64zUjdm_BSfPg9nwdlPJU,5774
-forge/printer/machine.py,sha256=QDNyTYDFRcY3azyOP_Cx3eNypRfvGWuK8UsB0a-RNFg,9515
+forge/printer/machine.py,sha256=Evh4VBirWvyrJipzETbOOSnBKZC-00o5m486JBmrR5I,9883
 forge/printer/operating_system.py,sha256=bGibs-39VDLQQOFRQgEfs14pxiusuOcXWcpC8O3f5sw,6805
 forge/printer/provider.py,sha256=3O5R6_a4z-AfObqHJ8rK662uHGJnfJ-fTgcCnbReAzI,4861
 forge/printer/rule.py,sha256=h6B9ctihLhaMEMNe9kcJqzbINyEMfBMeKM-6Rm087lk,7019
 forge/printer/site.py,sha256=awVS069bd4qV-FdFGg4ygf-wN1KHhpjYJOTqYjqFxe0,6497
 forge/printer/ssh_key.py,sha256=udFFvxXrB_H7dg1XNHLHHCEOzmlVGvt-bSVNSxkVYHU,4815
 forge/printer/ssh_key_group.py,sha256=MzBmo-S5ev66-baCG8XuSxSfyFLewzvyCzoriFKpQfw,9171
 forge/printer/subnet.py,sha256=w8dX-16OnKXuJFVqq46JISaM2xk7yiBDS2ey5ZQly3U,6169
 forge/printer/tenant.py,sha256=fLS1iTDHbajNTwH5CpH4fdxiEHdU-Xp-DaaCEq-Ob0c,4875
 forge/printer/tenant_account.py,sha256=HAbJPtsOu2HPEhMSA8NCCF_PW15VTko6bcnWim8KrC4,7009
 forge/printer/user.py,sha256=CNnn0Ck57cizgR5KNNHLRGjIxd1nrvkI5DCaa-_drC8,1965
 forge/printer/vpc.py,sha256=_g-Lwk8oqfiePGXfnOePHJwYhwlD3h6q1UxspVkQhoY,5023
 ngcbpc/api/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-ngcbpc/api/authentication.py,sha256=DNKPxJFydnVhIJ2i8de_xT6LCMM96bZB6x-DjzvQGH8,33141
+ngcbpc/api/authentication.py,sha256=LZCIm1pLEq6C98YvoSi-AkI7wM2gbq21WXwYEhiytmQ,33141
 ngcbpc/api/configuration.py,sha256=FZenIU6AFSwRxtVzMk7HEpMliHkexSEJz7AvG72ATyI,69915
 ngcbpc/api/connection.py,sha256=Id2NN3eTGeeeDwr116HeAUxJl1F7uQg1cPun84kMVfE,21459
 ngcbpc/api/pagination.py,sha256=dP7mlDdoBMzWqXxR4QoBBvEulmo4ISCRCiu9Hj6P0G8,8333
 ngcbpc/api/search.py,sha256=UxAccoXCNOY3GwPNIWW_6wP8GM6wGIkqKhs5ujeKrrQ,4129
 ngcbpc/api/utils.py,sha256=AsS79D7-LQE-97NO3jOpGbiCxoslPlzBtVbIfgEhrSE,7078
 ngcbpc/command/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 ngcbpc/command/args_validation.py,sha256=LlXvRIxaM3pQONHGNOCuMs3rrd-_WMOR3NXDq9yF0NE,13108
 ngcbpc/command/clicommand.py,sha256=QWTt_fsthzTcTwb2xdNEC5HdToLJLrE8nzu3_k5TcGc,14002
 ngcbpc/command/completers.py,sha256=hgzDW2_k7cy5WGuCylzHf7i1xUTpkAqm8ZWTusHHGIg,1540
 ngcbpc/command/config.py,sha256=czzlmG7fhDTWWmeOrGdxonmlMSk7PDPbSTng8BSbTnY,24492
 ngcbpc/command/global_args.py,sha256=6JiuB0jAbejJgfhkMUlz7nkQD6z9jnY3aCwxhg80Y2s,4150
 ngcbpc/command/parser.py,sha256=cQAoBJSTb66sbA1rk1ERyUiSIY1ZJjvKtq7Z3KC3xkM,9883
-ngcbpc/constants.py,sha256=7jJt3Jb_MY28CcUZhQq15_-A_SUkZHJDFUXoMzE_Iwc,12660
-ngcbpc/data/api/Ace.py,sha256=7_L6OZDcGVVVfwr-G5fnh9NMVKPgps742Tci0OT7pWI,29186
-ngcbpc/data/api/AceCreateRequest.py,sha256=PsEBf6uPLloeAAMnwLRlQmleHd-vWi3zw9jciUwCSxM,24775
+ngcbpc/constants.py,sha256=5mBn4skX98aER5LUfnkhjOl4DGNUy_fED4FCjS6JvjI,12815
+ngcbpc/data/api/Ace.py,sha256=3mQAFN-9G3KoXknPBtNyOU9ZSa0DX2fS93dk8AVsB74,29186
+ngcbpc/data/api/AceCreateRequest.py,sha256=eHj5kMSbKPxwpRBSx2SZhROyVMRLl0LuYP2ZRwBaZpw,24775
 ngcbpc/data/api/AceHealth.py,sha256=L_BLnEXdLMEhM6kqWmmmkzdyYHBkNbrNKm0gliNvj50,2612
 ngcbpc/data/api/AceInstance.py,sha256=T7IpfPXXxcylB63c9u7eb9zrqOXuRhFFJICoemcAMaQ,30841
 ngcbpc/data/api/AceInstancePrices.py,sha256=172x-QTWIewAKHt2vAt3l1oUtnUEQS5CGyWBsugIF1g,5090
 ngcbpc/data/api/AceInstancePricesResponse.py,sha256=XuF2QW9DaNUKdjmaowdxJmURuw3wVhMKGBSM_lGKmYo,3229
 ngcbpc/data/api/AceInstanceTypeEnum.py,sha256=IQaBtxI_neczo0AAKcAGT7P7ye4K3z2QTz3CWYQyT1M,108
-ngcbpc/data/api/AceListResponse.py,sha256=GDfy3FdxIl_3MG93HQPRDHlNz9ppeWv0YcEKSkJDeeA,4010
+ngcbpc/data/api/AceListResponse.py,sha256=vGba0LPd2gD8crXMGdj_7OIYDVKGIHnsi62JKaUosg0,4010
 ngcbpc/data/api/AceNodeRemapRequest.py,sha256=WCeC0QOfrQP_c-GDjS8ROzODxbZiX4xa45GCODWEczY,1979
 ngcbpc/data/api/AceProvider.py,sha256=pbuwIUrWi_tc8t8F_7R6SqKVx9ok5gvnABIkoZlPFmw,124
-ngcbpc/data/api/AceResponse.py,sha256=cFwpVsDV_4DwVkGfdlVbRBOSCuoW97vbPnIVB4OX17Y,2811
+ngcbpc/data/api/AceResponse.py,sha256=_pVeybmJz3yloKXel9pgkTq7SidVCDC3fLiYl5swo9c,2811
 ngcbpc/data/api/AceSimplified.py,sha256=I-G1NpA1nQjZUGr934Ag63qI4hbH126ZlvWF5Jz107Q,3191
 ngcbpc/data/api/AceStorageInfo.py,sha256=gB4zoQoOG7S2eQizwtuLXPSbn_jJoqwPoxDAQ49Ujkw,10624
 ngcbpc/data/api/AceType.py,sha256=i1DQ8qMst_g5KJG2hSJK2xSTnK8E-7-Z7oELgYD0Xj0,104
-ngcbpc/data/api/AceUpdate.py,sha256=ILn-fFACi2kVRSRqQO9oTA50g5h_Ux4LhuX2ARdal8o,26375
+ngcbpc/data/api/AceUpdate.py,sha256=ajYPDoZc-_Ge0WwQ2-X3KSHXvLByxCiP4AF-ggVKp_4,26375
 ngcbpc/data/api/AlertAggregationType.py,sha256=OllS-qf8zAI_ZmKyYs6V60Xbz4XoOV1Vh6K6dx2e7IQ,120
 ngcbpc/data/api/AlertDeliveryMode.py,sha256=zsmbi2KBJKBkqeB5pIo7bLP3gaiGlxSDQOa3AhJaJFk,5118
 ngcbpc/data/api/AlternateContact.py,sha256=nY2Jr3d80XPEhYkjSfnXzORO3eKrJrKjIiC7l13dWRM,3615
 ngcbpc/data/api/Analysis.py,sha256=HQRbATkCVOhSJvR78w11X7B31o1U-3JP1oueIy0npuU,4036
 ngcbpc/data/api/AuditLogs.py,sha256=GPUug9XW8h7Lr34gt1XJgCMV7a-20yLZVRj_bg3hJIw,9458
 ngcbpc/data/api/AuditLogsEventRequest.py,sha256=VuEeMXw-fx0nwFOyeaGaS7ZJIo9J_VJiaQjMDCoHdlM,8488
 ngcbpc/data/api/AuditLogsEventResponse.py,sha256=2WEG1p-qkcS2E6NbXJApvPAwa3Eyd5uKISEpdoClrPk,7632
 ngcbpc/data/api/AuditLogsPresignedUrlResponse.py,sha256=2zqvGa2sbaq1Q2DD-kpCR4MmCoZFvMtP2a7FuzIT6W0,2955
 ngcbpc/data/api/AuditLogsRequest.py,sha256=gz3izKgPoVI8Ql3KhdZg2nunYYKxJvACzVomDlO7Kgk,3025
-ngcbpc/data/api/AuditLogsResponse.py,sha256=MOh9OaXzRoFAUeV83mdfwGsQx8qE6IoWi2yt2He5BQA,3108
-ngcbpc/data/api/BannerEvent.py,sha256=2FhrYYpU65-5J5HmMae1ZL2sNlNp-X7CUAPOGS1bahw,4895
-ngcbpc/data/api/BannerEventCreateRequest.py,sha256=lCyvMeMxcUnJPqvHI-QZ70pdn9BG3KtMuUOde-7fGJU,7317
-ngcbpc/data/api/BannerEventCreateResponse.py,sha256=Miuql4HCAxh2imXZw76cqAmcEaoZHP7yDm9PQJeT7h4,12130
-ngcbpc/data/api/BannerEventIncident.py,sha256=9eDcbej9Pan6ErLkZXa5QuGX0hI49E2jkl6FGEzn30I,9626
+ngcbpc/data/api/AuditLogsResponse.py,sha256=c8u4TZfZcyyWjV-n-b1PcqvGZ7J7cBtUfOOUaofmBrA,3108
+ngcbpc/data/api/BannerEvent.py,sha256=LWnGpIpZ5vdBSvDxPcid7-zKswX2ELzSqYQ6i7_87zI,4895
+ngcbpc/data/api/BannerEventCreateRequest.py,sha256=EMIGB03i3hXtwa3ixTLRNAs2yYhc0S93vfgzB450gXU,7317
+ngcbpc/data/api/BannerEventCreateResponse.py,sha256=orTcbloTD709YX6tOG6KcVz-JHYVsbT9mg7XGt8bXWY,12130
+ngcbpc/data/api/BannerEventIncident.py,sha256=SJiON38Wqm5xzc_N9ZHnSFl3-cWtDVD0SqOQ-681D4c,9626
 ngcbpc/data/api/BannerEventIncidentMeta.py,sha256=Agbtk7jN4k9OEVO634OrYuaHd6DuxZFcuFxhlAjkKXY,8611
 ngcbpc/data/api/BannerEventIncidentSeverityEnum.py,sha256=qrzoAwUiVZgzVI3yNvQ3Gl43UwB4zJExx9zMVbcIuvs,232
 ngcbpc/data/api/BannerEventIncidentStatusEnum.py,sha256=FgYkaJKV2sZ1qgNI95W4Z-VwBHY_6R9aA6NCQr4xT2A,247
-ngcbpc/data/api/BannerEventListResponse.py,sha256=EzluR7I-W0DbISYjOVTT8K3xJqnMgesrhh5CI3po06o,3818
-ngcbpc/data/api/BannerEventResponse.py,sha256=aEsVgr2Sc_uYl92hpe2g5x-tF3_WXjqqJ8EzGBWDF_4,3707
+ngcbpc/data/api/BannerEventListResponse.py,sha256=Dc-GsjcAYTAZY9A1Sn39-nFFb5i1fZ8I6CLhyiFOCPk,3818
+ngcbpc/data/api/BannerEventResponse.py,sha256=DFcIa6jEYlTK8f3rcOJ05K0AstOwsq5gOoGutSWVP2s,3707
 ngcbpc/data/api/BannerEventTypeEnum.py,sha256=kGnKMsjgBYB-GveWqeN9XzuLmpAxDNo6kSPBZ7lyUv4,101
 ngcbpc/data/api/BannerEventUpdateRequest.py,sha256=G1D9XIaN0j1eVWfptTAbmUMOgvnq1zacboAf5DvJUbE,6022
-ngcbpc/data/api/BannerEventUpdateResponse.py,sha256=uuy_MX0uREnIBVU7sNMRkgtE9RAs_fLWnYjmotxiHP8,12125
+ngcbpc/data/api/BannerEventUpdateResponse.py,sha256=IRDNYfFg1ZY4xikeksOQtQNTzz0QyExYkyxtCOaQgEM,12125
 ngcbpc/data/api/BatchResourceTypeEnum.py,sha256=OKdqkFqSSPpqlKuNiiT2ocsOXKMLmBnStlRd5_9d6TM,128
 ngcbpc/data/api/CelestialErrorDetail.py,sha256=M79YXOnERatxwb5l--2L50HyrVjQDgijeU5DmTDAaDw,2483
 ngcbpc/data/api/CelestialFilters.py,sha256=rWKGamh_rgNxX0B1eg_TSgiKSR4LFbmMObOU843DJMU,1925
 ngcbpc/data/api/ConfigRequest.py,sha256=uRPNI8KuP35zTc0WAu8yooMaJnNUK_c5p_pAKizAZ3I,7598
 ngcbpc/data/api/ContainerResources.py,sha256=evKF-LD-tmZO4MSRWtSSjClI9rdK7cHi49fAIqkeRY8,2996
 ngcbpc/data/api/CreditsHistory.py,sha256=ILoLAYijWngc541LfANjOXurkc6PqHTZDkEqk0g1cFw,1755
 ngcbpc/data/api/CreditsHistoryResponse.py,sha256=tpKsTHF19-ylnIZWMJMuAJQYzAjksNvNANEUk2Dlrzs,3029
 ngcbpc/data/api/CurrencyCode.py,sha256=WJ-WUkIuZUc0YgBlbR8fna4hNLenpKkORGBXNZrT-r8,90
-ngcbpc/data/api/Dataset.py,sha256=6w_BoVnsv0mc4MVnIgClM36QbiTqDb1NdQAM-14KotQ,25858
+ngcbpc/data/api/Dataset.py,sha256=XY0sFvEoCxQ9WKdzmbJs3ad0hL2ZFOfJCW4QWICZtb8,25858
 ngcbpc/data/api/DatasetAddFilesRequest.py,sha256=WFpJriUT2mhDlfnGfTPxuc4OCRJ7E1EV3qMVoUYC0Vw,2267
 ngcbpc/data/api/DatasetCreateRequest.py,sha256=pcXXo__h25t8r5Rml3dS8SCwefQJX4Gy9QVB1CYPPd8,8227
 ngcbpc/data/api/DatasetFile.py,sha256=-8MdMJgzWBErAHDEhHktP7FtmOmS_D2AjUa4ZdIcQpo,6081
 ngcbpc/data/api/DatasetFileBatch.py,sha256=ZxBG9HfgcymgvVuQ1gfJai2amlFEifjdX9URaPniELc,1986
 ngcbpc/data/api/DatasetFileEventRequest.py,sha256=rpt1hbeLRR8f35KgeJcuxJA0NtE1C8g8nZo4RJO24k8,5944
 ngcbpc/data/api/DatasetFilePath.py,sha256=X_Ci0N7slTuPQoFRRa4qkLh-fN5Na_97oYEYLIoWmXU,2496
-ngcbpc/data/api/DatasetListResponse.py,sha256=A_ACPOLmm7aytFzllFMK3f8OoCZ_wcoOt5FRGSfLdcQ,5248
-ngcbpc/data/api/DatasetResponse.py,sha256=Qj1rLpohrOrIejzWoB6Y5YAWu-0XDj1j-ZDKT2aNEM0,5075
+ngcbpc/data/api/DatasetListResponse.py,sha256=8Gz5HxaEKmk0tztTOYPA5i3TeX4yV7jJ4aA0RXgmG6I,5248
+ngcbpc/data/api/DatasetResponse.py,sha256=uO8hFRx4kkIz7cqN_HwsN_v5CM7s2_8hsHkBC78PDRg,5075
 ngcbpc/data/api/DatasetSimplified.py,sha256=1JhBkpavvOi8-4Y52NshzPrmr0MvjD50Xug0q2BHB7k,20617
 ngcbpc/data/api/DatasetStatusEnum.py,sha256=d6PekqIdlUwic9K8wxwh8gfd9U0-NzzO2tXXqcUDRkg,121
 ngcbpc/data/api/DatasetUpdateRequest.py,sha256=Z1t3L112AOXvHCuQI2VehWP4Jyp1nu-Xm0ECHE6sOVc,7497
 ngcbpc/data/api/DeviceLoginRequest.py,sha256=T8_UBp6TUhpWZoY5-mwJlxoUTX6NLf_uL7hhwpaYv2k,3632
 ngcbpc/data/api/DeviceLoginResponse.py,sha256=mcHfQ01Y9i7YI4dRZ1v62JBcBPBRWa1pg39C4t5MhXI,4215
 ngcbpc/data/api/DownloadTokenMetadata.py,sha256=Wh4_AHRIwz6EJucuJXZJYzxFKl9ttPd1Aa1fMq54Krc,3313
-ngcbpc/data/api/EarlyAccessOrgCreateRequest.py,sha256=8Uzta_L3R1r9nT-OEsdryaCYbpm9k8n7lwaA3VL8xag,6748
+ngcbpc/data/api/EarlyAccessOrgCreateRequest.py,sha256=ek65cGj6N-cqCqFXkyh6YIRI8WGFKwAYi3OCbU5_MhE,6748
 ngcbpc/data/api/Entitlement.py,sha256=dZlBsSU9gziwFazybgdgnSUakuUCcIv_T4rGChVAj64,5681
 ngcbpc/data/api/EntitlementProduct.py,sha256=J0RYMd9PxDVmR8rw36zQnjr-J7lbdbCht21aJ3oOyq4,3397
 ngcbpc/data/api/Env.py,sha256=8c5CRDwwkncFV9D6-2EJRNGWZaLzEOsGTUCM6hNNITw,2943
 ngcbpc/data/api/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
 ngcbpc/data/api/Eula.py,sha256=7lxWNA1ZDnvnSkA3rSv8A9vc9jMOB5vVGjEmGBeM8mo,2964
-ngcbpc/data/api/EulaSubmitResponse.py,sha256=1XkyvAB0UoRYPRQXEndqPhL0rW9H-8qPijyFN0abqYI,2753
+ngcbpc/data/api/EulaSubmitResponse.py,sha256=-ivI_ssr7qNTVV_ITJNDTgEC8tuY3u8mCHh6uqNnhiY,2753
 ngcbpc/data/api/ExpTrackingParams.py,sha256=i6-5JEUM8jRAk180qE0LPe0bVTzN-8W5DO465UUNDHA,3846
 ngcbpc/data/api/FcOnboardingEventRequest.py,sha256=4mWPLmER8hiWrJpxdvzTaMxauMuOFzl6hZ3s8_-hF7c,1892
-ngcbpc/data/api/GetRepositoryTagVexResponse.py,sha256=DGFXM8v0rLH0mXacbfCo4u-u-v5-R86Y8otxCuxnZDU,3753
+ngcbpc/data/api/GetRepositoryTagVexResponse.py,sha256=3PXZf7ulakADHhAWYhl96-_E4PlOR2s4LB4SRjE3cIg,3753
 ngcbpc/data/api/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
-ngcbpc/data/api/HealthResponse.py,sha256=GK5fZtgZh5pR2KnFcxF5pw1JsEEp930ubmCGjWJ-7Xk,3013
+ngcbpc/data/api/HealthResponse.py,sha256=5mdmVDD67RhFOoeFHF1YIYKkSsxcyrf4fFFI0m-YwNk,3013
 ngcbpc/data/api/HttpGet.py,sha256=q-CPnFPEdKQmjctAeaW6BvFmvOcn_zC2KiFsvXjo9l4,2410
 ngcbpc/data/api/IPAddress.py,sha256=khL2G0Lz9lTodtXjfHXGsFoEcKSxOrl5k3ZJcgKN6e4,2323
 ngcbpc/data/api/InfinityManagerSettings.py,sha256=XmueItuc_fmVJwtszl3jWzIOay-v9rixOhsgUyWpe3k,3099
-ngcbpc/data/api/Job.py,sha256=Lyvdmw3FU02l6r4l3xkhn4Ee9DGw8zs3-AMXFYxjQHI,35355
+ngcbpc/data/api/Job.py,sha256=GCwM6uQ_56-EXgRBUKdx2GGpaEH2--m5o-sG8XUVnlI,35355
 ngcbpc/data/api/JobArrayTypeEnum.py,sha256=cJJho2ZklOnm2oNyQdr0OjcW1QC37knq2KbZ9PEVTo4,121
-ngcbpc/data/api/JobContainerProperties.py,sha256=uKza3RM1csq1uilFYNHj7F-Tgd9O5JIIM7fkucp6ZTQ,12900
+ngcbpc/data/api/JobContainerProperties.py,sha256=5_zdjBgCyjCKJUN8jlv0I1c44zSBp2phFBlyey7pOB8,12900
 ngcbpc/data/api/JobContainerResources.py,sha256=UhLENjI8mXIkZdpYmxfyWgcQPVUdIjanMvFchiLXiQg,2577
-ngcbpc/data/api/JobCreateRequest.py,sha256=ZnjkfqbaWwF1FS8jNwSu3bG3LRbvYc1R_8-MF0S7Rok,41050
+ngcbpc/data/api/JobCreateRequest.py,sha256=PrgjR46tZft8EBxtDRNpk2Q0YJDF9U9N0w0DuzPdwKY,41050
 ngcbpc/data/api/JobDataLocation.py,sha256=fy2jEXjIpqTfEc80WQ9GeqsfVC9HAux-H2Ask93JKJ4,9678
 ngcbpc/data/api/JobDatasetMountInfo.py,sha256=O2Gzyn23NxXHKafjZYcMusNfFV5-WohmzRHH_xzCeeI,3490
-ngcbpc/data/api/JobDefinition.py,sha256=8XjQnZGjdNRu57Jvq_Ju2PuSwmzG86aG6-GUWwCBOmo,39617
+ngcbpc/data/api/JobDefinition.py,sha256=OBZPEwWiL3VY3K_NOreby64pp0AFFQroSXrJ-HLfxtQ,39617
 ngcbpc/data/api/JobFlowTypeEnum.py,sha256=O5JE5cdfzg6scJkcIncxdad3gzUUZTdU5kCjLcvWdT8,97
 ngcbpc/data/api/JobHealthCheck.py,sha256=pLEOf44S2yBNBI-MyvK5tjerIlZlS41SXG_PoeISnqo,4617
-ngcbpc/data/api/JobInitContainer.py,sha256=6mU6oIREa-uWLmd6Os0qJoQq02FxyADncMgxLynPChg,12808
+ngcbpc/data/api/JobInitContainer.py,sha256=WLLkM-NyQF8gCMHp0Fj2haaxLWaiKQLDee3P8IBMDLA,12808
 ngcbpc/data/api/JobLabelDeleteRequest.py,sha256=YMdHreYNVeq453gdOwhbLMYsXLb5hQC3Py0z15xHEps,3556
-ngcbpc/data/api/JobLabelResponse.py,sha256=ssk8sw-tWMh28dOqDElxxIi3DIp5S9bQLIj6BxfZHa8,5211
+ngcbpc/data/api/JobLabelResponse.py,sha256=L9A4Qz8X8xmXdX6F0ZUA-41rRIHrgmld2nSf_0DPjE4,5211
 ngcbpc/data/api/JobLabelUpdateRequest.py,sha256=qNTQd-WOrWmqSsRd3oadCbVe7PvDw-J7AoGXF8Zx7_I,4241
-ngcbpc/data/api/JobLabels.py,sha256=kNKvnJ_FuKDxKuvYYD4lyzWAtCJhk3u9rmdB6BM4X3c,4940
-ngcbpc/data/api/JobListResponse.py,sha256=LGo9yOKkjt2BuhOPZoV_ZXN3foPqyxrg3VbuilA8F6A,5146
-ngcbpc/data/api/JobNodeCreateRequest.py,sha256=kRW_PMhZSDf7N3it0zY4BARXvIYhTWEHfkiARdOiQvA,11711
+ngcbpc/data/api/JobLabels.py,sha256=imbFmLr0_-ejexCb8DBKzv0w0Sz_ewmFsITjeONPVBs,4940
+ngcbpc/data/api/JobListResponse.py,sha256=0E8NsP-tfFc0Ww47jNCJFnJZlc_45xr6Qt3AKtPiwBQ,5146
+ngcbpc/data/api/JobNodeCreateRequest.py,sha256=jhb3slVKgnmwUV2jjKlUttpocBNDzovNEHzKRA5NIKA,11711
 ngcbpc/data/api/JobNodeDeleteRequest.py,sha256=J8t_HDSpT_7DAp8k9Utptu_IGrEOkRqLVYBjpWC-VUg,2948
 ngcbpc/data/api/JobNodePreemptRequest.py,sha256=CudMjIjCPIwM73MuSuy2IVzZKUihqqXwRMo-urtVlDk,1907
 ngcbpc/data/api/JobNodeResumeRequest.py,sha256=JzUqcAcUjCFMInkHT74g_Vpf_mqLMBAYE-exuQGvx4k,1919
 ngcbpc/data/api/JobPortMapping.py,sha256=U8k7H0GW6UHu5tZN5kxmk1VVL24DtCAKJA_H5AlgRvs,6209
 ngcbpc/data/api/JobPriorityEnum.py,sha256=W1zRqf0WwmTpRLN_GnJcndtznNFqjaYjvAvTFyreGxg,104
-ngcbpc/data/api/JobResponse.py,sha256=hP8PJMnIXkVUNg0WWbajCfVk2ejcwvSQ3U2CZ5vtxes,4883
+ngcbpc/data/api/JobResponse.py,sha256=BDqv7YMw88AwU9cCRr6e1uMCsGKxy034vZcBlxSi4Zc,4883
 ngcbpc/data/api/JobResultsetMountInfo.py,sha256=t2ru2B3faJ0HLDVlQpP-dx1vAMtXJ-ZwPIvBFhi5Fn4,3890
 ngcbpc/data/api/JobRunPolicy.py,sha256=qa8wbVtKM3mhiI1aGvOAyXCuUqvjKw_93wEQodVeWis,5817
-ngcbpc/data/api/JobSidecarContainer.py,sha256=LjnZP28n-t31hjAo1OQ3LBNaC5rJKBnBIRT07whDg98,16057
-ngcbpc/data/api/JobStatus.py,sha256=5xp9p-BcY_qIGkNH87RAeFfBhZdH1tMoFH0dlDzQjqM,19200
+ngcbpc/data/api/JobSidecarContainer.py,sha256=z88pjzGc_Rb4RvDYMlNcG4t3e0ZnFFLNHvP2tIS-GtI,16057
+ngcbpc/data/api/JobStatus.py,sha256=nyTly3ExrkXCZ1dZlyJ4yO15Y2dS1RJX24tV0TF3AhQ,19200
 ngcbpc/data/api/JobStatusChangedEvent.py,sha256=f-Hb9RhkCHG9HAiWtejArNg0n9FnPN6pEgqCdjwDyjo,2491
 ngcbpc/data/api/JobStatusCount.py,sha256=_dREcfWpXx__tHPKaGTrMGj4whN7tQ1MpYHQHLoTHeY,2464
 ngcbpc/data/api/JobStatusCountResponse.py,sha256=ExAULk44OBLJ1S8U_6No36BKAH44z7HkMsH9O8nEz4Q,3086
 ngcbpc/data/api/JobStatusEnum.py,sha256=tk4n3QRbvhAA8t5OnxAW5smxHON4DhmYfJ9smMOkqDI,541
 ngcbpc/data/api/JobStatusSyncRequest.py,sha256=ZOdSly3WV8kTi40kAl4ApIQ-44DsHAA_REwsl5R8L_U,2339
-ngcbpc/data/api/JobStatusUpdateRequest.py,sha256=yOby8hEvlRC7kXzUVVJDg6O-i9XRlo1oWe7MMnXOqKo,8345
+ngcbpc/data/api/JobStatusUpdateRequest.py,sha256=wtb_t3yqbvfLjPuH6oeLn1PGeLnD1iNuIPWoPpo-TPc,8345
 ngcbpc/data/api/JobSubmitResponse.py,sha256=vIGedEWgP9vrjN0Trx_wzKIshZNpblL2sgdUutb4N3I,2872
 ngcbpc/data/api/JobTemplate.py,sha256=RECQL-BZRruSAEmkf1RtOzhJ_z2akGvX-e_edvauTRg,6644
 ngcbpc/data/api/JobTemplateCreateRequest.py,sha256=ZFpt4nNZQYRhhtqDdIvhN3Kiuf3HSYvG6AN4-2N1WtM,4810
-ngcbpc/data/api/JobTemplateResponse.py,sha256=UxCpCH9DIUOAZk5Kxp9lkzokx83wlBh9EJcjOMd63Tc,3052
-ngcbpc/data/api/JobTemplateUpdateRequest.py,sha256=v0RPgzDMhbc83RkY_s3578qtjjrCOVrXq5glFq4Jt3Q,5980
+ngcbpc/data/api/JobTemplateResponse.py,sha256=dKwYB4_wOC1qShYSQ1DCrN36J03NvW_MChdHpyx7k8o,3052
+ngcbpc/data/api/JobTemplateUpdateRequest.py,sha256=kqnEeSDQEa65wpkx-dIkQF9QoB0Bi9mLdOoH9iIa1HQ,5980
 ngcbpc/data/api/JobTypeEnum.py,sha256=6pCphFYrb7XTUthLV_1o1Rak9P5C_lzbWyK0iOvddpY,92
 ngcbpc/data/api/JobVolume.py,sha256=LeqdBBzaS5SNeHfq6uoq_wJL7ugXXUb3L_vYY5Vzai4,1799
 ngcbpc/data/api/JobVolumeMount.py,sha256=ZOsVqJPQXc0JELlObVFT4kcrAlZUE2bgeMa0mMaYkFs,3837
 ngcbpc/data/api/JobWorkspaceMountInfo.py,sha256=nbnwpL-PZJeWBoK_KGly3jg8Gywr4jHqXqOMVDFnuE8,3819
 ngcbpc/data/api/Measurement.py,sha256=41xWquXhdvY96_L_1kjlrC997dy2ld1xCihQgwtM4TU,1696
 ngcbpc/data/api/MeasurementAggregationType.py,sha256=kni3kEnm6lUi23kdZ4Maf6tnrVz0Z8CEwxJeffpplxU,140
-ngcbpc/data/api/MeasurementAlert.py,sha256=4xlh5ozo6FMJb3OkXR2h1aLbMJSLmj65_7RuollUJ1g,9534
-ngcbpc/data/api/MeasurementAlertCreateRequest.py,sha256=U7NaJcvc39AzUOPUEaTqJux9Zj0p8TTIEkxK9yYPV9s,9069
+ngcbpc/data/api/MeasurementAlert.py,sha256=xdChXOfMZVH4Opx23g2qugWzZZawTMoKgSdimLg6kyQ,9534
+ngcbpc/data/api/MeasurementAlertCreateRequest.py,sha256=75Tj5bwUxUPcAWcXjHgXuDI7aE8GbF7HlWwskmG69zA,9069
 ngcbpc/data/api/MeasurementAlertCriteria.py,sha256=i-xCCnCvzFQZpNwjYyaznWpFmdQACrt6GHq-zIcRgtU,4394
-ngcbpc/data/api/MeasurementAlertListResponse.py,sha256=v4dEJtXQe0BLvJyFiCG0zNX33qx69oPyHnqu-6Vx6UQ,4138
-ngcbpc/data/api/MeasurementAlertResponse.py,sha256=2lopiPaoW3ovQZ1Nt357JAfg254aQ95RVqtuDZMwuqk,2956
-ngcbpc/data/api/MeasurementQueryParams.py,sha256=e2zYun1ogbMx6kHxFkKy0pAALLs4KLFA_KlREm7Xklo,5771
+ngcbpc/data/api/MeasurementAlertListResponse.py,sha256=iz2Wwwjv2hxhTc2_9LSrQxjJ1IVAeGYJK5hvWeevbjU,4138
+ngcbpc/data/api/MeasurementAlertResponse.py,sha256=o7cAVziPZtRnDFfM0ibjgBFc96QaZvp-LzDaIxybLhg,2956
+ngcbpc/data/api/MeasurementQueryParams.py,sha256=jkTe-iq6VTPaJ-jTDJ5xm7roDhwDOVheLNYRybRHKmI,5771
 ngcbpc/data/api/MeasurementQueryRequest.py,sha256=Q-eScPsSlaeAgk-CeEPo1liSez6hmXNgMXDUfdpqHY4,2124
 ngcbpc/data/api/MeasurementResult.py,sha256=ThVvMzW_Pg2zuEw7MQM_cH2LH94FpHRKr070tpOKQek,2041
-ngcbpc/data/api/MeasurementResultListResponse.py,sha256=xJIkPCoL32irzey4IEnUGN-WRH8FZKDrac2qAEw5C2k,3151
-ngcbpc/data/api/MeasurementSeries.py,sha256=fRoBg35Gnbg5uLphee5Ku-KIBkab7qtHZ27E6tCrg1U,4566
+ngcbpc/data/api/MeasurementResultListResponse.py,sha256=ig_SfFS1NMPAE8diUAgCz3bVAiCSTBtvgwuhcwPtQ6I,3151
+ngcbpc/data/api/MeasurementSeries.py,sha256=0XGiW9V8dpRPFmXaOkMpH2TSx0PuxCfHJD0pDnUPU5U,4566
 ngcbpc/data/api/MeasurementTag.py,sha256=qJ14NeQn6vPrPal1-fmTKn5Vwt3fcXpXhyASJmV-jFU,2557
 ngcbpc/data/api/MeasurementType.py,sha256=2JkRNdpczxwMYSxHKhR3AOTdF1mCUW3r2I-AY5UWrq4,1139
 ngcbpc/data/api/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
 ngcbpc/data/api/MeteringQueryParams.py,sha256=AkHxFrORJiE-h-WYOpL2fKajY9cvVC8GNj2D51Ss8ts,5806
 ngcbpc/data/api/MeteringQueryRequest.py,sha256=-4x3G9MQxyUD1WLgVayMoGVzYxOtaQ5qFUZE7Z3SVoU,2108
 ngcbpc/data/api/MeteringResourceUtilizationEvent.py,sha256=RigcoqHItBu2yLpBsU4fyKaI6YjhkH6jWHFfy3gr4Nw,8876
-ngcbpc/data/api/MeteringResultListResponse.py,sha256=tvA85M7ngkyxAgPS9x0_ZzbOmOiKsiupCnrGCEaErxo,3145
+ngcbpc/data/api/MeteringResultListResponse.py,sha256=qTrK_MbtzRLT0RNR4A7nSicfvCWsLx711EG613tdJ3s,3145
 ngcbpc/data/api/MeteringType.py,sha256=fxS9yLnqBCY0HnIrCTa52NIlRL0lcTN72l4PEvKb6Yo,464
 ngcbpc/data/api/MoveNodeRequest.py,sha256=vIAA8_VemJGpPt-ycCC48edZxqCI_dSPIHgyGm1PxOI,1880
 ngcbpc/data/api/NetworkProtocolEnum.py,sha256=WrTLk0E4lQ4AgFwps7MzJGLcIWriHo6Kv_naR3Z4P2I,117
 ngcbpc/data/api/NetworkTypeEnum.py,sha256=c9TOPxzy3_TDN5_KMjoRYIVdgXfgEQ7tvxuUMCFG_wY,106
-ngcbpc/data/api/Node.py,sha256=_A7gj-ArR06Lm9rPb30HUoQ6hOMStva8tsZ2nw4WAAY,12102
+ngcbpc/data/api/Node.py,sha256=1cvjSvnWlWEMHdJvUx6WEWMrfPiF_E75F0G5Aug0cms,12102
 ngcbpc/data/api/NodeCommand.py,sha256=OR-RC0FZQf4bCpCIpPhk4pAksv8FtMI7sg9pzbSIYpA,3564
 ngcbpc/data/api/NodeCommandRequest.py,sha256=zqhsj7KJhtLQ1elrPVkm64a3m5Pc2kcJL9i4NmajIqM,2778
-ngcbpc/data/api/NodeCreateResponse.py,sha256=izUMW3ET3XixpUbQ2vV4Y5vXRPllIKuXmBvP9RlAwwk,5388
-ngcbpc/data/api/NodeListResponse.py,sha256=gYZ8wWVG0blcDC_KyBYpsTklaw5ubi_K6JfyScudNHM,4017
-ngcbpc/data/api/NodeResponse.py,sha256=MGKHPhUYr9joG3yAmeA2Iu11VqrdD2pobfPd40tBwho,3755
+ngcbpc/data/api/NodeCreateResponse.py,sha256=IR_bDfL6QqSaMUlyJl6meZVUQwvkuld1AWQMUm5e7rU,5388
+ngcbpc/data/api/NodeListResponse.py,sha256=yo_WbyB0JqPwlYv040bmW7QLaWYLSm6rwk5Utz-bf_w,4017
+ngcbpc/data/api/NodeResponse.py,sha256=YO4YL2th1hDGoMlkWM9FGT51MJ_ME6fBD3_hCZxwTw0,3755
 ngcbpc/data/api/NodeSimplified.py,sha256=UEQ4gBUMOJNqL6_qDaUOAshDfEe8eCGOS8lK-t9md30,3336
 ngcbpc/data/api/NodeStatus.py,sha256=jpslgG-4fzwd8xmeWFli_Tr1hH6U0qL638Gpx6D-sNU,28410
 ngcbpc/data/api/NodeStatusChangedEvent.py,sha256=k28J3QN7yJXFZKRazSeSF6kLVw4y4L51UOaaNIPhSJ0,1883
 ngcbpc/data/api/NodeStatusUpdate.py,sha256=Ie-mdZCcxAYmj70hCYaRO4dQFyviufxftI_doDKqnOU,4161
 ngcbpc/data/api/NodeType.py,sha256=rRboqXP6aGaZVR3dierWMt4i_IyE1smrcL-xjSxBMlo,163
 ngcbpc/data/api/OrgAdminUserCreatedEvent.py,sha256=VG3cC0CvksP7t0fcXL6Gk85n5P_vaNYVuv6RjXceYGg,3446
-ngcbpc/data/api/OrgCreateRequest.py,sha256=MW8Ch4O1rshrRNb5kmV_VqIlQEfWUFpCZ0b4X2dBO8A,14183
-ngcbpc/data/api/OrgCreateResponse.py,sha256=SSvVr87-QajbeB1dMlMTqE8VH6ciAPSZvGaYw-CRnhQ,2929
+ngcbpc/data/api/OrgCreateRequest.py,sha256=qa6pz4WIWlh0r2zRJjNshoFsgqGElUn5cRu9yzyIhDM,14183
+ngcbpc/data/api/OrgCreateResponse.py,sha256=cAyvFmkgHN1uVt4TwoIbOMaW4ONKcqcB8NmV0UuZA6c,2929
 ngcbpc/data/api/OrgCreatedEvent.py,sha256=QfDfieq6d5FxSRZepHKNL09G_dov29i69dMri1PmaVE,1777
 ngcbpc/data/api/OrgEnablementCreateRequest.py,sha256=CVTGAZbu_92z0AWe8ajQVbr6PhKhWMDyG8vRL3xMP1M,3450
-ngcbpc/data/api/OrgListEntitlementResponse.py,sha256=8TxxSO0mwfiL70PODjBnfcPovFsKvoIIiqw2Ahk70tY,3219
-ngcbpc/data/api/OrgListResponse.py,sha256=eofZO1XTd4nGuym6L5Xv8xCRNJzredghVxwv4Z9ytXI,4197
+ngcbpc/data/api/OrgListEntitlementResponse.py,sha256=gLNGoevQTWSeVbFm0aZ8XJzMMcs09lA3oHL-mY0eWDM,3219
+ngcbpc/data/api/OrgListResponse.py,sha256=5KFctZJJ7HvZFthaYsQVEgOzl24sZqZkSHGxmK7gRbc,4197
 ngcbpc/data/api/OrgOwner.py,sha256=JJcTFI5DpxRsFETjq9Z3Phth8seBZOsWwbhsjvjDypg,4754
 ngcbpc/data/api/OrgProfileUpdateRequest.py,sha256=wSOKWsuZVlL1isxd55DhG3jBuN-VX2zLlNylq_VC41g,3459
-ngcbpc/data/api/OrgResponse.py,sha256=dwCIqLA94Nwx9beBNrjocG49coNixLL5bjE_jda24lg,3041
+ngcbpc/data/api/OrgResponse.py,sha256=phYUV80acDcXT51toK_R9wXISPCG74UsNdZxB9gCUmc,3041
 ngcbpc/data/api/OrgType.py,sha256=WSAh3QAhYsAq0pZFd05bLjAJT0VcODFsKt8tFWpPl7w,118
-ngcbpc/data/api/OrgUpdateRequest.py,sha256=ENA8jf3sKnL9Ej7HGTl4HErckZ8yZzi9t28afmCYxBw,19529
-ngcbpc/data/api/Organization.py,sha256=1qMMcpUHF1z3e9t99Pt6wEQZOb1sddv_XKvgYNFP2sA,22086
+ngcbpc/data/api/OrgUpdateRequest.py,sha256=1vrMf0l0pb-NmDUSgeE31jzpJajsm2Y8sgXQSEF69LI,19529
+ngcbpc/data/api/Organization.py,sha256=a3jj5r9lPgS7iRep1R3KSWymD3XXcrSgfKww9KRY9g0,22086
 ngcbpc/data/api/OrganizationEntitlement.py,sha256=ry2x77e7PQsyPGWIwjJ335ypYhaM5lktTTSxTUp7MEk,2826
 ngcbpc/data/api/PackageVersion.py,sha256=Z6cPH7dEumjKI0GM7rzu386SXZIYNDFMebCfkEQB6UY,4056
-ngcbpc/data/api/PackageVersionListResponse.py,sha256=TkeqwqEIZdkuP241vi4xRvs9mn9Syi5qKsK8TkfB2O0,3032
+ngcbpc/data/api/PackageVersionListResponse.py,sha256=71X6dzPKmJlumMnhoLXgKwcwB7YhJ5kEu3wuDtfCux4,3032
 ngcbpc/data/api/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
 ngcbpc/data/api/PasswordChangeRequest.py,sha256=m6TGlwEJknU3Gbs7Mtts_SoKWwY0yAd1kmDST_QhN1E,3629
 ngcbpc/data/api/PhysicalNodeCreateRequest.py,sha256=Bn6XGnTXotZfPU_U3HeWWd3BEANNm9MOjWY-Lgtrx0E,5365
-ngcbpc/data/api/PoolMeasurementQueryParams.py,sha256=02rtOZjMim59ul1af20x9lODgJBE7gNRK4nWGT_4sYM,6106
+ngcbpc/data/api/PoolMeasurementQueryParams.py,sha256=fPkinqkEdGyPYiYnmYSeFWCSnpruG5_dOofLhk3ufRk,6106
 ngcbpc/data/api/PoolMeasurementQueryRequest.py,sha256=UruV0Y9XkiT0Rk_Q7X3lfs6GHW--Mr-5mPdoRHNs69E,2153
 ngcbpc/data/api/PoolMeasurementType.py,sha256=yq6Pv01ydSWNw92u7s4RpE-nlV_KLF-xHwV0XFK_jmM,341
 ngcbpc/data/api/PostStorageProvision.py,sha256=gB4Hj9_V_5HDR0WezZZTQT8_1ecfxusK3UN4IDhVZQc,4619
-ngcbpc/data/api/Price.py,sha256=AxTQiXztS7KDU59N770PMgvgcWMgnQ7o7VrW7Kixpno,4135
+ngcbpc/data/api/Price.py,sha256=rv54TOVBq3BUhXG-7pQKBMmVegdhWxnrRrKDtQ2Gees,4135
 ngcbpc/data/api/PriceType.py,sha256=WpihCEt6p9g83G7TNbU87n1dAK8MioVgRa6ZT_iBg7Y,107
-ngcbpc/data/api/ProductEnablement.py,sha256=FuwzTGtkUInqSHuZpK1QP9YLtw_Vauu7FCqX9aA0r3g,5355
+ngcbpc/data/api/ProductEnablement.py,sha256=IsRGxeA7sR-5glzofIuw0wH5IO-GceltNFTm7uCszdk,5355
 ngcbpc/data/api/ProductEnablementTypeEnum.py,sha256=U-RWZoaL5LMCKbUNPvw2egUxl7dQokiq2t9p76yR_OM,196
 ngcbpc/data/api/ProductNameEnum.py,sha256=ysTpUtsLfUResARGq0FiGc2cwNsaI2epfHueZhtbRrU,637
 ngcbpc/data/api/ProductSubscription.py,sha256=Iso5jG3_RucU1IxMnOYCFjXaOxqKqzLLjjXOX4BHyW4,7108
 ngcbpc/data/api/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
 ngcbpc/data/api/Replica.py,sha256=vhf-HQt-axsrkXJaxNYaloJuQTczyTlZeUGSNL0bId8,11869
-ngcbpc/data/api/ReplicaListResponse.py,sha256=Emz-xcfehwLg8ZZHhsSRoEpafp5xzund3YaqM9QPzWA,4167
-ngcbpc/data/api/ReplicaResponse.py,sha256=A54Q2EZOQqFrdLfRknRXOwZXt8a4mwBV1igPB-cl6dc,4182
+ngcbpc/data/api/ReplicaListResponse.py,sha256=gSNjKuIEiXsRiCPhtc_IartpZKor_ikCsNUpatSI68w,4167
+ngcbpc/data/api/ReplicaResponse.py,sha256=bcAcRrKKGv0L2VQQ9Sp7DhJFMFq1EpTfTAtPYVEfT4Q,4182
 ngcbpc/data/api/RepoScanSettings.py,sha256=slbOIf1Q3S5HWf1Ssfh1TxMj5DRKwRiPF9uEi_OmocA,6724
 ngcbpc/data/api/RepositoryTagVexByDigest.py,sha256=0jVKReHqrSaL05R2-MQfWoYXMolqdmOFWxbGakU8T7A,2672
 ngcbpc/data/api/RepositoryTagVexDetail.py,sha256=OMS57-bRQeHNn3C8c3mK6jDA7CnLMpnG1IlJjgmxSYM,2528
 ngcbpc/data/api/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
 ngcbpc/data/api/ReservedLabels.py,sha256=5WrIennNIOlFAP28GHRIdW8ngDgzmDydHENVCg2Lnnc,1730
 ngcbpc/data/api/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngcbpc/data/api/Resultset.py,sha256=jifHXekzj9v0eDNc7AvTM_1aHL4eEnemoxOds6o00pg,11985
+ngcbpc/data/api/Resultset.py,sha256=IvBcFktCrlP1f2F1Sx68dUgAXIhTY8xShjiZE-K5kmk,11985
 ngcbpc/data/api/ResultsetFile.py,sha256=lnmnychCjjxV6-9I8QdrYD-KcSlc58xtfpLN-H6sYxA,6582
 ngcbpc/data/api/ResultsetFileBatch.py,sha256=tloKsOZgem4iflJzfsCEGi5R9xUTgGGq8dJ61ZwSHt0,2002
 ngcbpc/data/api/ResultsetFileEventRequest.py,sha256=tSgBpMqdqU1-OsZw14MsAJ-hs0eEryWIanp-3r-DUsc,4130
-ngcbpc/data/api/ResultsetListResponse.py,sha256=Jh2vx8PmThBVHdb_Xrke3lVeZTQJQ9jpvku8goT_IFs,5280
-ngcbpc/data/api/ResultsetResponse.py,sha256=JINDpnhem5Vh-uTqfHd7IcNbzt1DUZ5KbXc6-SS1B_M,5145
+ngcbpc/data/api/ResultsetListResponse.py,sha256=0DHUHtvzuDq78kX7lb73bbWGjiP-qO4YY6z3qYWVWUM,5280
+ngcbpc/data/api/ResultsetResponse.py,sha256=Banf-pqOZ22wOgNS1Y9lK059ghmVR0tF18JzVWYwJz8,5145
 ngcbpc/data/api/ResultsetToDatasetConversionEvent.py,sha256=SXB3CzwkMl1WODrvaJY1zvLxXceiJCvEd_Sw-mt99yk,3429
 ngcbpc/data/api/RoleChangeRequest.py,sha256=N4zc14jMocC-DJalMZYI9vDmS3huWjFX2y2Nb6QJLX8,5182
 ngcbpc/data/api/RoleProduct.py,sha256=opYPVS5u9I6yfVA4JcQv4Bw1ViGwkb1y_WnTQ3tuka0,2623
 ngcbpc/data/api/RoleType.py,sha256=vz1ep3FiolCyEwdqOAXXJx0CG9Mw0XUZYXo1n8q-fX0,1810
 ngcbpc/data/api/SCPJobDetails.py,sha256=T-KfbNRwNFXx9Lq3CfOVYa3l7DqISsARhh5d2VW2080,1694
 ngcbpc/data/api/Saml.py,sha256=UyMGLkUb1OTrJ1x9QelRNOlSbh8Pq5riDuntzb7wdbk,2413
-ngcbpc/data/api/SamlResponse.py,sha256=oQGIYcypKyNBg36MECwjjD5qJKTk5EUuJmCBT7XhFQ4,2747
+ngcbpc/data/api/SamlResponse.py,sha256=Fc-xFzp7YCnh4Rt1vhkI9J3-Lpac1pvaCpblWys5mDc,2747
 ngcbpc/data/api/Secret.py,sha256=AvR-T3jc2rqRsVz2zVXvxCkq2dZ33D6ByTSYuYhZeCU,3983
 ngcbpc/data/api/SecretKVEnv.py,sha256=9mIWnGDojgdSdrGSW8BrQk6x9U1WxlarZOyJzSnC3RU,4504
 ngcbpc/data/api/SecretKeySpec.py,sha256=sx4TtaePGrif_2rHMMox4T4Ml_inytfE__T7R6W2VaM,3314
 ngcbpc/data/api/SecretSpec.py,sha256=XZte7OZwv9uEkMF6e6P1OjAf7viF8MuhApdcM7MUWTg,4057
 ngcbpc/data/api/ServiceAccess.py,sha256=zv-qAyg4G3eD8VAs1MkkaFYoLvi3AHUEiFYJGRYyR-8,3507
 ngcbpc/data/api/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
 ngcbpc/data/api/StorageAccessInfo.py,sha256=2eSl9QvCYquZjviVJyido36lnWu4wYH45JwnvUrMmfs,4320
 ngcbpc/data/api/StorageAuthenticationResponse.py,sha256=GnXwnDANLbnXsHiSV9c2_uqdUBSRNTRxF-bRtH-ZTYY,6019
 ngcbpc/data/api/StorageCephInfo.py,sha256=5XnS__0RsgxgwwHfYr088k9m-3oQe4R_pgdKgsOVrnk,2688
 ngcbpc/data/api/StorageClusterCreateRequest.py,sha256=D4yKOCDLznReVSg9jLv1oc3H-U068_8kSTIDRnUARMI,11664
-ngcbpc/data/api/StorageClusterListResponse.py,sha256=hVmDA-51QmBjV8KNrgvleD6-q5rNLSmakAYXOlsa_U4,3227
-ngcbpc/data/api/StorageClusterResponse.py,sha256=IWPEYmjNHrqLezdecQgxJ1bwLlfqg0OApiRZNDakj_U,3140
+ngcbpc/data/api/StorageClusterListResponse.py,sha256=L2grfx92KJ5a6cTi0IVV1oruVlXXuTAMXBkrW-tWx7c,3227
+ngcbpc/data/api/StorageClusterResponse.py,sha256=dIjxSkPQL8CwcU0kpnV0U7nr_iciDWrTrVJzAcnu3Dw,3140
 ngcbpc/data/api/StorageClusterUpdateRequest.py,sha256=ypX1wJk1p9Q_2YXGCAR3PFAPOvc175fYerCSncqQ1tM,9783
 ngcbpc/data/api/StorageEngineTypeEnum.py,sha256=4X1zYynMr4wcpLA_1xVvc84NBNxSSg4_qkjuzkRPMhI,129
 ngcbpc/data/api/StorageLocation.py,sha256=fYxlNvvIMHKez4-d2X1sPs18vqQDpVVbx4Oda33ch70,4059
 ngcbpc/data/api/StorageLocationStorageTypeEnum.py,sha256=LWSnY3HRhkwBGJjy57lrZb_ZnkXc4qk9Mgbv1ixwaGo,128
 ngcbpc/data/api/StorageLustreInfo.py,sha256=MZwqSmVucj3CaBHSH6iyVyn_zuEovXZ_4QkPHPdE74k,1996
 ngcbpc/data/api/StorageNfsv3Info.py,sha256=g7Xp2wQZNLQZrWt8vEFHsVvJOfKPTXOx3dnVd6EW44Y,1955
 ngcbpc/data/api/StorageProxyfsInfo.py,sha256=rQqeXm0DpoQsU1uxuVdVnsr6Z0dw2tyAVU-RrukneQY,2011
@@ -358,120 +407,419 @@
 ngcbpc/data/api/StorageResourceStatusEnum.py,sha256=DWrDvb0M6aWjIsJ0iBoHFJ65h1KuDLJZUcPXUupu5Hk,161
 ngcbpc/data/api/StorageServiceConfig.py,sha256=xQ2ij9qj2HNiteddaJFZiK8qokLxZH6gd9koFtPHFIQ,5120
 ngcbpc/data/api/StorageServiceConfigDetails.py,sha256=p06aHAf_vSCig8JMC7KYTz7FhvUrgY_SFhxZHnIwq8M,13574
 ngcbpc/data/api/StorageYarofsInfo.py,sha256=c9lLmlnVOEmkllOMEiTzW879iXTJyJjGnIBKQoYTC5s,5312
 ngcbpc/data/api/SuggestedNamesResponse.py,sha256=W0t-Hb_6xXa2_D9rBC9tj0WXyd2hAdXOVCzrI5scJOk,2722
 ngcbpc/data/api/SystemLabels.py,sha256=yLaTogbu7Jyg67CsFOUZusbekhML1ez-hI55JQYHoc8,1712
 ngcbpc/data/api/TargetSystemUserIdentifier.py,sha256=gIlIbqX6amfKAVlGX1QQ3uZkM78LHwbFbkvkxaa1ZpQ,6470
-ngcbpc/data/api/Team.py,sha256=CB2xSMqfdCzUd5lCxiM4P4LrPDMfSlHy42tMaca6fXo,6353
+ngcbpc/data/api/Team.py,sha256=SOfaXouJHinqOCDAj2RyzR6k1hi20EXg8QCSdWqrpvw,6353
 ngcbpc/data/api/TeamCreateRequest.py,sha256=8awxlfnUFS6k68KOO18ADFcthSPzOw2ZujkBXfU8-js,3756
-ngcbpc/data/api/TeamCreateResponse.py,sha256=yyGydPyK7uW_1dVpsF6x8SCeo04VA2yewkjJNKvspOI,2856
+ngcbpc/data/api/TeamCreateResponse.py,sha256=O6f7ol-t5z12iBgtXboH_0CtPQdCqYSbcH128RVXjjY,2856
 ngcbpc/data/api/TeamCreatedEvent.py,sha256=77vAtprTmdzL5LzEUJzv_VukI7Y6wiwfi2cGbDLBVQw,3332
-ngcbpc/data/api/TeamListResponse.py,sha256=H4L1BNvvWiXfPKVX68GeG7UGeo5T89Ywbx_hnmm13U4,4017
-ngcbpc/data/api/TeamResponse.py,sha256=9wOSMO8m4Umq_kYkP_OLrOdZorEEvPcw1CG_AcIaytE,2811
-ngcbpc/data/api/TeamUpdateRequest.py,sha256=0pP9NhEUgA0D3IDV_y0qteiPoEP1NHtbb6PRXrgZ6e8,4496
+ngcbpc/data/api/TeamListResponse.py,sha256=dexWg54bPRZPZiWW8h-26v5_v8REq0X8Y9jatKzcujU,4017
+ngcbpc/data/api/TeamResponse.py,sha256=kNnHS8yU0ZSIXEnc8lBDbGbhs1SsBY9mj1UyYnGulT8,2811
+ngcbpc/data/api/TeamUpdateRequest.py,sha256=PH71AmUtSUIZJf1z8oha9py9QbPHkd_jU_34oTiJtpY,4496
 ngcbpc/data/api/TelemetryClientCreateResponse.py,sha256=Z2llgkVNZrCe5EkDf5iUZEtjTDERe7WvjqPGKfL_Lbg,3608
 ngcbpc/data/api/TokenResponse.py,sha256=aIkTIj-5k4xpsrfKYhfiZOQCeHHtNw1Qo62LT1op7YA,2705
 ngcbpc/data/api/UpdateAceRequest.py,sha256=f0lNTCeGU58V74z3D5HoXZnl4xzcOSgttAl8odD0mNM,1914
 ngcbpc/data/api/UpdateNodeRequest.py,sha256=DbFzG3wn5Bls28ceQAlWBTjGSgB5gMEhZWbgBfiw_h8,2736
-ngcbpc/data/api/User.py,sha256=p59Sd5Kb0I17gv-d9s7h_FxzCzTOljHWhDgdQQuW8Hg,31143
-ngcbpc/data/api/UserCreateRequest.py,sha256=pxUqS8pikPDjctbfHdydPyGat84VZUen0uS6YfTLgmc,9435
+ngcbpc/data/api/User.py,sha256=szYjD1kaDfttISgYBrUwWTbpvvX0w93eCE3-iql8H2w,31143
+ngcbpc/data/api/UserCreateRequest.py,sha256=hTpDxCs5tgrfXZYO3uPp8Aos_15NvHN_RidPn8ExM9c,9435
 ngcbpc/data/api/UserCreatedEvent.py,sha256=vT_ew2DzLqcIhMrbBhQusjNke3dV8_Hid_1oq9O_LCM,2525
 ngcbpc/data/api/UserInvitation.py,sha256=4woFFsbBCmgdrGboyyHw7xV6z0MGdxjSy3HXxTwAD60,9651
-ngcbpc/data/api/UserInvitationListResponse.py,sha256=pRjEc0dvgz0xefl0vxOM8kCivt1t60EYwZKN1_KAFlc,4231
-ngcbpc/data/api/UserInvitationResponse.py,sha256=GCqn8SqfMnowFCA9VIpr0TIsf59CyPUKMX_St30iK4k,2988
+ngcbpc/data/api/UserInvitationListResponse.py,sha256=EZxgicoa6nn2k2CWlheGPXUQgdPHY9d4xcZOQeGcGug,4231
+ngcbpc/data/api/UserInvitationResponse.py,sha256=8w0YpIMzZfMqK_NxfZDk4rUZvAtxJ4BERLIcqK4-Gbg,2988
 ngcbpc/data/api/UserKeyResponse.py,sha256=zJyNxvsXrq6miALIjuxJbKn6nCXqRndzmAuEItpyhMw,5560
 ngcbpc/data/api/UserLabels.py,sha256=eoFQ4SRV-8hIDX8bHkz_7X_gjxHtAiagAy2UQ5mutkI,1726
-ngcbpc/data/api/UserListResponse.py,sha256=e4pIc0iK1YSmI6d0jSTj12zYGZAi4p-YG0Sx3liBbM0,4058
+ngcbpc/data/api/UserListResponse.py,sha256=64PUyjY_StRjN37Sz4HW1JwQ1qBvma9QZCPVjV9vxy4,4058
 ngcbpc/data/api/UserMetadata.py,sha256=1GunPpiDPOXdqLxkX-fEaW36dFmdMitVdJb2NNH90SA,8112
 ngcbpc/data/api/UserOrgRegisterRequest.py,sha256=S7gDoammaGdenuO6lo1HbQpjF1tKLnaX1xhosymz8D0,9791
 ngcbpc/data/api/UserRegisterRequest.py,sha256=hoSH4orYod9GYsEq_MXG_0auSbH9EPgWEqNdOAxtRgU,7022
-ngcbpc/data/api/UserResponse.py,sha256=uDAjyv-KbcLZVABKh5ju2fbD2rp8HOXyvEHpyBrFz_o,4806
-ngcbpc/data/api/UserRole.py,sha256=ZrVa7wkZFhRWeQdWbudIG6X0EdCDQkZqpMqmAuZ5sH0,6556
+ngcbpc/data/api/UserResponse.py,sha256=5OmUfZO5jRWFBZn1J2IJEjQvzCad1ENyrN60WBPCSII,4806
+ngcbpc/data/api/UserRole.py,sha256=Ljgf8w2QQZJ6Z94BGA9PtO0eoOr0Jm5LH0dt-6OZdec,6556
 ngcbpc/data/api/UserRoleDefinition.py,sha256=P89q-uGSQQ8ICiBarbb5w_M5yEMyjtvuBSaqHnfJpL8,5464
-ngcbpc/data/api/UserRoleDefinitionsResponse.py,sha256=NKAiXw4aA23qwyr0QNN1wN8Fbgu-A_wib_Gwk7rs6z4,3085
+ngcbpc/data/api/UserRoleDefinitionsResponse.py,sha256=30WksXmYjzieUFuBIMZe1fQjC7f-mc0I1Xh0SIZKJB4,3085
 ngcbpc/data/api/UserSession.py,sha256=Nuvgw30MBD_nW8VZzBVSIeSbAmVBqNV_oKtD2qGBBKc,1780
 ngcbpc/data/api/UserSessionResponse.py,sha256=J9n0xAKB0z-Zbeo1LCEGkLy9X2aPlUSL5XL-ymASkxA,2986
 ngcbpc/data/api/UserStorageClusterUpdateRequest.py,sha256=2Hbezbp1DnVz7fNI9QkubiGgjcbWzwDyHMiERnC7YsY,6456
 ngcbpc/data/api/UserStorageQuota.py,sha256=9ZfUcjOBq7Ur1jjkZ3JJL3DZAM2D4X3w-3OUHYrmy2Y,12800
-ngcbpc/data/api/UserStorageQuotaListResponse.py,sha256=ftE2AZ3MzWX0yl99DvRxQeGSoaZyhUqgVEeJ6imhmy8,5965
-ngcbpc/data/api/UserStorageQuotaResponse.py,sha256=ErGrbpv3XjiS2ksiIGBF0-Ba43GTx_jDZSNllU881rk,3210
+ngcbpc/data/api/UserStorageQuotaListResponse.py,sha256=7o9nCXHSACJWD09d6VeYUoL5WZ5IQk-2Lv9Mx1AZ0tk,5965
+ngcbpc/data/api/UserStorageQuotaResponse.py,sha256=A3YNrsx4PabPNZKNfh55RwNPzq67wHrw9i9ybT6raIY,3210
 ngcbpc/data/api/UserStorageQuotaUpdateRequest.py,sha256=hPDn3aeQUvjf85oCSqrdygXGxVWqBIxO0yJheAKtM50,3825
 ngcbpc/data/api/UserTopicEvent.py,sha256=GyafLEQ65G3n65stYL8oc0xD4MUuEoL7ENL43wisCl0,6239
 ngcbpc/data/api/UserUpdateRequest.py,sha256=QB2XwAF7oGaEbXt_CuIrCmAQc5nOiJ-3kh7NLTMLp3s,16740
 ngcbpc/data/api/UsersInfo.py,sha256=gLEr6mMH3HpclrYfy1JjsgM3x2s5GEVjcPqTOAKhs-0,1718
-ngcbpc/data/api/ValidateOrgQueryParams.py,sha256=dw94dOOIOgD_JgpRZnNi45PEt79pI_Z5j0LPB8yDcHI,4635
+ngcbpc/data/api/ValidateOrgQueryParams.py,sha256=C-7gzWjBSCDZII7GFqc1n47Y_RnoBV5sAqibXE9XXlw,4635
 ngcbpc/data/api/VirtualNodeCreateRequest.py,sha256=DsuSdEjwc_zu4831o7JSuzGKuT1D9pkwhC8u4bAWW4c,2604
 ngcbpc/data/api/WebSocket.py,sha256=Vn5SYAWofD1Si4t6CbyJ17d6CCWYId6hNu9UauET_Jo,2873
 ngcbpc/data/api/WebSocketReceipt.py,sha256=VQ0oSQKTB2XpODPKPgfgw8ua4DhVCIeAQ9HYN8mQdAo,3611
 ngcbpc/data/api/Webhook.py,sha256=nVuj_H5icC6bpOzpsEkF3TB17DtYnb3d4azS2uFc3ow,9410
 ngcbpc/data/api/WebhookCreateRequest.py,sha256=3Fjo0WB1Gsayga4mRdvI1v_-OBdNe3kzLG4SfOz-ong,8997
 ngcbpc/data/api/WebhookEventType.py,sha256=OJvyyPDkgFSjVrj85vgGY44TkYl4r4ybI8zbZuxKLUU,127
-ngcbpc/data/api/WebhookListResponse.py,sha256=4Zd2p3iLYsw4I08yLL87GEBID13Fxhv3lh5jS2WETJY,4112
-ngcbpc/data/api/WebhookResponse.py,sha256=wqz0dgAvFsFfnxh96CuKlqZIOh4T4qDNAQkttWOe32g,2860
+ngcbpc/data/api/WebhookListResponse.py,sha256=A5Snn8mXP75lGNIRX4LY5iI9Mf9jnHPEbnlDiWbCito,4112
+ngcbpc/data/api/WebhookResponse.py,sha256=zqLUVeXAknG4gStivRKoPF2Hi5_3lo8cqQ7U3nbOxb0,2860
 ngcbpc/data/api/WorkspaceCreateRequest.py,sha256=qn0yw9ChZhwnZfN6P4rtCp1PxJZZ9ymMZ7NVLC3TgjU,5270
-ngcbpc/data/api/WorkspaceListResponse.py,sha256=zQPy3tGzLYP5sbUHNuJ9kyvms-U-K6eS7g8_2up-CNM,5272
-ngcbpc/data/api/WorkspaceResponse.py,sha256=yRlQMREfzF4te_TPYcZqX7C0CbJ7JSGxddG1jdRrm3U,3019
+ngcbpc/data/api/WorkspaceListResponse.py,sha256=_RqLECGgrvM1o19TNgdX5xTNF3aEv-d-nbtrKXel4Uo,5272
+ngcbpc/data/api/WorkspaceResponse.py,sha256=H5NeRBVpDhGz1jnQk_QhliH0bry_xwscGnNQRDktwsg,3019
 ngcbpc/data/api/WorkspaceUpdateRequest.py,sha256=-yfkRjaJB1gY5FF_IVcTsokIwl3nemyAhb55gWoHbRw,3430
 ngcbpc/data/api/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
+ngcbpc/data/model/AIFoundationModel.py,sha256=kTpusqO33gS65YyXW-e_qv78WIkWvy071TgakHJZ7pw,7525
+ngcbpc/data/model/AIPlaygroundCreateRequest.py,sha256=_Ap6coh66ZEOdVR02VBhjH_7BUYrq2RmXeb2dp1FU7Q,4299
+ngcbpc/data/model/AIPlaygroundResponse.py,sha256=V4QgmcxZtoEVjQy2r-QiEjAd-URpTtDX-5yVJK3GOOo,7548
+ngcbpc/data/model/AIPlaygroundUpdateRequest.py,sha256=ieB3R2gP0sYUToXcBylzm7vHERPFLKLEGHyFTzTkWzQ,3461
+ngcbpc/data/model/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
+ngcbpc/data/model/ApplicationType.py,sha256=1Rzy9CYud3j7XY0o-uefAZRzeBvDL2U4qMzfT-SQhGs,552
+ngcbpc/data/model/Artifact.py,sha256=_Q2eg9SZXSf8h1uqEocRZnPYeeDmfvbbVYhUCWd-SIk,24085
+ngcbpc/data/model/ArtifactAttribute.py,sha256=jIRENKZZZ6bHWVHCH-IWzlpGJ9JU57zNbp_aD7WvBvo,3124
+ngcbpc/data/model/ArtifactCatalogFlags.py,sha256=cCCw1TEucNeUUO5jmyWexiS9-ub9PxulmiVp1jvM04s,3524
+ngcbpc/data/model/ArtifactCreateRequest.py,sha256=HetC3O42HFuh_zg7pCmroVJ4Ly2A6QcAbc-pDsDqn1M,15113
+ngcbpc/data/model/ArtifactDeploymentParameters.py,sha256=KeoflmcdqMf0FfJk5uCnuAypqXDuJIOEB0_54Jau4FA,9003
+ngcbpc/data/model/ArtifactDownloadAllRequest.py,sha256=ykNhDhoFYa42BVOrWmEyZj4FzIcmQsqgNPJU9IO527c,3853
+ngcbpc/data/model/ArtifactDownloadAllResponse.py,sha256=_wmW1idfSsjmD6SMlVQVdgBEtCdEUprat5Ga8Vcu2oY,5910
+ngcbpc/data/model/ArtifactDownloadRequest.py,sha256=Swl61UiL6GUvz5866lRWm82Pt3eYDofgWN9BB6miZFw,4808
+ngcbpc/data/model/ArtifactDownloadResponse.py,sha256=vsaxqA5lh9wSvCTWKfE4waHqQZPb4mjZ6M6v-_gavgo,3732
+ngcbpc/data/model/ArtifactEvent.py,sha256=8S-JqnL0d2Mjq5nX05CNzsn2nkKmboNxT1H1wAPE9x0,5414
+ngcbpc/data/model/ArtifactListResponse.py,sha256=bT0rOE9JHvDeK0ebFY84K3XfVQoMojPLF3DuRpAbtB0,4148
+ngcbpc/data/model/ArtifactPublishRequest.py,sha256=43I1q_rQnPAhbdqFOHnmHOPTLobepvZbQcremx8j8D0,4967
+ngcbpc/data/model/ArtifactResponse.py,sha256=DV3OyXq0koGadpcDlbQJ9IRbH1f_vAPw7jce-HQTV88,2961
+ngcbpc/data/model/ArtifactTypeEnum.py,sha256=o3G8-cGrsfhDmnoCoTjGKiKxl1G_fBhJhvpq-xtvwXY,146
+ngcbpc/data/model/ArtifactUpdateRequest.py,sha256=UeJzrvWJNcToqL_UyN-fL9ZNQLEABPDKXwy2xiEfKUo,13199
+ngcbpc/data/model/ArtifactVersion.py,sha256=IyJE1XPHzsbwQlqLGoSZIU2EaAQYaH2iGTMq63XCZ98,10576
+ngcbpc/data/model/ArtifactVersionCreateRequest.py,sha256=68j5AibJoVCZHPcfduKMMoPQlhfmsVCwjCmNDGLLN1k,3799
+ngcbpc/data/model/ArtifactVersionFileListResponse.py,sha256=-yNQf4piO9B838iE4jFwQW4hPGKvjhDFi_hDh6mSAJ8,6261
+ngcbpc/data/model/ArtifactVersionListResponse.py,sha256=AggD3UJ0ZASoEzOWxmQ7Vq--1AyTJloFbkP6iGlhknU,5241
+ngcbpc/data/model/ArtifactVersionResponse.py,sha256=K-tZG_oo-Y8VtL3x8i-K_TZaDDFy-gpyQax11-y-z5E,4083
+ngcbpc/data/model/ArtifactVersionUpdateRequest.py,sha256=5vZaCGmeBpebLcHFU9sv3WxGYBbHaoc1811Vu9njkVc,3979
+ngcbpc/data/model/Asset.py,sha256=xhhlHvO0JEqB0YU6SP9YOiw9kUBBEQEuM8heaQKRW9c,19418
+ngcbpc/data/model/AssetCdnProviderTypeEnum.py,sha256=jlBQlBx72yPyp54ZiAAVC31pdLhfVXFE683mYHMpOhs,114
+ngcbpc/data/model/AssetResponse.py,sha256=o52azOC6we6VIUaMZwWI-mZWzb61Spkl_rNyIsAiQ68,2864
+ngcbpc/data/model/AssetSimplified.py,sha256=izrf1BXuf0jAAjrtQLYKqsH3RL3wXtU_jzWIxTKmcN8,3575
+ngcbpc/data/model/AssetStatusTypeEnum.py,sha256=J4GY68RLLsyKKaSbwXQPlIk4zjtGhzFlE4mxE9AZ8Ak,141
+ngcbpc/data/model/AssetStorageEvent.py,sha256=ebmpp_RdRYPkbLk1zkiUsMiEVv59MVT0Zbrj-zsxExY,4470
+ngcbpc/data/model/AssetStorageTypeEnum.py,sha256=lTgUup8hMDG6J0yaerqlhmC4oB84RQa-wKFW7b-lri0,97
+ngcbpc/data/model/AssetUpdateRequest.py,sha256=KrC0Kz5ZwC5d59xPtW_Z4905aiZaS_61odPwxMNsuw4,7178
+ngcbpc/data/model/CatalogArtifactMetadata.py,sha256=wTXuWXG9d8pdcl0kSK3-rVvSrPy2xv9MBbOQ_fCRiO8,5084
+ngcbpc/data/model/CloneArtifactVersionFilesRequest.py,sha256=xDCFJ2sOZHHIFVwbjx8Pj_VYkC0IZkrZ1yKoWc2UqtM,3994
+ngcbpc/data/model/CloneableArtifact.py,sha256=5KRa9dzoSF--9_HntvfQLDM3f9SUZF5Amt592y7zEHo,3916
+ngcbpc/data/model/CloudServiceProvider.py,sha256=OlUdf7EiY2itAB42W5rx5ZOtegylBrzPp77UG7MgGSQ,10280
+ngcbpc/data/model/CloudServiceProviderCreateRequest.py,sha256=1yDQUMcTQZVvhME2PZg1EG_qN9aCrK95ClIjMaqfrYM,6963
+ngcbpc/data/model/CloudServiceProviderListResponse.py,sha256=YUg2PgXh0eq4Y-dBmDsmat5ypTvIcBqOXMTTdCUL4Es,4414
+ngcbpc/data/model/CloudServiceProviderUpdateRequest.py,sha256=ysDbQkdIB9Uch7pP4DT-2Z6v5YWA8JO-KQIOS97NN2U,6037
+ngcbpc/data/model/Collection.py,sha256=znIQvnU9yppEMExzzaC5VATyBphjdi4_C3AP06VQqOM,18935
+ngcbpc/data/model/CollectionCategoryType.py,sha256=ef64cWHNiLxyTcqQ8E0fPV0bKvb9ZroPNxe6na8h_1M,510
+ngcbpc/data/model/CollectionCreateRequest.py,sha256=mPssBNe3GAJItIxAbrFM43pvomDzlnNcvMv8CD0jTuc,13636
+ngcbpc/data/model/CollectionListResponse.py,sha256=DdlZA9G1DqqterKtSpogFtT27FawfJfbKLB_96Knr_I,4192
+ngcbpc/data/model/CollectionOperation.py,sha256=j0BiL1cXfWjJh72ZPSKC9Gsqs9BGczWvbcNuMC8dWDc,3343
+ngcbpc/data/model/CollectionOperationType.py,sha256=QCgIH475WgYjbjcMUe8uyReWMTVPqTFVNuIl_NJYEHg,131
+ngcbpc/data/model/CollectionPatchRequest.py,sha256=LZlPfmFX4iMr2KKHfQs1Y1v7HzjiodhqM7zUtmd32u0,2338
+ngcbpc/data/model/CollectionPublishRequest.py,sha256=SLf3xIO0kna94aF7Ug2toNLDURtpbuT87RgHL0mdTcg,4970
+ngcbpc/data/model/CollectionResponse.py,sha256=C9bKXUnRvrNE0nSUopYaW0XTqckvyqhW4vXO2QQDb7Y,3020
+ngcbpc/data/model/CollectionSimplified.py,sha256=w900yJcwEYzBX90SQ3HX8Isuh9nZ3M4bRvwvD53A7Pw,3610
+ngcbpc/data/model/CollectionUpdateRequest.py,sha256=KpkFkcpE1VHCV1ayJOtZc-xTCl_8Dy1MuNetj4zs3pI,11520
+ngcbpc/data/model/CountableResource.py,sha256=OFu6lGeuiX3CkKPJbBPqgj7BWvz-LYF1pzoAEzGUH7I,3329
+ngcbpc/data/model/CustomMetric.py,sha256=AjM8-JV-6oxEcjNDcHehjN0cf10jxttciV1lIM7QXJU,2799
+ngcbpc/data/model/CustomMetricGroup.py,sha256=fGd5W4dGxtQ4bgH_Tt_3QAe8TBUuoA7NehR9nK9zDTo,3003
+ngcbpc/data/model/Dataset.py,sha256=IpsCVnx0h0JmEAMqX4XklW21aFeBAjU1q8h6MdOcz1c,3803
+ngcbpc/data/model/DeploymentArtifactParameters.py,sha256=g_wt3bKOah-JC8II_dE4zE8fBTyq6IH4JSdzDa9mC-w,6861
+ngcbpc/data/model/DeploymentCpuParameters.py,sha256=lR9Jn5CozL7YogLTHp1EZOgby-5IuhRau1YyebfH1ac,1683
+ngcbpc/data/model/DeploymentCpuParametersMeta.py,sha256=RADfy2x7mBrSvfvTbo6zuPhdNJkn6YbF0eG7QZAPrMI,2160
+ngcbpc/data/model/DeploymentGpuParameters.py,sha256=aYGe3rRtcjSP1Y2DK5E-ENe2z4G_NrcOrQuRlN6MTlA,2387
+ngcbpc/data/model/DeploymentGpuParametersMeta.py,sha256=oLINmKxIbwdq8R33bIo49537ZibiYtAUZc3T-9X14_I,3127
+ngcbpc/data/model/DeploymentMemoryParameters.py,sha256=7UZfDDxEkCcqLwC3wIBoqKe3XUg7Og8l3ke4ORs1giA,1787
+ngcbpc/data/model/DeploymentMemoryParametersMeta.py,sha256=Q2DXY6YpBfwi5zfsaTN6ofhD8UhiKiFBfaCSN5F6R9E,2288
+ngcbpc/data/model/DeploymentParameters.py,sha256=Ny6Dvd7L4KwCAkOsd0Ratq1cBB24EP_Zk90D0xCfc7g,8995
+ngcbpc/data/model/DeploymentParametersCreateRequest.py,sha256=e55lfXApan-rdabzx9a2Xu5eNcDfgJ3ClYLi5qCjyVw,8305
+ngcbpc/data/model/DeploymentParametersListResponse.py,sha256=olqViaq8rI7n20YfV_dIoIvE1UMwHN4_aV2fcMpVmIE,6237
+ngcbpc/data/model/DeploymentParametersMeta.py,sha256=Pbsu50elh39YpWxIOfU0PtMoSe59uuyTyL2pbBSFsfs,6125
+ngcbpc/data/model/DeploymentParametersMetaCreateRequest.py,sha256=aPQGEyVkYAIXC9iL_Hm0SEPlfPE3kKh-djjsRB9jVPQ,5840
+ngcbpc/data/model/DeploymentParametersMetaListResponse.py,sha256=7AlB3oRpfpWFnZXv9GWTo95gmNYhnbbs-vT49EDo_rs,5216
+ngcbpc/data/model/DeploymentParametersMetaUpdateRequest.py,sha256=O7tK6ahf4PsstxO8IqvHiFtFd8ZN1cAzAXmlsdM1MK0,5458
+ngcbpc/data/model/DeploymentParametersUpdateRequest.py,sha256=5lQc8shASTrzvHlTAGU1WmNhPRdLEeGy1Iwt4MB6mFo,8308
+ngcbpc/data/model/DeploymentStorageParameters.py,sha256=unx4UmyhBLE-XBFZFwTJNrb9YRutlyb0GEsltjLWot0,1789
+ngcbpc/data/model/DeploymentStorageParametersMeta.py,sha256=PVtEcwZj1VYM_qlLkdjpieTx0cTnagNECnezUywEJU4,2291
+ngcbpc/data/model/DeploymentUrlCreateRequest.py,sha256=y1AAX46ruEFOIlr7EpIydqPJSCSoesAAtJcGSSdVYzA,8291
+ngcbpc/data/model/DeploymentUrlResponse.py,sha256=oVvEO6SSQUPpLsGRgquwmbuBleBFb99YZyX-zWsNnCQ,4823
+ngcbpc/data/model/EnumerableResource.py,sha256=lDqvzewGiqj0gawovVS50RtuxGQxAN2Y3FjBWMJp5aI,2941
+ngcbpc/data/model/EnumerableResourceItem.py,sha256=tv_WkawuyeZxK2EZR6HuLxMrhHnVOAD37A7vmzXfP6I,3164
+ngcbpc/data/model/File.py,sha256=TaS9-ns4mXWMl50xdMFtoSqzrPVWyIcsklwCf-vXw1s,6436
+ngcbpc/data/model/FrameworkType.py,sha256=yueiSgyJx005LIRMzS_XwxvH0b8wvtDu27A155T09dM,197
+ngcbpc/data/model/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
+ngcbpc/data/model/HealthResponse.py,sha256=TCGXNJKL6E4X5xWh_SeRtTK1ASZg9mS0Syb6z8Hrtjs,1989
+ngcbpc/data/model/HelmChartDependency.py,sha256=J6Aa1oBojPxLsAF92kc_oRBLpp7OADikuo8Ll4d9PX0,3845
+ngcbpc/data/model/HelmChartMaintainer.py,sha256=mq3Thxbg6Pj_kXbQctFNKjUYtGXsZ1aJuzDR2_zqJkM,3171
+ngcbpc/data/model/HelmChartVersion.py,sha256=6lvRVstbyq94Q__AVT-1xvBpP_C6KllY1rPffB_6VuE,12667
+ngcbpc/data/model/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
+ngcbpc/data/model/Model.py,sha256=Fcox0ULEoUPpgE7tfi_X7JPLXKVgcFbuxPwHL3KS2is,30696
+ngcbpc/data/model/ModelCreateRequest.py,sha256=GhxCl7EmYToNivBmeRy63Q7lOe_yY8MKLS-KQLgZib8,22262
+ngcbpc/data/model/ModelCreateResponse.py,sha256=FHVU2xtEpJS1VhVRtitjMletTynWNpVgt8aee1dBB_Y,2882
+ngcbpc/data/model/ModelFile.py,sha256=V8rim7bTmLdHKwJipVK_sG55oTJOTZTG_Xl_2HJbo7M,5242
+ngcbpc/data/model/ModelFormatType.py,sha256=D84sZV01TsKkP2DdWA01zyPQ-X8XD2dzIbKHwe_EXyQ,221
+ngcbpc/data/model/ModelListResponse.py,sha256=EUWAsB0WTdUsNXA8QFLLMM2YbC-8Bj2MLx5YgLx1MVI,4063
+ngcbpc/data/model/ModelResponse.py,sha256=0444F2gTM4Dk7WoqMUX021_2DdliWDDY0eOLhn3gBUY,2871
+ngcbpc/data/model/ModelSimplified.py,sha256=Cx1SSUb5WcgszHaKQsU0jj-T_9sQ5kTIzs9KKGNvbeQ,3575
+ngcbpc/data/model/ModelUpdateRequest.py,sha256=aNLXiqQnzmSg9cIBo6eCEs2BuzZX_V6Tc88MUjsWcHE,20197
+ngcbpc/data/model/ModelVersion.py,sha256=_EY63zw5QrmA15PDIPXAV-hnvmM4_uPb70Tg8uaBvCE,15426
+ngcbpc/data/model/ModelVersionCreateRequest.py,sha256=2AQ8A9n36h2tI9rWaNbMti0rkVQ86FJFWe2eiu6l94o,13578
+ngcbpc/data/model/ModelVersionCreateResponse.py,sha256=2Eet6BO8gttx0VKkXTGd6LoW7bW0GeCTZp-zFqXQOCk,3924
+ngcbpc/data/model/ModelVersionFileListResponse.py,sha256=-bQhdAaiD5nIctGK700upBXpyEbjdG1DTJawSMDbD4I,6072
+ngcbpc/data/model/ModelVersionListResponse.py,sha256=tlJvd8A_2E3Wf3A7Etv_FkBEXu1iCmS06vtClQ6uydU,5084
+ngcbpc/data/model/ModelVersionResponse.py,sha256=7azIYz5pRhLFyERREa_v3OstTOH4EVh9eHD45QLOJdw,3923
+ngcbpc/data/model/ModelVersionUpdateRequest.py,sha256=QDm_DhVnMBzvpqHb3EnatHgM-j7LS5Eo3Ih-WMG_sa8,12069
+ngcbpc/data/model/MultipartUploadAbortRequest.py,sha256=VfdE84KaGbEgfJYrqJEE8Bp8jwkT_PEqGwNBOE7f-q8,5878
+ngcbpc/data/model/MultipartUploadCompleteRequest.py,sha256=mdVeBuBo7f25MMJb9IEWUdRB3r2FfO8P1ue-QBe-1Go,6906
+ngcbpc/data/model/MultipartUploadCreateRequest.py,sha256=uX17zPYGuTfoXqAby2E8N49KMtHhWIlr_PI_2s-iAGA,7401
+ngcbpc/data/model/MultipartUploadCreateResponse.py,sha256=IslhvYP93gErxhIxvCKr8OWu48q6LfydzuCCX56JrIM,6049
+ngcbpc/data/model/PaginationInfo.py,sha256=RzvaVvJXG6Zr-xlbGXL0uXZpdzkPRdhrt-IuOkvX4ak,4827
+ngcbpc/data/model/PrecisionType.py,sha256=cmhvPJ8RtTAIwVhMhEe5_8Ls9pIxm2tmhf6yQlB-6p0,130
+ngcbpc/data/model/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
+ngcbpc/data/model/Recipe.py,sha256=NX0vvSJhkLit-nvDQu4gRPKqSiTKKYHqdBhcj2v_OGk,27541
+ngcbpc/data/model/RecipeCreateRequest.py,sha256=OTpvxFn7ek3hrvxFU4vui4Xwz5l-WZ8SBp2lcZGmqPs,19453
+ngcbpc/data/model/RecipeFile.py,sha256=e0bWmWORZYN70yuYxQaDO7GSeBsDehnzwAn0fucbA9o,5249
+ngcbpc/data/model/RecipeListResponse.py,sha256=aNYEkeRcs9cQ5Ai4rSyk4pvJVDMWF2T7jyHfhP5sX9M,4085
+ngcbpc/data/model/RecipeResponse.py,sha256=VTmx9o4mu5dZgEjyTsgCn4l99sYaUY8ixrAuqC3-yeE,2890
+ngcbpc/data/model/RecipeUpdateRequest.py,sha256=SkNfkk-bm5M6vVFv5swiOBRt0XM-rEqIdZ90wbE2-yA,17702
+ngcbpc/data/model/RecipeVersion.py,sha256=q2lR5D1tR6cfxtiw9NqILuCjMYh7tW6ETza5zxxY-wk,17930
+ngcbpc/data/model/RecipeVersionCreateRequest.py,sha256=EJi0StY15XBwfGuH5XfEWD5RPAU92IvP5REvFCWnnrg,15539
+ngcbpc/data/model/RecipeVersionFileListResponse.py,sha256=5F5PtjSBsDwukALx8JMTmgC6VbZ2pk56aiRel57722Q,6142
+ngcbpc/data/model/RecipeVersionListResponse.py,sha256=oXiD8Px224BDH9ybv6wqrBd4QhlttwtwVo3Pmxt7Tvw,5130
+ngcbpc/data/model/RecipeVersionResponse.py,sha256=DeTPSqB0zBU2MJ-0SSDqhgOprOIJ8fg_c5oNVjdblGc,3964
+ngcbpc/data/model/RecipeVersionUpdateRequest.py,sha256=MsOruRjxKfqsIB9JncJt0FKLkHScD7dK1C8MHFnp5a4,14027
+ngcbpc/data/model/RequestStatus.py,sha256=Jq3gYldBXwGxu_UuxYr9X4z2Oi605GGdQkd_Bv3MDws,4213
+ngcbpc/data/model/Response.py,sha256=HOoZXNJjLgX00gaxkVHZe2Y_dVUkXbByMEITu9plZ4E,1976
+ngcbpc/data/model/SortOrderEnum.py,sha256=4aV4ylYKrkEMuH2WJ-5dbGQ2LPfn5DZDkPCEY9QkeLg,358
+ngcbpc/data/model/StatusCode.py,sha256=0W18iCZ2YXBns50nPxIm589M60KMl3iFfSNMbBhajtc,359
+ngcbpc/data/model/VersionStatusEnum.py,sha256=16XhUlqs3BngXFOAsHaSyWJ1PD8wfhxMg56U3mEAMSk,121
+ngcbpc/data/model/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
+ngcbpc/data/registry/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
+ngcbpc/data/registry/Actor.py,sha256=AUfYxuH2rtp4woY6ivSE3lvvQGLf1nHBnqsk67XhO74,1719
+ngcbpc/data/registry/Allowlist.py,sha256=eytnw0QyXSwd8ClBv0YoctZqx9gh6zIQKZmVhw36x2g,4859
+ngcbpc/data/registry/AllowlistItem.py,sha256=35I5N9gM74KbWC103DHxY6T5b-MXhFzVeNIrPPDU1f8,3193
+ngcbpc/data/registry/Analysis.py,sha256=HQRbATkCVOhSJvR78w11X7B31o1U-3JP1oueIy0npuU,4036
+ngcbpc/data/registry/AnalysisStatus.py,sha256=5qv3dPNKDDCFMnA2hjft8pN7JvRLQEAYnMFgMn1H-WE,139
+ngcbpc/data/registry/AnchoreParameter.py,sha256=pJxGGkkOXc1CW-vr2eqBidnvHfUzo5vKvWEixTay29s,2347
+ngcbpc/data/registry/AnchorePolicyBundle.py,sha256=ZIBg6q7IHdrb1y32afzIYXI8K2Znz-s5rCmtv4gHdAE,9910
+ngcbpc/data/registry/AnchorePolicyBundleRecord.py,sha256=xnnYC9EB34g0dqhBJ9JwSi0xvZ8DdEGu44ZiAN1dfb4,6971
+ngcbpc/data/registry/BaseImageDetails.py,sha256=NaMyN4vKROcrKBI0wGJR4HUOZFmTYJ98NJv8OBm1wjM,5543
+ngcbpc/data/registry/BaseImageList.py,sha256=srvhsC168L2MFZcm1DY6PEiTN79wxTjgjSAaENbRlao,1732
+ngcbpc/data/registry/BaseImagesDetailResponse.py,sha256=tyW2bp0RTVhXcZCdbt7C1VRN9DnRZtTaTpAcknPCLhY,2142
+ngcbpc/data/registry/BlobSum.py,sha256=z3EuP_aWSjNBT7vaD81NzXwsKtti4g6FBcCykjDncEg,1666
+ngcbpc/data/registry/CatalogArtifactMetadata.py,sha256=7R2bWdJ61jbDm1zTybzWKxvME9MzUCACM4XEUgFwms0,5084
+ngcbpc/data/registry/Envelope.py,sha256=jaDenZpAkomi7u3HYd_fwMndnfp3givDa_ejgPsX3L0,2020
+ngcbpc/data/registry/EventRequest.py,sha256=Qs9c--lLaInosdyweN_95chG674V5btPoJD0Sw3udf8,4956
+ngcbpc/data/registry/EventSource.py,sha256=rJ0tGwOVv5PUMJIXLRqZfdzFe9Axy88eLphQG0q2wTU,2664
+ngcbpc/data/registry/EventTarget.py,sha256=C3zsjlb5fGrV0OtjgxFlqa7n_81CsuI8WRkERTAUMw0,6419
+ngcbpc/data/registry/GetManifestByTagResponse.py,sha256=0lu1WB50roONsUbWZUWgjClSDvDYomGvW2SIiANLERs,8208
+ngcbpc/data/registry/GetRepositoryTagVexResponse.py,sha256=AeNQnLBBaCIJ9paFNy_JT__oGERoymbU1TKmz7grWYY,3749
+ngcbpc/data/registry/GetTagsResponse.py,sha256=G14ssIh6bvFtvI-JHyGtaamZOB-eMDxT_0EyX6ZSfvA,3392
+ngcbpc/data/registry/Header.py,sha256=tMjrWGoaQZbBAUz1gmrdMd3qS84-bSuvz9SLKtQj6Os,2451
+ngcbpc/data/registry/HistoryLayer.py,sha256=UGtTRLH89WXqLFe-dNYoBbj98I2TpBalo7eJGAC1KOw,1797
+ngcbpc/data/registry/ImageArchitectureVariant.py,sha256=A-9gedZB8RWRCbSR8NXykOj0ezIDSPouz6q3rb_Tqao,8463
+ngcbpc/data/registry/ImageDeleteRequest.py,sha256=S5Wo3tRRghXE4niwXFa5YhWfbnJXRzknVjSPTi0GCl8,2972
+ngcbpc/data/registry/ImageOwnerDetails.py,sha256=CXtPp5HVWIRunURaONIdFHTfHI8l62FXEbnIRpRbcLc,8722
+ngcbpc/data/registry/ImageRef.py,sha256=i4gPb7UIGw2vH1Q5tzC5s7NekMDkRRfM0Yielfp193U,2342
+ngcbpc/data/registry/ImageScanDetails.py,sha256=7cfWjN0DeUgC4FKnXg_lrYaAg5uly5XNu9ZlaHn70VM,10863
+ngcbpc/data/registry/ImageSelectionRule.py,sha256=6f3Sd80s1iAcA061qnVLbYYkUwfPaT0tOaywlIWojHc,4699
+ngcbpc/data/registry/ImageSignature.py,sha256=mwrzuDZBaE3AFOCaZg9aMA4KLKIPA3v4Og7yN9A2XYQ,2557
+ngcbpc/data/registry/Jwk.py,sha256=0bcdKYmZAurVoLV-AVJ2jKpb_7jmxQJWCCZgPIRwaQ0,4468
+ngcbpc/data/registry/ManifestByTagV2Response.py,sha256=8Au9GTUkMQHuKsYHuX0yGsBFhCycvhz33IckgnkpO7s,7637
+ngcbpc/data/registry/ManifestListByTagV2Response.py,sha256=9qav6M9ywYqopITrOxNBW_HVB9LzOQ6bk-mf-hjA1rs,4764
+ngcbpc/data/registry/ManifestV2Config.py,sha256=rD16GvopMwOGbf4QaAq1-2IH6suZPg3mVvqjhC4_H5c,3209
+ngcbpc/data/registry/ManifestV2Layer.py,sha256=U685c0wqqAtcUju2Vfy5NA2xqSlUzb-NkvaWRiPedUA,3186
+ngcbpc/data/registry/MappingRule.py,sha256=Vx-HeLrhCNZ9SHVEpUB2ESxU__X_UCHwMrUqcycEdWk,6468
+ngcbpc/data/registry/MetaImageDetails.py,sha256=TtFiMOBYH_fU-6dIUP-vtabwGjNNs1oQUb_gYO1Bd5Q,12531
+ngcbpc/data/registry/MetaImageDetailsList.py,sha256=Qvtd2eJ7DBR1gjFxm4U0dmxWaDT31-x7T3-nhWBQ-3s,5927
+ngcbpc/data/registry/OciIndexManifest.py,sha256=NIbH1dJa10l-Kv3AfgwjJjxpIRfJYQj0KduM8D9aLSk,3998
+ngcbpc/data/registry/OciIndexResponse.py,sha256=xiw9juPIdrNmJgTeu6wnsk7qNhmZKiMJHRoIuQNr3QI,4703
+ngcbpc/data/registry/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
+ngcbpc/data/registry/Platform.py,sha256=mSKlUIpALQuuTAxcs5j23MFJPXEJV937GS9ULNn4k-E,4309
+ngcbpc/data/registry/PlatformManifest.py,sha256=8u0Et6JY9jBY-TSVSljP_OFzQfMskE8XWwtsfBkXglg,4840
+ngcbpc/data/registry/PolicyRule.py,sha256=A3_bl3qGzs485J7uPhCcGJBb1LogKR_qJYP2NOCKYuk,4845
+ngcbpc/data/registry/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
+ngcbpc/data/registry/RegistryEvent.py,sha256=Ap10g3E1WJqLwPOETBne_iYLE4kzkPcUo8qAQqYS--U,6858
+ngcbpc/data/registry/Repository.py,sha256=I_pco4K1Q881pH02CRoxIkp8KZOt63ULfIuzgbTKlSU,27728
+ngcbpc/data/registry/RepositoryCreateRequest.py,sha256=7NjSz_wiHKT85GzpFlFlSBPj58S2u1TpAQUT-xkooRE,11157
+ngcbpc/data/registry/RepositoryImageDetails.py,sha256=kOfV5joD8Lg_fYJyVkrlRUlalxI0DQavH9Xb2mWuvXQ,11907
+ngcbpc/data/registry/RepositoryImageDetailsList.py,sha256=hyeNXEAAIrG7Xxr7ZokAtP-8ybktm6dsHFzV-PuwZUg,4159
+ngcbpc/data/registry/RepositoryImageScanComplete.py,sha256=NNvJ6dRSWuGxYT9d2oBFx-Ob59AwbwpLBgeQ_xV4IBc,5902
+ngcbpc/data/registry/RepositoryImagesDeletedEvent.py,sha256=UlqUlzuJjUCjHT-dam892R89gvDjr7VxR93cA7iITf4,4440
+ngcbpc/data/registry/RepositoryInfoUpdateRequest.py,sha256=VxszdStgEPBE200EBmr46ymosjif5HGMNMR4mwRce3s,16048
+ngcbpc/data/registry/RepositoryLabelsPatchRequest.py,sha256=DHp3GgH7m75_Va371Kjq7ioZuOX8RRDGK785o0EC99c,1677
+ngcbpc/data/registry/RepositoryList.py,sha256=GoFkz2SriDI6jUtXgXSeQctBLbS1KkDGXu4FUjEelIA,4182
+ngcbpc/data/registry/RepositoryTagVexByDigest.py,sha256=0jVKReHqrSaL05R2-MQfWoYXMolqdmOFWxbGakU8T7A,2672
+ngcbpc/data/registry/RepositoryTagVexDetail.py,sha256=OMS57-bRQeHNn3C8c3mK6jDA7CnLMpnG1IlJjgmxSYM,2528
+ngcbpc/data/registry/RepositoryTagsCountResponse.py,sha256=eZj52OgKEdOiw_c7EEj44H3GTtFGcmVvlMh8ZzIspIg,2758
+ngcbpc/data/registry/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
+ngcbpc/data/registry/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
+ngcbpc/data/registry/RuleSet.py,sha256=lsIVPadWaC_otsLmfViQqnF6Zkxsncgmf34IvyDm9OM,4870
+ngcbpc/data/registry/ScanIssue.py,sha256=VRUYl7L9c8bmwKGvVW1GofhQKjwNa8rdHMG2F7ccJhw,7489
+ngcbpc/data/registry/ScanIssueCount.py,sha256=CwabKHFESi_14BSMbWCtNhVosrZaxTsJMHEwZy2a46Y,2486
+ngcbpc/data/registry/ScanIssueSeverity.py,sha256=TeWv3WPwbmTZZQlcUOgZjwm20Y6Ha8aw8eSeGD6WHzw,137
+ngcbpc/data/registry/ScanStatus.py,sha256=QE_J1OKnC0s1yfqToiD8NxOctru0TrIVc0ATqhaM7ac,138
+ngcbpc/data/registry/ScanType.py,sha256=yfXyugvM1yJk3Mc3nWVhEP8PrllFt0qa6JySUExHHu0,102
+ngcbpc/data/registry/SecurityRatingDescription.py,sha256=iaHovjUiCFA_rUr2r87B5BYBk7t_0XvlaupcoyOemw4,7621
+ngcbpc/data/registry/SecurityRatingType.py,sha256=J5dQ2NHAtSKum35BJfR2HgXr0VmndhRW3rQxgB4tanA,119
+ngcbpc/data/registry/SecurityRatingsResponse.py,sha256=bEjpOcFkNZ0KpBtSPamHmrkkqImP1Lw3uZvveE6cyrQ,2081
+ngcbpc/data/registry/StatusCode.py,sha256=Y64E0Wqv8Gd1H9MdK7pNmKbzPWsWk-yFGUarCtzIvPw,317
+ngcbpc/data/registry/TagUpdateRequest.py,sha256=E8CqdCAXbooqf8MbVVKkUzjj508TWITroaHNFQ6N1SA,1766
+ngcbpc/data/registry/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
 ngcbpc/data/search/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
-ngcbpc/data/search/CountParams.py,sha256=9nNc6358W8_tX99N4rExngnELJidWQDYYeuOWDRcrKM,3344
+ngcbpc/data/search/CountParams.py,sha256=PrbWaKEGRI7rCK1nK_F1G6uQF5Nxy2JciBHz_zqJ-PA,3344
 ngcbpc/data/search/CountParamsField.py,sha256=jD-p10t0z_lLlqVGz0GMWN66Mhh8dTatrXRQOnQjulU,3146
 ngcbpc/data/search/CountResponse.py,sha256=Jgy3u0yXZOPwrAAEvljOESTcbvN9cxCpvZF__6i3_0E,3360
 ngcbpc/data/search/CountResponseCount.py,sha256=RLgYD54546Me7uNGc0A2eFL3ndvm9f3rDcKw6OskSng,4031
 ngcbpc/data/search/CountResponseParams.py,sha256=1Q877WfxqY1hf3YR4_LEFPEeSkNWiEht_TQxJOoEyKY,2046
 ngcbpc/data/search/Health.py,sha256=qTDVz_yi0kQWdL-9M09vtjFPZm_GJswySbhp2UBELXo,4468
 ngcbpc/data/search/HealthResponse.py,sha256=TCGXNJKL6E4X5xWh_SeRtTK1ASZg9mS0Syb6z8Hrtjs,1989
 ngcbpc/data/search/LabelGroup.py,sha256=J2l29QDClPqv6EzT3X4b4QXV3Oao3By5KkOIM4pDtis,3689
 ngcbpc/data/search/LabelGroupValue.py,sha256=E2YrkcTPJ_me3ofkz192lN9RyIGa9EMexi9zDAH9Gr4,3647
 ngcbpc/data/search/LabelResponseGlobal.py,sha256=FyOpWpyxjPwKHKhBZ4C2jctQXuu1Zz2jROXq2qY7nF0,2001
 ngcbpc/data/search/LabelResponseOrgTeam.py,sha256=pFkd4gzOLUgXRm51dAIKvUhp4gEyMzk1vB8VBflh6Uw,2842
-ngcbpc/data/search/LabelSet.py,sha256=tL8hZmN00PoXy9Sp1Bo6RBTEPbFSEjRb-SIoFXSUr3w,9026
-ngcbpc/data/search/LabelSetCreateRequest.py,sha256=rHNsMCfAPY3L9c4VZUKORLOMHJN_lddndjCtb9YJObQ,5850
-ngcbpc/data/search/LabelSetResponse.py,sha256=XCPvO5uC57zgSuhKeaSfaaiefTMZiR5cD4oYZrRXu-s,8710
-ngcbpc/data/search/LabelSetUpdateRequest.py,sha256=IJnxodgUrcrMhmA3beGE7oOUOWYRVMIWe8tSOKmbndY,4151
+ngcbpc/data/search/LabelSet.py,sha256=0bcIoczaw3qY1ZABVRVHEOWTXmU00n61kum1xJBxHbQ,9026
+ngcbpc/data/search/LabelSetCreateRequest.py,sha256=o3lO5c0lyeldBQP96L1Zf3VlmqAU2F6lOkGIcUWIHAk,5850
+ngcbpc/data/search/LabelSetResponse.py,sha256=cgFCTrkRHvRga9D8r0g-bb-bkIozO5OY1GMx3WVD8do,8710
+ngcbpc/data/search/LabelSetUpdateRequest.py,sha256=INEgbf08zYc74LIPynQsKhKMUPM5PcwAmro7iizjRag,4151
 ngcbpc/data/search/LabelValue.py,sha256=sULQI7_MryjaoodA_IRfmon7UzzRf09x6mC2LZFr-e0,3461
 ngcbpc/data/search/ListLabelSetsResponse.py,sha256=1BDDa5E5JWw4UUkGWClOj8rVHTNgTH7tM-cI0D-SmtI,2018
 ngcbpc/data/search/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngcbpc/data/search/Resource.py,sha256=sLeF5JhT1RzuNbTRFijecz8Rk4Qo8oI2PLMNBMAiNHI,23861
+ngcbpc/data/search/Resource.py,sha256=JnfVK1MJhvFgm68DfEGrTmd04QpfLu1Lv5ft3lsNJ-g,23861
 ngcbpc/data/search/ResourceAttribute.py,sha256=fWBw9vzlE020PiNGQaKdu7e-RrhDhee8xpYD-EX8Gek,3140
 ngcbpc/data/search/ResourceEventEnum.py,sha256=48YARuDp7CnAikDnkkHsvhDAPbHlRH-VAlBRgSQI0Mg,113
 ngcbpc/data/search/ResourceLabel.py,sha256=INELLDOVXLGl0TUqPihcVpaTu6siI646bZc1YOSnF38,2891
 ngcbpc/data/search/ResourcePopularityTypeEnum.py,sha256=3ecszGo1Sbt0MTk1Mc1hf_0zXKiooqYNy-Gk-vGuu2A,141
 ngcbpc/data/search/ResourcePopularityUpdate.py,sha256=arkLJlhJ8Nuf4MOfa2GpJ4Sxx0TQ6XrWHug07GVW0t0,5387
 ngcbpc/data/search/ResourceTypeEnum.py,sha256=93W9zB1-we_VKpBZM-2OAs7kZlrH6Q9NgxIG11FvxQA,233
 ngcbpc/data/search/SearchFilterCategory.py,sha256=6KdosoNo6J-4vYXOuELAyk-a8MrcUIynLD4hHLr1w98,4374
 ngcbpc/data/search/SearchFilterValue.py,sha256=yDRLCIW7ZGnkW_MltSTxk8QqJFQ3XRP861FUWAzXEW4,3896
 ngcbpc/data/search/SearchParamFilter.py,sha256=3-95Y87emOU7JAvs0cez0b_1et-QgGRVW8pPTkFq3fo,3095
 ngcbpc/data/search/SearchParamOrderBy.py,sha256=bi62jYTXM6wFmVcANwxA17JPthK4vaP9PyVQVyKt0lA,3197
 ngcbpc/data/search/SearchParamOrderByEnum.py,sha256=U1h3qpvbGL_rNlNlJPSEDCNKLbn_73B4LFREcLX0ALk,109
 ngcbpc/data/search/SearchParams.py,sha256=6st9dVhgpSVCspS-ngaKZfQbtrTlajEOkBWv_WFOdHA,10137
 ngcbpc/data/search/SearchPopularityUpdateQueueMsg.py,sha256=VViWXL4lxMhgSwl1xoOI-wN7n68LxVoap90uc4eyE20,3716
 ngcbpc/data/search/SearchQueueMsg.py,sha256=eWfVHFMt9xNKEJFBFk85mB5pCn-Hwa4flfr1jtZQy0A,3224
-ngcbpc/data/search/SearchResponse.py,sha256=urflGcdYOrfiVkkhlTp0H4MbxsEAlSbR1hWXwLRx4NA,5330
+ngcbpc/data/search/SearchResponse.py,sha256=qBZ-SpyBS1nBGaEItKcGL4gaaKzhHdg7dBQiCaKO7Qk,5330
 ngcbpc/data/search/SearchResponseResult.py,sha256=44gqjZyMExFnjOk-1uXm2gZRdv6KaytvRp3lG6xrOUs,4724
-ngcbpc/data/search/SearchResponseResultResource.py,sha256=50Q_qKyFkms7AtuQZqlxl4pr7nKcZLlfBdXJKDlJHi8,22530
+ngcbpc/data/search/SearchResponseResultResource.py,sha256=78SDNzYXS_vBI8jifzb0a7QDuTI7JQshyJLYEKfo2us,22530
 ngcbpc/data/search/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
+ngcbpc/data/uis/AccountInfo.py,sha256=dwsGS3e0rQx8pgWHpLnQOeK9oj8SqVroWUKdV1FCr1Y,9513
+ngcbpc/data/uis/AddRolesRequest.py,sha256=XIHRrTiJV-YGzQu4EAjzXwSUyYA2Zo5wJAsqi2KsgS8,1859
+ngcbpc/data/uis/AlternateContact.py,sha256=nY2Jr3d80XPEhYkjSfnXzORO3eKrJrKjIiC7l13dWRM,3615
+ngcbpc/data/uis/ApiKey.py,sha256=78iXM2jdpdD2LBbu_SsW1Gh3H6IODDFr9FwR-GFxciE,9270
+ngcbpc/data/uis/ApiKeyPolicy.py,sha256=IJlyVLea490rDoQoURXHi6diuqUJcC4KzeA7Z_NtHT4,5026
+ngcbpc/data/uis/ApiKeyRequest.py,sha256=Dc-mB93s62sZw3-LmQORnU4foBBTJgvhFPbUxx9AoQI,4981
+ngcbpc/data/uis/ApiKeyResponse.py,sha256=-q4Lby7AzklTY_V3q58AoW_puZdd3GxwNU7V-6j8doQ,2848
+ngcbpc/data/uis/ApiKeyStatusEnum.py,sha256=L-KfkXraAy0tUdUGY5fgJhvzK5_qqDDswZ9lUuElI6c,113
+ngcbpc/data/uis/ApiKeyTypeEnum.py,sha256=760MOJKJ0HQQcTd7a9lFkPAaa2xT5mnpLxP5-r0nXok,144
+ngcbpc/data/uis/CreateBillingAccountRequest.py,sha256=jBZ05qUUWRzwCDGepguptR1d9BDHlTP2Vq6UWYxsy0I,4899
+ngcbpc/data/uis/CreateBillingAccountResponse.py,sha256=KWNvqnGfhxyCcTkOx24IiUjmuV-phesaLbP1Lhy67dE,3418
+ngcbpc/data/uis/CreateUserRolesRequest.py,sha256=UJDeuf9vrmvTEzTKdI3h4KfueJy6i_aXoP9XqvvZFvc,1864
+ngcbpc/data/uis/EmailTemplateDataSourceEnum.py,sha256=13lvx_jPCEgwGG_BfFeH-cI7tmF8xH4HifWRzS-_Wxw,128
+ngcbpc/data/uis/EmailTemplateTypeEnum.py,sha256=Jbzmd7Z33AY_EuSJJpknINOsI68bMGck26A_gfOwgcE,305
+ngcbpc/data/uis/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
+ngcbpc/data/uis/GetUchIdByOrgResponse.py,sha256=SUY6rxQ1QnpHgFCeG35YNGoO0otk3Ejmli5sr8VwKm8,2690
+ngcbpc/data/uis/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
+ngcbpc/data/uis/HealthResponse.py,sha256=nMOIWaVLT2gL4tx99XggF2XdpDDgAWyflCV-CnnoRz8,3013
+ngcbpc/data/uis/IdpLock.py,sha256=pnrOhX-4e3sWge8qsJ3E-S8HKxH-yQChwVcJhD_caOQ,7085
+ngcbpc/data/uis/IdpLockResponse.py,sha256=-2H1kUogjkVtP7-Fd4rpM72jm8hgUuGhrAD0Wd-Y1ow,3320
+ngcbpc/data/uis/IdpRule.py,sha256=IZAo9boLu0RuzyQJiOuib8u34GgNGgKPvxWUGuuvfgs,10866
+ngcbpc/data/uis/IdpRuleListResponse.py,sha256=pXfUh5ftye3jGK0QeSo-UfPSPVpSkUM5cr1dNfFRo5U,4541
+ngcbpc/data/uis/IdpRuleRequest.py,sha256=RO_qnSE1aCbHSc2f2fZldlqrrwu8JtGs-b7F0w0JCXI,4778
+ngcbpc/data/uis/IdpRuleResponse.py,sha256=uZYjHol1N_tEhGfIx1iLiDCivB1teraIXFNqrHYCwhI,3295
+ngcbpc/data/uis/InfinityManagerSettings.py,sha256=J3eY-cYKyLbhtRLOdZ_fq7j1owyJDvx4T9ZJj4yqWDg,2720
+ngcbpc/data/uis/ListApiKeysResponse.py,sha256=iMwuSHJUF5hAWgb3RerXy81bJUSFTJlJk6_chqpwzxo,2975
+ngcbpc/data/uis/ListRolesResponse.py,sha256=PlU3DsmL7jy9NTzfk-JQ826Y12xoK9hLe1fzhnnz7fw,2774
+ngcbpc/data/uis/ListUserRolesResponse.py,sha256=1QESeV9-RifEwtxqisfZSBqYE4jwOYV5X2JmZ71QkFk,4307
+ngcbpc/data/uis/MetaData.py,sha256=dRsoN1kAy2HRwwz-QmG3zGJmzXaRrOseztsAmBwAG4U,2525
+ngcbpc/data/uis/NvcfCluster.py,sha256=A8mxGcAKt_1xwoqGSzLYQvTRLMq524mTqrBiOCkSo0k,4868
+ngcbpc/data/uis/NvcfGpuUsage.py,sha256=g_7jpWGTMLvjmX6BF_sqXzSUc4mecgS3cEi1uAR0dPs,6570
+ngcbpc/data/uis/NvcfGpuUsageRequest.py,sha256=R8szbTSTCQf5N2qcvMLHCcHZwpuAAw7wJL9Q772gDlg,2013
+ngcbpc/data/uis/NvcfGpuUsageResponse.py,sha256=wwkImTRiSWGq21-lDpBBDqq10KlllE_dTk1ypWV0vQg,3039
+ngcbpc/data/uis/NvcfOrgResponse.py,sha256=uIxLyDlGqPWePqaT86CNIGvC3TP0bGu7pfH9g1K2ViA,5013
+ngcbpc/data/uis/NvcfOrgUpdateRequest.py,sha256=SdRwVfT4HYCrEhtUK_RU73Q-yb_UU-gbEyRBVJkhknw,2013
+ngcbpc/data/uis/OrgAdminUserCreatedEvent.py,sha256=VG3cC0CvksP7t0fcXL6Gk85n5P_vaNYVuv6RjXceYGg,3446
+ngcbpc/data/uis/OrgListResponse.py,sha256=rbIfQJmU4urB-g1iETTBczeukv6goCg1odsiTVnzygk,4197
+ngcbpc/data/uis/OrgOwner.py,sha256=RVtU503rw4IdgpSwLG-ZL18k4Hc9k8WvyHKt33wR_ug,5428
+ngcbpc/data/uis/OrgOwnerUpdateRequest.py,sha256=WM45jgOnPJVeNLAuhUon5f-m_Ixu_ljtpRr1FC7SQus,3126
+ngcbpc/data/uis/OrgOwnersResponse.py,sha256=kkDi_1dkqdItOxac3-fXtjcimdKcikx6yWoazGKq-Gc,4150
+ngcbpc/data/uis/OrgProfileUpdateRequest.py,sha256=wSOKWsuZVlL1isxd55DhG3jBuN-VX2zLlNylq_VC41g,3459
+ngcbpc/data/uis/OrgType.py,sha256=WSAh3QAhYsAq0pZFd05bLjAJT0VcODFsKt8tFWpPl7w,118
+ngcbpc/data/uis/OrgUpdateRequest.py,sha256=goWs717tJhg7hXZfuouefYSCZAU5V_84_UiL57rVUaM,19528
+ngcbpc/data/uis/Organization.py,sha256=uyt0D2uMxZk6R_iA_FTfnZw50eRlcRj2UDa4d0y8qZ4,25089
+ngcbpc/data/uis/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
+ngcbpc/data/uis/ProductEnablement.py,sha256=7JFrF_kCA-WNsncPQDGRQERZhWfg4W6fzG8Px_wT1LA,5273
+ngcbpc/data/uis/ProductSubscription.py,sha256=Qx24J6mVo7Gr4cqJGrt51_1PrVJHpAnVjktj2GhUcak,7235
+ngcbpc/data/uis/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
+ngcbpc/data/uis/RemoveRolesRequest.py,sha256=YhlldzcN7yvEUX8EStmQlkZe5FLRjfP2hlsYvB9nmD0,1872
+ngcbpc/data/uis/RemovedUser.py,sha256=AoN7IvDO7bFXEsAgsrOzPRcRy6tQC6_4oh4gqHWryos,11504
+ngcbpc/data/uis/RemovedUserListResponse.py,sha256=8I4KURD65pUMOS6rYStYfWrr4IHkdMIaDQXzQAWRZfY,4132
+ngcbpc/data/uis/RepoScanSettings.py,sha256=slbOIf1Q3S5HWf1Ssfh1TxMj5DRKwRiPF9uEi_OmocA,6724
+ngcbpc/data/uis/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
+ngcbpc/data/uis/Resource.py,sha256=IJB5IoqqRj0YU0vlqqiTer7lgHoYPCisufAq7G8vUzw,2320
+ngcbpc/data/uis/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
+ngcbpc/data/uis/RoleScopes.py,sha256=BukWuyCXFPtQljNctxCCN5MRg5FDJ1YbtdsvGhAH4kA,3890
+ngcbpc/data/uis/RoleScopesRequest.py,sha256=4GXRPjOcJI3XTLaBtihH0sBsPDZFN8KMl1I6iJUt0sE,2034
+ngcbpc/data/uis/RoleScopesResponse.py,sha256=eCtEfKxj68nMfjCNIIDXVWnca-5EmLzRdN2YdE3qgi0,3060
+ngcbpc/data/uis/RoleType.py,sha256=Ogsb7vqOM2mgwo8aKmB1un6U9yUb-9trXwNan9yX83o,1726
+ngcbpc/data/uis/RotateApiKeyRequest.py,sha256=Loat3kcaJlEhrez_VJ58E8bTKu81nodiGijDkqqezpg,1940
+ngcbpc/data/uis/SakCallerInfoRequest.py,sha256=jeBUQwsMJAEuxQ1WoNoP3KiksoyOhgmDlWF7qz9jhNY,1975
+ngcbpc/data/uis/SakCallerInfoResponse.py,sha256=tHc7VkHB1SDJRRMleMyuBOd8MqfpCdEwEmGGXLLZKc0,5852
+ngcbpc/data/uis/SendTemplatedEmailRequest.py,sha256=j57BEnJzVzio0-vgYo-_nl1WnXxaaxgJhzN0hPvaD_c,9736
+ngcbpc/data/uis/ServiceAccess.py,sha256=5RvI0SCMC_KNMEuLmeiacAZYgQrDXpxsMgKSjBaLdCo,3012
+ngcbpc/data/uis/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
+ngcbpc/data/uis/TargetSystemUserIdentifier.py,sha256=ZbsvvU9RKZwEf2hbsMIY3waMShriwllpLGq3qyo-9rc,5648
+ngcbpc/data/uis/Team.py,sha256=Tv_a-XAPKxjij3ZxIbuQP8jNv8DsZL79qi-e4X6f8pc,6353
+ngcbpc/data/uis/TeamCreateRequest.py,sha256=8awxlfnUFS6k68KOO18ADFcthSPzOw2ZujkBXfU8-js,3756
+ngcbpc/data/uis/TeamCreateResponse.py,sha256=O6f7ol-t5z12iBgtXboH_0CtPQdCqYSbcH128RVXjjY,2856
+ngcbpc/data/uis/TeamCreatedEvent.py,sha256=77vAtprTmdzL5LzEUJzv_VukI7Y6wiwfi2cGbDLBVQw,3332
+ngcbpc/data/uis/TeamListResponse.py,sha256=2lLqs2FfNx3NtonH_RXBZpUwEvQH86z3xw4wdv5x71A,4017
+ngcbpc/data/uis/TeamResponse.py,sha256=kNnHS8yU0ZSIXEnc8lBDbGbhs1SsBY9mj1UyYnGulT8,2811
+ngcbpc/data/uis/TeamUpdateRequest.py,sha256=kNAW_EBo8txDpexlWVxigeHRHi0L91mW5MJia-qdjec,4496
+ngcbpc/data/uis/UisOrgInfoResponse.py,sha256=yc9xivR8AteyhQQ9zREWN-_FAFO-T1gte0X-iZ3eY6g,3032
+ngcbpc/data/uis/UpdateApiKeyRequest.py,sha256=42ppqCYwQz8JCXKeqUM1xA6W3xi38NtHDPhMPgaSJpA,2811
+ngcbpc/data/uis/UpdateUisOrgInfoRequest.py,sha256=Y8K6ER2FzUCRW0gF7EhuVLJLZ8AJvxhSznfSyQgnOGQ,4360
+ngcbpc/data/uis/User.py,sha256=0wTB7WJLTt44qzbubbezqBOeNTklJd5e55VMLb8azzc,33471
+ngcbpc/data/uis/UserCreateRequest.py,sha256=55e5cggZwaLY2QNAp4IQwMYJvsZWT2gRGzFMxQhLZLc,9435
+ngcbpc/data/uis/UserCreatedEvent.py,sha256=vT_ew2DzLqcIhMrbBhQusjNke3dV8_Hid_1oq9O_LCM,2525
+ngcbpc/data/uis/UserGdprStatus.py,sha256=oFZFL5tcJ8-IVvGo8hS9rjPQKGNpUuMDv00T2f9BiXg,136
+ngcbpc/data/uis/UserIdentifierType.py,sha256=f9i3xgkzPJtPzBDv3kGZrxq6L7powGqMZSvfZZ1Jwto,164
+ngcbpc/data/uis/UserInvitation.py,sha256=4woFFsbBCmgdrGboyyHw7xV6z0MGdxjSy3HXxTwAD60,9651
+ngcbpc/data/uis/UserInvitationListResponse.py,sha256=S5S9VBBCkKG7gMrNU-_ESuSsOYrs2CW60ucLfS486qQ,4231
+ngcbpc/data/uis/UserInvitationResponse.py,sha256=hvg9OCqoGhHDCbZA0wmnmDgtjPvGFBwNgmwdRkN9tiY,2988
+ngcbpc/data/uis/UserKeyResponse.py,sha256=zJyNxvsXrq6miALIjuxJbKn6nCXqRndzmAuEItpyhMw,5560
+ngcbpc/data/uis/UserListResponse.py,sha256=qlLzJsGBzDEuB5CWMJ8tpAWrv9dLFgwk3hI6gl2V20o,4058
+ngcbpc/data/uis/UserMetadata.py,sha256=1GunPpiDPOXdqLxkX-fEaW36dFmdMitVdJb2NNH90SA,8112
+ngcbpc/data/uis/UserProfile.py,sha256=XiZVWF529AMBNz9bkn53we59ZxjZfWZ12_vAHTAe6pA,11401
+ngcbpc/data/uis/UserProfileGetResponse.py,sha256=4M897W4VYgPcdoMMbKaLwvDd4Wrafgtyok2cLnRkP38,3002
+ngcbpc/data/uis/UserProfileOrgInfo.py,sha256=EBsbFglgetG5k16r2e3XtS2cuvzLpfV3PApqJ36r7B4,5170
+ngcbpc/data/uis/UserProfileUpdateRequest.py,sha256=TTAR16HuTuZ_qKIFJUr_avtztQKnhWgsrRj7nauiu1o,1982
+ngcbpc/data/uis/UserResponse.py,sha256=p3z4DUXUd07xRgxIwPNxnsIf4g3UFS0mCAl0I00UugY,4806
+ngcbpc/data/uis/UserRole.py,sha256=0PzAfI5ossdgUJSSNcbifE7LZuxzX6zFbSTvRVN9UD0,6556
+ngcbpc/data/uis/UserRoleDefinition.py,sha256=KhTgZsIl0CvUSTIc5Qf4Q3aUTr2s37XmPLk3UO8gtHo,2808
+ngcbpc/data/uis/UserRoles.py,sha256=n6w8qhTErS-gufh4yasOlZccMXupU1DpbmU-Zog13io,5029
+ngcbpc/data/uis/UserStatus.py,sha256=nGnxIDpxng-wMCJTysobaJw1H6cq9czRHIfbwnyc_mQ,112
+ngcbpc/data/uis/UserStorageQuota.py,sha256=9ZfUcjOBq7Ur1jjkZ3JJL3DZAM2D4X3w-3OUHYrmy2Y,12800
+ngcbpc/data/uis/UserUpdateRequest.py,sha256=phvQfSfexG7YHzYOPRp4BUcK1X2WvbGlfwiVT4vO8qo,22375
+ngcbpc/data/uis/UsersInfo.py,sha256=gLEr6mMH3HpclrYfy1JjsgM3x2s5GEVjcPqTOAKhs-0,1718
+ngcbpc/data/uis/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
 ngcbpc/environ.py,sha256=BD-Pe84nP5-WbAnUM5HsT_x4qSXFbB06yId2YSkqmW8,7202
 ngcbpc/errors.py,sha256=Lf4xnFZytL1sfSQmA7qgkIbCWV0RgSOMyQIOuT60nzk,4487
 ngcbpc/expiring_cache.py,sha256=YyhIHWGNIY69yYJMQHOKx-eCqbJnXTWptrbIxUWvmxE,1910
 ngcbpc/logger.py,sha256=Zi1_pknMF1fYREf0X31dYDxir7kfxu7citElbe46r08,1847
 ngcbpc/printer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-ngcbpc/printer/config.py,sha256=CGbadlDHQENk5rAB6pCw6TWK73qy0AOy5xjoZY4bbK0,1743
+ngcbpc/printer/config.py,sha256=YUsEb8RbOE6yM2D7OtX2nt0K_08NYZmK87h8kIaNdDg,1729
 ngcbpc/printer/formatter.py,sha256=UO5V6j0q1iOF1_fW1wsBLiyjUcX79aygU8L7FWaRFuk,7896
 ngcbpc/printer/nvPrettyPrint.py,sha256=q9XuSX6a3bEc7ZCGWSsl9eLid6qHCtfBB1kvE0f0T3I,37160
 ngcbpc/printer/prettytableWrap.py,sha256=LLmaT7AYfR13ILmkOLT-APPaGuFeG367acbbU5xDhww,4672
 ngcbpc/printer/transfer.py,sha256=FFdpWkXmrlIw_vhItwznoJHy2d1KtLdqqNdKxJaHPO0,10068
 ngcbpc/printer/utils.py,sha256=v_dBz-9I3tlAya3PYtDnBsUXkspqe7fFVTTKMEvG0Ec,1337
 ngcbpc/singleton.py,sha256=XWNvUZW5VS5xDa770Cf16I_m7W_MmyB03fXEROG-BiM,1065
 ngcbpc/timer.py,sha256=81fXhROMxyrbyL767cKtdn5zDj3h34U1FVTxkN3h0_8,920
-ngcbpc/tracing.py,sha256=WP-3Ph3gpA_2IhDe8J70-h1emPmddzhpkYKYBaN0pwo,11890
+ngcbpc/tracing.py,sha256=AojAGBPa_py2KCNLfGS-JZMx0M5tGTFPG3QR2BXqS3Q,11921
 ngcbpc/transfer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 ngcbpc/transfer/adapter.py,sha256=H4zIqSZzNrneas6O0bewOXS1B_Xil9v31Rx_gVC1fbk,23268
-ngcbpc/transfer/async_download.py,sha256=yqg-quQZnNkXp_LJxOaM6L-DlB5Ve-eXCDfKhAxDDZo,38256
+ngcbpc/transfer/async_download.py,sha256=e_q9HBQU7CMoUc9WJe8ezeMT5N_l6TApnq6eROZsUtU,38485
 ngcbpc/transfer/controller.py,sha256=BS2DiFsuC2K5QswHt_jmeFnuc0yfZX-iUzh4YApfNTU,7787
 ngcbpc/transfer/download.py,sha256=BlEfGW4218Uj2tJxVipHW0ub2jPCL4jXnIogfEIc7Wo,22885
 ngcbpc/transfer/file_cache.py,sha256=W38GWE6d4IN016h-R7XqxCOo9fMVHuB99_yLYYXnOSc,3925
 ngcbpc/transfer/grpc/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 ngcbpc/transfer/grpc/proto_py/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 ngcbpc/transfer/grpc/proto_py/upload_pb2.py,sha256=nnW-zygXDS6tSZ5dWg6CLklNEqE00AszT7SeHyjQVpE,33874
 ngcbpc/transfer/grpc/proto_py/upload_pb2_grpc.py,sha256=1hzY5I5oxeMCMJWW5Z2D9vaBMpQiC_cKPi5qLzZosic,4636
@@ -484,996 +832,210 @@
 ngcbpc/util/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 ngcbpc/util/base_utils.py,sha256=ERp23Uzt1_8LffP4tC8S3SAJAsGqKMPdtDTiV3CpEdw,1261
 ngcbpc/util/datetime_utils.py,sha256=8Dq_b_rEzKDdJB0M6qH_RYO71j4-k2Akz35359gTh4A,5076
 ngcbpc/util/db_util.py,sha256=uZ5D2s4hqFnmkqEXsL8ncxahFG2z6myp6wgm7xRGp3k,729
 ngcbpc/util/file_utils.py,sha256=m4_QhY09XrroFqgEYkr4w71Usj84QgBDzS7x8B5OJ2o,16838
 ngcbpc/util/io_utils.py,sha256=D0oWOJmTRmh1jokW3l11O8EbwlpUiNDGU4YJoaRiZhI,5095
 ngcbpc/util/ssh_utils.py,sha256=stDXRVKa9Dzu99aq0LYSU_cQmDR9PNWp9RpTY0um04Q,5457
-ngcbpc/util/utils.py,sha256=PMooVdQ2j9FUB2f4WZSBUnPFKiZQHRPmOIH8BnzDDYU,18125
-ngccli/data/api/Ace.py,sha256=kA69N7G6nSg8yfeXkcbwx0ddg2xzzgaCYFMyz4wcOxk,29186
-ngccli/data/api/AceCreateRequest.py,sha256=09VO57l6aUzuH5wb_R-f7tuNtbUFK4Tn8NJSbSKwcCY,24775
-ngccli/data/api/AceHealth.py,sha256=L_BLnEXdLMEhM6kqWmmmkzdyYHBkNbrNKm0gliNvj50,2612
-ngccli/data/api/AceInstance.py,sha256=iwM8mbgXkiQtRcZh57hDfacQfQW1yVJSOZ53hJRRC9Y,30841
-ngccli/data/api/AceInstancePrices.py,sha256=172x-QTWIewAKHt2vAt3l1oUtnUEQS5CGyWBsugIF1g,5090
-ngccli/data/api/AceInstancePricesResponse.py,sha256=nInm5vEKXcYEgvxpwTuOv4sY-mSeRIurYDb_Tn4TBbA,3229
-ngccli/data/api/AceInstanceTypeEnum.py,sha256=IQaBtxI_neczo0AAKcAGT7P7ye4K3z2QTz3CWYQyT1M,108
-ngccli/data/api/AceListResponse.py,sha256=mcMIrssQyWCUANa8txxW5MuSGRT5TKz2LzD34Dh4mC0,4010
-ngccli/data/api/AceNodeRemapRequest.py,sha256=WCeC0QOfrQP_c-GDjS8ROzODxbZiX4xa45GCODWEczY,1979
-ngccli/data/api/AceProvider.py,sha256=pbuwIUrWi_tc8t8F_7R6SqKVx9ok5gvnABIkoZlPFmw,124
-ngccli/data/api/AceResponse.py,sha256=oLt10aNpVvK589A3fCkdcZwwkgrP5fD-tWVAXUnMwoo,2811
-ngccli/data/api/AceSimplified.py,sha256=I-G1NpA1nQjZUGr934Ag63qI4hbH126ZlvWF5Jz107Q,3191
-ngccli/data/api/AceStorageInfo.py,sha256=gB4zoQoOG7S2eQizwtuLXPSbn_jJoqwPoxDAQ49Ujkw,10624
-ngccli/data/api/AceType.py,sha256=i1DQ8qMst_g5KJG2hSJK2xSTnK8E-7-Z7oELgYD0Xj0,104
-ngccli/data/api/AceUpdate.py,sha256=2Tv3UgaQ8-i3mg1Zs3dX02RuMVh2zGYUYtISOW3HPY0,26375
-ngccli/data/api/AlertAggregationType.py,sha256=OllS-qf8zAI_ZmKyYs6V60Xbz4XoOV1Vh6K6dx2e7IQ,120
-ngccli/data/api/AlertDeliveryMode.py,sha256=zsmbi2KBJKBkqeB5pIo7bLP3gaiGlxSDQOa3AhJaJFk,5118
-ngccli/data/api/AlternateContact.py,sha256=nY2Jr3d80XPEhYkjSfnXzORO3eKrJrKjIiC7l13dWRM,3615
-ngccli/data/api/Analysis.py,sha256=HQRbATkCVOhSJvR78w11X7B31o1U-3JP1oueIy0npuU,4036
-ngccli/data/api/AuditLogs.py,sha256=GPUug9XW8h7Lr34gt1XJgCMV7a-20yLZVRj_bg3hJIw,9458
-ngccli/data/api/AuditLogsEventRequest.py,sha256=VuEeMXw-fx0nwFOyeaGaS7ZJIo9J_VJiaQjMDCoHdlM,8488
-ngccli/data/api/AuditLogsEventResponse.py,sha256=2WEG1p-qkcS2E6NbXJApvPAwa3Eyd5uKISEpdoClrPk,7632
-ngccli/data/api/AuditLogsPresignedUrlResponse.py,sha256=2zqvGa2sbaq1Q2DD-kpCR4MmCoZFvMtP2a7FuzIT6W0,2955
-ngccli/data/api/AuditLogsRequest.py,sha256=gz3izKgPoVI8Ql3KhdZg2nunYYKxJvACzVomDlO7Kgk,3025
-ngccli/data/api/AuditLogsResponse.py,sha256=aBduDKOvn61UJN13CQYN8oLvdxW0uFVcMUcjIlqhYXQ,3108
-ngccli/data/api/BannerEvent.py,sha256=A_3khLJU9jJdLFqcK3TdzPX6V_AL62YiZowqiKJXmk0,4895
-ngccli/data/api/BannerEventCreateRequest.py,sha256=lCyvMeMxcUnJPqvHI-QZ70pdn9BG3KtMuUOde-7fGJU,7317
-ngccli/data/api/BannerEventCreateResponse.py,sha256=umeD4eZf4oXTNkGiDjX5tE0TqPRTtRm2shyiRwNQ52c,12130
-ngccli/data/api/BannerEventIncident.py,sha256=hqLbn000I2vF_0g_k1P8jFnSOI_QWYThewzqdYxfg80,9626
-ngccli/data/api/BannerEventIncidentMeta.py,sha256=NSSBxBOMPRZmX8wzXCxxJZUJXympNkk76n68s_awiVM,8611
-ngccli/data/api/BannerEventIncidentSeverityEnum.py,sha256=qrzoAwUiVZgzVI3yNvQ3Gl43UwB4zJExx9zMVbcIuvs,232
-ngccli/data/api/BannerEventIncidentStatusEnum.py,sha256=FgYkaJKV2sZ1qgNI95W4Z-VwBHY_6R9aA6NCQr4xT2A,247
-ngccli/data/api/BannerEventListResponse.py,sha256=Dc-GsjcAYTAZY9A1Sn39-nFFb5i1fZ8I6CLhyiFOCPk,3818
-ngccli/data/api/BannerEventResponse.py,sha256=DFcIa6jEYlTK8f3rcOJ05K0AstOwsq5gOoGutSWVP2s,3707
-ngccli/data/api/BannerEventTypeEnum.py,sha256=kGnKMsjgBYB-GveWqeN9XzuLmpAxDNo6kSPBZ7lyUv4,101
-ngccli/data/api/BannerEventUpdateRequest.py,sha256=WKptpcuLWQv8rsImMVYdoHgKSogTXRSlYEJdImw4rJs,6022
-ngccli/data/api/BannerEventUpdateResponse.py,sha256=bMDqaUeDmRS_093pBfwJxOq133qSME3BEQn-eEBFCbM,12125
-ngccli/data/api/BatchResourceTypeEnum.py,sha256=OKdqkFqSSPpqlKuNiiT2ocsOXKMLmBnStlRd5_9d6TM,128
-ngccli/data/api/CelestialErrorDetail.py,sha256=M79YXOnERatxwb5l--2L50HyrVjQDgijeU5DmTDAaDw,2483
-ngccli/data/api/CelestialFilters.py,sha256=rWKGamh_rgNxX0B1eg_TSgiKSR4LFbmMObOU843DJMU,1925
-ngccli/data/api/ConfigRequest.py,sha256=uRPNI8KuP35zTc0WAu8yooMaJnNUK_c5p_pAKizAZ3I,7598
-ngccli/data/api/ContainerResources.py,sha256=evKF-LD-tmZO4MSRWtSSjClI9rdK7cHi49fAIqkeRY8,2996
-ngccli/data/api/CreditsHistory.py,sha256=ILoLAYijWngc541LfANjOXurkc6PqHTZDkEqk0g1cFw,1755
-ngccli/data/api/CreditsHistoryResponse.py,sha256=YX7pik2CwDhfbwPEFC0nbHocehJckfbrws6pjWlVkoo,3029
-ngccli/data/api/CurrencyCode.py,sha256=WJ-WUkIuZUc0YgBlbR8fna4hNLenpKkORGBXNZrT-r8,90
-ngccli/data/api/Dataset.py,sha256=T_rjFVK_LHJs91sYdgqnK0VGuwHMpZuF8EMHJNOArUg,25858
-ngccli/data/api/DatasetAddFilesRequest.py,sha256=WFpJriUT2mhDlfnGfTPxuc4OCRJ7E1EV3qMVoUYC0Vw,2267
-ngccli/data/api/DatasetCreateRequest.py,sha256=pcXXo__h25t8r5Rml3dS8SCwefQJX4Gy9QVB1CYPPd8,8227
-ngccli/data/api/DatasetFile.py,sha256=-8MdMJgzWBErAHDEhHktP7FtmOmS_D2AjUa4ZdIcQpo,6081
-ngccli/data/api/DatasetFileBatch.py,sha256=ZxBG9HfgcymgvVuQ1gfJai2amlFEifjdX9URaPniELc,1986
-ngccli/data/api/DatasetFileEventRequest.py,sha256=rpt1hbeLRR8f35KgeJcuxJA0NtE1C8g8nZo4RJO24k8,5944
-ngccli/data/api/DatasetFilePath.py,sha256=X_Ci0N7slTuPQoFRRa4qkLh-fN5Na_97oYEYLIoWmXU,2496
-ngccli/data/api/DatasetListResponse.py,sha256=wlKB7GumpEoBEbYVJVwdks1JVp5EWd2BkK8KcIjAmTw,5248
-ngccli/data/api/DatasetResponse.py,sha256=0E77KGUFiaFLvFvz3mjaaAUAUUY6cVMtAJJqJkefpB8,5075
-ngccli/data/api/DatasetSimplified.py,sha256=1JhBkpavvOi8-4Y52NshzPrmr0MvjD50Xug0q2BHB7k,20617
-ngccli/data/api/DatasetStatusEnum.py,sha256=d6PekqIdlUwic9K8wxwh8gfd9U0-NzzO2tXXqcUDRkg,121
-ngccli/data/api/DatasetUpdateRequest.py,sha256=Z1t3L112AOXvHCuQI2VehWP4Jyp1nu-Xm0ECHE6sOVc,7497
-ngccli/data/api/DeviceLoginRequest.py,sha256=T8_UBp6TUhpWZoY5-mwJlxoUTX6NLf_uL7hhwpaYv2k,3632
-ngccli/data/api/DeviceLoginResponse.py,sha256=mcHfQ01Y9i7YI4dRZ1v62JBcBPBRWa1pg39C4t5MhXI,4215
-ngccli/data/api/DownloadTokenMetadata.py,sha256=Wh4_AHRIwz6EJucuJXZJYzxFKl9ttPd1Aa1fMq54Krc,3313
-ngccli/data/api/EarlyAccessOrgCreateRequest.py,sha256=2tl3YKxifFAqfZTTW5-U_v8Bnt9sw6KJcuXyzYI2vMA,6748
-ngccli/data/api/Entitlement.py,sha256=dZlBsSU9gziwFazybgdgnSUakuUCcIv_T4rGChVAj64,5681
-ngccli/data/api/EntitlementProduct.py,sha256=J0RYMd9PxDVmR8rw36zQnjr-J7lbdbCht21aJ3oOyq4,3397
-ngccli/data/api/Env.py,sha256=8c5CRDwwkncFV9D6-2EJRNGWZaLzEOsGTUCM6hNNITw,2943
-ngccli/data/api/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
-ngccli/data/api/Eula.py,sha256=7lxWNA1ZDnvnSkA3rSv8A9vc9jMOB5vVGjEmGBeM8mo,2964
-ngccli/data/api/EulaSubmitResponse.py,sha256=-ivI_ssr7qNTVV_ITJNDTgEC8tuY3u8mCHh6uqNnhiY,2753
-ngccli/data/api/ExpTrackingParams.py,sha256=i6-5JEUM8jRAk180qE0LPe0bVTzN-8W5DO465UUNDHA,3846
-ngccli/data/api/FcOnboardingEventRequest.py,sha256=4mWPLmER8hiWrJpxdvzTaMxauMuOFzl6hZ3s8_-hF7c,1892
-ngccli/data/api/GetRepositoryTagVexResponse.py,sha256=3PXZf7ulakADHhAWYhl96-_E4PlOR2s4LB4SRjE3cIg,3753
-ngccli/data/api/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
-ngccli/data/api/HealthResponse.py,sha256=5mdmVDD67RhFOoeFHF1YIYKkSsxcyrf4fFFI0m-YwNk,3013
-ngccli/data/api/HttpGet.py,sha256=q-CPnFPEdKQmjctAeaW6BvFmvOcn_zC2KiFsvXjo9l4,2410
-ngccli/data/api/IPAddress.py,sha256=khL2G0Lz9lTodtXjfHXGsFoEcKSxOrl5k3ZJcgKN6e4,2323
-ngccli/data/api/InfinityManagerSettings.py,sha256=XmueItuc_fmVJwtszl3jWzIOay-v9rixOhsgUyWpe3k,3099
-ngccli/data/api/Job.py,sha256=k2u8nkuJuQAbf7CdLip8C3BPXsW6oh1nnS7q8bYzbX0,35355
-ngccli/data/api/JobArrayTypeEnum.py,sha256=cJJho2ZklOnm2oNyQdr0OjcW1QC37knq2KbZ9PEVTo4,121
-ngccli/data/api/JobContainerProperties.py,sha256=qc_vJrYpXKRa9slSKiixSxCET_wGi98dTippXgSP3Y0,12900
-ngccli/data/api/JobContainerResources.py,sha256=UhLENjI8mXIkZdpYmxfyWgcQPVUdIjanMvFchiLXiQg,2577
-ngccli/data/api/JobCreateRequest.py,sha256=lUd-YlMPdnPyrlqI0-qnCqhKmOmdRUgj9Ha-Qk_1sgI,41050
-ngccli/data/api/JobDataLocation.py,sha256=fy2jEXjIpqTfEc80WQ9GeqsfVC9HAux-H2Ask93JKJ4,9678
-ngccli/data/api/JobDatasetMountInfo.py,sha256=O2Gzyn23NxXHKafjZYcMusNfFV5-WohmzRHH_xzCeeI,3490
-ngccli/data/api/JobDefinition.py,sha256=LEt1g7zkuJXjFAWr_M5KXxKx7zqZri_6V4p6PBF76js,39617
-ngccli/data/api/JobFlowTypeEnum.py,sha256=O5JE5cdfzg6scJkcIncxdad3gzUUZTdU5kCjLcvWdT8,97
-ngccli/data/api/JobHealthCheck.py,sha256=pLEOf44S2yBNBI-MyvK5tjerIlZlS41SXG_PoeISnqo,4617
-ngccli/data/api/JobInitContainer.py,sha256=SourcAAu6CybbZT7ZSgEENTxYzVevWaobJwPfRFDcvM,12808
-ngccli/data/api/JobLabelDeleteRequest.py,sha256=YMdHreYNVeq453gdOwhbLMYsXLb5hQC3Py0z15xHEps,3556
-ngccli/data/api/JobLabelResponse.py,sha256=hfL9zspyjRNB8G2OVDAVOnNcJvuLe0x-q4BGs0dTqWs,5211
-ngccli/data/api/JobLabelUpdateRequest.py,sha256=qNTQd-WOrWmqSsRd3oadCbVe7PvDw-J7AoGXF8Zx7_I,4241
-ngccli/data/api/JobLabels.py,sha256=vbd5txjZuwVEbG-61vFAZCR2_BotJMUaLFBA7AfyYow,4940
-ngccli/data/api/JobListResponse.py,sha256=DY0tKq3CwpH0YwDCWzlac3pK-gIZkLjYbF25KGiZNR4,5146
-ngccli/data/api/JobNodeCreateRequest.py,sha256=--W0OV6Squ86daJphZBOsd6jsIwBNaG2nPjeb-RNDvQ,11711
-ngccli/data/api/JobNodeDeleteRequest.py,sha256=J8t_HDSpT_7DAp8k9Utptu_IGrEOkRqLVYBjpWC-VUg,2948
-ngccli/data/api/JobNodePreemptRequest.py,sha256=CudMjIjCPIwM73MuSuy2IVzZKUihqqXwRMo-urtVlDk,1907
-ngccli/data/api/JobNodeResumeRequest.py,sha256=JzUqcAcUjCFMInkHT74g_Vpf_mqLMBAYE-exuQGvx4k,1919
-ngccli/data/api/JobPortMapping.py,sha256=U8k7H0GW6UHu5tZN5kxmk1VVL24DtCAKJA_H5AlgRvs,6209
-ngccli/data/api/JobPriorityEnum.py,sha256=W1zRqf0WwmTpRLN_GnJcndtznNFqjaYjvAvTFyreGxg,104
-ngccli/data/api/JobResponse.py,sha256=CyQRe9LjfQnyOmGT1HE-DfZt5QDgDskBMr2XEFBlo84,4883
-ngccli/data/api/JobResultsetMountInfo.py,sha256=t2ru2B3faJ0HLDVlQpP-dx1vAMtXJ-ZwPIvBFhi5Fn4,3890
-ngccli/data/api/JobRunPolicy.py,sha256=qa8wbVtKM3mhiI1aGvOAyXCuUqvjKw_93wEQodVeWis,5817
-ngccli/data/api/JobSidecarContainer.py,sha256=Nrjfn8rIzd5FNoNDViOCaacTVh_Xup6qEpowRhLsCxU,16057
-ngccli/data/api/JobStatus.py,sha256=cROnxDvMApXsa5Wwtsc3PdUIGJ6QTsGCSd6DMcZ1qjI,19200
-ngccli/data/api/JobStatusChangedEvent.py,sha256=f-Hb9RhkCHG9HAiWtejArNg0n9FnPN6pEgqCdjwDyjo,2491
-ngccli/data/api/JobStatusCount.py,sha256=_dREcfWpXx__tHPKaGTrMGj4whN7tQ1MpYHQHLoTHeY,2464
-ngccli/data/api/JobStatusCountResponse.py,sha256=KUSsDY56qzooOX8UG8P2AkBXL_ustCSxT94nzXTjeAU,3086
-ngccli/data/api/JobStatusEnum.py,sha256=tk4n3QRbvhAA8t5OnxAW5smxHON4DhmYfJ9smMOkqDI,541
-ngccli/data/api/JobStatusSyncRequest.py,sha256=ZOdSly3WV8kTi40kAl4ApIQ-44DsHAA_REwsl5R8L_U,2339
-ngccli/data/api/JobStatusUpdateRequest.py,sha256=fAZUWusySI0AmlBd69nzEssGhTlHzQ5JoQQpkZh7DYQ,8345
-ngccli/data/api/JobSubmitResponse.py,sha256=vIGedEWgP9vrjN0Trx_wzKIshZNpblL2sgdUutb4N3I,2872
-ngccli/data/api/JobTemplate.py,sha256=RECQL-BZRruSAEmkf1RtOzhJ_z2akGvX-e_edvauTRg,6644
-ngccli/data/api/JobTemplateCreateRequest.py,sha256=ZFpt4nNZQYRhhtqDdIvhN3Kiuf3HSYvG6AN4-2N1WtM,4810
-ngccli/data/api/JobTemplateResponse.py,sha256=dKwYB4_wOC1qShYSQ1DCrN36J03NvW_MChdHpyx7k8o,3052
-ngccli/data/api/JobTemplateUpdateRequest.py,sha256=v0RPgzDMhbc83RkY_s3578qtjjrCOVrXq5glFq4Jt3Q,5980
-ngccli/data/api/JobTypeEnum.py,sha256=6pCphFYrb7XTUthLV_1o1Rak9P5C_lzbWyK0iOvddpY,92
-ngccli/data/api/JobVolume.py,sha256=LeqdBBzaS5SNeHfq6uoq_wJL7ugXXUb3L_vYY5Vzai4,1799
-ngccli/data/api/JobVolumeMount.py,sha256=ZOsVqJPQXc0JELlObVFT4kcrAlZUE2bgeMa0mMaYkFs,3837
-ngccli/data/api/JobWorkspaceMountInfo.py,sha256=nbnwpL-PZJeWBoK_KGly3jg8Gywr4jHqXqOMVDFnuE8,3819
-ngccli/data/api/Measurement.py,sha256=41xWquXhdvY96_L_1kjlrC997dy2ld1xCihQgwtM4TU,1696
-ngccli/data/api/MeasurementAggregationType.py,sha256=kni3kEnm6lUi23kdZ4Maf6tnrVz0Z8CEwxJeffpplxU,140
-ngccli/data/api/MeasurementAlert.py,sha256=3yZzLIvGcAdEUaNVysjgRUwQRvPswVXHhlYCkXG-d50,9534
-ngccli/data/api/MeasurementAlertCreateRequest.py,sha256=i3X4ht7fuAvMW8JMMKIaKW9HqiB131Khuap3M4r08Jk,9069
-ngccli/data/api/MeasurementAlertCriteria.py,sha256=i-xCCnCvzFQZpNwjYyaznWpFmdQACrt6GHq-zIcRgtU,4394
-ngccli/data/api/MeasurementAlertListResponse.py,sha256=_0PwHZboTP94OFfgvBDS032NXTbsiIpde-i2OB6D-fk,4138
-ngccli/data/api/MeasurementAlertResponse.py,sha256=3JO0_uFQ8URuEdMeGVZbrFL0au5LimVUaYOiM2wzZnw,2956
-ngccli/data/api/MeasurementQueryParams.py,sha256=jkTe-iq6VTPaJ-jTDJ5xm7roDhwDOVheLNYRybRHKmI,5771
-ngccli/data/api/MeasurementQueryRequest.py,sha256=Q-eScPsSlaeAgk-CeEPo1liSez6hmXNgMXDUfdpqHY4,2124
-ngccli/data/api/MeasurementResult.py,sha256=ThVvMzW_Pg2zuEw7MQM_cH2LH94FpHRKr070tpOKQek,2041
-ngccli/data/api/MeasurementResultListResponse.py,sha256=xJIkPCoL32irzey4IEnUGN-WRH8FZKDrac2qAEw5C2k,3151
-ngccli/data/api/MeasurementSeries.py,sha256=QGR-vx680Ico708YKBR6HkF-lzg-_-0HUlTWCqa_Nhc,4566
-ngccli/data/api/MeasurementTag.py,sha256=qJ14NeQn6vPrPal1-fmTKn5Vwt3fcXpXhyASJmV-jFU,2557
-ngccli/data/api/MeasurementType.py,sha256=2JkRNdpczxwMYSxHKhR3AOTdF1mCUW3r2I-AY5UWrq4,1139
-ngccli/data/api/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngccli/data/api/MeteringQueryParams.py,sha256=AkHxFrORJiE-h-WYOpL2fKajY9cvVC8GNj2D51Ss8ts,5806
-ngccli/data/api/MeteringQueryRequest.py,sha256=-4x3G9MQxyUD1WLgVayMoGVzYxOtaQ5qFUZE7Z3SVoU,2108
-ngccli/data/api/MeteringResourceUtilizationEvent.py,sha256=RigcoqHItBu2yLpBsU4fyKaI6YjhkH6jWHFfy3gr4Nw,8876
-ngccli/data/api/MeteringResultListResponse.py,sha256=tvA85M7ngkyxAgPS9x0_ZzbOmOiKsiupCnrGCEaErxo,3145
-ngccli/data/api/MeteringType.py,sha256=fxS9yLnqBCY0HnIrCTa52NIlRL0lcTN72l4PEvKb6Yo,464
-ngccli/data/api/MoveNodeRequest.py,sha256=vIAA8_VemJGpPt-ycCC48edZxqCI_dSPIHgyGm1PxOI,1880
-ngccli/data/api/NetworkProtocolEnum.py,sha256=WrTLk0E4lQ4AgFwps7MzJGLcIWriHo6Kv_naR3Z4P2I,117
-ngccli/data/api/NetworkTypeEnum.py,sha256=c9TOPxzy3_TDN5_KMjoRYIVdgXfgEQ7tvxuUMCFG_wY,106
-ngccli/data/api/Node.py,sha256=8BBRsa_R6QbG3Z_GXhIKXOshQFht5vpBf-mmYsmWAlw,12102
-ngccli/data/api/NodeCommand.py,sha256=OR-RC0FZQf4bCpCIpPhk4pAksv8FtMI7sg9pzbSIYpA,3564
-ngccli/data/api/NodeCommandRequest.py,sha256=zqhsj7KJhtLQ1elrPVkm64a3m5Pc2kcJL9i4NmajIqM,2778
-ngccli/data/api/NodeCreateResponse.py,sha256=SFimjY0Ryl_Lct0xKr1g1317rTSwxcSVB05sTPEdcMo,5388
-ngccli/data/api/NodeListResponse.py,sha256=yo_WbyB0JqPwlYv040bmW7QLaWYLSm6rwk5Utz-bf_w,4017
-ngccli/data/api/NodeResponse.py,sha256=UDdkR-JsodIVa5-uha915frpnKeHd1GUeZ56HSLF8bA,3755
-ngccli/data/api/NodeSimplified.py,sha256=UEQ4gBUMOJNqL6_qDaUOAshDfEe8eCGOS8lK-t9md30,3336
-ngccli/data/api/NodeStatus.py,sha256=jpslgG-4fzwd8xmeWFli_Tr1hH6U0qL638Gpx6D-sNU,28410
-ngccli/data/api/NodeStatusChangedEvent.py,sha256=k28J3QN7yJXFZKRazSeSF6kLVw4y4L51UOaaNIPhSJ0,1883
-ngccli/data/api/NodeStatusUpdate.py,sha256=Ie-mdZCcxAYmj70hCYaRO4dQFyviufxftI_doDKqnOU,4161
-ngccli/data/api/NodeType.py,sha256=rRboqXP6aGaZVR3dierWMt4i_IyE1smrcL-xjSxBMlo,163
-ngccli/data/api/OrgAdminUserCreatedEvent.py,sha256=VG3cC0CvksP7t0fcXL6Gk85n5P_vaNYVuv6RjXceYGg,3446
-ngccli/data/api/OrgCreateRequest.py,sha256=Co5OrApP7cZD4fx2HYcZfPZZDJ5xAypL1Gmxnb0YNgs,14183
-ngccli/data/api/OrgCreateResponse.py,sha256=NaoH9S33bc2R52yc_kavhfXVrMESqSOO-0ZrUm49Ulc,2929
-ngccli/data/api/OrgCreatedEvent.py,sha256=QfDfieq6d5FxSRZepHKNL09G_dov29i69dMri1PmaVE,1777
-ngccli/data/api/OrgEnablementCreateRequest.py,sha256=CVTGAZbu_92z0AWe8ajQVbr6PhKhWMDyG8vRL3xMP1M,3450
-ngccli/data/api/OrgListEntitlementResponse.py,sha256=N0zFxbitCCvFnNI5j_1xk-Xp_NoED99liTkdwJv2V14,3219
-ngccli/data/api/OrgListResponse.py,sha256=-qLU3SrydwAdCi6WPjsKppJ2rndOj19YdbmdrXobgPI,4197
-ngccli/data/api/OrgOwner.py,sha256=JJcTFI5DpxRsFETjq9Z3Phth8seBZOsWwbhsjvjDypg,4754
-ngccli/data/api/OrgProfileUpdateRequest.py,sha256=wSOKWsuZVlL1isxd55DhG3jBuN-VX2zLlNylq_VC41g,3459
-ngccli/data/api/OrgResponse.py,sha256=wJDHX1N_iKZVaxonaIJS6JmwR96JxHIcxMA7o0ORUAs,3041
-ngccli/data/api/OrgType.py,sha256=WSAh3QAhYsAq0pZFd05bLjAJT0VcODFsKt8tFWpPl7w,118
-ngccli/data/api/OrgUpdateRequest.py,sha256=VsbpQb3sSnWDXT4HoZXLoTaLm_Qqxl-xTRiMp3vJO5w,19529
-ngccli/data/api/Organization.py,sha256=uiYtW9un_fvCHDMfiwKLX9f6vuNHud_Lpnf5rE_CpMk,22086
-ngccli/data/api/OrganizationEntitlement.py,sha256=ry2x77e7PQsyPGWIwjJ335ypYhaM5lktTTSxTUp7MEk,2826
-ngccli/data/api/PackageVersion.py,sha256=Z6cPH7dEumjKI0GM7rzu386SXZIYNDFMebCfkEQB6UY,4056
-ngccli/data/api/PackageVersionListResponse.py,sha256=7YqZuP5iVeML9pc5OlqDndeojlCN4fQkupQMlAlX7bE,3032
-ngccli/data/api/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
-ngccli/data/api/PasswordChangeRequest.py,sha256=m6TGlwEJknU3Gbs7Mtts_SoKWwY0yAd1kmDST_QhN1E,3629
-ngccli/data/api/PhysicalNodeCreateRequest.py,sha256=Bn6XGnTXotZfPU_U3HeWWd3BEANNm9MOjWY-Lgtrx0E,5365
-ngccli/data/api/PoolMeasurementQueryParams.py,sha256=02rtOZjMim59ul1af20x9lODgJBE7gNRK4nWGT_4sYM,6106
-ngccli/data/api/PoolMeasurementQueryRequest.py,sha256=UruV0Y9XkiT0Rk_Q7X3lfs6GHW--Mr-5mPdoRHNs69E,2153
-ngccli/data/api/PoolMeasurementType.py,sha256=yq6Pv01ydSWNw92u7s4RpE-nlV_KLF-xHwV0XFK_jmM,341
-ngccli/data/api/PostStorageProvision.py,sha256=gB4Hj9_V_5HDR0WezZZTQT8_1ecfxusK3UN4IDhVZQc,4619
-ngccli/data/api/Price.py,sha256=rv54TOVBq3BUhXG-7pQKBMmVegdhWxnrRrKDtQ2Gees,4135
-ngccli/data/api/PriceType.py,sha256=WpihCEt6p9g83G7TNbU87n1dAK8MioVgRa6ZT_iBg7Y,107
-ngccli/data/api/ProductEnablement.py,sha256=IGxT8n4TD22En9xmcduK7c1B6ZUDBV81mCt5LF0GIaY,5355
-ngccli/data/api/ProductEnablementTypeEnum.py,sha256=U-RWZoaL5LMCKbUNPvw2egUxl7dQokiq2t9p76yR_OM,196
-ngccli/data/api/ProductNameEnum.py,sha256=ysTpUtsLfUResARGq0FiGc2cwNsaI2epfHueZhtbRrU,637
-ngccli/data/api/ProductSubscription.py,sha256=Iso5jG3_RucU1IxMnOYCFjXaOxqKqzLLjjXOX4BHyW4,7108
-ngccli/data/api/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
-ngccli/data/api/Replica.py,sha256=vhf-HQt-axsrkXJaxNYaloJuQTczyTlZeUGSNL0bId8,11869
-ngccli/data/api/ReplicaListResponse.py,sha256=KFooi4O206i-Ntu3PZriMG7XYcOGQO3btoSFl-1RZyo,4167
-ngccli/data/api/ReplicaResponse.py,sha256=r11zTtsxNjfkRKOxmkMU9CS5TAT-2LmjGlF7BKHz0fI,4182
-ngccli/data/api/RepoScanSettings.py,sha256=slbOIf1Q3S5HWf1Ssfh1TxMj5DRKwRiPF9uEi_OmocA,6724
-ngccli/data/api/RepositoryTagVexByDigest.py,sha256=0jVKReHqrSaL05R2-MQfWoYXMolqdmOFWxbGakU8T7A,2672
-ngccli/data/api/RepositoryTagVexDetail.py,sha256=OMS57-bRQeHNn3C8c3mK6jDA7CnLMpnG1IlJjgmxSYM,2528
-ngccli/data/api/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
-ngccli/data/api/ReservedLabels.py,sha256=5WrIennNIOlFAP28GHRIdW8ngDgzmDydHENVCg2Lnnc,1730
-ngccli/data/api/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngccli/data/api/Resultset.py,sha256=jifHXekzj9v0eDNc7AvTM_1aHL4eEnemoxOds6o00pg,11985
-ngccli/data/api/ResultsetFile.py,sha256=lnmnychCjjxV6-9I8QdrYD-KcSlc58xtfpLN-H6sYxA,6582
-ngccli/data/api/ResultsetFileBatch.py,sha256=tloKsOZgem4iflJzfsCEGi5R9xUTgGGq8dJ61ZwSHt0,2002
-ngccli/data/api/ResultsetFileEventRequest.py,sha256=tSgBpMqdqU1-OsZw14MsAJ-hs0eEryWIanp-3r-DUsc,4130
-ngccli/data/api/ResultsetListResponse.py,sha256=JAoHu73bcHKE0gpTX_hxf_lHum7fKybEnGGfWh3JLuE,5280
-ngccli/data/api/ResultsetResponse.py,sha256=XKm9n8Y-Z77IRZzbaJOwlGsXq1TJx5dFSjhpSuqLqu8,5145
-ngccli/data/api/ResultsetToDatasetConversionEvent.py,sha256=SXB3CzwkMl1WODrvaJY1zvLxXceiJCvEd_Sw-mt99yk,3429
-ngccli/data/api/RoleChangeRequest.py,sha256=N4zc14jMocC-DJalMZYI9vDmS3huWjFX2y2Nb6QJLX8,5182
-ngccli/data/api/RoleProduct.py,sha256=opYPVS5u9I6yfVA4JcQv4Bw1ViGwkb1y_WnTQ3tuka0,2623
-ngccli/data/api/RoleType.py,sha256=vz1ep3FiolCyEwdqOAXXJx0CG9Mw0XUZYXo1n8q-fX0,1810
-ngccli/data/api/SCPJobDetails.py,sha256=T-KfbNRwNFXx9Lq3CfOVYa3l7DqISsARhh5d2VW2080,1694
-ngccli/data/api/Saml.py,sha256=UyMGLkUb1OTrJ1x9QelRNOlSbh8Pq5riDuntzb7wdbk,2413
-ngccli/data/api/SamlResponse.py,sha256=yQI0jIxisHl6U4K3S6VXkB1wGSuCht7q7pZVdrcauRA,2747
-ngccli/data/api/Secret.py,sha256=AvR-T3jc2rqRsVz2zVXvxCkq2dZ33D6ByTSYuYhZeCU,3983
-ngccli/data/api/SecretKVEnv.py,sha256=9mIWnGDojgdSdrGSW8BrQk6x9U1WxlarZOyJzSnC3RU,4504
-ngccli/data/api/SecretKeySpec.py,sha256=sx4TtaePGrif_2rHMMox4T4Ml_inytfE__T7R6W2VaM,3314
-ngccli/data/api/SecretSpec.py,sha256=XZte7OZwv9uEkMF6e6P1OjAf7viF8MuhApdcM7MUWTg,4057
-ngccli/data/api/ServiceAccess.py,sha256=zv-qAyg4G3eD8VAs1MkkaFYoLvi3AHUEiFYJGRYyR-8,3507
-ngccli/data/api/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
-ngccli/data/api/StorageAccessInfo.py,sha256=2eSl9QvCYquZjviVJyido36lnWu4wYH45JwnvUrMmfs,4320
-ngccli/data/api/StorageAuthenticationResponse.py,sha256=GnXwnDANLbnXsHiSV9c2_uqdUBSRNTRxF-bRtH-ZTYY,6019
-ngccli/data/api/StorageCephInfo.py,sha256=5XnS__0RsgxgwwHfYr088k9m-3oQe4R_pgdKgsOVrnk,2688
-ngccli/data/api/StorageClusterCreateRequest.py,sha256=D4yKOCDLznReVSg9jLv1oc3H-U068_8kSTIDRnUARMI,11664
-ngccli/data/api/StorageClusterListResponse.py,sha256=G2oL8zrvklqsF6OQg2dLYt3vx20YkLf2j71mLPJ0PCY,3227
-ngccli/data/api/StorageClusterResponse.py,sha256=p5bCI-gKT4ieQ4pnIeLttK0AOgRoUxy1Vqg-muPkoh0,3140
-ngccli/data/api/StorageClusterUpdateRequest.py,sha256=ypX1wJk1p9Q_2YXGCAR3PFAPOvc175fYerCSncqQ1tM,9783
-ngccli/data/api/StorageEngineTypeEnum.py,sha256=4X1zYynMr4wcpLA_1xVvc84NBNxSSg4_qkjuzkRPMhI,129
-ngccli/data/api/StorageLocation.py,sha256=fYxlNvvIMHKez4-d2X1sPs18vqQDpVVbx4Oda33ch70,4059
-ngccli/data/api/StorageLocationStorageTypeEnum.py,sha256=LWSnY3HRhkwBGJjy57lrZb_ZnkXc4qk9Mgbv1ixwaGo,128
-ngccli/data/api/StorageLustreInfo.py,sha256=MZwqSmVucj3CaBHSH6iyVyn_zuEovXZ_4QkPHPdE74k,1996
-ngccli/data/api/StorageNfsv3Info.py,sha256=g7Xp2wQZNLQZrWt8vEFHsVvJOfKPTXOx3dnVd6EW44Y,1955
-ngccli/data/api/StorageProxyfsInfo.py,sha256=rQqeXm0DpoQsU1uxuVdVnsr6Z0dw2tyAVU-RrukneQY,2011
-ngccli/data/api/StorageResource.py,sha256=ZuXRP9SVcnoNL7K9vGawQUHG30oqrwZwerv_X0APDf8,17601
-ngccli/data/api/StorageResourceStatusEnum.py,sha256=DWrDvb0M6aWjIsJ0iBoHFJ65h1KuDLJZUcPXUupu5Hk,161
-ngccli/data/api/StorageServiceConfig.py,sha256=xQ2ij9qj2HNiteddaJFZiK8qokLxZH6gd9koFtPHFIQ,5120
-ngccli/data/api/StorageServiceConfigDetails.py,sha256=p06aHAf_vSCig8JMC7KYTz7FhvUrgY_SFhxZHnIwq8M,13574
-ngccli/data/api/StorageYarofsInfo.py,sha256=c9lLmlnVOEmkllOMEiTzW879iXTJyJjGnIBKQoYTC5s,5312
-ngccli/data/api/SuggestedNamesResponse.py,sha256=W0t-Hb_6xXa2_D9rBC9tj0WXyd2hAdXOVCzrI5scJOk,2722
-ngccli/data/api/SystemLabels.py,sha256=yLaTogbu7Jyg67CsFOUZusbekhML1ez-hI55JQYHoc8,1712
-ngccli/data/api/TargetSystemUserIdentifier.py,sha256=gIlIbqX6amfKAVlGX1QQ3uZkM78LHwbFbkvkxaa1ZpQ,6470
-ngccli/data/api/Team.py,sha256=Tv_a-XAPKxjij3ZxIbuQP8jNv8DsZL79qi-e4X6f8pc,6353
-ngccli/data/api/TeamCreateRequest.py,sha256=8awxlfnUFS6k68KOO18ADFcthSPzOw2ZujkBXfU8-js,3756
-ngccli/data/api/TeamCreateResponse.py,sha256=O6f7ol-t5z12iBgtXboH_0CtPQdCqYSbcH128RVXjjY,2856
-ngccli/data/api/TeamCreatedEvent.py,sha256=77vAtprTmdzL5LzEUJzv_VukI7Y6wiwfi2cGbDLBVQw,3332
-ngccli/data/api/TeamListResponse.py,sha256=EtEhqhiT6ktgAD61tSphKgCIuV1tVeYkyM_U-55VheA,4017
-ngccli/data/api/TeamResponse.py,sha256=kNnHS8yU0ZSIXEnc8lBDbGbhs1SsBY9mj1UyYnGulT8,2811
-ngccli/data/api/TeamUpdateRequest.py,sha256=kNAW_EBo8txDpexlWVxigeHRHi0L91mW5MJia-qdjec,4496
-ngccli/data/api/TelemetryClientCreateResponse.py,sha256=Z2llgkVNZrCe5EkDf5iUZEtjTDERe7WvjqPGKfL_Lbg,3608
-ngccli/data/api/TokenResponse.py,sha256=aIkTIj-5k4xpsrfKYhfiZOQCeHHtNw1Qo62LT1op7YA,2705
-ngccli/data/api/UpdateAceRequest.py,sha256=f0lNTCeGU58V74z3D5HoXZnl4xzcOSgttAl8odD0mNM,1914
-ngccli/data/api/UpdateNodeRequest.py,sha256=DbFzG3wn5Bls28ceQAlWBTjGSgB5gMEhZWbgBfiw_h8,2736
-ngccli/data/api/User.py,sha256=3ZP3C9xDnU3TMfNQ39IAMs6Xo6P-pEvHqIxgWBvw7EM,31143
-ngccli/data/api/UserCreateRequest.py,sha256=tA3Hp4xDWvLC87Z3iclkFwvH7CKvPjliGslseumGq5Y,9435
-ngccli/data/api/UserCreatedEvent.py,sha256=vT_ew2DzLqcIhMrbBhQusjNke3dV8_Hid_1oq9O_LCM,2525
-ngccli/data/api/UserInvitation.py,sha256=4woFFsbBCmgdrGboyyHw7xV6z0MGdxjSy3HXxTwAD60,9651
-ngccli/data/api/UserInvitationListResponse.py,sha256=oX5dmX8jNcycKfaJVScWFKaCVisfoTpyen171bphl4E,4231
-ngccli/data/api/UserInvitationResponse.py,sha256=8w0YpIMzZfMqK_NxfZDk4rUZvAtxJ4BERLIcqK4-Gbg,2988
-ngccli/data/api/UserKeyResponse.py,sha256=zJyNxvsXrq6miALIjuxJbKn6nCXqRndzmAuEItpyhMw,5560
-ngccli/data/api/UserLabels.py,sha256=eoFQ4SRV-8hIDX8bHkz_7X_gjxHtAiagAy2UQ5mutkI,1726
-ngccli/data/api/UserListResponse.py,sha256=Fa4rkn8WaAFV0z5uhHMpg-GbKHDO3N5xaE20M3qJsaQ,4058
-ngccli/data/api/UserMetadata.py,sha256=1GunPpiDPOXdqLxkX-fEaW36dFmdMitVdJb2NNH90SA,8112
-ngccli/data/api/UserOrgRegisterRequest.py,sha256=S7gDoammaGdenuO6lo1HbQpjF1tKLnaX1xhosymz8D0,9791
-ngccli/data/api/UserRegisterRequest.py,sha256=hoSH4orYod9GYsEq_MXG_0auSbH9EPgWEqNdOAxtRgU,7022
-ngccli/data/api/UserResponse.py,sha256=ih9SyGsTXQomhQc-J0a0X8DvTQ-zmoga4yQ0atDBzUc,4806
-ngccli/data/api/UserRole.py,sha256=8FH_G90QUVvg2h-jDoHRjewv-NQUCgcziQ_-5-oQX64,6556
-ngccli/data/api/UserRoleDefinition.py,sha256=6B4SLvpG4Tsw8grrZZrytN2QbVlf0Jti1JdRGGCUmfA,5464
-ngccli/data/api/UserRoleDefinitionsResponse.py,sha256=zI7TMDNMiSOHaU_ESuVcjpVYFVkqsFTjulsqfmaSYlI,3085
-ngccli/data/api/UserSession.py,sha256=Nuvgw30MBD_nW8VZzBVSIeSbAmVBqNV_oKtD2qGBBKc,1780
-ngccli/data/api/UserSessionResponse.py,sha256=ABh9_t0ehu4tsAol1zsDga0YfQQs4Nb5hvie9Lu7HU0,2986
-ngccli/data/api/UserStorageClusterUpdateRequest.py,sha256=2Hbezbp1DnVz7fNI9QkubiGgjcbWzwDyHMiERnC7YsY,6456
-ngccli/data/api/UserStorageQuota.py,sha256=9ZfUcjOBq7Ur1jjkZ3JJL3DZAM2D4X3w-3OUHYrmy2Y,12800
-ngccli/data/api/UserStorageQuotaListResponse.py,sha256=W615RV3qcdAhdGjL8MyG-Ye9XC6M5w57qTJhzjsb-dA,5965
-ngccli/data/api/UserStorageQuotaResponse.py,sha256=ErGrbpv3XjiS2ksiIGBF0-Ba43GTx_jDZSNllU881rk,3210
-ngccli/data/api/UserStorageQuotaUpdateRequest.py,sha256=hPDn3aeQUvjf85oCSqrdygXGxVWqBIxO0yJheAKtM50,3825
-ngccli/data/api/UserTopicEvent.py,sha256=GyafLEQ65G3n65stYL8oc0xD4MUuEoL7ENL43wisCl0,6239
-ngccli/data/api/UserUpdateRequest.py,sha256=QB2XwAF7oGaEbXt_CuIrCmAQc5nOiJ-3kh7NLTMLp3s,16740
-ngccli/data/api/UsersInfo.py,sha256=gLEr6mMH3HpclrYfy1JjsgM3x2s5GEVjcPqTOAKhs-0,1718
-ngccli/data/api/ValidateOrgQueryParams.py,sha256=JzT7XPyGBmSYKn4muvjnKZRd6DuluXHp69O6jWDsE0E,4635
-ngccli/data/api/VirtualNodeCreateRequest.py,sha256=DsuSdEjwc_zu4831o7JSuzGKuT1D9pkwhC8u4bAWW4c,2604
-ngccli/data/api/WebSocket.py,sha256=Vn5SYAWofD1Si4t6CbyJ17d6CCWYId6hNu9UauET_Jo,2873
-ngccli/data/api/WebSocketReceipt.py,sha256=VQ0oSQKTB2XpODPKPgfgw8ua4DhVCIeAQ9HYN8mQdAo,3611
-ngccli/data/api/Webhook.py,sha256=axu4KTqCOcl4c1ExPt6RDvquqd-79WLdIIlChpAmY_E,9410
-ngccli/data/api/WebhookCreateRequest.py,sha256=mAlZOFEza8l6UnDd0OjXsL4EzLeb-55X3P8VvH3ckm4,8997
-ngccli/data/api/WebhookEventType.py,sha256=OJvyyPDkgFSjVrj85vgGY44TkYl4r4ybI8zbZuxKLUU,127
-ngccli/data/api/WebhookListResponse.py,sha256=a6cTFuuGmLNUAJ_jFl3WsFK1DINIdEkLnKme3dweVms,4112
-ngccli/data/api/WebhookResponse.py,sha256=3Yclh4w1-y75o3YA7yTjsuMCPhIq0b_vyGwx3YWQx_Y,2860
-ngccli/data/api/WorkspaceCreateRequest.py,sha256=qn0yw9ChZhwnZfN6P4rtCp1PxJZZ9ymMZ7NVLC3TgjU,5270
-ngccli/data/api/WorkspaceListResponse.py,sha256=Yzv4UB8FL33Ua4gqyJh4Sv2Gpu1C82gWT5WMi-BrarQ,5272
-ngccli/data/api/WorkspaceResponse.py,sha256=H5NeRBVpDhGz1jnQk_QhliH0bry_xwscGnNQRDktwsg,3019
-ngccli/data/api/WorkspaceUpdateRequest.py,sha256=-yfkRjaJB1gY5FF_IVcTsokIwl3nemyAhb55gWoHbRw,3430
-ngccli/data/api/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/ecm/AdvancedStorage.py,sha256=-OPTFMP7pfFfe8gzTohnkFWRqWXOX7Y7nUC1dsWG6_g,4573
-ngccli/data/ecm/AdvancedStorageResponse.py,sha256=2KP85skaAtqSRgtsSf-uQN0MvU9CGe1oWB6nLJBABPw,4833
-ngccli/data/ecm/Alert.py,sha256=1gnnq_lPxBwuDzJhKNfagrsAXM8Cz0xxZis6me_t8C0,5307
-ngccli/data/ecm/ApiKeyCreateRequest.py,sha256=uM96Yd7VVI-LIF9qb61nMDs9eLRR87bQFlqZKxJwsHo,1874
-ngccli/data/ecm/ApiKeyResponse.py,sha256=3rI59BhZsks3YKCAGfJT12P3P4jyGlwQVZpZnRPAsLE,2784
-ngccli/data/ecm/AppConfigCreateRequest.py,sha256=OHJgwh7nKU5RMH9pCs_SdcYSkEkpGh8Dc1NIMgVVAT0,3553
-ngccli/data/ecm/AppConfigResponse.py,sha256=ZN-HCYGgUisS0VfotW7jw4j4PFKXx-1C75LPabqAO5U,2930
-ngccli/data/ecm/AppConfigUpdateRequest.py,sha256=dtt1k82jPMZ-UsQ6Qhfu3CFboUL16XWF3A-dmcT2LYw,1827
-ngccli/data/ecm/AppConfigs.py,sha256=1LHbL_QoM2cCsS1ExFEo41pppoxHbuQpfVOfQ3gRfXE,3775
-ngccli/data/ecm/AppConfigsResponse.py,sha256=fGTiIKOgJZ4yurOV4fvpHmukXpsWt2_gzIL0W0R8o8c,3087
-ngccli/data/ecm/Application.py,sha256=ZxoRbDDX96wQu7cRVzVSjB69iQ50SMWkAy2EEF8MRew,9830
-ngccli/data/ecm/ApplicationRequest.py,sha256=hygOEBtvOmX9CCgsFKto_vDnPv7MgZR1FsAJ4N7R-n8,1902
-ngccli/data/ecm/ApplicationResponse.py,sha256=8h13_29v26_K0IDJeOhuZRJjPHvpLKszCPAXCYwn9uk,2971
-ngccli/data/ecm/ApplicationUpdateRequest.py,sha256=OV-YVeq1XtYwugqqLpQrNGtZM_RmBU8wsuQNRzvLfMo,1908
-ngccli/data/ecm/ApplicationsResponse.py,sha256=kVPYKga3oAXeRYubH6kfi4Tib-dbYowx_6jf7IAbh-M,4230
-ngccli/data/ecm/BuildStatus.py,sha256=u0VkJvL3CGs08nQECkcuRfBlc0tJtwWO_ZZC_go-aQY,4266
-ngccli/data/ecm/BuildStatusEnum.py,sha256=IfOAZMzjYcnFNY8xhufZDUxBN2KHAMYhZSXgZOyhh7Q,120
-ngccli/data/ecm/ComponentResponse.py,sha256=aoZvSyySrAwVgKAAljTlds29D5qvxgwVvzZwRrNw040,1735
-ngccli/data/ecm/Console.py,sha256=NRCwHTIhq83-68NJjrJyt6LyDRLDrDlOi7u0Kpz-R_k,6318
-ngccli/data/ecm/ConsoleResponse.py,sha256=iiq_ak7H4kOfcyoawzJ8Bam8w3M1K6EPnFXlFB7qc3I,2816
-ngccli/data/ecm/ConsolesResponse.py,sha256=boLwZGU3y925iDNe68c_R5beXyCWAFlLsx-8L0p85JE,2984
-ngccli/data/ecm/CreateCustomRootFsRequest.py,sha256=RifLC2F9kHN630XPgkdCD3FiSeetWF85lKyhaPRSvtU,2879
-ngccli/data/ecm/CreateDeploymentRequest.py,sha256=OkKOPlfif8r2dajnpMt4Lo6aPgNwOZMVJSDB3DtC5Oc,13151
-ngccli/data/ecm/CreateLocationRequest.py,sha256=7dt2ztTZE8KwyYezBnNALMGFwXUwID20j0Zt2rCkeac,8959
-ngccli/data/ecm/CreateNodeRequest.py,sha256=yBp4X5zqqHysVBuNBcKTFwTQ02M48riDzjQxEK_nWic,5933
-ngccli/data/ecm/CustomInstaller.py,sha256=w15TYjnqtxENzjpKg5eLLwOwdTpulVi8sRb-Cgdr2As,9573
-ngccli/data/ecm/CustomRootFsCreationEvent.py,sha256=oxHoSEiLZ6HjggmM-E9g-QCZYv2ln2C_pOL1LxjbLAE,3846
-ngccli/data/ecm/Deployment.py,sha256=Oie3kH_kLJlFAs3HRFcd7vmO1aucENdIoMAq6XWk05M,20692
-ngccli/data/ecm/DeploymentLocation.py,sha256=cZri6vypadr88vH0_YlIM_9uUrDLzxofcmrjqxXC7EY,18100
-ngccli/data/ecm/DeploymentResponse.py,sha256=c2PYgdGvaW043KjbZuHwhmESeVN3pyQduc9KkdhkVHs,2904
-ngccli/data/ecm/DeploymentsResponse.py,sha256=Gnto6RUw28v9aT9dtkiqD2LPZOcyqjtha1yaDHrdA-I,4134
-ngccli/data/ecm/EmsMetaData.py,sha256=Gl_NeH8iMUnxBcouLC84B2o7oVdveHmdW8220SZm-Yg,6181
-ngccli/data/ecm/EmsResponse.py,sha256=OGKF12PEP1U1EQawYYNCDBt5Ekj7lKQ3KSPdAhgLDeM,5052
-ngccli/data/ecm/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
-ngccli/data/ecm/Git.py,sha256=RO_ekziSGGxxWM0nu6-I4baFCv92FABMHclONiZQTa4,6817
-ngccli/data/ecm/GitApp.py,sha256=dyFdRbpIkbWM3XgtEsknJNteeB2KCAVk2lub7G7ftOQ,3435
-ngccli/data/ecm/GitRepositoriesResponse.py,sha256=Lw12ZRDcaIjjfLal7RhcfpJttIT0gQ7kHDp9XA5STXA,3128
-ngccli/data/ecm/GitRepository.py,sha256=v4J6opNXlH0wj5tJEBCbTdXAxardrzScjBJ_y9XgZLk,4160
-ngccli/data/ecm/GitRepositoryRequest.py,sha256=PDGbOrXGsdnO7NynLl2qG6hpjuS56OcvCKa8GjnLTtE,9018
-ngccli/data/ecm/GitRepositoryResponse.py,sha256=7dmach6YSCYU6Ww3J9jPB7wGSRP09jnzba0FvWWLEL4,3085
-ngccli/data/ecm/GitRepositoryUpdateRequest.py,sha256=nnjcMvf9Llc_hhHprh0gfn7AdzpPMMx2SyYIYFV3aG4,8283
-ngccli/data/ecm/GpuInfo.py,sha256=RnvVEl-rXCohXfR_Vc1JhzIsq4ZtqSUYt67dcWdnuT4,7370
-ngccli/data/ecm/GpuLogStorageUsageResponse.py,sha256=OG7xzEh96RY-whBJV2q6eMXgkqVFvKc30yJvFOBEIuU,4393
-ngccli/data/ecm/GpuManagement.py,sha256=6qco_LQ_j5UVl9I6fDlQ8WolehbhfWx0Yn6CCkIL5cQ,6483
-ngccli/data/ecm/GpuManagementResponse.py,sha256=I3UAnVERI2LoQWQbzdIFGyFxfVNp2V-IOGBoFb5h-so,3140
-ngccli/data/ecm/Installer.py,sha256=jew0dgAGcxKJoQRIRZ32YLUSDFNS73pcA43eKM96np0,2425
-ngccli/data/ecm/InstallersResponse.py,sha256=5fu-6DZKhfyd0XKR1i8vfyBnEle-g9uYWJ3CFyBccvI,3206
-ngccli/data/ecm/InstallersValidationRequest.py,sha256=e1sbo4UtfDzgaXVzaQiC3Pp6CyowIWqq-WtgD1hmmwc,1931
-ngccli/data/ecm/Iso.py,sha256=7xcmYutufUgXOq1XNe9Fbf1V9c-aI0QnTLzlhrZDcM0,4001
-ngccli/data/ecm/Label.py,sha256=OK22Ft7T0fip9cUWanQJ5rchXoTlEaAyvt6BkzDIYQ8,2293
-ngccli/data/ecm/LabelsResponse.py,sha256=q0IdV0ASBr7i6sfNJ7KyPiKJpwbjABNpVkXBYknwzxE,4033
-ngccli/data/ecm/Location.py,sha256=YZxEzQnbMnjrPVF-q-3UaD8w1_KvjSyXxJMOhdTif4k,21965
-ngccli/data/ecm/LocationAvailabilityEnum.py,sha256=ApbjV6PuedX81Dg7ZUjP_rMioVYRIowBKN9uUS2MRMU,126
-ngccli/data/ecm/LocationDeploymentStatusEnum.py,sha256=dUEifvGMtlCrZ9kiJ_b1xl6t1RxuTR4is0mKwPo6Kbo,178
-ngccli/data/ecm/LocationHealthEnum.py,sha256=V-cjrbLDWcD-4qTXHiZNO3hcfdInWE0ooQqTmZ9waKc,113
-ngccli/data/ecm/LocationResponse.py,sha256=hTmNcMV37kwlPGpWR-nX9N21U9mmYz36x6FpumQfeig,2858
-ngccli/data/ecm/LocationStatusEnum.py,sha256=-g8dPu-EtwikLc3KbK5Bx0W-3_hJA28tvwa1AjlDIvg,137
-ngccli/data/ecm/LocationsResponse.py,sha256=Q4djnD5RyQfPrB-8HbUJAD_m584B0AmWq2qjqRy74iU,4143
-ngccli/data/ecm/Log.py,sha256=QrUxi95CJmK0zUlwa5a1yDbW4Oigzcuue9AJ7LMmK2A,3653
-ngccli/data/ecm/LogsResponse.py,sha256=q_pXinApL4nL3K0f1VZvolAvOFOR4xhWcqm4QrSofmc,4091
-ngccli/data/ecm/ManagedGpus.py,sha256=ZYMgmqgK45QasKzhDPTA8h40xvOWBK7qwNRwRSxOkH4,2370
-ngccli/data/ecm/MetaData.py,sha256=0Xxg_-qFMFssKIrUarqwXpQ-oVqqnF2CZVfS2N7_WkE,2296
-ngccli/data/ecm/MetricQueryResponse.py,sha256=2vINUD98EnMIpJtEEjNUFh362VyVuQ7yd-QzTz8Io2Y,9696
-ngccli/data/ecm/Metrics.py,sha256=Idf--YwlzXLZOQ7xbGxQo9211vXfrGIJvTuYP_gJ4Qk,2358
-ngccli/data/ecm/MetricsBucketsResponse.py,sha256=Mo3gcru9MLctBxOyEw7Nsm4fU_h8916Bsj2EcsWyj5E,2679
-ngccli/data/ecm/MetricsListResponse.py,sha256=iU85VDfj1eG3YXsJbjVdobPbjOAyub8edKqPG0ltGbs,3697
-ngccli/data/ecm/MigProfileInfo.py,sha256=kFC3UF8i7OMpdpZePVkZL873cEY7ysHV5wBaGt2vO6s,2463
-ngccli/data/ecm/MigStatusEnum.py,sha256=LE_uCcRkyXpF7U9CBHHEm3RIt9cPC7H58_fgn27Tbh4,144
-ngccli/data/ecm/NetworkInfo.py,sha256=RW8g52jw2gefyYzktg8s9S8b3258HM1skpfUk3xxsBw,8419
-ngccli/data/ecm/NetworkInfoResponse.py,sha256=nLHgmfXE8HkGSQObqbdzCWUcQ1OJJtMGYgFwtH7DlKE,3071
-ngccli/data/ecm/NetworkInterface.py,sha256=ed0yd6iMPmkA9D-DcLrQfnQ3VcMWg6vgF6CLY_NQm9M,2536
-ngccli/data/ecm/Node.py,sha256=nXoAjoK49y-XU-5XnUWQg-GqPXtpjMXR3ZoFgS6LJWo,20002
-ngccli/data/ecm/NodeConnectionEnum.py,sha256=DU-LDLAY06dP4IsTWzhpimk56xA2yrHEOzx1vOsgWIo,107
-ngccli/data/ecm/NodeGpuInfoResponse.py,sha256=Ssi7OIR6l5ZvFBVRC0INikpRWzHoZP4QRhZsDNZbdRo,5671
-ngccli/data/ecm/NodeHealthEnum.py,sha256=U4RbRM0HqI4udjcR01T3vndJNOft6n4muK1PNFkF4MI,118
-ngccli/data/ecm/NodeResponse.py,sha256=bVyeVSZtN2aYMhwGJ7os33kkLuBU69L8jBhH1RKGVSQ,2747
-ngccli/data/ecm/NodeStatusEnum.py,sha256=aKWUxxjmzsAv3cLNKCBopvDi8vEUlAfLR588WF3Re1g,197
-ngccli/data/ecm/NodesResponse.py,sha256=6HU-enmg7Dz9UhI4ZQgg_P9nr9UCLa2GI2RYwTbGL2s,3983
-ngccli/data/ecm/PaginationInfo.py,sha256=RzvaVvJXG6Zr-xlbGXL0uXZpdzkPRdhrt-IuOkvX4ak,4827
-ngccli/data/ecm/RemoteApp.py,sha256=JR0hgxKXlFCxAiAe7Hip-wAaX1Y6le1Z2chQMibJhPE,4565
-ngccli/data/ecm/RemoteAppDetail.py,sha256=3AWyr2h07oYmP4ikJtHy5DhDDnH35v8A7uQ3Vy6kKF8,6169
-ngccli/data/ecm/RemoteAppResponse.py,sha256=8RcSyy93qHOz3PrUEAJVis1gNsz9yz6u9qCec-nZas0,2923
-ngccli/data/ecm/RemoteAppTunnelResponse.py,sha256=92-GRCLP2XGWIBFhYCtxcC6mJctizdsA6whTwh34e38,4964
-ngccli/data/ecm/RemoteConsoleSshRequest.py,sha256=zXFZ-GLsZfIrqiITlwrdvg_CacQuAvq7VCxkJAfExhI,1923
-ngccli/data/ecm/RemoteConsoleSshResponse.py,sha256=XEHAxaWjaYbQXD3Bmz1IIBiteSJ6AeLjOH6PsXvsOTo,4984
-ngccli/data/ecm/RemoteManagerStatusTypeEnum.py,sha256=fnbX6RubpgJ29StXQN5GRPHFCeV-Q_bVdZI2onQ0uwE,169
-ngccli/data/ecm/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
-ngccli/data/ecm/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngccli/data/ecm/ScanResultsStatusEnum.py,sha256=tFJIAh95KnlR0d_qGL_aEE326u7VAZQPPxrqt3ufGr8,118
-ngccli/data/ecm/SecurityMinimunSupportedVersion.py,sha256=DzRwtEIEujdDy4-m2gcieWST6TXLQal4AxWUl63UfYo,2626
-ngccli/data/ecm/SettingsResponse.py,sha256=8zcF0mtQ8j2mkacREtStdhsfWdH0PJg2hWxLXfbYVCY,22970
-ngccli/data/ecm/SignedContainerKeysRequest.py,sha256=zwc7Xhed_Nm8W2OReFVOsKXRajAMZwGba0TMHgPmS08,2144
-ngccli/data/ecm/SignedContainerKeysResponse.py,sha256=nacBhAZn41RXVsFDT1F0FoRzoWMVkOJD-yUGF-bd2Eg,2145
-ngccli/data/ecm/SortOrderEnum.py,sha256=Cw-ArS2GMR8Z0eqxYoYMN_AQvZ3vEQKHjFsK318lUFI,218
-ngccli/data/ecm/StatusCode.py,sha256=EFA9uFXyUPfUR-XR3kFqD6FptLFHM4ChcsYkXnUjq7E,282
-ngccli/data/ecm/TypeVersion.py,sha256=JDseBgpGUzi2Myyht8WapKvwbY2SGFttQMzZp0PF8Gk,3164
-ngccli/data/ecm/TypeVersions.py,sha256=XJQ_qQG5fAwBcMxaK5JriaKWbJVU11KRcvMsCSUwcpM,2721
-ngccli/data/ecm/UpdateDeploymentRequest.py,sha256=mk_Kxu_hpRpOafRZWLoCmOxomplS1gRuULRadSQHv2o,10110
-ngccli/data/ecm/UpdateGpuInfo.py,sha256=RP-6B3XpvKS0bzVaPKnt6yCmew1k8L5D3D5lBeDvsbQ,3333
-ngccli/data/ecm/UpdateLocationRequest.py,sha256=wlc60LgHTlsxUX-32JHMorSNjQB13kSL98w_KMF4dUQ,8527
-ngccli/data/ecm/UpdateNodeGpuInfoRequest.py,sha256=ULtR4SvnbOpOFQKKeb7bFYhe4DGlwpS9eHuXFTws6ak,3012
-ngccli/data/ecm/UpdateNodeRequest.py,sha256=m59kptLuTyl7QGL8O1qUj4KM3gR98ML5d7qot7run5o,5183
-ngccli/data/ecm/UpdateSettingsRequest.py,sha256=wYwo9_lvzXL4gDgmlBDKFE7iI9QoO1Pupuq3uPWBWJY,11447
-ngccli/data/ecm/UpdateStatusEnum.py,sha256=FuPYKwe_Qv32ucHOCh_5sQWVbdSDp4ni36OJT3ZLiAA,215
-ngccli/data/ecm/ValidationStatus.py,sha256=Aya5mNybuFsCPzamwAhIkiy7FbHsJy62LF0RGbzC6ug,3920
-ngccli/data/ecm/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/model/AIFoundationModel.py,sha256=kTpusqO33gS65YyXW-e_qv78WIkWvy071TgakHJZ7pw,7525
-ngccli/data/model/AIPlaygroundCreateRequest.py,sha256=_Ap6coh66ZEOdVR02VBhjH_7BUYrq2RmXeb2dp1FU7Q,4299
-ngccli/data/model/AIPlaygroundResponse.py,sha256=V4QgmcxZtoEVjQy2r-QiEjAd-URpTtDX-5yVJK3GOOo,7548
-ngccli/data/model/AIPlaygroundUpdateRequest.py,sha256=ieB3R2gP0sYUToXcBylzm7vHERPFLKLEGHyFTzTkWzQ,3461
-ngccli/data/model/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
-ngccli/data/model/ApplicationType.py,sha256=1Rzy9CYud3j7XY0o-uefAZRzeBvDL2U4qMzfT-SQhGs,552
-ngccli/data/model/Artifact.py,sha256=xj96Jsm5v1NBwhOekFkx_fifdtr-B6flCad4od9kRUw,24085
-ngccli/data/model/ArtifactAttribute.py,sha256=jIRENKZZZ6bHWVHCH-IWzlpGJ9JU57zNbp_aD7WvBvo,3124
-ngccli/data/model/ArtifactCatalogFlags.py,sha256=cCCw1TEucNeUUO5jmyWexiS9-ub9PxulmiVp1jvM04s,3524
-ngccli/data/model/ArtifactCreateRequest.py,sha256=HetC3O42HFuh_zg7pCmroVJ4Ly2A6QcAbc-pDsDqn1M,15113
-ngccli/data/model/ArtifactDeploymentParameters.py,sha256=MUTqZTvIzVr_OHKiKTxW4dD-w82-80vqyvgG7oEXCu4,9003
-ngccli/data/model/ArtifactDownloadAllRequest.py,sha256=ykNhDhoFYa42BVOrWmEyZj4FzIcmQsqgNPJU9IO527c,3853
-ngccli/data/model/ArtifactDownloadAllResponse.py,sha256=Y9yBvxQkO1STC8IBEvbpA0178kgxPRs_EIclQNBlC3k,5910
-ngccli/data/model/ArtifactDownloadRequest.py,sha256=Swl61UiL6GUvz5866lRWm82Pt3eYDofgWN9BB6miZFw,4808
-ngccli/data/model/ArtifactDownloadResponse.py,sha256=vsaxqA5lh9wSvCTWKfE4waHqQZPb4mjZ6M6v-_gavgo,3732
-ngccli/data/model/ArtifactEvent.py,sha256=8S-JqnL0d2Mjq5nX05CNzsn2nkKmboNxT1H1wAPE9x0,5414
-ngccli/data/model/ArtifactListResponse.py,sha256=NXMSerLu6alDHIDkVDSzqXkrqhthed5owXT8iEJotoo,4148
-ngccli/data/model/ArtifactPublishRequest.py,sha256=jLlJKJpAq9sgK3FYReySXnawy6qFGXfB1yQCZkWd3JE,4967
-ngccli/data/model/ArtifactResponse.py,sha256=zih3X6AA5BOfvPtxBd8FSEShsNAmxMOBE22W9z-S3Ys,2961
-ngccli/data/model/ArtifactTypeEnum.py,sha256=o3G8-cGrsfhDmnoCoTjGKiKxl1G_fBhJhvpq-xtvwXY,146
-ngccli/data/model/ArtifactUpdateRequest.py,sha256=UeJzrvWJNcToqL_UyN-fL9ZNQLEABPDKXwy2xiEfKUo,13199
-ngccli/data/model/ArtifactVersion.py,sha256=sHdjHizrz405FoYDcqeFqOzXOf_-agWL-p6ewRPKI2k,10576
-ngccli/data/model/ArtifactVersionCreateRequest.py,sha256=68j5AibJoVCZHPcfduKMMoPQlhfmsVCwjCmNDGLLN1k,3799
-ngccli/data/model/ArtifactVersionFileListResponse.py,sha256=eR3ktTSNdSwihenZi8-LgJ-890gsrI6Ae7I38C_fpYY,6261
-ngccli/data/model/ArtifactVersionListResponse.py,sha256=9gsIRjTtgw084X6tQ4Mcq2NaY_fhoMR-Tt_31daMtBU,5241
-ngccli/data/model/ArtifactVersionResponse.py,sha256=zOPZnSbVlD6Xs8LDYq8oHvwwpU7XCP1JB1Id4nx_aEA,4083
-ngccli/data/model/ArtifactVersionUpdateRequest.py,sha256=SFYVdqdfEuO7Tz51yT3xUqI0lKvJiVdnMHDWW6iwE-o,3979
-ngccli/data/model/Asset.py,sha256=x8Z-Dz00YwNQy7PbrOv0R5zK2qpw6GkieYw4daVIcW8,19418
-ngccli/data/model/AssetCdnProviderTypeEnum.py,sha256=jlBQlBx72yPyp54ZiAAVC31pdLhfVXFE683mYHMpOhs,114
-ngccli/data/model/AssetResponse.py,sha256=CaBZb-6rcFbrXp8nN6xsGaM6OgouJowxgIvDGuOSHEE,2864
-ngccli/data/model/AssetSimplified.py,sha256=izrf1BXuf0jAAjrtQLYKqsH3RL3wXtU_jzWIxTKmcN8,3575
-ngccli/data/model/AssetStatusTypeEnum.py,sha256=J4GY68RLLsyKKaSbwXQPlIk4zjtGhzFlE4mxE9AZ8Ak,141
-ngccli/data/model/AssetStorageEvent.py,sha256=ebmpp_RdRYPkbLk1zkiUsMiEVv59MVT0Zbrj-zsxExY,4470
-ngccli/data/model/AssetStorageTypeEnum.py,sha256=lTgUup8hMDG6J0yaerqlhmC4oB84RQa-wKFW7b-lri0,97
-ngccli/data/model/AssetUpdateRequest.py,sha256=KrC0Kz5ZwC5d59xPtW_Z4905aiZaS_61odPwxMNsuw4,7178
-ngccli/data/model/CatalogArtifactMetadata.py,sha256=lDgOalcpxgScHG9Ajm7OIWfUZcsvYHujBJ_MVh6Lk80,5084
-ngccli/data/model/CloneArtifactVersionFilesRequest.py,sha256=ju0fRx-07Rlo3QRBGNq0i7egRw7MG3WuPvnmCfO7hQ4,3994
-ngccli/data/model/CloneableArtifact.py,sha256=5KRa9dzoSF--9_HntvfQLDM3f9SUZF5Amt592y7zEHo,3916
-ngccli/data/model/CloudServiceProvider.py,sha256=OlUdf7EiY2itAB42W5rx5ZOtegylBrzPp77UG7MgGSQ,10280
-ngccli/data/model/CloudServiceProviderCreateRequest.py,sha256=1yDQUMcTQZVvhME2PZg1EG_qN9aCrK95ClIjMaqfrYM,6963
-ngccli/data/model/CloudServiceProviderListResponse.py,sha256=CjmYNKlJW6Z2Wgx9VYqnpnbAphIpL1eBiJYBT_C_R_Y,4414
-ngccli/data/model/CloudServiceProviderUpdateRequest.py,sha256=ysDbQkdIB9Uch7pP4DT-2Z6v5YWA8JO-KQIOS97NN2U,6037
-ngccli/data/model/Collection.py,sha256=r7XZqsU52U_0LFZrji--gb9Z9LOm1zeD-EmCcOtBD58,18935
-ngccli/data/model/CollectionCategoryType.py,sha256=ef64cWHNiLxyTcqQ8E0fPV0bKvb9ZroPNxe6na8h_1M,510
-ngccli/data/model/CollectionCreateRequest.py,sha256=mPssBNe3GAJItIxAbrFM43pvomDzlnNcvMv8CD0jTuc,13636
-ngccli/data/model/CollectionListResponse.py,sha256=We7FCcmaV8VqBkSzfTEnkoJ2GXHN_dvywuNLcT4C78k,4192
-ngccli/data/model/CollectionOperation.py,sha256=j0BiL1cXfWjJh72ZPSKC9Gsqs9BGczWvbcNuMC8dWDc,3343
-ngccli/data/model/CollectionOperationType.py,sha256=QCgIH475WgYjbjcMUe8uyReWMTVPqTFVNuIl_NJYEHg,131
-ngccli/data/model/CollectionPatchRequest.py,sha256=LZlPfmFX4iMr2KKHfQs1Y1v7HzjiodhqM7zUtmd32u0,2338
-ngccli/data/model/CollectionPublishRequest.py,sha256=yxlYmQUdpX0q93psgYWCoqebzFDn8MPFZEDq0ARTlyo,4970
-ngccli/data/model/CollectionResponse.py,sha256=vDuLWwYZ2QqT4Z-sayDPyaIhd6CQp_l4-y2EgW89swU,3020
-ngccli/data/model/CollectionSimplified.py,sha256=w900yJcwEYzBX90SQ3HX8Isuh9nZ3M4bRvwvD53A7Pw,3610
-ngccli/data/model/CollectionUpdateRequest.py,sha256=KpkFkcpE1VHCV1ayJOtZc-xTCl_8Dy1MuNetj4zs3pI,11520
-ngccli/data/model/CountableResource.py,sha256=OFu6lGeuiX3CkKPJbBPqgj7BWvz-LYF1pzoAEzGUH7I,3329
-ngccli/data/model/CustomMetric.py,sha256=AjM8-JV-6oxEcjNDcHehjN0cf10jxttciV1lIM7QXJU,2799
-ngccli/data/model/CustomMetricGroup.py,sha256=fGd5W4dGxtQ4bgH_Tt_3QAe8TBUuoA7NehR9nK9zDTo,3003
-ngccli/data/model/Dataset.py,sha256=IpsCVnx0h0JmEAMqX4XklW21aFeBAjU1q8h6MdOcz1c,3803
-ngccli/data/model/DeploymentArtifactParameters.py,sha256=g_wt3bKOah-JC8II_dE4zE8fBTyq6IH4JSdzDa9mC-w,6861
-ngccli/data/model/DeploymentCpuParameters.py,sha256=lR9Jn5CozL7YogLTHp1EZOgby-5IuhRau1YyebfH1ac,1683
-ngccli/data/model/DeploymentCpuParametersMeta.py,sha256=RADfy2x7mBrSvfvTbo6zuPhdNJkn6YbF0eG7QZAPrMI,2160
-ngccli/data/model/DeploymentGpuParameters.py,sha256=aYGe3rRtcjSP1Y2DK5E-ENe2z4G_NrcOrQuRlN6MTlA,2387
-ngccli/data/model/DeploymentGpuParametersMeta.py,sha256=pAiuVcjhAu38GcS4b2eJvTVnIeQ7k8tNIBwzDQ4f984,3127
-ngccli/data/model/DeploymentMemoryParameters.py,sha256=7UZfDDxEkCcqLwC3wIBoqKe3XUg7Og8l3ke4ORs1giA,1787
-ngccli/data/model/DeploymentMemoryParametersMeta.py,sha256=Q2DXY6YpBfwi5zfsaTN6ofhD8UhiKiFBfaCSN5F6R9E,2288
-ngccli/data/model/DeploymentParameters.py,sha256=UFM9EFjMJJlF6y_ysASa_SImne2LG-y1gfOx-BtJmkM,8995
-ngccli/data/model/DeploymentParametersCreateRequest.py,sha256=yVY8IcDJKnWK9aLA2FCB_e-1Qu5wWP1ktJ6JkNwRCnU,8305
-ngccli/data/model/DeploymentParametersListResponse.py,sha256=TDRWG3MI8K7bEN2i_SHgoQuTBfqALVvL630EEKJ8LnI,6237
-ngccli/data/model/DeploymentParametersMeta.py,sha256=08UxePnCuzJRslpXymr2I27wJ9SGXNciNerpr8CCGbU,6125
-ngccli/data/model/DeploymentParametersMetaCreateRequest.py,sha256=IrlQ6ntLfaQOtu-rNIpzTPlqPIXAWjAenoGmCx3rC_k,5840
-ngccli/data/model/DeploymentParametersMetaListResponse.py,sha256=2q8INB5txCtEr-AT_twRA-J_Roey11K4Y3HXAucY8FQ,5216
-ngccli/data/model/DeploymentParametersMetaUpdateRequest.py,sha256=8QL6GPmCjHXpTfbz3lwvG6oPhkKe3jeL39wzuEHXjVM,5458
-ngccli/data/model/DeploymentParametersUpdateRequest.py,sha256=eZoNTfyaHq0V1UAhtOvdvDHb3TX3zMcLqHtf56f3w6s,8308
-ngccli/data/model/DeploymentStorageParameters.py,sha256=unx4UmyhBLE-XBFZFwTJNrb9YRutlyb0GEsltjLWot0,1789
-ngccli/data/model/DeploymentStorageParametersMeta.py,sha256=PVtEcwZj1VYM_qlLkdjpieTx0cTnagNECnezUywEJU4,2291
-ngccli/data/model/DeploymentUrlCreateRequest.py,sha256=FahAMMwgiKysyCp08dS-JXG-xxmu3UqJUzHm7SHVZg4,8291
-ngccli/data/model/DeploymentUrlResponse.py,sha256=-HWtGN1CuaqvtSTCq8EYIFjOlI0vKSyudEdwFk4Joho,4823
-ngccli/data/model/EnumerableResource.py,sha256=lDqvzewGiqj0gawovVS50RtuxGQxAN2Y3FjBWMJp5aI,2941
-ngccli/data/model/EnumerableResourceItem.py,sha256=tv_WkawuyeZxK2EZR6HuLxMrhHnVOAD37A7vmzXfP6I,3164
-ngccli/data/model/File.py,sha256=TaS9-ns4mXWMl50xdMFtoSqzrPVWyIcsklwCf-vXw1s,6436
-ngccli/data/model/FrameworkType.py,sha256=yueiSgyJx005LIRMzS_XwxvH0b8wvtDu27A155T09dM,197
-ngccli/data/model/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
-ngccli/data/model/HealthResponse.py,sha256=TCGXNJKL6E4X5xWh_SeRtTK1ASZg9mS0Syb6z8Hrtjs,1989
-ngccli/data/model/HelmChartDependency.py,sha256=J6Aa1oBojPxLsAF92kc_oRBLpp7OADikuo8Ll4d9PX0,3845
-ngccli/data/model/HelmChartMaintainer.py,sha256=mq3Thxbg6Pj_kXbQctFNKjUYtGXsZ1aJuzDR2_zqJkM,3171
-ngccli/data/model/HelmChartVersion.py,sha256=6lvRVstbyq94Q__AVT-1xvBpP_C6KllY1rPffB_6VuE,12667
-ngccli/data/model/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngccli/data/model/Model.py,sha256=9rTWJjEKY3eEFojhfnpxqIYeYmqaArt4HCcxc9D0oEA,30696
-ngccli/data/model/ModelCreateRequest.py,sha256=GhxCl7EmYToNivBmeRy63Q7lOe_yY8MKLS-KQLgZib8,22262
-ngccli/data/model/ModelCreateResponse.py,sha256=FHVU2xtEpJS1VhVRtitjMletTynWNpVgt8aee1dBB_Y,2882
-ngccli/data/model/ModelFile.py,sha256=V8rim7bTmLdHKwJipVK_sG55oTJOTZTG_Xl_2HJbo7M,5242
-ngccli/data/model/ModelFormatType.py,sha256=D84sZV01TsKkP2DdWA01zyPQ-X8XD2dzIbKHwe_EXyQ,221
-ngccli/data/model/ModelListResponse.py,sha256=zdOnxX6nCZIhicvfUcPrHcfKeNWTuXtxbRUfNnMONtk,4063
-ngccli/data/model/ModelResponse.py,sha256=0444F2gTM4Dk7WoqMUX021_2DdliWDDY0eOLhn3gBUY,2871
-ngccli/data/model/ModelSimplified.py,sha256=Cx1SSUb5WcgszHaKQsU0jj-T_9sQ5kTIzs9KKGNvbeQ,3575
-ngccli/data/model/ModelUpdateRequest.py,sha256=aNLXiqQnzmSg9cIBo6eCEs2BuzZX_V6Tc88MUjsWcHE,20197
-ngccli/data/model/ModelVersion.py,sha256=Yhu5WB-GxRxKR_uO-C--sWL921eZXPYu2cJjHlCRmrE,15426
-ngccli/data/model/ModelVersionCreateRequest.py,sha256=F1opxLo5GKrF9f5Fsp6zbNs6856qXLZ-zStIzIQKiQI,13578
-ngccli/data/model/ModelVersionCreateResponse.py,sha256=LwLbJ79ttcyqZ_QmHZLOlpAdNBUmvSbpdQMhmDp1YxQ,3924
-ngccli/data/model/ModelVersionFileListResponse.py,sha256=LqOB3SYse1Bise2J_hIMRrUsNQ5L4j0j_R12G01y1X4,6072
-ngccli/data/model/ModelVersionListResponse.py,sha256=EUDIkls1tSRszq6yunygvhH9IMSYqp81k_Em1PdvYX8,5084
-ngccli/data/model/ModelVersionResponse.py,sha256=c03wImYMdzWyEkID49XH0receXIVt3Bs0gHm-HId3C8,3923
-ngccli/data/model/ModelVersionUpdateRequest.py,sha256=JMt-8SBhloX_550U8_G8kIZUz4DBwNoU_GK_c_pUAIM,12069
-ngccli/data/model/MultipartUploadAbortRequest.py,sha256=VfdE84KaGbEgfJYrqJEE8Bp8jwkT_PEqGwNBOE7f-q8,5878
-ngccli/data/model/MultipartUploadCompleteRequest.py,sha256=mdVeBuBo7f25MMJb9IEWUdRB3r2FfO8P1ue-QBe-1Go,6906
-ngccli/data/model/MultipartUploadCreateRequest.py,sha256=uX17zPYGuTfoXqAby2E8N49KMtHhWIlr_PI_2s-iAGA,7401
-ngccli/data/model/MultipartUploadCreateResponse.py,sha256=pTprkBuqKHeZ9EGXr-Rio-5PHsIcGjpkCXA-Ex5mSIw,6049
-ngccli/data/model/PaginationInfo.py,sha256=RzvaVvJXG6Zr-xlbGXL0uXZpdzkPRdhrt-IuOkvX4ak,4827
-ngccli/data/model/PrecisionType.py,sha256=cmhvPJ8RtTAIwVhMhEe5_8Ls9pIxm2tmhf6yQlB-6p0,130
-ngccli/data/model/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
-ngccli/data/model/Recipe.py,sha256=o7h0GrtJcxKkvyAewFlWA_rgOHWRafaFd7mygvVoN_Y,27541
-ngccli/data/model/RecipeCreateRequest.py,sha256=OotqpzCmClWP4dGBnRSZIbUGn0-pPxyRiV7kc-y9KFI,19453
-ngccli/data/model/RecipeFile.py,sha256=e0bWmWORZYN70yuYxQaDO7GSeBsDehnzwAn0fucbA9o,5249
-ngccli/data/model/RecipeListResponse.py,sha256=NxBZ_bODpcpHizphOohAwoTAjT82ydl4o6mfWy7SPcc,4085
-ngccli/data/model/RecipeResponse.py,sha256=gtg7LQaOrg9qEMP8Z7xCc7kGF7KsI6GIksNHsJCCsoM,2890
-ngccli/data/model/RecipeUpdateRequest.py,sha256=LrqrjwL6n0kirf0OZbA9CkkOnsOBk9RwKQO2JqouLy8,17702
-ngccli/data/model/RecipeVersion.py,sha256=AI_SAYnwJ1Swz1wP3KthKbQ0C4Y_ByHAQMFh3fM6kiU,17930
-ngccli/data/model/RecipeVersionCreateRequest.py,sha256=ntEsNRdGs8X62MgegwC9FMXYdE9Y6wWnKmk4MypfWec,15539
-ngccli/data/model/RecipeVersionFileListResponse.py,sha256=0Qde-7CVSjIEtRv1G1QwXBO517VZdVsGn2acGmiEH7U,6142
-ngccli/data/model/RecipeVersionListResponse.py,sha256=nx_VRk4pSTF0aea6CvhGrokLuIpPqIc65U5m0JslUl4,5130
-ngccli/data/model/RecipeVersionResponse.py,sha256=5O-9rqCAoxnQB6jmOzKDQskGOUfqnDpUoufJ3QjPK6k,3964
-ngccli/data/model/RecipeVersionUpdateRequest.py,sha256=xqLXLzaDfwHO64YEJtqJzX77SU0cxqNHeQUm5W7N-cg,14027
-ngccli/data/model/RequestStatus.py,sha256=Jq3gYldBXwGxu_UuxYr9X4z2Oi605GGdQkd_Bv3MDws,4213
-ngccli/data/model/Response.py,sha256=HOoZXNJjLgX00gaxkVHZe2Y_dVUkXbByMEITu9plZ4E,1976
-ngccli/data/model/SortOrderEnum.py,sha256=4aV4ylYKrkEMuH2WJ-5dbGQ2LPfn5DZDkPCEY9QkeLg,358
-ngccli/data/model/StatusCode.py,sha256=0W18iCZ2YXBns50nPxIm589M60KMl3iFfSNMbBhajtc,359
-ngccli/data/model/VersionStatusEnum.py,sha256=16XhUlqs3BngXFOAsHaSyWJ1PD8wfhxMg56U3mEAMSk,121
-ngccli/data/model/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/package/Health.py,sha256=h85veB7fFG6Q2iaTErnMPdeKueHo3D-JHB3COl9AQkc,4439
-ngccli/data/package/HealthResponse.py,sha256=KJIStrFGA2RRQwXG__0cC44oH2I_y4WxxhHaEH6sJBU,2001
-ngccli/data/package/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngccli/data/package/Package.py,sha256=Brrmo_Z_NKqtUZgNckEfKyfQpqUnh2U8ZdJTdwXF-EI,5574
-ngccli/data/package/PackageFile.py,sha256=AbVCdtBsH2X6_qAgJb6c-Qtxyb1AkKofXrxUg9LIUfY,3999
-ngccli/data/package/PackageVersion.py,sha256=keYhheIPR8qTChOad18SLv7qJFP6ENvunWSE-vDL7No,6808
-ngccli/data/package/PackageVersionListResponse.py,sha256=I8LTvQKVi4OboBnlldQ5S7mii9OIeFdD7E5Ey7QPKPE,5094
-ngccli/data/package/PackageVersionResponse.py,sha256=CKfbLgqeZICa38yrW32uXRko7tp1t4zcF4pYu3bZvQI,3945
-ngccli/data/package/PaginationInfo.py,sha256=RzvaVvJXG6Zr-xlbGXL0uXZpdzkPRdhrt-IuOkvX4ak,4827
-ngccli/data/package/RequestStatus.py,sha256=Jq3gYldBXwGxu_UuxYr9X4z2Oi605GGdQkd_Bv3MDws,4213
-ngccli/data/package/Response.py,sha256=HOoZXNJjLgX00gaxkVHZe2Y_dVUkXbByMEITu9plZ4E,1976
-ngccli/data/package/StatusCode.py,sha256=0W18iCZ2YXBns50nPxIm589M60KMl3iFfSNMbBhajtc,359
-ngccli/data/package/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/publishing/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
-ngccli/data/publishing/Artifact.py,sha256=GSlN0joVFQM7I49IWu98U9xEgQVY0tn8qRBWlf6vDUk,5242
-ngccli/data/publishing/ArtifactBatch.py,sha256=j6dXKXnoT7egZXncolDvs-EfiLnGK1bf9jj-YNMpJa4,6230
-ngccli/data/publishing/ArtifactToCollectionRequest.py,sha256=Y1hFxxbWln5slegVAUzbqGrYDVQCIv3GbASik6hCeuo,4473
-ngccli/data/publishing/ArtifactType.py,sha256=LEHnJnxA6bhNWfqdK0jBz4XUqQ2wl7z7_XDch9c_L0I,141
-ngccli/data/publishing/BatchPublishingRequest.py,sha256=PUEVBUpcyk2VY52DCpq97-xKSFGXhJMkTkAheC-x3IA,10846
-ngccli/data/publishing/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
-ngccli/data/publishing/PublishingRequest.py,sha256=ZD9MSxSOih5_-ZeuDPX-XPOMWbU_eXm59YWMCO88tns,10067
-ngccli/data/publishing/RequestStatus.py,sha256=Jq3gYldBXwGxu_UuxYr9X4z2Oi605GGdQkd_Bv3MDws,4213
-ngccli/data/publishing/Response.py,sha256=HOoZXNJjLgX00gaxkVHZe2Y_dVUkXbByMEITu9plZ4E,1976
-ngccli/data/publishing/StatusCode.py,sha256=pjlKDECycPA-Ea2lq_YFwuvMJ1HVeqd5iH0E695WGfQ,415
-ngccli/data/publishing/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/pym/AdditionalOpenPortURLs.py,sha256=fav2pRiuuIHKxxMCjotOx4p-P_7EZldBYM5GHqIpKoo,3174
-ngccli/data/pym/ClusterComponent.py,sha256=cIAXMQInpCAREo1dsUvKsnElWmC3CQSes_cwDCtZvG4,3633
-ngccli/data/pym/ClusterComponentModifyParams.py,sha256=TBXyNGfmTBjTxlfpC4S3zZmMzIz9Dj1grYyaidUs0JI,6010
-ngccli/data/pym/ClusterComponentParams.py,sha256=yXSsUG8cmMD5SitHBqKHxj6LYjfzJoK8v1HIoYgCKlk,6742
-ngccli/data/pym/ClusterCreateRequest.py,sha256=ZPX-ueilvY0nrHH4e6me5KMWPq3IeGr_gG0tyqnW4qg,3019
-ngccli/data/pym/ClusterInfo.py,sha256=F2kyq4uvBO8p5XqfJb5BhahJjyGbNaSCUufhjSqs0Y0,7701
-ngccli/data/pym/ClusterInfoResponse.py,sha256=UYf8frpLy5zc-zeBinXGXhhayw4hlOtKCzGZX9flQ9w,3089
-ngccli/data/pym/ClusterInstance.py,sha256=RSzJ7vryDor8tTIi8oORVZsU1QE6cA7UQk31F0iqGWc,9539
-ngccli/data/pym/ClusterInstanceInfo.py,sha256=i762VtO07il1pcLWr7WgPWAzMI-zTewalEnPqkyRDAs,3490
-ngccli/data/pym/ClusterInstanceTypesResponse.py,sha256=75G1gIMlTlkyMFDMDPy94GO9jQG8bxRWlGyiE8oXm88,3365
-ngccli/data/pym/ClusterListResponse.py,sha256=x3_xzXDcDBp2yE6G7Weem1VgP4Ym3Ss7jX4Jad7m2ZM,3149
-ngccli/data/pym/ClusterModifyParams.py,sha256=GZJr1iGwJxi5iMPMRLlmvYjbEz3FGbPQNOxQhiiTI7Y,30037
-ngccli/data/pym/ClusterModifyRequest.py,sha256=DCwfbJCpb1oLInu_PZprRPifXICFLPYiY1wPj7ApEKI,3333
-ngccli/data/pym/ClusterParams.py,sha256=q2-7qybOMVJfZ6eHvJmEfLcJej3-wetouafuNUqnviQ,30984
-ngccli/data/pym/ClusterPortMapping.py,sha256=G8JkKDiYuGUlft_vLUYGh0qVTVP2TMBX-AhL_e7yY98,6221
-ngccli/data/pym/ClusterRequestStatus.py,sha256=FZcN2VT_ofT3u_hpSraaAR3-9MoLcfFmwYYx4dlj8nA,12789
-ngccli/data/pym/ClusterStatusEnum.py,sha256=6w_HVEae6jn5mFHjHya1GM02Lk5nuH7FGg8Mr__tiZg,191
-ngccli/data/pym/ClusterSuccessResponse.py,sha256=qlD-Nd7usYkvrcpWz9HVmHM9Sy2_odsi-w0lGTh_ex4,3210
-ngccli/data/pym/ClusterTelemetry.py,sha256=OEZrSEZFxxSS7nmLVAFccwx20jVE0YtC5-SFvGOj-kQ,3048
-ngccli/data/pym/ClusterTypeEnum.py,sha256=ehd4L61cnZDGQ7-bRE6hSrPJUKqBV9hJaCfAPSumcnU,102
-ngccli/data/pym/ClusterURLs.py,sha256=osI0n4--piPn2RMOP9q2x-eRxZ9zQYnHhGUXTJZv6hQ,5293
-ngccli/data/pym/DataInput.py,sha256=Z-PGTmWi1C2QXPtBk6q3jZ7Nipk8g6ZSY0QTmeqAYzc,3188
-ngccli/data/pym/Dataset.py,sha256=-XxRw_O-I-d7mxllOLIvPAkyaOa_gIIrUt7Ll1zHwJU,2982
-ngccli/data/pym/Env.py,sha256=8c5CRDwwkncFV9D6-2EJRNGWZaLzEOsGTUCM6hNNITw,2943
-ngccli/data/pym/HealthInfoItem.py,sha256=iXLqb3VLaemvDiaNnqpUawHeScXTeEHFp75DgjpsD78,4484
-ngccli/data/pym/HealthResponse.py,sha256=O_K748m65eLOp6YCBfol2dbmzkWW38_H2Bp8S3VSZAY,4004
-ngccli/data/pym/ProjectCreateRequest.py,sha256=HY0z6lwjk7-tordhm6CqcLmP6JimmEU1-8vJSWZv4ak,5276
-ngccli/data/pym/ProjectDetails.py,sha256=YxddnQn3pny2j6SbBBPdjf1sGYxevjjh2HiuM8OhvH8,7374
-ngccli/data/pym/ProjectInfoResponse.py,sha256=yPLkCwMGheyc-Fm0IX9vkk5aVNIQjeeFwjJSJJYW6cI,4120
-ngccli/data/pym/ProjectListResponse.py,sha256=5MIvkzvEWdQxcPHobxSlJLgGNuQjj9h4RbUstbXi9Zg,3119
-ngccli/data/pym/ProjectModifyParams.py,sha256=7T4MF_M-dXr8OsIDYSns45RCTlzdrPKgntfVfTwugac,2976
-ngccli/data/pym/ProjectModifyRequest.py,sha256=PyATR1goWT2Wa34YgQTtgl9RwQcEYYSrzyvPHmM2VpU,3080
-ngccli/data/pym/ProjectParams.py,sha256=6k-YgqLkAVwdSg_hcAKyqhi4Z41h1lDo--tnyF7Bf18,3303
-ngccli/data/pym/ProjectRequestStatus.py,sha256=6yCMJ99YzH1cqiNEEicuoJiwq_uL12hHG04WqjKID_0,4714
-ngccli/data/pym/ProjectSuccessResponse.py,sha256=SJgOiHFWCDe3GJX1Eud4u4-HGB0_1RDvmW_Tbu68lDQ,3210
-ngccli/data/pym/ProjectTemplateCreateRequest.py,sha256=Txxy4MsvYjXqv_MqVLRijzRFZjE8FldHii5yNR_81po,3129
-ngccli/data/pym/ProjectTemplateInfoResponse.py,sha256=m7tghW5xFq_AW58jHZ7l25qWbj_T9oj5clfmKIy5x5A,5220
-ngccli/data/pym/ProjectTemplateListParams.py,sha256=C_xBrIBtWp1o0xrgMqaRhK0rFyOYye3nf2hCH_TIF-4,8708
-ngccli/data/pym/ProjectTemplateListResponse.py,sha256=ZLObvbOENieaY8AqXAzrUuTSb98XBD4FuTWjAZV6ppo,3224
-ngccli/data/pym/ProjectTemplateModificationRequest.py,sha256=ECH4dY2JWqVSgS6R3d0R1_jk81-VQN4emAe9aC3i9wk,3223
-ngccli/data/pym/ProjectTemplateModifyParams.py,sha256=l2iq3VoHqK1Eppb5GuMqskGylEMppirhcc1fAGTB9_M,6830
-ngccli/data/pym/ProjectTemplateParams.py,sha256=LV5VkAx97lkn0sZGqqxgbAqGsxtvXQQNXoL9cRmylwY,7106
-ngccli/data/pym/ProjectTemplateParamsDeprecated.py,sha256=12iamYAikpEZDSVYmUc94PkasSjJIsbZnVwIAUEvJA8,17506
-ngccli/data/pym/ProjectTemplateRequestStatus.py,sha256=4EoKaXGhyBcRVfPEPRs9TGXyxUL13vNJJIQIl7gVb6M,2752
-ngccli/data/pym/ProjectTemplateSuccessResponse.py,sha256=7g-XddLcdD-IuMbWvFsE-lkMLe3jLrqxquS-T_6hDfM,3333
-ngccli/data/pym/SecretKeySpec.py,sha256=sx4TtaePGrif_2rHMMox4T4Ml_inytfE__T7R6W2VaM,3314
-ngccli/data/pym/SecretSpec.py,sha256=XZte7OZwv9uEkMF6e6P1OjAf7viF8MuhApdcM7MUWTg,4057
-ngccli/data/pym/Workspace.py,sha256=lyDA-dC30KJ39lWfzzlFp55rIqYxGCgjzQd377thx_E,4074
-ngccli/data/pym/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/registry/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
-ngccli/data/registry/Actor.py,sha256=AUfYxuH2rtp4woY6ivSE3lvvQGLf1nHBnqsk67XhO74,1719
-ngccli/data/registry/Allowlist.py,sha256=eytnw0QyXSwd8ClBv0YoctZqx9gh6zIQKZmVhw36x2g,4859
-ngccli/data/registry/AllowlistItem.py,sha256=35I5N9gM74KbWC103DHxY6T5b-MXhFzVeNIrPPDU1f8,3193
-ngccli/data/registry/Analysis.py,sha256=HQRbATkCVOhSJvR78w11X7B31o1U-3JP1oueIy0npuU,4036
-ngccli/data/registry/AnalysisStatus.py,sha256=5qv3dPNKDDCFMnA2hjft8pN7JvRLQEAYnMFgMn1H-WE,139
-ngccli/data/registry/AnchoreParameter.py,sha256=pJxGGkkOXc1CW-vr2eqBidnvHfUzo5vKvWEixTay29s,2347
-ngccli/data/registry/AnchorePolicyBundle.py,sha256=KFZkx3zTz4wABjUHYKiYFTmYSER-rI1azYjrJb_qNMo,9910
-ngccli/data/registry/AnchorePolicyBundleRecord.py,sha256=xnnYC9EB34g0dqhBJ9JwSi0xvZ8DdEGu44ZiAN1dfb4,6971
-ngccli/data/registry/BaseImageDetails.py,sha256=NaMyN4vKROcrKBI0wGJR4HUOZFmTYJ98NJv8OBm1wjM,5543
-ngccli/data/registry/BaseImageList.py,sha256=srvhsC168L2MFZcm1DY6PEiTN79wxTjgjSAaENbRlao,1732
-ngccli/data/registry/BaseImagesDetailResponse.py,sha256=tyW2bp0RTVhXcZCdbt7C1VRN9DnRZtTaTpAcknPCLhY,2142
-ngccli/data/registry/BlobSum.py,sha256=z3EuP_aWSjNBT7vaD81NzXwsKtti4g6FBcCykjDncEg,1666
-ngccli/data/registry/CatalogArtifactMetadata.py,sha256=lDgOalcpxgScHG9Ajm7OIWfUZcsvYHujBJ_MVh6Lk80,5084
-ngccli/data/registry/Envelope.py,sha256=jaDenZpAkomi7u3HYd_fwMndnfp3givDa_ejgPsX3L0,2020
-ngccli/data/registry/EventRequest.py,sha256=Qs9c--lLaInosdyweN_95chG674V5btPoJD0Sw3udf8,4956
-ngccli/data/registry/EventSource.py,sha256=rJ0tGwOVv5PUMJIXLRqZfdzFe9Axy88eLphQG0q2wTU,2664
-ngccli/data/registry/EventTarget.py,sha256=C3zsjlb5fGrV0OtjgxFlqa7n_81CsuI8WRkERTAUMw0,6419
-ngccli/data/registry/GetManifestByTagResponse.py,sha256=LRUlFz06sPupDwL9vvgxKfz62sA3N9q-oj1R6F1MZsI,8208
-ngccli/data/registry/GetRepositoryTagVexResponse.py,sha256=AeNQnLBBaCIJ9paFNy_JT__oGERoymbU1TKmz7grWYY,3749
-ngccli/data/registry/GetTagsResponse.py,sha256=G14ssIh6bvFtvI-JHyGtaamZOB-eMDxT_0EyX6ZSfvA,3392
-ngccli/data/registry/Header.py,sha256=tMjrWGoaQZbBAUz1gmrdMd3qS84-bSuvz9SLKtQj6Os,2451
-ngccli/data/registry/HistoryLayer.py,sha256=UGtTRLH89WXqLFe-dNYoBbj98I2TpBalo7eJGAC1KOw,1797
-ngccli/data/registry/ImageArchitectureVariant.py,sha256=pzyVCHKlsiWObkRv9uC7eCwZ9oczOPGcr7F2tdJVcbk,8463
-ngccli/data/registry/ImageDeleteRequest.py,sha256=S5Wo3tRRghXE4niwXFa5YhWfbnJXRzknVjSPTi0GCl8,2972
-ngccli/data/registry/ImageOwnerDetails.py,sha256=CXtPp5HVWIRunURaONIdFHTfHI8l62FXEbnIRpRbcLc,8722
-ngccli/data/registry/ImageRef.py,sha256=i4gPb7UIGw2vH1Q5tzC5s7NekMDkRRfM0Yielfp193U,2342
-ngccli/data/registry/ImageScanDetails.py,sha256=-CWhW1kDliMxrz1Chz5iMlW5deXY3fgaN00HyPB3xfA,10863
-ngccli/data/registry/ImageSelectionRule.py,sha256=6f3Sd80s1iAcA061qnVLbYYkUwfPaT0tOaywlIWojHc,4699
-ngccli/data/registry/ImageSignature.py,sha256=mwrzuDZBaE3AFOCaZg9aMA4KLKIPA3v4Og7yN9A2XYQ,2557
-ngccli/data/registry/Jwk.py,sha256=0bcdKYmZAurVoLV-AVJ2jKpb_7jmxQJWCCZgPIRwaQ0,4468
-ngccli/data/registry/ManifestByTagV2Response.py,sha256=GgMXRo2ha24IWrsuqdOKHGR2kSSEDh8ox44X0O52MYg,7637
-ngccli/data/registry/ManifestListByTagV2Response.py,sha256=9qav6M9ywYqopITrOxNBW_HVB9LzOQ6bk-mf-hjA1rs,4764
-ngccli/data/registry/ManifestV2Config.py,sha256=rD16GvopMwOGbf4QaAq1-2IH6suZPg3mVvqjhC4_H5c,3209
-ngccli/data/registry/ManifestV2Layer.py,sha256=U685c0wqqAtcUju2Vfy5NA2xqSlUzb-NkvaWRiPedUA,3186
-ngccli/data/registry/MappingRule.py,sha256=Vx-HeLrhCNZ9SHVEpUB2ESxU__X_UCHwMrUqcycEdWk,6468
-ngccli/data/registry/MetaImageDetails.py,sha256=2PDERWFw01WmAq5ecbVwa_eVGvBErEGI21C06yiF_54,12531
-ngccli/data/registry/MetaImageDetailsList.py,sha256=5KQfbQDSjdfrV3E9CBVCjofeXj_4aMwYq0SstvZnt6o,5927
-ngccli/data/registry/OciIndexManifest.py,sha256=NIbH1dJa10l-Kv3AfgwjJjxpIRfJYQj0KduM8D9aLSk,3998
-ngccli/data/registry/OciIndexResponse.py,sha256=xiw9juPIdrNmJgTeu6wnsk7qNhmZKiMJHRoIuQNr3QI,4703
-ngccli/data/registry/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
-ngccli/data/registry/Platform.py,sha256=mSKlUIpALQuuTAxcs5j23MFJPXEJV937GS9ULNn4k-E,4309
-ngccli/data/registry/PlatformManifest.py,sha256=8u0Et6JY9jBY-TSVSljP_OFzQfMskE8XWwtsfBkXglg,4840
-ngccli/data/registry/PolicyRule.py,sha256=A3_bl3qGzs485J7uPhCcGJBb1LogKR_qJYP2NOCKYuk,4845
-ngccli/data/registry/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
-ngccli/data/registry/RegistryEvent.py,sha256=zoFVMCZGOZhy4X7L30W5HXKjvmIMh7wlRo7YyswfLiY,6858
-ngccli/data/registry/Repository.py,sha256=WIqpXK7RZ-Hb8DDZDr-Cmhp7hpB70JErX3CjX0dwS4w,27728
-ngccli/data/registry/RepositoryCreateRequest.py,sha256=7NjSz_wiHKT85GzpFlFlSBPj58S2u1TpAQUT-xkooRE,11157
-ngccli/data/registry/RepositoryImageDetails.py,sha256=YABNcjwAVYNyKw3gIFklQvfeWgcGaEp-gfwpNDxAtLk,11907
-ngccli/data/registry/RepositoryImageDetailsList.py,sha256=9e939SLPmAyRMGbVRnjbwKgMIpsfGiIxxFLbMP0dji0,4159
-ngccli/data/registry/RepositoryImageScanComplete.py,sha256=H05zkXVQiiroxpMgnMVYHR3NcpBCVF4fZUQlsX23YhE,5902
-ngccli/data/registry/RepositoryImagesDeletedEvent.py,sha256=UlqUlzuJjUCjHT-dam892R89gvDjr7VxR93cA7iITf4,4440
-ngccli/data/registry/RepositoryInfoUpdateRequest.py,sha256=hfXNcWJSKf1IN5880cpr1GZPSTFs0B4X8bylj34uJjQ,16048
-ngccli/data/registry/RepositoryLabelsPatchRequest.py,sha256=DHp3GgH7m75_Va371Kjq7ioZuOX8RRDGK785o0EC99c,1677
-ngccli/data/registry/RepositoryList.py,sha256=CWgRFl_JXl2Lk3yfQAMqPH0LDIysuSI4h7O38U9HiVo,4182
-ngccli/data/registry/RepositoryTagVexByDigest.py,sha256=0jVKReHqrSaL05R2-MQfWoYXMolqdmOFWxbGakU8T7A,2672
-ngccli/data/registry/RepositoryTagVexDetail.py,sha256=OMS57-bRQeHNn3C8c3mK6jDA7CnLMpnG1IlJjgmxSYM,2528
-ngccli/data/registry/RepositoryTagsCountResponse.py,sha256=eZj52OgKEdOiw_c7EEj44H3GTtFGcmVvlMh8ZzIspIg,2758
-ngccli/data/registry/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
-ngccli/data/registry/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngccli/data/registry/RuleSet.py,sha256=lsIVPadWaC_otsLmfViQqnF6Zkxsncgmf34IvyDm9OM,4870
-ngccli/data/registry/ScanIssue.py,sha256=VRUYl7L9c8bmwKGvVW1GofhQKjwNa8rdHMG2F7ccJhw,7489
-ngccli/data/registry/ScanIssueCount.py,sha256=CwabKHFESi_14BSMbWCtNhVosrZaxTsJMHEwZy2a46Y,2486
-ngccli/data/registry/ScanIssueSeverity.py,sha256=TeWv3WPwbmTZZQlcUOgZjwm20Y6Ha8aw8eSeGD6WHzw,137
-ngccli/data/registry/ScanStatus.py,sha256=QE_J1OKnC0s1yfqToiD8NxOctru0TrIVc0ATqhaM7ac,138
-ngccli/data/registry/ScanType.py,sha256=yfXyugvM1yJk3Mc3nWVhEP8PrllFt0qa6JySUExHHu0,102
-ngccli/data/registry/SecurityRatingDescription.py,sha256=iaHovjUiCFA_rUr2r87B5BYBk7t_0XvlaupcoyOemw4,7621
-ngccli/data/registry/SecurityRatingType.py,sha256=J5dQ2NHAtSKum35BJfR2HgXr0VmndhRW3rQxgB4tanA,119
-ngccli/data/registry/SecurityRatingsResponse.py,sha256=bEjpOcFkNZ0KpBtSPamHmrkkqImP1Lw3uZvveE6cyrQ,2081
-ngccli/data/registry/StatusCode.py,sha256=Y64E0Wqv8Gd1H9MdK7pNmKbzPWsWk-yFGUarCtzIvPw,317
-ngccli/data/registry/TagUpdateRequest.py,sha256=E8CqdCAXbooqf8MbVVKkUzjj508TWITroaHNFQ6N1SA,1766
-ngccli/data/registry/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/search/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
-ngccli/data/search/CountParams.py,sha256=Qypr2QmKIRaYtW1aFTcOx0Zg0EEFYlieYfCbHi1T6_U,3344
-ngccli/data/search/CountParamsField.py,sha256=jD-p10t0z_lLlqVGz0GMWN66Mhh8dTatrXRQOnQjulU,3146
-ngccli/data/search/CountResponse.py,sha256=Jgy3u0yXZOPwrAAEvljOESTcbvN9cxCpvZF__6i3_0E,3360
-ngccli/data/search/CountResponseCount.py,sha256=RLgYD54546Me7uNGc0A2eFL3ndvm9f3rDcKw6OskSng,4031
-ngccli/data/search/CountResponseParams.py,sha256=1Q877WfxqY1hf3YR4_LEFPEeSkNWiEht_TQxJOoEyKY,2046
-ngccli/data/search/Health.py,sha256=qTDVz_yi0kQWdL-9M09vtjFPZm_GJswySbhp2UBELXo,4468
-ngccli/data/search/HealthResponse.py,sha256=TCGXNJKL6E4X5xWh_SeRtTK1ASZg9mS0Syb6z8Hrtjs,1989
-ngccli/data/search/LabelGroup.py,sha256=J2l29QDClPqv6EzT3X4b4QXV3Oao3By5KkOIM4pDtis,3689
-ngccli/data/search/LabelGroupValue.py,sha256=E2YrkcTPJ_me3ofkz192lN9RyIGa9EMexi9zDAH9Gr4,3647
-ngccli/data/search/LabelResponseGlobal.py,sha256=FyOpWpyxjPwKHKhBZ4C2jctQXuu1Zz2jROXq2qY7nF0,2001
-ngccli/data/search/LabelResponseOrgTeam.py,sha256=pFkd4gzOLUgXRm51dAIKvUhp4gEyMzk1vB8VBflh6Uw,2842
-ngccli/data/search/LabelSet.py,sha256=1XUQYsX_FrlqTbCMJwpembPfYGkseZZT5zVvXctxNwE,9026
-ngccli/data/search/LabelSetCreateRequest.py,sha256=h2HemBGjxSkxWTWGNM4a07-kcWV1kSKut8ZIOz3EbOg,5850
-ngccli/data/search/LabelSetResponse.py,sha256=ioiRvRIH78AfQ_RvuD-_bUQ1V1fWKs2qx8fE33h8tYs,8710
-ngccli/data/search/LabelSetUpdateRequest.py,sha256=lymb0FAwFyv1k8bQQPkfM2jK634QeITwy5N9a7rqUbQ,4151
-ngccli/data/search/LabelValue.py,sha256=sULQI7_MryjaoodA_IRfmon7UzzRf09x6mC2LZFr-e0,3461
-ngccli/data/search/ListLabelSetsResponse.py,sha256=1BDDa5E5JWw4UUkGWClOj8rVHTNgTH7tM-cI0D-SmtI,2018
-ngccli/data/search/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngccli/data/search/Resource.py,sha256=B4DJ3HJwT4wmp-_VUkhzsnKrODGGSCJFqufAnnlDDU4,23861
-ngccli/data/search/ResourceAttribute.py,sha256=fWBw9vzlE020PiNGQaKdu7e-RrhDhee8xpYD-EX8Gek,3140
-ngccli/data/search/ResourceEventEnum.py,sha256=48YARuDp7CnAikDnkkHsvhDAPbHlRH-VAlBRgSQI0Mg,113
-ngccli/data/search/ResourceLabel.py,sha256=INELLDOVXLGl0TUqPihcVpaTu6siI646bZc1YOSnF38,2891
-ngccli/data/search/ResourcePopularityTypeEnum.py,sha256=3ecszGo1Sbt0MTk1Mc1hf_0zXKiooqYNy-Gk-vGuu2A,141
-ngccli/data/search/ResourcePopularityUpdate.py,sha256=arkLJlhJ8Nuf4MOfa2GpJ4Sxx0TQ6XrWHug07GVW0t0,5387
-ngccli/data/search/ResourceTypeEnum.py,sha256=93W9zB1-we_VKpBZM-2OAs7kZlrH6Q9NgxIG11FvxQA,233
-ngccli/data/search/SearchFilterCategory.py,sha256=6KdosoNo6J-4vYXOuELAyk-a8MrcUIynLD4hHLr1w98,4374
-ngccli/data/search/SearchFilterValue.py,sha256=yDRLCIW7ZGnkW_MltSTxk8QqJFQ3XRP861FUWAzXEW4,3896
-ngccli/data/search/SearchParamFilter.py,sha256=3-95Y87emOU7JAvs0cez0b_1et-QgGRVW8pPTkFq3fo,3095
-ngccli/data/search/SearchParamOrderBy.py,sha256=bi62jYTXM6wFmVcANwxA17JPthK4vaP9PyVQVyKt0lA,3197
-ngccli/data/search/SearchParamOrderByEnum.py,sha256=U1h3qpvbGL_rNlNlJPSEDCNKLbn_73B4LFREcLX0ALk,109
-ngccli/data/search/SearchParams.py,sha256=EUstSOhXElA6X2cv4-_GwFRH9DUdD0gQpv7io3S-pqo,10137
-ngccli/data/search/SearchPopularityUpdateQueueMsg.py,sha256=VViWXL4lxMhgSwl1xoOI-wN7n68LxVoap90uc4eyE20,3716
-ngccli/data/search/SearchQueueMsg.py,sha256=3TI6VYytGGkcyumWHz3vciMlRKjFAEFp5E0iimIrM2k,3224
-ngccli/data/search/SearchResponse.py,sha256=urflGcdYOrfiVkkhlTp0H4MbxsEAlSbR1hWXwLRx4NA,5330
-ngccli/data/search/SearchResponseResult.py,sha256=44gqjZyMExFnjOk-1uXm2gZRdv6KaytvRp3lG6xrOUs,4724
-ngccli/data/search/SearchResponseResultResource.py,sha256=Q0Rcf-tJqt_NzRXmfN_Ya_4Gb1u_BQW7yW7-STrdg8M,22530
-ngccli/data/search/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/sms/HealthResponse.py,sha256=aAhB_soUNfGrRZnd2zyxPbtplYng-cOwBMlqLuOuHhQ,2905
-ngccli/data/sms/KV.py,sha256=CXZedIazcyxFRpOUd32oFlb798ov2Gjgjpmux8bGxzc,3116
-ngccli/data/sms/Secret.py,sha256=YcJsQRuAdtm-WryATB6lGL6cPpRSmXZR-C8CgBBQKKk,8710
-ngccli/data/sms/SecretCreateRequest.py,sha256=xNaVlRUbM70F_1DQiBykFFwApQ3H6t3DCarjJMN5-2M,4968
-ngccli/data/sms/SecretDecryptRequest.py,sha256=jT6VutxVHgNhS4icnM5reJMIckn1BFTZMXpmcW-mR7Y,4395
-ngccli/data/sms/SecretDecryptResponse.py,sha256=vDGRpmJRBenMbnvRJyz7yuQOUqUdASxzlflh97tN8HA,3253
-ngccli/data/sms/SecretGetResponse.py,sha256=eVInMrjlw8VsxZPCf1Y6hQNGyl_bF5Zic-rj1AMhWgk,3037
-ngccli/data/sms/SecretModifyRequest.py,sha256=d52BL-3fuqjeIOu5XFwUcYbjvP4uP3Nf_y63-vA6JnQ,4583
-ngccli/data/sms/SecretNameKV.py,sha256=HfMuYBCDgt5OR807ePAU1g5AMM-0N_wCOtMSnadVQM0,3123
-ngccli/data/sms/SecretRequestStatus.py,sha256=NbmwENENwi5Be4_XE9GQUEqKnJTAuYCU9J5EcCHqBng,3680
-ngccli/data/sms/SecretSuccessResponse.py,sha256=D6h3TcfvkiHK2oEWkS0Sd19CrhBhzD3ss3Ul6QaE0Ao,3197
-ngccli/data/sms/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/subscription_management_service/Action.py,sha256=IxZnpGkLkk3dswJG_FBZwGUPi7vvpja1hPP2puci5n4,3043
-ngccli/data/subscription_management_service/AzureMarketplaceSubscription.py,sha256=5irvSrbMx8wj5Zovbm3lju4xKd__r9T_EQJRwJJ7fuE,16440
-ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py,sha256=j-uKI0IBTaAwuFO81ApNQ5SoV-7CEEksp9e0q90IW5I,11664
-ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py,sha256=qzwPwc5ObyDAr8sMN80yz6phT4KLVZSerkM8nkSDFFU,4213
-ngccli/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py,sha256=nnMKKowqKFLNxmxzSMaGhsM9e0LGfISFNPyWQ_CD3Z0,4002
-ngccli/data/subscription_management_service/BusinessContact.py,sha256=Oh2M7skCI1UbLEJzEozvA4MPnUn3j0qGdyNiiB3etyE,13228
-ngccli/data/subscription_management_service/Charge.py,sha256=dEtheiEJXe78pwJdbBNlE9vSpLbkIji_436TAGNEadY,7569
-ngccli/data/subscription_management_service/CreateOrderRequest.py,sha256=RlTW8A3bJUPe46umLmunByQF9CXiglZHOJWvqN_RSto,3844
-ngccli/data/subscription_management_service/CreateOrderResponse.py,sha256=MipiTJ45fuGkIwh7vmvYyhv5X_qr7NywrydB7A0EaN8,2814
-ngccli/data/subscription_management_service/CreateProductOfferRequest.py,sha256=zYP2mNcCe4NA2wMsOdFBkMkc3mQcSKRKZfkn1GoAOk0,2189
-ngccli/data/subscription_management_service/CreateProductOfferResponse.py,sha256=CH8PGQhgqzhjqgXm4kotMP7-71GFIjr6JUPOVF5Gt70,3027
-ngccli/data/subscription_management_service/CreateProductRequest.py,sha256=Dm1rZFS7ZxXjZipDtrgzOdKrhANDmPrU2vWrdT8hTYA,1837
-ngccli/data/subscription_management_service/CreateSubscriptionsRequest.py,sha256=KUx3-25p267zaawTkcdeRYUS-B6s9m0ta4TvVDNmRCs,2199
-ngccli/data/subscription_management_service/CreateSubscriptionsResponse.py,sha256=yhDeYkgciZpre2wBspvlloT6dN1CSi2Srkmn-dIFz00,3121
-ngccli/data/subscription_management_service/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
-ngccli/data/subscription_management_service/GetSubscriptionRequestResponse.py,sha256=jNIlyrhmPCp5dTvN2EGihoseIF8eRF8D04f3em16ohY,3167
-ngccli/data/subscription_management_service/GtsOrderTypeEnum.py,sha256=e0YN-_mg078t4omgJUl_cGNh5SS5iX9AT6-Ppl9cr5A,165
-ngccli/data/subscription_management_service/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
-ngccli/data/subscription_management_service/HealthResponse.py,sha256=5mdmVDD67RhFOoeFHF1YIYKkSsxcyrf4fFFI0m-YwNk,3013
-ngccli/data/subscription_management_service/LineItem.py,sha256=ZAlkqIoBVg5pFmaZy-F2bGB7q9xoRsxJ3tGOkZ3DMcc,8838
-ngccli/data/subscription_management_service/LineItemTypeEnum.py,sha256=LRMnOZOGLRgk5ZzAIcfFgxVHw9aUQ362ry6KgwiZO0I,116
-ngccli/data/subscription_management_service/ListProductOffersResponse.py,sha256=GMVi_8Ur0As0dfdqhTx692_xCXBpj8xb9uAfpABmiCY,3024
-ngccli/data/subscription_management_service/ListSubscriptionRequestsResponse.py,sha256=C-yrY0m7ZjC34NQ48FdO6xf2Jla0P84NkOUIUVd9itY,4376
-ngccli/data/subscription_management_service/ListSubscriptionsResponse.py,sha256=GBbgbRRUnuqJmwC5-sDDR2rHDtIrbtgXS_XtlUqNnsI,3146
-ngccli/data/subscription_management_service/ListUserSubscriptionsResponse.py,sha256=-sNPx9TOKLrgCXLzYMl8N7kiC6znUFMZ0T3FYO_FuR8,3180
-ngccli/data/subscription_management_service/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
-ngccli/data/subscription_management_service/Order.py,sha256=hbzmwh1TDTP0KtT9vyoMdsDyiYsdRX5wMbI0uPTJtS4,6764
-ngccli/data/subscription_management_service/OrderActionTypeEnum.py,sha256=ooZT2ioqOcvOc_DaTh6ahsSwHBrBAq4s-8AY6uH5m6o,319
-ngccli/data/subscription_management_service/OrderSummary.py,sha256=EHA7_rm6voP0aO9DxkexHDak9KKkn79hcZpwKrI6bVs,5498
-ngccli/data/subscription_management_service/OrgEnablementCreateRequest.py,sha256=CVTGAZbu_92z0AWe8ajQVbr6PhKhWMDyG8vRL3xMP1M,3450
-ngccli/data/subscription_management_service/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
-ngccli/data/subscription_management_service/PreviewOrder.py,sha256=Cg8xACZ_aJ3zv-dNekamYxPgNsvnjQbk9_eNq_Vpt2c,5380
-ngccli/data/subscription_management_service/PreviewOrderRequest.py,sha256=MU4rje1hjeveaWNGHFkCGPZnu8_v_VSiMHcRBp41ixo,3848
-ngccli/data/subscription_management_service/PreviewOrderResponse.py,sha256=c32ZjfBwU9LenKKV1IsKtHlZ7WBFPMvrM6G6LFnGvXM,2991
-ngccli/data/subscription_management_service/PriceFormatEnum.py,sha256=BPaBzIFd6Z_TGnj6TiA73-EvrxugU3fYHBIqCUA4rwQ,104
-ngccli/data/subscription_management_service/Pricing.py,sha256=sg14OZW-YkcoiTDS2B-gD2RaGSJiVCo4HbkdVUvZtUI,7508
-ngccli/data/subscription_management_service/Product.py,sha256=JInyl6F_9ZXkMLjEE-oPFyTowjQhaj2lZHkmXwrWFkQ,19993
-ngccli/data/subscription_management_service/ProductEnablement.py,sha256=7JFrF_kCA-WNsncPQDGRQERZhWfg4W6fzG8Px_wT1LA,5273
-ngccli/data/subscription_management_service/ProductOffer.py,sha256=wInIpy3e2Ga3x5Dw12BUkKJEHr0QC2R516bE0jPAZL0,4859
-ngccli/data/subscription_management_service/ProductPlan.py,sha256=a8s777IoSDkcCUNMRhWyaedKHR_N6Rtflhm_es95_cs,15339
-ngccli/data/subscription_management_service/ProductPlansResponse.py,sha256=71QKR_mU-09voE5sS4aLrU22YPm8lWJF-Xk6fcOt8UU,3120
-ngccli/data/subscription_management_service/ProductResponse.py,sha256=wwuNoaYyYyeyILFQrg5q7jQWeBdIY7dZlmgNd7raRPA,2851
-ngccli/data/subscription_management_service/ProductsResponse.py,sha256=7Arq4zNEj4GgPLv85wLm2LKY8jm4XxYdB5_x4ZbslKs,3026
-ngccli/data/subscription_management_service/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
-ngccli/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py,sha256=WfZP6dHMUO3qOHkIyK3f9w9X1lTyg1eMIc7dBTB4PCY,1911
-ngccli/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py,sha256=VLUN-yX7CLIJ8XLYXi7eVhG-HOzscR9SjGDeTy_9Gcg,2964
-ngccli/data/subscription_management_service/RedeemSubscriptionRequest.py,sha256=gW2cDD5UpXZ9D7fPGY0sr22UyfNYuI6s0opCxzBRFzQ,2957
-ngccli/data/subscription_management_service/RedeemSubscriptionResponse.py,sha256=vLIN_KrWKgHHu1lPS0ALdhKpxVOlJgrSXemcyBcwn68,2820
-ngccli/data/subscription_management_service/RelatedArtifact.py,sha256=8u5lJq_aZLlp6jZNoI0-6_Qt3Pg7bbFh3U_WifDy1dg,6650
-ngccli/data/subscription_management_service/RelatedArtifactsResponse.py,sha256=hcFQCpWZrS1WyuX8LIFB3tcawAsC_8PYJpRM2WeWAEM,3212
-ngccli/data/subscription_management_service/RelatedItem.py,sha256=M6KpS18DHY7Hra3eq3-D-RCt5M4FgCM5niaaYtfJT9E,2371
-ngccli/data/subscription_management_service/RenewSubscriptionResponse.py,sha256=n-Q7bFze0YETfMnqkARY5HOwibnUZKCf3A4GjCH8NCw,3001
-ngccli/data/subscription_management_service/RequestCreateSubscriptionRequest.py,sha256=ZekrVpkHo7nVe2wPI_o7V_ge86KckNJkOyZyKcVGu4k,2703
-ngccli/data/subscription_management_service/RequestCreateSubscriptionResponse.py,sha256=G68q1mtIDgd-zxsdrc6QsjQZDqcJsHCJUwauUxDYZUI,3175
-ngccli/data/subscription_management_service/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
-ngccli/data/subscription_management_service/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngccli/data/subscription_management_service/ReviewSubscriptionRequestRequest.py,sha256=YhkOziMudUMGOWSr1ukB_fVn36Ml_uNPOwpGsVuC7nw,5119
-ngccli/data/subscription_management_service/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
-ngccli/data/subscription_management_service/Subscription.py,sha256=NXYr4xvDWX-poe4fcGKhFf_9PDHB8o6iE6Wxv311Bio,18782
-ngccli/data/subscription_management_service/SubscriptionRequest.py,sha256=LBGyIsekNoUvkEh-ETvM8NEYoypVVPHo3rvWpNm8Ysg,17298
-ngccli/data/subscription_management_service/SubscriptionRequestActionEnum.py,sha256=baATTL7Rdh2TH2SmkJP0URniRDnMbpHF8uPe6HE0UJg,214
-ngccli/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py,sha256=lqn0ih1ZpVq0zkoH1gKU8CNIRtNK1959eJuIeLf0ohw,141
-ngccli/data/subscription_management_service/SubscriptionRequestHistory.py,sha256=dbzrIgqJg8E4vqPRo6W_Vy143VVdv3Ic9IcoLd-FSlw,8580
-ngccli/data/subscription_management_service/SubscriptionRequestStatusEnum.py,sha256=SIyco4vEwdGQiRuT8yEU2xEkXsWk06N7A2YtmqDe3o0,149
-ngccli/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py,sha256=K743L3sWNjj_tVb716nIQUy8JnHDLdNnUVAzFXVMFv0,138
-ngccli/data/subscription_management_service/SubscriptionResponse.py,sha256=tbxHm7sdD5EYaNrTyBkOuEyu_btAZ6Xh9TJ-LGIc2lY,2994
-ngccli/data/subscription_management_service/SubscriptionStatusEnum.py,sha256=uIxQtNjEmasZjUIThC6iazzZG7Rdh_G37UVwh2kWlBk,169
-ngccli/data/subscription_management_service/Tab.py,sha256=AGJV4_5fsuC950HmZ2p7DuUMOOKgZ0TOEcpfJ8g8pKU,2397
-ngccli/data/subscription_management_service/Tou.py,sha256=8cCZPpALiKMtJ6r7i_Py-RtlQFTp4NYNKsufJaDqDRg,2267
-ngccli/data/subscription_management_service/UpdateAccountStatusGtsRequest.py,sha256=OlGlliRe0PUsgQbhIPlF_9aaDHhBWJrBaRZSfwWb4Is,3797
-ngccli/data/subscription_management_service/UpdateAccountStatusGtsResponse.py,sha256=8ztx9L-Vnp15xsC2s9O6OgSiYqrlC32rTPzTGm7PDro,2745
-ngccli/data/subscription_management_service/UpdateProductRequest.py,sha256=AMNtRYIh478n5qvCCqCT_a5o0sipVKZafF1NMyAFK20,1837
-ngccli/data/subscription_management_service/UserSubscriptions.py,sha256=vveGY1j5aMCyIAe4LfEFyXMGEfs9xJf0WhDNyS0WZs4,2416
-ngccli/data/subscription_management_service/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngccli/data/uis/AccountInfo.py,sha256=dwsGS3e0rQx8pgWHpLnQOeK9oj8SqVroWUKdV1FCr1Y,9513
-ngccli/data/uis/AddRolesRequest.py,sha256=XIHRrTiJV-YGzQu4EAjzXwSUyYA2Zo5wJAsqi2KsgS8,1859
-ngccli/data/uis/AlternateContact.py,sha256=nY2Jr3d80XPEhYkjSfnXzORO3eKrJrKjIiC7l13dWRM,3615
-ngccli/data/uis/ApiKey.py,sha256=FmgxutHXaTYw2HLZb02jQCqg9qIhVBuaECCtvpufDmk,9270
-ngccli/data/uis/ApiKeyPolicy.py,sha256=IJlyVLea490rDoQoURXHi6diuqUJcC4KzeA7Z_NtHT4,5026
-ngccli/data/uis/ApiKeyRequest.py,sha256=Wz2lNvokpiGbkpqnjSraciVbyy0e1MYcjwFQFiPevzI,4981
-ngccli/data/uis/ApiKeyResponse.py,sha256=N_PzWnuPfFIzclEGdph21A3F1FRvHAJtAUuqtB7CePQ,2848
-ngccli/data/uis/ApiKeyStatusEnum.py,sha256=L-KfkXraAy0tUdUGY5fgJhvzK5_qqDDswZ9lUuElI6c,113
-ngccli/data/uis/ApiKeyTypeEnum.py,sha256=760MOJKJ0HQQcTd7a9lFkPAaa2xT5mnpLxP5-r0nXok,144
-ngccli/data/uis/CreateBillingAccountRequest.py,sha256=jBZ05qUUWRzwCDGepguptR1d9BDHlTP2Vq6UWYxsy0I,4899
-ngccli/data/uis/CreateBillingAccountResponse.py,sha256=KWNvqnGfhxyCcTkOx24IiUjmuV-phesaLbP1Lhy67dE,3418
-ngccli/data/uis/CreateUserRolesRequest.py,sha256=UJDeuf9vrmvTEzTKdI3h4KfueJy6i_aXoP9XqvvZFvc,1864
-ngccli/data/uis/EmailTemplateDataSourceEnum.py,sha256=13lvx_jPCEgwGG_BfFeH-cI7tmF8xH4HifWRzS-_Wxw,128
-ngccli/data/uis/EmailTemplateTypeEnum.py,sha256=Jbzmd7Z33AY_EuSJJpknINOsI68bMGck26A_gfOwgcE,305
-ngccli/data/uis/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
-ngccli/data/uis/GetUchIdByOrgResponse.py,sha256=SUY6rxQ1QnpHgFCeG35YNGoO0otk3Ejmli5sr8VwKm8,2690
-ngccli/data/uis/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
-ngccli/data/uis/HealthResponse.py,sha256=5mdmVDD67RhFOoeFHF1YIYKkSsxcyrf4fFFI0m-YwNk,3013
-ngccli/data/uis/IdpLock.py,sha256=pnrOhX-4e3sWge8qsJ3E-S8HKxH-yQChwVcJhD_caOQ,7085
-ngccli/data/uis/IdpLockResponse.py,sha256=PAuRNiQbZhAKL2e0orwq62-zK_fRTMK_OYqnRRiPraU,3320
-ngccli/data/uis/IdpRule.py,sha256=IZAo9boLu0RuzyQJiOuib8u34GgNGgKPvxWUGuuvfgs,10866
-ngccli/data/uis/IdpRuleListResponse.py,sha256=11UuZf9DRMikAruLkoR2iQJPf0hMDp-GPt9aYqyr6NM,4541
-ngccli/data/uis/IdpRuleRequest.py,sha256=RO_qnSE1aCbHSc2f2fZldlqrrwu8JtGs-b7F0w0JCXI,4778
-ngccli/data/uis/IdpRuleResponse.py,sha256=uZYjHol1N_tEhGfIx1iLiDCivB1teraIXFNqrHYCwhI,3295
-ngccli/data/uis/InfinityManagerSettings.py,sha256=J3eY-cYKyLbhtRLOdZ_fq7j1owyJDvx4T9ZJj4yqWDg,2720
-ngccli/data/uis/ListApiKeysResponse.py,sha256=1bWBWzpAfGH6HCY3M1a9IJVZdJYsydCyRPM5eqKArzs,2975
-ngccli/data/uis/ListRolesResponse.py,sha256=PlU3DsmL7jy9NTzfk-JQ826Y12xoK9hLe1fzhnnz7fw,2774
-ngccli/data/uis/ListUserRolesResponse.py,sha256=k4afpOdKwHNzHqjDcoZjIPcVvht2Q8B-aPF6isSfn_8,4307
-ngccli/data/uis/MetaData.py,sha256=dRsoN1kAy2HRwwz-QmG3zGJmzXaRrOseztsAmBwAG4U,2525
-ngccli/data/uis/NvcfCluster.py,sha256=A8mxGcAKt_1xwoqGSzLYQvTRLMq524mTqrBiOCkSo0k,4868
-ngccli/data/uis/NvcfGpuUsage.py,sha256=g_7jpWGTMLvjmX6BF_sqXzSUc4mecgS3cEi1uAR0dPs,6570
-ngccli/data/uis/NvcfGpuUsageRequest.py,sha256=R8szbTSTCQf5N2qcvMLHCcHZwpuAAw7wJL9Q772gDlg,2013
-ngccli/data/uis/NvcfGpuUsageResponse.py,sha256=wwkImTRiSWGq21-lDpBBDqq10KlllE_dTk1ypWV0vQg,3039
-ngccli/data/uis/NvcfOrgResponse.py,sha256=_0xO1B4i1qpQrgDkrHVRjd-O-wCqoY6idAKpUSKVRvo,5013
-ngccli/data/uis/NvcfOrgUpdateRequest.py,sha256=SdRwVfT4HYCrEhtUK_RU73Q-yb_UU-gbEyRBVJkhknw,2013
-ngccli/data/uis/OrgAdminUserCreatedEvent.py,sha256=VG3cC0CvksP7t0fcXL6Gk85n5P_vaNYVuv6RjXceYGg,3446
-ngccli/data/uis/OrgListResponse.py,sha256=aJa53X62JFSoChIpd1e2paF2Cb2tu5-qsxKNClNsbcE,4197
-ngccli/data/uis/OrgOwner.py,sha256=RVtU503rw4IdgpSwLG-ZL18k4Hc9k8WvyHKt33wR_ug,5428
-ngccli/data/uis/OrgOwnerUpdateRequest.py,sha256=WM45jgOnPJVeNLAuhUon5f-m_Ixu_ljtpRr1FC7SQus,3126
-ngccli/data/uis/OrgOwnersResponse.py,sha256=kkDi_1dkqdItOxac3-fXtjcimdKcikx6yWoazGKq-Gc,4150
-ngccli/data/uis/OrgProfileUpdateRequest.py,sha256=wSOKWsuZVlL1isxd55DhG3jBuN-VX2zLlNylq_VC41g,3459
-ngccli/data/uis/OrgType.py,sha256=WSAh3QAhYsAq0pZFd05bLjAJT0VcODFsKt8tFWpPl7w,118
-ngccli/data/uis/OrgUpdateRequest.py,sha256=zHp3koe01pItQ5Q--tIDlfkLP5EMiOi9PaTDuVXcMUQ,19528
-ngccli/data/uis/Organization.py,sha256=0djBFWBHmRnSv2Dei3z1fXhEPPDBPou_6WAaE2N_-ws,25089
-ngccli/data/uis/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
-ngccli/data/uis/ProductEnablement.py,sha256=7JFrF_kCA-WNsncPQDGRQERZhWfg4W6fzG8Px_wT1LA,5273
-ngccli/data/uis/ProductSubscription.py,sha256=Qx24J6mVo7Gr4cqJGrt51_1PrVJHpAnVjktj2GhUcak,7235
-ngccli/data/uis/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
-ngccli/data/uis/RemoveRolesRequest.py,sha256=YhlldzcN7yvEUX8EStmQlkZe5FLRjfP2hlsYvB9nmD0,1872
-ngccli/data/uis/RemovedUser.py,sha256=mhmadmHNOhxwzIdfBbDr8zUQTyZHSX8VGKgztT2z_u4,11504
-ngccli/data/uis/RemovedUserListResponse.py,sha256=LRwJ0dH_tsjalRoPys9And4OmU6lmeEFwHSDuqMeINA,4132
-ngccli/data/uis/RepoScanSettings.py,sha256=slbOIf1Q3S5HWf1Ssfh1TxMj5DRKwRiPF9uEi_OmocA,6724
-ngccli/data/uis/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
-ngccli/data/uis/Resource.py,sha256=IJB5IoqqRj0YU0vlqqiTer7lgHoYPCisufAq7G8vUzw,2320
-ngccli/data/uis/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
-ngccli/data/uis/RoleScopes.py,sha256=BukWuyCXFPtQljNctxCCN5MRg5FDJ1YbtdsvGhAH4kA,3890
-ngccli/data/uis/RoleScopesRequest.py,sha256=4GXRPjOcJI3XTLaBtihH0sBsPDZFN8KMl1I6iJUt0sE,2034
-ngccli/data/uis/RoleScopesResponse.py,sha256=DQkhdIp6qREWDLlJU1lh6X2t3u6IQaMa8_L-bfHgd0s,3060
-ngccli/data/uis/RoleType.py,sha256=Ogsb7vqOM2mgwo8aKmB1un6U9yUb-9trXwNan9yX83o,1726
-ngccli/data/uis/RotateApiKeyRequest.py,sha256=Loat3kcaJlEhrez_VJ58E8bTKu81nodiGijDkqqezpg,1940
-ngccli/data/uis/SakCallerInfoRequest.py,sha256=jeBUQwsMJAEuxQ1WoNoP3KiksoyOhgmDlWF7qz9jhNY,1975
-ngccli/data/uis/SakCallerInfoResponse.py,sha256=-3bIsrDwN4IFQYIikrRwyV5dn0rnjOkS8rbsYbpZU1U,5852
-ngccli/data/uis/SendTemplatedEmailRequest.py,sha256=3Qn6-mK21J1GkgVTaCwkT4BxIJbnhy3UncEkyDcNZgU,9736
-ngccli/data/uis/ServiceAccess.py,sha256=5RvI0SCMC_KNMEuLmeiacAZYgQrDXpxsMgKSjBaLdCo,3012
-ngccli/data/uis/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
-ngccli/data/uis/TargetSystemUserIdentifier.py,sha256=ZbsvvU9RKZwEf2hbsMIY3waMShriwllpLGq3qyo-9rc,5648
-ngccli/data/uis/Team.py,sha256=Tv_a-XAPKxjij3ZxIbuQP8jNv8DsZL79qi-e4X6f8pc,6353
-ngccli/data/uis/TeamCreateRequest.py,sha256=8awxlfnUFS6k68KOO18ADFcthSPzOw2ZujkBXfU8-js,3756
-ngccli/data/uis/TeamCreateResponse.py,sha256=gVjsgGApuEyXstxZA3jms4VUTzcn2-PMaSo13HVNmVs,2856
-ngccli/data/uis/TeamCreatedEvent.py,sha256=77vAtprTmdzL5LzEUJzv_VukI7Y6wiwfi2cGbDLBVQw,3332
-ngccli/data/uis/TeamListResponse.py,sha256=x2NRybvc0ZhDCJUp7taq2luwH89nKlMYwi7C6vVqVBU,4017
-ngccli/data/uis/TeamResponse.py,sha256=B5JfG8y1r0y8ZPOJ7VRoxhEkH00v3TixvgV9G_VVeAo,2811
-ngccli/data/uis/TeamUpdateRequest.py,sha256=kNAW_EBo8txDpexlWVxigeHRHi0L91mW5MJia-qdjec,4496
-ngccli/data/uis/UisOrgInfoResponse.py,sha256=JLdi_VdorlK3OHqmMKKwo7BVuU0hWurfjoQ_FC2wmrU,3032
-ngccli/data/uis/UpdateApiKeyRequest.py,sha256=WeX1pivUv2IXcDWVZ6t8lcc5GloKqeRrNChKHzijwbI,2811
-ngccli/data/uis/UpdateUisOrgInfoRequest.py,sha256=Y8K6ER2FzUCRW0gF7EhuVLJLZ8AJvxhSznfSyQgnOGQ,4360
-ngccli/data/uis/User.py,sha256=Q_btV-EDMHrh9xHehYixw-3XNdxTn_yJyXZRZueiU3I,33471
-ngccli/data/uis/UserCreateRequest.py,sha256=hTpDxCs5tgrfXZYO3uPp8Aos_15NvHN_RidPn8ExM9c,9435
-ngccli/data/uis/UserCreatedEvent.py,sha256=vT_ew2DzLqcIhMrbBhQusjNke3dV8_Hid_1oq9O_LCM,2525
-ngccli/data/uis/UserGdprStatus.py,sha256=oFZFL5tcJ8-IVvGo8hS9rjPQKGNpUuMDv00T2f9BiXg,136
-ngccli/data/uis/UserIdentifierType.py,sha256=f9i3xgkzPJtPzBDv3kGZrxq6L7powGqMZSvfZZ1Jwto,164
-ngccli/data/uis/UserInvitation.py,sha256=4woFFsbBCmgdrGboyyHw7xV6z0MGdxjSy3HXxTwAD60,9651
-ngccli/data/uis/UserInvitationListResponse.py,sha256=oX5dmX8jNcycKfaJVScWFKaCVisfoTpyen171bphl4E,4231
-ngccli/data/uis/UserInvitationResponse.py,sha256=8w0YpIMzZfMqK_NxfZDk4rUZvAtxJ4BERLIcqK4-Gbg,2988
-ngccli/data/uis/UserKeyResponse.py,sha256=zJyNxvsXrq6miALIjuxJbKn6nCXqRndzmAuEItpyhMw,5560
-ngccli/data/uis/UserListResponse.py,sha256=mjyjtXK8medpnEmq199C3lS8tYK8Z3bUeNSsyB8RaQE,4058
-ngccli/data/uis/UserMetadata.py,sha256=1GunPpiDPOXdqLxkX-fEaW36dFmdMitVdJb2NNH90SA,8112
-ngccli/data/uis/UserProfile.py,sha256=XiZVWF529AMBNz9bkn53we59ZxjZfWZ12_vAHTAe6pA,11401
-ngccli/data/uis/UserProfileGetResponse.py,sha256=owjSzUlkvSlcjQRUa9WzepYLlF0Jn2zC7vy8o4OezZQ,3002
-ngccli/data/uis/UserProfileOrgInfo.py,sha256=EBsbFglgetG5k16r2e3XtS2cuvzLpfV3PApqJ36r7B4,5170
-ngccli/data/uis/UserProfileUpdateRequest.py,sha256=TTAR16HuTuZ_qKIFJUr_avtztQKnhWgsrRj7nauiu1o,1982
-ngccli/data/uis/UserResponse.py,sha256=o2KAH9oaX6d_h6cVHFWrEzLoglCVyvnXfS3FoOkJA7A,4806
-ngccli/data/uis/UserRole.py,sha256=vOJqokrF50DA7090_o-dEHEJaitL3JvR2-lt7kRRlLk,6556
-ngccli/data/uis/UserRoleDefinition.py,sha256=KhTgZsIl0CvUSTIc5Qf4Q3aUTr2s37XmPLk3UO8gtHo,2808
-ngccli/data/uis/UserRoles.py,sha256=n6w8qhTErS-gufh4yasOlZccMXupU1DpbmU-Zog13io,5029
-ngccli/data/uis/UserStatus.py,sha256=nGnxIDpxng-wMCJTysobaJw1H6cq9czRHIfbwnyc_mQ,112
-ngccli/data/uis/UserStorageQuota.py,sha256=9ZfUcjOBq7Ur1jjkZ3JJL3DZAM2D4X3w-3OUHYrmy2Y,12800
-ngccli/data/uis/UserUpdateRequest.py,sha256=phvQfSfexG7YHzYOPRp4BUcK1X2WvbGlfwiVT4vO8qo,22375
-ngccli/data/uis/UsersInfo.py,sha256=gLEr6mMH3HpclrYfy1JjsgM3x2s5GEVjcPqTOAKhs-0,1718
-ngccli/data/uis/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
-ngcsdk/__init__.py,sha256=OLsQpxpNLuEQ34l3AJsbomUSUTNvoYrQwE2LpHZa_MM,4540
+ngcbpc/util/utils.py,sha256=QGTA5KS5ndAeic4Rrdbg-sdQcGrEvIpy-oPw_AmF7jg,18177
+ngcsdk/__init__.py,sha256=gLwaSicrNcTtb8bqXcYc-NREGBxJ-f8lMPdPhSnr83A,4777
 nvcf/api/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 nvcf/api/asset.py,sha256=9AE0ck8-pkoqfYlRAIhvcXaR879H0TFvsbgc1KZNNmw,7605
 nvcf/api/deploy.py,sha256=QkwLmCUneJ6UpiJyKIv-MwJv6IwggkzzYSnd7b1Fvxg,9212
 nvcf/api/deployment_spec.py,sha256=Pm-pDMOzBw_x8gVLoWp7VmPodYOvtIRTI85Cm1gu2BQ,3901
-nvcf/api/function.py,sha256=5JjOFT2LueU5gMmNEHIdL5EYplB7khZ8FVI0nO-f_nw,20295
+nvcf/api/function.py,sha256=dWxCcNVqJbRpOx4kC4W827o4ek957Y--0veLtjI1ozI,21436
 nvcf/api/gdn_nvcf_grpc_client/__init__.py,sha256=W7awGVuhjAcufY3MN5sRAgtdhMRXmQJLAStjZ6-5Xxk,476
 nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2.py,sha256=edbuNQUtop-soNud0jJTAGJFIagmygvfS1pRLAxP9Cc,27469
 nvcf/api/gdn_nvcf_grpc_client/grpc_service_pb2_grpc.py,sha256=-JToftnNQKtoHMcv500jhxcO1zUxfmnaXAiAb8dibzw,39051
 nvcf/api/gdn_nvcf_grpc_client/model_config_pb2.py,sha256=micpnx-DTOZvXONjidllNU4F2b8X7ttCfWw4N9ueTXk,25600
 nvcf/api/invocation_handler.py,sha256=NaL6tThkem9cRjXd6ceoJnWGnQtExO-zgVFB2lkcmC4,9301
 nvcf/api/nvcf.py,sha256=M7HFU9tWXcr3IQZj-J5JFePBvFKsqxZw9G6M7y9FVkY,1136
 nvcf/api/utils.py,sha256=MqJK4qGbjc5Zi7UjxRNMSyejxNkWmV-MbPsMxkDMmys,1147
 nvcf/command/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 nvcf/command/all_commands.py,sha256=BG1dUI9Vj2YXXr9wlCXM_uPZnLWzzfdnDgxjU9ZVuso,610
 nvcf/command/args_validation.py,sha256=j11lgkOW2P-MQd41HOcuL36LoI5jEkZOyl31cbDH-x8,1484
 nvcf/command/cloud_function.py,sha256=qfcDFWh2KRwrmf2cibfKMhPO2KxsbRF2LVbPs4KY7RI,1415
 nvcf/command/deploy.py,sha256=9ZoRtMma9JVMS2ENRKR8omRU-JRld-7teJkvDjmSnwQ,5797
-nvcf/command/function.py,sha256=KsAXpV03tUldnX-yfJo-zp8MWMNfz2C3zxqIUa6nue0,9166
+nvcf/command/function.py,sha256=lkhee3BdRQnQFwkHamlu8bmTIhfR89JEQlf2L92SBrY,9730
 nvcf/command/utils.py,sha256=cNJ1yosO8GrikmRbzHCUMzDZCcknxZHn28wcnqIQiNY,3388
 nvcf/constants.py,sha256=aIvKtYoFTfm9h_NNVf8wH94g8jT_dk5ts4EGT5h9Oc4,833
 nvcf/printer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 nvcf/printer/deploy_printer.py,sha256=j4RfKXrvk4J0eVujC3Qmk_rp8GpZMTfkSmSGTPfqmUs,5121
-nvcf/printer/function_printer.py,sha256=MKxis-57D0AMQoraSb3BTGsmPQ2XIp51shjuKMC3nq8,3804
+nvcf/printer/function_printer.py,sha256=JToe0Zr_yHB1lLiFh1UHAHZulNVGpmrN3M8BGTJr3jI,4235
 organization/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 organization/api/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-organization/api/alert.py,sha256=MvF8VQP-89dhSxCWNKbMvCZiZmu1HoCitwOazinWQ0U,3070
-organization/api/audit.py,sha256=sj2hLpxt9bi74qbnxhO910BRHm0qVEFEsQ5xgUdLlvQ,5957
+organization/api/alert.py,sha256=tPLPDgk-3PplY_ty61EBIH3sTJNDNp-_aqvbemNL6gY,3070
+organization/api/audit.py,sha256=-haPKmVMwjU7Kh8UlqHBT2-IlF7k0djtkSNR209XUGg,5957
 organization/api/organization.py,sha256=Uf0ot0HeeRWXvPhNP8tJ3FbUZ6FoUcwSOyql7CDxQB8,1738
-organization/api/orgs.py,sha256=vrCeKskAnPCqAF56jF2N7kWETAOQw1M9pAuL32mIuWg,2275
-organization/api/secrets.py,sha256=Z90j5EKuf19THB64uUuTTcY582okcUSz6APJQoV2D00,9174
+organization/api/orgs.py,sha256=x_U0Hl5LUtZ7nVnz8pwr4xp_AKPVpbtUFlGvXuwSUIg,2275
+organization/api/secrets.py,sha256=Yn8yFe3_yKxn6qgcnJ8UF7W7BVh4k2oSX950TcvVv14,9198
 organization/api/storage.py,sha256=sXnEONJXCJWVqidLIwTbMTLDvpviZcl3ltXxGqFlMM8,1479
-organization/api/subscription.py,sha256=5CoxuvY_KJmD0LVv9RpXjzVsz1akyHdEDvGOWLIXax0,7816
-organization/api/teams.py,sha256=oEnwfVxuLjS6Q7Hy1zowo_YLyK3jO-Yw35KvHlAfmQI,5318
-organization/api/users.py,sha256=LYS1F57sWgK6Y5whZ4pbMzaZhR8KhCst91OfiKPPzmY,22690
+organization/api/subscription.py,sha256=_ZC6OaMdYsZgWTDQSmVnfCkPsr2x0HvOCNOwP7Omvsg,7846
+organization/api/teams.py,sha256=YElxBrmhIlaRZTOHHMqYmULlsX03FIL6uvFDP7V5TZg,5318
+organization/api/users.py,sha256=unbMdB9bNXs0VI8v258tBApzSxkvA4ouiRYee7LitFg,22690
 organization/command/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-organization/command/alert.py,sha256=rITr6T9-iuwAOx4BNElCyJeHkm_VwN8ZLhoD3ajpRPs,7691
+organization/command/alert.py,sha256=PZvpFrnE6i_7g6E1IALna9Y1N9_5IAy-yLCqcaANS3E,7691
 organization/command/all_commands.py,sha256=3TGX-sFku7jj1tcM4hiqiHBjvcObDHeutBIIfcNk3PQ,817
 organization/command/audit.py,sha256=K6KYzaa9MptRzLfNUhVjdd7oLRv195VlQAaAcN7Ua2A,5334
 organization/command/org.py,sha256=URBEIvq8S8X1z06jwl8Ud3L2D7ytTcPWlUPcXcdNCJA,15269
 organization/command/secret.py,sha256=_tBe_ZvDci9zxxBwf9gxR5a76y91fRD8FSR-zNgpwZk,6548
-organization/command/subscription.py,sha256=TOWuG2YB_L17c5ttuStftCd_2jzroRUW0rmTBrQugb8,8457
+organization/command/subscription.py,sha256=3wgU_TPeMdI9-Lmb6qN9BC2LHass5UXoe9R7vmPjsGw,8463
 organization/command/team.py,sha256=96rDFlPNS7tPvsUtR6y1mSBH7HNMjriH85i-CMPqw-g,19595
 organization/command/user.py,sha256=81CKJxtlIE9miGD25K9x-C1vXAD4h7ydzvSrNkMX18U,4717
+organization/data/sms/HealthResponse.py,sha256=aAhB_soUNfGrRZnd2zyxPbtplYng-cOwBMlqLuOuHhQ,2905
+organization/data/sms/KV.py,sha256=CXZedIazcyxFRpOUd32oFlb798ov2Gjgjpmux8bGxzc,3116
+organization/data/sms/Secret.py,sha256=YcJsQRuAdtm-WryATB6lGL6cPpRSmXZR-C8CgBBQKKk,8710
+organization/data/sms/SecretCreateRequest.py,sha256=xNaVlRUbM70F_1DQiBykFFwApQ3H6t3DCarjJMN5-2M,4968
+organization/data/sms/SecretDecryptRequest.py,sha256=jT6VutxVHgNhS4icnM5reJMIckn1BFTZMXpmcW-mR7Y,4395
+organization/data/sms/SecretDecryptResponse.py,sha256=vDGRpmJRBenMbnvRJyz7yuQOUqUdASxzlflh97tN8HA,3253
+organization/data/sms/SecretGetResponse.py,sha256=eVInMrjlw8VsxZPCf1Y6hQNGyl_bF5Zic-rj1AMhWgk,3037
+organization/data/sms/SecretModifyRequest.py,sha256=d52BL-3fuqjeIOu5XFwUcYbjvP4uP3Nf_y63-vA6JnQ,4583
+organization/data/sms/SecretNameKV.py,sha256=HfMuYBCDgt5OR807ePAU1g5AMM-0N_wCOtMSnadVQM0,3123
+organization/data/sms/SecretRequestStatus.py,sha256=NbmwENENwi5Be4_XE9GQUEqKnJTAuYCU9J5EcCHqBng,3680
+organization/data/sms/SecretSuccessResponse.py,sha256=D6h3TcfvkiHK2oEWkS0Sd19CrhBhzD3ss3Ul6QaE0Ao,3197
+organization/data/sms/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
+organization/data/subscription_management_service/Action.py,sha256=IxZnpGkLkk3dswJG_FBZwGUPi7vvpja1hPP2puci5n4,3043
+organization/data/subscription_management_service/AzureMarketplaceSubscription.py,sha256=60o8RYOH9D0ZEIMtAl6mW7B71wqaxhDNHpnDKKu2hj0,16440
+organization/data/subscription_management_service/AzureMarketplaceSubscriptionNotificationEvent.py,sha256=j-uKI0IBTaAwuFO81ApNQ5SoV-7CEEksp9e0q90IW5I,11664
+organization/data/subscription_management_service/AzureMarketplaceSubscriptionTerm.py,sha256=qzwPwc5ObyDAr8sMN80yz6phT4KLVZSerkM8nkSDFFU,4213
+organization/data/subscription_management_service/AzureMarketplaceSubscriptionUser.py,sha256=nnMKKowqKFLNxmxzSMaGhsM9e0LGfISFNPyWQ_CD3Z0,4002
+organization/data/subscription_management_service/BusinessContact.py,sha256=Oh2M7skCI1UbLEJzEozvA4MPnUn3j0qGdyNiiB3etyE,13228
+organization/data/subscription_management_service/Charge.py,sha256=dEtheiEJXe78pwJdbBNlE9vSpLbkIji_436TAGNEadY,7569
+organization/data/subscription_management_service/CreateOrderRequest.py,sha256=RlTW8A3bJUPe46umLmunByQF9CXiglZHOJWvqN_RSto,3844
+organization/data/subscription_management_service/CreateOrderResponse.py,sha256=EfdPuvaz4EjQFShQEPaIvJ8-wTyR9MOJ-JKnj1_8FEg,2814
+organization/data/subscription_management_service/CreateProductOfferRequest.py,sha256=zYP2mNcCe4NA2wMsOdFBkMkc3mQcSKRKZfkn1GoAOk0,2189
+organization/data/subscription_management_service/CreateProductOfferResponse.py,sha256=YcnAsowh4YoXfWGRAH7-v6UlSgigmu042tflIm5jsWk,3027
+organization/data/subscription_management_service/CreateProductRequest.py,sha256=Dm1rZFS7ZxXjZipDtrgzOdKrhANDmPrU2vWrdT8hTYA,1837
+organization/data/subscription_management_service/CreateSubscriptionsRequest.py,sha256=KUx3-25p267zaawTkcdeRYUS-B6s9m0ta4TvVDNmRCs,2199
+organization/data/subscription_management_service/CreateSubscriptionsResponse.py,sha256=o2cqVTGgqswBMwGwEDZvjEzHXdOhpYxkZX2KYwIzhWc,3121
+organization/data/subscription_management_service/ErrorResponse.py,sha256=jeqvKWNYTPw3KQusNCn3jKpr4k5Q7dbrmGaegIJApYE,1941
+organization/data/subscription_management_service/GetSubscriptionRequestResponse.py,sha256=r9wZJGAzNt1c-gg0VJHV8EMWK2rAmFbge-r0tWk23Tg,3167
+organization/data/subscription_management_service/GtsOrderTypeEnum.py,sha256=e0YN-_mg078t4omgJUl_cGNh5SS5iX9AT6-Ppl9cr5A,165
+organization/data/subscription_management_service/Health.py,sha256=4Php8TYKTWtSMuocuu-HooaPrRqI7OiUfY2EK6S8FXk,4431
+organization/data/subscription_management_service/HealthResponse.py,sha256=5mdmVDD67RhFOoeFHF1YIYKkSsxcyrf4fFFI0m-YwNk,3013
+organization/data/subscription_management_service/LineItem.py,sha256=NVvxxjFc0UNPcFGmQM1QvKry3o-lB3aqny5wrWx7XuY,8838
+organization/data/subscription_management_service/LineItemTypeEnum.py,sha256=LRMnOZOGLRgk5ZzAIcfFgxVHw9aUQ362ry6KgwiZO0I,116
+organization/data/subscription_management_service/ListProductOffersResponse.py,sha256=D2g4hYH0qDCDRQa1MosDo-wUfoir_O9cHbxpEQYXaJw,3024
+organization/data/subscription_management_service/ListSubscriptionRequestsResponse.py,sha256=6tlgnn2DTHOJzPEUq2slN0FuSUDsGaL1OPPVtT7DkMA,4376
+organization/data/subscription_management_service/ListSubscriptionsResponse.py,sha256=D2e1GmvM5xDFjtmyDF1zIZerrt4J_JnXsMu-owRoytk,3146
+organization/data/subscription_management_service/ListUserSubscriptionsResponse.py,sha256=WO7H975OKP5t0XYF1gdoI13rqK91dHekjUOBkZDJQAg,3180
+organization/data/subscription_management_service/MetaData.py,sha256=_hKxI7vBoTx3HTOfSZ72DOLf3GXzdBnjCqhUvtMM-RY,2762
+organization/data/subscription_management_service/Order.py,sha256=hbzmwh1TDTP0KtT9vyoMdsDyiYsdRX5wMbI0uPTJtS4,6764
+organization/data/subscription_management_service/OrderActionTypeEnum.py,sha256=ooZT2ioqOcvOc_DaTh6ahsSwHBrBAq4s-8AY6uH5m6o,319
+organization/data/subscription_management_service/OrderSummary.py,sha256=EHA7_rm6voP0aO9DxkexHDak9KKkn79hcZpwKrI6bVs,5498
+organization/data/subscription_management_service/OrgEnablementCreateRequest.py,sha256=CVTGAZbu_92z0AWe8ajQVbr6PhKhWMDyG8vRL3xMP1M,3450
+organization/data/subscription_management_service/PaginationInfo.py,sha256=tSlPe592LjTav89fR40B4SNEL1BFN7-wpgF3_l5vEwg,4853
+organization/data/subscription_management_service/PreviewOrder.py,sha256=Cg8xACZ_aJ3zv-dNekamYxPgNsvnjQbk9_eNq_Vpt2c,5380
+organization/data/subscription_management_service/PreviewOrderRequest.py,sha256=MU4rje1hjeveaWNGHFkCGPZnu8_v_VSiMHcRBp41ixo,3848
+organization/data/subscription_management_service/PreviewOrderResponse.py,sha256=izXMIs6BHKuvxqMfUBmNwTfww_BUMdJm0sH-1O9hkdM,2991
+organization/data/subscription_management_service/PriceFormatEnum.py,sha256=BPaBzIFd6Z_TGnj6TiA73-EvrxugU3fYHBIqCUA4rwQ,104
+organization/data/subscription_management_service/Pricing.py,sha256=sg14OZW-YkcoiTDS2B-gD2RaGSJiVCo4HbkdVUvZtUI,7508
+organization/data/subscription_management_service/Product.py,sha256=6u40TGV0YnKthfZU_IN8vRFFQey7Pb6BXmuQ_FOcKcg,19993
+organization/data/subscription_management_service/ProductEnablement.py,sha256=7JFrF_kCA-WNsncPQDGRQERZhWfg4W6fzG8Px_wT1LA,5273
+organization/data/subscription_management_service/ProductOffer.py,sha256=wInIpy3e2Ga3x5Dw12BUkKJEHr0QC2R516bE0jPAZL0,4859
+organization/data/subscription_management_service/ProductPlan.py,sha256=a8s777IoSDkcCUNMRhWyaedKHR_N6Rtflhm_es95_cs,15339
+organization/data/subscription_management_service/ProductPlansResponse.py,sha256=5XS-DBxhWI6-_NeamzxcMtTiqIQ01_JHPwtkxDbveeA,3120
+organization/data/subscription_management_service/ProductResponse.py,sha256=0VXbHyybT8AxD-xFP-8s7UUWlynKHGed0_rwRm8nW60,2851
+organization/data/subscription_management_service/ProductsResponse.py,sha256=m5f6L8p2LX5AwnAcMMION3oybpYED6JT1BrqoI566JA,3026
+organization/data/subscription_management_service/PurchaseOrder.py,sha256=U-21e3iFX5METpuXr35S6biOemmtzjJC_0ZZyC_NLeE,2525
+organization/data/subscription_management_service/RedeemPreviewSubscriptionRequest.py,sha256=WfZP6dHMUO3qOHkIyK3f9w9X1lTyg1eMIc7dBTB4PCY,1911
+organization/data/subscription_management_service/RedeemPreviewSubscriptionResponse.py,sha256=jS9uUCPWq7MHkaEUlVpggM0Gt3Lojtihmf063RQa4V0,2964
+organization/data/subscription_management_service/RedeemSubscriptionRequest.py,sha256=gW2cDD5UpXZ9D7fPGY0sr22UyfNYuI6s0opCxzBRFzQ,2957
+organization/data/subscription_management_service/RedeemSubscriptionResponse.py,sha256=JLSO5cM3ZYakQmTt8Ly8qZU82hHAppo_O-KfPEpPhqo,2820
+organization/data/subscription_management_service/RelatedArtifact.py,sha256=8u5lJq_aZLlp6jZNoI0-6_Qt3Pg7bbFh3U_WifDy1dg,6650
+organization/data/subscription_management_service/RelatedArtifactsResponse.py,sha256=RBgEz7J0yLhVOXx49im6YY00Tgq1ahjDBZt4lDrNvCo,3212
+organization/data/subscription_management_service/RelatedItem.py,sha256=M6KpS18DHY7Hra3eq3-D-RCt5M4FgCM5niaaYtfJT9E,2371
+organization/data/subscription_management_service/RenewSubscriptionResponse.py,sha256=ziOhQTUW6cTZq5o1eNUSRjM3otDCL5E5urMJxFLAtmg,3001
+organization/data/subscription_management_service/RequestCreateSubscriptionRequest.py,sha256=ZekrVpkHo7nVe2wPI_o7V_ge86KckNJkOyZyKcVGu4k,2703
+organization/data/subscription_management_service/RequestCreateSubscriptionResponse.py,sha256=fpVAzqyJmMGUEK-OV0VXE8sg1tntSCCPhrwrsPw33JI,3175
+organization/data/subscription_management_service/RequestStatus.py,sha256=jR7Y_9Kh21mN05P-XWKkx3NS5ZPx8Ef_a9ymNXAxKHc,4127
+organization/data/subscription_management_service/Response.py,sha256=rF_-9igbt4zDkwpWg_7XrXZ8TTYBppfO877xK9JKNmQ,1936
+organization/data/subscription_management_service/ReviewSubscriptionRequestRequest.py,sha256=YhkOziMudUMGOWSr1ukB_fVn36Ml_uNPOwpGsVuC7nw,5119
+organization/data/subscription_management_service/StatusCode.py,sha256=9cSEGHM0lC-ofsnJl0KU29TYfVEJfb5p5S613qHEvDc,450
+organization/data/subscription_management_service/Subscription.py,sha256=NXYr4xvDWX-poe4fcGKhFf_9PDHB8o6iE6Wxv311Bio,18782
+organization/data/subscription_management_service/SubscriptionRequest.py,sha256=TF9u_n14hIKAD3tRTRKYiFHCXixMbaPcRLi3KRqqoS4,17298
+organization/data/subscription_management_service/SubscriptionRequestActionEnum.py,sha256=baATTL7Rdh2TH2SmkJP0URniRDnMbpHF8uPe6HE0UJg,214
+organization/data/subscription_management_service/SubscriptionRequestActionStatusEnum.py,sha256=lqn0ih1ZpVq0zkoH1gKU8CNIRtNK1959eJuIeLf0ohw,141
+organization/data/subscription_management_service/SubscriptionRequestHistory.py,sha256=_6LRfO6pjsIzAHKsKLkoSqQ-8MlG4SzRazHzxWpX4wY,8580
+organization/data/subscription_management_service/SubscriptionRequestStatusEnum.py,sha256=SIyco4vEwdGQiRuT8yEU2xEkXsWk06N7A2YtmqDe3o0,149
+organization/data/subscription_management_service/SubscriptionRequestTermUnitEnum.py,sha256=K743L3sWNjj_tVb716nIQUy8JnHDLdNnUVAzFXVMFv0,138
+organization/data/subscription_management_service/SubscriptionResponse.py,sha256=36IscaRhSQoGmBKZfZlFqqx0JJnS63m7EbssgPXg2z4,2994
+organization/data/subscription_management_service/SubscriptionStatusEnum.py,sha256=uIxQtNjEmasZjUIThC6iazzZG7Rdh_G37UVwh2kWlBk,169
+organization/data/subscription_management_service/Tab.py,sha256=AGJV4_5fsuC950HmZ2p7DuUMOOKgZ0TOEcpfJ8g8pKU,2397
+organization/data/subscription_management_service/Tou.py,sha256=8cCZPpALiKMtJ6r7i_Py-RtlQFTp4NYNKsufJaDqDRg,2267
+organization/data/subscription_management_service/UpdateAccountStatusGtsRequest.py,sha256=OlGlliRe0PUsgQbhIPlF_9aaDHhBWJrBaRZSfwWb4Is,3797
+organization/data/subscription_management_service/UpdateAccountStatusGtsResponse.py,sha256=8ztx9L-Vnp15xsC2s9O6OgSiYqrlC32rTPzTGm7PDro,2745
+organization/data/subscription_management_service/UpdateProductRequest.py,sha256=AMNtRYIh478n5qvCCqCT_a5o0sipVKZafF1NMyAFK20,1837
+organization/data/subscription_management_service/UserSubscriptions.py,sha256=vveGY1j5aMCyIAe4LfEFyXMGEfs9xJf0WhDNyS0WZs4,2416
+organization/data/subscription_management_service/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
 organization/environ.py,sha256=u37g8nv1vSivxjeAyWAYxehzt5NtmN4ycUJaVI-IkE4,672
 organization/printer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 organization/printer/alert.py,sha256=ORsyDDCUsENm6avT6jQYFrtrVX-oBsRN3EeKkHHkcVM,5250
 organization/printer/audit.py,sha256=ZDmTc6CYHqYAW7YplNOrMfhMGNim5PMcVzvzmM1BkN4,1808
-organization/printer/org_team_user.py,sha256=TbBo8c8MwJUg4pnJKFvvES01B8ndwnsmWV3iBpLwPLw,18008
+organization/printer/org_team_user.py,sha256=wKrfZLHcJgYsivUSPzJerQ8d0swavBhBv9EpdCY4OaM,18014
 organization/printer/secret.py,sha256=EPN9qeOcfHBExvohWh5PlqQCKWv2cHHiDjkUaPe8lXY,2576
 registry/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 registry/api/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-registry/api/chart.py,sha256=SwaLruZPZr4pH1uiouF_z8x8-gnE43ovqF6u8i20KxQ,38303
-registry/api/collection.py,sha256=ugSp87D7H0mo0oAqMpNV-m2fov3oryO3avZ1LlYvOlM,9315
-registry/api/csp.py,sha256=U5XJ2qvimiXo37nXSGyzzGbdwysSS6PiyCDEURMxkbY,7863
-registry/api/deploy.py,sha256=seB6xhlUaT3W-VwQk3PRLSDUXARkL7mcpAyJPDi69pc,5460
+registry/api/chart.py,sha256=8ngOxnkiKYa7HZHm418hsQRDePyGGXzNzIWwZfv-OME,38341
+registry/api/collection.py,sha256=M-jUgL1vEtVKMYfKM77790OhxOVJAQMiIbAb1gvCmCA,9315
+registry/api/csp.py,sha256=KIkDFkOYpY3WeVOnruyS6xBJvck35O5fXbOFv822Y1g,7863
+registry/api/deploy.py,sha256=9FgjZ5rMUuRmRZ602Wd6zJEdAUds4XyOf7H5UN0BZyc,5460
 registry/api/dockerwrappers.py,sha256=08jbg5J8b1DaKsTv0SE7GCYOR0VOF0R_Z-9z-4QFkXg,7091
-registry/api/image.py,sha256=at0AM2K81l5It3PCX2FDNPauWro4YCLmVQ-dGKUeB44,41396
-registry/api/label_set.py,sha256=2c-kj_Pp52LXn-vfwnfLHr9aGaaaJKpXgEWplndFKjQ,4619
-registry/api/models.py,sha256=Z8Vo48CpDNOgkcqCP-KVj2BsBXRiwdHi_xBP8HoX4Ug,40508
-registry/api/playground.py,sha256=4TdpCEIwSiIhAGkR5iWwac6j30C6DxJlAMjj3YOYI4o,4048
-registry/api/publish.py,sha256=lcPE-dZaoI7lmz-w42_mczKy2SPA2nRMGK4G84sn0us,6588
+registry/api/image.py,sha256=mzK9LUsZ1Ul_M_KEoOhO8LIk9cAIUp9lcg7MEaPBc9g,51245
+registry/api/label_set.py,sha256=WsPu2klfDrPDVVLPWnKAcWqhTfEwPOPjvp4agCE8cVY,4619
+registry/api/models.py,sha256=UZUetWQFivBgsSdrIsZQTh7Hh_jddFE1uA3mjK228LM,40508
+registry/api/playground.py,sha256=0Kj5Nv2jHLck0GsEvFDhUnTQuMpZX6lfNv2RAf1_fbA,4048
+registry/api/publish.py,sha256=OoBF4_nhEPR-7ixWbUo2aa3snZ-tBBHcx4y7Opgp7l0,8314
 registry/api/registry.py,sha256=87gVNRZzEt4Rf74bupba0oJgHrbStxdhI0g3b2HWVm8,4693
-registry/api/resources.py,sha256=NQkpo-YAVHNa4jF_eWmXPZMef1Dc7AnR0ykN5EHFV34,46836
-registry/api/search.py,sha256=FmgeDtVG_WOJoALvxBULm_E14dNdqd_51c51KcmZwB0,5503
-registry/api/utils.py,sha256=ssvRn68ub4qmwEuSRxV9rUF8MEzAan_ZItziMKh4zFE,21639
+registry/api/resources.py,sha256=YSLY26vhbwgbvqtB1tG118zERoCliGVtob-hgO_Cg28,46836
+registry/api/search.py,sha256=6AhLx-I0HobxIeaHpx1Eix0FRK7qhN0ujXUp84Ya33Q,5503
+registry/api/utils.py,sha256=CUAJ2CFRDvJRgYoeUiKMnmw6AE-Pgz_VkKpKlnCA1l4,21828
 registry/command/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 registry/command/all_commands.py,sha256=kG3rDPZ1wmeR-lZ8JrCHzSoLomzA8-bPvDcm-_OeT-o,1087
-registry/command/chart.py,sha256=D0s0uU73ike7XQBCuKvtJlcvABXthWbYTpL9_iGFzVo,24429
-registry/command/collection.py,sha256=uPS0dvac4pKeMTI21FmPyLbjdNlCszywpdKQsGSuMNw,24586
-registry/command/csp.py,sha256=JpfkqZ89CY-eFBket2AKrhgEDEiqOvGKl285cM1AKfs,18448
-registry/command/image.py,sha256=9DABvDNGGIVF7UCT29coZwAT0oqlOCi1p60MJEwv-A0,25517
-registry/command/image_deploy.py,sha256=BWOA1uxhETljxAg5XWwpuYSGS6OAxV9ghDDBlGo-w9s,9578
-registry/command/label_set.py,sha256=TviOjIYQj89mliSfeVGNevi1z1aC23Pb2c3iLO8ECQM,12015
-registry/command/model.py,sha256=EIQsIvPiF-oQlBHjYB2g4EXbhgwx9E2nDlphQuQfu4U,36120
-registry/command/model_deploy.py,sha256=CVZ5nnbcplGMolP1OYqNwTAILS4f9rk0nfB9q3gUT3Q,11360
+registry/command/chart.py,sha256=MOcZ484IC0oazXJSG_6hbM4TrIWZGGBN3ju-WTrk38U,24374
+registry/command/collection.py,sha256=2F0t3ykD6bPclQGJr6BM9D5OA3KHbk2Ws-3JmEnKF9Y,24586
+registry/command/csp.py,sha256=QJg_F__hgK6xZ4oHnhxnoMEeTaXDlLpTOxJrueKwNiI,18448
+registry/command/image.py,sha256=TVUPCB291m4siY9_L-GWRZul6PTiXDVgLPKBkywyDNE,24220
+registry/command/image_deploy.py,sha256=pa4FfYG_bzCXvxb2gfD11K-fgys9neKOO1efScX2SL4,9578
+registry/command/label_set.py,sha256=Apo7LKsH1Xn8r-wcy7bJyv7VufL15UPXdMLM5qdCRbw,12015
+registry/command/model.py,sha256=HCgp-ntLeBy6kmJZuqlnkWvWW7amd2gK9ehsnJGFUWw,36120
+registry/command/model_deploy.py,sha256=DUgGcRrmq9rv00CqEGWOrQclgZM9rxjJqQYaRE8c_tQ,11360
 registry/command/model_playground.py,sha256=vpr_yWjKxurL6c39UhqIIHcf1rrn19NrDHGqRQxxvGo,1834
-registry/command/publish.py,sha256=A0ClPQ4_NJugSc8vVz1oRKxPb2OpriH2pEPrcmPNNJA,5545
+registry/command/publish.py,sha256=y-hFt7nVIQAUalpqhJTOxUcptnGYcmQx7eMcJwbtISU,5255
 registry/command/registry.py,sha256=J6NW7unSKcrx0Xt1i4xl7arnmPfSxkglz7WCs-9LQxo,789
-registry/command/resource.py,sha256=g8jOTBUGhS8wScJuwir2jbmP11EjOUA1d34eEis_sGg,34026
-registry/command/resource_deploy.py,sha256=lORgSrVta3bkhUAaN8u8b5WqA_BTCyGQtpKAyerUBCY,11713
+registry/command/resource.py,sha256=5HgGO8c_AyNk1cUt_Yjp6FF15p9I6c8NlLM1MRpH-Nk,34026
+registry/command/resource_deploy.py,sha256=zxL6trDljFH35BvCai6Waa1U-y2kNJwpisvHBDPUAcA,11713
 registry/constants.py,sha256=ecEfQNxS1rMc8h3btS-yWipb1VXKnJRbdkeCRepgwWI,1485
+registry/data/publishing/AccessTypeEnum.py,sha256=-ahglQhv9F1wLgdwwO9y0osb4sp3RQ304yMeFD0S68g,114
+registry/data/publishing/Artifact.py,sha256=GSlN0joVFQM7I49IWu98U9xEgQVY0tn8qRBWlf6vDUk,5242
+registry/data/publishing/ArtifactBatch.py,sha256=j6dXKXnoT7egZXncolDvs-EfiLnGK1bf9jj-YNMpJa4,6230
+registry/data/publishing/ArtifactToCollectionRequest.py,sha256=lCpQz9r5yUgopWJgYDQnGeRTP97p9IJyp2wFq12ooaU,4473
+registry/data/publishing/ArtifactType.py,sha256=LEHnJnxA6bhNWfqdK0jBz4XUqQ2wl7z7_XDch9c_L0I,141
+registry/data/publishing/BatchPublishingRequest.py,sha256=zP7HerRNU24HyCIwpwVg-JH-ccW-6TLPbyqEXFXClXk,10846
+registry/data/publishing/ProductNamesEnum.py,sha256=zJv92ugScB8h78DpHYUvAYtuIcV-aGwCmfVsvipvH84,390
+registry/data/publishing/PublishingRequest.py,sha256=J-MiDftz3ocobcoriKP-JKQWME9INTAkZTOZSyEMaBk,10067
+registry/data/publishing/RequestStatus.py,sha256=Jq3gYldBXwGxu_UuxYr9X4z2Oi605GGdQkd_Bv3MDws,4213
+registry/data/publishing/Response.py,sha256=HOoZXNJjLgX00gaxkVHZe2Y_dVUkXbByMEITu9plZ4E,1976
+registry/data/publishing/StatusCode.py,sha256=pjlKDECycPA-Ea2lq_YFwuvMJ1HVeqd5iH0E695WGfQ,415
+registry/data/publishing/__init__.py,sha256=FbvDHkzR9lkwJVECKCr5pgxILMHfumFBx16QzPNHu1U,46
 registry/environ.py,sha256=lx2w2nDCXjxlUjvgzNd4-Ck6Tp1S62v5f1ayS6ljN1E,681
 registry/errors.py,sha256=def4Wt2pE7u1Yu39b1omZVzQDPZNf5dwazocqe8a1hg,1135
 registry/printer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
 registry/printer/artifact_deploy.py,sha256=Ypos29Bc7UTo7r6iMbq7L7EPjtHyXULLTiivOdlG1DU,3112
 registry/printer/chart.py,sha256=LO7M5ALHhCvDCvnUUdPklIKz7o1eDttkKYcdkMRk0DU,9767
 registry/printer/collection.py,sha256=FYRbOewWZOKkUm9P8i-1NLNC2HxguawSf-xWwTiUTWQ,9148
-registry/printer/csp.py,sha256=K1hBJQ24fV_193fi8-yENUJZxx9UCYyYV-lZFCVShF8,5752
+registry/printer/csp.py,sha256=ZoHaLPyZeEb2i3GhNx5W_rVX_luTUirKLCuYnUa-1YY,5752
 registry/printer/image.py,sha256=KhERd7lCDdZT1SAZjVLGX3kSD4I3KPyKCrTTbIY2cKg,18115
 registry/printer/label_set.py,sha256=_zZm5hIkioCYIXJWl9CZXZxA1ZDDDpJQ9VdSMvXGQYk,4177
 registry/printer/model.py,sha256=LyCh3jLwPDkQKatt93-qjTbeXY6mPBdeBfx8gKDAIe0,13778
 registry/printer/playground.py,sha256=h5UEVdYx17AbxipxzHWumfwU0UJ6LQR1qdVmrDFqOgE,2247
 registry/printer/resource.py,sha256=cjCBj0rlcUQ0tP9g09fHiKrLu5h-IL7X_6hTiVQTg7g,15141
 registry/transformer/__init__.py,sha256=jb__AFq1iuEdCnnUX8uoc9RTm1LUhwi1GB2CH3YB_lc,476
-registry/transformer/chart.py,sha256=xh9_yZG0Y1yzxdrsMJRUpWr6tohHB24mwHy4ZwYx0r0,1024
-registry/transformer/collection.py,sha256=wUqbxy8u3kynskmV7FQ3bSt63m4_Ceo_YOSmw0YDbao,932
-registry/transformer/image.py,sha256=1FCvT2BQMgxcxFLgHq7geSiJGglrG2eAeXYKH11Cnw0,907
-registry/transformer/model.py,sha256=gqgOpeUCdHWXEwLYKXJdeiGayBTwYqm_ngiVcBCZyqY,907
-registry/transformer/model_script.py,sha256=U8f2W8eMu3ForWq8HE-zU1gfYAcXIn-fYYKrOCheUdk,951
-ngcsdk-3.41.4.dist-info/METADATA,sha256=j0wSAAug7pSxRJbFeOdvs8N3E_oWR7zVDJFll3T03Jg,1959
-ngcsdk-3.41.4.dist-info/WHEEL,sha256=Zb28QaM1gQi8f4VCBhsUklF61CTlNYfs9YAZn-TOGFk,88
-ngcsdk-3.41.4.dist-info/entry_points.txt,sha256=Au_y9DMn0FYOF_s-yPzRiD3lPWuO4zp93PCMEWF9uTE,83
-ngcsdk-3.41.4.dist-info/RECORD,,
+registry/transformer/chart.py,sha256=wPB2485HuREbVCOhpTXUTEDcIcVkgaCRVtmCkFqp3O4,1024
+registry/transformer/collection.py,sha256=Lii1VbBv9fS9uQ12PHoL_6QlqkyfgPdA-4bEodlSips,932
+registry/transformer/image.py,sha256=pvlF7UMyUjthfw_2jm9RJFjDR6AwdXdqToN4hE4dNbA,907
+registry/transformer/model.py,sha256=uuqcJZGhI2mw9xh3RSOxzXsIvr9LawyqgAMh9ZaL_Ng,907
+registry/transformer/model_script.py,sha256=JqWAUF2yuuC1VzlbjxVozcgr_6RROorKxE32R9-YVxE,951
+ngcsdk-3.42.0.dist-info/METADATA,sha256=g-tUrTMR8jiXvVk-Y5HYdpRkob6E0AfIFTQJ7zR5Cwg,5722
+ngcsdk-3.42.0.dist-info/WHEEL,sha256=Zb28QaM1gQi8f4VCBhsUklF61CTlNYfs9YAZn-TOGFk,88
+ngcsdk-3.42.0.dist-info/entry_points.txt,sha256=Au_y9DMn0FYOF_s-yPzRiD3lPWuO4zp93PCMEWF9uTE,83
+ngcsdk-3.42.0.dist-info/RECORD,,
```

